

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="2025年10月02日 08:32发言人   00:00I guess one thing I and the rest of the staff request is that you, whenever you have a question, you first read the book and then you re-read the assignment, and you maybe">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解计算机系统 003-Bits,Bytes,andInteger">
<meta property="og:url" content="http://example.com/2025/10/12/15213-003/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="2025年10月02日 08:32发言人   00:00I guess one thing I and the rest of the staff request is that you, whenever you have a question, you first read the book and then you re-read the assignment, and you maybe">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-12T02:00:02.000Z">
<meta property="article:modified_time" content="2025-10-25T05:03:39.693Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>深入理解计算机系统 003-Bits,Bytes,andInteger - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="深入理解计算机系统 003-Bits,Bytes,andInteger"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-12 10:00" pubdate>
          2025年10月12日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          14k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          121 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">深入理解计算机系统 003-Bits,Bytes,andInteger</h1>
            
            
              <div class="markdown-body">
                
                <p>2025年10月02日 08:32<br>发言人   00:00<br>I guess one thing I and the rest of the staff request is that you, whenever you have a question, you first read the book and then you re-read the assignment, and you maybe reread it again. And then you ask us, because a lot of the questions we’re getting are ones where we just say, look at this page of the book, look at this paragraph, the assignment, look at this part of the file that you were given. And so, I mean, there’s a lot of stuff. And I understand how sometimes it’s easy to miss things, not saying don’t ever ask questions, but just before you ask your questions, try and figure out if I really sort of come through the resources I have available to see if the answer to my question can be found there. So anyways, enjoy the lab.<br>我猜我和其他员工要求的一件事是，每当你有问题时，先读这本书，然后再读一遍任务，也许再读一遍。然后你问我们，因为我们得到的很多问题都是这样的: 看看书的这一页，看看这一段，看看你被分配的文件的这一部分。所以，我的意思是，有很多东西。我理解有时候很容易错过事情，不是说永远不要问问题，但在你问问题之前，试着弄清楚我是否真的通过现有的资源来找到我问题的答案。所以无论如何，享受这个实验室。</p>
<span id="more"></span>

<p>发言人   00:55<br>So today is sort a second part of a two part lecture on integers and integer arithmetic.<br>今天是关于整数和整数算术的两部分讲座的第二部分。</p>
<p>发言人   01:02<br>Last time we looked at representations about how bit patterns can be interpreted as either unsigned numbers, meaning they range between 0 and 2 to the word size -1, or as twos complement numbers, which is the most usual way to represent what are sometimes called sine numbers, ones that can be either negative or positive. And by the way, there are other ways to represent sign numbers out there. Tooth complement is so overwhelmingly the most used system that that’s what we concentrate on today. What we’ll do is now go beyond the representations of these values to talk about arithmetic operations on them and some of their properties. And what we’ll do in general is talk about the unsigned case, which is in some ways easier to understand and more intuitive. And then talk about the two’s complement case.<br>上次我们看了关于位模式如何被解释为无符号数字的表示，这意味着它们的范围在0和2之间，或者作为二进制补码数字，这是表示有时被称为正弦数字的最常用方法。可以是负面的也可以是正面的。顺便说一下，还有其他的方法来表示符号数字。牙齿补足是绝大多数最常用的系统，这就是我们今天关注的重点。我们现在要做的是超越这些值的表示，讨论对它们的算术运算和它们的一些属性。一般来说，我们会谈论未签名的情况，这种情况在某些方面更容易理解，也更直观。然后谈论两者的补充情况。</p>
<p>发言人   02:03<br>So the basic rule on this is if you take two numbers that range between up to the maximum value of an unsigned number and you add them, then in principle, you might need to get an extra bit to represent that sum If you want to represent the true sum, the sort of integer sum of those two numbers, because you’re doubling it. And unfortunately, we can’t just go out and add more bits to your computer indefinitely. So we just stop it at some point and say, well, whatever happen to be in that sort of next over bit position? We’re just going to drop it and pretend it doesn’t exist and say that the result of addition is just whatever the W bit pattern you get if you only consider the first w bits out of it with no warning, no messages, no error or anything. This is just it happens silently.<br>因此，基本规则是，如果您将两个范围在无符号数字最大值之间的数字相加，那么原则上，如果您想表示真实的总和，您可能需要获得额外的位来表示该总和。这两个数字的整数和，因为你正在加倍它。不幸的是，我们不能无限制地向您的计算机中添加更多的位。所以我们只是在某个时候停止它，然后说，好吧，无论发生在那种下一个比特位置的是什么？我们只是要放下它，假装它不存在，并说如果你只考虑其中的前W位，而没有警告，没有消息，没有错误或任何东西，那么加法的结果就是你得到的w位模式。这只是静静地发生的事情。</p>
<p>发言人   03:05<br>For to complement this is not such a hard thing to understand. It can be thought of as just modular arithmetic computing modulo the two to the word size. So I’m going to use some examples. And this time I’ve got them worked out a little more carefully, won’t get mixed up as much, and we’ll use a word size of 4 here. And as I mentioned last time, it really helps with this to do the examples with small word sizes to get your intuition for it, rather than trying to write out 30 two-two bit numbers, 60 two-four bit numbers, or something like that.<br>因为补充这一点并不难理解。它可以被看作是模块化的算术计算，将两者取模为单词大小。所以我将使用一些例子。这次我让他们更仔细地制定，不会混淆太多，我们这里将使用单词大小为4。正如我上次提到的，用小字大小的例子来获得你的直觉确实有帮助，而不是试图写出30个2-2位数字，60个2-4位数字或类似的东西。</p>
<p>发言人   03:45<br>So if you think about in the unsigned case. A 4 b number. Means that it will range between 0 and 2 to the 4th -1 or 15. And so let’s just do a few examples of cases where it overflows. So if you add 13 to 5.<br>所以如果你考虑未签名的情况。一个4 b数字。意味着它的范围将在0到2到第4个1或15之间。所以让我们举几个它溢出的例子。所以如果你把13加到5。</p>
<p>发言人   04:21<br>First of all, you know, I assume already that you just add binary numbers the way you learned in school, just doing carries and so forth, except it’s all module 2. So this is zero carry 1, 1, 0 carry 1, 0 carry one. So in principle, to represent the sum, which is this is 5, So to represent 18, you need 5 b, not 4. But we’re just going to conveniently drop that number and say that this is actually two, which of course, is what 18 modules 16 is. So the unsigned case is really pretty straightforward.<br>首先，你知道，我已经假设你只是像在学校学到的那样添加二进制数，只是做进位等等，除了所有的模块2。所以这是零进位1，1，0进位1，0进位1。所以原则上，要表示总和，这是5，所以要表示18，你需要5 b，而不是4。但我们只是方便地放弃这个数字，并说这实际上是2，这当然是18个模块16的意思。所以未签名的案件真的非常简单。</p>
<p>发言人   05:13<br>And we can visualize this in this picture is in the book too, by saying if you are representing.<br>我们可以想象这张图片也在书中，通过说明你是否在代表。</p>
<p>发言人   05:21<br>On the x and y axis, what they call u and v are values between 0 and 15, the range of possible unsigned numbers. And if we were to add those, we could get a sum that’s up to as much as 30. Which would in principle, require 5 b to represent, but what we’ll do is we’ll just by dropping that most significant bit, what we do is sort of create a cliff that when you roll over from 15 to 16, instead, it drops all the way down to 0. And that’s referred to as an overflow. And then from there, we’ll build up to the maximum value here will be 14, which is 30 -16. So what we’ve done is basically, as this picture shows, when we overflow, we effectively subtract off 2 to the w from the sum and keep it within the representable range of w bit numbers.<br>在x轴和y轴上，它们所称的u和v是0到15之间的值，这是可能的无符号数字的范围。如果我们将这些相加，我们可以得到最多30的总和。原则上，需要5个b来表示，但我们要做的是通过放下最高有效位，我们所做的是创建一个悬崖，当你从15翻转到16时，它会一直下降到0。这被称为溢出。然后从那里开始，我们将积累到这里的最大值为14，即30 -16。所以我们所做的基本上是，正如这张图片所示，当我们溢出时，我们有效地从总和中减去2到w，并将其保持在w位数字的可表示范围内。</p>
<p>发言人   06:21<br>So that’s unsigned two comple The first thing I want to convince you of is that two’s complement edition looks just like regular edition. In other words, I can perform subtraction, addition, subtraction of numbers by using this two’s complement representation for negative numbers. So let me just show you some examples of that.<br>所以这是未签名的两个comple，我想说服你的第一件事是，两个的补充版看起来就像普通版一样。换句话说，我可以通过使用这两个负数的补码表示来执行数字的减法，加法，减法。让我给你看一些例子。</p>
<p>发言人   06:57<br>So first of all, remember that what range of values, what’s the smallest number that could be represented with a 4 b? The most negative number, 4 b, two’s complement number -8. And the largest plus seven, thank you. So let’s just do some examples if we took.<br>首先，请记住值的范围是什么，可以用4 b表示的最小数字是什么？最负数4 b，2的补码数-8。还有最大的加七个，谢谢。所以，如果我们采取行动，让我们做一些例子。</p>
<p>发言人   07:27<br>This number 1, 1 0 1 as a T’s complement number is -3. And we add it to 5. We’ll get what we got before.<br>这个数字1、0作为T的补数是-3。我们把它加到5上。我们会得到我们之前得到的。</p>
<p>发言人   07:52<br>And we’re going to ignore whatever carry bit it is. And so the result is 2. And lo and behold, that’s what 5 -3 is. So it seems like magic because it is. And that’s part of the reason why I choose complement is sort of the most commonly used way of representing S numbers. The same hardware, the same algorithms that are used for doing addition. It works for either unsigned or two S complement numbers.<br>我们将忽略它的任何携带位。所以结果是2。瞧，这就是5 -3。所以它看起来像魔法，因为它就是。这就是我选择补码是表示S数最常用方式的部分原因。用于加法的相同硬件和相同算法。它适用于无符号或两个补码数。</p>
<p>发言人   08:32<br>And this works as well. Just to show you, if the overflow goes, the resulting sum goes the other way. So if I have -3, -5, and plus three, and I add those together.<br>这也行得通。只是为了向您展示，如果溢出消失，结果总和会相反。所以，如果我有-3、-5和 + 3，我把它们加在一起。</p>
<p>发言人   09:04<br>I’ll get 1, 1, 1, 0, which is -2. So again, if you use the patterns for the same rule for addition as you do with the unsigned case, you’ll get two complement arithmetic. So let’s look at a few cases where the two S complement overflows.<br>我会得到1，1，1，0，即-2。因此，如果您将模式用于与无符号情况相同的加法规则，您将得到两个补码算术。因此，让我们来看一些两个S补码溢出的情况。</p>
<p>发言人   09:36<br>So if we take three.<br>那么，如果我们拿三个。</p>
<p>发言人   09:46<br>And.<br>而且。</p>
<p>发言人   09:54<br>Minus six. And we add them together. We’ll get 1, 1, 1, 0. We’re going to drop off the carry, which is what, 7? So we’ve added two negative numbers, and it’s become positive. And that’s referred to as a negative overflow.<br>-6。然后我们把它们加在一起。我们会得到1，1，1，0。我们要把东西放下，什么是7？所以我们添加了两个负数，它变成了正数。这被称为负溢出。</p>
<p>发言人   10:24<br>And the reason, of course, is the number -9 can’t be represented in a 4 b chooses complement number. It overflowed. You’ll notice that the plus seven, of course, differs from -9 by 16, and that’s not next. And then going the other direction, if we had two large positive numbers. So if we had 7. And 5?<br>当然，原因是数字-9不能在4 b选择补码数字中表示。它溢出了。你会注意到，加7当然不同于-9乘16，这不是下一个。如果我们有两个大的正数，然后朝着另一个方向前进。如果我们有7个。And 5?</p>
<p>发言人   11:10<br>We’ll get -6. So this was 7 plus 5. Is -4? And so this is referred to as positive overflow. We’ve taken two.<br>我们会得到-6。所以这是7加5。是-4吗？因此这被称为正溢出。我们已经拿了两个。</p>
<p>发言人   11:38<br>Positive numbers and added them together and gotten a negative result. And you can see this, by the way, if you think about this addition, we took 7 and 5 would be 12. And this is the bit level representation of 12. It’s just that because this is now the sine bit, we think of that as -4, not positive 12. And so that’s the idea of two’s complement overflow. And you can see there’s two different cases here. One is where number the. Sum was, if we looked at the true sum, the number that you’d get, for example, 12 is too big to represent. And so when we think of that as a twos complement number, it becomes now a negative number. So that’s positive overflow.<br>将正数相加得到否定的结果。顺便说一下，如果你考虑这个加法，我们拿了7和5，就是12。这是12的位级表示。只是因为这现在是正弦位，我们认为那是-4，而不是正的12。这就是2的补码溢出的想法。你可以看到这里有两种不同的情况。一个是数字所在的地方。总和是，如果我们看看真正的总和，你得到的数字，例如12太大了，无法代表。所以当我们把它看作是一个二零补数时，它现在就变成了一个负数。所以这是正溢出。</p>
<p>发言人   12:33<br>Similarly, if we have two negative numbers and we add them together so that the sum is too small, too negative to represent, then those become positive numbers. That’s negative overflow. And you can see that in this picture, the same idea as before, except there’s three regions. This is the, and by the way, now you’ll see our numbers range between -8 and positive c, and the sum will also range between -8 and positive 7. But there’s these three regions. One is where everything’s fine, it’s within the representable range, the other is where the sum was so far toward the negative side that it becomes positive, or where it’s so high on the positive side that it becomes negative. And so part of data web, you’ll learn to understand these quite in quite precisely.<br>同样地，如果我们有两个负数，我们把它们相加，使得总和太小、太负而无法表示，那么它们就变成正数。这就是负面溢出。你可以看到这张图片和之前的想法一样，只是有三个区域。顺便说一句，现在你会看到我们的数字范围在-8和正c之间，总和也在-8和正7之间。但是有这三个地区。一种是一切都很好，在可表示的范围内，另一种是总和远远接近负值而变成正值，或者正值太高而变成负值。因此，作为数据网络的一部分，你将学会非常精确地理解这些。</p>
<p>发言人   13:44<br>But that’s the idea. And it’s a little bit counterintuitive to say. So somehow I can accept the idea that modular arithmetic for unsigned numbers, there’s some sort of mathematical beauty to modular arithmetic. And this just looks like kind of useless from a. Operational characteristic. But it’s the way it is. We’re stuck with it. And multiplication is basically the same idea. In fact, all the operations are basically the same idea.<br>但这就是我的想法。这样说有点违反直觉。因此，我可以接受这样的想法，即无符号数的模块化算术，具有某种数学美感。而这看起来只是有点没用。运营特点。但事情就是这样。我们被它卡住了。乘法基本上是相同的思想。事实上，所有的操作基本上都是相同的想法。</p>
<p>发言人   14:23<br>If you can’t represent it within the word size, you just take the lower w bits. So all this complicated notation here is just a way of saying, in principle, if you take two w bit numbers and multiply them together, you need the result may require as much as two times w bits to represent before addition. It’s w plus 1 multiplication. You actually have to double because you’re potentially squaring the largest number. And so again, we don’t want to just keep doubling our word size over and over again, we’ll run out of bits very quickly that way, and so we just truncate it at w bits and.<br>如果您无法在单词大小内表示它，则只需采用较低的w位。所以这里所有这些复杂的符号只是一种说法，原则上，如果你把两个w位数字相乘，你需要的结果可能需要两倍的w位才能表示出来。这是w加1乘。你实际上必须翻倍，因为你可能要平方最大的数字。所以再次强调，我们不想一遍又一遍地让我们的字数翻倍，这样我们很快就会用完位数，所以我们只需要将其截断为w位。</p>
<p>发言人   15:14<br>For the unsettling, it’s, again, modular arithmetic. It’s something that you can kind of understand and believe, but. And so again, let’s just do a few examples. And I won’t try workout. Multiplying in binary is like multiplying in decimal. You do a big table and it takes a long time. So I won’t try to do that. But let me just show a few examples.<br>令人不安的是，这是模块化算术。这是你可以理解和相信的事情，但是。再说一遍，让我们举几个例子。我不会尝试锻炼。二进制乘法就像十进制乘法。你做一张大桌子，需要很长时间。所以我不会尝试这样做。但让我举几个例子。</p>
<p>发言人   15:54<br>So if I multiply three times 5 is of course, equal to 15. And in an unsigned number, I can represent that. So, that’s OK. But if I multiply five times 5.<br>所以，如果我乘三乘5，当然等于15。在一个无符号的数字中，我可以表示它。所以，没关系。但是如果我乘五次5。</p>
<p>发言人   16:23<br>Then that would have a representation. If I were to think about it, as possibly as many as 8 b, it would have a representation.<br>那么就会有一个代表。如果我考虑一下，可能多达8个b，它将有一个代表性。</p>
<p>发言人   16:39<br>With an extra bit. And I’m going to throw this part away. And so I’d call that 9, which of course, is equal to 25 mod 16.<br>多一点。我要把这部分扔掉。所以我称之为9，当然，它等于25 mod 16。</p>
<p>发言人   16:56<br>And so that’s the general idea of it is regardless of whatever is in this upper part of the word, the product. I’m just going to discard that and only look at the lower one. And life gets a little more interesting with the two’s complement case. So let’s look at what that does. And the answer is even a little bit stranger in that you not only trunk throw away whatever high order bits happen to be there, but whatever bit gets left in this position will determine whether it’s a positive or a negative result, even though completely irrespective of the signs of the original two operands. So that can make you go all over the place.<br>这就是它的一般思想，无论这个词的上部是什么，产品。我只是打算放弃那个，只看下面的那个。随着两者的补充情况，生活变得更有趣了。让我们看看它的作用。答案甚至有点奇怪，因为你不仅扔掉了碰巧存在的任何高阶位，而且在这个位置留下的任何位都将决定它是正的还是负的结果，即使完全不考虑原始两个操作数的符号。这样可以让你走遍所有的地方。</p>
<p>发言人   18:03<br>So if we had five times 4 or 20. That would be represented. In this 8 b form.<br>如果我们有五个乘以4或20。这将被代表。在这个8 B形式中。</p>
<p>发言人   18:24<br>Like so. And we’d just call that four, right? Because we’re throwing this away. But if we did five times 5.<br>就像这样。我们就称它为四，对吧？因为我们要把这个扔掉。但是如果我们做了五次5。</p>
<p>发言人   18:40<br>As we saw before, that’s represented like this.<br>正如我们之前看到的，这就代表了这样。</p>
<p>发言人   18:51<br>And that? Now becomes, so we’re throwing away this and this becomes our sine bit. So the result is -8 plus 1 or -7. So you see, this is similar to an example we showed at the beginning of the first lecture, that you can have two positive numbers and multiply them and get a negative result because of the sort of quirks of this overflow question there.<br>那个呢？现在变成了，所以我们扔掉了这个，这变成了我们的正弦位。所以结果是-8加1或者-7。所以你看，这类似于我们在第一节课开始时展示的例子，你可以有两个正数，然后将它们相乘得到负面结果，因为这个溢出问题的怪癖。</p>
<p>发言人   19:26<br>Oh I’m just taking 25 and writing it in binary. Yeah, if you want to, you know, you start with the two numbers. I’m not going to do well. Actually, this one’s an easy one. There’s a trick for this. If you want to multiply a number by a power of two, we’re going to show that later. You just shift it left by two positions.<br>哦，我只是用二进制写25。是的，如果你想，你知道，你可以从这两个数字开始。我不会做得很好。实际上，这个很容易。这是有诀窍的。如果你想将一个数乘以2的幂，我们稍后会展示。你只需要将它向左移动两个位置。</p>
<p>发言人   19:56<br>So that one’s an easy one. Otherwise, you have to write out the table and sum all the results and all that stuff. I prefer to let computers do that.<br>所以这是一个容易的。否则，你必须写出表格并汇总所有结果和所有这些内容。我更喜欢让计算机来做这件事。</p>
<p>发言人   20:15<br>And again, the two complement stuff. One interesting feature is that it works for negative numbers too. If you do this trick of throwing away the high order bits, and you’ll have overflow cases like before because you’re throwing away information. The lower bits, if the number is representable, you’ll get the right result. So let me just demonstrate to that to you. So -3. But you remember this is equivalent to 13 as an unsigned number and. This is -2, which is equivalent to 14 as an unsigned number. So now if we multiply 13 times 14, you get 182. And that has a hex representation of B6.<br>再次，这两个补充的东西。一个有趣的特性是它也适用于负数。如果你使用这种丢弃高阶比特的技巧，就会出现像以前一样的溢出情况，因为你正在丢弃信息。在较低的位，如果数字是可表示的，你将得到正确的结果。让我向你们演示一下。所以-3。但你记得这相当于13作为一个无符号数。这是-2，相当于14作为一个无符号数。所以现在如果我们乘13乘14，你得到182。并且它的十六进制表示为b6。</p>
<p>发言人   21:30<br>And so just looking at the low order, 4 b are 0, 1, 1, 0 is 6. And indeed, that’s negative three times -2 is 6. So the point being, and I’m waving my hands here because I don’t want to go through all the details, but to complement multiplication also gives you, if you can do it using the exact same rules. And as you do for unsigned multiplication, same hardware, I should mention that there are instructions in the computer in ways that you can get the upper word of a multiplication 2. And those the bit patterns are different depending on whether it’s treated as two complement number versus unsigned different instructions for doing that computation, But 99% of the time or more, you just looking at this lower part of the product. And that’s the same whether it’s a tooth complement or an unsigned. And it handles negative numbers, positive, but it has these overflow characteristics.<br>所以仅仅看低阶，4 b是0，1，1，0是6。事实上，这是负数的三倍 – 2是6。所以重点是，我在这里挥手，因为我不想浏览所有的细节，但是如果你能使用完全相同的规则，补乘也会给你带来帮助。正如你对无符号乘法所做的那样，同样的硬件，我应该提到计算机中有一些指令，可以获得乘法2的上位单词。而这些位模式取决于它是否被视为两个补码数和无符号不同的指令来进行计算，但99% 以上的情况下，你只是看到乘积的这个下部。无论是牙齿补全还是无符号牙齿，都是一样的。它处理负数、正数，但它具有这些溢出特性。</p>
<p>发言人   22:45<br>So as I was talking about, there’s a trick we can do for multiplying by a power of two, which is just to shift the number to the left. And you’ll often see that when you have in your code, I want to multiply some number by 4. You’ll write in your C code. If you look at the assembly code, you’ll see that what the compiler generated just says. I’ll just shift it left by two. So in general, and you can see why this is true. By the way, if you think of the number. As the sum of the bits?<br>所以正如我所说的，我们可以做一个技巧来乘以2的幂，这只是将数字向左移动。你经常会看到，当你在代码中写代码时，我想把某个数字乘以4。你将用你的C代码编写。如果你查看汇编代码，你会发现编译器生成的代码只是说出来的。我会把它向左移动两点。总的来说，你可以明白为什么这是真的。顺便说一下，如果你想到数字。作为比特数的总和？</p>
<p>发言人   23:35<br>Where x sub I is the ith bit and x is the number it represents. If I shift everything left by two, what I’m effectively doing is increasing their weight by that number of positions. So let’s just shift by one. If I shift everything to the left by one.<br>其中，x sub I是第I个位，x是它代表的数字。如果我将所有东西左移两，我有效地做的是将它们的权重增加那么多个位置。那我们就转一个吧。如果我把所有东西向左移动一个。</p>
<p>发言人   24:02<br>Which we write like this in C 2, 2 less symbols. It’s like taking that sum, but now weighting the bits by 2 to the I plus one by one more. And of course, that’s equal to twice what the original sum was. And so we doubled the number. And that works. Even if you shift things so you lose some bits, they shift off to the left. All you’re doing is the way multiplication works anyhow, of truncating to W bit product.<br>我们这样用c2写，少了2个符号。这就像取那个总和，但现在将比特加权2到I加一加一。当然，这等于原始总和的两倍。所以我们将数字翻倍了。这行得通。即使你移动了一些东西，丢失了一些位，它们也会向左移动。你所做的只是乘法的工作方式，即截断为W位乘积。</p>
<p>发言人   24:48<br>You’ll see this, as I mentioned, quite often in compiled code, machine level code, that they’re doing shifts where you might expect them to be doing multiplications. And the reason for that is an optimization is historically, the multiplication instruction took a lot longer than a shift instruction, say one clock cycle to do a shift. And it used to be like 11, 1230 clock cycles to do a multiplication. Nowadays, like on computers, we use the shark machines, it only takes three clock cycles to do multiplication because they added a lot of hardware to do that. But three clock cycles is still more time than one. And so when you can get away with a shift, it’s generally a better idea. And the compiler has its own kind of judgment calls on when is it more efficient to substitute one operation for another?<br>正如我所提到的，在编译代码中，机器级别的代码中，你会经常看到这一点，它们正在进行移位，你可能期望它们进行乘法运算。而这样做的原因是从历史上看，乘法指令比移位指令花费了更长的时间，比如一个时钟周期来进行移位。它曾经需要大约11，1230个时钟周期来进行乘法运算。现在，就像在计算机上一样，我们使用鲨鱼机，只需要三个时钟周期就可以进行乘法，因为他们添加了很多硬件来实现这一点。但三个时钟周期仍然比一个时间更长。所以当你可以逃脱轮班时，通常是一个更好的主意。编译器有自己的判断要求，何时用一种操作代替另一种操作更有效？</p>
<p>发言人   25:53<br>Did I lose ground here?<br>我在这里失去了基础吗？</p>
<p>发言人   26:04<br>So the idea then, if we want to multiply something by two to the k, we just shift it left by k bit.<br>所以这个想法是，如果我们想将某物乘以二得到k，我们只需要将其向左移动k位。</p>
<p>发言人   26:21<br>It turns out that the same almost works for dividing by two as well, that if you want to divide something by a power of two, you can shift it right by in the same general idea. Only thing that becomes a little bit quirky is, well, what if the number you have is not actually divisible by that power of two?<br>事实证明，同样的方法几乎也适用于除以二，如果你想将某物除以二的幂，你可以按照同样的一般想法将其向右移动。唯一有点古怪的是，如果你拥有的数字实际上不能被2的幂整除呢？</p>
<p>发言人   26:52<br>So for example, if we had the number 0, 1. I want. I’m gonna use this.<br>例如，如果我们有数字0，1。我想要。我要用这个。</p>
<p>发言人   27:10<br>So that’s 6. So if we shift it right by one, we’ll get 0, 0, 1, 0. One, 1, thank you, which is 3. And that’s six divided by 2 is 3. If we shift that again. We’ll get one. But of course, you know that 3&#x2F;2 are 1.5. The rule on integer division is you round it down, round it towards 0, and so that goes to one. So this is what the unsigned case works fine. The signed case, which I don’t have a slide for.<br>那就是6。所以如果我们把它向右移动一，我们会得到0，0，1，0。1，1，谢谢，也就是3。6除以2就是3。如果我们再次转移。我们会得到一个。但是当然，你知道3&#x2F;2是1.5。整数除法的规则是你向下舍入，向0舍入，这样就得到1。所以这就是未签名案例运作良好的地方。签名的案子，我没有幻灯片。</p>
<p>发言人   28:07<br>It’s a little bit less pretty. Well, first of all, you notice if it’s a positive number, the shifting right is going to be the right thing, just as it is for unsigned. But let’s take a number that is.<br>它稍微不那么漂亮了。嗯，首先，你注意到如果它是一个正数，右移将是正确的事情，就像对无符号的情况一样。但让我们取一个数字。</p>
<p>发言人   28:29<br>Negative, so this is -6. Now, here’s where, remember I told you in the previous lecture, there’s two ways to do shifting. There’s logical shifting where you fill in with zeros, an arithmetic shifting where you fill in with ones. Guess where arithmetic shifting comes in this is it when you want to preserve the sine of a number while you’re dividing it by powers of 2. You want arithmetic shifts. So if we shift this by one, we’ll keep that sine bit and then copy the other ones over. So we just preserved this bit here and copied the other ones over. And this is -3. And so that’s good. But now if we shift again arithmetically. Well, get what?<br>这是负数，所以这是-6。现在，记住我在上一节课中告诉过你，这里有两种转移的方法。有逻辑移位，你用零填充，算术移位，你用一填充。猜猜算术移位的作用是什么？当你想保持一个数的正弦，同时将它除以2的幂时。你想要算术移位。所以如果我们将其移动一个，我们将保留那个正弦位，然后复制其他位。所以我们只是保留了这个位，并复制了其他的位。这是-3。这很好。但是现在如果我们再次算术转移。好吧，明白什么？</p>
<p>发言人   29:43<br>Nice too. I can see you guys need to know how to negate numbers, right? You don’t know that, so I’ll show you in a second. So here is a little bit problematic that we shifted. We want to divide by two, but the rule should be the same, that you should round toward 0. And what this is doing is it’s rounding toward minus infinity. It’s rounding toward a more negative number than the true thing. And so there’s a cute little trick that says, before you shift, before you divide by a power of two, before you do the shift, you should add a bias.<br>也不错。我明白你们需要知道如何否定数字，对吧？你不知道，所以我马上给你看。所以我们转移了一点问题。我们想要除以二，但规则应该是相同的，你应该四舍入到0。它所做的是向负无穷大四舍五入。它向一个比真实数字更负的四舍五入。所以有一个可爱的小技巧说，在你移动之前，在你除以2的幂之前，在你移动之前，你应该添加一个偏差。</p>
<p>发言人   30:34<br>Which, in this case, would just be one. And I’ll tell you where that comes from. And so if we add those numbers together, we’ll get 1, 1, 1, 0. And now when we do the shift on that, we’ll get 1, 1, 1, 1, and that’s -1. So there’s a trick.<br>在这种情况下，只有一个。我会告诉你这是从哪里来的。所以如果我们把这些数字相加，我们会得到1，1，1，0。现在当我们在上面进行转换时，我们会得到1，1，1，那就是-1。所以有一个小技巧。</p>
<p>发言人   30:58<br>And again, you’ll see the compiler doing this where you have in your code divide by 16, and it’ll add a bias. Then it will do a right shift instead of calling division. And by the way, division really, really is slow, even on a modern computer like what you have the shark machines, it takes 30 plus clock cycles. So anytime the compiler can avoid figure out a trick that does it with shifting and tweaking things around, it will.<br>再次，你会看到编译器在你的代码除以16的地方这样做，它会增加一个偏差。那么它将进行向右移动，而不是调用部门。顺便说一下，除法确实很慢，即使在像鲨鱼机器这样的现代计算机上，也需要30多个时钟周期。因此，只要编译器能够避免想出转移和调整事物的技巧，它就会做到。</p>
<p>发言人   31:30<br>So I realize I should tell you, there’s a couple ways you can.<br>所以我意识到我应该告诉你，有几种方法可以。</p>
<p>发言人   31:38<br>Negate a number that are handy to know if you ever have to do it in your head or on paper. And the standard way is what’s called complement and increment. So this is how do I go from x to minus x? So if I have a number. And I want to negate it, whether it’s currently a negative number or it’s a positive number. The same trick works. What I’ll do is complement it, meaning I’ll flip all of the bits. And then I’ll add one to that.<br>否定一个数字，它很方便知道你是否曾经在脑海中或在纸上做过。标准方式是所谓的补足和递增。这就是我如何从x到-x？如果我有一个号码。我想否定它，无论它是目前的负数还是正数。同样的把戏行得通。我要做的是补充它，意思是我会翻转所有的位。然后我会再添加一个。</p>
<p>发言人   32:21<br>And do the regular sum. And so this is 6. And this is -6. So if you ever have to do it by hand, that’s the way to do it, complement and increment. And it goes the other way. You’ll see if I complement this.<br>并做常规的总和。所以这是6。这是-6。所以，如果你必须手工完成，那就是方法，补充和增加。它是另一种方式。你会看到我是否补充了这个。</p>
<p>发言人   32:46<br>And I increment. It. Back to my previous number. So that’s a trick. It’s pretty much only useful when you do things on the blackboard or when you have to solve a problem in data web.<br>和I递增。它。回到我之前的号码。所以这是个小把戏。它几乎只有当你在黑板上做事情或者在数据网络中解决问题时才有用。</p>
<p>发言人   33:15<br>Anyways, this idea of of doing shifting to the right to do power of two division, actually, that’s the whole justification for arithmetic shifting in the first place, which by the way, and see, there’s no fixed requirement for how shifting works in C for signed numbers, for unsigned. It has to be a logical shift. Sine numbers, the C standard says there’s no fixed definition. The reality is, on our machines, most machines, just about every machine out there, when it’s a sine number, it’s two’s complement. And when you do a shift, it will be an arithmetic shift.<br>无论如何，这种向右移动以进行两除法的幂的想法实际上，这首先是算术移位的理由，顺便说一下，对于有符号的数字，对于无符号的数字，没有固定的要求。这必须是一个合乎逻辑的转变。正弦数字，C标准说没有固定的定义。现实情况是，在我们的机器上，大多数机器，几乎每台机器上，当它是正弦数时，它是2的补码。当你做一个移位时，它将是一个算术移位。</p>
<p>发言人   34:09<br>So getting back to then summarizing this integer arithmetic, you see that, first of all, whether it’s signed or unsigned, the addition or multiplication operations are the same, whether it’s an unsigned number or two’s comple. And it works, the negative stuff works out as long as you don’t have an overflow. And you can end up with an overflow, only one type of overflow for unsigned and two types for signed numbers. But it’s not like they just overflow and generate random numbers, a pattern to result what they are and how they can be interpreted.<br>所以回到总结这个整数算术，你会看到，首先，无论它是有符号的还是无符号的，加法或乘法操作都是相同的，无论它是无符号的数字还是2的整数。它会起作用，只要你没有溢出，负面的东西就会起作用。并且您最终可能会导致溢出，对于无符号数字只有一种类型的溢出，对于有符号数字只有两种类型。但它们并不只是溢出并生成随机数，而是一种模式来导致它们的存在以及如何解释它们。</p>
<p>发言人   35:03<br>So I talked about this a little bit last time and gave this example similar to this, but let me go over it a little bit more. One thing you might think of, wow, if this unsigned and signed stuff gets so murky, and we saw some funny examples last time, maybe we should just banished unsigned numbers from the universe and OAO L two’s complutum. And that’s exactly the rule that was adopted. For example, in Java, they said, is this too weird? Let’s just say every number is two’s comple The only trick they did was they put in a triple right shift. Means logical shift? This is Java, this is not C?<br>所以我上次谈了一点这个，并给出了与此类似的例子，但让我再详细介绍一下。有一件事你可能会想到，哇，如果这个无符号和有符号的东西变得如此模糊，我们上次看到了一些有趣的例子，也许我们应该把无符号的数字从宇宙中驱逐出去。这正是采用的规则。例如，在Java中，他们说，这太奇怪了吗？我们只能说每个数字都是2的comple，他们唯一的技巧就是进行了三个右移。这意味着逻辑转变？这是Java，这不是C？</p>
<p>发言人   36:04<br>Whereas the double is arithmetic.<br>而双精度是算术的。</p>
<p>发言人   36:17<br>Because they realize there’s a lot of cute little times when you want to play tricks with things and you need that logical right shift. So that’s actually one approach. Or other more modern languages and C are saying it’s okay to have signed and unsigned, but we don’t want them sort of mysteriously being cast back and forth in ways that the programmer might not recognize. And so you have to explicitly do a cast rather than implicitly. And I think that’s the better approach. But C, as I mentioned, does this implicit casting.<br>因为他们意识到，当你想玩弄事物时，有很多可爱的小时候，你需要逻辑上的右移。这实际上是一种方法。或者其他更现代的语言，C语言和C语言都说有签名和无签名是可以的，但我们不希望它们以程序员可能无法识别的方式神秘地来回转换。所以你必须明确地进行强制转换，而不是隐式地进行。我认为这是更好的方法。但是，正如我所提到的，C会进行隐式转换。</p>
<p>发言人   36:52<br>And so, as we saw for last time, what happens with this program when you run it? To count down through an array, do you remember? Well, I, if it’s unsigned, what will happen with this test? It always succeeds. So the thing will be in an infinite loop. Actually, what will happen is it will try to access, I will go down to 0, and then it will wrap around to become the largest possible ensign number, which is probably way out of bounds. And it will give a memory error, but it won’t do what’s supposed to be.<br>所以，正如我们上次看到的，当你运行这个程序时会发生什么？通过一个数组倒数，你还记得吗？好的，我，如果它是无符号的，这个测试会发生什么？它总是成功的。所以这个东西将会处于一个无限循环中。实际上，它会尝试访问，我将下降到0，然后它将环绕成为最大的可能的标志数字，这可能超出了界限。它会产生记忆错误，但它不会做应该做的事情。</p>
<p>发言人   37:40<br>And as I mentioned before, these things, there a lot of sneaky ways this problem can show up in ways you might never think of. So for example, the operator size of is defined to say how big a particular data type is, it’s a very useful operator. Its return value is what’s called a size underscore t, which is defined to be a long unsigned number. And so if we just throw in a. Constant like this. Then this subtraction we have AI is now int, but size of is unsigned. And so it will cast that to be unsigned implicitly. And when you compare it to 0, you’ll have the same problem as before.<br>正如我之前提到的，这些事情，这个问题可能会以你可能从未想过的方式出现。例如，运算符的大小被定义为特定数据类型的大小，这是一个非常有用的运算符。它的返回值称为大小下划线t，它被定义为一个长的无符号数字。所以如果我们只是投入一个。像这样不断。那么我们得到的这个减法现在是int，但size是无符号的。因此它会隐式地将其强制转换为无符号。当你将其与0进行比较时，你将遇到与之前相同的问题。</p>
<p>发言人   38:31<br>So just to show you that these things can sneak in very tricky ways. So one way to do that then is just don’t use unsigned like and make sure if this is.<br>所以只是为了告诉你，这些东西可以以非常棘手的方式偷偷溜走。因此，一种方法是不要使用未签名的像，并确保这是否是这样。</p>
<p>发言人   38:48<br>A possible unsigned number. You cast it to sign. You make sure that this is recognized and signed. But there’s another way that actually, at least there’s a fellow over at the Software Engineering Institute named Robert Secord who has written the books that are considered the. The gold standard for how to write secure code. He works for this organization called the Computer Emergency Response Team, which is out there tracking down bad things going on in computer security. And one of the things he and others have done is to try and come up with standards so that people who write programs well avoid some of the pitfalls that make their programs vulnerable to security of flaws to attack.<br>可能的无符号数字。你投它来签名。你要确保这被识别和签名。但实际上还有另一种方式，至少有一位名叫罗伯特·塞科德的软件工程研究所的研究员写了被认为是最重要的书。如何编写安全代码的黄金标准。他在一个名为计算机应急响应团队的组织工作，该团队正在追踪计算机安全方面的不良事件。他和其他人所做的事情之一就是尝试制定标准，以便编写程序的人能够避免一些使他们的程序容易受到安全漏洞攻击的陷阱。</p>
<p>发言人   39:43<br>And so his recommended technique is when I first saw this, it was so counterintuitive to me, it hardly made sense, right? So you start, and again, this is all unsigned arithmetic, So I’m starting to count down, and my test is when I is less than count. So here’s the thing, I started off smaller than count, and it’s only being decremented. So when would this test ever fail? When it overflows, when it wraps around, when I goes from 0 and counts down to what would now be u max, this test will fail, which is exactly when you want it to stop.<br>所以他推荐的技巧是，当我第一次看到这个时，它对我来说是如此违反直觉，几乎没有感知，对吗？所以你开始，再一次，这都是无符号算术，所以我开始倒计时，我的测试是当我小于计数时。所以事情是这样的，我一开始比计数小，它只是被减少了。那么，这个测试什么时候会失败呢？当它溢出，当它包裹时，当I从0计数到现在的最大值时，这个测试将失败，这正是你想要它停止的时候。</p>
<p>发言人   40:31<br>And his observation is in c with sine numbers. There’s no guarantee on what happens with overflowing. As I said, most people just assume it’s going to be too’s compliment. But if you really want to be careful, you shouldn’t assume anything outside of the C standard. And if you’re trying to write secure code, it’s probably a good idea to be cautious. Be conservative.<br>他的观察结果是在c和正弦数字之间。无法保证溢出会发生什么。正如我所说，大多数人只是假设这将是对太的赞美。但如果你真的想小心，你不应该假设C标准之外的任何事情。如果你试图编写安全的代码，保持谨慎可能是个好主意。保守一点。</p>
<p>发言人   40:55<br>On the other hand, the C standard guarantees that unsigned arithmetic will be modular arithmetic. So it guarantees that if you subtract 1 from 0, you’ll get the largest number that could be represented. So it will be OK. And in fact, he recommends, instead of using unsigned, which is on our machines, just a 32 b value that you call it a size t, which is a 64 b value. And write your code the way that I showed you. So I’ve actually started doing this. And once you kind of get used to it, it’s an okay way to write code, but it’s very strange looking initially. One thing I’ll point out is.<br>另一方面，C标准保证无符号算术将是模算术。因此，它保证了如果你从0中减去1，你将得到可以表示的最大数字。所以会没事的。实际上，他建议不要使用我们机器上的无符号，而只使用32 b的值，你称之为大小t，这是64 b的值。并以我展示的方式编写您的代码。所以我实际上已经开始这样做了。一旦你习惯了它，这是编写代码的一种不错的方式，但一开始看起来很奇怪。我要指出的一件事是。</p>
<p>发言人   41:47<br>What would happen if count were a sine number, an int, and it? Was less than 0? What would happen here? So I less than count what would happen.<br>如果count是一个正弦数，一个int数，它会发生什么？小于0？这里会发生什么？所以我数不清会发生什么。</p>
<p>发言人   42:14<br>And so it become a very large positive number. And this test would almost certainly succeed. So you have the same. This code doesn’t avoid the pitfall, it just shifts it to saying you better make sure you don’t test for this case beforehand before you get into it.<br>因此它成为一个非常大的正数。这个测试几乎肯定会成功。所以你有相同的。这段代码并不能避免这个陷阱，它只是将其转移到说你最好确保在进入这个案例之前不要事先测试它。</p>
<p>发言人   42:38<br>I think part of it is the observation that, man, if you want to be careful and write code, that that is guaranteed correct no matter what implementation goes on, as long as it’s within the C standard, It’s pretty tricky business. A question up there.<br>我认为其中的一部分是观察到，如果你想小心编写代码，那么无论执行什么实现，只要它在C标准内，都是相当棘手的业务。这里有一个问题。</p>
<p>发言人   43:02<br>Yes, which is unfortunate. So yes, that’s exactly the rule that it’s implicitly, silently, the C compiler doesn’t give any warnings.<br>是的，这很不幸。所以是的，这正是规则，它是隐式的，默默地，C编译器不发出任何警告。</p>
<p>发言人   43:14<br>You’ll never know. You cast it to unsigned. And as these examples show, when you stare at that code and you think about it, it’s really easy to have bugs that you just, you can look at it a thousand times and not realize that it’s a bug. It’s a very, and there’s examples, There are examples in the book of security flaws in sort of very important library software due to this problem exactly. So part of the reason we teach in the course is just so you appreciate that this is a quirk in this. And see that again, 99% of the time you’ll never even, it won’t bother you at all. But there will be some oddball cases that you can get in trouble with. So the other that you’ll find unsigned representation useful is, first of all, when you’re doing modular arithmetic, which is, for example, the way most encryption algorithms work, or when you’re using the bits not to represent numbers, but to represent sets the way I described it before, then you don’t’s easiest to just think of that as unsigned numbers.<br>你永远不会知道。你把它转换为未签名的。正如这些例子所展示的，当你盯着代码思考时，很容易出现bug，你可以看上几千次而没有意识到这是一个bug。这是一个非常，有例子，在书中有一些非常重要的图书馆软件安全漏洞的例子，正是由于这个问题。所以我们在这门课程中教授的部分原因只是为了让你欣赏这是其中的一个怪癖。再说一遍，99% 的时间你永远不会，它根本不会打扰你。但是也会有一些奇怪的情况，你可能会惹上麻烦。因此，你会发现无符号表示有用的另一个方面是，首先，当你在进行模算术时，例如，大多数加密算法的工作方式，或者当你使用比特不是代表数字，而是代表我之前描述的集合时，那么你最不容易把它想成无符号数字。</p>
<p>发言人   44:47<br>Okay, so the final thing to talk about today is some of the low level of representations of numbers within memory. And the main point is when you are running a program on a computer. From the programming perspective, even as an assembly level programmer, not just as AC programmer, in your mind, the memory is just this big array of bytes that’s numbered from 0 up to some maximum number. So for example, in the machines, we’re using the 64 b machines, an address is represented in 64 b. But in fact, the maximum address you’re allowed to use in current machines is 47 b.<br>好的，今天要讨论的最后一件事是记忆中数字的一些低水平表示。重点是当你在计算机上运行程序时。从编程的角度来看，即使是汇编级程序员，而不仅仅是交流程序员，在你的脑海中，内存只是一个大的字节数组，从0到某个最大数字编号。例如，在机器中，我们使用的是64 b机器，地址用64 b表示。但实际上，您在当前机器中允许使用的最大地址是47 b。</p>
<p>发言人   45:43<br>Two to the 47th is still a pretty big number. So that’s more memory than anyone’s able to buy right now anyhow. And so it’s a reasonable restriction. But the point is that logically, your program thinks that it has an array of that many bytes.<br>2到47号仍然是一个相当大的数字。因此，无论如何，这比任何人现在都能够购买的更多的记忆。所以这是一个合理的限制。但重点是，从逻辑上讲，你的程序认为它有一个这么多字节的数组。</p>
<p>发言人   46:01<br>Let’s try and figure out how big two to the 40 sevenths is. Anyone know it off the top of their head? So there’s a trick if you want to get an approximate idea, which is to say that two to the 10th, which is 110 24, is approximately equal to 10 to the third.<br>让我们试着弄清楚两个到40的七分之一有多大。有人知道它的头顶吗？所以如果你想要得到一个近似的想法，有一个技巧，也就是说2到10，也就是110 24，大约等于3的10。</p>
<p>发言人   46:31<br>You say, well, that’s really helpful. What it means is that 10 b worth of number is about the same as 3 decimal digits. So for example, to the. 20th? Is around 10 to the 6th, 2 to the 30th. It’s around 10 to the 9th, 2 to the 40th, around 10 to the 12th. And so that would tell you that two to the 48, 47th is around 128 times 10 to the 12th, which is 128 TB, right, Tara, 10 to the twelf.<br>你说，嗯，这真的很有帮助。它的意思是10 b的数字与3位十进制数字大致相同。例如，对于。20号？大约是10到6号，2到30号。大约是10到9号，2到40号，大约是10到12号。所以这就告诉你，2的48次方，47次方大约是128乘以10的12，也就是128 TB，对吧，塔拉，10的12次方。</p>
<p>发言人   47:26<br>So if you just want to say, get a quick figure for, and of course, these are approximations.<br>所以如果你只想说，得到一个快速的数字，当然，这些都是近似值。</p>
<p>发言人   47:33<br>But if you just want to get a quick handle on how big a number, what range of values can I represent with so many bits of it, this is a really easy trick to do that. So the point is, 128 TB, it’s a lot you can buy disk drives, a couple of disk drives will do that for you. You couldn’t buy enough DRAM on a normal budget to get that kind of memory. So that’s the current range of values. But logically, when you run a program, it thinks that it has that possible range. Now it doesn’t really, and in fact, what happens is that the operating system only allows certain regions within that memory to be referenced and other regions, if you try to access them, it will create a, it will a signal, an error, what they call a segmentation fault. But logically, at least, it’s as if you have this big array of bytes Now, in reality, and we’ll go into this when we talk about how the memory system works and virtual memory.<br>但是如果你只是想快速掌握一个数字的大小，我能用这么多位表示什么范围的值，这是一个非常简单的技巧。所以重点是，128 TB，你可以购买很多磁盘驱动器，几个磁盘驱动器就可以为你做到这一点。你无法以正常预算购买足够的DRAM来获得那种内存。这就是当前的值范围。但从逻辑上讲，当你运行一个程序时，它认为它有可能的范围。现在它并不是真的，事实上，发生的情况是操作系统只允许引用该内存中的某些区域，而其他区域，如果您尝试访问它们，它将创建一个信号，一个错误，他们称之为段故障。但从逻辑上讲，至少，就好像你现在有这么大的字节数组，实际上，当我们谈论内存系统和虚拟内存如何工作时，我们会深入探讨这个问题。</p>
<p>发言人   48:44<br>There’s this very complex combination of hardware and software. It gives the program this image of a very large, what you call flat space, just a big array of bytes, when in reality, it’s shuffling between different regions of your memory and even between your memory and your disk drive on your computer to make it implement this particular. Idea that you have this big array of bytes. And that’s all handled, as I said, by the operating system, by the computer hardware. And it’s largely invisible even to the machine level programmer, even people writing assembly code.<br>有一个非常复杂的硬件和软件组合。它给程序提供了一个非常大的图像，你称之为平坦空间，只是一个大的字节数组，而实际上，它正在你内存的不同区域之间，甚至在你的内存和计算机上的磁盘驱动器之间进行洗牌，以使其实现这个特定的功能。你有这么大的字节数组的想法。正如我所说，这一切都由操作系统、计算机硬件来处理。而且即使对于机器级程序员，甚至编写汇编代码的人来说，它也基本上是不可见的。</p>
<p>发言人   49:32<br>You’ll often hear the term word size and it can get very conf confusing nowadays because there’s no really fixed idea of what a word size is. But roughly speaking, the word size should be whatever the largest number is or the range, that sort of. Signifies how big a pointer is in this language? Or hardware wise, the largest sort of chunk of hardware for which there’s standard support for storing it for arithmetic operations and so forth. So when we say it’s a 64 b machine, what we mean is that regular and routinely manipulates 64 b values on arithmetic operations and also has pointers. The values of addresses are 64 b, even if for right now only 47 of those bits are usable, it’s still considered a 64 b machine. One thing that’s strange is in one of the features of. Of machines such as we have?<br>你经常会听到单词大小这个术语，现在它可能会变得非常混乱，因为对于单词大小并没有真正固定的概念。但粗略地说，单词大小应该是最大的数字或范围，那种类型。表示指针在这种语言中有多大？或硬件方面，最大的硬件块，有标准支持存储它以进行算术运算等。所以当我们说它是一台64 b的机器时，我们的意思是常规和常规地在算术运算中操作64 b的值，并且还有指针。地址的值是64 b，即使目前只有47位可用，它仍然被认为是64 b的机器。有一件事很奇怪，那就是它的一个特征。像我们这样的机器？</p>
<p>发言人   50:51<br>Is that if I compile a program using a GCC, is the standard compiler I can specify either I want it to be 64 b code or 32 b code as a flag? And it will actually generate two different kinds of object code as a result. And we’ll talk about these later. But for right now, the point is the hardware itself doesn’t necessarily define what the word size is. It’s a combination of the hardware and the compiler that determines what is the word size being used in this particular program. And that code can be run on. The point is that 64 b machines such as we have and most machines are nowadays, can in sort of a backward compatibility style, also execute 32 b code. And as we also saw, one of the other features is, even though it’s a 64 b word size, the data type int, without any other qualifiers to it, is just 32 b.<br>如果我使用GCC编译程序，标准编译器是否可以指定我希望它是64 b代码或32 b代码作为标志？它实际上会生成两种不同类型的目标代码。我们稍后再讨论这些。但就目前而言，关键是硬件本身并不一定定义单词大小。它是硬件和编译器的组合，确定这个特定程序中使用的单词大小。并且这些代码可以运行。关键是，像我们现在拥有的64 b机器一样，大多数机器都可以以一种向后兼容的方式执行32 b代码。正如我们所看到的，另一个特性是，即使它的字数大小为64 b，但没有任何其他限定符的数据类型int只有32 b。</p>
<p>发言人   52:07<br>There’s sort of this mixture of how big things are. So when people just say word or word size, and let’s say give a precise definition, that’s not a very meaningful term. And we’ll sort of throw it around when we mean sort of a generic chunk of bits without trying to assume that it has a particular number of bits to it.<br>事情有多大有点混合。所以当人们只说出单词或单词大小，假设给出一个精确的定义时，这并不是一个非常有意义的术语。当我们指的是一种通用的位块，而没有试图假设它有特定数量的位时，我们会把它扔掉。</p>
<p>发言人   52:39<br>Yes, so one of the things is if we ever get to 64 b words, it will be 16 PB, 18 PB, depending on how you define when those numbers get big. The error due to this approximation gets more significant. But something times 10 to the 15th bytes. But right now we can only get to 128 times 10 to the 12th.<br>是的，所以其中一件事是，如果我们达到64 b的话，它将是16 PB，18 PB，这取决于你如何定义这些数字变得很大的时候。由于这种近似而产生的误差变得更加显著。但是乘以10的第15个字节。但是现在我们只能得到128乘10的12次方。</p>
<p>发言人   53:15<br>So anyways, the idea that the memory itself is a series of bytes, but we can group those into blocks of words of different word sizes. And the way we do that is usually by assuming that the address of the word is the lowest valued address in it. We also will generally try to align these so that, for example, a 32 b word would be a line. So its first byte, its lowest byte, has all zeros in the first.<br>无论如何，内存本身是一系列字节的想法，但我们可以将它们分组为不同单词大小的单词块。我们通常的做法是假设单词的地址是其中价值最低的地址。我们通常也会尝试对它们进行对齐，例如，一个32 b的单词将是一行。因此它的第一个字节，它的最低字节，在第一个全部为零。</p>
<p>发言人   54:01<br>In the first 5 b positions, no, 30 two-women, sorry, the lowest 2 B. So as this example shows, the address is 0, 4, 8, and 12. They should have really written this in hex and said it’s C, I guess these are all in decimal anyhow. So yeah, these are decimal numbers, so 0, 4, 8, 12. So you see these are in multiples of 4 b boundaries. And similarly, the 64 b words are in multiples of 8, and those are known as aligned words. And we’ll generally, we’ll see that the compiler works pretty hard to keep things aligned because the hardware runs more efficiently that way. But the main point is that we can just take as many bytes as we want and collect them together and call it a word for whatever word size we need.<br>在前5个b的位置中，不，30个是两个女人，抱歉，最低的2个B。正如这个例子所示，地址是0、4、8和12。他们应该用十六进制写这个，并说它是C，我想这些都是十进制的。是的，这些是十进制数字，所以0、4、8、12。所以你会看到这些是以4 b边界的倍数为基础的。类似地，64 b的单词是8的倍数，这些被称为对齐单词。通常情况下，我们会看到编译器会非常努力地保持一致，因为这样硬件会更高效地运行。但主要的一点是，我们可以随心所欲地获取尽可能多的字节，并将它们收集在一起，然后根据我们需要的单词大小来称呼它。</p>
<p>发言人   55:01<br>I think we saw a variant of this table before, but this is the machines we’ll be working on. The standard int is still only 32 b, but if we qualify something as being wrong, then it will be 64 b. And we’ll tend to do that these two different floating point representations that we’ll talk about. And then the main feature of a 64 b machine is it has an 8 by or 64 b pointer as compared to 32.<br>我想我们之前见过这个表格的变体，但这是我们将要研究的机器。标准的int仍然只有32 b，但如果我们将某些东西限定为错误，那么它将是64 b。我们倾向于将这两种不同的浮点表示形式进行讨论。然后64 b机器的主要特点是它具有8 by或64 b指针，而32则不同。</p>
<p>发言人   55:34<br>Now, there’s one other kind of detail that says, okay, so if a word has multiple bytes in it, what order should those bytes be? Should it be? And there’s two basic ways this could go. One is that you put the bytes in what’s known as little Indian order, meaning that the first byte in the word is the least significant byte. And then the next, and then the next. And the final byte in the word is the most significant. Or you can flip that around. And those are called Little Indian and Big Indian.<br>现在，还有另一种细节说明，好的，如果一个单词有多个字节，这些字节应该是什么顺序？应该吗？有两种基本的方法可以实现。一种是你以所谓的小印度顺序放入字节，这意味着单词中的第一个字节是最低有效字节。然后是下一个，然后是下一个。并且单词中的最后一个字节是最重要的。或者你可以把它翻转过来。这些被称为小印度人和大印度人。</p>
<p>发言人   56:13<br>The sort of terms for that which comes from? English book called Gulliver’s Travels, which didn’t anticipate computers at all. But it’s an interesting story of how that comes about. So out there in the world, you’ll find both types of machines, big Indian and little Indian machines. It turns out that increasingly it’s getting hard to find big Indian machines. So literally all of x 86 is little Indian.<br>这种术语的来源是什么？英语书叫做《格列佛游记》，它根本没有预料到计算机。但这是一个有趣的故事，讲述了这是如何发生的。所以在世界上，你会发现两种类型的机器，大型印度机器和小型印度机器。事实证明，越来越难找到大型的印度机器了。所以字面上所有的x86都是小印度。</p>
<p>发言人   56:45<br>And it turns out Arm processors like what you have in almost every cell phone here is an Arm processor. And the hardware in those can actually be configured to run either way, big Indian or little. But when you’re running it on any of the standard operating systems that run on Arm processors. Then it’s running little Indian. So there used to be a brand called Sun Microsystems, and they were fairly common on campus and then back the Macintosh, before they were x 86 processors, they ran one called the Power PC, and that was a big Indian machine.<br>事实证明，几乎每部手机中都有Arm处理器。这些设备中的硬件实际上可以配置为运行任何一种方式，大印度或小印度。但是当你在任何在Arm处理器上运行的标准操作系统上运行它时。然后它正在运行小印度。所以曾经有一个品牌叫做Sun Microsystems，它们在校园里相当普遍，然后在Macintosh上，在x86处理器之前，他们运行一个叫做Power PC的机器，那是一个巨大的印度机器。</p>
<p>发言人   57:30<br>But those are long in the distant past. The internet’s about the only place out there when you send packets over the internet and you want to send 32 b words, they’re actually sent in big Indian order. And so at the network interface, you have to translate between those two.<br>但这些都在遥远的过去很久了。当你通过互联网发送数据包并且想要发送32个字时，互联网大概是唯一的地方，它们实际上是按照印度的大订单发送的。因此，在网络接口上，您必须在这两者之间进行转换。</p>
<p>发言人   57:51<br>So again, just to illustrate what I mean by this is think of a byte value, 4 B value like this. And remember that the way we write numbers is we put the most significant to the left and the least significant to the right. And so now with big Indian, instead of the intuitive one from that perspective, in that the bytes, if you write the words in memory from the smallest address up to the highest, the big Indian will sort of map to what you see, whereas the little Indian will look confusing. But you say 0, 1, 2, 3, 4, 5, 6, 7, because 6, 7 is actually the least significant byte here. And so that comes first in little Indian order.<br>所以，再一次，为了说明我的意思，我认为这是一个字节值，像这样的4 B值。记住，我们书写数字的方式是将最重要的放在左边，最不重要的放在右边。所以现在有了大印度，而不是从那个角度来看直观的，在字节中，如果你从最小的地址到最高地址写入内存中的单词，大印度会有点映射到你看到的地方，而小印度会看起来很混乱。但是你说0，1，2，3，4，5，6，7，因为6，7实际上是这里最不重要的字节。所以这在小印度顺序中是第一位的。</p>
<p>发言人   58:46<br>And so it used to be people would get impassionate arguments about this. That’s sort of in the distant past. But, and people saying, you know. And the main feature in sort of argument of big Indianness is this feature here.<br>所以以前人们会对此进行无情的争论。这有点像是遥远的过去。但是，人们说，你知道的。而大印度性争论的主要特征就是这里的这个特征。</p>
<p>发言人   59:08<br>When you look at it, it’s easier to write down, but computers don’t really care. They’re happy either way. And so they just want one convention or another.<br>当你看着它时，写下来更容易，但计算机并不在乎。不管怎样，他们都很高兴。所以他们只想要一个或另一个约定。</p>
<p>发言人   59:17<br>And like I said, some hardware is can actually be by a sort of flag to flip it from being big Indian to little Indian. But the reality is most of the machines you will encounter, you’ll encounter little Indian machines nowadays. But just to give you an example, here’s some results that I got from actual machines. There used to be some machines around.<br>就像我说的，一些硬件实际上可以通过一种旗帜将其从大印度人转变为小印度人。但现实是，你会遇到的大多数机器，现在你会遇到一些小型印度机器。但只是为了给你一个例子，这里是我从实际机器上得到的一些结果。过去周围有一些机器。</p>
<p>发言人   59:40<br>So back in the old days, I could run this, I don’t even know where to get a big Indian machine anymore. So these are sort of a legacy, a result. But you’ll see the main feature is between a little Indian and a big Indian machine. When you have an integer, the bytes get flipped around so that the least significant byte comes first in a little Indian machine and last in a big Indian machine. And that’s true with negative numbers as well, that you’ll get the sine bits first. In a big Indian machine along, you’ll see that.<br>所以回到过去，我可以运行这个，我甚至不知道在哪里可以买到一个大的印度机器了。所以这些都是一种遗产，一种结果。但你会看到主要特点是介于一个小印度机器和一个大印度机器之间。当你有一个整数时，字节会被翻转，使得最低有效字节在小型印度机中首先出现，在大型印度机中最后。对于负数也是如此，你首先会得到正弦位。在印度的大型机器中，你会看到。</p>
<p>发言人   01:00:25<br>The only difference between a 32 b machine and a 64 b machine is you have more zeros or more ones depending on whether it’s a positive or negative number. And again, a sun. And if I had access to a 64 b machine, sun is now manufactured by a company called Oracle. So in principle, I could go get one of these machines and run this experiment. But it’s really not a very interesting experiment, so I won’t bother. So in principle, I could try it on a 64 b Oracle machine and show you something different.<br>32 b机器和64 b机器之间唯一的区别是你有更多的零或更多的一，这取决于它是正数还是负数。再说一次，太阳。如果我有机会使用64 b机器，那么sun现在由一家名为Oracle的公司制造。所以原则上，我可以去拿一台这样的机器来进行这个实验。但这真的不是一个非常有趣的实验，所以我不会打扰。所以原则上，我可以在64 b的Oracle机器上尝试一下，并向您展示一些不同的东西。</p>
<p>发言人   01:01:07<br>So one thing that kind of a useful tool, and the book goes through some examples of this, is a little program that will take a series of bytes starting at some position start and do it for however many bytes you request, and just print out in hex format the two hex digits that represent that byte value. And here, this term pointer. I’m using an unsigned care as a pointer type, sort of generic pointer type.<br>所以有一件有用的工具，这本书介绍了一些例子，就是一个小程序，它将获取从某个位置开始的一系列字节，并为您请求的字节数执行，并以十六进制格式打印出代表该字节值的两个十六进制数字。在这里，这个术语指针。我正在使用未签名的护理作为指针类型，有点像通用的指针类型。</p>
<p>发言人   01:01:51<br>And so again, if I run this on a x 86 machine. And I’m also, by the way, printing out the actual address that this character is stored at to. And so you’ll see that there’s these addresses with a lot of 7 F’s. What that means is it’s in the upper end of this 47 b address space. If you work it through 7 is three ones then. Enough hex digits here to correspond to. So there’s 11 hex digits beyond the 7. And you’ll see that these addresses are at successive bytes BCB, DBE, BF, and the values are 6 D3 b 0 0 0 0. This is the least significant byte. And these are the successive bytes.<br>再次强调，如果我在x86机器上运行这个。顺便说一下，我还在打印出这个字符存储在到的实际地址。所以你会看到这些地址有很多7个F。这意味着它位于这个47 b地址空间的上端。如果你通过7来工作，那么就是三个一。这里有足够的十六进制数字来对应。所以在7之外有11个十六进制数字。你会看到这些地址是连续的字节BCB，DBE，BF，并且值是6 D3 b 0。这是最低有效字节。这些是连续的字节。</p>
<p>发言人   01:02:52<br>And similarly, I can use this to examine pointers of various sorts. And I can examine different values and just get their low level byte representations. And so I did this back when I could get to a sun machine, had one way of representing a pointer.<br>同样地，我可以用它来检查各种指针。我可以检查不同的值并获取它们的低级字节表示。所以当我能够到达一台太阳机时，我就这样做了，有一种表示指针的方式。</p>
<p>发言人   01:03:12<br>And the main point is even across machines, whether it’s byte ordering or whatever, you’ll get different values for pointers. There’s no guarantee that when you load a program into one machine and run it, that it will use the same addresses as that same programming running on a different machine, even if actually they’re identical hardware and operating system. There can be variation because pointers, you can’t directly copy a pointer from one machine to another.<br>而且主要的一点是即使在机器上，无论是字节排序还是其他什么，你都会得到不同的指针值。不能保证当你将一个程序加载到一台机器上并运行它时，它将使用与在另一台机器上运行的相同程序相同的地址，即使它们实际上是相同的硬件和操作系统。可能会有变化，因为指针，你不能直接将指针从一台机器复制到另一台机器。</p>
<p>发言人   01:03:47<br>One thing about also is regardless of byte ordering, the ordering of of characters is the same. And so a string and C is always represented by a series of bytes where the final byte is 0 null, called null terminated, and the individual bytes correspond to the character codes for that number. And these character codes are just sometimes called Ascii format, which is a little bit old fashioned. By the way. There’s more modern character codes that can represent non-engine alphabets, but the C standard is still back in the days of only supporting the Ascii format question.<br>还有一点是，无论字节排序如何，字符的排序都是相同的。因此，字符串和C总是由一系列字节表示，其中最后一个字节为0空，称为空终止，各个字节对应于该数字的字符代码。而这些字符代码有时被称为Ascii格式，这有点过时。顺便说一下。有更现代的字符代码可以表示非引擎字母，但C标准仍然回到了只支持Ascii格式问题的时代。</p>
<p>发言人   01:04:54<br>Yes, so this should have been.<br>是的，所以这应该是。</p>
<p>发言人   01:05:02<br>Well, no, this is good. So I’m casting, I want to show the 4 B size event because this is an int. I’m representing the pointer. Let’s see the code where it’s printing the pointer. All this notation percent p is the directive to say print out a pointer. And percent x is the directive to print out a He representation. So it’s printing out both the address, the starting position of that particular byte. And the value of that byte has two different things. Does that answer your question?<br>好吧，不，这很好。所以我正在铸造，我想展示4 B大小的事件，因为这是一个整数。我代表的是指针。让我们看看它打印指针的代码。所有这些符号百分比p是指示打印出指针的指令。百分比x是打印出表示的指令。所以它打印出地址，即该特定字节的开始位置。并且该字节的值有两个不同的东西。这回答了你的问题吗？</p>
<p>发言人   01:05:56<br>But remember, show bytes? Is being given a pointer and a length? And so, and what it’s saying is starting at that address, print out the next series of bytes for me. How many bytes I ask for? And in this case I’m creating a pointer to this integer, but I want to show the bytes in that integer, the 4 B that make up that integer. And that’s why I’m giving the number 4 here instead of 8 is.<br>但是记住，显示字节？被给予一个指针和一个长度？所以，它所说的是从该地址开始，为我打印出下一系列字节。我要多少字节？在这种情况下，我正在创建一个指向该整数的指针，但我想显示该整数中的字节，即构成该整数的4 B。这就是为什么我在这里给出的数字是4而不是8。</p>
<p>发言人   01:06:37<br>Yes, it will be. And that’s fine because in this code I’m using the percent P directive to designate how to print out the pointer. And that will print it as many bytes as it takes for that particular machine that it’s running on. So percent p is actually a very handy directive if you have to print addresses, like for debugging purposes or something, because it will automatically adapt to whatever machine it’s running on question. Well I’ve defined it to be an unsigned care here. So type De is a way to introduce a name for some data type, right? And so I’ve just declared a pointer pointer to refer to an unsigned care.<br>是的，会有的。这很好，因为在这段代码中，我使用百分比P指令来指定如何打印出指针。这将打印它所需要的字节数，因为它正在运行的特定机器上。因此，如果您需要打印地址 (例如用于调试或其他目的)，百分号p实际上是一个非常方便的指令，因为它会自动适应正在运行的任何机器。我在这里将其定义为未签字的护理。所以De类型是为某些数据类型引入名称的一种方式，对吗？所以我刚刚声明了一个指针来引用未签名的护理。</p>
<p>发言人   01:07:30<br>If you did avoid star, it would not be happy with this reference here, right? You can’t reference a Vo star is just a way to pass around a generic pointer, but you can’t actually reference that element. So what I’m basically doing is saying this reference is treat it like an array, treat my series of bytes as an array, and print out each of the bytes in that array. And so here where I’m a is a number. And I’m taking the address of that integer and casting it to be an unsigned care star. So sort of a slightly generic pointer, but not quite as generic as a void star, and then printing it out.<br>如果你确实避免了star，这里的引用就不会让你满意了，对吧？你不能引用Vo星号只是传递通用指针的一种方式，但你实际上不能引用该元素。所以我基本上要做的是说这个引用将其视为数组，将我的一系列字节视为数组，并打印出该数组中的每个字节。所以在这里，我是一个数字。并且我正在获取该整数的地址并将其转换为未签名的关心星。有点像一个稍微通用的指针，但不像空星那么通用，然后打印出来。</p>
<p>发言人   01:08:28<br>These are good questions, by the way. OK, so the point being that strings are just strings. And that’s the same from one machine to the next.<br>顺便说一下，这些问题很好。好的，关键是字符串只是字符串。从一台机器到另一台机器也是如此。</p>
<p>发言人   01:08:43<br>Okay, let’s finish up today with some puzzles. And these have this annoying way of showing up on exams. So it’s worth being able to do these kind of things. And you’ll also notice I cleverly did not include the answers in the slides.<br>好的，让我们以一些谜题结束今天的比赛。这些在考试中出现的方式很烦人。所以能够做这些事情是值得的。你也会注意到，我巧妙地没有在幻灯片中包含答案。</p>
<p>发言人   01:09:05<br>So you can’t just peek ahead and figure out what the Nss are. So let’s just go through them. But I actually worked them out to make sure I have the Nss right. So, and basically, these are sort of statements that you want to say, these are either always true, and maybe there’s some logic behind why it’s always true or it’s possibly false. And you have to give some example that would make that false. So let’s go through these as many as we have time for and see where we get to.<br>所以你不能只是往前看，然后弄清楚Nss是什么。所以让我们通过它们。但我实际上已经解决了这些问题，以确保我的Nss是正确的。所以，基本上，这些是你想说的陈述，这些要么总是正确的，也许有一些逻辑为什么它总是正确的，或者它可能是错误的。你必须给出一些例子来证明这是错误的。所以，让我们尽可能地浏览这些，看看我们能走到哪里。</p>
<p>发言人   01:09:36<br>So if I take x and I double it, multiply it by two, if x were negative, am I guaranteed that 2x will be negative? So by the way, one general way to find counter example ins is to try t min. It’s a really good one. And that works here. If I take TN, which is 1 and a bunch of zeros, I double it. It’s like shifting it, but left, and it will become what, 0? And so again, assume that x is at any negative number and uux. Is issed I’m sorry, any two’s complement number and uux is what happens if I cast it to be unsigned? So is uux always greater than or equal to 0, yeah?<br>所以，如果我取x，我把它加倍，乘以二，如果x是负的，我可以保证2x是负的吗？所以顺便说一下，找到反例的一种一般方法是尝试t min。这是一个非常好的。这在这里是有效的。如果我取TN，它是1和一堆零，我会加倍它。这就像转移它，但是离开了，它会变成什么，0？所以再次假设x是任何负数和uux。很抱歉，任何两个的补码数和uux是如果我将其转换为无符号会发生什么？所以uux总是大于或等于0，是吗？</p>
<p>发言人   01:10:30<br>It is slightly more obscure. If I take x and I mask off, 7, you remember is the bit pattern 1, 1, 1. So if I mask off all but the lowest 3 b, and I find that those are all ones. I’m already giving you the answer here, and then I shift it left by 30 positions. What can I say about the result?<br>它稍微模糊一些。如果我将x和掩码关闭为7，您记得这是位模式1，1，1。所以如果我把除了最低的3 b以外的所有都掩盖掉，我发现那些都是一的。我已经在这里给你答案了，然后我把它向左移动了30个位置。我能对结果说些什么？</p>
<p>发言人   01:11:04<br>So I know that x must finish with three ones, right? And I shift that. By 30.<br>所以我知道x必须以三个1结尾，对吗？我改变了这个。到30。</p>
<p>发言人   01:11:24<br>And these will be the only 2 b that are left after the shifting. And they will be in the most significant position. So what can I say about that number? It’s negative. So this is a true statement, rather obscure, but it is true, is uux greater than -1? It’s almost true, right? The one counter example, that would be what? Zero, well, actually, no, you’re right. There’s a lot of examples. It’s hardly ever true, it’s almost always fault. I was wrong. The only thing that would make it true would be actually, it’s never true. So it’s never true. OK, if x is greater than y is minus x less than minus y?<br>这些将是转移后剩下的唯一2 b。他们将处于最重要的位置。关于这个数字，我能说些什么呢？这是负面的。所以这是一个真实的陈述，相当晦涩，但它是真实的，uux是否大于-1？这几乎是真的，对吧？唯一的反例是什么？零，实际上，不，你是对的。有很多例子。这几乎从来都不是真的，这几乎总是错的。我错了。唯一能使它成为现实的是，它永远不是真的。所以这从来都不是真的。好的，如果x大于y是负x小于负y？</p>
<p>发言人   01:12:39<br>No, so by the way, one thing we didn’t really cover is what is the negative of t min?<br>不，所以顺便说一句，我们没有真正涵盖的一件事是t min的负数是什么？</p>
<p>发言人   01:12:51<br>And to see that we can use our comp and increment trick.<br>并且看到我们可以使用我们的comp和increment技巧。</p>
<p>发言人   01:13:03<br>So when you complement an increment t min, you get t min. And that’s why it’s such a great counter examples. So in particular, if. Y is t min, and x is something else. Then the left hand part will be true, but the right hand part will not be true.<br>因此，当你补足一个增量t min时，你得到t min。这就是为什么它是如此好的反例。尤其是，如果。Y是t min，x是另一种东西。那么左手部分将是正确的，但右手部分将不是正确的。</p>
<p>发言人   01:13:31<br>X times x greater than or equal to 0. We’ve seen examples of that being fault. If this is kind of silly, if x is greater than 0 and y is greater than 0, is x plus y greater than 0? No, if x is greater than or equal to 0, is minus x less than or equal to 0? Gotcha, you’re right. It’s true, right? Because, but let’s take its counterpart, if x is less than or equal to 0, is minus x greater than equal to 0 TN So the point being that the largest, any positive number can be represented as negative, but there’s one negative number that can’t be represented as positive. And so that asymmetry is why you get different answers to these.<br>X乘以x，大于或等于0。我们已经看到了这种错误的例子。如果这有点傻，如果x大于0而y大于0，那么x加y是否大于0？不，如果x大于或等于0，那么负x是否小于或等于0？你说得对。这是真的，对吧？因为，让我们取它的对应项，如果x小于或等于0，则减去x大于等于0 tn，因此要点是，最大的任何正数都可以表示为负数，但有一个负数不能表示为正数。因此，这种不对称性就是为什么你会得到不同的答案。</p>
<p>发言人   01:14:30<br>If I take x and I look at minus x, and I shift them to the right by 31 AM I going to get all ones? This is a really weird statement.<br>如果我拿x，然后看负x，然后把它们向右移动31，我会得到所有的一吗？这是一个非常奇怪的声明。</p>
<p>发言人   01:14:53<br>So it actually kind of works if I take all zeros.<br>所以如果我取全部零，它实际上是有效的。</p>
<p>发言人   01:15:07<br>And I subtract 1. I’ll get -1.<br>我减去1。我会得到-1。</p>
<p>发言人   01:15:16<br>And I order them. That works. So what’s wrong with this? What’s that? Oh, but if I shift this to the right 31 places, it’s going to shift arithmetically.<br>我订购了它们。这很有效。这有什么问题吗？那是什么？哦，但如果我将它向右移动31位，它将在算术上移动。</p>
<p>发言人   01:15:46<br>What’s that? Oh I see, oh I’m sorry, I already jumped ahead to a different puzzle. X and minus x I. So you’re right, actually, if the two numbers are 0. And I order those, I get 0. But you’ll figure out, you’ll notice if it’s anything non-zero, actually, this will be true. And that’s an interesting feature. So there’s a couple other puzzles, and I’ll let you solve those on your own. We’re all set for today.<br>那是什么？哦，我明白了，哦，对不起，我已经跳到了另一个谜题。X和-x I。所以实际上你是对的，如果这两个数字都是0。我订购那些，我得到0。但是你会发现，如果它是任何非零的东西，实际上，这将是真的。这是一个有趣的特点。所以还有其他几个谜题，我会让你自己解决这些谜题。今天我们都准备好了。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>深入理解计算机系统 003-Bits,Bytes,andInteger</div>
      <div>http://example.com/2025/10/12/15213-003/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月12日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/12/15213-004/" title="深入理解计算机系统 004-Floating Point">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">深入理解计算机系统 004-Floating Point</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/12/15213-002/" title="深入理解计算机系统 002-Bits,Bytes,andInteger">
                        <span class="hidden-mobile">深入理解计算机系统 002-Bits,Bytes,andInteger</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
