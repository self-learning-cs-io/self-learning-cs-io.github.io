

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="发言人   00:01Good afternoon, everyone. So now we’re going to jump into the part of the course that I’d call the real core of the course where we go into machine level programming.大家下午好。所以现在我们将进入我称之为课程真正">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解计算机系统 005-Machine-Level Programming I, Basic">
<meta property="og:url" content="http://example.com/2025/10/12/15213-005/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="发言人   00:01Good afternoon, everyone. So now we’re going to jump into the part of the course that I’d call the real core of the course where we go into machine level programming.大家下午好。所以现在我们将进入我称之为课程真正">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-12T02:00:04.000Z">
<meta property="article:modified_time" content="2025-10-25T05:03:39.695Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>深入理解计算机系统 005-Machine-Level Programming I, Basic - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="深入理解计算机系统 005-Machine-Level Programming I, Basic"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-12 10:00" pubdate>
          2025年10月12日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          16k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          135 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">深入理解计算机系统 005-Machine-Level Programming I, Basic</h1>
            
            
              <div class="markdown-body">
                
                <p>发言人   00:01<br>Good afternoon, everyone. So now we’re going to jump into the part of the course that I’d call the real core of the course where we go into machine level programming.<br>大家下午好。所以现在我们将进入我称之为课程真正核心的部分，我们将进入机器级别编程。</p>
<span id="more"></span>

<p>发言人   00:14<br>And by the term machine level programming, I mean when you’re actually considering the individual instructions to get executed by the machine in response to your program. And there’s really two forms of machine programs. One is the actual object code that runs on the computer. And as we’ll see, that’s a series of bytes that encode instructions that the processor executes. But because it’s hard to look at bytes and understand them, there’s various text forms to make it more clear. And one of those is assembly code that it used to be. That’s how people program machines. And nowadays, it’s what the target of a compiler is, is to generate assembly code. And I’ll use those terms.<br>所谓机器级编程，是指当你实际考虑由机器执行的各个指令来响应你的程序时。实际上，机器程序有两种形式。一个是在计算机上运行的实际目标代码。正如我们将看到的，这是一系列对处理器执行的指令进行编码的字节。但是因为很难查看字节并理解它们，所以有各种文本形式可以使其更清晰。其中之一就是以前的汇编代码。这就是人们对机器编程的方式。而现在，编译器的目标是生成汇编代码。我会使用这些术语。</p>
<p>发言人   01:02<br>When I say machine code, I sort of interchangeably mean object code, the binary form or assembly code, the text version of it interchangeably, because there really is a one to one mapping between them. But in case I sort of use a term like assembly code, instead of consistently saying machine code, it’s because they’re really the same general idea. So this is sort of one place where this course, 213, 5, 13, takes a particular perspective that’s very different from done elsewhere.<br>当我说机器码时，我的意思是对象代码，二进制形式或汇编代码，它的文本版本可以互换，因为它们之间确实存在一对一的映射。但如果我使用汇编代码这样的术语，而不是一致地说机器代码，那是因为它们实际上是相同的一般思想。所以这是一个地方，这门课程213、5、13采取了与其他地方非常不同的特定观点。</p>
<p>发言人   01:39<br>In the bad old days of computing, you would be required to take a course. It was typically called assembly level programming. The way you actually learn to write programs in assembler, and your assignments would be to do things like to sort an array of numbers, or you set up some kind of linked list data structure, just sort of low level of programming that nowadays you wouldn’t even think of wanting to write an assembly code. And so people didn’t really enjoy those courses very well. And so they got sort of largely cut out of the curriculum.<br>在计算机行业糟糕的旧时代，你将被要求参加一门课程。它通常被称为汇编级编程。你实际上学习用汇编程序编写程序的方式，以及你的任务是做一些事情，比如对数字数组进行排序，或者你设置某种链表数据结构，只是一种低级别的编程，现在你甚至不会想写汇编代码。所以人们并没有真正喜欢这些课程。因此，他们基本上被课程所淘汰。</p>
<p>发言人   02:15<br>But what our version of it is, this is pretty important stuff to know as a sort of gateway between what, how you write your program, say, and see or any other language and how those programs actually execute on a machine. So machine code is sort of the intermediate form there, the intermediate language. And you need to understand that to understand better what your programs are trying to do and what the machine is trying to do. As a result of that, our perspective will be we won’t actually write except in very, very small amounts.<br>但是我们的版本是什么，这是非常重要的东西，作为一种网关，在什么，如何编写你的程序之间，比如说，看到或任何其他语言，以及这些程序如何在机器上实际执行。所以机器代码是一种中间形式，中间语言。你需要理解这一点，以便更好地理解你的程序试图做什么以及机器试图做什么。因此，我们的观点将是，除了非常小的数量外，我们实际上不会写。</p>
<p>发言人   02:53<br>We’re not going to actually sit down and write assembly programs in this course. But what you’ll do is you’re going to look at a lot of code that was generated by AC compiler, GCC, and try to see how does that, what came out of that compiler relate to what went into it? How does this low level of code implement the higher level constructs that I was trying to express my program in, how our procedures functions implemented in machine language? How are data structures such as arrays and structs? How are those implemented in machine code? So we’re going to learn all of that stuff. And it takes a significant chunk of this course and a fair number of lectures to get through all that material because it’s really quite a bit. But I think, like I said, I think this is sort of the core where this course is.<br>在这门课程中，我们不会真正坐下来写汇编程序。但是你要做的是查看很多由交流编译器GCC生成的代码，并尝试看看编译器产生的内容与其中的内容有何关联？这种低级别的代码如何实现我试图表达我的程序的高级结构，我们的过程如何用机器语言实现？像数组和结构这样的数据结构是怎样的？这些在机器码中是如何实现的？所以我们将学习所有这些东西。这门课程需要相当大的一部分内容和相当数量的讲座才能通过所有这些材料，因为它真的相当多。但我认为，就像我说的，我认为这是这门课程的核心。</p>
<p>发言人   03:53<br>And as you know, in this course, we only look at one particular class of machines, even though there’s many more different machine level programming possibilities out there. And we’ve chosen the Intel, the 64 b version of the Intel instruction set. So I’ll go through a little bit of the history behind Intel and how it got to where it is. We’ll look at sort of this idea of how does C code relate to assembly code, machine code, and so forth. We’ll go through senator, the low level basics that you need to understand of what assembly machine code looks like. And then we’ll actually take on and look at some real code focusing specifically on arithmetic operations.<br>正如你所知，在本课程中，我们只关注一类特定的机器，尽管还有许多不同的机器级别编程可能性。我们选择了英特尔，即英特尔指令集的64 b版本。所以我将介绍一下英特尔背后的历史以及它是如何发展到现在的。我们将会探讨C代码如何与汇编代码、机器码等相关的概念。我们将通过参议员，了解您需要了解的汇编机器代码的低级基础知识。然后我们将实际处理并查看一些专门关注算术运算的真实代码。</p>
<p>发言人   04:43<br>So x 86 is a sort of colloquial term for Intel processors. And the reason is the first one was called the 8086. And then they kind of skipped 81. But then they went to 82, 86 and 83, 86. So the one thing in common was 86. And so people just call it x 86.<br>所以x86是一种英特尔处理器的口语术语。原因是第一个被称为8086。然后他们跳过了81。但随后他们又去了82、86和83、86。所以唯一的共同点是86。所以人们就叫它x86。</p>
<p>发言人   05:08<br>And one thing that’s important to this, and it will have influence on what the programs look like, is x 86 is a language like English that it’s been an accrual, an evolution of different features layered on top of each other and not always the most elegant way. So just like English, there’s all these sort of quirky things. How you write it is very different from how you pronounce it, and there’s all these irregular cases. And it doesn’t make sense. It’s not sort of a purpose designed language. It’s the same with x 86, a language that just got there because of a bunch of decisions that locally were probably the right thing to do, but globally were not. There’s other instruction sets that are much cleaner and easier to understand, but we figure it’s just the same. The reason that you learn English instead of learning Esperanto or something like that, that it’s a much more useful language.<br>有一件很重要的事情，它将影响程序的外观，那就是x86是一种像英语一样的语言，它是一种权责发生制，是不同功能层层叠加的演变，并不总是最优雅的方式。所以就像英语一样，有很多古怪的东西。你写它的方式与你发音的方式非常不同，而且有许多不规则的情况。这并没有产生感知。这不是一种目的设计的语言。X86也是如此，这是一种语言，它是由于一系列决定才到达那里的，这些决定在本地可能是正确的事情，但在全球范围内则不是。还有其他更清晰、更容易理解的指令集，但我们认为它们都是一样的。你学习英语而不是学习英语或类似的东西，是因为它是一种更有用的语言。</p>
<p>发言人   06:09<br>X 86 is what sometimes was called a sysc. There is a big thing in the early 80s, 80s in general called risk vs, well, risks was a relatively new idea, what they called a reduced instruction set computer. And it was all the rage and nobody had a name for what came before. But the risk people named what came before a cysk for a complex instruction set computer with the obvious sort of pejorative nature to that title.<br>X86有时被称为sysc。在80年代早期，有一件大事，一般被称为风险与风险，风险是一个相对较新的概念，他们称之为精简指令集计算机。它风靡一时，没有人知道之前发生的事情的名称。但是风险人士将cysk命名为复杂指令集计算机之前的名称，该名称具有明显的贬义性质。</p>
<p>发言人   06:42<br>And so Intel is sort of the classic Syk architecture, meaning it has a ton of features. We’re not going to even scratch the surface if you want. The manual for it is two big fat books, which nowadays you do with PDF documents, but it’s still a huge amount of stuff and some 500 or more instructions, everything from doing decimal arithmetic to even decimal floating point and all kinds of goofy stuff in there. But it turns out that you can kind of get a pretty good handle on it by focusing more on just what does the code look like that GCC is generating for the kind of programs that you typically write. And you should also realize that at many levels. This should not have been the successful design because as I said, it’s just got lots of stuff on there. But Intel has been such a powerful company and had so much market and better technology as far as semiconductors than its competitors. But it’s been able to kind of keep this thing alive for almost 40 years.<br>因此，英特尔有点像经典的Syk架构，这意味着它有吨功能。如果你愿意，我们甚至不会去抓表面。它的手册是两本又大又胖的书，现在你可以用pdf文件来完成，但它仍然是大量的东西和大约500条或更多的指令，从十进制算术到十进制浮点以及各种愚蠢的东西。但是事实证明，通过更多地关注GCC为您通常编写的程序生成的代码看起来是什么样子，您可以相当好地处理它。你也应该认识到，在许多层面上。这不应该是成功的设计，因为正如我所说，它只是有很多东西在那里。但英特尔一直是一家强大的公司，在半导体方面拥有比竞争对手更多的市场和更好的技术。但它已经能够让这个东西存活近40年了。</p>
<p>发言人   08:00<br>This is pretty admirable. So just to give you a sort of time scale, as I mentioned, 8086 was the first one of the first single chip 16 b microprocessors came out in 78. And slight variation on it was the basis for the original IBM PC, which I know Preds, most of you your lives, but it was sort of the big breakthrough that put computers on the desktops of many people. And there’s been many, many generations.<br>这相当令人钦佩。所以只是为了给你一个时间尺度，正如我所提到的，8086是第一批单芯片16 B微处理器中的第一个，出现在78年。它的微小变化是最初的IBM PC的基础，我知道它会影响你们大多数人的生活，但这是一项重大突破，将计算机放在许多人的桌面上。而且已经有很多很多代人了。</p>
<p>发言人   08:37<br>I’m just giving you the highlights that are relevant to this particular class, the 386, which dates back to 1985, was the one that really made the transition from these being personal computers that could run not very interesting applications to ones that could actually run something like a Unix or Linux machine. And the reason is they extended it to 32 b and they removed some of the weird addressing stuff that used to be in there.<br>我只是给你与这个特定类别相关的亮点，可以追溯到1985年的386，真正实现了从可以运行不太有趣的应用程序的个人计算机到可以实际运行Unix或Linux机器的过渡。原因是他们将其扩展到32 b，并删除了一些曾经存在的奇怪寻址内容。</p>
<p>发言人   09:07<br>So these look like sort of a generic processor and that was queer back in 85 and that was what’s sometimes called IA 32. Intel Architecture 32, which was the dominant way of code up till just even a few years ago. So even up recently as this past summer, this course was teaching IA 32. And then, and I’ll talk about it more later, reason and a strange story behind the extension from 32 to 64 b, which kind of was sneaked in by Intel in an odd model, the Pentium 4 e. But you see, it was only about 10 years ago. And one of the smart things they did with that is that the machines that can run the 64 b code can also run 32 b code. So they were able to sort of bring out all these machines without everybody having to change over their software. And it’s taken about that amount of time for the software to largely transition away from 32 b code to 64 b code.<br>所以这些看起来有点像一个通用处理器，在85年很奇怪，这就是有时被称为IA 32的东西。英特尔架构32，这是直到几年前还是占主导地位的代码方式。所以即使最近像去年夏天，这门课程的教学水平也是32。然后，我稍后会更多地谈论它，从32扩展到64 b背后的原因和奇怪的故事，这种情况是由英特尔在一个奇怪的模型奔腾4 e中潜入的。但是你看，这只是大约10年前的事情。他们做的一个聪明的事情是，可以运行64 b代码的机器也可以运行32 b代码。因此，他们能够在不需要每个人更换软件的情况下推出所有这些机器。软件从32 b代码大部分转换到64 b代码大约花费了这么长的时间。</p>
<p>发言人   10:23<br>And then for actually fairly interesting reasons, you could map how fast a single processor would run. And it was climbing up at a pretty steady pace in till around 2004. And then Intel and all the companies got into serious trouble with the power consumption of their chips. They’re approaching 100 W. So imagine a 100 W light bulb and how much heat that generates inside of a box that you try to blow a fan on really hard to keep it from getting too hot. And they were reaching the point where they really couldn’t go much beyond 100 W. And so they sort of got into a power budget problem. And as a result, they haven’t been able to scale up the frequency how fast the inner clock that drives this thing is beyond just a few gigahertz since 2004.<br>然后，由于相当有趣的原因，您可以绘制单个处理器的运行速度。直到2004年左右，它一直以相当稳定的速度攀升。然后英特尔和所有公司都在芯片功耗方面陷入了严重的麻烦。它们正在接近100瓦。想象一下一个100瓦的灯泡，在一个盒子里产生多少热量，你试图用风扇吹打它，以防止它变得太热。他们已经达到了一个地步，他们真的无法超过100瓦。所以他们有点陷入了电力预算问题。因此，自2004年以来，他们一直无法将驱动这个东西的内部时钟的速度提高到超过几千兆赫的频率。</p>
<p>发言人   11:19<br>So what’s happened was they said, well, we can’t make any single processor faster, but we can put a bunch of processors on a single chip. And those that are referred to cores or multicore. So most of you with laptops probably have 2 cores on those. And a laptop processor and a server might have up to 16 cores. So those are independent processors that all reside on a single chip.<br>所以发生的事情是，他们说，好吧，我们无法使任何单个处理器更快，但我们可以在单个芯片上放置一堆处理器。以及那些被称为核心或多核的。所以大多数使用笔记本电脑的人可能都有两个核心。而笔记本电脑处理器和服务器可能最多有16个核心。所以这些都是独立的处理器，全部驻留在一个芯片上。</p>
<p>发言人   11:49<br>The shark machines date back to 2008, and they each have 4 cores on them. The shark machines, the one thing about computers haven’t really gotten that much faster in the meantime. So there’s still fairways, and they were, in their day, a very high performance machine, so they’re still pretty decent.<br>鲨鱼机器可以追溯到2008年，它们每个都有4个核心。鲨鱼机器，关于计算机的一件事并没有在此期间真正变得更快。所以还有球道，在他们的时代，他们是一台非常高性能的机器，所以他们仍然相当不错。</p>
<p>发言人   12:15<br>This shows a picture of the chip that makes up AI think, the shark machines or approximately that same era. And you’ll see that as the picture shows, there’s 4 cores are integrated onto one chip. And then down at the bottom is what they call a cache. And we’ll learn a lot about cache memory. It’s basically a temporary memory used to hold the most recently accessed data so that you can get to it more quickly. And you’ll see that that shared across the 4 cores. So if you look at the latest, if you were to go off shopping in the catalog, the latest instance, and I don’t have any chip pictures of it, is a model they call the Broadwell model. And you’ll see that on a single chip, they have multiple cores, 4 for a serious standard desktop model, 8 for a server request machine.<br>这张照片展示了构成人工智能思维的芯片，即鲨鱼机器或大致相同的时代。你会发现，如图所示，一个芯片上集成了4个内核。然后在底部是他们所谓的缓存。我们将会学到很多关于缓存的知识。它基本上是一个临时内存，用于保存最近访问的数据，以便您可以更快地访问它。你会看到这是在4个核心之间共享的。所以，如果你看看最新的，如果你要在目录中购物，最新的实例，我没有任何芯片图片，是一个他们称之为布罗威尔模型的模型。你会看到在一个芯片上，它们有多个核心，4个用于严格的标准桌面模型，8个用于服务器请求机器。</p>
<p>发言人   13:17<br>And then built around the perimeter, there are various connections to the rest of the world. So DDR is the way you connect to the main memory, what’s called DRAM dynamic Ram. PCI is the connection to peripheral devices. SATA is a connection to different types of disks and USB, well, you know what USB is, and then the Ethernet is the connection also to a network connection. That’s all integrated onto a single chip is not just the processor itself, but a logic that glues that processor into a larger system. And one interesting thing you’ll notice is that the desktop model is a higher power, 65 W versus the server is 45 W.<br>然后围绕周边建造，与世界其他地方有各种连接。所以DDR是你连接到主存的方式，这被称为DRAM动态内存。PCI是与外围设备的连接。SATA是到不同类型的磁盘和USB的连接，你知道什么是USB，然后以太网也是到网络连接的连接。集成在单个芯片上的不仅仅是处理器本身，还有将处理器粘合到更大系统中的逻辑。你会注意到的一件有趣的事情是，台式机型号是更高的功率，65瓦，而服务器是45瓦。</p>
<p>发言人   14:11<br>When you put a lot of computers in a room, turns out power is the biggest issue you have to deal with.<br>当你把很多电脑放在一个房间里时，电力是你必须处理的最大问题。</p>
<p>发言人   14:22<br>So Intel isn’t the only company in this game. They sort of historic competitor is a company called AMD. And AMD was always sort of number two behind Intel in just so I gave us this number two behind hers. They had a little burst in time when they. Kind of got out ahead of Intel because Intel had wasted their time on some bad ideas and they actually were the one that came up with the 64 b extension to Intel that we use. Right now though AMD is not doing very well. Intel sort of realized that it had to get its act together, and it did, and it was more or less crushed AMG. And I should mention, they had these ferocious patent suits many years ago.<br>所以英特尔并不是这个游戏中唯一的公司。他们的历史性竞争对手是一家名为AMD的公司。而AMD总是排在英特尔之后的第二位，所以我给了我们这个排在她之后的第二位。他们在时间上有点爆裂。有点领先于英特尔，因为英特尔在一些糟糕的想法上浪费时间，实际上他们提出了我们使用的英特尔64 b扩展。但现在AMD做得并不是很好。英特尔意识到它必须齐心协力，它做到了，它或多或少被压垮了。我应该提到，他们很多年前就有这些凶猛的专利诉讼。</p>
<p>发言人   15:19<br>And the result of that was a cross licensing deal that allows AMD to produce x 86 processors too.<br>其结果是达成了一项交叉许可协议，允许AMD也生产x86处理器。</p>
<p>发言人   15:27<br>Now, it’s interesting story behind Intel. In 64 b, they decided to make this radical shift to an architecture that they called the. They called IA 64 at the time, and it was based on a whole new concept that looked really good on paper and initial results looked promising. They invested a lot of money in this stuff. They formed a joint operation with Hewlett and Packard on this, and it turned out not to work. It was much too aggressive. It assumed miraculous optimization capabilities by the compiler. And so it was a, from a technically idea, it was very interesting technology, but in the marketplace, it didn’t work.<br>现在，英特尔背后的故事很有趣。在64 b中，他们决定彻底转变为一种他们称之为架构的架构。他们当时称之为IA 64，它基于一个全新的概念，在纸上看起来非常好，初步结果看起来很有希望。他们在这个东西上投入了很多钱。他们与休利特和包加德组成了一个联合行动，但结果并不奏效。这太咄咄逼人了。它假设编译器具有神奇的优化能力。因此，从技术角度来看，这是一项非常有趣的技术，但在市场上，它并不起作用。</p>
<p>发言人   16:12<br>And this was sort of a branch off that Intel pursued and felt obligated to keep it up because they’d invested so much in it.<br>这是一个分支，英特尔追求并感到有义务继续保持，因为他们在这方面投入了大量资金。</p>
<p>发言人   16:20<br>And along came AMD, and they said, well, we don’t have to do this radical shift. We’ll just sort of do the obvious thing of adding, making the registers bigger, making things go from 32 to 64 b. And they came along with that and were successful. And so Intel kind of had to just sheepishly follow behind AMD on this, but they could because of their cross licensing deal.<br>然后AMD来了，他们说，好吧，我们不必做这种彻底的转变。我们只是做一些显而易见的事情，增加寄存器，使内容从32 b增加到64 b。他们随之而来，并取得了成功。因此英特尔不得不羞怯地跟随AMD，但他们可以，因为他们的交叉许可协议。</p>
<p>发言人   16:47<br>So nowadays, as I mentioned, hardware wise, just about every processor that is in a laptop, in a desktop, even your cell phones of recent generation or all 64 b processors. So what we’ll talk about then, we used to teach IA 32, but that’s gone. This is the first term where we’re skipping it all together. So we’re using what we’ll call x 80 two-six hyphen 60 two-four. There’s various ways this is named, but this is sort of the Linux way of naming it. If you’re interested in i.e. 32, there’s a document on the web associated with the book called a webi side goes through at least some of the basics of it. But to really read that, you need to learn the 64 b because it assumes you kind of already know that. Okay, so let’s go in.<br>所以现在，正如我提到的，硬件方面，几乎每个处理器都在笔记本电脑、台式机、甚至你的最新一代手机或所有64 B处理器中。那么我们接下来要谈的是，我们以前教的是IA 32，但现在已经过去了。这是第一个我们一起跳过的学期。所以我们使用的是我们称之为x 80的2-6连字符60 2-4。有多种命名方式，但这是Linux命名它的一种方式。如果您对以下内容感兴趣:32，在网络上有一个与这本书相关的文档，称为webi面，它至少介绍了其中的一些基础知识。但是要真正阅读它，你需要学习64 b，因为它假设你已经知道了这一点。好的，我们进去吧。</p>
<p>发言人   17:42<br>And I should mention too, just for general interest, the other major class of processor and common use today are called Arm. So Arm actually is an acronym for Acorn Risk Machine. I just told you what risk means. It means risk reduced instruction set computer. An acorn means like the seed of an oak tree.<br>我也应该提到，只是为了大众的兴趣，另一类主要的处理器和今天常用的被称为Arm。所以Arm实际上是橡子风险机器的首字母缩写。我刚刚告诉你什么是风险。这意味着风险降低了指令集计算机。橡子的意思就像橡树的种子。</p>
<p>发言人   18:03<br>It was a British company that decided to make its own personal computers in the early days of it. And they said, we’re not going to buy those chips from Intel. We’re going to make them ourselves. So they designed and manufactured their own chips. Well, as a company, a computer manufacturer, it was a complete bust, but it turned out that they’d come up with a fairly good instruction set that was sufficiently simple that it could be put on chips, and better yet, it could be customized. So Arm is now a company of its own, headquartered in Cambridge, England, and the reason why, part of the reason they’re successful there is because it tends to be a lower power requirements than a x 86 machine because it’s simpler.<br>这是一家英国公司在早期决定制造自己的个人电脑。他们说，我们不会从英特尔购买这些芯片。我们将自己制作它们。所以他们设计并制造了自己的芯片。作为一家公司，一家计算机制造商，这是一个完全的破产，但事实证明，他们提出了一个相当好的指令集，这个指令集足够简单，可以放在芯片上，而且更好的是，它可以定制。所以Arm现在是一家自己的公司，总部位于英国剑桥，他们在那里成功的部分原因是因为它往往比x86机器低功耗，因为它更简单。</p>
<p>发言人   18:51<br>But the other is that they don’t actually sell processors. They sell companies the rights, the licensing rights to use their design. And so if you look at like a cell phone processor, the actual Arm processor is a little tiny part of it on the chip, and then they’ll have other stuff to make the graphics go better, to improve your phone calls and so forth. And so they’re really selling what, intellectual property as opposed to chips people, we’ve gotten various inquiries.<br>但另一个问题是他们实际上并不销售处理器。他们向公司出售使用其设计的权利和许可权。所以如果你看一个手机处理器，实际的Arm处理器只是芯片上的一小部分，然后它们会有其他的东西来使图形变得更好，改善你的电话通话等。所以他们真的在卖什么，知识产权而不是芯片人，我们已经收到了各种询问。</p>
<p>发言人   19:24<br>When are you going to start talking about Arm in your book or your course or something? And we go, it would be another book to write to do justice to arm, it would be like a whole redo of the thing. And we’re not inclined to do that right now. Just so you know, two worlds out there, x 86 and Arm are the dominant players right now.<br>你什么时候开始在你的书或课程中谈论手臂？我们去，这将是另一本书，以公正地对待武装，这将是对事情的整个重做。我们现在不倾向于这样做。只是让你知道，在那里有两个世界，x86和Arm是目前的主导者。</p>
<p>发言人   19:50<br>So let’s talk some terminology. And you’ve probably heard some of these terms before, but let’s make it clear. So when we talk about the instructions, the instruction set, that’s the target of a compiler to give you a series of instructions that tell the machine exactly what to do. But it turns out that the hardware people have figured out all kinds of clever ways to implement instructions. Some of them are really fast, but take a lot of hardware. Some are pretty slow, but don’t take much hardware at all. And so they managed to create this abstraction that’s called the abstraction set architecture, which is what the target of a compiler should be, and then what the hardware people figure out how best to implement it.<br>那么让我们来谈谈一些术语。你可能之前听过其中一些术语，但让我们把它说清楚。因此，当我们谈论指令时，指令集是编译器的目标，它会给你一系列的指令，告诉机器该做什么。但事实证明，硬件人员已经想出了各种聪明的方法来实现指令。其中一些速度非常快，但需要很多硬件。有些很慢，但根本不需要太多硬件。所以他们设法创建了这个抽象，称为抽象集体系结构，这是编译器的目标应该是什么，然后硬件人员想出如何最好地实现它。</p>
<p>发言人   20:37<br>And so that’s a concept, actually, that came along in the 1960s. So that’s even before my time as far as a computer person. But it’s a very important concept in the world of computers and then what they call the lower level stuff, how it actually gets implemented is called the microarchite, and we won’t talk very, very little about microarcsecond this course.<br>实际上，这是一个概念，出现在19 60年代。所以这甚至在我成为计算机人之前。但它在计算机世界中是一个非常重要的概念，然后他们称之为低级别的东西，它实际上是如何实现的被称为微石墨，我们在这门课程中不会谈论非常少的微石墨。</p>
<p>发言人   21:04<br>And as I mentioned, machine code is sort of a generic term that incorporates both the actual bytes that are operating, executing, as well as the assembly level version of it.<br>正如我所提到的，机器码是一种通用术语，包含了实际操作、执行的字节以及汇编级别版本。</p>
<p>发言人   21:19<br>And as I mentioned, you can think of from an instruction set point of view. So IA 3 2x 8664 and what’s called titanium, this not very successful Intel thing, Those are all in some ways different instruction set architectures. Arm, actually similar to Intel, has gone through various different generations. So there’s various different generations of its instruction set.<br>正如我所提到的，你可以从指令集的角度来考虑。所以，IA 3 2x8664和所谓的钛，这不是很成功的英特尔产品，它们在某些方面都是不同的指令集架构。Arm实际上类似于英特尔，经历了不同的世代。因此，它有不同代的指令集。</p>
<p>发言人   21:49<br>So from a machine level programmer’s perspective, things are a bit different than you see when you write C code.<br>因此，从机器级程序员的角度来看，事情与你编写C代码时看到的有些不同。</p>
<p>发言人   21:57<br>First of all, there is some very visible parts of the instruction, the machine state that you can examine and test and operate on. And you must, in fact, that you would never understand what those are if you’re just thinking in terms of C particular, some sort of a program counter tells you what address is the instruction that you’re going to execute next. Where is that located in memory? And then there’s a set of registers which are part of that the programmer actually makes use of. You can think of them as as a very small number of memory locations, but rather than giving an address from 0 up to n -1 or something, you actually give them by name specifically. And then there’s another sort of state that’s just a few bits worth of state that talk about what are the results of some recent instructions where they did it produce a value of 0? Did it produce a negative or a positive value? And those are used to implement conditional branching, which we’ll look at later as we go.<br>首先，指令中有一些非常可见的部分，您可以检查、测试和操作机器状态。而且事实上，如果你只是从特定的角度思考，你永远不会理解这些指令是什么，某种程序计数器会告诉你接下来要执行的指令是什么地址。它在记忆中的什么位置？然后有一组寄存器，它们是程序员实际使用的一部分。你可以把它们看作是数量非常少的内存位置，但是与其给出从0到n -1的地址，你实际上是专门给它们命名。然后还有另一种状态，它只是几位的状态，它谈论一些最近的指令产生的值为0的结果是什么？它产生了负值还是正值？这些用于实现条件分支，我们稍后会在进行中查看。</p>
<p>发言人   23:11<br>And then the other part of it, so that’s sort of the processor. And then the other part of it is the memory. And as I mentioned in. One of the first lectures, the memory is you can think of logically as just an array of bytes. And that’s what the machine level programmer sees. And it’s actually kind of a fiction in different ways.<br>然后是它的另一部分，那就是处理器。然后它的另一部分是记忆。正如我在中提到的。最早的讲座之一，内存是你可以从逻辑上想象为一个字节数组。这就是机器级程序员所看到的。这实际上在不同方面有点像虚构。</p>
<p>发言人   23:36<br>As I mentioned before, there’s sort of a collaboration between the operating system and the hardware, what they call virtual memory, to make it look like each program running on a processor has its own independent array of bytes that it can access, even though they actually share values within the physical memory itself, more the term cache, The idea of a cache is not visible here at all because it just is automatically loaded with recent stuff. And the only thing that will look different is if you re-access that memory, it will go faster than it would if it hadn’t been cached. But it’s not visible in terms of there’s no instructions to manipulate the cache. There’s no way you can directly access the cash. So you already see that it’s already abstract. It’s got some more details of real hardware, but underneath it, the sort of microarchitecture has some features built into it that you’re not operating on, you’re not making use of directly when you write machine level programs.<br>正如我之前提到的，操作系统和硬件之间有一种协作，他们称之为虚拟内存，以使处理器上运行的每个程序看起来都有自己独立的字节数组可以访问，即使它们实际上在物理内存本身内共享值。更多的术语是缓存，缓存的想法在这里根本不可见，因为它只是自动加载最近的东西。唯一看起来不同的是，如果您重新访问该内存，它会比没有缓存时运行得更快。但它是不可见的，因为没有操作缓存的指令。你无法直接访问现金。所以你已经看到它已经很抽象了。它有更多真实硬件的细节，但在它下面，这种微架构有一些内置的功能，你不是在操作这些功能，当你编写机器级别的程序时，你也不会直接利用这些功能。</p>
<p>发言人   24:54<br>So if you have a program, then say in C, it would typically a larger program that will include multiple files and it will make use of some library code. And so the process of compilation is actually a series of steps that will take what you’ve written for code, turn it into machine code, combine it with the compiler, compiler generated code for the libraries, and produce finally a file that’s your actual executable program. And so that’s shown here in this picture that the first step is to take C and actually generate assembly code from it. And then the next is to run that through an assembler, which takes the text representation of instructions and turns it into the actual byte level representation. We’ll look at all this shortly. And then there’s a program called a linker, which merges together all the different files for both your individual file. They’re compiled versions, and for the library code. And then finally there, even once you run a program, there’s actually some libraries that get imported dynamically when the program first begins, so it’s a sort of many layered set of activities.<br>所以，如果你有一个程序，比如说用C语言，它通常是一个包含多个文件的较大的程序，它将利用一些库代码。因此，编译的过程实际上是一系列步骤，这些步骤将您为代码编写的内容转化为机器码，将其与编译器结合，编译器为库生成代码，最后生成一个实际可执行程序的文件。因此，这张图片中显示的第一步是使用C并从中实际生成汇编代码。然后，接下来是通过汇编器运行它，汇编器采用指令的文本表示形式并将其转换为实际的字节级表示形式。我们很快就会看到这一切。然后有一个名为链接器的程序，它可以将您个人文件的所有不同文件合并在一起。它们是编译版本，用于库代码。最后，即使你运行了一个程序，实际上也有一些库在程序刚开始时动态导入，所以它是一组多层的活动。</p>
<p>发言人   26:19<br>And I’ll go through some of these one by one for you.<br>我会为你逐一介绍这些内容。</p>
<p>发言人   26:24<br>Example, not very interesting function in terms of doing anything useful, but it sort of demonstrates the basic ideas of compilation. And if I run this through AC compiler, I get something that looks like what’s shown on the right, and that’s the assembly code. And just to give you an idea of what it is, it looks like a sort of strange language the first time you see it. But you’ll see those percent are something. Those are the actual names of registers. Remember I told you those registers that you give by name, and then those instructions are telling it to do something?<br>这个例子并不是很有趣的函数，但它展示了编译的基本思想。如果我通过交流编译器运行这个，我会得到一些看起来像右边显示的东西，那就是汇编代码。为了让你了解它是什么，当你第一次看到它时，它看起来像是一种奇怪的语言。但是你会发现那些百分比有些关系。这些是寄存器的实际名称。记得我告诉过你那些你按名字指定的寄存器，然后那些指令告诉它做某事？</p>
<p>发言人   27:03<br>Push Q means push something onto a stack. Move means move, copy it from one place to another. Call means to call some procedure. Pop is the counterpart to push, and then rep is exit. Return out of this particular function. So you see each of those is an instruction and it’s written in text, but each of those will turn into one actual instruction in the object code representation. So I should tell you that this is actually a slightly cleaned up version of what really happened. So let me show you the reality because you’ll be experiencing that a bit more too.<br>Push Q的意思是将某物推到堆栈上。移动意味着移动，将其从一个地方复制到另一个地方。Call意味着调用某个过程。Pop是push的对应项，rep是exit。返回这个特定的功能。因此，您会看到其中的每一个都是一条指令，并且它是用文本编写的，但是每一个都将在目标代码表示中变成一条实际的指令。所以我应该告诉你，这实际上是对实际情况的稍微清理过的版本。所以让我向你展示现实，因为你也会经历更多。</p>
<p>发言人   27:49<br>I had this bigger before. Let me make it bigger.<br>我以前有过这个更大的。让我把它放大一点。</p>
<p>发言人   28:06<br>Blow this up so that you can see it. That, can you see it in the back there? Better?<br>把这个吹起来，这样你就能看到了。你能看到后面的那个吗？更好？</p>
<p>发言人   28:25<br>And let me get the other one. No, that’s not what I.<br>让我去拿另一个。不，那不是我想的。</p>
<p>发言人   28:52<br>And I’ve already. Logged into a fish machine to get here. This is a file. Then you see it’s called some DOC. And I’ll mention that all of these programs are available. You can see the whole well slash Afs is my own personal and all that first stuff is my own personal links. But once you get to the class web page, www slash code slash, and then it’s all given by which particular lecture it is, I think these are linked on the homepage too. And you can see various files there that are used for the demonstration.<br>而且我已经。登录到一个鱼油加工机械来这里。这是一个文件。然后你会看到它被称为某个医生。我会提到所有这些程序都是可用的。你可以看到整个井斜杠Afs是我个人的，而所有这些第一件事是我自己的个人链接。但是一旦你进入班级网页，www斜线代码斜线，然后全部由哪个特定的讲座给出，我想这些也在主页上链接了。您可以在那里看到用于演示的各种文件。</p>
<p>发言人   29:34<br>The C files are obviously the programs that we typed in and then ones that have an S at the end, that’s assembly code 1 that are D are what’s called disassembly. So anyways, if I say GCC is O two’s, sorry, minus 0?<br>C文件显然是我们输入的程序，然后结尾有S的程序，即汇编代码1和D，这就是所谓的 “拆卸”。无论如何，如果我说GCC是O两个，对不起，减去0？</p>
<p>发言人   29:54<br>G minus S capital sum dot C, what I did was just tell the compiler to take the C code and turn it into assembly code. So when you invoke GCC, you’re actually invoking it, not just one program, but a whole sequence of programs that do various stages of the compilation. And by giving it this minus capital S switch I’m saying stop. Just do the first part C to assembly code. And the minus O little g is a specification of what kind of optimization I want the compiler to do. So if you don’t say anything, if you just don’t give any directive, it will generate completely unoptimized code. And it’s actually very hard to read that code, tedious the way it works.<br>G减去S大写和点C，我所做的只是告诉编译器将C代码转换为汇编代码。因此，当您调用GCC时，实际上是在调用它，而不仅仅是一个程序，而是整个执行不同编译阶段的程序序列。通过给它这个减去大写字母的开关，我说停止。只需对汇编代码执行第一部分C即可。减号O小g是我想让编译器做什么样的优化的规范。因此，如果你什么也不说，如果你不给出任何指令，它将生成完全未优化的代码。实际上，阅读这些代码非常困难，它的工作方式非常繁琐。</p>
<p>发言人   30:50<br>If you say minus o one, which is what you used to do to turn on the optimizer, it turns out that as GCC, as they’ve gotten more advanced, it does a lot of optimizations now that for the purpose of this course, make the code pretty hard to understand. So just one of the most recent generations of GCC came out with this level called G for debugging. That’s a, for this course, purpose of this course, a nice level that sort of does the obvious kind of optimizations to make the code readable without being sort of extravagant and trying to rewrite your whole program in a way that would make it a lot different and hopefully more efficient.<br>如果你说-o one，这是你过去用来打开优化器的方法，结果发现，随着GCC变得更加高级，它现在会进行很多优化，为了本课程的目的，使代码变得非常难以理解。所以只有最新一代的GCC推出了这个称为G的级别来进行调试。这就是本课程的目的，一个不错的水平，它做了一些明显的优化，使代码可读，而不会有点奢侈，并试图重写整个程序，使其变得与众不同，希望更高效。</p>
<p>发言人   31:38<br>So that’s what we’ll use in this course. It’s only exists in the recent versions of GCC. It’s non-standard across other compilers question. No, it’s an O capital. O, it stands for Optimize.<br>这就是我们在本课程中将要用到的。它只存在于最近的GCC版本中。这在其他编译器中是非标准的问题。不，它是一个大写字母。O，它代表优化。</p>
<p>发言人   31:57<br>So what that command just did was produce a file called sums. So let me show you. What sum dot s is, and let me show you the function sum store. Can you see that then?<br>所以这个命令所做的就是生成一个名为sum的文件。让我向你展示一下。总和s是什么，让我向您展示函数和存储。你看见了吗？</p>
<p>发言人   32:30<br>So this is the code. It says some store. And then you’ll see, you’ll recognize those instructions I mentioned before, the push, the move, the call, the mush move, the pop, and the rat. But you also see other junk there that we edited it out for the presentation. And even in the book, it got edited out. And the reason is these are various directives that aren’t really directly part of the code itself. The fact they start with a period is an indication that these aren’t actually instructions. There’s something else, and they all are related to the information that needs to be fed a debugger it to be able to locate various parts of the program and some information for the linker to tell it that this is a globally defined function and various other things that you don’t really need to at least think about initially.<br>这就是代码。它说一些商店。然后你会看到，你会认出我之前提到的那些指令，推动、移动、呼叫、糊状移动、弹出和老鼠。但是你也会看到我们为演示文稿编辑的其他垃圾内容。甚至在书中，它也被编辑掉了。原因是这些是各种指令，它们并不是代码本身的直接组成部分。它们以句号开始的事实表明这些实际上并不是指令。还有一件事。它们都与需要提供给调试器的信息有关，以便能够找到程序的各个部分，以及链接器的一些信息，告诉它这是一个全局定义的函数以及其他各种你不需要考虑的东西。</p>
<p>发言人   33:29<br>So we sort of take those out of the program just to make them more readable. But if you ever do this yourself, you’ll find this cred in there and we don’t want you to get like, oh my gosh, this wasn’t in the book. I don’t know what to do with it.<br>所以我们把它们从程序中取出来，只是为了让它们更易读。但如果你自己做这件事，你会发现这里面有这种可信的东西，我们不希望你觉得，天哪，这本书里没有这一点。我不知道该怎么办。</p>
<p>发言人   33:48<br>So let’s go back.<br>那我们回去吧。</p>
<p>发言人   34:00<br>The other thing is people are learning on datalab is shark versus non-ss Hark, it makes a difference. And even like this is a Mac computer and I’ve got GCC installed and it generates its Intel processor in there, but it’s not directly compatible with Linux code. So it’s pretty important for this course, we’re saying just stick with the shark machines for everything you do.<br>另一件事是人们在datalab上学习的是鲨鱼和非ss哈克，这有所不同。甚至像这样，这是一台Mac计算机，我安装了GCC，它在其中生成英特尔处理器，但它不能直接与Linux代码兼容。所以对于这门课程来说，这非常重要，我们说的是，无论你做什么，都要坚持使用鲨鱼机器。</p>
<p>发言人   34:31<br>So what are some characteristics of assembly code? Especially, how do they differ from C? Well, first of all, there’s a number of different sort of integer data types of size 1, 2, 4, and 8 B. In integer data types, they don’t distinguish signed versus unsigned, how it gets stored, and even an address or a pointer is just stored as a number in a computer and doesn’t have any special significance to it. A floating point is handled in a very different way, on the other hand, with a different set of registers that I think I’ll talk about very briefly in one of the later lectures, the program itself is in x 86. It’s just a series of bytes. And I’ll show you some examples of those and things like arrays and structs and things that you think of as fundamental data types don’t exist at the machine level, constructed artificially by the compiler Later in the course.<br>那么，汇编代码的一些特征是什么？特别是，它们与C有什么不同？嗯，首先，有许多不同类型的整数数据类型，大小为1、2、4和8 B。在整数数据类型中，它们不区分有符号和无符号，也不区分它是如何存储的，甚至一个地址或指针只是作为一个数字存储在计算机中，对它没有任何特殊意义。一个浮点以一种非常不同的方式处理，另一方面，使用一组不同的寄存器，我想我会在后面的讲座中非常简要地谈论，程序本身是在x86中。这只是一系列的字节。我将向您展示一些示例，例如数组、结构以及您认为是基本数据类型的东西，这些东西在机器级别上是不存在的，稍后在课程中由编译器人为构建。</p>
<p>发言人   35:35<br>In these lectures, we’ll cross over into how that’s actually done as well. So some of the things you know about Inc exist here and some of them are sort of have to be built up in layers on top of the assembly level program.<br>在这些讲座中，我们将深入探讨这实际上也是如何做到的。因此，您所了解的有关Inc的一些事情存在于这里，其中一些必须在组装级程序的基础上分层构建。</p>
<p>发言人   35:54<br>So the other thing about assembly level programming is each instruction is very, very limited in what it can do. It can move data from a register to memory from, or it do an addition or a multiplication or something like that, but can really basically only do one thing and. So you have to write a whole. If you were writing it by hand, you’d have to write a whole series of instructions to get anything done. And that’s part of the reason why it’s really much better to let the compiler do that. And we’ll also see there’s sort of how things like do loops while loops. Conditionals, switch statements, those are all built up on top of some other lower level features in the instructions. So for this function, some store actually, it gets encoded by a total of 14 B.<br>因此，汇编级编程的另一件事是，每条指令所能做的事情非常非常有限。它可以将数据从寄存器移动到内存，或者进行加法、乘法或类似的操作，但实际上只能做一件事。所以你必须写一个完整的。如果你是手写的话，你必须写一整套的指令来完成任何事情。这就是为什么让编译器这样做真的要好得多的部分原因。我们还将看到像做while循环这样的事情。条件语句、switch语句，这些都是建立在指令中的一些其他较低级别功能之上的。所以对于这个函数，实际上有些存储，它被总共14 B编码。</p>
<p>发言人   36:57<br>And so one thing about x 86 is some instructions are as short as 1 B, but others can be as long as 15 B in the encoding.<br>关于x86的一点是，有些指令短至1 b，但有些指令在编码中可长达15 b。</p>
<p>发言人   37:16<br>Like I said, each instruction really typically only does one thing. So for example, in C, if you say star dust equals t, what that will typically, and not always, but the sort of way to think about that at the machine level, is it t or some local value would be typically stored in a register. And as you know, in C, if you put star in front of it, you want it referenced as a pointer. And if that reference is on the left, you want to store a number a value at that place where you’re pointing to. So what would typically happen is dust, the actual pointer value would also be stored in a register here in register rbx. And I use a move instruction to say, take the value from one register, which is called Rax here, and store it in the memory location that’s specified by another register. So you see the idea, we’ll go into more detail about all these register names and what the parentheses mean.<br>就像我说的，每个指令通常只做一件事。因此，例如在C中，如果你说星尘等于t，那通常会是什么，并不总是如此，但在机器级别上考虑这个问题的方式是，它是t还是一些本地值通常存储在寄存器中。而且如你所知，在C中，如果你在它前面放了星星，你希望它被引用为指针。如果该引用在左侧，则您希望在指向的那个位置存储一个值。所以通常会发生的是灰尘，实际的指针值也将存储在这里的寄存器rbx中。并且我使用移动指令说，从一个寄存器 (这里称为Rax) 中取出值，并将其存储在由另一个寄存器指定的内存位置中。所以你明白了这个想法，我们将更详细地介绍所有这些寄存器名称以及括号的含义。</p>
<p>发言人   38:20<br>You get the rough idea that a move instruction is saying can refer to either a register or a memory location, And the actual object code representation of this is just 3 B where the first byte. Tells that? And we won’t even talk much in this course about how the instructions are encoded, won’t generally let programs do that for us, but in this case, it only takes 3 B to write that particular instruction. So how can we know that kind of stuff? How can we figure out that level of detail?<br>你得到了大致的想法，即一个move指令可以引用一个寄存器或一个内存位置，而实际的目标代码表示形式只是3 b的第一个字节。告诉我？在这门课中，我们甚至不会过多地谈论指令是如何编码的，通常不会让程序为我们做这件事，但在这种情况下，编写特定的指令只需要3 b的时间。那么我们怎么知道那种东西呢？我们如何计算出这种程度的细节？</p>
<p>发言人   39:00<br>Well, there’s some really useful tools that let you examine machine code, even if you don’t have a copy of the original C file or even the assembly code file ahead of time. And there’s one called a disassembler. So an assembler goes from this text version of instructions to a byte level representation, and a disassembler just reverses that. Here is a series of bytes, and I, the disassembler, know that this particular byte sequence refers is a move instruction, and so it will now print out on the screen to say, oh, that was a move instruction. And so it basically reverse engineers from the object code back to the assembly code or something, sort of like the assembly code. You’ll see it lost. Well, it’s very slightly different.<br>嗯，有一些非常有用的工具可以让你检查机器码，即使你事先没有原始C文件甚至汇编代码文件的副本。还有一种叫做反汇编程序。所以汇编器从指令的文本版本转换为字节级的表示形式，而反汇编器则相反。这是一系列字节，而反汇编程序知道这个特定的字节序列引用的是一个移动指令，因此它现在将在屏幕上打印出来说，哦，那是一个移动指令。因此，它基本上将目标代码反向工程回到汇编代码或类似汇编代码的东西。你会看到它丢失了。嗯，这有点不同。</p>
<p>发言人   39:59<br>One thing also to notice, I should mention about assembly code is all those, all the names I used, all the names of variables are completely lost at the assembly code level. At the machine code level, things are just, they’re in registers, they’re somewhere in memory. The program has no understanding of your original source code at that level, and so the disassembled is just a way to go backward. And you can do that yourself. And you’ll find that useful in various contexts. To do that yourself? Things kind of monkeying around me. So if I compile the sum program.<br>还有一件事需要注意，我应该提到汇编代码，所有我使用的名称，所有变量的名称都在汇编代码级别完全丢失了。在机器代码层面上，事物只是，它们在寄存器中，它们在内存中的某个地方。该程序在那个级别上无法理解您的原始源代码，因此反汇编只是一种倒退的方式。你可以自己做。你会发现这在各种情况下都很有用。你自己做吗？我周围的事情有点像小人。所以如果我编译求和程序。</p>
<p>发言人   41:05<br>So if I do the more standard thing you do in using a compiler, you say run the compiler, give it some optimization, tell what the source files are, and tell it where to put the final executable code. Terribly clever. I call the function sum. And so sum is a binary file. Of 8663 B, you’ll see off on the left, it’s marked as executable and it actually works. I can add numbers together with it. That’s your sort of standard executable program, excuse me.<br>所以如果我使用编译器做更标准的事情，你说运行编译器，给它一些优化，告诉它源文件是什么，并告诉它在哪里放置最终的可执行代码。非常聪明。我调用函数sum。所以sum是一个二进制文件。对于8663 B，您将在左侧看到，它被标记为可执行，并且实际上可以工作。我可以和它一起相加。这是您的标准可执行程序，对不起。</p>
<p>发言人   41:48<br>And if I run a program called object dump. And ask it to disassemble. It can do various things. It will spit out a disassembled version of the program, and it will fly by on the screen. But if I redirect that to some file. Which I already did. I’ll remove the old one.<br>如果我运行一个名为对象转储的程序。并要求它拆卸。它可以做各种各样的事情。它会吐出一个拆解版本的程序，然后在屏幕上飞过。但是如果我将其重定向到某个文件。我已经做了。我会把旧的去掉。</p>
<p>发言人   42:21<br>And now I look at that. You’ll see that it has what I described as is the disassembled representation of the program, including some files that some functions that you didn’t write has ones that are sort of the low level functions that are used in the initial start-up of a program called init.<br>现在我看看这个。你会看到它具有我所描述的程序的反汇编表示，包括一些你没有编写的函数的文件，这些文件是在名为init的程序的初始启动中使用的低级函数。</p>
<p>发言人   42:46<br>Oops. But here, somewhere in the middle of it, you’ll see, lo and behold, is that program, that function, some sort that got compiled? And you can see that what it did was it took this 14 B from the. Object code. And it picked those apart and came back with what instructions? Those bytes and coat. So for example, the push instruction only takes a single byte. The move, as you saw before, takes 3 B. This call, because it has to give the a location of where to call, is a 5 B instruction and so forth.<br>哎呀。但是在这里，在它中间的某个地方，你会看到，你看，那个程序，那个函数，某种被编译的东西吗？你可以看到它的作用是拿走了14 B。目标代码。然后它把这些拆开，带回来什么指示？这些字节和外套。例如，push指令只占用一个字节。这个动作，正如你之前看到的，需要3 B。这个调用，因为它必须给出一个调用的位置，是一个5 B指令等等。</p>
<p>发言人   43:37<br>But again, the disassembly didn’t have access to the source code. It didn’t have access even to the assembly code. It figured this out just by the bytes in the actual object code file. So this is the way, if you ever want to know, actually, the byte level encoding, this is how you figure it out, is to run a program, run it through an Asse, get object code, and then come back out with it.<br>但是，再次强调，该拆解程序无法访问源代码。它甚至没有访问汇编代码的权限。它仅通过实际目标代码文件中的字节来解决这个问题。所以这就是方法，如果你想知道，实际上，字节级编码，这就是你如何解决的方法，就是运行一个程序，通过一个Asse运行它，获得目标代码，然后回来处理它。</p>
<p>发言人   44:06<br>There’s another way you can do it. Using the debugging program, which you’ll get to know very well in the next web you’re going to do. And it’s called gdb. And Gdb is a very powerful debugging program that you can examine and step through and operate on programs in. And again, if the source code for it’s available, it will make use of it. But it also can be used on programs for which there’s no source available.<br>你还有另一种方法可以做到。使用调试程序，您将在下一个网站中非常了解该程序。它被称为gdb。并且Gdb是一个非常强大的调试程序，您可以在中检查、逐步执行和操作程序。再次强调，如果它的源代码可用，它将利用它。但它也可以用于没有可用源代码的程序。</p>
<p>发言人   44:44<br>But one of the features is the ability to disassemble functions in there. So if I say disassemble. Some store, it’ll come back with something that looks a lot like what you saw from Object dump, a listing of the instructions. And here it just shows in hex what the addresses of those different instructions are. It doesn’t show the byte level encoding. So my point here is there’s various tools that let you look at a program, even if its actual representation is a binary file that you don’t want to examine directly.<br>但其中一个特点是能够反汇编其中的功能。所以如果我说拆卸。有些商店，它会返回一些看起来很像您从对象转储中看到的指令清单的东西。在这里，它只是以十六进制的形式显示这些不同指令的地址。它不显示字节级编码。所以我的观点是，有各种工具可以让你查看程序，即使它的实际表示是你不想直接检查的二进制文件。</p>
<p>发言人   45:38<br>And just plug this in.<br>然后把这个插上。</p>
<p>发言人   45:46<br>So what this slide shows is what I just showed you on the screen, which is what the object dump program produces for this function. And this is a version showing what Gdb would show you for and with Gdb, if you want to actually get the bytes out, you can do that. You can basically, for any address, you can just give an address and tell it to display some number of bytes. So this rather cryptic command to Gdb says examine 14 B in hex format starting at the address of the function some store. And it produced something that looks like what you see on the left.<br>所以这张幻灯片所展示的就是我刚刚在屏幕上向您展示的内容，也就是对象转储程序为此功能所生成的内容。这是一个展示Gdb将向您展示的版本，如果您想实际获取字节，您可以这样做。基本上，对于任何地址，您只需提供一个地址并告诉它显示一些字节数。所以这个相当神秘的Gdb命令说检查14 B以十六进制格式从函数的地址开始存储。它产生了一些看起来像你左边看到的东西。</p>
<p>发言人   46:36<br>In fact, disassembly is a tool that can be used as part any of reverse engineering tools. And I used to demo this by showing a disassembly of Windows of Microsoft Word. I had a PC back then, not a Mac, but some people. And our slides are online and so we got some nasty grams from people saying, you know, you’re violating the Microsoft end user license agreement when you do that because you’re supposed to. You don’t know this, but remember all those quick through, I agree things, but you never read one of them is I agree not to try to reverse engineer any Microsoft product. So this technically, so I’ve served just for modesty, I blanked this out.<br>事实上，反汇编是一种工具，可以用作任何逆向工程工具的一部分。我曾经通过展示微软Word窗口的拆解来演示这个。那时我有一台电脑，不是Mac，而是一些人。我们的幻灯片是在线的，所以我们得到了一些来自人们的恶意信息，他们说，你知道，当你这样做时，你违反了微软的最终用户许可协议，因为你应该这样做。你不知道这一点，但请记住所有那些快速通过的东西，我同意，但你从来没有读过其中的一个是我同意不要试图对任何微软产品进行逆向工程。所以从技术上讲，我服务只是为了谦虚，我把它空白了。</p>
<p>发言人   47:27<br>But you can actually do it if you can find where the file is. It’s sort of obscure where the actual executable files of an application are. My point is that word like any other. Application you run is just an executable file. And that executable file is just a bunch of bytes that encode instructions. So let’s go a little bit further into this assembly level programming business.<br>但是如果你能找到文件的位置，你实际上可以做到这一点。应用程序的实际可执行文件在哪里有点模糊。我的观点是这个词和其他任何词都一样。你运行的应用程序只是一个可执行文件。而这个可执行文件只是一堆编码指令的字节。因此，让我们进一步探讨这个汇编级编程业务。</p>
<p>发言人   47:58<br>So I keep talking about regist and X 8664 has this totally quirky set of registers. And it’s a reflection, again, of this sort of evolutionary history to it. But you’ll see that there’s 16 registers that you can use to hold integers and pointers. And some of them have these sort of alphabetic names, and some of them have numeric names. I’ll show you why in a minute. And also for each register, if you use the sort of percent r name of it, you’ll get 64 b. But if you use the percent e version of it, you’ll get 32 b. And what you’ll find in programs that manipulate long ints, you’ll see the use of r, and if they’re just int 32 b things, you’ll see code saying percent E, so you’ll see both of these show up.<br>所以我一直在谈论regist，而X 8664有这个完全古怪的寄存器集。这再次反映了这种进化历史。但是你会看到有16个寄存器可以用来保存整数和指针。其中一些有字母名称，一些有数字名称。我会在一分钟内告诉你为什么。而且对于每个寄存器，如果您使用它的百分比名称，您将获得64 b。但是如果你使用它的百分比e版本，你将得到32 b。你会在操纵长整数的程序中发现什么，你会看到r的使用，如果它们只是int 32 b的东西，你会看到代码显示百分比E，所以你会看到这两个出现。</p>
<p>发言人   48:54<br>And it’s fairly important to remember that percent E version is just the low order 32 b of a larger percent R entity. And in fact, it goes beyond that.<br>而且相当重要的是要记住，百分比E版本只是更大的百分比R实体的低阶32 b。事实上，它不止于此。</p>
<p>发言人   49:08<br>You can also reference the lower order 16 b and the low order 2 b. I’m sorry, onete bytes and 1 B. Within each of these registers as well. But again, think of these as like named locations where you can store values and you can retrieve values from them and you. I’m sort of personifying machine level programming here, not you personally. We’ll actually have to explicitly name those registers for the most part to say where things should go, where they should come out of. It’s not like a memory where you just give a number to tell where to look for. You could compute a number, each one is identified separately.<br>您也可以参考较低的阶16 b和较低的阶2 b。对不起，一个字节和1 B。在这些寄存器中也是如此。但是，请再次将这些视为命名位置，您可以在其中存储值并从中检索值。我在这里有点人格化机器级别的编程，而不是你个人。我们实际上必须明确命名这些寄存器，大部分是为了说明事物应该去哪里，它们应该从哪里出来。这不像一个记忆，你只需要给出一个数字来告诉你去哪里寻找。你可以计算一个数字，每个数字都是单独标识的。</p>
<p>发言人   50:01<br>So just as a little bit of history. With i.e. 32, so we just talked about there being eight registers, all the percent E versions. And one of the changes that went from IA 32 to X 8664 was to double the number of registers. And by the way, this is a really helpful thing because it was very frustrating how few registers there were in the old I 32 machines.<br>所以只是一点点历史。与e.32，所以我们刚刚谈到有八个寄存器，所有的百分比版本。从IA 32到x8664的变化之一是将寄存器数量增加了一倍。顺便说一下，这是一件非常有帮助的事情，因为在旧的i32机器中几乎没有寄存器，这非常令人沮丧。</p>
<p>发言人   50:37<br>As I mentioned. You could actually, in the old machine, refer to the low order 16 B of these registers. And that was a legacy from the 80, 86 days. And within the first four, you could even refer to the individual two or or bytes in those. So nowadays, you can actually get to the low order byte of all of them. And we just sort of that’s covered in the book.<br>正如我所提到的。实际上，在旧机器中，您可以参考这些寄存器的低阶16 B。那是80、86天的遗产。在前四个中，你甚至可以引用其中的单个两个或字节。所以现在，你实际上可以得到所有这些的低位字节。我们只是在书中涵盖了这一点。</p>
<p>发言人   51:10<br>Actually. We don’t talk about how you can get to these bytes because that’s really a legacy from back before the Ad 86 was one called the.<br>实际上。我们不谈论如何获得这些字节，因为这实际上是在Ad 86之前的遗留问题。</p>
<p>发言人   51:25<br>8080, which was an 8 B machine. So anyways, you can see then how you got from this kind of weird state of affairs to the even weirder state that we are in today, where some of them have names and some of them have numbers. And those names, by the way, had a reason back in ancient days. They had very specific purposes. And so they were given names that sort of reflected those purpose. But that all went away years and years ago. And so now these names are just legacy names, have nothing to do with their purpose.<br>8080，是一台8 B的机器。无论如何，你可以看到你是如何从这种奇怪的状态发展到今天更奇怪的状态的，其中一些人有名字，一些人有数字。顺便说一下，这些名字在古代是有原因的。他们有非常具体的目的。于是他们被命名，反映了这些目的。但这一切都在多年前就消失了。所以现在这些名称只是传统名称，与它们的用途无关。</p>
<p>发言人   52:11<br>Now, I should mention only there are some, there’s one special register nowadays as shown in pink here, and that’s called the stack pointer. And that register, you don’t just use any old way you please. It has a very specific purpose. And all the other registers, there’s some that are slightly different than the other, but for the most part, they’re all usable for holding program data. Back in the i.e. 32 days, there was a register called the base pointer that also got used for procedures, but that no longer gets used anymore either, at least not usually. So anyways, I don’t want to spend a lot of time on historic legacy stuff. Have you memorized what feature was added and what model of processor? But just in case you’re wondering why there these weird names for these things, so you appreciate the fact that this is a legacy thing.<br>现在，我应该提到的只是一些，现在有一个特殊的寄存器，在这里以粉红色显示，那就是堆栈指针。那个寄存器，你不只是使用任何旧的方式。它有一个非常具体的目的。和所有其他寄存器一样，有一些与其他寄存器略有不同，但在大多数情况下，它们都可用于保存程序数据。回到过去。在32天内，有一个名为基本指针的寄存器也被用于过程，但它也不再被使用了，至少通常不会。所以无论如何，我不想花太多时间在历史遗留的东西上。你是否记得添加了什么功能以及处理器的型号？但以防万一你想知道为什么这些东西有这些奇怪的名字，所以你很感激这是一个遗留的东西。</p>
<p>发言人   53:12<br>OK, so now we can think of it then, that there’s eight registers with names, and there’s eight registers that are indicated by some number. And let’s look at some of the instructions that operate on those registers. And there’s sort of three different. So the move instruction in x 86 is actually can do a lot of things. Because it can take different types of information or what they call operands. So the source is where you’re copying from the source to the destination. The source can be some what’s called immediate. It’s actually a number that’s baked into the program that you want to copy into some other location, a register we’ve talked about as one of these specially named memory locations.<br>好的，现在我们可以想象一下，有八个带有名称的寄存器，其中八个寄存器由某个数字表示。让我们来看看在这些寄存器上操作的一些指令。有三种不同的类型。所以x86中的移动指令实际上可以做很多事情。因为它可以接受不同类型的信息或他们所谓的操作数。源是你从源复制到目标的地方。来源可以是一些所谓的即时的。它实际上是一个嵌入程序中的数字，您想要复制到其他位置，我们谈论过的寄存器是这些特别命名的内存位置之一。</p>
<p>发言人   54:10<br>And memory is the array of bytes that you typically you have to specify what’s the address that you’re either reading from, if it’s the source, or you’re writing to if it’s the destination. And so the move instruction gives you all these possibilities.<br>而内存是一个字节数组，你通常需要指定你从哪个地址读取，如果它是源，或者如果它是目标，你要写入到哪个地址。因此，移动指令为您提供了所有这些可能性。</p>
<p>发言人   54:30<br>An immediate value can be written to a register or directly to memory. A register value can be copied to another register. Or written to memory? Or you can take a value from memory, read it from memory, and copy it to a register.<br>立即值可以写入寄存器或直接写入内存。一个寄存器的值可以被复制到另一个寄存器。还是写给记忆？或者你可以从内存中取出一个值，从内存中读取它，然后将它复制到一个寄存器。</p>
<p>发言人   54:48<br>So if you think of, wait, shouldn’t there be 9 different combinations here? Well, no, because it doesn’t make sense to have an immediate value as a destination. It’s a constant. And also just for sort of the sake of convenience of the hardware designers, it doesn’t let you directly copy from one memory location to another. What you have to do is use two instructions, one to copy from memory to read it from memory, copy it to a register, and a second to take that value in the register and write it to memory. So that’s why there’s this only five possibilities. And so each of these actual 5 combinations you’ll see in some form or another.<br>所以如果你想到，等等，这里不应该有9种不同的组合吗？不，因为作为目的地具有即时价值是没有感知的。这是一个常数。而且只是为了方便硬件设计人员，它不允许您直接从一个内存位置复制到另一个内存位置。你需要做的是使用两条指令，一条指令从内存中复制并读取，然后复制到寄存器中，第二条指令将寄存器中的值写入内存。这就是为什么只有五种可能性。因此，您将以某种形式看到这五个实际组合中的每一个。</p>
<p>发言人   55:35<br>So for example, if I take a constant value and copy it to a register, it’s a little like you can think of registers, sort of the temporary data that you’re operating on right now. So it’s a way of sort of assigning a constant value to a temporary. Similarly, if you have memory as your destination, it’s like storing a constant value in memory somewhere. If you’re copying from one register to another, it’s sort of like copying one temporary value to another one register to memory. It’s as if you, it’s sort of like storing to an address, a pointer dereference where the pointer is on the left side. The dereference and memory to register is the opposite. You’re reading from some location into a temporary position. So these, you’ll see all five versions get used in some form or another.<br>因此，例如，如果我取一个常量值并将其复制到寄存器中，这有点像你可以想象的寄存器，它是你现在正在操作的临时数据。所以这是一种将常量值分配给临时值的方式。同样，如果你将内存作为目的地，就像在内存的某个地方存储一个常数值一样。如果你正在从一个寄存器复制到另一个寄存器，这有点像将一个临时值复制到另一个寄存器到内存。这就好像你，有点像存储到一个地址，指针在左侧的指针引用。取消引用和记忆注册是相反的。你正在从某个位置阅读到一个临时位置。所以这些，你会看到所有五个版本都以某种形式使用。</p>
<p>发言人   56:40<br>So now let’s talk about how we write these pointers, how we specify either a source or a destination for a memory reference. And you already saw one version of this, in fact, in some of the code, when you put the name of a register in parentheses, that’s just saying, use this register, whatever is in that, that’s an address, and use that address to reference some memory location. And so you’ll see something like this is the equivalent of dereferencing a pointer and putting it in a temporary. You’re also allowed to do a little bit of arithmetic to derive an address from some collection of registers and other constant values. So if you see a number, it’s called the displacement d in front of this parentheses. It means to offset, not use the address that’s in the register, but add or subtract some number from it to get an address that’s just slightly off of it by some fixed amount. And that, we’ll see, is fairly useful for accessing different data structures.<br>现在让我们来谈谈如何编写这些指针，如何为内存引用指定源或目的地。实际上，您已经在一些代码中看到了这个版本，当您将寄存器的名称放在括号中时，这只是说，使用此寄存器，其中的任何地址，并使用该地址引用某些内存位置。所以你会看到这样的东西，相当于取消对指针的引用并将其放入临时文件中。你还可以进行一些算术运算，从一些寄存器和其他常量值的集合中推导出地址。所以如果你看到一个数字，它被称为这个括号前面的位移d。它的意思是偏移，不使用寄存器中的地址，而是从中添加或减去一些数字，以获得与它稍微偏离一些固定数量的地址。而且，我们将看到，对于访问不同的数据结构非常有用。</p>
<p>发言人   57:51<br>So here’s an example of a very simple function that we can understand everything about it already, because we know what the move instruction does. And that’s the sort of classic swapping of two values that are stored in memory. So my arguments are two pointers called XP and yp, and I’m going to dereference those pointers. I’m going to read from memory into registers, and then I’m going to copy back to memory, reversing the two destinations. And so as you can imagine, it lines up to be 4 move instructions that correspond to these four references.<br>这是一个非常简单的函数的例子，我们已经可以理解它的所有内容，因为我们知道移动指令的作用。这就是存储在内存中的两个值的经典交换。所以我的参数是两个指针XP和yp，我将取消引用这些指针。我将从内存中读取寄存器，然后将两个目标反向复制到内存中。所以你可以想象，它会排成4条移动指令，对应于这四个引用。</p>
<p>发言人   58:38<br>And the final one just we’ll learn more about functions and how they’re called, just think of the red as it gets you. It returns from wherever the calling position was. And so let’s look at more detail the actual code then. And so it turns out with the x 86 64.<br>最后一个我们将了解更多关于函数以及它们如何被调用的信息，只需想象一下红色的部分。它从呼叫位置所在的任何地方返回。那么让我们来看看实际代码的更多细节。因此，对于x86 64来说，情况就是这样。</p>
<p>发言人   59:08<br>Arguments always come in some specific registers, and the ones to remember for today is RDI will be the first argument register and Rs will be the second argument register. There can be up to six of these, and we’ll go into more of that later. So those two registers represent the values of XP and yp. Those are set before the function is actually begins executing. That’s set by the part of the code that calls this function. And those will be pointers. So what they are is they contain addresses that specifying locations in memory, and then within the code, the compiler just came up with its own ideas of how to use different registers for temporary data by whatever what’s known as the register allocation algorithm it uses.<br>自变量总是出现在一些特定的寄存器中，今天要记住的是RDI将是第一个参数寄存器，Rs将是第二个参数寄存器。最多可以有六个，稍后我们会详细讨论。所以这两个寄存器代表了XP和yp的值。这些是在函数实际开始执行之前设置的。这是由调用此函数的代码部分设置的。这些将是指针。所以它们包含指定内存中位置的地址，然后在代码中，编译器想出了自己的想法，如何通过任何所谓的寄存器分配算法来使用不同的寄存器来存储临时数据。</p>
<p>发言人   01:00:01<br>And we don’t really care. We just what we’ll want to do is figure out what it’s doing, and we’ll see that a register X is being used to hold the value of t 0 and RDX the value t 1.<br>我们并不在乎。我们想做的就是弄清楚它在做什么，然后我们会看到一个寄存器X被用来保存t0的值，RDX则是t1的值。</p>
<p>发言人   01:00:18<br>Now, so let’s get actually concrete here. And this is very detailed, but I think it’s important that you understand, sort of you can almost simulate the execution of some instructions by yourself. You’re going to really have to know this stuff. So what each of these instructions is doing and how it works, and really have that wired into you pretty well.<br>现在，让我们在这里变得更具体一些。这非常详细，但我认为重要的是你要理解，你几乎可以自己模拟一些指令的执行。你真的必须知道这些东西。那么这些指令中的每一个在做什么以及它是如何工作的，并且真的很好地融入你的思想中。</p>
<p>发言人   01:00:42<br>So let’s make up an example. Let’s imagine that the two addresses that are used for these two pointers in hex 1, 2 0, and 1 0 0, by the way, those would not be typical addresses. They’re way too small a number, but it’s much easier to use them as an illustration. And let’s suppose that one of them held the value 1, 2, 3, and the other 4, 5, 6. So the first instruction says use RDI as an address copy from that memory location and store the result and register rrx. So RDI is 120. I’ll read from that address. I’ll read the value 123 and store it and register Rix.<br>那么让我们举一个例子。让我们想象一下，十六进制1、2 0和1 0中用于这两个指针的两个地址，顺便说一下，这不是典型的地址。它们是一个太小的数字，但用它们来作为说明要容易得多。让我们假设其中一个持有值1、2、3，而另一个持有值4、5、6。所以第一条指令说，使用RDI作为从该内存位置复制的地址，并存储结果并注册rrx。所以RDI是120。我会从那个地址读出来。我将读取值123并存储它并注册Rix。</p>
<p>发言人   01:01:28<br>These are all, by the way, 8 B values. And I’m just sort of glossing over that part of it. But the Q refers to what an Intel terminology is, a quad word, a word, because it goes back to the 8086 Te bits, 2 B. Long word is 32 b and a quad word is 64 b. The terminology, and we’re stuck with it.<br>顺便说一下，这些都是8 b的值。我只是在掩盖这一部分。但是Q指的是英特尔的术语，一个四字，一个字，因为它可以追溯到8086 Te位，2 b。长单词是32 b，四单词是64 b。术语，我们被它束缚住了。</p>
<p>发言人   01:02:02<br>Okay, so that one instruction had that effect. The second instruction does the same thing, but using RSI, which holds 100 as an addressed, and so it copies 456 into RDX. And then the third instruction is writing back to memory. So its source is register RDX. The destination has the address of RDI, which is 120, and it’s storing that back in memory. And finally, this fourth instruction does the other part of the right, so you see these four instructions 2 read from memory into registers, two of them wrote from registers back to memory. And that’s the whole function.<br>好的，那一条指令有这种效果。第二条指令做同样的事情，但是使用RSI，它将100作为地址，因此它将456复制到RDX中。然后第三条指令是写回内存。所以它的来源是寄存器RDX。目标地址为RDI，即120，并将其存储在内存中。最后，第四条指令执行右边的另一部分，因此您会看到这四个指令2从内存读取到寄存器，其中两个指令从寄存器写入内存。这就是整个功能。</p>
<p>发言人   01:02:51<br>And you can see this move instruction is doing all the work here. So we’ve shown that example, just showed this very simple memory referencing that’s designated by the parentheses. And as I mentioned, you can do a version where you put a displacement there too. And in fact, there’s a much more elaborate form.<br>你可以看到这个移动指令正在完成这里的所有工作。所以我们已经展示了这个例子，只是展示了这个由括号指定的非常简单的内存引用。正如我提到的，你可以做一个版本，在那里也放置一个位移。事实上，还有一种更复杂的形式。</p>
<p>发言人   01:03:15<br>And we’ll see that this is useful for implementing array references where there can be actually two registers involved. And there can be a displacement, which is a constant offset, and a scale factor, which will be 1, 2, 4, 8. And the general idea of it is to take register that I’m referring to as R sub I, that’s known as an index register. You multiply it by the scale factor, you add the value of RB, register RB, and you also add the constant displacement. And these have a RB to base. RI is index and S is scale. And it turns out this will be the sort of natural way to implement array reference, and it will make a lot more sense when we talk about arrays.<br>我们将看到，这对于实现可能涉及两个寄存器的数组引用非常有用。并且可以有一个位移，它是一个恒定的偏移，和一个比例因子，它将是1、2、4、8。它的一般想法是取我称之为R sub I的寄存器，也就是所谓的索引寄存器。你将它乘以比例因子，你将RB的值相加，寄存器RB，还可以加上恒定位移。这些有一个RB基础。RI是索引，S是规模。事实证明，这将是实现数组引用的自然方式，当我们谈论数组时，这将更加感知。</p>
<p>发言人   01:04:11<br>But basically, you can think of as if this is an array index. I have to typically scale it by however many bytes my data type is. So if it’s an int, I have to scale it by 4. If it’s long, I have to scale it by 8. So that’s where the scale factors will come in. And basically, the format in the assembly code letsgo eliminate some of these fields if they’re not being used.<br>但基本上，你可以把它想象成数组索引。我通常必须按照我的数据类型多少字节来缩放它。所以，如果它是一个int，我必须将其缩放到4。如果它很长，我必须按8的比例缩放。这就是比例因素所在。基本上，汇编代码中的格式letsgo会消除一些字段，如果它们不被使用的话。</p>
<p>发言人   01:04:44<br>So we already saw the single parentheses is sort of a reduced version of this form. So let’s just do some examples of these address computations. And let’s imagine that register RDX holds he f with three zeros and rcx holds one with two zeros. Rather than doing it one at a time, you can see each of these.<br>所以我们已经看到单括号是这种形式的简化版本。那么让我们来举一些地址计算的例子。让我们假设寄存器RDX将f保存为三个零，而rcx将一个保存为两个零。与其一次做一个，你可以看到每一个。</p>
<p>发言人   01:05:11<br>I’m taking RDX, which is f with three zeros, adding 8. And so that’s f 0 0 8. Here I’m adding together registers, RDX and rcx, and that gives me F1 thousand. I’m doing the same here, except that I’m scaling rcx by 4. So four times 1, 0 is 4, 0 0, and I’m adding that to f, and here I’m taking RDX, which is f 0 with three zeros. If I double that, I get 1 e with three zeros. If you think about shifting and f to the left one, you get a one, and then it goes 1, 1, 1, 0, and that’s an e, and then I’m adding this displacement of 8, 0 to it.<br>我正在使用RDX，它是带有三个零的f，加上8。所以这就是f 0 0 8。在这里，我将寄存器RDX和rcx相加，这给了我F1千。我在这里做同样的事情，除了我将rcx缩放了4。所以四乘1，0是4，0 0，我把它加到f上，这里我得到RDX，它是带有三个零的f 0。如果我加倍，我会得到1个带有三个零的e。如果你考虑向左移动f，你会得到一个1，然后它会变成1，1，1，0，这就是一个e，然后我将这个位移加上8，0。</p>
<p>发言人   01:06:01<br>So the point of this is all of this is arithmetic. It’s all using whatever is in the register. And there’s some rules for how you combine this and get an address. And then that’s being used to either read or write some memory location. Okay, so now as a final part of it, today I’ll go through some arithmetic.<br>所以重点是所有这些都是算术。这一切都在使用寄存器中的任何东西。并且有一些规则可以规定如何组合这些并获得地址。然后它被用于读取或写入一些内存位置。好的，现在作为最后一部分，今天我将进行一些算术运算。</p>
<p>发言人   01:06:26<br>And one of the things that will be sure to confuse you and drive you crazy and make you be sending email to the staff for explanation is an instruction called load effective address. And the reason is its purpose in life is to do basically the ampersand operation of C to compute an address based on some whatever you want to compute an address from. But it also turns out to be a pretty handy way to do arithmetic. And the C compiler likes to use it. So in particular.<br>有一件事肯定会让你感到困惑、让你发疯，并让你向工作人员发送电子邮件进行解释，那就是所谓的加载有效地址说明。原因是它在生活中的目的基本上是做C的 &amp; 运算，根据你想从中计算地址的任何东西来计算地址。但这也证明是一种相当方便的算术方法。而C编译器喜欢使用它。尤其如此。</p>
<p>发言人   01:07:03<br>The format of it looks like a move instruction. There’s a source and a destination, but the destination has to be a register. And the source will be one of these memory references. So it looks like a move instruction.<br>它的格式看起来像一个移动指令。有一个来源和一个目的地，但目的地必须是一个寄存器。并且来源将是这些内存引用之一。所以它看起来像一个移动指令。</p>
<p>发言人   01:07:21<br>It looks like you’re doing some address computation, then you’re reading from memory and store to a register. But what it actually does is it does that, avers computation, and then it actually writes that address, not the memory value, but the value that got computed directly to the register, which is what you want to do here.<br>看起来你正在进行一些地址计算，然后你正在从内存读取并存储到寄存器。但它实际上做的是，它会进行计算，然后它实际上将该地址写入寄存器，而不是内存值，而是直接计算所得的值，这就是你想在这里做的。</p>
<p>发言人   01:07:44<br>Remember, the ampersand operation is give me the address of some place, give me a pointer that designate some location, so for example. X by 12, it’ll turn it into an. Address computation. And this is just a clever way to compute three times RDI adds RDI plus two times RDI. So that’s three times RDI and stores it in Rax. And then cell Q means shift left by two. And so you remember shifting up by two is like multiplying by 4. So the first value computed three times x, I shift that left by two positions, and I have 12 times x. So that’s a very special the Lea, but you’ll see it all over the place. So you need to be ready for it.<br>请记住，&amp; 操作是给我某个地方的地址，给我一个指定某个位置的指针，例如。X乘以12，它会把它变成一个。地址计算。这只是一种计算三次RDI和两次RDI相加的聪明方法。所以这是三次RDI并将其存储在Rax中。然后单元格Q表示向左偏移2。所以你记得，向上移动2就像乘以4一样。所以第一个值计算为x的三倍，我将其左移两个位置，我有12倍的x。所以这是一个非常特别的Lea，但你会在各个地方看到它。所以你需要为此做好准备。</p>
<p>发言人   01:08:50<br>These other ones look more like what you’d expect for arithmetic instructions. They have names like add and subtract and multiply and so forth, and they all have the same general format that they have two arguments.<br>这些其他的看起来更像你所期望的算术指令。它们的名称像加减法和乘法等等，它们都有相同的一般格式，即它们有两个参数。</p>
<p>发言人   01:09:04<br>And what’s called the destination is actually also a source. It’s a little like NC if you say x plus equals y, it’s saying take the value of x, add the value of y, and then store the resultant x, and now the destination is like that. The other thing that’s weird is that the operands are in the inverse order from where you’d expect them to be. So the source comes first and the destination comes last. And that’s important to remember. And other thing you’ll see that there’s nothing special here, whether it’s except that this is an arithmetic shift, and this is a logical shift of whether it’s assigned or unsigned value.<br>所谓的目的地实际上也是一个来源。这有点像NC，如果你说x加等于y，它说的是取x的值，加上y的值，然后存储结果x，现在目的地就是这样。另一件奇怪的事情是操作数的顺序与你期望的相反。所以源头是第一位的，目的地是最后一位。这很重要要记住。还有一件事，你会发现这里没有什么特别的，无论是算术移位，还是无符号值的逻辑移位。</p>
<p>发言人   01:09:48<br>Because you remember the bit level of behavior of these two instructions is the same. And then there’s a series of instructions that are used that are just take one operand, increment, decrement, negate, and not not is like the tilde operation in C, not the ex exclamation mark. So those are the basic instructions.<br>因为您记得这两条指令的行为位级别是相同的。然后有一系列的指令被使用，只需要一个操作数，递增、递减、求反，而不是像C中的波浪符号操作一样，而不是感叹号。这些是基本指示。</p>
<p>发言人   01:10:15<br>And again, now we can actually look at some programs and understand them. And here’s one that just does a bunch of junk of arithmetic instructions. And it converts into the following assembly code. And you see it’s using this Lea instruction multiple times to do addition in various forms. And it also has shifting and it has multiplication. You saw in the original code, I just have addition and multiplication. Here I have various instructions, I only have one multiplier, whereas I had two there. So the compiler is sort of scrambling things around, trying to find clever ways to implement what you’re asking for using less, less time consuming instructions.<br>再一次，现在我们可以实际查看一些程序并理解它们。这里有一个只是做一堆无用的算术指令的。并将其转换为以下汇编代码。你可以看到它正在多次使用这个Lea指令来以各种形式进行加法。它也有移位和乘法。你在原始代码中看到的，我只有加法和乘法。这里我有各种指令，我只有一个乘法器，而我有两个乘法器。所以编译器有点混乱，试图找到聪明的方法来实现你所要求的更少，更少耗时的指令。</p>
<p>发言人   01:11:07<br>And if you sort of go through this code carefully, what you’ll find is that this instruction here corresponds to this computation of T 1. It’s adding two values and giving it a new name. It’s putting in rax. Similarly, this one is adding z to T 1, storing it back in Rax.<br>如果你仔细阅读这段代码，你会发现这里的这条指令对应于t1的计算。它将两个值相加，并给它一个新名称。它正在放入rax。同样地，这个是将z添加到t1中，并将其存储回Rax中。</p>
<p>发言人   01:11:33<br>The x plus 4 doesn’t show up directly here. It turns out what it does is it jumps right ahead here and multiply y by 48. It does it by first computing 3 y, like we saw before, and computing shifting that left by 4, because three times 16 is 48. And then the four here, that’s in x plus 4 actually shows up here. It just uses the displacement field of this computation to add 4 to some other values. And so this is labeled. And these comments show how these correspond to the program, and these registers show it.<br>这里没有直接显示x加4。事实证明，它所做的就是跳到这里，然后将y乘以48。它首先计算3 y，就像我们之前看到的那样，然后将其向左移动4，因为3乘16是48。然后这里的四个，即x加4实际上显示在这里。它只是使用此计算的位移场将4添加到其他一些值。所以这被标记了。这些注释显示它们如何与程序相对应，这些寄存器显示它。</p>
<p>发言人   01:12:14<br>So the important thing to get from here, you will want to actually go back through this and make sure you believe the comments are correct, but it’s very important for you to figure out this Lea instruction. Otherwise you’re just going to be hopelessly confused. And it’s also important to understand that the code that gets generated will correctly implement your C function, but it might not exactly replicate at a low level the exact sequence of operations he specified at a high level. So that will just to summarize then, you’ve already gotten a glimpse then of what this very odd, a world of machine programming is and how different it is from C code already.<br>因此，从这里得到的重要的事情是，您需要实际返回并确保您相信注释是正确的，但对您来说，弄清楚这个Lea指令非常重要。否则你只会感到无可救药的困惑。而且同样重要的是要理解生成的代码将正确实现您的C函数，但它可能无法在低级准确复制他在高级指定的操作序列。所以这只是为了总结一下，你已经瞥见了这个非常奇怪的机器编程世界是什么，以及它已经与C代码有多么不同。</p>
<p>发言人   01:13:03<br>So you’ve already seen that x 86 is weird. Like I said, it’s English ISS, Latin, it’s not. Well designed. And but you just got to deal with that. So that’s your beginning to machine level programming, thanks a lot.<br>所以你已经看到了x86是奇怪的。就像我说的，这是英语，拉丁语，它不是。设计得很好。但你只需要处理这个问题。这就是你开始机器编程的起点，非常感谢。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>深入理解计算机系统 005-Machine-Level Programming I, Basic</div>
      <div>http://example.com/2025/10/12/15213-005/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月12日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/12/15213-006/" title="深入理解计算机系统 006-Machine-Level Programming II, Control">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">深入理解计算机系统 006-Machine-Level Programming II, Control</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/12/15213-004/" title="深入理解计算机系统 004-Floating Point">
                        <span class="hidden-mobile">深入理解计算机系统 004-Floating Point</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
