

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="发言人   00:00Okay? So continuing on with the saga of machine level programming, we’re in number four of our series of this. And I think that the total will be 5. So we’re almost through, and I’ve realiz">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解计算机系统 008-Machine-Level Programming IV, Data">
<meta property="og:url" content="http://example.com/2025/10/12/15213-008/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="发言人   00:00Okay? So continuing on with the saga of machine level programming, we’re in number four of our series of this. And I think that the total will be 5. So we’re almost through, and I’ve realiz">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-12T02:00:07.000Z">
<meta property="article:modified_time" content="2025-10-12T13:03:45.021Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>深入理解计算机系统 008-Machine-Level Programming IV, Data - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="深入理解计算机系统 008-Machine-Level Programming IV, Data"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-12 10:00" pubdate>
          2025年10月12日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          15k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          130 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">深入理解计算机系统 008-Machine-Level Programming IV, Data</h1>
            
            
              <div class="markdown-body">
                
                <p>发言人   00:00<br>Okay? So continuing on with the saga of machine level programming, we’re in number four of our series of this. And I think that the total will be 5. So we’re almost through, and I’ve realized this is a lot of material for the course. It’s essentially a third of the course if you think about, well, no, not that much, but it’s a lot of the course and part that we consider very central to it. A lot of this involves, since we’re talking about a particular machine, the Intel X 86, 64 machines, a lot of it’s kind of low level, nitty gritty stuff. But part of what we hope you also are understanding is some of the general principles involved, too. And you’ll find if you move from this machine to another machine.<br>好吗？所以继续机器级别编程的传奇，我们在这个系列的第四个。我认为总数将是5。所以我们几乎完成了，我意识到这门课程需要很多材料。这基本上是课程的三分之一，如果你想一想，嗯，不，不是那么多，但这是我们认为非常核心的很多课程和部分。很多都涉及，因为我们谈论的是特定的机器，即英特尔x86、64机器，其中很多都是低级的、细节丰富的东西。但我们希望您也能理解其中的一些一般原则。如果你从这台机器移动到另一台机器，你会发现。</p>
<p>发言人   00:53<br>Sort of learning your first assembly language is your hardest one. Learning successive ones a lot easier. So today we’re going to talk about data representations. We so far, all the programs we’ve looked at have been either. Just manipulating integers or long integers and pointers. So that’s all what we’d call scalar data, Data that is not in any aggregated form.<br>在某种程度上，学习第一种汇编语言是最难的。学习连续的要容易得多。所以今天我们要谈论数据表示。到目前为止，我们看过的所有节目都是。只是操作整数或长整数和指针。这就是我们所说的标量数据，即不以任何聚合形式存在的数据。</p>
<p>发言人   01:20<br>Today, we’ll look at places where data gets collected into you, put together multiple data elements, and then see there’s really two ways to do that. One is with arrays, where you can create many copies or many copies of an identical data type. You can have an array of ints, an array of pointers. A second is where you have struct. So you create a small collection of values that can be of different data types, and each one you access by its name or a tag, and it turns out those definitions can be recursive. So you can have arrays of structs and structs with arrays and Nest to an arbitrary degree. And what we’ll see is both how it’s represented in the machine memory and also then what the code looks like that will manipulate these different data structures.<br>今天，我们将看看数据被收集到你的地方，将多个数据元素放在一起，然后看看有两种方法可以做到这一点。一种是使用数组，您可以创建多个副本或多个相同数据类型的副本。你可以有一个int数组，一个指针数组。第二步是你有结构的地方。因此，您创建了一个小的值集合，这些值可以是不同的数据类型，并且每个值都可以通过其名称或标记进行访问，结果发现这些定义可以是递归的。因此，您可以拥有结构数组和带有数组的结构，并以任意程度嵌套。我们将看到的是它在机器内存中的表示方式，以及操纵这些不同数据结构的代码的样子。</p>
<p>发言人   02:17<br>And the main thing to see is that. At the machine code level, there’s no notion of an array that you’d have at a high level, except to think of it as a collection of bytes that you can are in contiguous part of storage. And same with a struct. It’s just allocated as a collection of bytes. And it’s the job of the C compiler, then, to generate the appropriate code to allocate that memory to.<br>最重要的是看到这一点。在机器代码级别上，除了将其视为可以位于存储的连续部分的字节集合外，在高层次上没有数组的概念。结构也是如此。它只是分配为字节集合。然后，这是C编译器的工作，生成适当的代码来分配该内存。</p>
<p>发言人   02:50<br>Get the right value When you refer to some element of a struct or an array. But the good news is, this is such a common type of requirement for a programming language that the machine gives you sort of instructions that you’ll see. Now they make perfect sense. They’re exactly designed for this particular class of applications. So we’ll talk about rays first and then structures or structures. And I’ll also mention we do a I’ll give you a glimpse of floating point today too, because it’s worth knowing how floating point arithmetic is implemented as well on a machine.<br>当您引用结构或数组的某些元素时，请获取正确的值。但好消息是，这是编程语言的常见要求，机器会给你一些你会看到的指令。现在他们做出完美的感知。它们正是为这类特定应用而设计的。所以我们先讨论光线，然后是结构或结构。我还会提到我们做了一个，今天我也会给你一个浮点数的一瞥，因为了解如何在机器上实现浮点算术是值得的。</p>
<p>发言人   03:32<br>So the basic idea of array allocation is fairly straightforward If you have an array with n elements, then that’s represented by enough bytes in memory all in 1 span to hold that much data. So if the underlying data type, say it’s an int or a care, is a single a data type. So to have a array of 12 cares takes 12 B and int takes 4 B. So have an array of 5 ints takes 20 B, you get the idea. You just multiply the size, the underlying data type, by the number of elements. And that’s how big the array has to be in terms of bytes. And we’ve already seen then in the care is 1 B, and it is 4. A double or a long would be 8 B, and so it be a pointer, all different amounts of storage.<br>因此，数组分配的基本思想相当简单，如果你有一个具有n个元素的数组，那么这将由内存中足够的字节在1个跨度中表示，以容纳这么多的数据。因此，如果基础数据类型 (例如它是一个int或一个关心) 是一个单一的数据类型。因此，拥有一个由12个关心组成的数组需要12个B，而int需要4个B。所以有一个5个整数的数组需要20个B，你明白了。你只需要将大小、基础数据类型乘以元素数量即可。这就是数组的字节大小。我们已经看到，在护理中是1 B，它是4。double或long将是8 B，因此它是一个指针，所有不同的存储量。</p>
<p>发言人   04:33<br>And you see in this diagram, we use, the x denotes the starting address of the beginning of this region of memory. So we can use address computation to compute offsets. By adding numbers to X to get the address of particular elements of this array. And that’s exactly what the code does. So in general, then, if you imagine an array A has some underlying type T, what the elements of the array are, and some number of elements in that array in the declaration l? We will, that declaration actually does two things. One is it allocates enough bytes of storage to hold the entire array. And the second, from a programming language perspective, the identifier of the array A can in some ways be treated like a pointer that you can do pointer arithmetic off of it.<br>你可以看到在这个图表中，我们使用，x表示这个内存区域开始的起始地址。所以我们可以使用地址计算来计算偏移量。通过将数字添加到X以获取此数组中特定元素的地址。而这正是代码所做的。所以，一般来说，如果你想象一个数组A有一些底层类型T，数组的元素是什么，以及在声明中数组中的一些元素数量l？我们会，这个声明实际上做两件事情。一种是分配足够的存储字节以容纳整个阵列。第二，从编程语言的角度来看，数组的标识符在某种程度上可以被视为一个指针，你可以从中进行指针算术。</p>
<p>发言人   05:37<br>And that’s one of the features of C that is was fairly unique to see when it was created and is still unique to this day, this idea of the sort of interchangeability of pointers and arrays, array identifiable.<br>这是C的特性之一，在创建时是相当独特的，直到今天仍然是独一无二的，这种指针和数组可互换的思想，数组可识别。</p>
<p>发言人   05:54<br>So for example, I can use an array notation to say val of 4, element 4 of this array. And it’s a five element array. So that would just be this final element. But I can also just refer to Val and its underlying data type is as an star. So pointer to ints and its value would be x, it’s just a pointer. A pointer is, remember, an address, and it’s just the address at the beginning of the array. And I can do pointer arithmetic val, which, as you know in C, and this is a little confusing, we’ll go back and forth.<br>因此，例如，我可以使用数组表示法来表示此数组的元素4的val。它是一个五元素数组。所以这只是最后一个元素。但我也可以只引用Val，其基础数据类型为星号。所以指向int的指针及其值将是x，它只是一个指针。请记住，指针是一个地址，它只是数组开头的地址。我可以做指针算术val，正如你在C中所知道的那样，这有点令人困惑，我们将来回讨论。</p>
<p>发言人   06:36<br>Because in C, when you do pointer arithmetic, like you say, p plus plus for a pointer, let me just give you an example. So if you had something like K star p as a declaration, and you said p is equal to some string s, and then you say p plus plus, so you’re incrementing that pointer. In this case, you’re incrementing it by one because the underlying data type is. Is a care? But if you said something like in star I’ll call it IP.<br>因为在C中，当你进行指针算术时，就像你说的那样，p加号代表指针，让我给你一个例子。所以，如果你有一个像K star p这样的声明，你说p等于一些字符串s，然后你说p加号，所以你增加了那个指针。在这种情况下，您将其递增一，因为基础数据类型是。这是一种关心？但是如果你说了像星星这样的东西，我会称之为IP。</p>
<p>发言人   07:23<br>I different pen.<br>我不同的笔。</p>
<p>发言人   07:36<br>And I said, you know IP plus plus, then IP would get IP plus. What does anyone know? 4, yes. So it’s a confusion in C, this, remember, is the same as saying IP plus equals 1. But what you’re actually doing is incrementing the number of the value of p by 4, because you want a pointer When you jump from one place to another, you want it to increment by enough bytes to point to the next integer, in this case for IP. And so similarly, val plus 1 denotes this value x plus 4, because it’s the address of the next integer in the array.<br>我说，你知道IP加加，那么IP就会得到IP加。有人知道什么？4，是的。所以这是C中的一个混淆，记住，这与说IP加等于1是一样的。但是你实际要做的是将p的值的个数增加4，因为当你从一个地方跳到另一个地方时，你想要一个指针，你想要它增加足够的字节以指向下一个整数，在这种情况下是IP。同样，val加1表示这个值x加4，因为它是数组中下一个整数的地址。</p>
<p>发言人   08:41<br>By the way, the one thing different between an array and a pointer is I can’t say val plus plus, I can’t change the value of val. It’s fixed by the declaration, whereas a pointer, I can increment it, I can change it in various ways. And similarly, ampersand val of two says, give me the address of the second element of the array. So that would be at x plus 8. And this is, again, one of the fundamental properties of c that.<br>顺便说一下，数组和指针之间的一个不同之处是我不能说val加，我不能改变val的值。它由声明修复，而指针，我可以递增它，我可以以各种方式更改它。同样，两个与号符的val表示，给我数组第二个元素的地址。所以这将是x加8。这也是c的基本属性之一。</p>
<p>发言人   09:24<br>Basically in C, if you take a pointer.<br>基本上在C中，如果你拿一个指针。</p>
<p>发言人   09:39<br>That’s weird?<br>这很奇怪？</p>
<p>发言人   09:44<br>This is an I, not very well written. These are equivalent statements. There are just two notations for the same thing. So on the upper part, it says IP plus two, meaning actually 8 to IP, and then dereference set. It’s the same as finding the second element of array, an imaginary array where IP indicates the beginning of the array. So that’s a very fundamental principle of C, that, again, this whole idea of point arithmetic is fairly unique to see question.<br>这是一个I，写得不是很好。这些是等价的语句。同一事物只有两种符号。因此，在上部，它说IP加2，实际上意味着8到IP，然后取消引用设置。这与查找数组的第二个元素相同，这是一个虚构的数组，其中IP指示数组的开头。所以这是C的一个非常基本的原则，再次强调，点算术的整个思想在问题中是相当独特的。</p>
<p>发言人   10:26<br>Pardon, yes. The compiler will happily let you use negative values for array indices, and it will give you a potentially undefined value. But there’s nothing in C that prevents you from giving out of bounds either. Numbers that are too big for an array or too small for an array. There’s no bounds checking in.<br>对不起，是的。编译器会很高兴让你对数组索引使用负值，它会给你一个可能未定义的值。但是C中也没有任何东西阻止你越界。对于数组来说太大或太小的数字。没有边界检查。</p>
<p>发言人   10:59<br>So the question is becoming, what about negative indices? And the answer is very simple, because in other words, in general, something like IP plus x, maybe, can you see this? Should I turn on? Kind of bright is really equivalent to IP plus 4x. So this is the notation. And it’s really hard to read, isn’t it? And the right hand side is a computation.<br>那么问题就变成了，负指数怎么办？答案非常简单，因为换句话说，一般来说，像IP加x这样的东西，也许，你能看到这个吗？我应该打开吗？有点亮真的相当于IP加4x。所以这是符号。而且它真的很难读懂，不是吗？右侧是一个计算。</p>
<p>发言人   11:49<br>In C, you write it using, you don’t have to give scaling factors for your data types, otherwise it would drive you out of your mind, but you secretly underneath, when the compiler generates the code, we’ll see examples of this. It’s scaling everything. So now the question that is being asked is, what if x is a negative number? Well, the rule still applies, it’s just the final result will be less than IP instead of greater than IP, but it’s totally valid C, and there’s actually times you will use it in this term, I can promise you yes question.<br>在C中，你使用编写它，你不必为你的数据类型提供缩放因子，否则它会让你离开你的头脑，但是你秘密地在下面，当编译器生成代码时，我们会看到这样的例子。它正在扩展一切。现在被问到的问题是，如果x是负数怎么办？好吧，规则仍然适用，只是最终结果将小于IP而不是大于IP，但它是完全有效的C，实际上有时你会在这个术语中使用它，我可以向你保证是问题。</p>
<p>发言人   12:33<br>No, you can’t write two plus IP, try it. I’m pretty sure you can’t do that with point arithmetic. If somebody wants to type in some code and do it, I don’t think you can do that, but if you did, it would have to figure it out. The parser knows the data types of its two arguments. So yeah, you could probably do it. I’ve never seen this. You could do it, but the compiler would know that one of the arguments is a pointer and therefore scale the other.<br>不，你不能写2加IP，试试吧。我很确定你不能用点算术做到这一点。如果有人想输入一些代码并执行它，我认为你做不到，但如果你做到了，它必须自己解决。解析器知道它的两个参数的数据类型。所以，是的，你可能可以做到。我从未见过这个。你可以这样做，但编译器会知道其中一个参数是指针，因此会缩放另一个参数。</p>
<p>发言人   13:02<br>What you can’t do is add two pointers, you can take the difference of two pointers, this is obscure. I’m not even going to tell you about this, we’ll get up in K and R, but you can do arithmetic. But you can, for addition, it can only be one pointer and one, and then the other has to be a regular integer value, and it will scale it appropriately. So I believe you can do it. It’s just somebody will smack you on the back of the hand if you actually write code it that way, but not the compiler. In particular?<br>你不能做的是添加两个指针，你可以取两个指针的差异，这是模糊的。我甚至不会告诉你这个，我们会得到K和R，但你可以做算术。但是你可以，另外，它只能是一个指针和一个，另一个必须是常规整数值，它会适当地缩放它。所以我相信你能做到。如果你真的这样写代码，只是有人会打你的手背，而不是编译器。特别是？</p>
<p>发言人   13:39<br>If you go beyond the bounds of an array, you’ll get whatever is beyond the bounds of that array. And it might be an invalid, or it might not even be a valid address. And you get a segmentation fault. But more typically, you’ll get some. Whatever happens to be there, that’s not so bad when you read it. But you can also potentially write it, as we saw before, and corrupt data that’s already in the memory. So here’s, again, the same statement I was making before that IP val, plus I just get scaled. The value computed would be the starting address plus four times whatever I is.<br>如果你超出了一个数组的界限，你将得到超出该数组界限的任何东西。它可能是无效的，或者甚至可能不是有效的地址。你会得到一个段错误。但更典型的是，你会得到一些。不管那里发生了什么，当你读到它的时候并不是那么糟糕。但是你也有可能像我们之前看到的那样编写它，并破坏已经在内存中的数据。所以这又是我在那个IP val之前做的同样的声明，而且我只是被缩放了。计算的值将是起始地址加上I的四倍。</p>
<p>发言人   14:25<br>Look, so that’s all. See, everything I said before is basic C of stuff. Now let start looking at it, the actual machine code involved. And so I made up this example here where I declare.<br>看，这就是全部。看，我之前说的一切都是基本的东西。现在让我们开始研究它，涉及到实际的机器码。所以我在这里做了这个例子，我声明。</p>
<p>发言人   14:44<br>Three arrays, each with 5 nths, and I go through what is considered sort of good form when you’re building up data that instead of having arbitrary constants sprinkled, three year program, often called magic numbers, that you instead use a pound define, and you give it some meaningful name and some documentation, usually at the top of a file or in a Doh file. And then the type D is a very handy way if you’re going to create complex data structures, I highly recommend you sort of break that into type depths because the declaration notation and C gets fairly obscure fairly quickly, but all this is saying is the data type I’m going to call a zip did is defined to be 5, an array of 5 ints. And now whenever I say zip did something I’m just popping down. I’m saying this is an array of 5 ins, and so I created three of them with the appropriate zip codes for the schools represented here, and now I’m just making up for sake of presentation actual addresses, these in general, you don’t have any control over that. And I made it up so that they all happen to be in contiguous part of memory. And again, there’s no fundamental reason that should be true, so you can never trust what particular address anything is ever going to be allocated at, but you are certain that each of these blocks will be a contiguous collection of 20 B.<br>三个数组，每个数组有5个n，当你构建数据而不是任意常量散布时，我经历了一种被认为是好的形式，三年的程序，通常被称为幻数，你使用磅定义，并给它一些有意义的名称和一些文档，通常位于文件的顶部或多个文件中。如果您要创建复杂的数据结构，那么类型D是一种非常方便的方法，我强烈建议您将其分解为类型深度，因为声明符号和C很快就会变得相当模糊。但这一切都表明，我要称之为zip的数据类型被定义为5，一个由5个整数组成的数组。现在，每当我说zip做了什么，我就会突然跳下来。我是说这是一个由5个元素组成的数组，所以我创建了其中的三个，并为这里所代表的学校提供了适当的邮政编码，现在我只是为了展示实际的地址而弥补，这些地址通常是你无法控制的。我编了这个，使它们恰好都在记忆的连续部分。再说一次，没有根本的原因是正确的，所以你永远不能相信任何东西将被分配到哪个特定的地址，但你可以肯定这些块中的每一个都是20 b的连续集合。</p>
<p>发言人   16:24<br>So here’s some example code then to say I want to retrieve for one of these arrays, I want to retrieve element whose index is digit. And this gets turned into the following code. So remember the first argument, which will be a pointer now. RDI and the second it will be will be passed in register Rs. And what I want to get out of this is an int. And so you see that here’s where that scaled addressing, this is exactly what it was designed for and why, why they went to the trouble of adding this sort of fancy address modes to x 86? Because this is such a common thanks.<br>这里有一些示例代码，说明我想检索其中一个数组，我想检索索引为数字的元素。这将转换为以下代码。所以记住第一个参数，现在它将是一个指针。RDI和第二个将在寄存器Rs中传递。我想要从这里得到的是一个整数。所以你可以看到这就是缩放寻址的地方，这正是它的设计目的，为什么他们费心将这种花哨的地址模式添加到x86？因为这是一种常见的感谢。</p>
<p>发言人   17:14<br>So remember, what this says is take RDI and add to it what you get by multiplying RSI by 4. So you scale that, and of course, that’s exactly the computation we want to do if we compare it to this is what we’re trying to get computed it’s exactly.<br>所以请记住，这说的是将RDI乘以4，然后将得到的RSI相加。所以你可以扩展它，当然，这正是我们想要做的计算，如果我们将其与我们试图得到的计算进行比较，这就是我们想要得到的计算。</p>
<p>发言人   17:38<br>It’s exactly this computation here. And that gives us an address. And then we’re reading from that address, and we’re going to copy it in EA. Remember, this is an int, so it will be in the E version, the lower 4 B of register rax. And that’s all the code it takes to implement this particular operation. Yes, so RDI is the base address.<br>这就是这里的计算。这给了我们一个地址。然后我们从那个地址读取数据，我们将把它复制到EA中。请记住，这是一个int，因此它将在E版本中，即寄存器rax的下部4 b。这就是实现这个特定操作所需的所有代码。是的，所以RDI是基址。</p>
<p>发言人   18:06<br>We multiply by 4 and p plus RR SI on the right side. Yeah, this is a typo, thank you, thanks for pointing that out. I’ll make a note of that. Right, so this slide is incorrect, and I’ll fix that. So this should be RDI plus 4 RSI, right? Thanks for noting that. Let me make it.<br>我们乘以4，右边的p加上RR SI。是的，这是一个错字，谢谢，谢谢你指出这一点。我会把它记下来的。对，所以这张幻灯片不正确，我会修正的。所以这应该是RDI加4 RSI，对吧？谢谢你注意到这一点。让我来。</p>
<p>发言人   18:38<br>Okay? And so now let’s just look at another. Just some code. In particular, what if I wanted to go through one of these arrays and for every element of the array add 1 to it? So increment single element by one? Well, first of all, you can see that we’re setting up a loop and it uses the jump to middle business, where the initial part is to jump to the test. And all the testing involves we’re using Rax is for I here, and we’re incrementing it and comparing it at various places.<br>好吗？所以现在让我们来看看另一个。只是一些代码。特别是，如果我想遍历其中一个数组，并且对于该数组的每个元素添加1，该怎么办？那么，单个元素递增一个？首先，您可以看到我们正在设置一个循环，它使用跳转到中间业务，其中初始部分是跳转到测试。所有测试都涉及我们在这里使用Rax，我们将其递增并在不同的地方进行比较。</p>
<p>发言人   19:30<br>Here’s the line of code that does all the real work. Again, taking the i-th element, which I is in Rax, scaling it by four, adding it to the base of the array, and that gives us an address. And now remember, you can have an arithmetic instruction where the second operand, the destination, is a memory reference. And what this actually requires is to first read the original value from the memory, do the addition, and then store the result back in memory. So this one instruction is exactly doing this plus operation on this stored data in the array.<br>这是做所有实际工作的代码行。再次，获取第i个元素，即我在Rax中的第I个元素，将其缩放四，将其添加到数组的底部，这就给了我们一个地址。现在记住，你可以有一个算术指令，其中第二个操作数，目标，是一个内存引用。这实际上需要的是首先从内存中读取原始值，进行加法，然后将结果存储回内存中。所以这一条指令正在对数组中存储的数据进行这个加法操作。</p>
<p>发言人   20:24<br>By the way, I should mention the whole idea of pointer arithmetic. And C was C was really people who had programmed in assembly code for most of their lives thinking about how could I make this look like a high level language, but keep all the flexibility, all the tricks I learned to play an assembly code in a programming language? Because it was designed, it was originally designed to implement an operating system, the Unix operating system. And historically operating systems were written directly in assembly code and these people kernighan and Richie and Dennis Richie realize that the way to do this is to sort of build point arithmetic into a programming language. So anyways, the reason I’m saying this is you see a pretty close correspondence here between instructions in machine code and constructs in a program in the C programming language, And that whole plus operator and plus equals is sort of something you see variations of assembly weight code.<br>顺便提一下，我应该提到指针算术的整个概念。而C实际上是那些在大部分时间里都在用汇编代码编程的人，他们思考着如何让这看起来像一种高级语言，但保留了我在编程语言中学习汇编代码的所有灵活性和技巧？因为它的设计初衷是为了实现一个操作系统，即Unix操作系统。历史上，操作系统是直接用汇编代码编写的，这些人kernighan、Richie和Dennis Richie意识到做到这一点的方法是在编程语言中构建点算术。无论如何，我这么说的原因是，你可以在这里看到机器码中的指令和C语言程序中的构造之间的非常接近的对应关系，而且整个加号运算符和加号等于是你可以看到汇编重量代码的变化。</p>
<p>发言人   21:37<br>Okay? So that’s a sort of single dimension array. And I’d like to just. Change things up a little bit by having us look at what the real difference is between arrays and pointers in a programming language in C? And so I have a couple of these examples that I’ll bring out one by one. But the idea of this is you see the declaration on the left is something called a one and something called a two. So call those a sub n, and now what I want to know for each of these is, doesn’t compile, is this a valid statement in C?<br>好吗？所以这是一种单维数组。我只是想这样做。通过让我们看看在C语言编程语言中数组和指针之间的真正区别，可以稍微改变一下事情。所以我有几个这样的例子，我会一个接一个地提出来。但是这个想法是你看到左边的声明是称为一的东西，被称为二的东西。因此，将这些称为子n，现在我想知道的是，每个都不编译，这是C中的有效语句吗？</p>
<p>发言人   22:29<br>Second, would this potentially give me a null pointer reference? Because I’m referencing a pointer for which I haven’t actually allocated space for the that that pointer is indicating, I haven’t initialized the pointer to a valid memory reference. And then finally, if I were to use the size of operator on that particular. Value with that, including for the case where there’s a star in front of it.<br>其次，这会给我一个空指针引用吗？因为我正在引用一个指针，而我还没有为该指针分配空间，所以我还没有将该指针初始化为有效的内存引用。最后，如果我要在那个特定上使用运算符的大小。价值，包括在它前面有一颗星星的情况下。</p>
<p>发言人   23:12<br>And part of this is to understand the difference, then, between an array and a pointer. The main reason, the main factor is an array. When you declare an array in C, you’re both, you’re actually allocating space. Space is being allocated somewhere for it, and you’re creating allowed to now use the array name in pointer arithmetic. Whereas when you just declare a pointer, all you’re allocating is the space for the pointer itself and not for anything that it’s you’re pointing too.<br>其中一部分是理解数组和指针之间的区别。主要原因，主要因素是数组。当你在C中声明一个数组时，你们都是，实际上是在分配空间。空间正在分配给它的某个地方，您正在创建允许现在在指针算术中使用数组名称。而当你只是声明一个指针时，你所分配的只是指针本身的空间，而不是指针指向的任何东西。</p>
<p>发言人   23:55<br>Just you’ve probably figured out that these both compile. Let me get my cheat sheet, Andy, but what would be the size of a 1 here? If I ran the size of operator on it.<br>只是你可能已经发现它们都可以编译。让我拿我的备忘单，Andy，但是这里1的大小是多少？如果我在上面运行了操作员的大小。</p>
<p>发言人   24:26<br>Let’s do the easier one. What’s the size of a 2? 8, because it’s a pointer. What’s the size of a A’s? An array of 3 ints 12, right?<br>让我们做更容易的那一个。2的大小是多少？8，因为它是一个指针。a的大小是多少？一个3个12的数组，对吧？</p>
<p>发言人   24:50<br>And those aren’t. No, oops.<br>而那些不是。不，哎呀。</p>
<p>发言人   24:58<br>And now if I said star A one or star a two, those would both compile.<br>现在，如果我说了star A 1或star a 2，它们都会编译。</p>
<p>发言人   25:14<br>Could either of them possibly give you a dereference?<br>他们中的任何一个可能给你一个引用吗？</p>
<p>发言人   25:27<br>Oh yes, the pointer itself is null, but. I haven’t dereferenced it yet. It’s a null pointer, but it’s not a potentially bad reference. It’s not a runtime. I won’t create a runtime error if I just say a two in my code, so you’re step ahead of me, basically. So you kind of answered the second question, though, this one could give you a null pointer error if you try to dereference a pointer that hasn’t been initialized, it doesn’t point to anything, whereas this one is fine.<br>哦，是的，指针本身是空的，但是。我还没有取消引用。它是一个空指针，但它不是一个潜在的错误引用。它不是运行时。如果我在代码中只是说a 2，我不会创建运行时错误，所以你基本上领先于我一步。所以你有点回答了第二个问题，但是，如果你尝试取消引用一个没有初始化的指针，它可能会给你一个空指针错误，它没有指向任何东西，而这个没问题。</p>
<p>发言人   26:04<br>And now what’s the size of a one of of star A 1, 4, and what about star A 2, 4? Yeah, because they’re both pointers to ints. So one way to think about that as a picture a one. It’s like we’ve been showing here. It’s an array of four ints. And when I declare a one I’m allocating also the program is allocating 12 B of storage that’s able to hold that. A 2, on the other hand, is just a pointer. Which I’ll show there, and so it’s 8 B long, but it doesn’t point to anything. So that’s what I meant, that if you tried to say star a two, you’d potentially have a null pointer dereference there.<br>现在一颗1，4星的大小是多少，而一颗2，4星的大小是多少？是的，因为它们都是指向整数的指针。因此，有一种方式可以将其视为一张图片。就像我们一直在这里展示一样。它是一个由四个整数组成的数组。当我声明一个我正在分配的存储时，程序也分配了12 B的存储空间来容纳它。另一方面，2只是一个指针。我会在那里展示它，所以它有8 B长，但它没有指向任何东西。所以这就是我的意思，如果你试图说star a 2，你可能会在那里有一个空指针取消引用。</p>
<p>发言人   27:11<br>And so that’s why this is 8, and this is Wolff. So those were the warm up one. So let’s make it a little more interesting.<br>所以这就是为什么这是8，这是沃尔夫。所以那些是热身的。让我们把它变得更有趣一些。</p>
<p>发言人   27:29<br>These aren’t in the slides, you’ll notice, but I’ll update the slides to include these later. But I think the point that if you find this confusing, it’s a sign that you really, really, really need to understand what a pointer is and what an array is, and how they’re the same and how they’re different because it. It’s a core part of programming in C that will lead to endless hours of confusion if you don’t really have this wired down pretty strongly. So let me just give you a preview of what’s self interestings about. This is I’m going to give you some numbers, and then we’re going to have to explain how those numbers come around.<br>这些不在幻灯片中，您会注意到，但我稍后会更新幻灯片以包括这些内容。但我认为，如果你发现这令人困惑，那就是一个迹象，你真的需要理解指针和数组是什么，以及它们是如何相同的，以及它们是如何不同的。它是用C编程的核心部分，如果你没有非常强烈地对此进行连接，它将导致无尽的混乱。那么让我给你一个关于自我兴趣的预览。这就是我要给你一些数字，然后我们将不得不解释这些数字是如何产生的。</p>
<p>发言人   28:34<br>Okay? So let’s try and understand what’s happening here. And you see that all of these declarations involve some combination of pointer and array. And the question is, is it pointer to an array? Is it an array of pointers? And the answer to those will depend on the particular syntax.<br>好吗？让我们试着了解这里发生了什么。你会发现所有这些声明都涉及指针和数组的某种组合。问题是，它是指向数组的指针吗？它是一个指针数组吗？这些问题的答案将取决于特定的语法。</p>
<p>发言人   29:00<br>So of course, the first one is one you’ve already seen before. And so, you know that compiles, and it’s not null, and you can dereference it, and it’s not null. But if you tried to say star, star a one, that’s not valid, it won’t even compile because you’re trying to here take the data type of star A is int, and then you’re trying to take a dereference an int. So that won’t compile, and therefore you can’t even test it.<br>当然，第一个是你之前已经见过的。所以，你知道编译时，它不是空的，你可以取消引用它，它也不是空的。但是如果你试图说star，star a one，这是无效的，它甚至不会编译，因为你在这里尝试采用star的数据类型是int，然后你试图取消引用一个int。这样就无法编译，因此你甚至无法测试它。</p>
<p>发言人   29:35<br>Okay, the question is, for these other three, you can see that. Somehow one is, well, let’s look at the bottom two first. So the one on the bottom says that, and this is part of, and there’s actually a really great section in Carnegie Richie that I highly encourage you how to read pointers, how to read declarations and see. And the basic rule is you start from the inside and you work your way outwards. So that declaration of a three says that. With that parentheses, it says a three is a.<br>好的，问题是，对于其他三个，你可以看到。不知何故，一个是，好吧，让我们先看看底部的两个。所以底部的那个说，这是其中的一部分，实际上在Carnegie Richie中有一个非常棒的部分，我强烈鼓励你如何阅读指针，如何阅读声明并查看。基本规则是你从内部开始，然后向外工作。所以三号的宣告是这样说的。用那个括号，它说3是a。</p>
<p>发言人   30:27<br>What is a three?<br>什么是三？</p>
<p>发言人   30:35<br>A 3 is a pointer that two parentheses around it, what does it point to, It points to an array of three ints. So we can diagram a 3 then.<br>3是一个指针，周围有两个括号，它指向什么，它指向一个由三个整数组成的数组。所以我们可以绘制一个3。</p>
<p>发言人   30:57<br>To be? Something like this?<br>要成为？像这样的东西？</p>
<p>发言人   31:14<br>Is a, like I said, read it from the inside out. A 3 is a pointer.<br>就像我说的，从里面读出来。3是指针。</p>
<p>发言人   31:23<br>And what does it point to, it points to an array of three elements. And what type of elements are they there ins? So you’re sort of reading outward and picking up pizzas from the right and from the left as you do this. And so when you know that this all makes sense, that these numbers, the size of a 3 itself is 8. But since it points to an array of three ints, the size of star A 3 is 12. And then star star A 3 would indicate this particular element of the array. And so it size is 4. So these all compile. But which of them could cause a null pointer dereferences which of the last two?<br>它指向什么，它指向一个由三个元素组成的数组。它们是什么类型的元素？这样你就可以向外阅读，从右边和左边拿起披萨。所以当你知道这一切都是感知的时候，这些数字，3本身的大小就是8。但是由于它指向一个3个整数的数组，所以星号A 3的大小是12。然后星号为3表示数组的这个特定元素。所以它的大小是4。所以这些都编译。但是它们中哪一个会导致空指针取消引用，最后两个中哪一个？</p>
<p>发言人   32:19<br>Guess you can flip coins, yes? Well I’m only looking at I’m trying to fill in a three right now. So a 3 is fine. But if I said star a 3, could that have a null pointer problem, yes. Why, because when I declare a three here, all I’m declaring is this particular. I’m only allocating enough storage for that pointer. I haven’t allocated the space for an array. I haven’t initialized a 3 to actually point an array, so it could be a null pointer, it could be an arbitrary junk, but the chances of it actually pointing to an array of three ins is highly unlikely. So this would be potentially bad. And therefore, double star is doubly bad, right?<br>猜猜你可以抛硬币，对吧？好吧，我现在只看我正在尝试填写三。所以3号很好。但是如果我说了星号a 3，那可能有空指针问题吗，是的。为什么？因为当我在这里声明三个时，我所声明的只是这个特定的。我只为那个指针分配了足够的存储空间。我还没有为数组分配空间。我还没有将3初始化为指向一个数组，所以它可能是一个空指针，也可能是一个任意的垃圾，但它实际上指向一个由三个数组组成的数组的可能性极小。所以这可能是不好的。因此，双星是双倍糟糕的，对吗？</p>
<p>发言人   33:17<br>So now let’s look at a four. So a 4. To understand that, you actually have to look at the. Charts in C, the precedent chart, which if you’re like me, your book falls open to that precedent. ISS chart the different operators and what levels they are. And one thing you’ll see is that level one of precedents, the highest precedents, includes square brackets, and level 2 includes star. In other words, bracket is higher precedence since star. So this particular statement here, the binding is actually like this. It says that a four is an array of three elements. And those elements are pointers. And they point to ints.<br>现在让我们来看看四个。所以是4。要理解这一点，你实际上必须看看。C中的图表，先例图表，如果你和我一样，你的书就会遵循先例。ISS绘制不同操作员及其级别的图表。你会看到的一件事是，第一级先例，最高的先例，包括方括号，第二级包括星星。换句话说，括号自星号以来具有更高的优先级。所以这里的这个特定语句，绑定实际上是这样的。它说四个是三个元素的数组。这些元素就是指针。他们指向整数。</p>
<p>发言人   34:32<br>So a 4. Is an array? Can you see this? But each of those elements. Is pointing to an int somewhere hopefully? And so let’s see if that matches the numbers we got. So the size of a 4 is 24 because it’s eight times 3. If I were to dereference a 4, it would just indicate this particular.<br>所以是4。是数组吗？你能看到这个吗？但是这些元素中的每一个。希望指向某个int吗？所以让我们看看这是否与我们得到的数字匹配。所以4的大小是24，因为它是8乘以3。如果我要取消引用4，它只会表明这个特定的。</p>
<p>发言人   35:15<br>Pointer A 4 is an array of pointers. Get an element out of that array. What I’ll get is a pointer. And so a four is a pointer, and so it’s also 8. But if I now do a second d reference, then I’ll get an int and it size is 4, okay?<br>指针A 4是指针数组。从该数组中获取一个元素。我会得到一个指针。因此，4是一个指针，因此它也是8。但是如果我现在做第二个d引用，那么我会得到一个int，它的大小是4，好吗？</p>
<p>发言人   35:46<br>These all compile. So could I have a could start a four then cause problems as far as a null pointer or bad pointer? No, that’s right. No is the correct answer. No is yes, because a four is an array. You’ve defined an array, and arrays get allocated by their declaration as a three element array. On the other hand, this could give you a null pointer because I haven’t initialized the array to anything. So for example, if it were initialized to all zeros, it would just be three null pointers in that array.<br>这些都在编译。所以我可以有一个可以开始四个，然后导致问题，就像空指针或坏指针一样？不，没错。不是正确答案。No就是yes，因为4是一个数组。您已经定义了一个数组，数组通过声明被分配为三元素数组。另一方面，这可能会给你一个空指针，因为我还没有将数组初始化成任何东西。例如，如果它被初始化为全零，则该数组中将只有三个空指针。</p>
<p>发言人   36:43<br>So this is sort of the stuff, the nitty gritty of C question, yes? How does it know that the size it 12 like I thought I see they didn’t really know how many things are in the question is. The compil what I’ll answer your question by saying, remember the compiler knows a lot. In particular I’ve declared this to be an array of three pointers. I’m compiling for a machine where pointers are 8 B. And so the compiler knows that SB 24 B in general, when you’re referencing in C, no, the machine doesn’t have built into it and doesn’t do bounds checking for you, but that’s in the runtime execution. But in see if I. When I declare something, it’s it has to be known at that point when the declaration occurs.<br>这就是C问题的基本细节，对吧？它怎么知道它的尺寸是12，就像我想我看到的那样，他们真的不知道问题中有多少东西。我回答你的问题时会说，请记住编译器知道很多。特别是我已经声明了这是一个由三个指针组成的数组。我正在为指针为8 B的机器进行编译。因此编译器通常知道SB 24 B，当你在C中引用时，不，机器没有内置到它里面，也不会为你做边界检查，但那是在运行时执行中。但是看看我是否。当我声明某事时，它必须在声明发生时被知道。</p>
<p>发言人   37:57<br>Empty bracket. Yeah, I think empty bracket is just another name for a pointer. Usually it’s just given his arguments, there’s some restrictions on it. But when you use the empty bracket notation and C, it’s equivalent to doing a pointer declaration. You’re not allocating any space for it here, but saying they want, right? Agreed, we have to be allocated a necessary on that.<br>空括号。是的，我认为空括号只是指针的另一个名称。通常只是给出他的论点，有一些限制。但是当你使用空括号符号和C时，它等效于进行指针声明。你并没有在这里分配任何空间，而是说他们想要，对吗？同意了，我们必须得到必要的分配。</p>
<p>发言人   38:24<br>Yes, right here, It really means when you declare an array and you give a number the size of that array, it really allocates that memories question eval.<br>是的，就在这里，它实际上意味着当你声明一个数组并给出一个数组大小的数字时，它确实分配了记忆问题eval。</p>
<p>发言人   38:36<br>And yes, oh, yes. And that’s the final one. You will notice numbers for a two and a four are the same. And the reason is it’s the same thing. And that, again, goes by the president’s rules of C, that A two first binds this way and then this way. And so a two and a four are synonymous just with west parentheses. So that was a bit of an aside. But as you can see, I think this is the kind of thing that will really probe your understanding.<br>是的，哦，是的。这是最后一个。你会注意到2和4的数字是一样的。原因是一样的。而且，再次遵循总统的规则C，即两个第一绑定的方式是这种方式，然后是这种方式。因此，2和4与西括号同义。所以这有点旁白。但是正如你所看到的，我认为这是一种真正能够探测你的理解的东西。</p>
<p>发言人   39:15<br>And now as a beginning C programmer, where you don’t have a very good sense, the underlying representation of a program, it’s really hard to figure these things out. But now that you know what it means to compile code, and you can actually look at compiled code, that’ll sort of clear up a lot of what’s really going on in a program. So let’s now generalize from one dimension to 2, just to make life a little more interesting. And again, it’s an important principle to understand that when you want to declare a multidimensional array and see you do it by a sequence of brackets with the bounds for each one. And the reason for that is actually there.<br>现在作为一个初级的C程序员，如果你没有一个非常好的感知，一个程序的底层表示，很难弄清楚这些事情。但是现在你知道了编译代码意味着什么，并且你可以实际查看编译后的代码，这将澄清程序中实际发生的很多事情。现在让我们从一维推广到二维，只是为了让生活更有趣一些。再次强调，当你想声明一个多维数组并查看时，理解这一点是一个重要的原则，你可以通过一系列括号来完成它，每个括号都有边界。原因其实就在那里。</p>
<p>发言人   40:10<br>We’ll see that it has to do with this notation that we just went through. So if I say int.<br>我们将看到它与我们刚刚经历的这个符号有关。所以如果我说int。</p>
<p>发言人   40:34<br>It turns out that I can read it like this. That a is an array of three elements. And each of those elements is in itself an array of five elements of type int. And we’ll get back to that. But that kind of explains everything thing I’m about to tell you in this picture. So in particular, if I declare an array with r rows and c columns, and you think of it mathematically as sort of a Ma two dimensional matrix. What it really does is it says, see as on the.<br>原来我可以这样读它。a是一个由三个元素组成的数组。每个元素本身都是一个由五个int类型元素组成的数组。我们会回到那个问题的。但这也解释了我在这张照片中要告诉你的一切。特别是，如果我声明一个包含r行和c列的数组，你可以把它数学上看作是一个马某某的二维矩阵。它真正做的是它所说的，就像在上面一样。</p>
<p>发言人   41:27<br>Yeah I’m sorry c actually ends up being the inner element. It says, first of all, I want row 0 will be an ray of c int. Being the number of columns I’ll put, so all the elements of row 0 will come first. All the elements of rho 1 come next, and so forth up to the end of it all. And so the total allocation will be 4, the data size times the number of rows times the number of columns. But the reason why they’re in that order, which is called rho major order, because if we thought of it these terms, we go through the first row, and then the second row. And the third row is precisely because.<br>是的，对不起，c实际上最终成为了内部元素。它说，首先，我希望第0行是一条c int的射线。作为我要放置的列数，因此第0行的所有元素都将排在第一位。rho 1的所有元素接下来都会出现，以此类推，直到最后。因此，总分配将为4，即数据大小乘以行数乘以列数。但是它们为什么按那个顺序排列的原因，称为rho主要顺序，因为如果我们想到这些术语，我们会遍历第一行，然后是第二行。而第三排恰恰是因为。</p>
<p>发言人   42:17<br>Of this? Notation, let me write it down like this. Hint of a. Well, let me just use the one I’ve said. We can write this out as a is a ray. A three element array.<br>关于这个？符号，让我这样写下来。a的暗示。好吧，让我用一下我说过的那个。我们可以把它写成a是射线。一个三个元素的数组。</p>
<p>发言人   42:45<br>What’s your battery on a microphone?<br>你的麦克风电池是什么？</p>
<p>发言人   42:53<br>Over half. It’s two thirds.<br>超过一半。是三分之二。</p>
<p>发言人   43:00<br>I’ll just put it over here. Okay, so A is a three element array, or generalizing to this picture, a is an array of R element. This is the first element, this is the second element, and this is the earth element. But what kind of elements are those? Each. Here is an array. Of 5 ins?<br>我就把它放在这里。好的，所以A是一个三元素数组，或者概括到这张图片，a是一个R元素的数组。这是第一个元素，这是第二个元素，这是地球元素。但是这些是什么元素？每个人。这是一个数组。在5个？</p>
<p>发言人   43:39<br>So within array A here, each sub-par of A then is an array of cints. And so that’s why logically, the way these are organized actually comes from this declaration notation directly. And we’ll see examples of that, for example.<br>因此，在这里的数组A中，then的每个子par都是一个cints数组。这就是为什么从逻辑上讲，这些组织的方式实际上直接来自于这个声明符号。我们会看到这样的例子。</p>
<p>发言人   44:07<br>Wanted to extend my zip digit idea and introduce an array of four of these. I could declare it this way. And again with remember, I used a type dev to declare zip did. But if I were to expand this out, it would be as if I was declaring this array Pgh to be 4 rows and 5 columns. But what it really is, it is an array of 4 elements, 1, 2, 3, 4, each of which is an array of 5”. So think of that nesting. When you read declarations, you start from the name of the element and you work your way outward through these brackets and stars in some order.<br>我想扩展我的zip数字想法并介绍一个由四个组成的数组。我可以这样宣布。并且再次记住，我使用了类型dev来声明zip done。但是如果我要扩展它，就好像我要将这个数组Pgh声明为4行5列一样。但它实际上是一个由4个元素组成的数组，1、2、3、4，每个元素都是一个由5 “组成的数组。所以想想那个嵌套。当您阅读声明时，您从元素的名称开始，然后按照某些顺序通过这些括号和星星来向外工作。</p>
<p>发言人   45:04<br>And so in particular, if I want to reference a particular element of an array, the general rule is wrong here, oh. The general rule is this one. If I want to reference, I don’t really. Oh I’m building up to. It. So yes, this shows that A of I can actually just do the reference A of I don’t have to give A of I of J in C, and what that denotes is one of these are rows of the array, and each of which is an array of c elements of type int.<br>因此，特别是，如果我想引用数组的特定元素，一般规则在这里是错误的。一般的规则就是这个。如果我想参考，我真的不知道。哦，我正在建设。它。是的，这表明I的A实际上可以引用A，而不必在C中给出J的I，这表示其中一个是数组的行，每个行都是int类型的c元素数组。</p>
<p>发言人   45:58<br>And so imagine that in general, we have k bytes for data type T, the underlying data type, in this case of t is and k equals 4. But in general, the starting address then of rho I would be gotten by multiplying the number of columns by k, and then multiplying that by the row number.<br>因此，想象一下，通常情况下，我们有k个字节用于数据类型T，这是底层数据类型，在这种情况下，t是并且k等于4。但一般来说，rho I的起始地址将通过将列数乘以k得到，然后再乘以行号得到。</p>
<p>发言人   46:26<br>And now within the array, I want to reference array element a sub ij. Then it comes out to this computation. You take the starting address. You scale the row number by the number of columns, add to it which column you want, and then multiply that all by k, So the way to see that is here, I can get to row number I by just scaling I by the number of columns times the size of the elements are 4. And now I want to get to the j element of this sub array here. And I can do that by scaling j by 4 and adding it to the beginning of this subarray. And now I can just collect the force together and then pull it outside here. That’s what gives you this formula.<br>现在在数组中，我想引用数组元素的一个子ij。然后它出来进行这个计算。你拿起始地址。您可以按列数缩放行号，将所需的列相加，然后将其全部乘以k，因此查看方法在这里，我可以通过按列数乘以元素大小为4来获得行号I。现在我想在这里找到这个子数组的j元素。我可以通过将j缩放为4并将其添加到此子数组的开头来实现这一点。现在我可以把力量集中在一起，然后把它拉出来。这就是你得到这个公式的原因。</p>
<p>发言人   47:23<br>So again, the point of this is that this all kind of is a natural outcome of the declaration. And it’s easy to think of it in terms of this storage model here of how the actual array is allocated.<br>所以，再次强调，这一切都是宣言的自然结果。而且很容易想到这里的存储模型，即实际阵列的分配方式。</p>
<p>发言人   47:45<br>Okay, now a different style of declaration is imagine I create three of these arrays. And now I want to create an array that contain. Points to these. So this is a different data structure you’ll observe from before. What uni-v now is an array of three pointers, and each of those pointers points to one of these arrays of five ints.<br>好的，现在一种不同风格的声明是想象我创建了三个这样的数组。现在我想创建一个包含的数组。指向这些。所以这是一个与之前不同的数据结构。现在的uni-v是一个由三个指针组成的数组，每个指针都指向这些五个整数数组之一。</p>
<p>发言人   48:27<br>And their underlying data type, by the way, of these elements are stars. And C does not differentiate When you want to declare array like this. You just say it’s an int star. You don’t say how many elements are the underlying array is. So you’ll see by these pictures that these are different data structures. So now let’s go through what the assembly code looks like to reference these two data structures.<br>顺便说一下，这些元素的基础数据类型是星形。当你想要像这样声明数组时，和C没有区别。你只是说它是一颗整型星。你不会说底层数组有多少个元素。所以你会从这些图片中看到这些是不同的数据结构。现在让我们来看看引用这两个数据结构的汇编代码是什么样子的。</p>
<p>发言人   49:04<br>We didn’t. Did we do the? I’m sorry, I would have thought I’d have assembly code. I think there might be a missing slide here, we’ll see. So imagine I wanted to reference.<br>我们没有。我们做了吗？对不起，我本以为我有汇编代码。我认为这里可能缺少幻灯片，我们会看到的。想象一下我想参考一下。</p>
<p>发言人   49:28<br>I’m sorry I’m confused why there is no.<br>对不起，我很困惑为什么没有。</p>
<p>发言人   49:50<br>There should have been. I’m sorry, this is I’m pausing here because I think I’m meant to have a slide that would show. What the code looks like, and I don’t. Okay, well, we’re going to have to wing it.<br>应该有。对不起，我在这里停顿一下，因为我想我应该有一张幻灯片来展示。代码是什么样子的，而我不是。好的，我们将不得不对它进行翼飞。</p>
<p>发言人   50:12<br>So if you wanted to an assembly code, then reference an element of an array like this, a multidimensional array. What you’ll see is that the code kind of builds up a computation like this. And typically, in the compiled code, the value of k is kind of a constant value. And if it’s aray that’s been declared with a constant bounds, then the value of c will also be a constant. And so a piece of code for this and that slide got omitted by extant. We’ll basically take this value and use some combination of the memory referencing and shifting and Lea instruction and so forth to implement this computation and then do a dereference.<br>所以，如果你想要一个汇编代码，那么引用一个像这样的数组的元素，一个多维数组。您将看到的是代码有点像这样构建计算。通常，在编译代码中，k的值是一种常量值。如果它是aray，它被声明为具有常量边界，那么c的值也将是一个常量。因此，这张幻灯片和那张幻灯片的一段代码被现有人省略了。我们基本上会取这个值，并使用内存引用、移位和Lea指令等的组合来实现这个计算，然后进行取消引用。</p>
<p>发言人   51:07<br>So let’s look at this second example. And there is code for this. And it’s actually a little bit more complex because this is going through two levels of indirection. So you’ll see that to get the. Digit a particular digit from a particular one of these universities, then? It has to, first of all figure out do this dereference is get a pointer to the beginning of the array. And that’s what this reference is doing here.<br>让我们来看看第二个例子。这方面有代码。这实际上有点复杂，因为这要经过两个间接层。所以你会看到得到。从这些大学中的一个特定的数字中选择一个特定的数字，然后呢？它必须首先弄清楚这个取消引用是获取一个指向数组开头的指针。这就是这个参考文献在这里做的事情。</p>
<p>发言人   51:53<br>First of all, what it’s doing is shifting RSA left by two, which is equivalent to scaling the digit by 4 because it’s getting ready to take that digit parameter and scale it appropriately. And then takes that number and it adds to it.<br>首先，它所做的是将RSA左移二，这相当于将数字缩放4，因为它准备接受该数字参数并适当缩放。然后将这个数字相加。</p>
<p>发言人   52:20<br>The value I get by reading from the array Univ, but using the index, scaling it by 8 to actually do a memory reference. So remember this instruction then, and it looks a little weird, is actually doing a memory reference here of this three element array of called Univ. So it’s reading from memory and doing an array index directly here by scaling. And now getting from that a pointer, adding to that the scaled value of the digit. And so that gives me a pointer now, as this notation shows. To. The particular element I want. And now it does a dereference. So that’s a pretty tough example to get as one of your first array ones.<br>我通过从数组Univ读取获得的值，但使用索引将其缩放8以实际进行内存引用。所以记住这个指令，看起来有点奇怪，实际上是在这里对这个三个元素数组的内存进行引用，叫做Univ。所以它从内存中读取，并通过缩放直接在这里进行数组索引。现在从中得到一个指针，再加上数字的缩放值。现在这给了我一个指针，正如这个符号所示。到。我想要的特定元素。现在它进行了一个取消引用。所以这是一个相当难的例子，作为你的第一个数组之一。</p>
<p>发言人   53:26<br>And as I said, I apologize for missing reference to a particular element of this array is done entirely by computing scaling indices in appropriate ways to take the array and scale the first index by 20. Because each row is 20 elements, it’s five times 4. And you want to scale the digit by 4 to select the particular element within that array. And so all this address computation takes place. And then there’s a single memory reference. Whereas in this data structure, you have to go through two memory references.<br>正如我所说，我很抱歉，缺少对此数组中特定元素的引用完全是通过以适当的方式计算缩放索引来获取数组并将第一个索引缩放20来完成的。因为每行有20个元素，所以它是4的五倍。并且您想将数字缩放4以选择该数组中的特定元素。因此，所有这些地址计算都发生了。然后有一个单一的记忆参考。而在这个数据结构中，你必须经过两个内存引用。</p>
<p>发言人   54:09<br>First of all, you have to index and get the appropriate element here, but that’s just a pointer now, and then we add an offset to that pointer to get the appropriate element in this array here. And then we read from that. So that’s what this notation means is that I’m doing two memory references here and just one there.<br>首先，你必须在这里索引并获取适当的元素，但现在这只是一个指针，然后我们向该指针添加一个偏移量以在这个数组中获取适当的元素。然后我们从中读到。所以这个符号的意思是，我在这里进行了两个内存引用，在那里只进行了一个。</p>
<p>发言人   54:30<br>And it’s a little bit curious because if you look at the C code, it looks the same, but the underlying data types are different, and so the references are different.<br>这有点奇怪，因为如果你看C代码，它看起来是一样的，但是底层的数据类型不同，因此引用也不同。</p>
<p>发言人   54:44<br>Okay, so let’s look at some other variations on this code. And these all will sort of follow up from these general principles I’ve described. So first of all, let’s introduce an array 2 by 2. I’m sorry, a 16 by 16 array of ints. And it used to be in C, if you wanted to do multidimensional arrays where the size of the array was not fixed at compile time, you basically had to implement your own version of that computation I showed before of scaling the row number by the number of columns and adding to it J, so this is sort of classic C I’ve written it as a macro here, but you can see it, it’s just doing the row major scaling directly.<br>好的，让我们看看这段代码的其他变体。这些都将遵循我所描述的这些一般原则。首先，让我们介绍一个2乘2的数组。抱歉，这是一个16乘16的整数数组。并且它曾经是在C中，如果你想做多维数组，其中数组的大小在编译时不是固定的，你基本上必须实现你自己的计算版本，我在按列数缩放行号并添加J之前展示了这个计算，所以这是经典的，我在这里将其编写为宏，但你可以看到它，它只是直接进行行主缩放。</p>
<p>发言人   55:37<br>Here is address arithmetic now since a more recent generation of the C compiler, what they call C 99, it was introduced in 1999. You can actually passes a parameter, an array, where the number of elements in the array is also a parameter that’s being passed to the function. And similarly, you can declare an array to be of n elements as long as n has been computed before it hits an array declaration. And the compiler will do the right thing. It will allocate the proper number of elements.<br>这是地址算术，自从最近的一代C编译器以来，他们称之为c99，它是在1999年引入的。你实际上可以传递一个参数，一个数组，其中数组中的元素数量也是一个被传递给函数的参数。同样，只要在数组声明之前计算过n个元素，就可以将数组声明为n个元素。编译器会做正确的事情。它将分配适当数量的元素。</p>
<p>发言人   56:25<br>So let’s just look at some of these code examples.<br>让我们来看看其中的一些代码示例。</p>
<p>发言人   56:37<br>Again, what we’ll see here, and this will show you an example of the kind of address computation that takes place with a two dimensional array. In this case, I know c is 16 and k is 4. So if I want to get element, I sub j ij out of this array, then first of all, scale I by 64, because I’ll add that to the base, and then I’ll scale RDX by 4, that’s j, and add it to this array, and then do a memory reference there. You see, these two instructions have done the appropriate, the three instructions done the appropriate scaling of I and J, added them to the beginning address of J, and done the computation. On the other hand, if it’s a.<br>再说一遍，我们将在这里看到什么，这将向您展示使用二维数组进行地址计算的示例。在这种情况下，我知道c是16，k是4。所以如果我想从这个数组中获取元素，那么首先将I缩放到64，因为我会将其添加到基础，然后将RDX缩放到4，即j，并将其添加到这个数组中，然后在那里做一个记忆参考。你看，这两条指令已经做了适当的调整，三条指令对I和J进行了适当的缩放，将它们添加到J的开始地址上，并完成了计算。另一方面，如果它是a。</p>
<p>发言人   57:44<br>The third example I showed where n is a parameter that’s passed to the function. So it’s not known at compile time how big a scaling factor to use. You’ll see that it has to use a multiply instruction to do that, which is relatively expensive instruction in terms of performance. And then once it has that, that’s just n times I, and then it uses various combinations of leas and the scaling notation from before to compute an appropriate offset into the array to do the reference. So here, I could do it with a shift. And here I had to introduce a multiplier. I don’t know in advance how big it is. If you want to torture yourself.<br>第三个例子我展示了其中n是传递给函数的参数。所以在编译时不知道要使用多大的缩放因子。你会发现它必须使用乘法指令来做这件事，就性能而言，这是相对昂贵的指令。一旦它有了这个，那只是n次I，然后它使用leas和之前的缩放符号的各种组合来计算适当的偏移量到数组中进行引用。所以在这里，我可以改变一下。这里我必须引入一个乘数。我事先不知道它有多大。如果你想折磨自己。</p>
<p>发言人   58:46<br>Here’s an example I was going to go over.<br>这是我要介绍的一个例子。</p>
<p>发言人   58:54<br>Of Tripoli, nested possibilities and dereferencing of the same idea.<br>的黎波里，嵌套可能性和同一想法的解引用。</p>
<p>发言人   59:04<br>But let’s move on to pointers to structs. So the idea of a struct is actually quite simple. Well, the base idea is simple, and it gets more complicated. The idea of it is, I want to, I declare a struct to have some number of fields, each of which can be an int, or it could be, in this case, a pointer, or it could be an array itself. But the rule is basically what I’ll do is allocate enough space if I introduce one of these structs for all the different array elements fields in that struct. And then I’ll basically keep track of where each of these field starts and generate the appropriate code to offset from the beginning so the structure itself the to it will be the beginning address of the struct. And then I’ll use appropriate offsets to get to the different fields.<br>但让我们继续指向结构的指针。所以结构的概念实际上非常简单。基本思想很简单，而且它变得更加复杂了。它的想法是，我想声明一个结构，它具有一定数量的字段，每个字段可以是一个int，或者在这种情况下它可以是一个指针，或者它本身可以是一个数组。但是规则基本上是，如果我为该结构中的所有不同数组元素字段引入这些结构之一，我将分配足够的空间。然后我将基本上跟踪每个字段的开始位置，并生成适当的代码以从头开始偏移，因此结构本身将成为结构的开始地址。然后我会使用适当的偏移量来到达不同的字段。</p>
<p>发言人   01:00:10<br>So here’s an example of some code, imagine. Have a pointer to one of these structures. And I have an index. And what I want to do is get to the that appropriate part of array A within this struct. Well, ay A is right at the beginning of this structure, so I can treat this just like I would any array reference, scaling Idx by four and adding it to the base to get the appropriate element. So I don’t really have to do anything special for this one.<br>这里是一些代码的例子，想象一下。有一个指向这些结构之一的指针。我有一个索引。我想做的是在这个结构中获得数组A的适当部分。好的，ay A就在这个结构的开头，所以我可以像处理任何数组引用一样处理它，将Idx缩放四并将其添加到基础以获得适当的元素。所以我真的不必为此做任何特别的事情。</p>
<p>发言人   01:00:51<br>Let’s look at some other code that you’ll typically see. Actually, this example is pretty involved. So I’m actually doing a whole bunch of stuff here with this one struct. First of all I’m trying to retrieve element I from the structure, then I’m using that to index into array A and insert a value into there. And then I’m updating this pointer to point to the next.<br>让我们来看一些你通常会看到的其他代码。实际上，这个例子相当复杂。所以我实际上在这里用这个结构做了很多事情。首先，我正在尝试从结构中检索元素I，然后我正在使用它来索引数组A并在其中插入一个值。然后我更新此指针以指向下一个。</p>
<p>发言人   01:01:28<br>If this were I’m going twist, what I want to do is step to the next element, one of the list. So I need to retrieve the next field from here. And so I’m actually making three references to this structure in this one, a rather small function. So let’s try and figure it all out.<br>如果我打算扭曲，我想做的是进入下一个元素，也就是列表中的一个。所以我需要从此处检索下一个字段。所以我实际上在这个结构中引用了三个，这是一个相当小的函数。所以让我们试着把一切弄清楚。</p>
<p>发言人   01:01:54<br>So first of all, I have to retrieve element I from it. And here you see that we know that element I is at offset 16. And here’s where you see that displacement field being used in the memory reference. Exactly for this purpose, I want to take R, but add 16 to it to get a memory address that I can use for. For I. And you see it actually uses move slq because I itself is an int, but I’m going to use it as an array index, in which case I have to scale it.<br>首先，我必须从中检索元素I。在这里你可以看到我们知道元素I在偏移16处。在这里，您可以看到内存引用中使用了位移场。正是出于这个目的，我想取R，但将其加上16以获得我可以使用的内存地址。对于我。你会发现它实际上使用了移动slq，因为I本身是一个int，但我会将它用作数组索引，在这种情况下，我必须缩放它。</p>
<p>发言人   01:02:36<br>I have to do address arithmetic using 8 B quantities. So this actually retrieves the 4 B value and does a sine extension on it. And now what I want to do is store a Val at L I, and so here you’ll see that it’s using Rax is the value I’ve just computed for I scaling by four and using the starting address of the r, which happens to be the starting address of A as well, and doing a store. So that’s sort of an array operation there. And then the next part is I’m going to offset 24, which is the position of next read from that location and store that in RDI, which is R, so this is the operation R gets r arrow next, and then the loop is I’m testing until R is null, so that’s going on here.<br>我必须使用8个B的数量进行地址算术运算。所以这实际上检索4 B值并对其进行正弦扩展。现在我想做的是在L I存储一个值，所以在这里你会看到它使用的是Rax，这是我刚刚计算出来的I缩放四的值，并使用r的起始地址，这恰好也是a的起始地址。做一家商店。所以这有点像数组操作。然后下一部分是我将偏移24，这是下一次从该位置读取的位置并将其存储在RDI中，即R，因此这是操作R得到r箭头，然后循环是我正在测试直到R为null，所以这是怎么回事。</p>
<p>发言人   01:03:48<br>So you see that those three references to the struct were implemented using three instructions here. So it’s a very direct mapping between the code here and the x 86 instructions and part of the x 86 instructions because this kind of stuff is so commonplace in programs they kind of made the instructions map very directly toward these operations. And now you should probably see why all the bells and whistles are there for these address references question.<br>所以你可以看到这三个对结构的引用是使用这里的三条指令实现的。因此，这里的代码与x86指令和部分x86指令之间是非常直接的映射，因为这种东西在程序中非常普遍，它们使得指令非常直接地映射到这些操作。现在你应该明白为什么这些地址参考问题都有花里胡哨的东西了。</p>
<p>发言人   01:04:26<br>What if I was three? I’m sorry? A has three elements. Yes, it will access. Actually, I think that’s a typo. He is supposed to be 4. So if I was four, it would access itself and it would mess things up. Question, this is a typo. By the way, it should be AF 4.<br>如果我是三个呢？对不起？A有三个元素。是的，它会访问。实际上，我认为这是一个错字。他应该是四岁。所以如果我四岁，它会自动访问，把事情搞得一团糟。问题，这是一个错字。顺便说一下，它应该是AF 4。</p>
<p>发言人   01:05:08<br>A null point. A null is 0.<br>一个零点。A null为0。</p>
<p>发言人   01:05:17<br>So that’s sort of the easy version of structs. Now let’s make them a little harder. One is, for reasons that are a bit obscure, the machine generally prefers that if you have a data type, an underlying data type of k bytes, the address that that starts at via multiple of k, and so that introduces a property we call alignment, which will actually, when a structure gets allocated well, the compiler will actually insert some blank unused bytes in the data structure in its allocation just so that it can maintain this alignment.<br>所以这是结构的简单版本。现在让我们让它们变得更难一点。一是，由于有些模糊的原因，机器通常更喜欢如果你有一个数据类型，一个基础数据类型k字节，这个地址从k的倍数开始，因此引入了一个我们称之为对齐的属性，它实际上将，当结构分配得好时，编译器实际上会在数据结构的分配中插入一些未使用的空白字节，以便它可以保持这种对齐。</p>
<p>发言人   01:06:01<br>So for example, here I is an int, and I want it to address to be a multiple of four, and I’ll give you a minute why that’s true. Just so trust me for a minute. And so actually pad 3 unused bytes here, because the first byte is being used by CE. And in general, we’ll see in the allocation, we’re going to make sure that the pointer to this data structure is itself a multiple of eight. And the reason for that is because there’s a double here, and it should reside on a boundary that it starting a dress should be a multiple of eight. And you’ll see, as long as this is 8, a multiple of eight, and this offset here is a multiple of eight, then this address will be a multiple of eight. So that’s the idea of alignment.<br>例如，这里I是一个int，我希望它的地址是4的倍数，我会给你一分钟为什么这是真的。请相信我一分钟。所以实际上在这里填充了3个未使用的字节，因为第一个字节被欧洲合格认证使用。一般来说，我们将在分配中看到，我们将确保指向此数据结构的指针本身是八的倍数。原因是这里有一个double，它应该位于一个边界上，它开始一件衣服应该是8的倍数。你会看到，只要这是8的倍数，并且这里的偏移量是8的倍数，那么这个地址将是8的倍数。这就是对齐的想法。</p>
<p>发言人   01:06:55<br>And so why is that true? Well, it’s really a hardware issue that the memory system, sort of the actual hardware memory, does not reference 1 B at a time. It references, actually, in most machines nowadays, about 64 B at a time, depending on various widths within the hardware. And in general, if a particular piece of data crosses the boundaries between two blocks that are because of a misaligned address, that will take extra steps by the hardware and potentially even the operating system to deal with. So just for efficiency reason, they say, do this alignment.<br>那么为什么这是真的呢？这确实是一个硬件问题，内存系统，有点像实际的硬件内存，一次不引用1 B。实际上，在当今大多数机器中，它一次大约引用64 B，具体取决于硬件的各种宽度。一般来说，如果一个特定的数据块由于地址不对齐而跨越了两个块之间的边界，那么硬件甚至可能是操作系统将需要额外的步骤来处理。所以他们说，仅仅出于效率的原因，进行这种对齐。</p>
<p>发言人   01:07:39<br>Trust me, in x 86 machines, if you have unaligned data, it will execute just fine. It just might run a little bit more slowly on some other machines. If you try to do an unwind access, it will actually cause a memory fault.<br>相信我，在x86机器上，如果你有未对齐的数据，它会正常执行。在其他机器上，它可能会运行得更慢一些。如果尝试进行解除访问，实际上会导致内存故障。</p>
<p>发言人   01:08:07<br>The question was, how can you force it to generate unwind data? I don’t know if you could. And we’ll talk about ways you can sort of be more clever in how you do your allocation to avoid wasting space. So in general, then we have, we’re mostly looking here at data types that are either 1, 2, or 4, 8 B long. There are some 16 B data types, but we won’t be looking at those.<br>问题是，你如何强迫它生成展开数据？我不知道你是否可以。我们将讨论如何更聪明地分配空间，以避免浪费空间。所以一般来说，我们在这里主要看的是1、2或4、8 B长的数据类型。有一些16 B的数据类型，但我们不会关注它们。</p>
<p>发言人   01:08:40<br>And in general, with the address, then you can tell the alignment of an address by how many zeros. If it’s a power of two alignment, how many 0 is there at the end of a bit level representation of that address? And so as we showed, in general, the C compiler, when it’s creating the layout for a structure, a structure will put in panning bytes in there to make the alignment work. The other thing it will do is if it need be, it will add bytes to the end to make sure that the overall size of the data structure meets whatever underlying alignment requirement there is.<br>通常情况下，通过地址，您可以通过多少个零来判断地址的对齐方式。如果它是两个对齐的幂，那么在该地址的位级表示的末尾有多少个0？因此，正如我们所展示的，通常情况下，C编译器在创建结构布局时，结构将在其中放置平移字节以使对齐工作。它会做的另一件事是，如果需要，它会在末尾添加字节，以确保数据结构的整体大小满足任何潜在的对齐要求。</p>
<p>发言人   01:09:22<br>And this one, because it contains a double, the overall data structure has to be aligned on an 8 B boundary. And the reasoning for that is, imagine I had an array of structs. Of these structs in particular, then, if I can assume that if I can ensure that this array is a address is a multiple of eight, then you can see that each successive element of this, these struct is a multiple of eight. And then within that struct I’ve ensured that each field that requires an alignment by 8 is positioned with an offset that’s a multiple of eight. And so it all works out. But if you try to tinker with this by making this too short, then you’d start getting misaligned references.<br>而这个，因为它包含一个double，所以整个数据结构必须在8 B边界上对齐。其原因是，想象我有一个结构数组。特别是这些结构，那么，如果我可以假设如果我能确保这个数组的地址是8的倍数，那么你可以看到这些结构的每个连续元素都是8的倍数。然后在该结构中，我确保每个需要对齐8的字段的偏移量是8的倍数。所以一切都成功了。但是如果你试图通过太短来修补这个，那么你就会开始得到不对齐的引用。</p>
<p>发言人   01:10:23<br>And so one thing you’ll see is for every struct, the actual alignment requirement depends on what’s the sort of worst case alment the maximum alignment of any element. So this particular structure, for example, contains a float v, which has a size of 4. And so this would be an alignment of 4. And you’ll see in the code in general, when it has all this address arithmetic we’ve seen gets used in various different ways, too. Scale values, compute offsets, and so forth to get the appropriate elements.<br>因此，您会看到的一件事是，对于每个结构，实际的对齐要求取决于最坏情况下的任何元素的最大对齐情况。所以这个特定的结构，例如，包含一个float v，其大小为4。所以这将是4的对齐。你会在代码中看到，当它具有我们所看到的所有这些地址算术时，也会以各种不同的方式被使用。缩放值、计算偏移等，以获得适当的元素。</p>
<p>发言人   01:11:06<br>So your question before is, could I tell the compiler not to do alignment? And the better way is to declare your fields in a. Way that minimizes the amount of wasted space. So for example, here, I wasted 3 B here and 3 B here to meet the alignment requirements. But if I just put I at the beginning and then C and D, I would have only wasted 2 B total.<br>所以你之前的问题是，我可以告诉编译器不要进行对齐吗？而更好的方法是在中声明您的字段。最大限度地减少空间浪费的方法。例如，在这里，我浪费了3 B和3 B来满足对齐要求。但是如果我只是把I放在开头，然后是C和D，我总共只浪费了2 b。</p>
<p>发言人   01:11:37<br>And in general, because all the alignment requirements are powers of 2, the sort of greedy algorithm works. It says, if I just put the biggest stuff at the beginning and then success with smaller elements, I will be able to minimize any wasted space. And that’s a general property. But this is a case where you, as the writer of c-code, have that effect. The compiler will not do this for you automatically.<br>一般来说，因为所有的对齐要求都是2的幂，贪婪算法的工作原理。它说，如果我只是把最大的东西放在开头，然后用较小的元素成功，我将能够最大限度地减少浪费的空间。这是一个普遍的属性。但这是一个你作为c代码的作者具有这种效果的案例。编译器不会自动为您执行此操作。</p>
<p>发言人   01:12:07<br>Question in the case of. Having. What’s that, oh, but remember an array? I don’t care about the array. I care about the elements of the array. This is only down at the lowest level where I’m accessing either a single int, a single double, or a pointer, and not all the rest of this stuff. Remember, I never read an entire array from memory, so alignment only refers down to the primitive types, not the aggregate types.<br>在案件中的问题。拥有。那是什么，哦，但记得一个数组吗？我不在乎数组。我关心数组的元素。这只是在最低级别下，我正在访问单个int，单个double或指针，而不是所有其余的东西。请记住，我从来没有从内存中读取整个数组，因此对齐只涉及原始类型，而不是聚合类型。</p>
<p>发言人   01:12:42<br>If this is confusing, the book covers this fairly carefully. So let me just finish up with a little glimpse of floating point.<br>如果这令人困惑，这本书会相当仔细地涵盖这一点。所以，让我以浮点数的一瞥作为结束。</p>
<p>发言人   01:12:54<br>Floating point is a complicated history in x 80 two-six Back in the really ancient S, there was a chip that went with the 8086 processor called the $8087. And at the time, it was a masterpiece of engineering to be able to come put all the hardware necessary to implement full IEEE floating point on a single chip. And it was the first one of its type. In fact, it was sort of co developed with the IEEE floating point standard itself. But the programming model for is horrendously awful and ugly. I used to, in older editions of the book, there were, it was in the first edition, it was in a webi sidetes, the second edition, and now it’s been expunged completely because it’s so awful.<br>浮点在x80中是一个复杂的历史，在真正古老的年代，有一个芯片与8086处理器一起使用，称为 $8087。在当时，能够在单个芯片上实现完整的iee浮点所需的所有硬件是工程的杰作。这是同类产品中的第一个。实际上，它是与IEEE浮点标准本身共同开发的。但是的编程模型非常可怕和丑陋。我曾经在这本书的旧版本中，有第一版，第二版，现在已经完全删除了，因为它太可怕了。</p>
<p>发言人   01:13:47<br>But more recently in the world of x 86, they realized that to support things like video and all the stuff people actually do with their machines, they needed some more horsepower and numeric processing, and they implemented a class of instructions called SSE, which stands for SIMD. Something SD execution anyways, and I’ll show you in a minute what that means. And that’s now in the more recent versions of x 86 has been juiced up to something called AVX. Which but the shark machines support this version of what’s called Ssc? So let me just give you a feeling for that. And in particular, the shark machines support what’s called SOC version 3.<br>但最近在x86的世界中，他们意识到要支持视频和人们在机器上实际做的所有事情，他们需要更多马力和数字处理，因此他们实现了一类名为SSE的指令，它代表SIMD。无论如何，有些事情SD卡执行，我稍后会向您展示这意味着什么。而现在最新版本的x86已经被加进了一个叫做AVX的东西。除了鲨鱼机器之外，哪一个支持这个叫做Ssc的版本？所以让我给你一个感觉。特别是鲨鱼机器支持所谓的SOC版本3。</p>
<p>发言人   01:14:43<br>And what it is is that there’s 16 special registers distinct from the other registers we’ve talked about before, each of which has 16 B. And then there’s operations that can operate on those and treat them in different ways. So one is to treat this, such an register, as an array of 16 cares, or as short or 4”. And also to support double floating point arithmetic. So this stuff was sort of going on. And somebody had the observation that said, well, I could just then sort of subset all this and implement the floating point operations directly using this SSE stuff and skip the old x 87 stuff. And so that’s the way floating point is now generated on, say, the shark machines. In most recent machines.<br>它是什么，有16个特殊寄存器与我们之前讨论过的其他寄存器不同，每个寄存器都有16个B。然后有一些手术可以对这些人进行手术并以不同的方式对待他们。所以我们应该把这个，这样一个寄存器，作为16个关心的数组，或者作为短的或4个 “。并且还支持双浮点运算。所以这种事情有点发生了。有人观察到说，好吧，我可以这样做，然后直接使用SSE的东西来实现浮点操作，跳过旧的x87的东西。这就是现在在鲨鱼机器上生成浮点的方式。在最近的机器上。</p>
<p>发言人   01:15:41<br>This is, again, an example of where the world is more complicated than it should have to be. So for example, there is an instruction that says add SS. So add a single scalar is what? That notation, add a single precision scalar. Add a scalar single precision and it looks a little like the add instructions, the add C instructions you’ve seen it increments. It adds the source to the destination.<br>这又是一个例子，说明世界比它应该有的更复杂。例如，有一个指令说添加SS。那么添加一个标量是什么？那个符号，添加一个单精度标量。添加一个标量单精度，它看起来有点像添加指令，你看到的添加C指令会递增。它将源添加到目标。</p>
<p>发言人   01:16:19<br>There’s ways I can do four ads all at the same time using this is what they call SD execution, which stands for single instruction, multiple data, one instruction, the add Ps P stands for pact. We’ll do well, we will perform that one instruction. Will you do add with four different numbers? And similarly, you can do it with double precision, You can do one of them, you can do a pet, and so actually the underlying and we’ll see this when we look at code optimization, if you write code to make use of these instructions, can really boost the performance of the computer.<br>有一些方法可以同时执行四个广告，这就是他们所说的SD卡执行，代表单指令，多数据，一条指令，add Ps P代表pact。我们会做得很好，我们将执行那一条指令。你会用四个不同的数字相加吗？同样地，你可以用双精度来完成，你可以做其中一个，你可以做一个宠物，所以实际上，当我们研究代码优化时，我们会看到这一点，如果你编写代码来利用这些指令，可以真正提高计算机的性能。</p>
<p>发言人   01:17:03<br>But this just gives you a flavor for what floating point code looks like.<br>但这只是为你提供了浮点代码的外观。</p>
<p>发言人   01:17:07<br>And the rules are pretty simple that just as we saw before, that arguments get passed in registers, well, floating point arguments get passed in these Xmm registers xmm zero, you don’t have to memorize RDI RSI RDX, they’re in Xmm 0 1 2. It’s all very logical and the return value is in Xmm 0 and all the registers are call or save, there’s no call you save. So something like adding two floating point numbers, what just look like a single floating point addition instruction, same with double and if you mix together code that has a pointer and a floating point operator, the pointer will be passed in a regular register RDI. And this double will be passed in XM 0. So as it goes through the argument list, you sort of in the particular order, if it’s an integer or a pointer, it’s in one of the R registers, and if it’s a floating point value, it’s in one of the Xmm registers and potentially interleaved. Almost done. And so this is code that does this particular operation.<br>规则非常简单，就像我们之前看到的一样，参数在寄存器中传递，浮点参数在这些Xmm寄存器中传递，xmm零，你不必记住RDI RSI RDX，它们在Xmm 0 1 2中。这一切都非常合乎逻辑，返回值以Xmm 0为单位，所有寄存器都是调用或保存的，没有您保存的调用。所以像将两个浮点数相加这样的东西，看起来就像一个浮点数加法指令，与double相同，如果您将具有指针和浮点运算符的代码混合在一起，该指针将在常规寄存器RDI中传递。这个双精度值将在XM 0中传递。因此，当它浏览参数列表时，按照特定的顺序排序，如果它是整数或指针，它在R寄存器中的一个，如果它是浮点值，它在Xmm寄存器中的一个，并且可能是交错的。几乎完成了。所以这是执行这个特定操作的代码。</p>
<p>发言人   01:18:29<br>And it’s interesting because it’s returning a, it’s doing memory referencing. So again, there’s instructions that will read from memory and copy into an Xmm register. You can add registers, you can make a copy from one Xmm register to another, and you can store results.<br>这很有趣，因为它返回了一个，它正在进行内存引用。所以，还有一些指令可以从内存中读取并复制到Xmm寄存器中。你可以添加寄存器，可以从一个Xmm寄存器复制副本到另一个，还可以存储结果。</p>
<p>发言人   01:18:50<br>So this code looks a lot like what you do in integer arithmetic, except it’s using Xmm and special floating point instructions rather than the ones you’ve seen before. So the basic idea of it is fairly simple. It gets way more complicated because there are lots of instructions double float on and on and on. There’s a special instruction to do square root and all this stuff. And the comparison stuff is really nasty and messy and hard to understand.<br>所以这段代码看起来很像你在整数算术中所做的，除了它使用Xmm和特殊的浮点指令，而不是你之前看到的那些。所以它的基本思想相当简单。它会变得更加复杂，因为有很多指令是双重浮动的。有一个特殊的指令来做平方根和所有这些东西。比较的东西真的很讨厌、混乱且难以理解。</p>
<p>发言人   01:19:24<br>You’ll see various tricks to use constant values too, so it’s covered in the book. We’re not going to really talk about it much in this course, but underlying the basic principles of it are fairly straightforward. Okay, that’ll do this for today.<br>你也会看到使用常量值的各种技巧，所以这本书已经涵盖了。在这门课程中，我们不会过多地谈论它，但它的基本原理相当简单。好的，今天就到这里。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>深入理解计算机系统 008-Machine-Level Programming IV, Data</div>
      <div>http://example.com/2025/10/12/15213-008/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月12日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/12/15213-009/" title="深入理解计算机系统 009-Machine-Level Programming V, Advanced Topics">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">深入理解计算机系统 009-Machine-Level Programming V, Advanced Topics</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/12/15213-007/" title="深入理解计算机系统 007-Machine-Level Programming III, Procedures">
                        <span class="hidden-mobile">深入理解计算机系统 007-Machine-Level Programming III, Procedures</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
