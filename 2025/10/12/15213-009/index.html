

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="发言人   00:01This will be the last lecture on machine level of programming. We call it advanced topics, but think of it more as miscellaneous topics.这将是最后一堂关于机器编程的讲座。我们称之为高级主题，但更多地将其视为杂项主题。 发言人   00:11A">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解计算机系统 009-Machine-Level Programming V, Advanced Topics">
<meta property="og:url" content="http://example.com/2025/10/12/15213-009/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="发言人   00:01This will be the last lecture on machine level of programming. We call it advanced topics, but think of it more as miscellaneous topics.这将是最后一堂关于机器编程的讲座。我们称之为高级主题，但更多地将其视为杂项主题。 发言人   00:11A">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-12T02:00:08.000Z">
<meta property="article:modified_time" content="2025-10-25T05:03:39.699Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>深入理解计算机系统 009-Machine-Level Programming V, Advanced Topics - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="深入理解计算机系统 009-Machine-Level Programming V, Advanced Topics"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-12 10:00" pubdate>
          2025年10月12日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          16k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          137 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">深入理解计算机系统 009-Machine-Level Programming V, Advanced Topics</h1>
            
            
              <div class="markdown-body">
                
                <p>发言人   00:01<br>This will be the last lecture on machine level of programming. We call it advanced topics, but think of it more as miscellaneous topics.<br>这将是最后一堂关于机器编程的讲座。我们称之为高级主题，但更多地将其视为杂项主题。</p>
<p>发言人   00:11<br>And I think most of you, of course, you know that your bomb webs are due tonight. So you, most of you are probably well into that or hopefully through it. And then at midnight tonight, the next web will come out, which is called Attack Lab. And there was a recitation about that yesterday. But this is a lab that’s new to the course. It’s similar to one that we used to use at this point in the course, but it’s been updated and changed in significant ways.<br>我想你们大多数人，当然，你们知道你们的炸弹网定于今晚。所以你们大多数人可能已经很熟悉了，或者希望能够度过这个过程。然后在今晚午夜，下一个网络将会出现，这个网络被称为攻击实验室。昨天有一场关于这个的背诵。但这是一个新的实验室。它类似于我们在课程中使用的那个，但它已经在重要方面进行了更新和更改。</p>
<p>发言人   00:43<br>We’re actually, when you have labs like we do in this course with this many students, there’s a lot of things that can go wrong. Going to keep a close eye on how things are going. But I encourage you only have a week and a half to do this next lab to get started soon. And partly by having some people start sooner, you’ll start breaking things for us that we can track down.<br>实际上，当你有像我们在这么多学生的课程中做的这样的实验室时，有很多事情可能会出错。我们将密切关注事情的进展。但我建议你只有一周半的时间进行下一个实验，以便尽快开始。部分原因是让一些人更早开始，你就会开始为我们破坏一些我们可以追踪的东西。</p>
<p>发言人   01:09<br>So today, what we’ll talk about is a couple. Like I said, it’s miscellaneous topics, but important topics. One is just sort, what does the memory look like when you’re running X 8664 programs? The other is a very important topic on security vulnerability called buffer overflows, and in fact, attack lab will be precisely exploiting those security vulnerabilities. And then we’ll look at unions. So far, you’ve looked at arrays and structs and how they’re organized, and I want to compare that to unions. So let’s talk about memory then, as I said at the beginning, early in the course, conceptually, a memory is just a big array of bytes and that the view of the machine level programmer, even though it’s not the actual implementation, there’s a whole part that we’ll talk about later in the course of this, is called virtual memory. This organization, this very simple organization, but the underlying implementation is this complex management of various different memory types from disk memories to solid state disks and to what’s called DRAM, which stands for dynamic Ram when you buy memory for your processor, it’s DRAM.<br>所以今天，我们要谈论的是一对。就像我说的，这是杂项话题，但很重要的话题。一个只是排序，当您运行X 8664程序时，内存是什么样子的？另一个是关于安全漏洞的非常重要的话题，称为缓冲区溢出，实际上，攻击实验室将精确地利用这些安全漏洞。然后我们再看看工会。到目前为止，您已经查看了数组和结构以及它们的组织方式，我想将其与联合进行比较。那么让我们来谈谈内存，就像我在课程开头所说的，从概念上讲，内存只是一个大的字节数组，机器级别程序员的视图，即使它不是实际的实现，有一个完整的部分我们将在稍后的课程中讨论，称为虚拟内存。这个组织，这是非常简单的组织，但底层实现是对各种不同内存类型的复杂管理，从磁盘内存到固态磁盘以及所谓的DRAM，当您为处理器购买内存时，它是DRAM，它代表动态内存。</p>
<p>发言人   02:38<br>So as you know, in X 8664, we’re working machines that nominally are addresses, can be up to sixty-fourth s long.<br>如你所知，在X 8664中，我们正在工作的机器名义上是地址，可以长达64秒。</p>
<p>发言人   02:48<br>And if you work out the numbers, remember I told you at the beginning of the course, you can estimate how big a number like 2 to the 64 is by remembering that 1020, and 1000 are very close to each other. So 2 to the 10th is roughly the same as 10 to the third. So you take 64 and you think 60. So how big is 2 to the 66 times 10? And therefore it’s six times 3, it’s like 10 to the 18th, and then you add the four to that, that two to the fourth is 16. So it’s around 16 times 10 to the 18th bytes.<br>如果你算出了数字，记得我在课程开始时告诉你的，你可以通过记住1020和1000彼此非常接近来估计像2到64这样的数字有多大。所以2的10与10的3大致相同。所以你拿64，你想60。那么2的66乘以10有多大呢？因此它是6乘3，就像10的18次方，然后你把4加在一起，那2到4就是16。所以它大约是16乘以10的18个字节。</p>
<p>发言人   03:32<br>So if you were to go off and look online on Amazon for DRAM chips and try to buy that much memory, you’d find you’re spending a lot of money more than you. I don’t know the numbers, but it would be a lot of memory money. And so you basically can’t do it nowadays. And so?<br>所以，如果你去亚马逊上在线寻找DRAM芯片并尝试购买那么多内存，你会发现你花的钱比你多很多。我不知道数字，但那会是很多记忆钱。所以现在你基本上做不到。所以呢？</p>
<p>发言人   04:03<br>Right now, the machines limit you to actually only 47 b worth of address in the address space. And so two to the 47th, again, work that out. That’s like 10 to the tweh times 256 times 10 to the 12th. So it’s 256 TB. And as you know, you can buy a disk drive now that has 8 TB. So it doesn’t seem like that much. But if you tried to buy that much DRAM again, you’d have to have a pretty big credit card.<br>现在，机器将您的地址空间限制为只有47 b的地址。所以两个47分，再一次，解决这个问题。这就像是10的tweh乘以256乘以10的12次方。所以它是256 TB。如你所知，你现在可以购买一个有8个TB的磁盘驱动器。所以看起来没那么多。但是如果你想再次购买那么多的DRAM，你必须有一个相当大的信用卡。</p>
<p>发言人   04:37<br>Limit And so even that’s a huge number. And modern supercomputer installations actually will have almost that much memory. But the point is that the hardware of today limits you to 47 b worth of address. But that’s not really a real limitation in terms of actual machines. And what will happen is as memory prices get cheaper and the technology gets better, they’ll slowly start adding as succeeding generations of processors come along, let you have bigger and bigger range of addresses.<br>限制，所以即使这是一个巨大的数字。而现代超级计算机的安装实际上将拥有几乎那么多的内存。但重点是今天的硬件限制了你只有47 b的地址价值。但就实际机器而言，这并不是一个真正的限制。接下来会发生的是，随着内存价格的降低和技术的进步，随着下一代处理器的出现，它们会慢慢开始增加，让你拥有越来越大的地址范围。</p>
<p>发言人   05:12<br>So all that is to say, that’s why. This number shows up, which is a 7 followed by 11 F’s. I can tell I need to scribble some numbers. You guys aren’t just saying numbers in the air is not working here. So let’s try.<br>也就是说，这就是原因。这个数字出现了，它是一个7后面跟着11个F。我知道我需要潦草地写一些数字。你们不只是在说空中的数字在这里不起作用。那么让我们试试。</p>
<p>发言人   05:53<br>Okay, so remember I said before two to the 64 is about equal to 16 times 10 to the 18th. And 2 to the 47th is 128 times 10 to the Tth. So it’s 128 TB.<br>好的，记得我之前说过，2的64大约等于16乘以10的18。而2的47次方是128乘10的第次方。所以它是128 TB。</p>
<p>发言人   06:29<br>So what’s the number after terabyte? You know, 10 to the 15th. How many bytes? Yes, petabytes, right? And do you know what 10 to the 18th is exa? So just as a reference, a company like Google, it probably its total storage across the whole enterprise is measured in some small number of exabytes. And it every day is getting several petabytes. I don’t know the numbers. They are, of course, secret, maybe 10 PB or more per day of new data that it’s ingesting into its system. These numbers are pretty huge, but not just totally off the charts.<br>那么TB之后的数字是多少？你知道，从10到15号。多少字节？是的，是PB，对吗？你知道10到18号是什么意思吗？因此，作为参考，像谷歌这样的公司，它可能以整个企业的总存储容量为一些少量的艾字节来衡量。它每天的数据量为几PB。我不知道数字。当然，它们是秘密的，每天可能有10 PB或更多的新数据进入其系统。这些数字相当巨大，但不仅仅是完全的图表。</p>
<p>发言人   07:31<br>Do you know what 10 to the 21st is. It’s called a zettabyte with two t’s. And it’s estimated if you add up all the digital content in the world, that gets created, everybody’s cell phone, camera, every video taken by anyone, anywhere, all year long is a couple of zettabytes a year.<br>你知道10到21号是多少吗？它被称为带有两个t的泽字节。据估计，如果你把世界上所有被创造出来的数字内容加起来，包括每个人的手机、相机、任何人在任何地方拍摄的每个视频，全年都是几个泽字节一年。</p>
<p>发言人   07:57<br>It’ll be a while before we’re really having to deal with that kind of memory. So just to give you an idea, 128 TB is the address limit on these systems. And so that’s why you have to have 7, because you remember that’s 1, 2, 3, and then there’s F, but there’s 11 of them. And this is 1, 1, 1 times 11, so that’s 44 ones, and this is three ones. And that’s where you get 47.<br>在我们真正不得不处理这种记忆之前，还需要一段时间。所以只是为了给你一个概念，这些系统的地址限制是128 TB。所以这就是为什么你必须有7个，因为你记得那是1、2、3，然后还有F，但有11个。这是1，1，1乘以11，所以这是44个，这是3个。这就是你得到47的地方。</p>
<p>发言人   08:38<br>And that’s the address of in Linux, that’s where they put the stack is up at the very top of the address space.<br>这就是Linux中的地址，这就是他们把堆栈放在地址空间的最顶部的地方。</p>
<p>发言人   08:47<br>And I should tell you, this picture is not at all to scale. It would be impossible to draw this picture to scale. For example, it shows that the stack starts way up at the top. And remember, stacks grow to smaller addresses when you’re pushing. And also we show the them upside down just to make everything confusing. The stack starts there and it grows towards lower addresses. And on a typical system, it will be limited to 8 MB. And you can tell that on a Linux system at least.<br>我应该告诉你，这张照片根本不适合缩放。把这张照片按比例画出来是不可能的。例如，它显示堆栈从顶部开始向上。请记住，当您推送时，堆栈会增长到较小的地址。而且我们把它们颠倒了，只是为了让一切都混乱。堆栈从那里开始，并向更低的地址增长。在典型的系统中，它将被限制为8个MB。你至少可以在Linux系统上看出这一点。</p>
<p>发言人   09:27<br>With the limit command, which? Used to be more interesting than it was is now because a lot of things are unlimited. But you see it says the stack size is limited to 81, 92 kB or kilobytes megabytes. And what that means is if you tried to access any memory via the stack pointer. That was outside of the range. Of this 8 MB range, you’d get a segmentation fault.<br>使用限制指令，哪个？过去比现在更有趣，因为很多东西都是无限的。但是你看到它说堆栈大小限制为81、92 kb或千字节兆字节。这意味着如果您尝试通过堆栈指针访问任何内存。这超出了范围。在这8个MB范围内，你会得到一个段故障。</p>
<p>发言人   10:11<br>And then down at the lower addresses, what comes in, what gets put into your program are the parts of the code that come out of the executable file. And so there’s a section, and we’ll talk more when we talk about linking, actually about the layout of the memory and the different regions of it. But for some obscure reason, they call where the code is sitting, the executable program, the text segment. I don’t know why that’s true, but it’s the way it is. And that’s across many machines.<br>然后在较低的地址处，进来的东西，被放入你的程序中的是来自可执行文件的代码部分。所以有一个部分，当我们谈论链接时，我们会更多地谈论，实际上是关于内存的布局和它的不同区域。但由于一些模糊的原因，他们称之为代码所在的位置，可执行程序，文本段。我不知道为什么那是真的，但事实就是这样。这跨越了许多机器。</p>
<p>发言人   10:43<br>And then the data is a first of all, there’ll be a section for the data that’s allocated program begins. So any global variables that you’ve declared will be in that section. And then the heap is the part of memory that is is allocated via Co Optoma It or one of its related functions. And so that varies dynamically as the program runs. It starts off with a very small allocation, and every time you call malloc. Not freeing memory. And so your memory requirements keep growing. It will keep moving up larger and larger addresses.<br>然后数据是首先，将有一个分配程序开始的数据部分。因此，您声明的任何全局变量都将在该部分中。然后，堆是通过cooptoma It或其相关函数之一分配的内存部分。因此，随着程序的运行而动态变化。它从一个非常小的分配开始，每次你调用malloc。不释放内存。因此，您的内存需求不断增长。它将继续向上移动，地址越来越大。</p>
<p>发言人   11:27<br>And then somewhere in the code too, and this can vary by system, is the code that gets brought in that represents the library functions, things like PDF and malloc itself, our own library code, they’re stored off on disk, and they get brought in, they get linked into your program when it first starts executing by a process known as dynamic linking, which we’ll talk about later in the course too, with the linking.<br>然后在代码的某个地方，这可能因系统而异，是被引入的代表库函数的代码，比如PDF和malloc本身，我们自己的库代码，它们存储在磁盘上，然后被引入，当你的程序第一次开始执行时，它们会通过一个称为动态链接的过程链接到你的程序中，我们将在课程的后面讨论这个链接。</p>
<p>发言人   11:53<br>And what you’ll find in general is that allocations will tend to be either at these very low addresses or these very high addresses as your program is running. So just as an example, here’s some code that it’s only a value is to show you different where things get located.<br>一般情况下，您会发现在程序运行时，分配往往会在这些非常低的地址或这些非常高的地址上进行。所以，作为一个例子，这里有一些代码，它只是一个值，旨在向您展示事物的不同位置。</p>
<p>发言人   12:16<br>And so you’ll see I allocated some fairly large arrays here. This one, they’re all cares, but this is 2 to the 24th, so 16 MB array, and this 1 is 2 to the 31st. So it’s 2 GB worth of ray.<br>所以你会看到我在这里分配了一些相当大的数组。他们都会在意这个，但是这个是2的24次方，也就是16 MB数组，而这个1是2的31次方。所以它是2 GB的射线。</p>
<p>发言人   12:38<br>I found that if I tried to larger ones, the program wouldn’t run. And I also do some. Here’s just a sort of global variable. And here’s a function. And then there’s a single function here with some local variable. And that will be allocated somewhere on the stack. And then there’s several calls to me, some of which are for some very small chunks of memory, and some were for some very large chunks of memory. And so we can run this program and see what addresses pop out of it.<br>我发现如果我尝试将它们变大，程序就无法运行。我也做了一些。这只是一种全局变量。这是一个函数。然后这里有一个带有一些局部变量的函数。并且将在堆栈上的某个位置分配。然后有几个电话给我，其中一些是针对一些非常小的内存块，另一些是针对一些非常大的内存块。因此，我们可以运行这个程序并查看其中弹出的地址。</p>
<p>发言人   13:17<br>And what you’ll see is the stack, this local variable, is somewhere up with an address in the range of the stack. And you see the 7 and a couple f’s, and then it goes to something else. And you’ll see also, interestingly enough, that code. And then looking down at the bottom, this yellow color is things get relegated to the tech segment, the main function.<br>你会看到的是堆栈，这个局部变量，位于堆栈范围内的一个地址。你看到7和几个f，然后它转到别的东西。你还会看到，有趣的是，那个代码。然后往下看底部，这个黄色的东西被降级到技术部分，这是主要功能。</p>
<p>发言人   13:43<br>And this function I declared called useless. And then the predefined arrays that were, in other words, globally, not declared by malloc, declared as part of the program itself, are down here in this data section. And because it’s a very large array, the huge array, you actually get some fairly large addresses. And then interestingly enough, I don’t know why it’s interesting, but for one reason or another, it happens that the smaller chunks of memory allocations are down here at addresses that are actually just a little bit above the pink section. And similarly, the really big chunks of memory I allocated are way up here. Near the stack limit. And so they’re there.<br>这个函数我声明称为无用。然后，换句话说，全局的预定义数组，不是由malloc声明的，声明为程序本身的一部分，在这个数据节中。而且因为它是一个非常大的数组，巨大的数组，你实际上会得到一些相当大的地址。然后有趣的是，我不知道为什么这很有趣，但由于某种原因，发生了这样的情况: 较小的内存分配块在这里，实际上只是略高于粉色部分。同样，我分配的真正大块内存也在这里。接近堆栈极限。所以他们在那里。</p>
<p>发言人   14:45<br>And in general, what’s happening is if I were to try and reference a memory address in this empty range I’d get a segmentation fault. It’s a valid address in terms of its bit properties, but it hasn’t actually been set up and allocated by the virtual memory allocator. So at any given time, the valid addresses are just those in the lower portion or the upper portion of this address ranges. In the middle is sort of no man’s land. And then what happens is you keep allocating more with malloc, and it will push the limits of what’s addressable in toward it.<br>一般来说，如果我尝试引用这个空范围内的内存地址，我会得到一个段错误。就位属性而言，它是一个有效的地址，但虚拟内存分配器尚未实际设置和分配。因此，在任何给定时间，有效地址只是此地址范围的下部或上部的地址。中间是一种无人之地。然后发生的事情是你通过malloc不断分配更多的资源，它会将可寻址的限制推向它。</p>
<p>发言人   15:23<br>And in principle, if you ever got too much of a memory request, these two would hit each other and malloc would return zero at that point. But it’s highly unlikely, given that you have 100 and twenty-eighth raby’s of address range here. So that, and you’ve probably seen this when you’re running, you’re looking at disassembled code with Gdb. You’re seeing some addresses that are way up here with the 7 and some f’s. Those are stack addresses. And you see these fours, a lot of zeros and some fours. Those tend to be where the code is going.<br>原则上，如果你收到了太多的内存请求，这两个内存会相互命中，malloc会在该点返回零。但这是极不可能的，因为你在这里有100和28个狂犬病毒的地址范围。所以，当你运行时，你可能已经看到了这个，你正在看使用Gdb的拆卸代码。你会看到一些地址在7和一些f的位置。这些是堆栈地址。你可以看到这些4个，很多0和一些4个。那些往往是代码要去的地方。</p>
<p>发言人   16:10<br>Now, why doesn’t the heat proceed in one direction? I actually don’t know. I’ll just observe that it had a strategy of putting big things here and small things here, and it probably uses slightly different management strategies for those two.<br>现在，为什么热量不向一个方向散发？我其实也不知道。我只会观察到它有一个把大事放在这里，把小事放在这里的策略，它可能对这两者使用略有不同的管理策略。</p>
<p>发言人   16:34<br>Okay, so that, but I think you’ll find that kind of useful to have some sense when you’re looking at when you’re running Gdb, it helps to just have some idea of what’s going on when you’re looking at these different addresses. Okay, now let’s talk about buffer overflow. And we’ll start this. You remember on the very first class, and I think we might have reviewed this part way along, we showed this example of some programs where if you do an out of bounds reference and write a value that’s out of bounds, in particular, I only have array of two elements here. But this function will take an arbitrary value of I and assign some magic number to element I of the array, and it has the possibility of. And we saw that when you do that, if I gets too big, it will first corrupt the double that’s stored as part of struct, and then when it gets bigger, it seems to not have any effect until it gets too big, and then you start corrupting memory. So the basic point is that it’s very easy in a program, AC program in particular, to a reference memory that’s not part of the sort of intent of the program.<br>好的，所以，但我认为当你在运行Gdb时，一些感知会对你有所帮助，当你在查看这些不同的地址时，了解正在发生的事情会有所帮助。好的，现在让我们谈谈缓冲区溢出。我们将开始这个。你还记得在第一个课上，我想我们可能已经回顾了这一部分，我们展示了一些程序的例子，如果你进行了越界引用并编写了一个越界的值，特别是，我这里只有两个元素的数组。但是这个函数将取任意值I，并为数组的元素I分配一些幻数，它有可能。我们看到当你这样做时，如果I变得太大，它将首先破坏作为struct一部分存储的double，然后当它变得更大时，它似乎没有任何影响，直到它变得太大，然后你开始破坏内存。所以基本的观点是，在一个程序中，特别是在交流程序中，要有一个不属于程序意图的参考存储器是非常容易的。</p>
<p>发言人   18:06<br>Happen in programs that aren’t properly written? That, and it becomes a security vulnerability.<br>发生在没有正确编写的程序中？这就变成了一个安全漏洞。</p>
<p>发言人   18:14<br>If there’s some way for an outsider two overflow, a buffer. For example, if there was some way for an outsider to give a larger value of I and ask that value be stored there, it could crash the program. And so in general, when you write in code, you try to think about, can I trust this value? A value that’s been computed by my program? And I’m sure that it’s within bounds? Or is it something that’s come from an external source and there has potentially at risk of being a vulnerability?<br>如果有一种方法可以让局外人溢出，那就是缓冲区。例如，如果外部人员有某种方法可以给出较大的I值并要求将该值存储在那里，则可能会导致程序崩溃。所以一般来说，当你写代码时，你会试着思考，我可以相信这个值吗？我的程序计算过的值？我相信它在范围内？或者它是来自外部来源并且可能存在成为漏洞的风险？</p>
<p>发言人   18:51<br>And so in particular, there’s a huge class of errors that have to do with overflowing buffers, where they’re trying to store a string of some type that’s been read from a message. And without knowing in advance how big that string is, it’s possible that it will be too big for the buffer that’s been allocated. And so one of the culprits is there’s a whole class of of library functions that let you store something, a string somewhere, without any kind of bounds checking, even being possible.<br>因此，尤其是有一大类错误与溢出的缓冲区有关，它们试图存储从消息中读取的某种类型的字符串。并且在事先不知道该字符串有多大的情况下，很可能对于已分配的缓冲区来说它太大了。因此，罪魁祸首之一是有一整套库函数类，让你可以在某个地方存储字符串，而无需任何边界检查，甚至是可能的。</p>
<p>发言人   19:31<br>So the sort of the worst 1 is one called get S, and the purpose of get S is normally it’s used to read a string from an input from a terminal input, something that somebody’s typed into a terminal. And so what it’s doing is it’s scanning this input string and looking for a character that represents the end of the line, which we write in c as backslash n, and it has the character code in hex of 0 a. And so gets this is sort of an approximate version of what the code for gets looks like. And as an argument, it’s just given a destination of where to store the result. And all it does is it reads one character at a time, looks for an endo file, meaning that the input stream is closed or an end of line. But as long as until it sees that, it just keeps adding more things to the end of this buffer. And so typically.<br>因此，最差的1被称为get S，而get S的用途通常是用于从终端输入的输入中读取字符串，这是某人在终端中键入的内容。所以它正在扫描这个输入字符串并寻找代表行尾的字符，我们用c写成反斜杠n，它的字符代码为0 a的十六进制。这有点像代码的近似版本。作为参数，它只是给出了存储结果的目的地。它所做的只是一次读取一个字符，查找endo文件，这意味着输入流已关闭或行尾。但只要在看到之前，它就会不断地在缓冲区的末尾添加更多的东西。如此典型。</p>
<p>发言人   20:45<br>When somebody calls gets, they’ll pass it a pointer to some buffer that they’ve allocated, but the function and it will get will just fill that buffer up, but it can potentially just keep going. There’s nothing in the function. There’s not even an argument to the function that tell the function when it has to stop, when it’s reached the limit of it. So it was written. Actually get us is if you try to compile code with get us, it will flash up a big warning that says this is really an unsafe function. You probably shouldn’t even be using it because it was written in an era in the 1970s when the early Unix distributions were coming out where people just weren’t worried about security vulnerabilities. And they just assumed that if you allocated a big enough buffer that there’s no reason why a string should be bigger than what you’ve allocated. And that’s actually true with other functions like stir, copy, you recall Ste coppi.<br>当有人调用get时，他们会传递一个指针给他们分配的某个缓冲区，但是函数和它将会填满这个缓冲区，但它可能会继续运行。这个功能里什么都没有。函数甚至没有一个参数告诉函数何时必须停止，何时达到限制。所以它被写了。实际上，如果您尝试使用get us编译代码，它将会弹出一个大警告，指出这确实是一个不安全的功能。你可能甚至不应该使用它，因为它是在1970年代编写的，当时早期的Unix发行版出现了，人们并不担心安全漏洞。他们只是假设，如果您分配了足够大的缓冲区，那么字符串就没有理由比您分配的大。这实际上适用于其他功能，如搅拌，复制，你记得Ste coppi。</p>
<p>发言人   21:59<br>Has two arguments, a destination and a source, and its purpose is to copy the string, the source into the destination and the way it determines the end of the string in the source is when it hits a null character and it just keeps copying one by one until it hits that. But it has no way of knowing. There’s no information there about how much, how big is the buffer allocated at the destination. And so it can easily overrun that. A similar one called stir cat, which is used to concatenate two strings, copy them to another destination.<br>有两个参数，一个是目标，一个是源，它的目的是将字符串复制到目标中，它确定源中字符串结尾的方式是当字符串命中null字符时，它会一直复制，直到命中该字符为止。但它没有办法知道。没有关于在目的地分配了多少缓冲区或有多大缓冲区的信息。因此它很容易超过那个。一个类似的叫做搅拌猫的方法，用于连接两个字符串，并将它们复制到另一个目的地。</p>
<p>发言人   22:39<br>And the scanner functions also have possible in the format string. You can give the percent S directive to the format string, which says read in a string and store it someplace. And it doesn’t say how long the string is limited to be, and it doesn’t say how much memory is available at the destination. So again, it can easily just write over that buffer.<br>和扫描仪功能也可以在格式字符串中使用。你可以给格式字符串指定百分比S指令，表示读取一个字符串并将其存储在某个地方。它没有说字符串的长度限制，也没有说目的地有多少内存可用。所以再次强调，它可以轻松地在缓冲区上写入。</p>
<p>发言人   23:07<br>So these are real vulnerabilities, and we’ll talk in a minute a little later about how you as a programmer can be a little smarter than this, but in their sort of raw form as presented, they have this vulnerability to them.<br>所以这些是真正的漏洞，我们稍后会谈到作为一名程序员如何比这更聪明一些，但在他们所呈现的原始形式中，他们有这种漏洞。</p>
<p>发言人   23:24<br>So let’s look at an example of what can happen there. So imagine, for example, we want to implement an echo function. So an echo function is one that you just type something in and it prints it back out. It’s a very uninteresting function, except it’s very useful to demonstrate things. So the idea is it has this little buffer, it’s only enough to hold four characters. It calls get us to read a string from the input, and then it calls put S, which simply writes back out the output.<br>让我们看一个例子，看看那里可能发生什么。想象一下，例如，我们想要实现一个echo函数。所以echo函数就是你只需要输入一些东西，然后它就会打印出来。这是一个非常无趣的功能，但它在演示方面非常有用。所以这个想法是它有一个小缓冲区，它只够容纳四个角色。它调用get来读取输入中的字符串，然后调用put S，这只是简单地写出输出。</p>
<p>发言人   24:10<br>And so let me just demo this not very interesting function.<br>所以让我演示一下这个不是很有趣的功能。</p>
<p>发言人   24:22<br>So I call it here buff demo dash Nsp, meaning it has no stack protector. We’ll see in a minute what a stack protector is. But you see, if you type a reasonably strong small string.<br>所以我在这里叫它buff demo dash Nsp，意思是它没有堆栈保护器。我们马上就会看到什么是堆栈保护器。但是你看，如果你键入一个相当强大的小字符串。</p>
<p>发言人   24:43<br>Let’s see I’ve got to remember it can handle more than 4. Actually, as written, it can’t handle more than three because there should be room for the null character too, our terminator.<br>让我们看看，我必须记住它可以处理4个以上的数据。实际上，正如所写，它不能处理超过三个，因为我们的终结者也应该有空字符的空间。</p>
<p>发言人   25:04<br>So it turns out with this particular one, if I type in a string of 24 characters, it’ll be okay.<br>所以事实证明，对于这个特定的一个，如果我输入24个字符的字符串，就没问题了。</p>
<p>发言人   25:23<br>But if I type in a string of 24 characters. It will hit a segmentation fault. So where do those numbers, 20 thre and 24, come in. Well, that’s something we can learn by looking at the assembly code.<br>但是如果我输入了一个24个字符的字符串。它会碰到一个段的故障。那么这些数字20 thre和24在哪里出现呢？嗯，这是我们可以通过查看汇编代码来学习的东西。</p>
<p>发言人   25:58<br>So here, and we’ll go through this code. So first of all, this is the code for Echo then. And you see the echo calls get S, and it calls put S. And here’s the part of the code where you can tell how much memory got allocated for the buffer and x 1, 8.<br>所以在这里，我们将浏览这段代码。首先，这是Echo的代码。你会看到echo调用get S，它调用put S。这是代码的一部分，您可以告诉缓冲区和x 1、8分配了多少内存。</p>
<p>发言人   26:29<br>Is what in decimal? 24, right? And you just saw that the thing actually seg faults with an input string of 24. So we’ll see that in a minute. But anyways, you can see here that it’s allocating on the stack a region of 24 B and it’s. Copying that into RGI, which is of course the argument for Get us, so Get us, is being called with a pointer to a buffer of size 24 of maximum 24. Even though you saw the original declaration was just for four. And then it calls. And then Geddes does it thing. And just one last good bit to keep in mind is we’ll get back to that.<br>十进制是什么？24对吧？你刚刚看到这个东西实际上用输入字符串24来切断故障。所以我们马上就会看到。但无论如何，你可以在这里看到它在堆栈上分配了一个24 B的区域。将其复制到RGI中，这当然是Get us的参数，所以Get us正在被调用，并使用一个指针指向一个最大24大小的缓冲区。尽管你看到最初的声明只有四个。然后它打电话。然后格迪斯做了这件事。最后一点需要记住的是，我们会回到那个问题的。</p>
<p>发言人   27:34<br>Oh, yes, and remember Echo? There’s a function called call echo, which is the thing that calls echo. And just to keep in mind, this red is the return address for call echo. And that’s going to be important. So what we see then is the memory layout is. Buff is normally big enough for four characters. There’s sort of 20 B of unused or wasted space here. And then the actual return address, which is the return address for back to call Echo, is stored on the stack.<br>哦，是的，还记得回声吗？有一个叫做call echo的函数，它是调用echo的东西。请记住，这个红色是呼叫回声的返回地址。这将是很重要的。所以我们看到的是内存布局。Buff通常足够容纳四个字符。这里有20 B未使用或浪费的空间。然后，实际的返回地址 (即回叫Echo的返回地址) 存储在堆栈上。</p>
<p>发言人   28:25<br>So when this program begins running, when Echo starts to run, we’ll find that this is the value on the stack for the return pointer. And if we type in a string of. Of here of 23 characters, you’ll see that it uses up this entire buffer. And remember, a string is terminated with a 0 0, but it’s still within the region that was allocated on the stack for that fits into the stack. And that’s why technically we overflow the buffer. But we didn’t really cause any harm because there was this extra space available. And so that’s why I could type in that string of 23 characters and it worked fine. But now if I type in. This is an example showing.<br>所以当这个程序开始运行时，当Echo开始运行时，我们会发现这是堆栈上返回指针的值。如果我们输入一个字符串。如果这里有23个字符，你会看到它使用了整个缓冲区。记住，字符串以0结尾，但它仍然在堆栈上分配的适合堆栈的区域内。这就是为什么从技术上讲我们溢出缓冲区的原因。但我们并没有真正造成任何伤害，因为有这个额外的可用空间。这就是为什么我可以输入23个字符的字符串，并且它工作得很好。但是现在如果我输入。这是一个展示的例子。</p>
<p>发言人   29:31<br>Actually, 25 characters. So once I go beyond the 23 characters plus the null character, you’ll see what I’m slowly starting to do is, is corrupt the byte representation of the return address? And so what happens, for example, here is that rather than trying to return back to where call echo, where it was supposed to go back to, it goes back to some other part of your code that may or may not be a valid address or might not have anything to do with the program you’re trying to run. So this example shows it. And if I typed in the 24.<br>实际上，25个字符。所以一旦我超过了23个字符加上空字符，你会看到我慢慢地开始做的是，返回地址的字节表示是否已损坏？所以发生了什么，例如，这里不是试图返回到呼叫回声应该返回到的地方，它会返回到代码的其他部分，这些部分可能是或可能不是有效的地址，或者可能与您尝试运行的程序没有任何关系。这个例子说明了这一点。如果我输入24。</p>
<p>发言人   30:24<br>Let’s see, before I got it to run. This thing depends on what happens, how the code happens to get compiled. Oh yeah, so. Actually, you see here, this first string I typed is actually 24 characters long plus the null pointer. So, and we’ll see why it didn’t. It should have crashed because we actually overwrite wrote the low order byte of the return address here. We typed in, this is 2500 characters, and so that’s the 1 I just showed where it really whacked the 2 B of the return address. So here we actually did overflow the buffer. And let’s try and figure out why that didn’t harm the program execution.<br>让我们看看，在我运行之前。这取决于发生了什么，代码如何被编译。哦，是的，所以。实际上，你看这里，我输入的第一个字符串实际上有24个字符加上空指针。所以，我们会看到为什么它没有。它应该已经崩溃，因为我们实际上在这里覆盖了返回地址的低位字节。我们输入了，这是2500个字符，这就是我刚刚展示的1，它确实破坏了返回地址的2 b。所以这里我们实际上确实溢出了缓冲区。让我们试着弄清楚为什么这没有损害程序的执行。</p>
<p>发言人   31:19<br>I see a question in this case, but is it possible there could have been, there could have been various other things, could have nothing? It hit a segmentation fault because it probably went to some weird part of the code and just started executing some random stuff and just got itself into trouble. But that’s the point is it’s not predictable exactly what will happen when you do this.<br>在这种情况下，我看到了一个问题，但是否可能存在，可能存在各种其他事情，可能什么都没有？它遇到了一个段故障，因为它可能进入了代码的某个奇怪的部分，并开始执行一些随机的东西，从而让自己陷入了麻烦。但关键是当你这样做时，无法准确预测会发生什么。</p>
<p>发言人   31:54<br>So this is an example of what actually happened the first time when I typed in a string that had 24 characters. And so this null byte at the index where corrupted the return address. And so it was supposed to return back to this address for 0 0 6 F 6. And instead, it will return back to the address 4 0 6 0 0, which happens to be in some other weird function that’s there.<br>所以这是一个例子，当我第一次输入一个有24个字符的字符串时实际发生了什么。因此，索引处的这个空字节损坏了返回地址。所以它应该在0 0 6 F 6返回到这个地址。相反，它将返回地址4 0 6 0 0，该地址恰好在某个其他奇怪的函数中。</p>
<p>发言人   32:24<br>And it just sort of landed at some place here. And it’s doing various things. But somehow it really didn’t crash the program. And that’s one of the frustrating things about this is things can go wrong in a program and they don’t always cause a crash. And so often a bug that’s working there might be doing some weird stuff that you don’t even know about. So that’s all fine if it’s just a way of crashing programs. I mean, that’s not great if it’s controlling your pacemaker or something like that. If it’s just a homework assignment, it’s not a big deal.<br>它只是降落在这里的某个地方。它正在做各种各样的事情。但不知何故，它真的没有使程序崩溃。这是令人沮丧的事情之一，在一个程序中，事情可能会出错，而且它们并不总是会导致崩溃。而且经常有一个bug在那里工作，可能会做一些你甚至不知道的奇怪事情。所以如果这只是一种使程序崩溃的方法，那也没关系。我的意思是，如果它控制着你的起搏器或类似的东西，那并不好。如果这只是一份家庭作业，那也没什么大不了的。</p>
<p>发言人   33:12<br>But what actually, and this is sort of only happened since attacking, became a normal activity, which has only been the last 30 years, is that it gives an opportunity for attacker or attacker to inject code into the program and execute it. And that’s what’s called a code injection attack.<br>但实际上，这种情况只是在攻击成为正常活动之后才发生的，这只是最近30年的事情，它为攻击者或攻击者提供了将代码注入程序并执行它的机会。这就是所谓的代码注入攻击。</p>
<p>发言人   33:38<br>And so the general scheme of it is I have this buffer that I can fill up with whatever bytes I want by feeding them to get S or whatever function is doing this copying. And what I can do then is set up and pass to it some bytes that encode an executable, a little bit of executable code you’ve seen in object dump. It’s printing out these byte code representations of instruction.<br>因此，它的一般方案是我有一个缓冲区，我可以通过供给它们以获取S或任何正在进行此复制的函数来填充我想要的任何字节。然后我可以做的是设置并传递给它一些编码可执行文件的字节，一点点可执行代码，你在对象转储中看到过。它正在打印出这些指令的字节码表示。</p>
<p>发言人   34:05<br>So imagine you fed some of those bytes into your string. You encode them in the string that you pass to get S, and then you might have to add some more sort of paddings, characters whose value doesn’t matter, in order to then get a number back into the position where the return pointer is supposed to be. And so what’s called that number B? It’s going to be an address. One of these ones with that represents a stack location. And value B, then, is the starting address of the buffer, which happens to be where your exploit code.<br>想象一下你将其中一些字节输入到你的字符串中。你将它们编码在传递给获取S的字符串中，然后你可能需要添加更多类型的填充，值无关紧要的字符，以便将数字放回返回指针应该所在的位置。那么那个数字B叫什么？这将是一个地址。其中一个代表堆栈位置。值B是缓冲区的起始地址，恰好是您的利用代码所在的位置。</p>
<p>发言人   34:50<br>Remember, this is just executable instructions we’re stored here. So now what will happen is when the program does its return. Here it was supposed to return back to wherever it got called from P?<br>记住，这只是我们存储在这里的可执行指令。所以现在会发生的是当程序返回时。在这里，它应该返回到它从P被召唤的地方？</p>
<p>发言人   35:13<br>This is a type O p calls q, not bar. So it’s supposed to return back to P? And the return address was stored here, but now I’ve overwritten that return address with this buffer position. So what will happen is the program counter will happily jump to this spot and start executing whatever it encounters, which are the instructions that you’ve inserted. And by that means, then you can inject code into a machine, potentially somewhere else in the internet. If you could set up a scheme like this that would feed these bytes into that machine, and it would read it in with a function like gets, and then it would try to do its return, but it would start executing your code. So that’s a classic code injection attack.<br>这是一种O p类型调用q，而不是bar。所以它应该返回到P？并且返回地址存储在这里，但是现在我已经用这个缓冲区位置覆盖了该返回地址。所以会发生的是程序计数器会很高兴地跳转到这个位置，并开始执行它遇到的任何事情，即你插入的指令。通过这种方式，你可以将代码注入机器，可能是在互联网的其他地方。如果你可以建立一个像这样的方案，将这些字节输入到那台机器中，它会使用像gets这样的函数读取它，然后它会尝试执行它的返回，但它会开始执行你的代码。所以这是一种典型的代码注入攻击。</p>
<p>发言人   36:11<br>And in fact, in this lab that you’re going to start, it comes out at midnight. It’s called the attack lab because you’re going to do this yourself for part of the lab. And I think you’ll find it pretty interesting. So this used to be a huge problem on programs.<br>事实上，在这个你要开始的实验中，它在午夜结束。它被称为攻击实验室，因为你将自己为实验室的一部分做这件事。我想你会发现它很有趣。所以这曾经是程序上的一个大问题。</p>
<p>发言人   36:37<br>Yes, on the last slide. So when you’re trying to replace red, how do you make sure that your new submitted red? Well, that’s part of the cleverness of being a hacker. You have to make sure it’s in the right spot, but that’s actually one of the easier parts because, for example, if you have to know the binary code. To be able to do this or be able to guess. So for example, in that previous 1, I could tell that it was allocating 24 B for that buffer. So if I just made sure that the length of my exploit code plus the padding is 24 B, then right after that comes to the return address. So that’s actually pretty easy to do much program.<br>是的，在最后一张幻灯片上。那么当你试图替换红色时，你如何确保你新提交的红色？好吧，这是作为一名黑客聪明的一部分。你必须确保它在正确的位置，但这实际上是更容易的部分之一，因为例如，如果你必须知道二进制代码。能够做到这一点或者能够猜测。所以例如，在之前的1中，我可以看出它为该缓冲区分配了24 b。所以如果我只是确保我的漏洞利用代码的长度加上填充是24 B，那么接下来就是返回地址。所以这实际上很容易做很多程序。</p>
<p>发言人   37:25<br>No, you have to have access. The reason why this works is. It works if you have enough knowledge about the operating system that’s running at the other end. For example, you know it’s Linux. You know that you can look at what GCC tends to allocate for it, or you somehow have access to information about the code itself, letsgo do this.<br>不，你必须有访问权限。这个工作的原因是。如果您对另一端运行的操作系统有足够的了解，它就会起作用。例如，你知道它是Linux。你知道你可以查看GCC倾向于为它分配什么，或者你以某种方式有权访问代码本身的信息，让我们这样做。</p>
<p>发言人   37:59<br>So anyways, this used to be a huge problem and it started way back in 1988, the first internet attack called the Morris Worm. And at the time, the internet was not a very big place and it basically brought down a huge fraction of the machines that were on the internet at the time. Interestingly enough, CMU did not fall victim to this attack because we’d patched already the vulnerabilities that this particular program exploited. And that was the cause that the Software Engineering Institute runs an organization called Cert, the Computer Emergency Response Team. And that team was set up in response to this attack, the Morris worm attack.<br>所以无论如何，这曾经是一个巨大的问题，它开始于1988年，第一个被称为莫里斯蠕虫的互联网攻击。当时，互联网不是一个很大的地方，它基本上导致了当时互联网上很大一部分机器的崩溃。有趣的是，CMU并没有成为这次攻击的受害者，因为我们已经修补了这个特定程序利用的漏洞。这就是软件工程研究所运营一个名为Cert的组织，即计算机应急响应团队的原因。那个团队就是为了应对莫里斯蠕虫的攻击而建立的。</p>
<p>发言人   38:51<br>We’ll also see an interesting example between two companies in messaging services and many others. It’s been the sort of standard attack mechanism for many years. And fortunately, nowadays, there’s a few things that make the attacking less likely to be successful. And so it’s not as huge a problem as it used to be, but still, it’s as far as some many vulnerabilities in programs.<br>我们还将看到两家消息服务公司和许多其他公司之间的有趣例子。多年来，它一直是标准的攻击机制。幸运的是，如今有一些事情使得攻击不太可能成功。因此，这不再是一个像以前那样巨大的问题，但仍然存在程序中的许多漏洞。</p>
<p>发言人   39:21<br>So let’s see, I won’t talk too much about this, but it used to be in the original implementation of there’s a command that most systems have now disabled that you could finger, you could request information about somebody in some remote location. It would send a message to that location, and then it would reply back. And it used gets the actual original implementation called, gets to read the input string from that was being sent to it.<br>所以让我们看看，我不会过多谈论这个，但它曾经是在最初的实现中，现在大多数系统都禁用了一个命令，你可以通过手指请求有关某个远程位置的某人的信息。它会向该位置发送消息，然后回复。它使用获取实际的原始实现，获取要发送给它的输入字符串。</p>
<p>发言人   39:58<br>And then there was an interesting one. You guys don’t remember messaging, instant messaging. But before it used to be that people would talk to each other on their computers by sending messages, sort of like you send text messages today.<br>然后有一个有趣的。你们不记得即时通讯了。但以前人们会在电脑上通过发送信息相互交流，有点像今天你发送短信。</p>
<p>发言人   40:14<br>But there is an interesting thing that there is a company still exists, but it’s a shadow, its former self called AOL, which ran the most popular internet services and had the most popular instant messaging program. And Microsoft came out with its client, its own program that you could run on your machine and communicate to other people on this messaging system. So the Microsoft code was running on your machine, but it would use the servers that were being run by AOL to manage this messaging traffic and. The funny story was. This Microsoft program would work fine. You could communicate with your friends who had different messaging clients, and it all seemed compatible.<br>但是有一件有趣的事情，那就是有一家公司仍然存在，但它只是一个影子，它以前的名字叫AOL，它运营着最受欢迎的互联网服务，并拥有最受欢迎的即时通讯程序。微软推出了它的客户端，它自己的程序，你可以在你的机器上运行，并通过这个消息系统与其他人通信。因此，Microsoft代码正在您的计算机上运行，但它将使用AOL运行的服务器来管理此消息传递流量。有趣的故事是。这个微软程序可以正常工作。您可以与拥有不同消息客户端的朋友进行通信，并且看起来都兼容。</p>
<p>发言人   41:11<br>Suddenly, the people that were running the Microsoft version of the software, it wouldn’t work. And then Microsoft people figured out how to patch it, and then it would work for a while, and then it wouldn’t work.<br>突然间，那些运行微软版本软件的人无法工作。然后微软的人想出了如何修补它，然后它会工作一段时间，然后它就行不通了。</p>
<p>发言人   41:22<br>And the way what was happening was AOL was using a bug in its own code to be able to determine who’s basically peek into the machines on the client side and do a buffer overflow attack on your code that you’re running on your machine. And then basically peek around and see, does this look like AOL code or is it some foreign code? And so it was basically able to use its own security weakness to figure out this information. And that got disclosed by a sort of funny message from somebody who called himself Phil Bucking. And it was determined that this email originated from somewhere within Microsoft. So anyways, and you can read more about it in the book around the slide fun stories.<br>而发生的事情是AOL在自己的代码中使用了一个错误，以便能够确定谁基本上是窥视客户端的机器，并对您在机器上运行的代码进行缓冲区溢出攻击。然后基本上看看，这看起来像AOL代码还是一些外国代码？因此，它基本上能够利用自己的安全弱点来找出这些信息。这个消息被一个自称Phil Bucking的人透露出来了。并且已确定此电子邮件起源于Microsoft内部的某个地方。所以无论如何，你可以在书中围绕幻灯片有趣的故事阅读更多关于它的内容。</p>
<p>发言人   42:24<br>So in general, in the security world, you’re supposed to distinguish between the idea of a worm and a virus, although people aren’t very good at doing that. So worm is a program that can run on its own and propagate itself from one place to the other and replicate it. A virus is like a biological virus. It doesn’t live on its own. It works by attacking a program and basically modifying that program’s behavior. So that gives you the basic idea of buffer overflows, and you’ll see it more first-hand.<br>所以一般来说，在安全领域，你应该区分蠕虫和病毒的概念，尽管人们不太擅长这样做。所以蠕虫是一种可以独立运行并从一个地方传播到另一个地方并复制它的程序。病毒就像生物病毒。它不会自己生活。它的工作原理是攻击程序并基本上修改该程序的行为。这样就给了你缓冲区溢出的基本概念，你会更直接地看到它。</p>
<p>发言人   42:59<br>So let’s look at techniques that machines can use to avoid, to make themselves less vulnerable to these attacks.<br>所以让我们看看机器可以用来避免的技术，使自己不那么容易受到这些攻击。</p>
<p>发言人   43:08<br>Well, first of all, you application or the writer on the server side can write code that’s more secure. So for example, what you’re supposed to do instead of get SI use a function called FGE s, and f gets has a property that it passes a parameter, which is the maximum number of bytes that the program should read. And if there’s more bytes than that in the input, it will just truncate the input. So you’re really supposed to use f gets and give a limit. Similarly, stir copy. There’s a version of called Stern copy where you can give a limit. And with scanf, you’re supposed to be careful about using the percent s, there’s even a terminology, you can say percent given a number that the maximum length of the string it should read.<br>首先，您的应用程序或服务器端的作者可以编写更安全的代码。所以举个例子，你应该使用一个叫做FGE s的函数来代替get SI，而f gets有一个属性，它传递一个参数，这个参数是程序应该读取的最大字节数。如果输入中的字节数多于这个字节数，它将只截断输入。所以你真的应该使用f gets并给出一个限制。同样地，搅拌复制。有一个叫做斯特恩复制的版本，你可以给出一个限制。使用scanf，你应该小心使用百分比，甚至还有一个术语，你可以说百分比给定一个数字，它应该读取的字符串的最大长度。</p>
<p>发言人   44:06<br>So there’s various places you can protect your code to make sure it won’t overflow buffers, unfortunately. And a lot of code has been, you’d call it hardening. People have gone through it. And it’s a lot of work because there’s a lot of places in programs where you’re copying strings from one place to another. And there are a lot of real subtleties, like when you’re converting from Unicode to bytes and so forth, you’re going back and forth between different character encodings. But for the large part, and those tools that the code developers have created to help track down these bugs. So it’s become a little bit safer out there, but there’s still vulnerabilities.<br>所以有很多地方可以保护你的代码，以确保它不会溢出缓冲区。很多代码已经被你称之为硬化。人们经历过它。这需要很多工作，因为在程序中有很多地方需要将字符串从一个地方复制到另一个地方。而且有很多真正的微妙之处，比如当你从Unicode转换成字节等等时，你就在不同的字符编码之间来回切换。但是在很大程度上，以及代码开发人员创建的用于帮助追踪这些错误的工具。所以外面变得有点安全，但仍然存在漏洞。</p>
<p>发言人   44:51<br>So then there’s other parts where you just try to build in safeguards into the system that would make it much harder to do a buffer overflow exploit like I showed you. And so one of them is called stack randomization, or it goes by a more general term. That’s abbreviated Aslr, which stands for address space. Layout randomization. And the idea of it is to make it so every time a program runs, the addresses change a little bit or a lot so that you can’t reliably know where things are going to be in the code. So imagine, for example, and the way it’s implemented is in the sort of run up of your program when it first starts up, but before your main routine gets called, it will just do an allocation on the stack of some random number of bytes of storage, a fair amount, like maybe a megabyte roughly of storage, where the exact number is randomly chosen. And what that means is that the dress of the stack of all the different positions of your, all the local storage on the stack will shift up and down from one run to another. And we can actually see that in this example I showed.<br>因此，还有其他部分，您只需尝试在系统中建立保护措施，这将使缓冲区溢出利用变得更加困难，就像我向您展示的那样。因此，其中一个被称为堆栈随机化，或者用一个更通用的术语来表示。它缩写为Aslr，代表地址空间。布局随机化。它的想法是让每次程序运行时，地址都会发生一点点或很多变化，这样你就无法可靠地知道代码中的内容将会在哪里。例如，想象一下，它的实现方式是在程序首次启动时启动，但在调用主例程之前，它将在堆栈上分配一些随机数量的存储字节，相当数量，大概是一兆字节的存储空间，其中确切的数字是随机选择的。这意味着，堆栈的所有不同位置的衣服，堆栈上的所有本地存储将从一个运行到另一个运行上下移动。在我展示的这个例子中，我们实际上可以看到。</p>
<p>发言人   46:36<br>So I have a program here. It’s not a very interesting program I’ll show you, except to demonstrate these ideas. All it’s doing is there’s some code it’s based on that 1 I already showed called locate. This one, there’s a global variable, there’s some functions, there’s something that gets allocated by malloc, and there’s something that is a local variable stored on the stack. And so what I’ll do is show addresses that are chosen, the address of this variable. Then we will be stack address of a local variable. Global will be this one that gets allocated globally.<br>所以我在这里有一个计划。除了演示这些想法之外，我将向您展示的程序不是一个非常有趣的程序。它所做的只是有一些代码，它基于我已经展示过的那个叫做locate的代码。这个有一个全局变量，有一些函数，有一些由malloc分配的东西，还有一些存储在堆栈上的局部变量。所以我要做的就是显示选择的地址，这个变量的地址。那么我们将成为本地变量的堆栈地址。全球将是全球分配的。</p>
<p>发言人   47:22<br>The heap is something allocated with malloc, and then this function useless, we’ll count as a code address. And now when I run it. You’ll see from one run to another that if some of these stay the same in stem of them change. So in particular, the global variable is the same 6001 2 c, and the code is the same 4 0 0 5 9 0 is the same every execution. But you’ll see this local variable.<br>堆是用malloc分配的，然后这个函数就没用了，我们就算作一个代码地址。现在当我运行它的时候。你会发现，如果其中一些在词干保持不变，它们会发生变化。特别地，全局变量是相同的6001 2 c，代码是相同的4 0 0 5 9 0每次执行都是相同的。但你会看到这个局部变量。</p>
<p>发言人   48:02<br>It’s a stack address. But you see that the lower half dozen or so bytes are actually changing from one run to another. One, 2, 3, 4, 5. So 5 B of thats? Well, five hex digits. I’m sorry, so that’s two to the 20th. So roughly a megabyte of variation is going on in stack addresses there. And similarly, you’ll see that the heap addresses are also varying from one to another, from one execution to the other.<br>这是一个堆栈地址。但是你可以看到下半部分大约十几个字节实际上正在从一个运行变为另一个运行。一，二，三，四，五。那么5 B呢？嗯，五个十六进制数字。对不起，这是2比20。因此，在堆栈地址中大约有一兆字节的变化正在发生。同样地，您会看到堆地址也因执行而异，从一个执行到另一个执行。</p>
<p>发言人   48:36<br>So malloc has built into it some amount of randomness too, in its allocation. So why is that? What’s the purpose of that?<br>所以malloc在它的分配中也加入了一些随机性。为什么呢？这样做的目的是什么？</p>
<p>发言人   48:48<br>As I told you, this code injection vulnerability. Relies on the fact that you can load up this buffer with some executable code, but somehow you have to know how to get to the start of that code. And so the attack is relying on the fact that it can somehow predict what the this address of the buffer is so that it can store it in the right of the string, encode it in the right part of the string, so it will show up where the return point is supposed to be, and have it jump to that location. But now with this randomization, this number is varying by quite a bit, sort of a million over a range of 1 million or so values. So there’s no way in advance, even if I have an exact copy of the code, and I even had access to the system itself and could run it, I can’t predict from one run to the next where it’s going to be. So that gives sort of thwarts this particular attack to make it using this randomization.<br>正如我告诉你的，这个代码注入漏洞。依赖于这样一个事实: 你可以用一些可执行代码加载这个缓冲区，但不知何故，你必须知道如何到达代码的开头。因此攻击依赖于它可以以某种方式预测缓冲区的地址，以便它可以将其存储在字符串的右侧，将其编码在字符串的右侧，因此它将显示返回点应该在哪里。并让它跳到那个位置。但是现在有了这种随机化，这个数字变化很大，在100万左右的范围内变化有一百万。所以即使我有代码的精确副本，即使我可以访问系统本身并可以运行它，我也无法预测它从一次运行到下一次运行的位置。因此，这在某种程度上挫败了这种特定的攻击，使其使用这种随机化。</p>
<p>发言人   50:06<br>Another idea that’s fairly straightforward, but it took a long time for the hardware people to implement this is, well, why is there supposed to be code on the stack in the first place? Isn’t the code supposed to be located down in the text segment where it can be especially identified as being executable?<br>另一个相当简单的想法，但是硬件人员花了很长时间才实现，那么，为什么一开始就应该在堆栈上有代码呢？难道代码不应该位于文本段下面，在那里它可以被特别识别为可执行的地方吗？</p>
<p>发言人   50:29<br>So in the original x 86, there is a 1 b flag for each region of memory saying, is it actually 2 1 b flags? One is, can this be written to so that you can prevent overwrites of things like string constants? And so? And then the other is, can I read it? And read means access those bytes and it was interpreted that readable and executable were the same. I can read it, I can execute it. And that was the rules in the sort of last 10 years or so, starting first with AMD and then Intel.<br>所以在原始的x86中，每个内存区域都有一个1 b的标志，它实际上是2个1 b的标志吗？一个是，是否可以将其写入以防止覆盖诸如字符串常量之类的内容？所以呢？然后另一个问题是，我可以读吗？和读意味着访问这些字节，它被解释为可读和可执行的是相同的。我可以阅读它，我可以执行它。这就是过去10年左右的规则，首先是AMD，然后是英特尔。</p>
<p>发言人   51:12<br>I’ve added a third bit that says, is this executable or not? Similarly to the permissions you have on a file on Unix, is it readable, writable, executable? Those are three separate permission debts that are allowed. So by simply marking the stack is not executable, it’ll also thwart this particular attack because I have to be able to execute these bytes that I’ve injected into the system.<br>我已经添加了第三个位，上面写着，这个可执行文件吗？类似于您在Unix上对文件拥有的权限，它是可读、可写或可执行的吗？这是三个允许的独立许可债务。因此，通过简单地将堆栈标记为不可执行，它也将阻止此特定攻击，因为我必须能够执行我注入系统的这些字节。</p>
<p>发言人   51:40<br>And then there’s a final idea, which is actually fairly effective too, which they call a canary that they built into the stack. And some of you actually encountered this code already. And looking at your bombs, because we’ve been getting some questions about it. So let me just give you an example here.<br>然后还有一个最终的想法，实际上也相当有效，他们称之为金丝雀，他们内置到堆栈中。你们中有些人已经遇到过这段代码了。并看着你们的炸弹，因为我们一直在收到一些问题。让我在这里给你一个例子。</p>
<p>发言人   52:09<br>And this one’s called Buff Demo Dash S because it’s been compiled with what they call a stack protector and.<br>这个叫做Buff Demo Dash，因为它是用所谓的堆栈保护器编译的。</p>
<p>发言人   52:20<br>This one now, it’s the same code as before. It’s just compiled a little bit differently. What you’ll find is I can give a string of length 8 and not have a problem. But if I now have 9 characters, it will dump out with this very strange exit error message. That is an indication. That it’s detected? Attempt to smash the stack. So buffer overflow is sometimes called stack smashing. So it detected somehow that even though my code was still the same old crappy code from before, a very small buffer allocation and no protection, somehow the system protected me from myself. And that’s by a relatively simple trick. That’s fairly clever, though.<br>现在这个代码和以前一样。它只是编译得有点不同。你会发现，我可以给出一个长度为8的字符串，而不会有问题。但是如果我现在有9个字符，它将转储出来，并显示这个非常奇怪的退出错误消息。这是一个指示。被检测到吗？试图打破堆栈。因此缓冲区溢出有时被称为堆栈粉碎。因此，它以某种方式检测到，即使我的代码仍然是之前的旧糟糕代码，缓冲区分配非常小，没有保护，系统还是以某种方式保护了我自己。这是通过一个相对简单的技巧实现的。不过，这相当聪明。</p>
<p>发言人   53:21<br>What they call a stack canary. So the term canary comes back from back in the coal mining days of old before they had very good ways of measuring things. They’d take a bird down with them in a cage. And a canary is a property that it’s very susceptible to dying if there’s methane gasps present. So these miners would be down there working, and they’d see their bird keel over and say, oh, we got a problem here, let’s get out fast. So that’s why they call it a canary in a coal mine, sometimes some kind of warning signal that something’s not right here.<br>他们称之为堆栈金丝雀。因此，“金丝雀” 一词来自过去的煤炭开采时代，那时还没有很好的测量方法。他们会把一只鸟带到笼子里。金丝雀是一种财产，如果有甲烷气体存在，它很容易死亡。所以这些矿工会在那里工作，他们会看到他们的鸟倒下说，哦，我们这里有问题了，让我们快点出去。这就是为什么他们称之为煤矿里的金丝雀，有时是某种警告信号，表明这里有东西。</p>
<p>发言人   54:05<br>And in general with GCC, if you invoke it with a stack protector nowadays, that’s the default. So even without you saying anything, this code will get built into it. And so let’s look at what that canary code looks like and how it does its thing. It’s really pretty clever, as I said.<br>一般来说，对于GCC，如果你现在使用堆栈保护器来调用它，那就是默认的。所以即使你不说话，这段代码也会被内置到其中。那么让我们来看看那个金丝雀代码是什么样子的，以及它是如何发挥作用的。就像我说的，这真的很聪明。</p>
<p>发言人   54:28<br>And some of you have already observed, this strange kind of memory reference in a register, reference in the code in your bomb labs, because it was compiled with the Stack Protect enabled, because that’s the default. And so in particular, what this code shows is it’s allocating, as before, 24 B on the stack. But now it’s getting some number. And we’ll talk in a second what that means and storing it at position 8 offset from the stack pointer and then the rest of the code, and then it zeroes it out not to worry. And then it looks like your previous code that it’s passing a pointer to the stack, the top of the stack, as the argument to get us and get S gets called, and then put S gets called. But now there’s some more code here that involves this strange looking register, and then there’s some kind of test, and then if that test fails, it will call this code that you just saw printed out, this error message.<br>你们中的一些人已经观察到，这种奇怪的内存引用在寄存器中，引用在你们炸弹实验室的代码中，因为它是在启用了堆栈保护的情况下编译的，因为这是默认的。因此，特别地，这段代码显示的是它像以前一样在堆栈上分配24 b。但现在它得到了一些数字。我们稍后会讨论这意味着什么，并将其存储在距离堆栈指针偏移的位置8处，然后将其余代码存储起来，然后将其归零，不用担心。然后它看起来像你之前的代码，它正在传递一个指向堆栈顶部的指针，作为让我们调用get S的参数，然后调用put S。但是现在这里有更多的代码涉及这个奇怪的寄存器，然后有某种测试，如果测试失败，它将调用你刚刚看到的打印出来的代码，这个错误消息。</p>
<p>发言人   55:46<br>So let’s see what that all means.<br>让我们看看这一切意味着什么。</p>
<p>发言人   55:48<br>What that means is that at offset 8 from the stack pointer, it’s putting in 8 B of value that it’s retrieving from a special register. So FS is a reference to a type of register that was created for the original 8086 and is now completely obsolete, but it’s still there for backward compatibility mode. But what it is, and actually I’ve looked and I’ve never fully been able to find the documentation on it, it’s able to read from a part of memory, a set of values that you can’t otherwise get to. And so that’s the canary’s getting somehow. It’s grabbing 8 B from somewhere, storing it as the canary value. And then if you give like a 7 character input, so you would affect the canary. So what happens when it returns from? The two calls from Get S and put S before it exits.<br>这意味着在堆栈指针的偏移量8处，它放入了从特殊寄存器检索的8 B的值。所以FS是对一种为原始8086创建的寄存器类型的引用，现在已经完全过时了，但它仍然存在，用于向后兼容模式。但它是什么，实际上我已经看过了，我从来没有完全能够找到关于它的文档，它能够从内存的一部分读取一组你无法以其他方式获得的值。所以这就是金丝雀不知怎么的。它正在从某个地方抓取8 B，将其存储为金丝雀值。然后，如果你输入了7个字符，那么你就会影响金丝雀。那么当它从返回时会发生什么？在退出之前，从Get S和put S发出的两个调用。</p>
<p>发言人   57:01<br>What it’s trying to detect is, has anything, has this buffer somehow overflowed and potentially at risk of corrupting some other part of the stack?<br>它试图检测的是，有什么东西，这个缓冲区是否以某种方式溢出并可能有破坏堆栈其他部分的风险？</p>
<p>发言人   57:13<br>So basically what it does is it retrieves back from the stack what is the current value of this canary. And it’s comparing it to what it should be by retrieving that back from this special region. And if they’re equal, it says fine. But if they’re not equal, it’s detecting that it’s got corrupted. So just like the canary in the coal mine, if these bytes get corrupted in any form, it’s an indication that something went wrong. Now, that example shows that if I have a seven character string, then I’m not going to corrupt the canary. But you notice I just got away with an eight character string. So let me just see what’s going on here.<br>基本上，它的作用是从堆栈中检索这个金丝雀的当前值。它正在通过从这个特殊的地区取回它来比较它应该是什么。如果他们相等，那就说好。但如果它们不相等，它检测到它已经损坏了。就像煤矿里的金丝雀一样，如果这些字节以任何形式损坏，则表明出了问题。现在，这个例子表明，如果我有七个字符的字符串，那么我不会破坏金丝雀。但是你注意到我刚刚逃脱了一个八个字符的字符串。所以让我看看这里发生了什么。</p>
<p>发言人   58:14<br>Great.<br>太好了。</p>
<p>发言人   58:34<br>I want a character string, right? Oh, wait, wait, wait.<br>我想要一个字符串，对吧？哦，等等，等等。</p>
<p>发言人   58:47<br>Sorry, I don’t have the code in front of me, so I have to look at it.<br>抱歉，我面前没有代码，所以我必须看看它。</p>
<p>发言人   58:56<br>So anyways, here’s where subtracting 24 from the stack pointer. And then the next instruction is retrieving the canary value. So let’s figure out what the canary is. Right now we are at.<br>无论如何，这是从堆栈指针中减去24的地方。然后，下一指令正在检索金丝雀值。让我们弄清楚金丝雀是什么。现在我们在。</p>
<p>发言人   59:19<br>Seven 2 F, so we’re at the first instruction here.<br>七个2个F，所以我们在这里的第一个指令。</p>
<p>发言人   59:30<br>Let’s do another step.<br>让我们再迈出一步。</p>
<p>发言人   59:44<br>So this is the canary. And you’ll see actually, from one room to another, you get a different value of it. So it’s purposefully put in there in a way that it’s unpredictable. The one thing you’ll notice is that the low order byte is zeros. And so apparently they knew that it’s so common to have sort of off by one bugs with strings where you don’t allocate enough space for the no terminator that they said, well, rather than having a canary that will detect that bite being corrupted, we’ll just sort of give that bite away. And so that’s why it’s letting me type in eight characters and it’s overriding this low order bite of the canary later on. But that’s not going to affect anything.<br>这就是那只金丝雀。你会发现，从一个房间到另一个房间，你会得到不同的价值。所以它被有目的地以一种不可预测的方式放入其中。你会注意到的一件事是，低位字节是零。所以显然他们知道，有一个带有字符串的虫子，你没有为没有终结者分配足够的空间是很常见的，他们说，与其有一个金丝雀会检测到被破坏的叮咬，我们只是把那一口咬掉。所以这就是为什么它让我输入八个字符，并且稍后覆盖了这种低级的金丝雀咬合。但这不会影响任何事情。</p>
<p>发言人   01:00:57<br>But let’s give it 9 characters, 10 character string, a 9 character string.<br>但让我们给它9个字符，10个字符的字符串，一个9个字符的字符串。</p>
<p>发言人   01:01:59<br>More well I’m not finding it where I thought it would be. Anyways. This well. Crop this stack. But what I was showing you, the main idea is the canary is some value that gets pulled out and it will vary from one time to the next. And it’s letting you get away with eight characters plus the null terminator, but anything more and it will detect that corruption.<br>更好的是，我没有在我想象的地方找到它。无论如何。这很好。裁剪这个堆栈。但是我向您展示的主要思想是，金丝雀是一些被拉出的价值，它会随着时间的推移而变化。它让你逃脱八个字符加上空终止符，但更多的是它会检测到损坏。</p>
<p>发言人   01:02:42<br>Okay, so now we’ve seen three different protection. Well, 4. One is write better code. But there’s three protections that are done by the system that have nothing to do with your code. One is 2. Randomize the stack position so it’s harder to figure out where the start addresses are. The second is to make the stack so it’s not executable. So you can’t put code on that. And then the third is to use a stack canary or other mechanisms to detect a potential buffer overflow at the source.<br>好的，现在我们已经看到了三种不同的保护措施。好吧，4。一是写更好的代码。但是系统有三种保护措施，与您的代码无关。一个是2。随机化堆栈位置，这样就很难确定起始地址在哪里。第二个是使堆栈不能执行。所以你不能在上面放代码。第三种方法是使用堆栈金丝雀或其他机制在源处检测潜在的缓冲区溢出。</p>
<p>发言人   01:03:20<br>So now there’s another attack that was developed in response to some of these. That is still often successful. It’s called return oriented programming. And for your attack web, you’re going to be doing these attacks too. That’s why the attack web is different than the old web. The old web just did code injection exploits, now you’re doing both code injection and return oriented programming. So the idea of this is if you’re a hacker, you’re frustrated because of these three techniques, stack randomization, non-executable stack, and canaries. Well, I can’t fix the canary problem that actually the canary is a pretty secure. Technique I’ve never seen anyone able to bypass a step canary, but the other two, you can do it using this technique.<br>所以现在有另一种攻击是针对其中一些而开发的。这仍然经常成功。这叫做面向返回编程。对于您的攻击网站，您也将进行这些攻击。这就是为什么攻击网与旧网不同的原因。旧的web只是进行了代码注入漏洞利用，现在您正在进行代码注入和面向返回编程。所以这个想法是，如果你是一名黑客，你会因为这三种技术而感到沮丧，即堆栈随机化、不可执行的堆栈和金丝雀。好吧，我无法解决金丝雀问题，实际上金丝雀是相当安全的。技术我从未见过有人能够绕过一步金丝雀，但其他两个，你可以使用这种技术来做到这一点。</p>
<p>发言人   01:04:20<br>And the strategy is so we don’t know where the stack is, but we could still, but we know where the code is because you saw in that example, the code my layout randomization was shifting the stack positions and the heat positions, but it wasn’t changing either global variables or or the code itself.<br>策略是，我们不知道堆栈在哪里，但我们仍然可以，但我们知道代码在哪里，因为你在那个例子中看到，代码的布局随机化正在改变堆栈位置和加热位置，但它并没有改变全局变量或代码本身。</p>
<p>发言人   01:04:45<br>So what if I can find some code that sort of already there in the existing part of the program and use that instead of my own code that I’ve injected? And of course, in general, you’re not going to find exactly lying there the exact program you want to execute that will cause whatever harm you intend to do, because that’s not usually compiled into most programs. But if I could sort of string together little segments of code and somehow put together a series of little sequences of code, maybe I can get something useful done. And so that’s the idea of this return oriented programming. And the idea of it is to find what are known as gadgets. And a gadget is a sequence of bytes that represent part of the executable program where the last byte, this is x 86 talking here, has hex value c 3, which is how the Ret instruction, the return instruction is encoded in x 8, 6, both I 3, 2 and x 8664.<br>那么，如果我能在程序的现有部分中找到一些已经存在的代码，并使用它来代替我自己注入的代码，那会怎样呢？当然，一般来说，你不会找到你想要执行的确切程序，这会造成你想要做的任何伤害，因为这通常不会编译到大多数程序中。但是如果我能把一小段代码串在一起，以某种方式把一系列小代码序列放在一起，也许我能完成一些有用的事情。这就是这种面向返回编程的思想。它的想法是找到被称为小工具的东西。小工具是一个字节序列，代表可执行程序的一部分，其中最后一个字节，这里是x86，具有十六进制值c 3，这就是Ret指令，返回指令如何编码为x8，6，I 3，2和x8664。</p>
<p>发言人   01:06:02<br>So as an example, the easy case is where there’s some function and it implements some operation that I might find useful as an attacker to be able to do. So for example, this function is computing a times b plus c, and if I look at just the last two instructions from there, one of them is a Lea, which is performing addition and the other is doing a return. So I can think of this, this little 5 B chunk, as a way, if I could get some data in registers, RDI, and RDX, then I could compute their sum and stick it in rax.<br>因此，作为一个例子，最简单的情况是，有一些功能并且它实现了一些操作，我可能会发现攻击者能够做这些操作很有用。因此，例如，这个函数正在计算a乘以b加上c，如果我只看那里的最后两条指令，其中一条是Lea，它正在执行加法，而另一条正在执行返回。所以我可以想到这个小的5 B块，作为一种方式，如果我能在寄存器、RDI和RDX中获取一些数据，那么我就可以计算它们的总和并将其粘贴在rax中。</p>
<p>发言人   01:06:48<br>So imagine taking your program you’re trying to execute and breaking it up into these good old fragments. And you want to somehow find a little block of code somewhere to implement each of these fragments. And then the interesting part is because each end in C 3, this return has this. Well, let me get to that in a minute. So that’s sort of the obvious way that you pull out.<br>所以想象一下，把你试图执行的程序分解成这些好的旧片段。你想以某种方式找到一小块代码来实现这些片段。然后有趣的部分是因为每个结尾都在c3中，这个返回值都有这个。好的，让我马上讲。所以这就是你拔出的明显方式。</p>
<p>发言人   01:07:12<br>This is an addition which you’d expect because that was in the original C code. But here’s an example of a gadget that has nothing to do with the original C code. It just happens to match the byte pattern of of some existing code. So this function seems to not do anything too terribly useful from a hacker’s point of view.<br>这是你所期望的一个加法，因为它是在原始的C代码中。但是这里有一个与原始C代码无关的小工具的示例。它只是碰巧与某些现有代码的字节模式匹配。所以从黑客的角度来看，这个功能似乎没有做任何太有用的事情。</p>
<p>发言人   01:07:40<br>But if you look at this particular byte sequence that happens to encode the instruction, move Q Rix to RDI, and C 3 encodes Rept. So, and you can see if this is at address 4D 9, that’s 4D 4 db, 4 DC, so it address 4 DC If you could start executing here, first do a move, and then it would do a return. So I’m sort of taking advantage of the fact in x 86, it’s this byte oriented instruction sequence. And if I sort of go off the aligned instructions, I can often find useful things to do. So that’s what’s called a gadget.<br>但是如果您查看这个恰好编码指令的特定字节序列，将qrix移动到RDI，然后c3编码Rept。所以，你可以看到这是否在地址4 d 9，那是4 d 4 db，4 DC，所以它地址4 DC，如果你可以从这里开始执行，首先做一个移动，然后它会做一个返回。所以我在利用x86中面向字节的指令序列的事实。如果我偏离了对齐的指示，我经常能找到有用的事情去做。这就是所谓的小工具。</p>
<p>发言人   01:08:30<br>And you might ask, well, what’s so special about having them end in a return? Well, imagine I could fill up my buffer instead of with executable code, I could fill it up with a series of gadget addresses. So each gadget then is some series of bytes where the final byte is C 3. And I’ll actually this I’ll position this at. Some place where you’re actually going to do the initial return instruction from before. If I can somehow get the program to return, execute a rep, right now, what it will do is return, we’ll pick an address off of the stack, pop an address, and begin executing. So that will start this code executing and it will hit the C 3, the Re instruction at the end, which will again take an address, pop it off the stack and executing. So we’ll start executing the second gadget.<br>你可能会问，让它们以回报结束有什么特别之处？好的，想象一下我可以用一系列小工具地址来填充我的缓冲区而不是可执行代码。所以每个小工具都是一些字节序列，其中最后一个字节是c3。我会把这个定位在这里。在某个地方，你实际上要执行之前的初始返回指令。如果我能以某种方式让程序返回，执行一个rep，现在，它将做的是返回，我们将从堆栈中选择一个地址，弹出一个地址，然后开始执行。这样就会开始执行这段代码，并会在最后执行C 3，即Re指令，这将再次获得一个地址，将其从堆栈中弹出并执行。所以我们将开始执行第二个小工具。</p>
<p>发言人   01:09:36<br>And so you’ll see what will happen is we’re effectively concatenating these pieces of code together where it’s using a rat to get from one part the end of one gadget to the start of the next.<br>所以你会看到会发生的事情是我们将这些代码有效地连接在一起，它使用老鼠从一个小工具的末尾到下一个小工具的开头。</p>
<p>发言人   01:09:49<br>And so that’s why it’s called return oriented programming. It’s a way instead of sequencing programs using a program counter like you normally do, you’re sequencing programs using the sort of peculiar behavior of this particular x 86, how returns work in that program. And remember, there’s enough x 86 out there that if I can find a way to attack them I’m in a pretty good place. It’s also possible to attack other processors this way too. It’s just particularly nice on x 86. So that’s the idea of return oriented programming.<br>这就是为什么它被称为面向返回编程。这是一种方法，而不是像通常那样使用程序计数器对程序进行排序，而是使用这个特定x86的特殊行为对程序进行排序，返回如何在该程序中工作。请记住，那里有足够的x86，如果我能找到攻击它们的方法，我就处于一个相当不错的位置。也可以用这种方式攻击其他处理器。它在x86上特别好。这就是面向返回编程的思想。</p>
<p>发言人   01:10:29<br>And you’ll do this yourself. You’ll find gadgets, string them together to do different things in the attack wheel. But I’ll point out that this still. Doesn’t. This stack canary idea is still successful at detecting buffer overflows fairly effectively.<br>你可以自己做。你会发现一些小工具，把它们串在一起，在攻击轮中做不同的事情。但我会指出这一点。不是。这个堆栈金丝雀的想法在相当有效地检测缓冲区溢出方面仍然成功。</p>
<p>发言人   01:10:56<br>So in your attack lab, for example, we’ve carefully compiled the code to make it vulnerable to these attacks. Otherwise, it would be a lot harder to We like if you could do this, you could probably go into the dark world and be very successful. But so we’re actually sort of exposing the vulnerability. But in the first part of the lab, you’re using code injection attack. So we’ve had to disable stack randomization and also make the stack executable. So we had to sort of. Return oriented programming, we re-enable that so that the stack is not executable. It keeps jumping around randomly, but we’ve turned off the stack canaries, so you’ll be able to overflow the buffer and put in your gadget addresses and build up attacks that way.<br>例如，在您的攻击实验室中，我们仔细编译了代码，使其容易受到这些攻击的攻击。否则，如果你能做到这一点，我们就会更难，你可能会进入黑暗世界并取得非常成功。但是，我们实际上是在暴露这个漏洞。但是在实验的第一部分，你正在使用代码注入攻击。所以我们不得不禁用堆栈随机化，并使堆栈可执行。所以我们不得不有点。返回导向编程，我们重新启用它，使堆栈不可执行。它一直在随机跳跃，但我们已经关闭了堆栈金丝雀，因此您将能够溢出缓冲区并放入您的小工具地址并以这种方式建立攻击。</p>
<p>发言人   01:12:02<br>So I think you’ll find by actually doing it, you’ll learn a lot more than you can by just hearing about it.<br>所以我认为你会发现，通过实际操作，你会学到比仅仅听到它更多的东西。</p>
<p>发言人   01:12:09<br>Oh, you might ask, why do we teach you this stuff, right? Are are we supposed to teach you to be good and not evil? Well, there’s a couple of reasons. One is you’re going to learn a lot about machine program execution, how stacks work, and how byte instructions are encoded and stuff like that. You’ll use the tools gdb, object dump and all those, even more than you did with the Bam web. So you’ll learn a lot. The other is we assume that you will work for forces of good to be a good person, you also know have to know what the bad people do. So part of it is too become more effective as a force for good.<br>你可能会问，为什么我们要教你这些东西，对吧？我们应该教你善良而不是邪恶吗？有几个原因。一是你将学到很多关于机器程序执行、堆栈如何工作、字节指令如何编码等方面的知识。您将使用gdb、对象转储等工具，甚至比使用Bam web还要多。所以你会学到很多东西。另一种是我们假设你会为善的力量努力成为一个好人，你也知道必须知道坏人会做什么。因此，它的一部分也变得更加有效，成为一种良好的力量。</p>
<p>发言人   01:12:56<br>Okay, so the final thing to talk about today is unions And the observation about a union in C is the declaration of it looks a lot like a struct where there’s these different fields and they’re named and they can have different types and they can be pointers to unions and all that stuff, but they’re actually totally different. What they do, you recall with a struct, what happens is it allocates enough memory for all the fields to coexist and potentially adding padding bytes for what a union does is it only allocates enough storage for the maximum field in it, and it assumes that you’re only going to be using one of the possible fields, and it will literally store these fields, get stored on top of each other, so that if you try to use multiple fields, you can mess things up, and it’s not for that purpose of doing multiple values is it for the purpose of, for example, if I know I’m only going to use one of these, or it’s another also a way to create essentially an alias that will let you reference memory in different ways.<br>好的，今天要讨论的最后一件事是联合，关于联合在C中的观察是它的声明看起来很像一个结构，其中有这些不同的字段，它们被命名，它们可以有不同的类型，它们可以是指向联合和所有这些东西的指针。但它们实际上完全不同。他们的所作所为，你记得有一个结构，它会为所有字段共存分配足够的内存，并可能为联合的作用添加填充字节，它只为其中的最大字段分配足够的存储，并且它假设您只会使用其中一个可能的字段，并且它将字面上存储这些字段，并将它们存储在彼此的顶部，因此如果您尝试使用多个字段，可能会弄乱事情，并且它不是为了做多个值，而是为了，例如，如果我知道我只打算使用其中一个，或者它也是另一种创建别名的方法，让你以不同的方式引用内存。</p>
<p>发言人   01:14:11<br>So for example, in your data lab you are using. You were manipulating the bit level representations of floating point numbers. And in our code, that would then convert that to an actual float. We used a union where the union is either to view this field of 4 B as an unsigned or as a float. And so I can. Convert from an unsigned to its float representation by just storing the unsigned value in this union and retrieving it as if it were float.<br>例如，在您的数据实验室中，您正在使用。你正在操作浮点数的位级表示。在我们的代码中，这将把它转换为实际的浮点数。我们使用了一个联合，其中联合要么将4 b的这个字段视为无符号字段，要么将其视为浮点数。所以我可以。通过仅将无符号值存储在此联合中并将其视为浮点数来将无符号值转换为浮点数表示。</p>
<p>发言人   01:14:54<br>And this is a fundamentally different operation than casting. Because you recall, when you take an unsigned value and you cast it to a float, you actually change the bit. You change it into the floating point number. That’s the closest a match to this particular number. It would be the equivalent of the function you implemented underscore u 2 f, but this one actually doesn’t change bits. It just changes the numeric value changes quite a bit. So it’s a useful technique to do that, to be able to override the type system and get to bit representations.<br>这是一种与铸造根本不同的操作。因为你记得，当你取一个无符号值并将其强制转换为浮点数时，实际上是改变了位。你把它变成浮点数。这是最接近这个特定数字的匹配项。它将与您实现的下划线u 2 f函数等效，但这个实际上不会更改位。它只是改变了数值变化相当大。所以这是一种有用的技术，能够覆盖类型系统并获得位表示。</p>
<p>发言人   01:15:33<br>And this actually turns out to be one of the places, too, where byte ordering will show up in programs if you’re not careful.<br>这实际上也是一个地方，如果你不小心，程序中会出现字节排序。</p>
<p>发言人   01:15:42<br>So in particular, with this union, I can view a block of 8 B as either eight characters, 4 shorts, 2”, or 1 long, and on a 64 b machine, like is shown here, where long is 64 b, you’ll see that you’re able to look at things as either as the individual bytes making it up or some longer aggregation of those bytes. And you’ll actually find that depending on what machine you run it on, you’ll get different results because of the byte ordering of the different machines. So this goes through it.<br>因此，特别是通过这个联合，我可以将一个8 B的块视为八个字符，4短，2 “或1长，在64 b的机器上，如图所示，其中长是64 b，你会发现你可以将事物看作是组成它的单个字节或这些字节的一些更长的聚合。你会发现，根据你在哪台机器上运行它，你会得到不同的结果，因为不同机器的字节顺序不同。所以这贯穿了它。</p>
<p>发言人   01:16:24<br>What happens when you run on different machines? But you’ll notice in particular that on an I 32 machine, a 32 b machine. It’s coming off in this byte pattern, F3, f 2, F1, f 0, And on a sun back when they existed, you’d get the opposite because of the byte ordering. And now on an x 8 64, where a long is 64 b, you get 8 B. And you can also determine from this, if you look carefully, that it’s in, it’s a little Indian order because this is the least significant byte as f 0, which is the first byte f 0. So it’s also a way to get to the low level bytes.<br>当你在不同的机器上运行时会发生什么？但你会特别注意到，在i32机器上，32 b机器上。它在这个字节模式中出现，F3，f2，F1，f0，当它们存在时，你会得到相反的结果，因为字节排序。现在在一个x8 64上，其中一个long是64 b，你得到8 B。如果你仔细看，你也可以从中确定它是在，它是一个小印度顺序，因为这是最不重要的字节，如f0，它是第一个字节f0。所以这也是一种到达低级字节的方法。</p>
<p>发言人   01:17:21<br>But when you use this kind of thing, you’re sort of intentionally telling the C compiler, Trust me, I know what I’m doing. You don’t have to protect me from myself. And so if you’re not careful, you can write code where because of a byte ordering problem or something like that won’t run properly on some machines.<br>但是当你使用这种东西时，你有点故意告诉C编译器，相信我，我知道我在做什么。你不必保护我自己。因此，如果你不小心，你可以编写代码，因为字节排序问题或类似的事情在某些机器上无法正常运行。</p>
<p>发言人   01:17:42<br>So just to summarize, then we’ve looked then at, we’ve looked then at the three compound types in C, the ways you can aggregate smaller types into larger ones. You can make an array of identical elements index by a number, the position. And that usually turns into some kind of scaled computation to get to the particular place we’ve seen structures where it’s a fixed number of fields, but the fields can be of different type and they’re referenced by their names, and that usually turns into some type of displacement off of the original position. And then a union, it’s just a way of sort of piling up in one place of a number of different fields. And so all it does is allocate the maximum number of bytes for that and doesn’t create enough space for them all to be there at the same time. Okay, that’s it for today then.<br>因此，总的来说，我们已经看过了，我们已经看过了C中的三种复合类型，即可以将较小的类型聚合成大的类型的方式。你可以让一个相同元素的数组按数字、位置进行索引。这通常会变成某种比例计算，以达到我们看到的结构的特定位置，其中字段的数量是固定的，但这些字段可以是不同类型的，并且它们通过其名称引用，这通常会变成原始位置的某种位移。然后是一个联盟，它只是一种将许多不同领域堆积在一个地方的方式。因此，它所做的只是为此分配最大字节数，而不会创建足够的空间让它们同时存在。好的，今天就到这里。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>深入理解计算机系统 009-Machine-Level Programming V, Advanced Topics</div>
      <div>http://example.com/2025/10/12/15213-009/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月12日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/12/15213-010/" title="深入理解计算机系统 010-Program Optimization">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">深入理解计算机系统 010-Program Optimization</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/12/15213-008/" title="深入理解计算机系统 008-Machine-Level Programming IV, Data">
                        <span class="hidden-mobile">深入理解计算机系统 008-Machine-Level Programming IV, Data</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
