

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="发言人   00:00All right, good afternoon, everybody. Welcome, good to see you.好的，大家下午好。欢迎，很高兴见到你。 发言人   00:06So today we’re going to look at an idea called exceptional control flow. That’s a very importan">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解计算机系统 015-Exceptional Control Flow, Exception and Processes">
<meta property="og:url" content="http://example.com/2025/10/12/15213-015/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="发言人   00:00All right, good afternoon, everybody. Welcome, good to see you.好的，大家下午好。欢迎，很高兴见到你。 发言人   00:06So today we’re going to look at an idea called exceptional control flow. That’s a very importan">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-12T02:00:14.000Z">
<meta property="article:modified_time" content="2025-10-19T11:16:51.137Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>深入理解计算机系统 015-Exceptional Control Flow, Exception and Processes - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="深入理解计算机系统 015-Exceptional Control Flow, Exception and Processes"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-12 10:00" pubdate>
          2025年10月12日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          15k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          125 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">深入理解计算机系统 015-Exceptional Control Flow, Exception and Processes</h1>
            
            
              <div class="markdown-body">
                
                <p>发言人   00:00<br>All right, good afternoon, everybody. Welcome, good to see you.<br>好的，大家下午好。欢迎，很高兴见到你。</p>
<p>发言人   00:06<br>So today we’re going to look at an idea called exceptional control flow. That’s a very important part of making modern systems, and it exists at all levels of the system, from the lowest level hardware all the way up to software. So the idea is when you turn on a computer from the very first time you turn it on, it just executes one instruction after another until that you turn it off. And if each core, if you have multiple cores, then each of those cores are executing instructions one after the other. Now, this sequence of instructions is called the control flow. And the actual sequence of instruction that the hardware is executing is called the physical control flow.<br>所以今天我们要看看一个叫做例外控制流的想法。这是制造现代系统非常重要的一部分，它存在于系统的各个层面，从最低级别的硬件一直到软件。所以这个想法是，当你第一次打开计算机时，它只是执行一个接一个的指令，直到你关闭它。如果每个内核都有多个内核，那么每个内核都会一个接一个地执行指令。现在，这个指令序列被称为控制流。而硬件正在执行的实际指令序列称为物理控制流。</p>
<p>发言人   01:05<br>Now, normally, normally this control flow executes just one instruction after another, just sequentially in memory.<br>现在，通常情况下，这个控制流通常只执行一条接一条的指令，只是在内存中顺序执行。</p>
<p>发言人   01:16<br>And we have so far, we’ve seen two mechanisms for altering the control flow so, so that we’re not executing just the next instruction. So that’s branches and jumps and procedure call in return. Nows and Branch’s jumps call and return. Those are reacting to changes in program state. So when you do a branch, you check the control condition codes and then based on some the results of that comparison, then you do the branch.<br>到目前为止，我们已经看到了两种改变控制流的机制，以便我们不只是执行下一条指令。这就是分支、跳转和过程调用的回报。Nows和Branch的跳跃呼叫和返回。这些是在对程序状态的变化做出反应。所以当你进行分支时，你检查了控制条件代码，然后基于该比较的一些结果，你就进行了分支。</p>
<p>发言人   01:52<br>But a real system needs to be able to adapt to changes in the system state. So for example, data arrives from a disk. Or, or a network user types control C, the program executes an illegal instruction. All of these represent change, some kind of change in the system state, and we need some way to react to that.<br>但真正的系统需要能够适应系统状态的变化。例如，数据来自磁盘。或者网络用户键入控件C时，程序执行非法指令。所有这些都代表着变化，系统状态的某种变化，我们需要某种方式来做出反应。</p>
<p>发言人   02:24<br>So this, so what we need is we call this exceptional control flow because it’s sort of outside of the normal control flow that we see in our programs.<br>所以这个，我们需要的是我们称之为例外控制流，因为它有点超出我们在程序中看到的正常控制流。</p>
<p>发言人   02:36<br>Now, exceptional control flow, or ECF, exists at all levels in the system from the very lowest level of hardware. At the very lowest level, we have what are called exceptions. And these are changes in the control flow in response to some low level system event. And by event, we mean a change in the state. Now, exceptions are implemented using a combination of hardware and OS software, which we’ll see in a minute. But these exceptional control flow exists at higher levels, too.<br>现在，异常控制流 (ECF) 存在于系统的所有级别，从最低级别的硬件开始。在最底层，我们有所谓的异常。这些是为了响应某些低级系统事件而对控制流进行的更改。所谓事件，我们指的是状态的变化。现在，异常是使用硬件和操作系统软件的组合实现的，我们将在一分钟内看到。但这些特殊的控制流也存在于更高层次上。</p>
<p>发言人   03:20<br>A process context switch is an example of exceptional control flow that it’s implemented by hardware and the operating system kernel. And so a process context switch, as we’ll see later today, you’re executing your code in your. Current process. And then all of a sudden, the system is executing code from another process. And so your process gets like suspended. And so that’s a form of exceptional control flow where you’re executing statements, instructions within one process. And then all of a sudden you’re executing statements, instructions in another process at a higher level.<br>进程上下文切换是异常控制流的一个例子，它是由硬件和操作系统内核实现的。因此，一个流程上下文切换，正如我们今天稍后会看到的那样，您正在执行您的代码。目前的过程。然后突然间，系统正在执行另一个进程的代码。所以你的进程就像被暂停一样。因此，这是一种特殊的控制流形式，您在其中执行语句，指令在一个进程中。然后突然间，你在更高级别的另一个进程中执行语句和指令。</p>
<p>发言人   04:10<br>Totally in software, we have the idea of a signal. And this is implemented by operating system software. And we’ll learn all about signals next lecture. And then even higher, at an even higher level, you have non-allocated jumps in C, which are just implemented by the C runtime library. So this allows you, non-slovak jumps allow you to break the normal call and return pattern from one from within a function. Normally, you can only return to the function that calls that calls you. Non-local jumps allow you to, within a function, break that and return to some other, some other function or some other part of the code. So we’ll look at signals and non-local jumps next lecture.<br>完全在软件中，我们有信号的概念。这是由操作系统软件实现的。下一节课我们将学习所有关于信号的知识。然后，在更高的级别上，您在C中有未分配的跳跃，这些跳跃仅由C运行时库实现。因此，这允许您，非斯洛伐克跳跃允许您从一个函数内部打破正常的调用和返回模式。通常，您只能返回到调用您的函数。非本地跳转允许您在函数内断开并返回到某个其他函数或代码的其他部分。所以下一节课我们将讨论信号和非局部跳跃。</p>
<p>发言人   04:55<br>Today we’re going to look at exceptions and processes. So an exception is a transfer of control to the operating systems kernel, where the kernel is the memory resonant part of the operating system. So an operating system provides all kinds of programs, like to list files, to change directories, to list the current processes. So all of that stuff constitutes the operating system.<br>今天我们来看看异常和流程。所以一个例外是控制权转移到操作系统内核，其中内核是操作系统的内存共振部分。因此，操作系统提供各种程序，例如列出文件，更改目录，列出当前进程。所以所有这些东西构成了操作系统。</p>
<p>发言人   05:28<br>The kernel is the part of the operating system that’s always resident in memory. So an exception is this really low level transfer of control to the operating system because something happened in the system.<br>内核是操作系统中始终驻留在内存中的部分。所以一个例外是，由于系统中发生了某些事情，这种非常低级的控制转移到了操作系统。</p>
<p>发言人   05:43<br>So you’re executing your code, user code, and then something happens some event. So by event, we mean there’s some change in the system state. In response to that, the exception transfers control from from your user code to code in the kernel, which is called an exception handler. And then the kernel responds to that change in some way. This is called the exception processing. And then there’s three things that can happen after the kernel handles the exception. It can return and re execute the current instruction. And we’ll see. This is useful for things like page faults, it allows us to implement virtual memory, It could return to the next instruction, which I’ve shown here, or it could abort.<br>所以你正在执行你的代码、用户代码，然后发生了一些事情。所以所谓的事件，我们指的是系统状态发生了一些变化。作为回应，异常将控制从您的用户代码转移到内核中的代码，这被称为异常处理程序。然后内核以某种方式响应这个变化。这被称为异常处理。然后，在内核处理异常后可能会发生三件事情。它可以返回并重新执行当前指令。我们会看到的。这对于页面错误之类的事情很有用，它允许我们实现虚拟内存，它可以返回到我在这里展示的下一条指令，或者它可以中止。</p>
<p>发言人   06:47<br>Now, exceptions are implemented by hardware and software. So the actual transfer of control, the change in the program counter or IP, is done by the hardware. But the code that executes as a result of that exception is set up and determined by the operating system kernel. So every type of event has a unique exception number, which serves as an index into a jump table called an exception table. When event K happens, then the hardware uses K as an index into this table and gets the address of the exception handler for that exception. And so every time that event K happens, that handler K is invoked.<br>现在，异常由硬件和软件实现。因此，实际的控制权转移，即程序计数器或IP的更改，是由硬件完成的。但是由于该异常而执行的代码是由操作系统内核设置和确定的。因此，每种类型的事件都有一个唯一的异常编号，该编号作为跳表 (称为异常表) 的索引。当事件K发生时，硬件使用K作为此表的索引，并获取该异常的异常处理程序的地址。所以每次事件K发生时，处理程序K都会被调用。</p>
<p>发言人   07:46<br>Now, there’s different kinds of exceptions. We distinguish them as being asynchronous or synchronous.<br>现在有不同种类的例外。我们将它们区分为异步的或同步。</p>
<p>发言人   07:54<br>Asynchronous exceptions happen as a result of changes in state that are occurred outside, outside of the processor. So these are called interrupts. And those changes in state, the processor is notified about those changes in state by setting a pin on the processor, an external pin called the interrupt pin. So this is the kind of when, say, a disk controller finishes doing a direct memory access and copying data from the disk into memory, it notifies the processor that it’s finished that copy by setting the interrupt pin high. And so after an interrupt happens, the handler returns to the next instruction. So an interrupt, typically, it’s as though you’re running your program, you’re running your program, and then there’s like this little, there’s like this little pause while the interrupt handler runs, and then your program just continues to run. So it’s usually sort of done behind the scenes, doesn’t affect your execution of your program.<br>异步的异常是由于在处理器外部发生的状态变化而发生的。这些被称为中断。当这些状态发生变化时，通过在处理器上设置一个引脚 (称为中断引脚的外部引脚) 来通知处理器状态的变化。所以，当磁盘控制器完成直接内存访问并将数据从磁盘复制到内存时，它会通过将中断引脚设置为高电平来通知处理器它已经完成了复制。因此，在中断发生后，处理程序返回到下一个指令。所以一个中断，通常情况下，就好像你正在运行你的程序，然后在中断处理程序运行时会有这样一个小小的停顿，然后你的程序就继续运行。所以它通常是在幕后完成的，不会影响你的程序执行。</p>
<p>发言人   09:13<br>Now, the A common. Example of interrupt is a timer interrupt. So all systems have a built in timer that goes off every few milliseconds. And when the timer goes off, it sets the interrupt pin high. And there’s a special exception number for timer interrupts. And this in order, this is, we need this.<br>现在，一个共同的。中断的例子是计时器中断。所以所有系统都有一个内置计时器，每隔几毫秒就会关闭一次。当定时器关闭时，它将中断引脚设置为高电平。计时器中断有一个特殊的例外号。为了这个，我们需要这个。</p>
<p>发言人   09:40<br>To allow the kernel to get control of the system again. Otherwise, a user program could just run forever in an infinite loop, and there’d be no way for the operating system to get control. So every few milliseconds, this timer goes off that causes an exception into the keel. And then the kernel, as we see, the kernel can decide what to do, maybe schedule a new process or let the current process run. And then an IO interrupt from an external device is also a common example.<br>允许内核再次获得系统的控制权。否则，用户程序可能会永远以无限循环的方式运行，操作系统将无法获得控制。所以每隔几毫秒，这个计时器就会停止，导致龙骨出现异常。然后内核，正如我们所看到的，内核可以决定要做什么，也许调度一个新的进程或者让当前进程运行。然后来自外部设备的IO中断也是一个常见的例子。</p>
<p>发言人   10:19<br>Now, the other class of exceptions are synchronous exceptions. And there are three classes of those. One is one class is called a trap. A trap is intentional exception. So this is an exception that’s caused intentionally by the program. And the most common form of a trap is a system call.<br>现在，另一类异常是同步异常。这些有三个等级。一类叫做陷阱。陷阱是一种有意的例外。所以这是一个由程序有意引起的异常。最常见的陷阱形式是系统调用。</p>
<p>发言人   10:41<br>So know the operating system kernel provides all kinds of services to a program, but your program doesn’t have direct access. Your program can’t call functions in the kernel. It can’t access data directly in the kernel because that memory is protected and unavailable to user programs. So what the kernel does is it provides an interface that allows programs to make requests effectively call functions within the kernel and to make requests for various services, and this interface is called a system call, so a program makes a system call and. Requests various functions from the kernel. The kernel sort of reacts to that request and then returns control back to the function there, the calling program. So you can think of a system call as kind of. It looks like a function call, but it’s really transferring control into the kernel.<br>所以要知道操作系统内核为程序提供各种服务，但您的程序没有直接访问权限。您的程序无法调用内核中的函数。它无法直接在内核中访问数据，因为内存受到保护，用户程序无法使用。所以内核所做的是提供一个接口，允许程序有效地发出请求，调用内核中的函数，并请求各种服务，这个接口被称为系统调用，因此程序进行系统调用。请求内核中的各种函数。内核会对该请求做出反应，然后将控制权返回给那里的函数，即调用程序。所以你可以把系统调用看作是一种。它看起来像一个函数调用，但实际上是在将控制转移到内核中。</p>
<p>发言人   11:48<br>Then there’s traps are intentional. All faults are unintentional, but maybe recoverable. So things like page faults. Which, we’ll learn more about these when we study virtual memory, Something like a page fault, it’s actually recoverable.<br>那么陷阱是故意的。所有故障都是无意的，但也许可以恢复。所以像页面错误这样的事情。当我们研究虚拟内存时，我们会学到更多关于这些的东西，比如页面错误，它实际上是可恢复的。</p>
<p>发言人   12:09<br>It just the kernel has to. It means that the data, the portion of the address space that your program referenced isn’t actually in memory. It needs to be copied from disk where it’s stored into memory, And then the instruction that the cause default is just restarted. And then it works. The memory is there, and then the instruction works properly. But other faults unintentionally re-covered like protection fault, if you try to access a portion of memory that’s not allocated or floating point exceptions, oftentimes those can be recoverable. So in either case, when there’s a fault, it either re-execute is the current instruction or a board.<br>这只是内核必须做的。这意味着数据，即程序引用的地址空间部分实际上并不在内存中。它需要从存储到内存的磁盘中复制，然后重新启动原因缺省值的指令。然后它起作用了。内存在那里，然后指令正常工作。但其他错误无意中被重新覆盖，如保护错误，如果您尝试访问未分配的内存部分或浮点异常，通常这些都是可以恢复的。因此，在任何一种情况下，当出现故障时，要么重新执行当前指令，要么重新执行板子。</p>
<p>发言人   13:02<br>And then there’s unintentional and unrecoverable exceptions, which are called aborts. Those always abort. So if you execute an illegal instruction, if there’s a problem with your memory, memory and it’s corrupted, or if there’s some problem with the machine, those create aborts that always that are unrecoverable and never return back to the program.<br>然后还有无意的和不可恢复的异常，这被称为中止。这些总是中止。因此，如果您执行非法指令，如果内存出现问题且已损坏，或者机器出现问题，则会创建中止，并且总是不可恢复且永远不会返回程序。</p>
<p>发言人   13:29<br>Now, system calls, there’s many different kinds of system calls, and they all have their own unique number, which is assigned by Linux. For example, to read a file, there’s a system called called read, which is number 0, opening a file, a system called number two, and so on. And there’s a, there’s an instruction called syscall, which? Actually performs the system call?<br>现在，在系统调用方面，有许多不同种类的系统调用，它们都有自己独特的编号，这是由Linux分配的。例如，要读取文件，有一个名为read的系统，其编号为0，打开文件，一个名为第二的系统，依此类推。还有一条叫做syscall的指令，是什么？实际执行系统调用？</p>
<p>发言人   14:08<br>Now you usually don’t use the syco instruction directly in your program. Linux wraps those in system level functions which actually call it for you.<br>现在你通常不会在程序中直接使用syco指令。Linux将这些包装在系统级别的函数中，这些函数实际上为你调用它。</p>
<p>发言人   14:21<br>It’s interesting to see how it actually works. So suppose you want to open a file, you call the system level function called open with a file name. And some options say read only, write only. And so the syscall instruction takes first the syscall number is in Rax, and then other arguments are in RDI. RSI RDX R 1 r 8 and R 9. So you can see if we look in the open function calls the underscore underscore open function, which actually invokes the syscall. So if you look at that code, you see it moves the two, which is the syscall number for read into EAF, and then it does the syscall, and then the syscall returns its status in Rax.<br>看看它实际上是如何工作的很有趣。因此，假设您想要打开一个文件，您可以使用一个文件名调用名为open的系统级函数。有些选项说只读，只写。因此，syscall指令首先接受syscall编号在Rax中，然后其他参数在RDI中。RSI RDX R 1 r 8和R 9。所以你可以看到我们是否在open函数中调用下划线下划线open函数，它实际上调用了syscall。因此，如果您查看该代码，您会看到它将读取的syscall编号中的两个移动到EAF，然后执行syscall，然后syscall在Rax中返回其状态。</p>
<p>发言人   15:17<br>If it’s a negative number, then that means something, some error occurred. If it’s a positive number, then that means something that no error occurred. So in this case, in the open, it’s returning a file descriptor, a small integer called a file descriptor, which you can use in subsequent calls to read and write. And then you can see the code is checking for this negative return value. And there’s a whole series of these compares.<br>如果它是负数，那么这意味着发生了一些错误。如果它是一个正数，那么这意味着没有发生错误。因此，在这种情况下，在打开时，它返回一个文件描述符，一个称为文件描述符的小整数，您可以在后续的读写调用中使用它。然后你可以看到代码正在检查这个负返回值。这里有一系列的比较。</p>
<p>发言人   15:51<br>So let’s look at an example of a fault. So here, suppose we have this program that we’re writing into a valid region of memory, but it’s not actually stored on. It’s not actually in the memory. It needs to be loaded from disk into memory, so called page fault. So this instruction, this move L, because the memory at this address isn’t available, triggers a page fault. So that creates an exception, a transfer of control into the page fault handler in the kernel, which copies that page from disk to memory. And then it returns. And when it returns, it re executed to the move L instruction. So that’s kind of cool.<br>让我们看一个故障的例子。所以在这里，假设我们有这个程序，我们正在写入一个有效的内存区域，但它实际上并没有存储在其中。它实际上不在记忆中。它需要从磁盘加载到内存中，即所谓的页面错误。因此，这个指令，这个移动L，因为这个地址的内存不可用，触发了一个页面错误。这样会创建一个异常，即控制转移到内核中的页面错误处理程序中，该处理程序将该页面从磁盘复制到内存。然后它返回。当它返回时，它会重新执行到移动L指令。这很酷。</p>
<p>发言人   16:43<br>Memory is available. And now that the move l, this move l instruction, when it’s re-executed completes, and then we continue.<br>内存可用。现在移动l指令，当它重新执行完成时，这个移动l指令，然后我们继续。</p>
<p>发言人   16:56<br>Now, another type of fault is an invalid memory reference. So here we have, we’re accessing an element of A, which doesn’t exist. It’s an illegal, it’s an invalid reference. So in this case, the move L instruction, it looks like a page fault, but the kernel detects that it’s an invalid address, that there isn’t anything that can be loaded from disk. This is an invalid region of the virtual address space. So it sends a signal to the to the process and then never returns. So the signal that sends is the infamous, the signal that causes the infamous segmentation fault message to print out. And we’ll see next lecture, we’ll see how these signals actually work.<br>现在，另一种故障类型是无效的内存引用。所以在这里，我们正在访问一个不存在的元素A。这是一个非法的引用，它是一个无效的引用。所以在这种情况下，移动L指令，它看起来像一个页面错误，但内核检测到它是一个无效的地址，没有任何可以从磁盘加载的东西。这是虚拟地址空间的无效区域。因此它向进程发送信号，然后永不返回。所以发送的信号是臭名昭著的，导致臭名昭著的段故障消息打印出来的信号。我们将看到下一节课，我们将看到这些信号实际上是如何工作的。</p>
<p>发言人   17:57<br>So at the we’ve seen exceptions are very low level transfers of control that are implemented by both hardware and the operating system software. At the higher level is another form of exceptional control flow called, and we see it in the context of a process context switch.<br>因此，在我们所看到的异常中，异常是由硬件和操作系统软件实现的非常低级别的控制转移。在更高层次上，是另一种称为异常控制流的形式，我们在流程上下文切换的上下文中看到它。</p>
<p>发言人   18:22<br>So let’s look at what a process is. So A, the idea of a process is one of the most fundamental and important ideas in computer science. And the classical definition is that a process is an instance of a running program. It’s different from a program. A program exists, can exist in many different places. A program exists in your C as text in AC file. It can exist as the dot text section of a binary, It can exist as bytes that have been loaded into memory.<br>那么让我们来看看过程是什么。因此，过程的思想是计算机科学中最基本和最重要的思想之一。经典的定义是进程是正在运行的程序的实例。它不同于一个程序。一个程序存在，可以存在于许多不同的地方。一个程序以文本形式存在于您的C交流文件中。它可以作为二进制文件的点文本部分存在，也可以作为已加载到内存中的字节存在。</p>
<p>发言人   19:03<br>A process is an instance of a program that’s running, that’s in execution. And 2, a process provides two key abstractions. The first abstraction is that it it gives you the illusion that you have exclusive access to the CPU and the registers. So when you’re running, when you’re running your program in a process, you never have to worry about any other programs modifying your registers. And you can’t even tell that there’s even other processes running on the system. It looks, except for occasional delays, like an instruction that just takes a little longer to run. Except for that, it looks like you have exclusive use of the processor and its registers.<br>进程是正在运行的程序的实例，正在执行中。和2，一个过程提供了两个关键的抽象。第一个抽象是它给你一种错觉，让你有独占访问CPU和寄存器的权限。因此，当您运行程序时，当您在进程中运行程序时，您不必担心任何其他程序修改您的寄存器。你甚至无法判断系统上还有其他进程在运行。它看起来除了偶尔的延迟，就像一条只需要运行一段时间的指令。除此之外，它看起来像你独占使用处理器及其寄存器。</p>
<p>发言人   20:03<br>The other abstraction that it provides is the illusion that you have your own address space. So you have, and this is provided by a mechanism called virtual memory. Each running program has its own code, data heap, stack, and you never see that the code and you never see the memory that’s being used by other processes. It, for all intents and purposes, the process gives you this illusion that you have access to the exclusive, access to all the memory and the processor.<br>它提供的另一个抽象是你有自己的地址空间的错觉。所以你有，这是由一种称为虚拟内存的机制提供的。每个正在运行的程序都有自己的代码、数据堆、堆栈，你永远不会看到这些代码，也永远不会看到其他进程正在使用的内存。从所有的意图和目的来看，这个过程给你一种错觉，你可以访问所有的记忆和处理器。</p>
<p>发言人   20:44<br>Now, the system runs many of these processes simultaneously, Even on a system with a single core, many of these multiple processes are actually running at the same time concurrently. And you can see this if you look at this here, I ran top on my Mac, and you can see it’s running 1 and 2123 total processes, 5 of which are actually running. And each one of these processes has its own unique process ID. This is integer.<br>现在，系统同时运行许多这些进程，即使在单核系统上，许多这些多个进程实际上同时运行。如果你看这里，你可以看到这个，我在我的Mac上运行顶部，你可以看到它正在运行1和2123个总共进程，其中5个实际上正在运行。每个过程都有其独特的过程账号。这是整数。</p>
<p>发言人   21:25<br>Now the way. So it looks like you have unique access or exclusive access to the to the system, but in reality, on a suppose we have a single core, you’re actually sharing the system and the operating system is sort of managing that sharing. So what it does is it. We have a process that’s running and it has its own, it has its own address space. It has, and it has its own registers.<br>现在的路。所以看起来你对系统有唯一的访问权限或独占访问权限，但实际上，假设我们有一个单核，你实际上在共享系统，操作系统在某种程度上管理这种共享。所以它所做的就是它。我们有一个正在运行的进程，它有自己的地址空间。它有，而且它有自己的寄存器。</p>
<p>发言人   22:04<br>And now at some point. At some point, an exception occurs either because of a timer interrupt or a fault of some kind or a trap.<br>现在在某个时刻。在某个时刻，异常发生可能是由于计时器中断、某种故障或陷阱。</p>
<p>发言人   22:16<br>At some point, the operating system gets control of the system. And in this case, let’s say it decides that it wants to run another process. So it copies, registers the current register values into memory, and saves them. And then it schedules the next process for execution, and it loads the registers that were saved from the last time that process was running. It loads those into the CPU registers, and then it switches the address space to the address space for this process. So the address space and the register values are the context, and so the context switch is what is the change in the address space in the registers? So then at that point, that process is running.<br>在某个时刻，操作系统获得了对系统的控制权。在这种情况下，假设它决定要运行另一个进程。因此，它将当前寄存器值复制、注册到内存中，并保存它们。然后它安排下一个进程的执行，并加载该进程上次运行时保存的寄存器。它将这些数据加载到CPU寄存器中，然后将地址空间切换到此进程的地址空间。因此，地址空间和寄存器值就是上下文，因此上下文切换是寄存器中的地址空间发生了什么变化？那么在那个时候，这个进程正在运行。</p>
<p>发言人   23:17<br>Now, in reality, our modern systems with multiple cores, the operating system will schedule processes on those multiple cores if there’s not enough core to handle the processes, then it’ll do the context switching just like we showed before.<br>现在，实际上，我们的现代系统具有多个核心，如果没有足够的核心来处理这些进程，操作系统将在这些多核上调度进程，然后它将像我们之前展示的那样进行上下文切换。</p>
<p>发言人   23:39<br>Now, each process represents a what we call a logical control flow. So if you were to, there’s a physical control flow. If we just looked at all the PC values, we’d be executing instructions from 1 process, and then all of a sudden, we’d be executing from another process. But within a single process, there’s a logical control flow, which are all the instructions for that process.<br>现在，每个进程都代表我们所谓的逻辑控制流。所以，如果你这样做，有一个物理控制流。如果我们只查看所有的PC值，我们将会从一个进程执行指令，然后突然之间，我们将会从另一个进程执行指令。但是在单个进程中，有一个逻辑控制流，这是该进程的所有指令。</p>
<p>发言人   24:04<br>Now, we say that two processes run concurrently if their flows overlap in time. Otherwise they’re sequential. So let’s look at, let’s look at an example, we have three processes, process A runs for a while, and then it’s interrupted by process B and process C, and then eventually it continues running, and then it terminates. Process B interrupts process A, and then it runs for a while, and then it terminates C when process B finishes, then process C gets to run for a while, then process A runs for a while, and then process C terminates. So given this definition of concurrency.<br>现在，如果两个进程的流程在时间上重叠，我们说它们同时运行。否则它们是连续的。让我们来看一个例子，我们有三个进程，进程A运行了一段时间，然后被进程B和进程C中断，最终它继续运行，然后终止。进程B中断进程A，然后运行一段时间，然后在进程B完成时终止C，然后进程C运行一段时间，然后进程a运行一段时间，然后进程C终止。因此，考虑到并发性的这个定义。</p>
<p>发言人   24:52<br>Which of these processes are running concurrently? What about or A and B, yes? So A and B’s flows B, b’s flow overlaps with A’s flow, right? So B?<br>这些进程中有哪些正在同时运行？关于A和B，是的？所以A和B的流B，b的流与A的流重叠，对吗？那么，B？</p>
<p>发言人   25:22<br>B finishes, starts, and finish. Some portion, this portion of B’s flow overlaps with A’s flow because B is still running, hasn’t finished. So A and B are concurrent, and similarly C and A overlap, so they’re concurrent, but B and C are not concurrent. B finishes before C starts.<br>B完成、开始和完成。在某些部分，B的流的这一部分与A的流重叠，因为B仍在运行，还没有完成。所以A和B是并发的，同样，C和A重叠，所以它们是并发的，但B和C不是并发的。B在C开始之前完成。</p>
<p>发言人   25:54<br>Now, this idea of concurrency, it doesn’t. This definition of concurrency holds regardless of the number of cores, even if you have one core. This example that I showed you was on one core, but even if you have multiple chords, as long as the flows overlap in time, they’re concurrent. But we can think of these no matter what. We can think of these as running in parallel with each other, at least from the point of view of these individual processes.<br>现在，这种并发的想法，它没有。无论内核数量有多少，即使您有一个内核，这种并发定义也会保持。我给你看的这个例子是在一个核心上，但即使你有多个和弦，只要流动在时间上重叠，它们就是并发的。但是无论如何我们都可以想到这些。我们可以认为这些进程彼此并行运行，至少从这些独立进程的角度来看是这样的。</p>
<p>发言人   26:32<br>Now, this notion of a context switch, it’s managed by the kernel and it’s important to realize that the kernel is not like a separate process that’s running. It always runs in the context of some existing process and it’s just code that’s in the upper portion of the address space that gets executed as a result of an exception. So what happens? The way to think about this is that you have this process A that runs, and then an exception occurs which transfers control to the kernel.<br>现在，上下文切换的概念是由内核管理的，重要的是要认识到内核不像一个单独的进程正在运行。它始终在某些现有进程的上下文中运行，并且只是地址空间上部的代码，由于异常而被执行。所以发生了什么？思考这个问题的方法是，你有这个运行的进程，然后发生异常，将控制转移到内核。</p>
<p>发言人   27:10<br>The kernel invokes its scheduler, which decides whether to let a continue to run or to do a context switch and run a new process another process. So in this example, the scheduler is decided to run process B, so it executes code, sort of changes sort of. Once it repointed the address space, then it’s running in the context of process B, and it finishes loading the registers for process B, general purpose registers, transfers control to B, and B picks up where it left off. And then at some point, another exception occurs, and the kernel decides to transfer control back to process A, which picks up where it left off right here. So whatever instruction it finishes executing, whatever instruction it was executing at the time of the exception, executes the next instruction here.<br>内核调用其调度程序，调度程序决定是让一个进程继续运行还是进行上下文切换并运行新进程。因此，在这个例子中，调度器决定运行进程B，因此它执行代码，排序更改。一旦重新指向地址空间，它就会在进程B的上下文中运行，并完成加载进程B的寄存器、通用寄存器、传输控制面向企业，然后从中断的地方继续运行。然后在某个时刻，另一个异常发生，内核决定将控制权转移回进程A，该进程从这里停止的地方开始。因此，无论它执行完的指令是什么，无论它在异常发生时执行的指令是什么，它都会在此处执行下一条指令。</p>
<p>发言人   28:19<br>Now Linux provides a number of functions that you can call from a user program to manipulate processes. And this, this act of manipulating processes we refer to as process control. Now, all of these functions, I should say, most of these functions call invoke make system calls, but they’re wrapped in higher levels, what we call system level functions that are the things you actually call from your user program.<br>现在，Linux提供了许多函数，您可以从用户程序中调用它们来操作进程。这种操纵过程的行为，我们称之为过程控制。现在，所有这些函数，我应该说，大多数这些函数调用调用都会进行系统调用，但它们被包装在更高层次中，我们称之为系统级函数，它们是你从用户程序中实际调用的东西。</p>
<p>发言人   28:51<br>Now, system in Linux, system level functions will typically return a -1 if there’s an error, and then they’ll set a global variable called a no to indicate the reason. So there’s a hard and fast rule doing when you’re invoking system level functions, you must check the return values from those functions, and you’ll get into huge trouble if you neglect to check the return values. So you should never make a system level function call without checking the return value. And the only exception, there’s some functions that return void. Such as exit or free, Don’t return anything. So the way, the typical way you would do this is like the fork call, which we use to create processes, returns the process idea of the process that it created, which is always positive.<br>现在，在Linux系统中，系统级函数如果出现错误通常会返回-1，然后他们会设置一个名为no的全局变量来指示原因。所以当你调用系统级函数时，有一个严格的规则，你必须检查这些函数的返回值，如果你忽略了检查返回值，你会遇到巨大的麻烦。所以你永远不应该在没有检查返回值的情况下进行系统级别的函数调用。唯一的例外是，有些函数会返回void。例如退出或自由，不要返回任何东西。这样做的典型方式就像我们用来创建进程的fork调用一样，返回它所创建的进程思想，这总是积极的。</p>
<p>发言人   29:57<br>If there’s an error, returns -1 for the return value to be less than 0. And then we deal with that error somehow. In this case, we’re just printing a message and exiting. Now, this gets, although it’s essential to do this, it gets sort of from my point of view, where I’m trying to present code to you, it gets really messy, it takes up a lot of space, yes.<br>如果出现错误，则返回-1以确保返回值小于0。然后我们以某种方式处理这个错误。在这种情况下，我们只是打印一条消息并退出。现在，虽然这很重要，但从我的角度来看，我试图向您呈现代码时，它变得非常混乱，它占用了很多空间，是的。</p>
<p>发言人   30:33<br>I’m checking that it’s less than 0. Oh yeah, that probably that should be normally the convention is to return non-zero. So you’re right. It’s not a hard and fast rule, but that’s typically the convention. So yes, it should be exit 1. So what we’ll do to simplify this in the code that we present to you, in the code that we present to you in the book, we’ll define error reporting functions.<br>我正在检查它是否小于0。哦，是的，通常情况下惯例应该是返回非零。所以你是对的。这不是一个严格的规则，但这通常是惯例。所以是的，它应该是退出1。因此，我们将在我们呈现给您的代码中简化这一点，在我们在书中呈现给您的代码中，我们将定义错误报告功能。</p>
<p>发言人   31:06<br>So Unix style errors, where the function returns -1 and then sets error. Now, if we get that, if we get that kind of error, we’ll we’ll print a message and we’ll report what that error was before we exit. And so then in the code, we can replace that body of that if statement with just a single line.<br>So Unix样式错误，其中函数返回-1，然后设置错误。现在，如果我们收到那个错误，我们将打印一条消息，并在退出之前报告错误是什么。因此，在代码中，我们可以将if语句的主体替换为单行。</p>
<p>发言人   31:33<br>So that makes the code a little tighter, but we’ll go even further than that and we’ll define these wrappers, which pioneered by a great technical writer named W Richards Stevens. And what we do here is we replace each function with an error, a wrapper that has the identical interface as the function, the original function, and it has the first letter uppercase. And then what this wrapper does is it calls, it calls the original function checks for the errors, and then if there’s no error returns, what the original function would have returned. So the behavior of this wrapper is identical to the wrapped function if there’s not an error. And if there is an error, then it, it deals with it somehow and print a message. And so then this allows us to make our code really compact without violating this hard and fast rule that we have to check for errors.<br>这样代码就变得更紧凑了，但我们将更进一步，我们将定义这些包装器，这是由一位名叫W Richards Stevens的伟大技术作家开创的。我们在这里要做的是用一个错误替换每个函数，一个与函数具有相同接口的包装器，原始函数，并且它的第一个字母大写。然后这个包装器执行的是调用，它调用原始函数检查错误，然后如果没有错误返回，原始函数将返回什么。因此，如果没有错误，此包装器的行为与包装的函数相同。如果有错误，它会以某种方式处理它并打印一条消息。因此，这允许我们使代码非常紧凑，而不会违反我们必须检查错误的硬性规则。</p>
<p>发言人   32:42<br>Okay, the simplest process. Control functions are functions that allow you to get the PID for the current process, which is get PID or the processor idea of the parent process that created the current process. So these take no arguments, and they return an integer, which is a process ID. Now Linux provides ways to create and terminate processes.<br>好的，最简单的过程。控制函数是允许您获取当前进程的PID的函数，即获取PID或创建当前进程的父进程的处理器思想。所以这些不需要参数，并且它们返回一个整数，这是一个进程账号。现在，Linux提供了创建和终止进程的方法。</p>
<p>发言人   33:13<br>From a programmer’s perspective, we can think of a process as being in one of three states. So in this case, the process is actually running and execute instructions. It can be scheduled. Maybe it’s not running, but it can be scheduled at a later time. And it’s is waiting to be scheduled. It can be stopped, which means that execution is be spend it and won’t be scheduled until further notice. So we’ll see how this works when we study signals in the next lecture.<br>从程序员的角度来看，我们可以认为一个过程处于三种状态之一。因此，在这种情况下，进程实际上正在运行并执行指令。可以安排。可能它没有运行，但可以在以后安排。它正在等待安排。它可以被停止，这意味着执行将花费它，并且在另行通知之前不会计划。所以我们将在下一节课研究信号时看到这是如何工作的。</p>
<p>发言人   33:48<br>But usually a process is stopped because it receives a certain kind of signal and then the process becomes stopped and it won’t be executed. It won’t be scheduled until you explicitly tell it to be scheduled or a process can be terminated, which means it’s stopped permanently. So it’ll never be scheduled again, it’s done.<br>但通常一个进程会因为接收到某种信号而停止，然后进程就会停止，不会被执行。它不会被计划，直到你明确地告诉它被计划，或者一个进程可以被终止，这意味着它被永久停止。所以它永远不会被安排再次，它已经完成了。</p>
<p>发言人   34:13<br>Now, a process can be terminated for one of three reasons. So one, it receives a signal whose default action is to terminate it. Your program returns from the main routine. So you can, if you know the definition for main is int, c, main routines always return an int, so you can return from main and that will terminate your, it will terminate the process, or you can explicitly call the exit function. The exit function exits the program with an exit status of its argument. So as you pointed out, the convention for normal return is to return zero and then nonzero on error. Or you can another way to do this is just return an integer value from the main routine, and that will set the exit status.<br>现在，一个进程可以因以下三个原因之一被终止。所以，它接收到一个信号，其默认操作是终止它。你的程序从主程序返回。所以，如果你知道main的定义是int，c，main例程总是返回一个int，所以你可以从main返回，这将终止你的进程，或者你可以显式地调用exit函数。退出函数以其参数的退出状态退出程序。正如你所指出的，正常返回的约定是在出错时返回零，然后返回非零。或者你可以用另一种方法来做到这一点，就是从main例程返回一个整数值，这将设置退出状态。</p>
<p>发言人   35:09<br>Now, exit is kind of unusual. And you’ll see this is typical of all these process control functions that they normally functions. You call them once, and then they return once, but exit, you call once, and then it never returns. So that’s a little unusual.<br>现在，退出有点不寻常。你会发现这是所有这些过程控制功能的典型特征。你调用它们一次，然后它们返回一次，但是退出，你调用一次，然后它永远不会返回。这有点不寻常。</p>
<p>发言人   35:31<br>Now, a parent process can create a child process by calling the fork function. So fork takes no arguments. And it returns an integer. It creates a new child process. And then it returns in both the parent and the child. So this is a little hard to wrap your head around at first. It’s called once by the parent, but then it returns, it creates a new process, and then it returns in both the parent and the child. And to the child, it returns zero. The parent, it returns the child’s process ID.<br>现在，父进程可以通过调用fork函数来创建一个子进程。所以fork不接受任何参数。它返回一个整数。它创建了一个新的子进程。然后它在父母和孩子中都返回。所以一开始你有点难以理解。它被父级调用一次，但随后它返回，它创建一个新的进程，然后在父级和子级都返回。对于孩子，它返回零。对于父进程，它返回子进程的账号。</p>
<p>发言人   36:24<br>The child gets an identical copy of the parent’s virtual address space, but separate, right? They’re distinct. But immediately after the fork returns the addresses, the address space is identical. So that means that all the variables, all the global variables, the stack, the code, everything is identical in the child and has exact same values as it does in the parent.<br>子节点将获得父节点虚拟地址空间的完全相同的副本，但它们是分开的，对吗？它们是独特的。但在分叉返回地址之后，地址空间立即相同。这意味着所有的变量，所有的全局变量，堆栈，代码，所有在子级中都是相同的，并且具有与父级完全相同的值。</p>
<p>发言人   36:54<br>The child gets identical copies of the parent’s open file descriptors. So the child has access to any open files, including like standard in and standard out that the parent had. And the only difference is that the child gets a different process ID than the parent.<br>孩子获得父母的打开文件描述符的相同副本。这样孩子就可以访问任何打开的文件，包括父级的标准输入和标准输出。唯一的区别是孩子得到的过程账号与父母不同。</p>
<p>发言人   37:13<br>So fork is really strange because it’s called once, but returns twice, once in the parent and once in the child. So here’s an example of this. This is an example program that has, it has a local variable called x on the stack initialized to one. And then it calls fork and fork creates the child and returns the. It returns a value to both the parent and the child.<br>所以fork真的很奇怪，因为它被调用一次，但返回两次，一次在父级，一次在子级。这里有一个例子。这是一个示例程序，它在堆栈上有一个名为x的局部变量初始化为1。然后调用fork，fork创建孩子并返回。它会向父级和子级返回一个值。</p>
<p>发言人   37:53<br>The only way we can distinguish whether we’re executing in the parent or the child is to check that return value. So here, if the process ID, if PID is 0, then we’re executing in the child. And remember, the child got exactly the same, has exactly the same.<br>我们可以区分是在父级执行还是在子级执行的唯一方法是检查返回值。所以在这里，如果进程账号，如果PID为0，那么我们正在执行子进程。请记住，这个孩子得到了完全相同的东西，拥有完全相同的东西。</p>
<p>发言人   38:14<br>Memory and code as the parent. So x in the child is one. So when we print this message from the child, we increment x and then print this message. So the child will print 1 plus 1, 2, and then exit in the parent. When we check this process ID, it’s going to be non-zero because it’s the process ID of the child. So in this case, so the parent won’t execute this, the body of this conditional. So the parent will execute this print f, and in the parent, we decrement x before we print it. So the parent prints out 1 -1 is 0. Now there’s no guarantee, we have no guarantee whether the child or the parent execute first when the fork.<br>内存和代码作为父代。所以孩子中的x是一个。所以当我们从孩子那里打印这条消息时，我们递增x，然后打印这条消息。所以孩子将打印1加1，2，然后退出父级。当我们账号检查这个过程时，它将是非零，因为它是孩子的过程账号。在这种情况下，父级不会执行这个条件体。因此，父级将执行此打印f，并且在父级中，我们在打印之前递减x。所以父打印输出1-1是0。现在无法保证，我们无法保证在分叉时子级还是父级首先执行。</p>
<p>发言人   39:10<br>When the fork returns, the colonel may decide to schedule the child first, in which case this code in the body of the conditional would run, or it may decide to run the parent first. And there’s no way to predict, and it’s wrong. It’s an error to make any assumption like that about what’s going to run first, the parent or the child. And you can see that they share the same open files. Both the parent and the child print to stand out, and it prints on the terminal.<br>当分叉返回时，上校可能会决定首先调度子级，在这种情况下，条件体中的此代码将运行，或者它可能决定首先运行父级。没有办法预测，而且这是错误的。对于首先运行的是父母还是孩子，做任何这样的假设都是错误的。你可以看到它们共享相同的打开文件。父级和子级都打印出来，并在终端上打印。</p>
<p>发言人   39:45<br>Yes, what if you call fork multiple? What the question is, what if you call fork multiple times? I’ll show you some examples of those. It gets a little hairy We have, we’ll use a model called a process graph to sort of understand what happens. So just like you said, thats forks are kind of can be kind of complex to understand, especially if they’re nested or you call them multiple times. So we use a tool called the process graph to capture sort of what what could happen when we call forks.<br>是的，如果你把分叉叫做多重呢？问题是，如果你多次调用fork怎么办？我会给你看一些例子。它变得有点毛茸茸的，我们将使用一个称为过程图的模型来理解发生了什么。所以就像你说的，分叉有点复杂，难以理解，特别是如果它们是嵌套的或者你多次称呼它们。因此，我们使用一种名为进程图的工具来捕捉当我们调用分叉时可能发生的情况。</p>
<p>发言人   40:27<br>We can’t make any assumption about the ordering of of different processes, but we can capture the partial ordering of events using this tool called a process graph. So what we’ll do is we’ll let each vertex correspond to the execution of a statement and then an edge that happens before relation. So A happens before B, and then we will label edges with current values of variables. If we have a printout vertices, a vertex that corresponds to a print f, we can label that with the output. And then every graph starts with a vertex with no in edges. So given this graph, then any topological sort of the graph represents some feasible, some feasible total ordering of events. And by topological sort, we mean a total ordering of the vertices where all the edges go from left to right.<br>我们不能对不同进程的顺序做出任何假设，但我们可以使用这个称为进程图的工具来捕获事件的部分排序。所以我们要做的是让每个顶点对应于一个语句的执行，然后是一个在关系之前发生的边。所以A发生在B之前，然后我们将用变量的当前值标记边缘。如果我们有一个打印输出顶点，一个对应于打印f的顶点，我们可以用输出标记它。然后每个图都从一个没有边线的顶点开始。因此，给出这个图，那么图的任何拓扑排序都表示一些可行的，一些可行的事件总排序。所谓拓扑排序，是指顶点的总排序，其中所有边都是从左到右排列的。</p>
<p>发言人   41:24<br>Okay, so let’s look at how this would work for our example program. Here we have the parent initially x is equal to one, and then the parent calls fork. The fork returns in both the parent and the child, the child prince, and both the parent and the child print the value of x after incrementing or decrementing, and then they both exit. So you can think of these as it is happening. So these happen concurrently, which means they can be interleaved in any way. So the topological sort of this graph will tell us what are feasible.<br>好的，让我们看看这对于我们的示例程序是如何工作的。在这里，我们首先让父代x等于1，然后父代调用fork。该分叉在父级和子级中都返回，即子王子，并且父级和子级都在递增或递减后打印x的值，然后它们都退出。所以你可以在这些事情发生时想到它们。所以这些是同时发生的，这意味着它们可以以任何方式交错。因此，此图的拓扑排序将告诉我们什么是可行的。</p>
<p>发言人   42:13<br>Interleavings? So we can. So if we relabel the graph, just to keep it simple. So if we relabel these edges with just single letters. Then this total ordering AB, EC, FD represents it’s a topological sort and thus a feasible total ordering.<br>交错？所以我们可以。所以如果我们重新给这个图做一个简单的定义。因此，如果我们只用单个字母重新给这些边缘加上字母。那么这个全序AB，EC，FD表示它是一个拓扑排序，因此是一个可行的全序。</p>
<p>发言人   42:39<br>So here we have a execu then b, then e executes in the child. And then at this point, the kernel decides to swap out, swap out e, swap out the child, and now let the parent run. So the parent picks up and executes C and then it gets rescheduled. Then the child gets scheduled it and executes F, and then the parent runs and finally finishes. So this is very unlikely that you’d only execute one instruction and then be and then have a context switch, but it’s feasible because it represents because the total ordering is a topological ordering.<br>这里我们有一个execu，然后是b，然后是e在孩子中执行。然后在这一点上，内核决定换出，换出e，换出子级，现在让父级运行。所以父代选择并执行C，然后重新安排时间。然后子进程被调度并执行F，然后父进程运行并最终完成。因此，不太可能只执行一条指令，然后进行上下文切换，但这是可行的，因为它表示的是总排序是拓扑排序。</p>
<p>发言人   43:32<br>On the other hand, this is infeasible because f here in this total ordering, we’re executing f before e, and you can see that just can’t happen. So the edges on the logical flow represented by this child have to occur in this order first E and then f by the just because. F follows E in the code. The compiler is not going to. It’s not going to alter those.<br>另一方面，这是不可行的，因为在这个总排序中，我们在e之前执行f，你可以看到这是不可能发生的。因此，由这个子级表示的逻辑流上的边缘必须按照这个顺序首先出现E，然后是f，因为只是因为。在代码中，F跟随E。编译器不会这样做。它不会改变这些。</p>
<p>发言人   44:09<br>OK, so what happens if now, if we have two consecutive forks? Well, let’s draw the process graph will help us understand this. So in the parent, we print L 0 and then fork, and that creates a child. And so the fork returns to this printf and both the parent and the child. So both the parent and the child print L 1. And then both parent and child execute a fork. So that creates another child. That creates now two children. And so that returns to the printf, which says buy. So the result of this, of calling fork twice like this, is that it creates 4 processes.<br>好的，那么如果现在我们有两个连续的分叉会发生什么？好的，让我们画进程图将帮助我们理解这一点。所以在父级中，我们打印l0，然后打印fork，这会创建一个子级。因此分叉返回到此printf以及父级和子级。所以父母和孩子都打印L 1。然后父母和孩子都执行一个分叉。这样就创造了另一个孩子。这就产生了两个孩子。这样就返回到printf，上面写着 “购买”。因此，像这样两次调用fork的结果是它创建了4个进程。</p>
<p>发言人   45:04<br>And if it’s confusing, you can always work it out with the process graph like this. So we can see feasible and infeasible orderings. So this one’s feasible. Take my word for it, this one is in feasible. And let’s see y, so L 0, and there’s no way to print by before the first fork. So that’s infeasible. If we drew out this process graph, we’d have a backward, a backward edge.<br>如果令人困惑，您可以随时使用这样的流程图表来解决问题。所以我们可以看到可行和不可行的订单。所以这个是可行的。相信我的话，这个是可行的。让我们看一下y，所以是L 0，而且在第一次分叉之前没有办法打印。所以这是不可行的。如果我们绘制这个过程图，我们会有一个向后的边缘。</p>
<p>发言人   45:41<br>Okay, now what happens if we nest forks in the parent? Okay? I’m not sure why you’d want to do this, except maybe to torture to 13 students, but. So we can just work this out by drawing the process graph.<br>好的，如果我们在父节点中嵌套分叉会发生什么？好吗？我不知道你为什么想这样做，除了可能折磨13个学生。所以我们可以通过绘制过程图来解决这个问题。</p>
<p>发言人   45:57<br>So here we have the parent at Prince L 0, and then it does a fork. So that creates a child. So the child. If fork is not equal to 0, then we’re in the parent. So this code executes in the parent. If fork is 0, then we’re executing the child, and the child just prints by and then, and then it eventually terminates.<br>这里我们有位于王子l0的父代，然后它进行分叉。这样就创造了一个孩子。所以这个孩子。如果fork不等于0，那么我们在父级中。所以这段代码在父级中执行。如果fork为0，那么我们将执行子进程，然后子进程将打印出来，最终终止。</p>
<p>发言人   46:28<br>I didn’t show it here, Carl, exit the function that called this function calls exit, So the parent, so fork not equal to 0 indicates that this is the parent. So the parent prints L 1, and then it does another fork that for creates a child. So if fork is not equal to 0, then we’re in the parent. So the parent prints L 2 and then exits this conditional and prints by if. If fork returns 0, then that means we’re executing the child. So we don’t execute this code, we jump out of this conditional, and then the child just prints by. And we can. So this represents an infeasible output from this program.<br>我没有在这里展示它，卡尔，退出调用此函数的函数exit，因此父函数，所以fork不等于0表示这是父函数。因此，父级打印L 1，然后执行另一个分支，为其创建一个子级。所以如果fork不等于0，那么我们在父级中。所以父项打印L 2，然后退出此条件并按if打印。如果fork返回0，那么这意味着我们正在执行孩子。所以我们不执行这段代码，我们跳出这个条件，然后孩子只是打印出来。我们可以。所以这代表了这个程序的不可行的输出。</p>
<p>发言人   47:32<br>So l 0. Followed by that’s feasible, and then followed by L 1, that’s OK. And then the next buy is OK. But we can’t have this by preceding this L 2, because L 2 will, this print f will execute before this print f? And I’ll let you work out this one as an exercise. Right now.<br>所以，我0。接着是可行的，然后是L 1，没关系。然后下一个买入就可以了。但是我们不能通过在这个L 2前面来实现这个，因为L 2会，这个print f会在这个print f之前执行吗？我会让你把这个作为练习来练习。就现在。</p>
<p>发言人   48:13<br>When a process terminates, for whatever reason, the system actually keeps it around until it’s reaped, and the reason until it’s reaped by its parent. And the reason it does this is that the parent may want to know about the exit status of the child.<br>当一个进程由于某种原因终止时，系统实际上会保留它直到它被收获，并且直到它被其父级收获。这样做的原因是家长可能想知道孩子的退出状态。</p>
<p>发言人   48:32<br>If a parent creates a child, it may want to wait for that child to finish and check its exit status. So when any process terminates, the system leaves it, it doesn’t remove it entirely from the system. It keeps a little bit of state associated with that child in the form of the exit status of the child and some other tables, some other OS tables. So because this child, it’s terminated, but it’s not gone, they’re called zombies. So they’re sort of half, half living, half dead. And so a process, a zombie remains a zombie until it’s reaped by its parent using a function called weight or weight pit. As a result, as a result of doing weight or weight pit, the parent is given the exit status information and then the kernel deletes the zombie process.<br>如果父项创建了一个子项，它可能需要等待该子项完成并检查其退出状态。因此，当任何进程终止时，系统会离开它，不会将其完全从系统中删除。它以孩子的退出状态和一些其他的表，一些其他的OS表的形式保持与那个孩子相关联的状态。所以因为这个孩子，它终止了，但它没有消失，他们被称为僵尸。所以他们有一半，一半是活的，一半是死的。因此，在一个过程中，僵尸一直是僵尸，直到它被其父级使用称为权重或权重坑的函数收获。因此，作为执行权重或权重坑的结果，父进程将获得退出状态信息，然后内核删除僵尸进程。</p>
<p>发言人   49:35<br>Now, what if the parent doesn’t reap? It’s one of its child zombies. If any parent, if the parent terminates, then the system arranges for the very first process that existed in the system called the init process, which has a process ID of 1. It arranges for the init process to reap that child. So orphaned children will always be reaped by the init process. So we only really have to worry about.<br>现在，如果父母不收获怎么办？它是它的一个子僵尸。如果有任何父进程，如果父进程终止，则系统将安排系统中存在的第一个进程，称为init进程，其进程账号为1。它安排init进程收获那个孩子。因此，孤儿将永远被init过程所收获。所以我们只需要真正担心。</p>
<p>发言人   50:12<br>Reaping zombies in the case where we have long running parents like shells or servers, because in that case, a server may create millions of child processes. Each one of those. Each one of those. Child processes, when they terminate, becomes zombies and they have state. It takes up room in the kernel. So you can get this. It’s a form of memory leak. If you don’t reap these zombie children, that can eventually fill up the memory space and crash the curdle.<br>在我们像shell或服务器一样长时间运行父进程的情况下，收获僵尸，因为在这种情况下，服务器可能会创建数百万个子进程。每一个。每一个。子进程在终止时会变成僵尸，并且它们具有状态。它在内核中占据了空间。所以你可以得到这个。这是一种内存泄漏的形式。如果你不收获这些僵尸孩子，最终会填满记忆空间并使凝乳崩溃。</p>
<p>发言人   50:51<br>So for cases where you have long running programs, then we have to use weight or weight pit to reap the children. So at an example, first, let’s look at an example of. Of this zombie phenomenon? So here we have a function we call fork. And then within the child, we print a message, the process idea of that child, and then we exit the child. Within the parent, we print a message, and then we go into an infinite loop. So this is a parent’s that never reaps the child that it created. So if we run this program called Forks, you can see it prints these two messages.<br>因此，对于长时间运行程序的情况，我们必须使用重量或重量坑来收获孩子。所以在一个例子中，首先，让我们来看一个例子。这种僵尸现象？这里我们有一个叫做fork的函数。然后在孩子内部，我们打印一条消息，该孩子的流程想法，然后我们退出孩子。在父级中，我们打印一条消息，然后进入无限循环。所以这是一个永远不会得到它所创造的孩子的父母。所以如果我们运行这个名为Forks的程序，你可以看到它打印这两条消息。</p>
<p>发言人   51:43<br>The parent prints a message, and the child prints a message and. We’re running it in the background with this ampersand because we’re going to, otherwise it would, it’s still running and we wouldn’t be able to inspect it. So after we run this program in the background, then we use Ps to print the current processes. And we can see that there’s two. We can see here the parent, which is process ID 6639, and then the child, which is 6006 4 0. And the defunct indicates that it’s a zombie. Okay, now if we kill 6, 6, 3, 9, that’s the parent and then do another Ps, you see that Z, the child is gone because it’s been reaped by the init process 1.<br>家长打印一条消息，孩子打印一条消息。我们使用这个 &amp; 符号在后台运行它，因为我们要这样做，否则它仍在运行，我们将无法检查它。因此，在后台运行此程序后，我们使用Ps打印当前进程。我们可以看到有两个。我们可以在这里看到父进程，即账号6639，然后是子进程，即6006 4 0。而死亡表明它是一个僵尸。好的，现在如果我们杀死6、3、9，即父母，然后再做一次Ps，你会看到Z，孩子消失了，因为它被init进程1收获了。</p>
<p>发言人   52:40<br>Now, what happens if the child doesn’t terminate? You might wonder? Like if a parent creates a child and then the parent. And then the child, the child never terminates and the parent terminates. Then what would happen? So let’s look at an example of this and see here we’re calling fork. We’re creating a child. Within the child, we print a message, and then the child goes into an infinite loop, and the parent prints a message and then exits. So if we run this program. You can see that the two messages from parent and child. And then if we look at, if we look at the processes, we can see, we can see that the child is still running.<br>现在，如果孩子不终止，会发生什么？你可能会好奇？就像父母创建了一个孩子，然后是父母。然后孩子，孩子永远不会终止，而父母终止。那么会发生什么呢？让我们来看一个例子，看看我们在这里调用fork。我们正在创造一个孩子。在孩子内部，我们打印一条消息，然后孩子进入一个无限循环，父母打印一条消息然后退出。所以如果我们运行这个程序。你可以看到来自父母和孩子的两条消息。然后，如果我们看一下这些过程，我们可以看到，我们可以看到孩子仍在跑步。</p>
<p>发言人   53:43<br>So the child process is still running even though the parent has terminated. And now if we kill this child, 6006, 7, 6.<br>因此，即使父进程已终止，子进程仍在运行。现在，如果我们杀了这个孩子，6006，7，6。</p>
<p>发言人   53:58<br>And then if we kill it, then we can see that it’s gone. It’s no longer in the system. So that child, when we killed it, that terminated it, it had no parents. So the init process reaped it, and it’s no longer a zombie.<br>然后如果我们杀了它，那么我们就可以看到它不见了。它不再存在于系统中。所以那个孩子，当我们杀死它时，终止了它，它没有父母。所以init进程收获了它，它不再是一个僵尸。</p>
<p>发言人   54:15<br>So the function that we use to synchronize with children and reap them, the simplest one is called weight. And weight, it takes an optional status where you can get the exit status of the inspect, the exit status of the child. Basically, weight suspends the execution of the process that calls it until one of its children terminates. And it doesn’t specify which one. It just waits until one of the children that it created terminates. And then if this child status is non null, then the integer that it returns or the integer that it points to, this is a pointer. The integer that it points to will be set to some value that indicated the reason the child terminated and its exit status. And you can check that using these macros, which your textbook describes in more detail you.<br>所以我们用来与孩子同步并收获他们的函数，最简单的一个被称为权重。和重量，它需要一个可选的状态，您可以获得检查的退出状态，孩子的退出状态。基本上，权重暂停调用它的进程的执行，直到它的一个子项终止。它没有具体说明是哪一个。它只是等待，直到它创建的一个孩子终止。如果这个子状态不为空，那么它返回的整数或它指向的整数就是一个指针。它指向的整数将被设置为某个值，指示子项终止的原因及其退出状态。你可以使用这些宏进行检查，你的教科书会更详细地描述你。</p>
<p>发言人   55:19<br>So let’s look at how this works in a simple example. So here we’re calling fork and creating a child which prints a message and then exits. The parent prints a message, and then it waits for the child to terminate. And when the child terminates, it prints a message and indicating that the child terminated and then print by. So if we were to look at the process graph for this, you would see that we would have the fork creates the parent and the child, both the parent and the child do their print FS, and then the parent waits, it suspends until the child terminates, in this case by crawling exit. So what that means is it’s infeasible. So you can say hello from the parent. It’s infeasible, though, for this child terminated message CT to occur before the buy.<br>让我们通过一个简单的例子来看看它是如何工作的。所以在这里，我们调用fork并创建一个子级，它打印一条消息然后退出。父级打印一条消息，然后等待子级终止。当孩子终止时，它会打印一条消息并指示孩子终止了，然后打印。因此，如果我们查看进程图，您会看到我们将让分叉创建父级和子级，父级和子级都执行打印FS，然后父级等待，直到子级终止，在这种情况下通过爬行退出。这意味着这是不可行的。所以你可以跟家长打招呼。但是，这个孩子终止的消息CT在购买之前发生是不可行的。</p>
<p>发言人   56:37<br>Because the child hasn’t yet terminated. These two messages will never be printed until the child is terminated by calling exit. So is that clear, yes?<br>因为孩子还没有结束。这两条消息永远不会打印出来，直到子级通过调用exit终止。那么清楚了吗？</p>
<p>发言人   56:59<br>So the question is, can you have an output HP? HHC? CT by yes. Yes, because the parent X print HP, there’s a context switch. The child prints HC and then exit. And now the parent will, the weight will return, and then it prints CT by.<br>所以问题是，你能有一个输出惠普吗？HHC?CT是。是的，因为父X打印惠普，有一个上下文切换。孩子打印HC然后退出。现在父级会，权重将返回，然后打印CT。</p>
<p>发言人   57:37<br>Here’s is a, this is a little more, a little more involved example.<br>这是一个，这是一个更复杂一点的例子。</p>
<p>发言人   57:45<br>So here what we want to do, we’re going to create a bunch of children and then we’re going to wait for them all to terminate. And we’re going to wait, but we won’t be able to wait in any specific order. So here we have a loop 0 through n, and in each loop body, we’re going to fork a child and exit with a return status. That’s going to tell us which child it was. In the parent. So we do this, we do this n times. And then afterward, the parent inside a similar loop, 0 to n, wait for a child to terminate. So it’ll wait for n children to terminate, returns, a weight returns.<br>所以在这里，我们想要做的是，我们将创建一堆孩子，然后我们将等待它们全部终止。我们将等待，但我们无法以任何特定的顺序等待。这里我们有一个从0到n的循环，在每个循环体中，我们将分叉一个子循环并以返回状态退出。这会告诉我们是哪个孩子。在父母中。所以我们这样做，我们这样做n次。然后，父级在一个类似的从0到n的循环中，等待子级终止。所以它会等待n个孩子终止，返回，重量返回。</p>
<p>发言人   58:42<br>The process ID and then a status. Which is in this child status variable? And so we take that variable now, and we can use this Wf exited macro to determine if it terminated normally with an exit by calling exit. And if so, then we can check its exit status using the W exit status macro. Otherwise, if W, if X is false, then that means something.<br>进程账号，然后是状态。这个子状态变量中包含哪个？所以我们现在接受这个变量，我们可以使用这个Wf退出的宏通过调用exit来确定它是否以exit正常终止。如果是这样，那么我们可以使用W exit status宏检查其退出状态。否则，如果W，如果X为假，那么这意味着什么。</p>
<p>发言人   59:17<br>The child terminated for some other reason, not because it called exit. There’s a, we can actually use weight pit, which similar to weight, but it allows us to wait for a specific process, a child, a specific child with a specific process. ID to terminate. And I’ll let you. You can wait. Pit is really involved. It’s described in detail in your textbook. And so you, you’ll need to look there for the details of how that works.<br>孩子因为其他原因而终止，而不是因为它被称为退出。有一个，我们实际上可以使用重量坑，类似于重量，但它允许我们等待一个特定的过程，一个孩子，一个特定的过程。账号终止。我会让你。你可以等待。坑真的很牵扯到。它在你的教科书中有详细描述。所以你需要在那里查看它是如何工作的细节。</p>
<p>发言人   59:58<br>Now, another important. So we’ve learned how to create new processes. But we haven’t learned how to. When we call fork, we just create an exact copy of the child is just an exact copy of the parent running the same code, same program, same variables to run a different program inside of a process, we use a function called exec ve and exec loads and runs within the current process, it loads and runs the executable file name, which is its first argument, and file name can be either a binary executable binary or it can be a script, it can be a text file, a sole carelle script file that starts whose first line starts with a. Pound, bang. And then the path of some interpret. So for example, if you want to write a shell script, the first line of shell script is is pound bang, and then the path name of the bass shell, and then that will execute bash, and then bash will read in the lines following and interpret them just as though you’d type them in at the command line. So in either case, it executes either an interpreter or it executes a binary with the argument list argv and a list of environment variables in envp.<br>现在，另一个重要的问题。所以我们学会了如何创建新的流程。但我们还没学会怎么做。当我们调用fork时，我们只是创建子节点的精确副本，它只是父节点的精确副本，运行相同的代码、相同的程序、相同的变量，以便在进程内运行不同的程序，我们使用名为exec ve和exec的函数加载并在当前进程内运行，它加载并运行可执行文件名，这是它的第一个参数，文件名可以是二进制可执行二进制文件，也可以是脚本，可以是文本文件，也就是第一行以a开头的唯一脚本文件。英镑，砰。然后是一些解释的路径。因此，例如，如果您想编写一个shell脚本，shell脚本的第一行是pound bang，然后是bass shell的路径名，然后执行bash，然后bash将读取后面的行并解释它们，就像您在命令行中输入它们一样。所以在任何一种情况下，它都会执行解释器或执行带有参数列表argv和envp中的环境变量列表的二进制文件。</p>
<p>发言人   01:01:42<br>Now, by default, the first argument in RV is the name of the file that’s being executed. So it’s this file name. So what that allows you to do is in your code, you can check arc-v zero if you want to print out the name of the file, the name of the program that’s executing, you just print out arc-v 0.<br>现在，默认情况下，RV中的第一个参数是正在执行的文件的名称。所以就是这个文件名。所以这允许你在代码中做的是，如果你想打印出文件的名称，正在执行的程序的名称，你可以检查arc-v zero，你只需要打印出arc-v 0。</p>
<p>发言人   01:02:09<br>Okay, now it exec overwrites all of the code and the data and the stack itworld. Completely overwrites the virtual address space. So once you call exec within a process, it blows away the current program, that’s it. However, it retains that it’s still the same process. It’s just running now a different program. And so it retains the process ID and any open files that you have. So exec is really is really mind blowing because it’s called once, but it never returns. Except if there’s an error. So if this file doesn’t exist, for example, then exec will return -1. But otherwise, in normal operation, it never returns.<br>好的，现在它会覆盖所有代码、数据和堆栈。完全覆盖虚拟地址空间。所以一旦你在进程内调用exec，它就会破坏当前的程序，就是这样。然而，它保留了它仍然是相同的过程。它现在只是在运行一个不同的程序。因此它会保留进程账号和您打开的任何文件。所以exec真的非常令人兴奋，因为它被调用了一次，但它永远不会返回。除非有错误。因此，如果此文件不存在，例如，则exec将返回-1。否则，在正常操作中，它永远不会返回。</p>
<p>发言人   01:03:10<br>So let’s look at the structure of the stack when this new program starts.<br>让我们来看看这个新程序启动时堆栈的结构。</p>
<p>发言人   01:03:17<br>After the exec veins its work, it creates a new stack, it loads in new code and data, creates a new empty heap. Everything’s new, and the stack that it creates has the following form. At the here’s the bottom of the stack, and our stack is growing this way. So the first function that executes is a function called libc underscore start underscore main. So that has a stack frame. So let’s look. This is what I’m showing here is the situation right before the startup code calls main. The future stack frame for Main will be here at following the top of the stack, there’s some padding and then the argument list in RV is contained on the stack.<br>执行后，它会创建一个新堆栈，加载新的代码和数据，创建一个新的空堆。一切都是新的，它创建的堆栈具有以下形式。这里是堆栈的底部，我们的堆栈正在以这种方式增长。因此，执行的第一个函数是一个名为libc下划线开始下划线main的函数。所以它有一个堆栈框架。让我们来看看。这就是我在这里展示的是启动代码调用main之前的情况。Main的未来堆栈帧将在堆栈顶部之后出现，有一些填充，然后RV中的参数列表包含在堆栈中。</p>
<p>发言人   01:04:24<br>So the RV is a list of pointers terminated by the null pointer. And each one of these pointers points up into a string that corresponds to an argument. So when you run a program, you specify the program name, and then arguments separated by spaces. And so these arguments, this arc-v, is a list of pointers to those argument strings. And it’s pointed to, right, as Maine is called. It’s the second argument to Maine, so it’s contained in RSI, the address of, of this argument list, the number of arguments is contained is the first argument RC? And that’s contained in RDI by the x 8664 parameter passing and convention.<br>所以RV是一个以空指针终止的指针列表。这些指针中的每一个都指向一个与参数对应的字符串。因此，当您运行程序时，您需要指定程序名称，然后用空格分隔参数。所以这些参数，这个arc-v，是指向这些参数字符串的指针列表。它被指向了，对，缅因的名字。它是Maine的第二个参数，所以它包含在RSI中，这个参数列表的地址，包含的参数数量是第一个参数遥控吗？并且这包含在RDI中x 8664参数传递和约定中。</p>
<p>发言人   01:05:21<br>Now, the environment list is also contained on the stack. It too consists of a list of pointers, each of which points into an environment string, which is a set of key equal value pairs. And it’s pointed to by the global environment variable environ. And if it’s passed in, it’s pointed at in EVPAY contained in RDX, which always holds the third argument.<br>现在，环境列表也包含在堆栈中。它也包含一个指针列表，每个指针指向一个环境字符串，该字符串是一组键相等值对。并且它由全局环境变量environ指向。如果它被传入，则指向RDX中包含的ev支付中，它始终包含第三个参数。</p>
<p>发言人   01:05:56<br>Okay, so let’s look now how we would use this. So we want to, within our current program, we want to execute the LS command with two arguments, dash Lt and slash user slash include. So what this is saying is list, list the files in slash user include show the long form of the listing and sort them in time order from most recently used to least recently used. So the way we do this, if we just called exec vector, would blow away our program.<br>好的，现在让我们看看如何使用这个。因此，我们希望在当前程序中执行带有两个参数的LS命令，破折号Lt和斜杠用户斜杠包括。所以这就是说列表，在斜线用户中列出文件包括显示列表的长格式，并按时间顺序从最近使用到最近使用的排序。所以我们这样做的方式，如果我们只调用exec vector，就会把我们的程序吹走。</p>
<p>发言人   01:06:35<br>So assuming we want to continue to do work after we execute LS, the standard way to do this is to create a child using fork and then x in the child have the child do the work, and then the child terminates and the parent, maybe we’ll wait for the child, maybe not, right? Just usually it’ll wait for the child. So within the parent, we fork a child, check that it’s zero. And so if it’s 0, then we’re executing that this code executes within the child, so the child does the exec, it passes the name of the function, the name of the function that we want to, The program that we want to execute is always contained in the first element of argv we call exec with a parameter of Mylar v 0.<br>所以假设我们想在执行LS之后继续工作，标准的方法是使用fork创建一个孩子，然后x在孩子中让孩子完成工作，然后孩子终止并且父母，也许我们会等待孩子，也许不会，对吗？通常它会等待孩子的出现。因此，在父母内部，我们分叉一个孩子，检查它是否为零。所以，如果它是0，那么我们正在执行这个代码在孩子中执行，所以孩子执行exec，它传递函数的名称，我们想要的函数的名称，我们想要执行的程序始终包含在argv的第一个元素中，我们称之为exec，参数为Mylar v 0。</p>
<p>发言人   01:07:37<br>And we’ve set up the argument list in my argv, and we passed the global environment variable environment. We’re just going to use the current list of environment variables that we have in the parent. And these environment variables are things of the form user equal d current working directory. And so? If this program in my RV zero doesn’t exist, then exec will return -1. So we check for that condition and then exit. Otherwise it never returns, right?<br>我们在我的argv中设置了参数列表，并传递了全局环境变量environment。我们只会使用父级中当前的环境变量列表。这些环境变量的形式为用户等于当前工作目录。所以呢？如果我的RV零中这个程序不存在，那么exec将返回-1。所以我们检查那个条件，然后退出。否则它永远不会回来，对吧？</p>
<p>发言人   01:08:24<br>It executes LS, LS, the code for LS, This is the name of a binary slash bin slash LS is a binary file. That binary file gets loaded into memory, that code gets executed, and it terminates the child. At this point, after the exec, the child is running the LS code, and it’s no longer running any of this code.<br>它执行LS，LS，LS的代码，这是二进制斜杠的名称，二进制斜杠LS是一个二进制文件。该二进制文件被加载到内存中，该代码被执行，并终止该子代码。此时，在exec之后，子进程正在运行LS代码，并且不再运行任何此代码。</p>
<p>发言人   01:08:56<br>Now, this seems the first time you see this, this combination of fork and exec, it seems, it seems a little odd, doesn’t it? Why not, why not just have one command that creates a new process and runs and runs a program in that process? Why, why separate, why have these two separate for inexec? I in fact Windows does this. Windows has like one command that creates a process and executes it.<br>现在，这似乎是你第一次看到这个fork和exec的组合，看起来有点奇怪，不是吗？为什么不，为什么不只有一条命令来创建一个新的进程并在该进程中运行和运行程序呢？为什么，为什么分开，为什么这两个为inexec分开？事实上，Windows是这样做的。Windows有一个命令，可以创建一个进程并执行它。</p>
<p>发言人   01:09:29<br>But it turns out that having a separate function like fork just to create processes is actually really useful. I mean, sometimes you just want to create replicas of your current process. For example, let’s say you have a server and you want to create a concurrent server. You want to create multiple copies of that server. Then you just fork A, you have the parent server can fork a bunch of children. So that’s useful, and they’re just all running.<br>但事实证明，拥有一个像fork这样的单独函数来创建进程实际上非常有用。我的意思是，有时候你只是想创建当前流程的副本。例如，假设您有一个服务器，想要创建一个并发服务器。您想要创建该服务器的多个副本。然后你只需要分叉一个，你让父服务器可以分叉一堆孩子。这很有用，而且它们都在运行。</p>
<p>发言人   01:10:01<br>But what this also allows you to do is it allows you to execute code in the child before you call exec. So you may want to set some, you may want to set some like some signal. This is especially useful when you’re dealing with with things like signals, if you want to block certain signals or unblock certain signals, you can do it right here in this gap between the fork and the exec.<br>但这也允许你做的是，它允许你在调用exec之前在孩子中执行代码。所以你可能想要设置一些，你可能想要设置一些像一些信号。这在您处理信号之类的事情时特别有用，如果您想阻止某些信号或解除阻止某些信号，您可以在fork和exec之间的间隙中进行操作。</p>
<p>发言人   01:10:37<br>Okay, so that’s it. So just to summarize what we’ve talked about today, exceptions are in response to events that require some kind of non standards or exceptional, what we call exceptional control flow. They can be generated internally in the form of interrupts or internally in the form of traps and faults. So at any point in time, a process has multiple, a system has multiple processes, only one of which can execute on a single core. Process execution is interleaved by the kernel, and each process thinks that it has sort, total, total control of the processor in its address space.<br>好的，就这样。因此，总结一下我们今天讨论的内容，异常是对需要某种非标准或异常的事件的响应，我们称之为异常控制流。它们可以在内部以中断的形式生成，也可以在内部以陷阱和故障的形式生成。因此，在任何时间点，一个进程都有多个，一个系统有多个进程，其中只有一个进程可以在单核上执行。进程的执行由内核交错进行，每个进程都认为它在地址空间中拥有处理器的排序总控制权。</p>
<p>发言人   01:11:26<br>There’s only one mechanism to spawn processes, that’s fork, and it’s called once and returns twice. We can terminate our process by calling exit, which is called once and never returns. We reap and wait for processes using weight or weight pit, and we load and run programs using exec Ve or one of its variants. And this one is called once and normally never returns. Okay, so that’s it for today. And we’ll see you have a good weekend and we’ll see you on Tuesday.<br>只有一种产生进程的机制，那就是fork，它被调用一次并返回两次。我们可以通过调用exit来终止我们的进程，exit被调用一次，从不返回。我们使用权重或权重坑来收割和等待进程，并使用exec Ve或其变体之一加载和运行程序。这个被调用一次，通常从不返回。好的，今天就到这里。我们会看到你有一个愉快的周末，我们会在周二见到你。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>深入理解计算机系统 015-Exceptional Control Flow, Exception and Processes</div>
      <div>http://example.com/2025/10/12/15213-015/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月12日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/12/15213-016/" title="深入理解计算机系统 016-Exceptional Control Flow, Signals and Nonlocal Jumps">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">深入理解计算机系统 016-Exceptional Control Flow, Signals and Nonlocal Jumps</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/12/15213-014/" title="深入理解计算机系统 014-Linking">
                        <span class="hidden-mobile">深入理解计算机系统 014-Linking</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
