

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="发言人   00:00Good afternoon, everyone. So I apologize if I’m going to sit mostly through this lecture, I managed to do something to my knee yesterday. I’m having trouble moving around very much. But tod">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解计算机系统 017-System-Level I&#x2F;O">
<meta property="og:url" content="http://example.com/2025/10/12/15213-017/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="发言人   00:00Good afternoon, everyone. So I apologize if I’m going to sit mostly through this lecture, I managed to do something to my knee yesterday. I’m having trouble moving around very much. But tod">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-12T02:00:16.000Z">
<meta property="article:modified_time" content="2025-10-25T05:03:39.707Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>深入理解计算机系统 017-System-Level I/O - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="深入理解计算机系统 017-System-Level I/O"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-12 10:00" pubdate>
          2025年10月12日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          15k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          126 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">深入理解计算机系统 017-System-Level I/O</h1>
            
            
              <div class="markdown-body">
                
                <p>发言人   00:00<br>Good afternoon, everyone. So I apologize if I’m going to sit mostly through this lecture, I managed to do something to my knee yesterday. I’m having trouble moving around very much. But today what we’re going to talk about is input, output, what it looks like from the programmer’s perspective.<br>大家下午好。所以我很抱歉，如果我要大部分时间都坐在这堂课里，我昨天设法对我的膝盖做了点什么。我在移动方面遇到了很多困难。但今天我们要讨论的是输入输出，从程序员的角度来看它是什么样子的。</p>
<p>发言人   00:24<br>And this is, you’ve already learned sort of a lot of the standard Unix libraries for like printf and scanf and those routines. And we’ll talk about them a little. But what we’ll first talk about is actually lower level IO stuff that is directly interfacing to the operating system. And this is what you’re going to need to learn about partly some of this material you’re going to need for the next lab that comes out at midnight tonight, the shell lab. And you’ll need to also, you’ll be revisiting this several other labs along the course, including the final lab, the web proxy web.<br>也就是说，你已经学习了很多标准的Unix库，比如printf和scanf以及那些例程。我们会稍微谈论一下它们。但我们首先要讨论的是直接与操作系统接口的较低级别的IO内容。这就是你需要了解的部分材料，你将需要为今晚午夜即将到来的下一个实验室 – 贝壳实验室而学习。你还需要在课程中重新审视其他几个实验室，包括最终的实验室，web代理web。</p>
<p>发言人   01:07<br>So this is sort of where we’re really digging down deeply into this type of programming you do if you’re writing system software, things that are very just barely above the operating system level.<br>所以这就是我们真正深入挖掘这种编程类型的地方，如果你正在编写系统软件，那些几乎只是在操作系统层面上的东西。</p>
<p>发言人   01:24<br>And I know for myself, learning this material, I actually learned this material from 213. My co-author, Dave o’halleran, is the one who knew this stuff already. He wrote that part of the book I learned by reading the book just like you are, but I found it actually very useful to know a variety of different other situations I’ve been in. In the meantime, this is quite a few years ago, and so I think it’s worth understanding. And I’ll also mention this kind of material usually is taught. You don’t really see it covered in most books except for ones that are really oriented toward system programmers and are fairly arcane, or you try and learn it by reading man pages. And that’s a fairly cryptic way to try and understand sort of a set of abstractions provided by an API. So I hope you’ll find this useful.<br>我自己知道，学习这个材料，我实际上是从213学的。我的合著者，戴夫·奥哈利兰，是已经知道这些东西的人。他写了那本书的一部分，我是像你一样通过阅读这本书学到的，但我发现它实际上对于了解我所经历过的各种其他情况非常有用。与此同时，这是几年前的事情了，所以我认为值得理解。我还会提到这种材料通常是教授的。除了那些真正面向系统程序员并且相当神秘的书籍，或者你尝试通过阅读手册页来学习它，你实际上并没有在大多数书中看到它。这是一种相当神秘的方式，试图理解由API提供的一组抽象。所以我希望你会发现这很有用。</p>
<p>发言人   02:22<br>So what we’ll talk about then is what I mentioned, this low level of IO that is supported by Unix and other related operating systems, and then a package called Rio, which stands for robust IO. And you will actually not be using this package until the last lab for the course, the proxy lab, at which time you’ll use it a lot. But it’s worth looking at partly in the book. It’s well documented in the book. And if you really want to understand how software works or a system works, the best thing you can do is if if there’s good quality source code to look at and study, you can learn a lot from doing that. And I really recommend for that chapter in the book that you go ahead and study all of the code that makes up Rio. It’s not a huge amount, and just get an appreciation for the subtleties involved and how you deal with errors, how you deal with exceptional conditions and things like that.<br>所以我们接下来要讨论的是我之前提到的，这个低级别的IO被Unix和其他相关操作系统支持，然后是一个叫做Rio的包，它代表健壮的IO。实际上，您将不会使用此软件包，直到课程的最后一个实验，即代理实验室，此时您将经常使用它。但这部分内容值得在书中探讨。这在这本书中有很好的记录。如果你真的想了解软件或系统的工作原理，你能做的最好的事情是，如果有高质量的源代码可以查看和学习，你可以从中学到很多东西。我真的建议你在书中那一章，继续学习构成Rio的所有代码。这不是一个巨大的数目，只要了解其中的微妙之处，以及如何处理错误，如何处理特殊情况之类的事情就可以了。</p>
<p>发言人   03:26<br>And then we’ll talk some about how files are represented, the sort of various data structures behind files, how they support standard IO and IO redirection in Unix. And we’ll also talk about the so called buffered IO, the IO that you’re more familiar with, and C when you use printf and scan of. So Unix actually has a much simpler and more unified view of IO than any other operating system.<br>然后我们将讨论文件如何表示，文件背后的各种数据结构，它们如何支持Unix中的标准IO和IO重定向。我们还将讨论所谓的缓冲IO，即您更熟悉的IO，以及当您使用printf和scan时的C。因此，与任何其他操作系统相比，Unix实际上拥有更简单、更统一的IO视图。</p>
<p>发言人   03:56<br>And it’s one of the nice design features of it that a lot of abstractions are built into the notion of a file. And a file is really just a sequence of bytes. And in Unix does not distinguish between different classes of files, unlike, say Windows or earlier versions of the Macintosh operating system. It just thanks to them as bytes. And the operating system level has essentially no understanding of a more detailed structure inside of a file. And one of the things it does is a file is normally originally thought of as something that’s stored on, say, a disk drive or some other external storage device, and that you open, you read it or write it, you close it, those sort of standard operations. But Unix also use the notion of a file to represent many other different things, including, for example, the devices that are the IO devices that are connected to a particular machine. The Tty stands for teletype, which is antique terminology for how people used to actually interface typewriters to computers.<br>这是它的一个很好的设计特点，它在文件的概念中内置了许多抽象。一个文件实际上只是一个字节序列。并且在Unix中并不区分不同类的文件，这与Windows或早期版本的Macintosh操作系统不同。这只是感谢他们作为字节。操作系统层面基本上不了解文件内部更详细的结构。它的作用之一是文件最初通常被认为是存储在磁盘驱动器或其他外部存储设备上的东西，你打开它，读或写，关闭它，这些标准操作。但是Unix也使用文件的概念来表示许多其他不同的事物，例如包括连接到特定机器的IO设备。Tty代表电传打字机，这是一种古老的术语，指的是人们如何将打字机与计算机实际接口。</p>
<p>发言人   05:15<br>The other thing that are viewed as like files are the network connections that are known as sockets. And when you do communication over the internet, you do it by, you send a message by writing to a socket, and you accept incoming communication by reading from Osaka. And so the same low level API is the same whether you’re reading or writing files on your disk drive or sending packets over the internet.<br>另一个被视为文件的东西是被称为套接字的网络连接。当你通过互联网进行通信时，你通过写入套接字发送消息，然后通过阅读大阪接收传入的通信。因此，无论您是在磁盘驱动器上读取或写入文件还是通过internet发送数据包，相同的低级API都是相同的。</p>
<p>发言人   05:55<br>So the core operations then associated with files, of course, are opening and closing them and reading and writing them.<br>因此，与文件相关的核心操作当然是打开和关闭它们，以及读取和写入它们。</p>
<p>发言人   06:03<br>The other sort of attribute that’s associated with most, but not all files is what’s called the file position. So again, if you imagine when you’re reading from a file, you don’t want to always start at the beginning. Every time you do a read, you read some data, and then you read some more data. And so that’s attracted by a file position, which is just a counter that says how many bytes have been read from this file so far so that I know where to go. And you can actually even alter that value with a various classes operation called seeking, which is just a way of changing the file pointer position pointer. Now, that doesn’t work too well if your input is a terminal where you move, you can’t sort of back up, have recover data that was presented to it earlier, or jump ahead and start accepting data that hasn’t been typed yet. So there’s some kinds of files have a file position and seeking and others don’t.<br>与大多数 (但不是所有) 文件相关联的另一种属性是所谓的文件位置。所以，如果你想象当你从一个文件读取时，你不想总是从开头开始。每次读取数据时，您都会读取一些数据，然后再读取一些数据。所以这被一个文件位置吸引，这个位置只是一个计数器，表示到目前为止已经从这个文件中读取了多少字节，这样我就知道该去哪里了。实际上，您甚至可以使用称为查找的各种类操作来更改该值，这只是更改文件指针位置指针的一种方式。现在，如果您的输入是一个移动的终端，您无法进行备份，无法恢复之前呈现给它的数据，或者向前跳并开始接受尚未输入的数据，那么这种方式就不太有效了。因此，有些类型的文件有文件位置和查找，而其他类型的则没有。</p>
<p>发言人   07:07<br>Similarly to a network socket, you can’t jump a socket forward in time. You can only read or write the particular packets as they come in. But in general, think of it then as the file position as part of the data associated with an open file. That tells me how far along in this file have I read or written.<br>与网络套接字类似，您不能在时间上向前跳套接字。您只能在特定的数据包进入时读取或写入它们。但通常情况下，将其视为文件位置，作为与打开的文件相关联的数据的一部分。这告诉我在这个文件中我读或写了多远。</p>
<p>发言人   07:35<br>And then again, the files, because there’s all these different things, are sort of unified in this file abstraction. But obviously, there’s differences and different attributes to them. And so there’s sort of many different categories, Ingos and subcategories. But the ones we’ll think about are a regular files.<br>然后，由于有所有这些不同的东西，这些文件在这个文件抽象中是统一的。但显然，它们有不同之处和不同的属性。因此，有许多不同的品类、Ingos和子类别。但我们将考虑的是常规文件。</p>
<p>发言人   07:54<br>Just think of things that are on a disk drive. Directories, which is a directory, is considered a type of file, meaning the data that’s in there is just as a file. But of course, it’s a special kind of file and that it actually does have an interpretation that entries in that file describe the locations and attributes of other files. And then, as I mentioned, the term socket is a connection to a network. And it’s both for sending and for receiving messages over the network.<br>想想磁盘驱动器上的东西。目录是一个目录，被认为是一种文件类型，意味着其中的数据只是一个文件。当然，它是一种特殊的文件，实际上它有一个解释，即该文件中的条目描述了其他文件的位置和属性。然后，正如我所提到的，术语套接字是与网络的连接。它既可以通过网络发送消息，也可以通过网络接收消息。</p>
<p>发言人   08:29<br>There’s other files that we won’t really talk about. For example, when you pipe, when you from one application to another, that’s both the output of the first program and the input of the second are special types of files called pipes. And they’re handled by writing is putting something into the pipe. And reading is to take something out of that pipe, something called a symbolic link, which is just a way that you can have multiple names for a file. And pointers to a file aren’t really. Without having to make separate copies of a file. And then other special types of devices. So we won’t really will only consider the first three types of files. In fact, for today, mostly the first two.<br>还有其他文件我们不会真正谈论。例如，当您使用管道时，当您从一个应用程序到另一个应用程序时，第一个程序的输出和第二个程序的输入都是称为管道的特殊文件类型。他们通过写作来处理，就是把东西放进管道里。而读取就是从管道中取出一些东西，这叫做符号链接，这只是一种可以为一个文件使用多个名称的方式。指向文件的指针并不是真的。不需要制作单独的文件副本。然后是其他特殊类型的设备。所以我们不会真的只考虑前三种文件类型。实际上，就今天而言，主要是前两个。</p>
<p>发言人   09:33<br>So the idea of a file then is it just contains arbitrary data And the operating system really, for regular file, doesn’t try to get into the details of what’s inside that file.<br>所以文件的概念就是它只包含任意数据，操作系统实际上对于常规文件，不会试图深入了解文件内部的细节。</p>
<p>发言人   09:45<br>And there’s some class of applications that will distinguish between a text file and a binary file, not really at the operating system level, but more at higher levels. And the main difference with that is it a text file should only have the standard characters of Ascii, or another class would be various encodings that allow you to do encodings of non-singing, withish alphabets. And binary files would be things like an image or actual object code, or a video or audio file or something that within that code, there’s a sequence of bytes that are encoding numbers in some form direct weight.<br>有一些应用程序可以区分文本文件和二进制文件，不是在操作系统级别，而是在更高的级别上。它的主要区别在于，文本文件应该只具有标准的Ascii字符，否则另一个类将是各种编码，允许您使用字母对非唱歌进行编码。而二进制文件可能是图像或实际目标代码，或者视频或音频文件之类的东西，在代码中，有一个字节序列以某种形式直接编码。</p>
<p>发言人   10:40<br>And then the main thing about a text file is that there’s certain functions that distinguish a new line character, meaning the end of it line of text. And you already learned about that character. It’s got the code a 0 a as a byte code. And that became one of the forbidden codes of your texts because it would be interpreted as a new line by the function gettas. Just to mention that. And this is one place when you’re transferring files between, say, a Windows machine and a Linux or a Mac, one of the things, if it’s a text file that has to be changed is that two classes of systems have different ways of interpreting, of encoding.<br>然后文本文件的主要功能是区分新行字符的特定功能，即文本行的末尾。你已经了解了这个角色。它以字节码的形式获得了0 a的代码。这就成为了你的文本中被禁止的代码之一，因为它会被函数gettas解释为一行新行。只是提一下。这是在Windows机器和Linux或Mac之间传输文件时的一个地方，如果它是一个必须更改的文本文件，那么两类系统有不同的解释和编码方式。</p>
<p>发言人   11:27<br>When is the end of the line? And in a Linux or Mac file, it’s just this character code A, which stands for line feed, whereas the Windows files finish with a two character end of line carriage, return in line feed.<br>什么时候是终点？在Linux或Mac文件中，它只是这个字符代码a，代表换行，而Windows文件以两个字符的行回车结束，换行。</p>
<p>发言人   11:47<br>And I show you this picture of an object that you’ve probably only seen in museums, but it’s a typewriter. And just to tell you what the heck is a carriage return and what’s the line feed? I thought you might like to, in case you’ve never actually used an old fashioned a typewriter, basically at the end of it, on the left hand side of a typewriter is this bar. And when you start typing along. This roller with your page on it, chin so long and it comes to the end. And then you want to get back to the beginning of the next line. So you want to both do the carriage return, which is this thing, shove it to the right, and you want to do a line feed.<br>我给你看一张你可能只在博物馆里见过的物体的照片，但它是一台打字机。只是为了告诉你什么是回车，什么是换行？我想你可能会喜欢，万一你从来没有真正使用过老式打字机，基本上在它的最后，在打字机的左手边是这个栏。当你开始打字的时候。这个滚轮上有你的页面，下巴那么长，它就结束了。然后你想回到下一行的开头。所以你想做回车，也就是这个东西，把它推到右边，然后你想做换行。</p>
<p>发言人   12:36<br>You want the roller on it to go down to the next line. So there’s a knob here that you can twist by hand. But in general, what you do is you type along, and then you go slam like that. And this lever both pushes the thing back and it rotates the roller by one lines worth. And so carriage return line feed is where that actually comes from.<br>你想让上面的滚轮向下走到下一行。这里有一个旋钮，您可以用手扭转它。但总的来说，你所做的是打字，然后你就会像那样猛烈地猛击。这个杠杆既把东西推回去，又把滚子旋转一行。所以回车换行是实际的来源。</p>
<p>发言人   13:04<br>Casey Wonder. And then a directory, as I mentioned, it’s stored as a file, but it’s a file that the operating system, at least the file system part of the operating system, actually interprets in very specific ways. And as you know, within every directory, there’s two special files, dot and dot, dot referring to the local file. And it’s parent in the tree structure.<br>凯西想知道。然后是一个目录，正如我提到的，它被存储为一个文件，但它是操作系统，至少是操作系统的文件系统部分，实际上以非常具体的方式解释的一个文件。正如你所知，在每个目录中，有两个特殊的文件，点 (dot) 和点 (dot) 引用本地文件。它在树结构中是父级。</p>
<p>发言人   13:38<br>Systems, systems that I know of. There’s a sort of hierarchical organization to the files. We’re not going to talk much about files systems, but there’s a hierarchical organization. And that’s maintained as a series of files, each being the directory. And the directory then is a pointer to it, subdirector, which again, are files.<br>系统，我所知道的系统。文件有一种等级组织。我们不会过多谈论文件系统，但它是一种分层组织。这被维护为一系列文件，每个文件都是目录。然后，目录是指向它的指针，即子目录，也就是文件。</p>
<p>发言人   14:02<br>And so what’s referred to in Unix terminology, in most other operating systems, what’s known as a path name is a way to navigate through this hierarchy of files and identify one particular one. And so that comes to say that the low level Unix operations that use to implement this are to open a file, to read it and write it, and to close it. And those, literally, those are the names of the functions. So the open function, then you give a path name.<br>因此，在Unix术语中提到的东西，在大多数其他操作系统中，所谓的路径名是一种在文件的层次结构中导航并识别一个特定文件的方法。因此，用于实现这一点的低级Unix操作是打开一个文件，读取和写入它，以及关闭它。而这些，字面上，就是这些功能的名称。所以打开函数，然后你给出一个路径名。</p>
<p>发言人   14:39<br>And remember, path names can be absolute, meaning that they start with a slash. They go all the way down the hierarchy. They can be relative to a particular, whatever your current directory is where, and they can also be relative to a user if you use the tilt slash or t it, then that’s of a. Shortcut in this path name to get to particular users. So a path name can be any of those forms.<br>记住，路径名可以是绝对的，这意味着它们以斜杠开头。它们沿着层次结构一路向下。它们可以相对于特定的，无论您当前的目录在哪里，如果您使用倾斜斜杠或t，它们也可以相对于用户，那么这就是a。在此路径名中获取特定用户的快捷方式。因此，路径名可以是这些形式中的任何一种。</p>
<p>发言人   15:12<br>When you open it, it just has to be some way that J, so I you specify in other places that you tell where this particular file is you’re trying to open. And so it’s given a path name, and then it’s given an integer code that says, what do you want to do when you open this file? In what form do you want to open it? And that’s specified by a series of constants that are already predefined when you include the proper files. And those actually get bitwise, each of those is a 1 b flag in a some power of two position, or it’s a position 1 b in a field somewhere. And so you can logically, or those together, if you want multiple combinations, for example, I can say read only, I can say read and write, I can say append, meaning if I’m opening it to write, don’t begin it, don’t start writing at the beginning, start writing it wherever the end of the file is now. So all those can be done, And this is described in the book by using the right set of names of constants and oring them together, and that will return something that’s called a file descriptor, and that’s a very important idea that, and one of the reasons why we’re talking about this today, this is going to be very important in your lab.<br>当你打开它时，它必须以某种方式J，所以你在其他地方指定你想要打开这个特定文件的位置。因此给它一个路径名，然后给它一个整数代码，说明打开此文件时你想做什么？您想以什么形式打开它？这由一系列常量指定，这些常量在包含适当的文件时已经预定义。而这些实际上是按位计算的，每个都是在2的幂的某个位置上的1 b标志，或者在某个字段的某个位置上是1 b。因此，如果您想要多个组合，则可以逻辑上或一起使用，例如，我可以说只读，我可以说读写，我可以说附加，这意味着如果我正在打开它以进行写入，不要开始它，不要在开始时开始写入，现在，无论文件末尾在哪里，都可以开始写入。所以所有这些都可以完成，这在书中描述了通过使用正确的常量名称集并将它们组合在一起，这将返回一个称为文件描述符的东西，这是一个非常重要的想法，我们今天谈论这个的原因之一，这对你的实验室将非常重要。</p>
<p>发言人   16:43<br>It’s the notion of a file descriptor, which is just a small integer that lists which particular one of the open files that’s being used by this particular program are you referring to, and so it’s a small number because these are assigned sequentially when you begin your program and you run and you’re in fact, limited on most machines to some bounded number of open files you’re allowed to have at any time, in fact, if you go to. Let’s see if you’re on a machine and you type in limits limit.<br>这是文件描述符的概念，它只是一个小整数，列出了这个特定程序正在使用的打开的文件中的哪个特定文件，所以这是一个很小的数字，因为当你开始程序并运行时，这些是按顺序分配的，实际上，在大多数机器上，打开的文件数量有限，你可以随时拥有，事实上，如果你去的话。让我们看看你是否在一台机器上，并且你输入了限制限制。</p>
<p>发言人   17:31<br>You’ll see there that entry called descriptors 1024. It says that you can’t have more than 1024 files open at any given time. And in fact, if you’ve got 1024 files open, it’s a chance you’re doing something really seriously wrong, meaning that you haven’t been closing the files you should be closing.<br>你会在那里看到一个名为描述符1024的条目。它说在任何给定时间打开的文件不能超过1024个。实际上，如果您打开了1024个文件，则很有可能您正在做一些非常严重的错误，这意味着您还没有关闭应该关闭的文件。</p>
<p>发言人   18:01<br>And all of the system calls encoding these always have a return code. And the return codes vary. Sometimes a negative number is an error, sometimes 0 is an error. They’re all different and all confusing and all inscrutable. So you have to look at the documentation for every single one of those functions.<br>并且所有编码这些的系统调用总是有返回码。并且返回代码各不相同。有时负数是错误，有时0是错误。它们都是不同的，都是令人困惑的，都是不可思议的。所以你必须查看每个函数的文档。</p>
<p>发言人   18:23<br>And one of the rules we’re going to hammer away at in this course is every time you make a system call, you should check the return code to see if there’s an error and then do some appropriate way of handling the error. That’s just a practice. It’s a pain in the butt. It makes your code look like a rat’s nest of conditionals. You really would rather not, because often there’s an error deciding what you’re going to do when there’s an error is harder than just ignoring it all together. And so there’s a lot of code out there where people just cross their fingers and hope there’s never errors in their system calls. But we’re going to really push on you hard to say every time you make a system call, check the return code and do something if it’s not right.<br>在这门课程中，我们要锤炼的规则之一是，每次进行系统调用时，都应该检查返回代码以查看是否有错误，然后采取适当的方法来处理错误。那只是一种实践。这是屁股上的痛。它使您的代码看起来像老鼠的条件嵌套。你真的不愿意，因为通常有一个错误决定当出现错误时你要做什么，比仅仅忽略所有错误更困难。因此，有很多代码，人们只是交叉手指，希望他们的系统调用中永远不会出现错误。但是我们要真正地推动你，很难说每次你进行系统调用时，检查返回代码并做一些不正确的事情。</p>
<p>发言人   19:10<br>And so the oppen will return a number, it’s an int that it returns. But if it’s a negative number, that means it couldn’t open the file. For example, the file doesn’t exist, or you’re trying to open it in a mode that you’re not authorized to open it in. So there’s three particular file descriptors associated with every single process that runs. One is standard input, the other is standard output, and the third is standard error. And they always have file descriptor numbers 0, 1, and 2, and. So that you shouldn’t really refer to them by their file descriptor numbers, even though you actually can reliably depend on those values.<br>因此oppen将返回一个数字，它返回的是一个int。但如果它是一个负数，这意味着它无法打开该文件。例如，文件不存在，或者您尝试以一种您无权打开它的模式打开它。因此，每个运行的进程都有三个特定的文件描述符。一个是标准输入，另一个是标准输出，第三个是标准误差。它们总是有文件描述符编号0、1、2和。这样你就不应该通过它们的文件描述符编号来引用它们，即使你实际上可以可靠地依赖于这些值。</p>
<p>发言人   20:04<br>Similarly, if you want to close the file, well, so open, you see you give a path name, a 1 b, a 1 integer field that gives these flags that say something about the modes in which you want to open it. To close the file, you just say close, and you give the file descriptor number, not the name of the file, and it returns a return code too.<br>同样，如果你想关闭文件，那么打开，你可以给出一个路径名，一个1 b，一个1整数字段，给出这些标志，说明你想要打开它的模式。要关闭文件，只需说关闭，并提供文件描述符编号，而不是文件名，它也会返回一个返回代码。</p>
<p>发言人   20:27<br>So you might say, now why in the world could you ever get an error closing a file if it’s open? And the answer is that actually it can happen. In particular, we’ll see when we have multithreaded programs where it’s possible to have two, essentially two programs running at the same time, sharing their data structures, interacting with each other, sharing their memory. It’s a very important kind of programming and one that you can really make bad mistake. And one of the bad, horrible mistakes is if you try to close a file that’s already been closed, it’ll be an error. And that can happen if there’s two different parts of your program running and each of them tries to close the file.<br>所以你可能会说，为什么在这个世界上，如果一个打开的文件被关闭，你会得到一个错误呢？答案是，这实际上是可能发生的。特别是，当我们有多线程程序时，我们将会看到两个基本上同时运行的程序，共享它们的数据结构，相互交互，共享它们的内存。这是一种非常重要的编程方式，你可能会犯一些严重的错误。其中一个糟糕而可怕的错误是，如果你试图关闭一个已经关闭的文件，那将是一个错误。如果您的程序有两个不同的部分正在运行，并且每个部分都试图关闭文件，则可能会发生这种情况。</p>
<p>发言人   21:16<br>So in the book and in this code, you’ll see we introduced some error handling routines, one of which is called P error. And all it does is print some whatever message you want to print, and then it exits the program. Or no, I guess it doesn’t. I’ll mention in a little while, it just prints an error message. But the point is, even something as mundane as closing a file, you should be checking the return code.<br>所以在这本书和这段代码中，你会看到我们介绍了一些错误处理例程，其中一个称为P错误。它所做的就是打印你想打印的任何消息，然后退出程序。或者不，我想它不会。我一会儿会提到，它只是打印一条错误消息。但关键是，即使是像关闭文件这样平凡的事情，你也应该检查返回代码。</p>
<p>发言人   21:53<br>Okay, so this is the function that reads at this low level is called read, and it’s given a file descriptor. You’ve provided a pointer to a buffer that you’ve had to allocate either statically or VM malloc. And you also specify how long that buffer is so that it can’t overflow that buffer.<br>好的，这个函数读取这个低级别被称为读取，它被赋予一个文件描述符。你提供了一个指向你必须静态分配或VM malloc分配的缓冲区的指针。并且您还指定了缓冲区的长度，以使其不会溢出该缓冲区。</p>
<p>发言人   22:18<br>And read just means read as many bytes as you feel like, but no more than the number I tell you to, which sounds like a weird statement. What do you mean what you feel like? Well, it has to be at least 1 B. So if, for example, it’s a standard input, it will hang there and wait until actually with standard input, it will wait until you’ve typed in a string and hit the return, and it will then read at least some fraction of that into the program. If it’s a network connection, again, the read will just wait. It will hang until something arrives on that particular network connection and then read in some number of bytes that have been sent to it.<br>而读只是意味着读尽可能多的字节，但不超过我告诉你的数字，这听起来像是一个奇怪的陈述。你的意思是你的感觉是什么？嗯，它必须至少为1 B。因此，例如，如果它是标准输入，它将挂在那里并等待直到实际使用标准输入，它将等待直到您键入字符串并点击返回，然后它将至少部分读入程序。如果是网络连接，读取将再次等待。它会挂起，直到某个特定的网络连接上有东西到达，然后读入已经发送给它的一些字节。</p>
<p>发言人   23:14<br>And I’m being vague by saying some number because the truth is there’s no guarantee it will read any fixed number of bytes. It’ll read at least one and it won’t read any more then that buffer is. But the number between that might be variable. And so when it reads less than the number of maximum number of bytes you specify, that’s called a short read. And that canon does happen, and you have to write your code expecting it. And we’ll talk about that a little bit.<br>我说一些数字是含糊不清的，因为事实是，不能保证它会读取任何固定数量的字节。它将读取至少一个，并且不会再读取该缓冲区。但这之间的数字可能是可变的。当读取的字节数少于您指定的最大字节数时，这被称为短读取。而且这个标准确实会发生，你必须编写你的代码来期望它。我们会稍微谈论一下这个问题。</p>
<p>发言人   23:51<br>And so again, n by read returns a signed number actually of data type S size t, like SSI z e underscore t, which is typically a long int, so potentially negative number. That number is, if it’s zero, it means that it’s hit, it’s detected an end of file that you’ve run to the end of the stored file, that the network connection has been closed, or something has happened. If it’s positive, then that’s the number of bytes that were read. And if it’s negative, it’s an error code.<br>因此，n by read返回一个数据类型为S大小t的有符号数字，就像SSI z e下划线t一样，它通常是一个长整型的整数，因此可能是负数。这个数字是，如果它是零，这意味着它被命中了，它检测到你已经运行到存储文件的末尾的文件结尾，网络连接已经关闭，或者发生了什么事情。如果是正数，那么这就是读取的字节数。如果是负数，则是错误代码。</p>
<p>发言人   24:40<br>So as I mentioned, if it reads fewer than the number of bytes you specify, that’s referred to as a short count. And I’ll talk about why that would occur.<br>所以正如我所提到的，如果它读取的字节数少于您指定的字节数，这被称为短计数。我会谈谈为什么会发生这种情况。</p>
<p>发言人   24:50<br>Writing is sort of the same idea, that you provide a file descriptor. You provide a buffer where the data that you want to write out is stored, and you give how many bytes long do you want your right to be? And it will write some number of bytes to the output, at least one and no more than n bytes. But it might not be all of them, which is kind of weird.<br>编写是一种相同的思想，你提供一个文件描述符。您提供了一个缓冲区，用于存储要写入的数据，并且您提供了您想要的长度为多少字节？并且它会向输出写入一定数量的字节，至少一个但不超过n个字节。但这可能不是全部，这有点奇怪。</p>
<p>发言人   25:17<br>I want to write this. I want to send it to a file, I want to send it over the internet, but it can potentially not send them all. And we’ll talk about that a little bit. So again, that’s called a short write. And similarly, it will return the number of bytes that were written. And so if it’s less than 0, that’s an error code.<br>我想写这个。我想将它发送到一个文件，我想通过互联网发送，但它可能无法将它们全部发送。我们会稍微谈论一下这个问题。所以再说一遍，这被称为短写。同样，它将返回写入的字节数。因此，如果它小于0，那就是一个错误代码。</p>
<p>发言人   25:46<br>So just to give you a really simple example of this in action, this code does what you call echoing, meaning that you type in something and it will print it out. And it does it in the most mundane way possible by reading, specifying a single byte reads and single byte writes.<br>所以只是为了给你一个非常简单的例子，这段代码做你所说的回声，意味着你输入一些东西，它会打印出来。它以最平凡的方式进行读取，指定单字节读取和单字节写入。</p>
<p>发言人   26:05<br>So you remember I told you read will read at least 1 B, but no more than the number you’ve told it. So when you give it one, it means it will read exactly 1 B. And similarly with write, if you say write 1 B, that’s guaranteed to happen. And so this is really, really bad code in the sense that call to read or to write the system level call is a relatively expensive call, kicking your whole up to the operating system, doing what’s called a context switch, meaning it will go into the kernel of the system, invoke operating system functions, do whatever the reader right tells it to do, come back out, switch back to your job, and that will typically take maybe 20000 to 40000 clock cycles, which a clock cycle nowadays is less than a nanoseconds.<br>所以你记得我告诉过你阅读至少会读1 B，但不会超过你所说的数字。所以当你给它一个时，这意味着它将读取正好1 B。与write类似，如果你说write 1 b，那肯定会发生。因此，这是感知中非常糟糕的代码，调用来读取或写入系统级调用是一个相对昂贵的调用，将整个操作系统踢给你，执行所谓的上下文切换，这意味着它将进入系统内核，调用操作系统函数，执行阅读器正确指示的任何操作，返回，切换回您的工作，这通常需要20000到40000个时钟周期，现在的时钟周期不到1纳秒。</p>
<p>发言人   27:06<br>You say, yeah, you’re talking maybe 10 microseconds, what’s the big deal there, but that’ll add up if you start sending long files out over millions of bytes. If you start sending them one bite at a time, you’ll spend most of that time sitting in the operating system going crazy. So this is not a good idea, but it does work, and that’s actually an easy mistake you can make as a programmer is to use this low level writing and reading and the program will function find it’s just, it will be really, really slow.<br>你说，是的，你说的可能是10微秒，有什么大不了的，但如果你开始发送超过数百万字节的长文件，那就算了。如果你开始一次只发送一口，你会把大部分时间花在疯狂地坐在操作系统中。所以这不是一个好主意，但它确实起作用，实际上作为一名程序员，你可以犯一个容易的错误，就是使用这种低级的写和读，程序会发现它只是，它会非常非常慢。</p>
<p>发言人   27:49<br>But just to give you a demo of this idea of. Calls to the operating system. It’s a pretty cool.<br>但只是为了给你一个这个想法的演示。对操作系统的调用。这相当酷。</p>
<p>发言人   28:05<br>So this program, and this is on the web, linked off the web page, the code for this lecture. So this one called CPA standard in meaning copy standard input is just the code I showed you. And so if you type something, it will just echo it back. So it’s reading. So it looks to you and to me. Like it? Reading online of text and then echoing it back. But what it’s actually doing is, again, the interface to the terminal is one that it doesn’t actually wake up this code until it gets a complete line, but it’s actually just printing these characters back one character at a time. And I can demo that, but there’s a pretty interesting.<br>所以这个程序，它是在网络上，从网页上链接出来，是本次讲座的代码。所以这个被称为CPA标准的意思是复制标准输入只是我向您展示的代码。所以如果你输入了什么东西，它只会回显它。所以它在阅读。所以在你和我看来。喜欢吗？在网上阅读文本，然后将其回应。但是它实际上做的是，再次强调，终端的接口是直到它获得完整的行，才真正唤醒此代码，但它实际上只是一次打印这些字符，返回一个字符。我可以演示这个，但有一个相当有趣的。</p>
<p>发言人   29:03<br>Facility called tracing S trace. And what S Chase will do if you give it the name of a program is it will detect every system call that you make. Every basically call to the operating system functions that you make when you run a program. And it will generally spew out this huge amount of inscrutable stuff that you don’t really want to see.<br>称为trace S trace的设施。如果你给它一个程序的名字，它会检测你进行的每一个系统调用。基本上，每次运行程序时调用操作系统函数。它通常会喷出大量你并不想看到的难以理解的东西。</p>
<p>发言人   29:31<br>I’ll just show you this. It’s telling you logging every single call, and it’s usually way too much stuff. So the more useful way to do this is to give it an argument that says, I only want to watch some limited class of functions when this is running. And so what? I just want our calls to the right, the low level output, right? And you’ll see that what happens then is this string I typed in turned into a series of 1 B writes calls to the low level of right function. And of course, some way I could show you the reads and writes. Let’s try that.<br>我就给你看这个。它告诉你记录每一个电话，通常是太多的东西。因此，更有用的方法是给它一个论点，说，当它运行时，我只想观察一些有限的函数类。那又怎样？我只想要我们的电话在右边，低电平输出，对吧？然后你会看到发生的事情是，我输入的这个字符串变成了对低级别的right函数的一系列1 B写入调用。当然，我可以通过某种方式向您展示读取和写入操作。让我们试试。</p>
<p>发言人   30:27<br>And it’s all confused because I’m meshing. This comes out on standard air. But on the terminal, it’s sort of interleaving standard air and standard out. So it’s kind of messy to look at. But again, you can see that it’s taking my characters and it’s reading 1 and writing one in this group.<br>这一切都很困惑，因为我正在网格化。这是用标准空气出来的。但在终端上，它有点交错着标准空气和标准输出。所以看起来有点混乱。但是，你可以再次看到，它正在拿我的角色，在这个小组中读一个并写一个。</p>
<p>发言人   30:50<br>So let’s see Ctrl D to get out of it. Back to the code.<br>所以让我们看看Ctrl D来摆脱它。回到代码。</p>
<p>发言人   31:04<br>So what’s this short count business? Why would that occur? Well, there’s a couple ones. As I mentioned, if you encounter an end of file, you’re not going to read in however indie bytes you were given for the buffer, if you were reading text wines from a terminal, the terminal handler will just send a line it’s worth at a time with the new line character terminating it. If you’re reading or writing a network packet the way network packets work, or messages if you have a big long message, it’s broken into smaller chunks. Typically about 1000 B or so.<br>那么，这是什么短期计票业务？为什么会发生这种情况？嗯，有几个。正如我所提到的，如果你遇到了文件结束，你就不会读取缓冲区中给定的独立字节，如果你从终端读取文本葡萄酒，终端处理程序将只发送一行代码，每次用新行字符终止它。如果您正在以网络数据包的工作方式读取或写入网络数据包，或者如果您有很长的消息，则消息会被分成小块。通常约为1000 B左右。</p>
<p>发言人   31:54<br>If you try to read from an end of file it, will you turn 0? Is that a short count? It’s a really short count, yes, but it’s not a negative, yes. So as it says here, if you encounter an indefi, it’ll actually, there’s two things.<br>如果您尝试从文件结尾读取它，您会变成0吗？这是一个简短的计数吗？这是一个非常简短的计数，是的，但它不是负面的，是的。所以正如这里所说，如果你遇到indefi，实际上有两件事。</p>
<p>发言人   32:15<br>Actually, it’s a really good question. If you’re like near the end of a file, you have 100 B left and you say read 200, your first call to read will come back and get 100. It will say 100, and it will get that number. And then you call again the second time, and it will return 0. And so that’s how you actually detect the true end of file as opposed to some other reason you might have gotten a short count is if that you actually get a read of 0. The only case you’ll get that for is an end of file. So that’s a good question, thanks.<br>实际上，这是一个非常好的问题。如果你接近一个文件的末尾，你还剩下100个B，你说读200，你的第一个read调用会回来并得到100。它会说100，它会得到那个数字。然后你第二次再次调用，它将返回0。所以这就是你实际检测文件真正结束的方式，而不是其他一些原因，你可能得到了一个短计数，如果你实际上得到了一个0的读取。你能得到的唯一情况是文件结尾。这是一个好问题，谢谢。</p>
<p>发言人   32:52<br>So again, if over the internet, typically packets are around 1000 B, it’s actually depends on where it’s gone through what layers in the protocols it’s gone through, but 1500 B is actually the standard, what they call a minimum transmission unit. So if you have a big long file, it will come back in blocks like that. And if you’re trying to read into a larger buffer, it will typically come back in chunks question.<br>所以，如果通过互联网传输，数据包通常在1000 b左右，这实际上取决于它经过了协议中的哪些层，但1500 b实际上是标准，他们称之为最小传输单元。所以，如果你有一个大的长文件，它会像那样以块的方式回来。如果你试图读入一个更大的缓冲区，它通常会以块问题的形式回来。</p>
<p>发言人   33:28<br>No, in other words, and again, if you’re writing code, you shouldn’t expect any number. Particularly, it will be depended on the implementation.<br>不，换句话说，如果你正在编写代码，你不应该期望任何数字。特别是，这将取决于实施情况。</p>
<p>发言人   33:45<br>No, because I’m only reading or writing one character at a time, right? So I guess you’re asking, what if I spent a week typing characters in a really long string and hit return? I don’t know if you try it, let me know the answer. But it won’t cause an error. But that part, believe me, they’ve really gone through that code a lot of times and gotten rid of all those lurking buffer over vulnerabilities in the code. But we’ll let you do it.<br>不，因为我一次只读或写一个字符，对吗？我猜你是在问，如果我花了一周的时间在一个非常长的字符串中键入字符并点击return怎么办？我不知道你是否尝试过，让我知道答案。但它不会导致错误。但是那部分，相信我，他们已经真正经历了很多次那个代码，并摆脱了代码中隐藏的漏洞缓冲区。但我们会让你这样做。</p>
<p>发言人   34:18<br>I don’t actually know, but within the you should write your code again, expecting short counts is a possibility. And by the way, that’s one of the headaches of using this low level iOS dealing with short counts. It’s often sort of a nuisance of application level. So you don’t usually package this kind of low level Fio IO into other libraries that you’re calling. It’s only we’re only demonstrating this is the sort of lowest level in the stack.<br>我实际上不知道，但在你应该再次编写你的代码，期望短计数是可能的。顺便说一句，这是使用这种低级别的iOS处理短计数的头痛之一。这通常是应用程序级别的一种麻烦。所以你通常不会将这种低级的Fio IO打包到你正在调用的其他库中。只是我们只是在展示这是堆栈中最底层的那种。</p>
<p>发言人   34:54<br>And writing also can give you a short count. For example, if you’re sending packets over a network, it will only send as many as that packet can hold and then return back to you. And you have to keep pumping them out to send the different packets. And so usually when you write code that uses this goal of oil, you have to anticipate these short counts. So Professor O’hara and wrote a package called Rio. For now, we’ll just talk about what this package is. This is a package that you’re really going to want to use for the final web for the course. And so for right now, it’s more of a high level.<br>写作也可以给你一个简短的计数。例如，如果您通过网络发送数据包，它将只发送该数据包可容纳的尽可能多的数据包，然后返回给您。你必须不断地抽出它们来发送不同的数据包。因此，通常当您编写使用石油目标的代码时，您必须预测这些短计数。奥哈拉教授写了一个叫做Rio的包。现在，我们只讨论这个包是什么。这是一个软件包，你真的想用于课程的最终网页。所以现在更多的是一个高水平。</p>
<p>发言人   35:38<br>Here’s an example of code that uses low level IO and packages up in a way that makes it a little bit more palatable. So Rio provides actually a number of different, two different. Well, actually 3, two different levels of of interface to the file. This file IO, the lowest one is basically just a fairly small wrapper around the.<br>这里有一个代码示例，它使用低级IO并以某种方式打包，使其更加可口。所以Rio实际上提供了许多不同的，两种不同的。嗯，实际上是3，两个不同级别的文件接口。这个文件IO，最低的一个基本上只是一个相当小的包装器。</p>
<p>发言人   36:10<br>Existing the IO, the reads and writes you saw that will handle the short count issue. And so when you say with Rio, if you make a call to the read n function and you say some number of bytes, then that function will not return until it’s read that number of bytes. So better be careful that many bytes are there. If it’s a network socket or a file. Well, because, well, why an error message if it will well, actually hang up? If it’s a network connection waiting to read the bytes or return an error if it hits, and to file what it’s not expecting? And similarly with, right, n is sort of a wrapper around the right function that will deal with just loop until the short counts are taken care of.<br>现有的IO，读取和写入你看到的将处理短计数问题。因此，当您使用Rio时，如果您调用read n函数并说出一定数量的字节，那么该函数将在读取该数量的字节之前不会返回。所以最好小心不要有很多字节。如果它是网络套接字或文件。好吧，因为，好吧，为什么一个错误消息如果它会挂掉呢？如果是网络连接，等待读取字节或在命中时返回错误，并提交不期望的内容？与之类似，对，n是一种围绕着正确函数的包装器，它将处理循环，直到处理短计数。</p>
<p>发言人   37:03<br>And then there’s another class of IO that’s called buffered IO. And this is what you really want to use in practice and what you mostly use with the standard Unix IO functions is that you want to, within the user code, build up a little buffer of bytes that have either been read in, but not yet consumed by the application program, or you accumulate some number of bytes in your program before it’s actually shoved out into the file or out onto the network. And there’s two versions of that. One is a text oriented, wine oriented IO, and the other is just a byte oriented Iowa. So let’s go through what the functions are and actually can look at the code for them.<br>然后还有另一类IO，称为缓冲IO。这就是您在实践中真正想要使用的，而标准Unix IO函数最常用的是，您希望在用户代码中建立一个已经读入但尚未被应用程序消耗的字节缓冲区。或者你在程序中积累了一定数量的字节，然后才将其实际放入文件或网络中。有两个版本。一个是面向文本、面向葡萄酒的IO，另一个只是面向字节的Iowa。让我们浏览一下这些函数是什么，并实际查看它们的代码。</p>
<p>发言人   37:58<br>So as I mentioned, the ones called and write down are just very thin. They have the same general semantics as the read and write, but they deal with the short count issue. So let’s actually take a look at read n, so again, read n is given a file descriptor, a destination buffer. An indication of how many characters, how many bytes it’s supposed to read and it’s supposed to.<br>正如我所提到的，那些被称为写下来的人非常薄。它们具有与读写相同的一般语义，但它们处理短计数问题。所以让我们实际上看一下read n，再次，read n被赋予一个文件描述符，一个目标缓冲区。指示应该读取多少个字符，多少字节以及应该读取。</p>
<p>发言人   38:38<br>It’s supposed to, I guess it will return either a negative number if there’s an error 0 if it’s at an end of file. Or the number of bytes red. So I guess I was a little bit, I should have been more careful.<br>它应该，如果在文件末尾有错误0，我想它会返回一个负数。或红色的字节数。所以我想我有点，我应该更小心。</p>
<p>发言人   38:58<br>If it hits an end of file part way, it will a short count, but that’s the only case. It won’t return a short count. If really it could have read more bytes. So the main loop here you see is it keeps calling read over and over again until it’s happy. One way it can be happy is if it’s read as many bytes as it was supposed to write read in the first place. The other is that if it hits an error code, and you’ll notice that.<br>如果它部分到达文件结尾，它将会短暂计数，但这是唯一的情况。它不会返回短计数。如果真的可以读取更多字节。所以你看到的主循环是它一遍又一遍地调用read，直到它快乐为止。它可以快乐的一种方式是，如果它被读取的字节数与最初应该写入的字节数一样多。另一种情况是，如果它遇到错误代码，你会注意到这一点。</p>
<p>发言人   39:40<br>And there’s some subtlety of tracking which type of error that is. But in general, common cases, it will return the negative number indicating an error. If the number read is 0, then that indicated an end of file. And so what we will return is as many bytes as it’s red. So return the short count. And here it’s just saying OK. I’ve read this number of bytes and increment and decrement the right values. So the point is that we’ll keep looping, keep doing reads until it either gets the number of bytes it should, it hits an error, or it encounters an end of file. And you’ll see it has it’s checking for all these different error conditions for every call it makes.<br>并且有一些微妙的跟踪哪种类型的错误。但通常情况下，它会返回负数，表示错误。如果读取的数字为0，则表示文件结束。所以我们将返回与红色一样多的字节。所以返回短计数。这里只是说好的。我已经读过这个字节数，并递增和递减正确的值。所以关键是我们将继续循环，继续进行读取，直到它要么得到它应该拥有的字节数，要么遇到错误，要么遇到文件结尾。你会看到它正在检查每次调用的所有这些不同的错误条件。</p>
<p>发言人   40:35<br>So this code, by the way, is sort of typical that it looks a little messy when you first look at it. But if you sort of study it, it all makes sense. So now let’s talk about buffered IO and what buffered IO is. And this is a very important concept. So that’s part of the reason we want to show you the code for it.<br>顺便说一下，这段代码有点典型，当你第一次看到它时看起来有点混乱。但是如果你研究它，一切都会变得感知。现在让我们来谈谈缓冲的IO以及什么是缓冲的IO。这是一个非常重要的概念。这就是我们想要向您展示其代码的部分原因。</p>
<p>发言人   41:01<br>So the idea of buffered IO is that there’s a buffer, meaning just a an array of characters, array of bytes that are allocated and associated with this particular file. And the program, if it’s on a read, what it will do is it will fill up this buffer. It will give a read with a much larger number, with a large number basically the size of the actual, how much memory you’ve allocated for this buffer. And the system will fill that up with up to that number of characters.<br>所以buffered IO的想法是有一个缓冲区，这意味着只是一个字符数组，一个分配并与此特定文件相关联的字节数组。如果程序处于读取模式，它将会填满这个缓冲区。它会给出一个更大的数字，基本上是实际大小，你为这个缓冲区分配了多少内存。系统将填充该数量的字符。</p>
<p>发言人   41:41<br>And then when the user program wants to now look at this, get some bytes, it’ll first check, do I already have some in the buffer that haven’t been read yet? And if so I’ll just return those. And if not, then I’ll refill the buffer it instead of every time going to the operating system and asking for one character or small number of characters, the call to the operating system says give me pretty much as many characters as you’ve got up to some limit, and then I’ll just go away and the application program sort of pull these out a couple bytes at a time. But I won’t bug the operating system to do it, I being the Rio function and the way it does it is by just keeping a pointer that indicates what part of the bytes that I’ve already brought in from the operating system call but haven’t been supplied yet to the application program. And so in the sort of larger picture of things, if you imagine you’re walking through a file at any given point in time, this buffer will represent some range in that file where the green is the stuff that’s already been read by the application program. The pink is the stuff that’s been read from the operating system out of the file, but not yet read by the application program.<br>然后当用户程序想要现在查看这个，获取一些字节，它将首先检查，我是否已经有一些尚未读取的缓冲区？如果是这样，我会把它们还回去。如果没有，那么我会重新填充缓冲区，而不是每次去操作系统并要求一个字符或少量字符，对操作系统的调用都会给我几乎尽可能多的字符，达到一定的限制，然后我就走开，应用程序一次取出几个字节。但是我不会让操作系统去做这件事，我是Rio函数，它的实现方式是只保留一个指针，指示我已经从操作系统调用中引入但尚未提供给应用程序的字节的哪一部分。因此，在更大的情况下，如果想象您在任何给定的时间点浏览一个文件，这个缓冲区将代表该文件中的某个范围，其中绿色是应用程序已经读取的内容。粉色是从操作系统读取文件的内容，但尚未被应用程序读取。</p>
<p>发言人   43:19<br>And the way this is implemented, once you think about it, it’s not too hard to do. Is it associated with every file connection? Then? Is a file descriptor a count that tells you how many bytes there are that have not been read yet, a pointer to where this changeover is, and then the actual storage of the buffer itself? The character is allocated the bytes allocated to the buffer itself.<br>而且实施的方式，一旦你考虑过，这并不难做到。它与每个文件连接都有关联吗？那么呢？是一个文件描述符，一个告诉你有多少字节尚未读取的计数，一个指向这个转换位置的指针，然后是缓冲区本身的实际存储？字符被分配给缓冲区本身的字节数。</p>
<p>发言人   44:03<br>And so here’s an example then, of using Rio to do this echo that you first read a line. Reading a line means it will look for and stop at a line feed character and writing it back out. And again, if you do the demo.<br>那么这里有一个例子，使用Rio来做这个回声，你首先读一行。读取一行意味着它将查找并停止在一个换行字符处，然后将其写回来。再一次，如果你做演示。</p>
<p>发言人   44:34<br>Of this code?<br>这个代码的？</p>
<p>发言人   44:53<br>Again, you get, let me just trace writes because it’s a little hard to see. The reads are hard to figure out with.<br>再说一遍，你明白了，让我追踪一下写作，因为它有点难看。阅读很难理解。</p>
<p>发言人   45:07<br>So you’ll see that it. Read the whole line. And now it’s done at the operating system level. It’s written just one chunks worth one call to the operating system’s write function. Instead of bite by bite.<br>所以你会看到它。阅读整行。现在它已经在操作系统级别完成了。它只写入一个块，值一次调用操作系统的write函数。而不是一咬。</p>
<p>发言人   45:41<br>Okay, so again I’m not going to go through all the code, but it’s actually worth your while to do this. And by the way I’ve actually done some applications where I took the Rio code. I wanted to add some features to it, but it’s a very useful starting point to be able to build your own customized routines.<br>好的，所以我不打算遍历所有的代码，但实际上值得你花时间去做这件事。顺便说一下，我实际上已经完成了一些应用程序，其中我使用了Rio代码。我想添加一些功能，但这是一个非常有用的起点，能够构建自己的自定义例程。</p>
<p>发言人   46:02<br>Okay, so let’s talk about some other parts of files. One is that associated with a file is what they call metadata. So the data are the actual contents of the file, the actual bytes inside of that file, but there’s a whole bunch of other stuff that’s associated with the file information about what type of file it is, what protection, read, write, execute protections it has. Some information about the ownership of that file, what type it is. So the times associated with it, when was it created? When was it last accessed, and when was it last modified? So that’s known as a metadata. And every file has that kind of information associated with it.<br>好的，让我们谈谈文件的其他部分。一种是与文件相关联的是他们所谓的元数据。所以数据是文件的实际内容，文件内的实际字节数，但还有很多其他与文件相关的东西，比如文件的类型、保护、读取、写入和执行保护等。有关该文件所有权的一些信息，它是什么类型。与它相关的时间，它是什么时候创建的？它最后一次访问是什么时候，最后一次修改是什么时候？这就是所谓的元数据。每个文件都有与之相关联的信息。</p>
<p>发言人   46:55<br>And you can actually, and it’s in a data structure called a step. Data structure. And you can, if you want to write code that then sort of probes the directory structure of A of a file system, you can make a call to the stat function, and it’s given the path name of the file you want to stat and then a pointer to one of these, that data structures. And then that data structure will get filled in by the information for this particular file. And then you can test various attributes about that file and see basically get the information that’s stored here. And there’s all these nasty compile time constants that you use or macros that you use to. Look at and examine these metadata.<br>实际上，它是在一个称为步骤的数据结构中。数据结构。如果你想编写代码来探测文件系统的目录结构，你可以调用stat函数，并给出你想要stat的文件的路径名，然后指向其中一个，这些数据结构。然后该数据结构将被此特定文件的信息填充。然后，您可以测试有关该文件的各种属性，并查看基本上获取存储在这里的信息。还有所有这些令人讨厌的编译时间常量或您使用的宏。查看和检查这些元数据。</p>
<p>发言人   48:07<br>So here’s an example. I won’t do it, but it’s a function called stat check. It’s in the same directory. And so if you check some file, it will typically say, well, it’s a regular file, and yes, you’re allowed to read it. But now if I call chmod to eliminate set all the protections to zero, it’ll say, no, you can’t read it now. And so again, it’s just making use of this data here. So now this is the part that gets a lot more tricky is how are files, how are all this information about files actually represented by the program’s question? Yes?<br>这里有一个例子。我不会这样做，但它是一个名为stat check的函数。它在同一目录中。因此，如果您检查某个文件，它通常会说，嗯，这是一个普通文件，是的，您可以阅读它。但是现在如果我调用chmod消除将所有保护设置为零，它会说，不，你现在不能读它。所以，它只是在这里利用这些数据。所以现在变得更加棘手的部分是文件是怎样的，程序的问题是如何表示有关文件的所有信息的？是吗？</p>
<p>发言人   49:10<br>I’ll tell you one way you can find out what stat does. If you say man 2 stat, you’ll get more than you want to know. So in general, if you say manstad. It will give a Unix command that you can use to stat the file. So I can say stat. Dot. And it will print out some information about a file, in this case, my local directory, let’s see. I can stat any file here and it will print out some cryptic information about.<br>我会告诉你一种方法，你可以找出stat的作用。如果你说man 2 stat，你会得到比你想知道的更多的东西。一般来说，如果你说曼斯塔德。它将给出一个Unix命令，您可以使用它来统计文件。所以我可以说统计。点。它将打印出有关文件的一些信息，在本例中是我的本地目录，让我们看看。我可以在这里统计任何文件，它会打印出一些神秘的信息。</p>
<p>发言人   50:05<br>It, but if you say man 2, the Unix man pages are divided into different categories and things that are system calls. Unix system library calls are typically in section 2 of the man pages. And so that will return information about it. But the main point of it ist is then a function that you call where you give it a path name and a pointer to a buffer that you want. And it will then fill in the contents of the buffer with the. The information about that particular file and the form that it fills it in is one of these data structure is called a struct step. And that’s pretty typical of a lot of these functions is they have some predefined and if you to get. Information you allocate one of those structs, you pass a pointer to it, and then the library function will fill in the details, does that make sense?<br>但如果你说的是man 2，Unix手册页会被分成不同的品类和系统调用。Unix系统库调用通常在手册页的第2节中。这将返回有关它的信息。但它的主要观点是你调用一个函数，在那里你给它一个路径名和一个你想要的缓冲区的指针。然后，它将使用填充缓冲区的内容。有关该特定文件及其填充表格的信息是这些数据结构之一，称为结构步骤。这就是许多这些函数的典型特征，它们有一些预定义的，如果你想要的话。您分配这些结构之一的信息，传递指向它的指针，然后库函数将填充细节，这是否感知？</p>
<p>发言人   51:26<br>Okay, so now let’s look at some of the internal data structures that the operating system maintains regarding the files associated with the program. And this is a source of really nasty exam problems. I’ll just warn you. So you’re going to want to read this part of the book carefully, study the practice problems, look at the old exams, because I can guarantee you you’re going to get some of these on the final. That’s a promise, and they can be infinitely obscure. So we can torture you with these.<br>好的，现在让我们来看看操作系统维护的与程序相关的文件的一些内部数据结构。这是一个非常讨厌的考试问题的来源。我只是警告你。所以你会想要仔细阅读这本书的这一部分，研究练习题，看看旧的考试，因为我可以向你保证，你会在决赛中得到其中的一些。这是一个承诺，它们可以无限模糊。所以我们可以用这些折磨你。</p>
<p>发言人   52:03<br>So the main point is that associated with any executing process, which you can think of a process is a running program is. Something called the descriptor table. And what that contains is for every open file that you have, it has a pointer to a data structure called an entry in a table that’s maintained by the operating system globally. Which describes each of the open files? Actually, each.<br>所以主要的一点是，与任何执行进程相关联，你可以把一个进程想象成一个正在运行的程序。一个叫做描述符表的东西。并且它所包含的是对于你拥有的每个打开的文件，它都有一个指针，指向一个被称为表中的条目的数据结构，该表由操作系统全局维护。这描述了每个打开的文件？实际上，每个人。</p>
<p>发言人   52:47<br>Every time a file is opened that allocates a record in this open file table. And so as I mentioned, file descriptors 0, 1, and 2 have specific meanings, and the other files are other ones that you’ve opened during the course of your program execution and have not yet closed so. Each of these, then, is a reference to a particular open file, and it gives information about that file. And it also gives the position in the file that currently, as I told you, every time you open a file for a regular file, at least there’s an associated position of where in the file was your last reader, right? Or where would you be your next read or write. And so that’s the file pause.<br>每次打开一个文件时，该文件在此打开的文件表中分配一条记录。正如我所提到的，文件描述符0、1和2具有特定的含义，而其他文件是您在程序执行过程中打开但尚未关闭的其他文件。那么，每一个都是对特定打开文件的引用，它提供了关于该文件的信息。它还给出了文件中的位置，正如我告诉你的那样，每次你打开一个普通文件的文件时，至少有一个与你最后一个读者在文件中的位置相关联的位置，对吧？你的下一次阅读或写作会在哪里。这就是文件暂停。</p>
<p>发言人   53:47<br>And there’s also a reference count, which is used by the operating system to keep track of, because you’ll see it’s possible to have multiple. Processes sharing an entry in this open file table. And it uses this reference count, which is a standard way of keeping track of memory allocation to know it no longer needs that entry when there’s been enough, when the file is no longer accessible, and therefore this entry is not needed. So for every one of your open files that will have an entry in this table. And this table, as I said, is shared across the whole operating system.<br>还有一个引用计数，操作系统使用它来跟踪，因为你会发现可能有多个。进程共享此打开文件表中的条目。它使用此引用计数，这是跟踪内存分配的标准方式，以知道当文件不再可访问时，它不再需要该条目，因此不需要此条目。因此，对于每个打开的文件，都将在此表中有一个条目。正如我所说，这个表在整个操作系统中共享。</p>
<p>发言人   54:36<br>And then associated with every file is called a vnode, which stands for virtual node. And this is where that contains the sort of information about this file. In particular, where is it stored, this information that you can get from Stat and things like that, how big it is and things like that. So that’s for every, every file in the system actually has a V node entry, whether it’s open or closed.<br>然后与每个文件相关联的称为vnode，它代表虚拟节点。这就是包含有关此文件的信息的位置。特别是它存储在哪里，你可以从Stat和类似的东西中获得这些信息，它有多大等等。因此，对于系统中的每个文件，无论是打开的还是关闭的，实际上都有一个V节点条目。</p>
<p>发言人   55:12<br>Now, this can get complicated. So for example, if within a single program you call open twice on the same function, you’ll actually get two different file descriptors and you’ll be able to access that same file and have two different positions in it. And it makes sense if you imagine you’re reading from a file and you. Might want to read from two different positions in that file within the same program? And you can do that. That’s perfectly legal. You just call open twice, and that will keep track of two different positions. So the point is, these file descriptors might be referring to the same file, but they’re actually at different positions within the file.<br>现在，这可能会变得复杂。因此，例如，如果在一个程序中对同一个函数调用open两次，实际上会得到两个不同的文件描述符，您将能够访问同一个文件并在其中具有两个不同的位置。如果你想象你正在从一个文件中阅读，它会让你感到感知。可能想要在同一个程序中从该文件中的两个不同位置读取吗？你可以这样做。这是完全合法的。你只需调用open两次，这将跟踪两个不同的仓位。关键是，这些文件描述符可能指的是同一个文件，但实际上它们在文件中的不同位置。</p>
<p>发言人   56:02<br>And that can happen also if you’ve opened a file for both reading and for writing, and you’re writing ahead, and then reading characters bytes that have already been written, that makes sense. It’s not such a good idea to have two different right file opens that are writing simultaneously. You can mess up the file pretty badly that way, but there’s nothing in the operating system that prevents you from doing that. So it’s not a good idea, but it’s a legal operation.<br>如果您打开了一个文件以进行读取和写入，并且您正在提前写入，然后读取已经写入的字符和字节，这也会发生感知。打开两个同时写入的不同右文件并不是一个好主意。你可以用这种方式把文件弄得很糟糕，但操作系统中没有任何东西阻止你这样做。所以这不是一个好主意，但这是合法的操作。</p>
<p>发言人   56:39<br>So’s the point is you have to distinguish at what level is sharing taking place? And you see that if you have. Two different. Table entries sharing one file. Then what’s different there is that you can be working at different file positions. Similarly, of course, the more common thing is you have two different open files, and they’re referred to different files.<br>所以重点是你必须区分在什么层次上进行共享？如果你有的话，你会发现。两个不同的。表条目共享一个文件。那么不同的是你可以在不同的文件位置工作。同样，当然，更常见的情况是您有两个不同的打开文件，并且它们引用不同的文件。</p>
<p>发言人   57:14<br>But now, and this is where life gets exciting. If you call fork, you remember about fork that it spawns a child, but that child inherits a lot of information from its parent. And one of the things, it inherits it descriptor table. It gets a replica of that descriptor table. And so now both the parent and the child have identical entries in their descriptor table. And so they’re sharing files, but not at the file level, but at the open file table. And what that means is if the parent does a read, it’ll bump along the file position. And if the child now does a read, it will see from this new position.<br>但是现在，这就是生活变得令人兴奋的地方。如果你调用fork，你会记得它产生了一个孩子，但是这个孩子从其父级继承了很多信息。还有一件事，它继承了描述符表。它获取该描述符表的副本。因此，现在父代和子代在其描述符表中具有相同的条目。因此，他们正在共享文件，但不是在文件级别，而是在打开的文件表中。这意味着如果父母进行读取，它会沿着文件位置颠簸。如果孩子现在进行阅读，它将从这个新的位置看到。</p>
<p>发言人   58:03<br>So you can see why the exam problems get really interesting that we’ll keep track of all these different possibilities and they’ll do different things. And so, and then, of course, the parent or the child can start opening and closing their own files as well. And that will get very messy.<br>所以你可以看到为什么考试问题变得非常有趣，我们将跟踪所有这些不同的可能性，它们会做不同的事情。因此，当然，父母或孩子也可以开始打开和关闭自己的文件。这会变得非常混乱。</p>
<p>发言人   58:25<br>And here’s you see the reason for having reference counts here. If you have a lot of forking going on, then you can create multiple pointers to this table entry and. In order to really, really close the file, each of these has to call close before the file is truly, truly closed from an operating system perspective.<br>这里是您看到这里有参考计数的原因。如果您有很多分叉，那么您可以创建多个指向此表条目的指针。为了真正关闭文件，从操作系统的角度来看，每个文件都必须在文件真正关闭之前调用close。</p>
<p>发言人   58:59<br>So there’s other fun things that make life interesting too, and contribute to the exam problem possibilities, what is it called?<br>所以还有其他有趣的事情让生活变得有趣，并有助于考试问题的可能性，它叫什么？</p>
<p>发言人   59:08<br>Called dupe 2. And the purpose of dupe 2 is 2. Me duplicate an entry in the descriptor table. And the most common use of that is IO redirection, either greater or less than sign to either redirect read instead of from standard input from a file, or instead of writing to standard output to write to a file. And the way the operating system actually implements that is shortly after starting the program, it will call dupe 2, 2, make it so that.<br>叫做dupe 2。而dupe 2的目的是2。我复制描述符表中的一个条目。最常见的用途是IO重定向，或者大于或小于符号以重定向读取而不是从文件的标准输入，或者代替写入标准输出以写入文件。操作系统实际实现的方式是在启动程序后不久，它将调用dupe 2，2，使其成为这样。</p>
<p>发言人   59:58<br>File descriptor one is not the standard output of for this process, but it’s actually the original standard output. But it’s actually a descriptor for the file that it’s supposed to write to. And same with if it’s doing input redirection. But you can call Duke two yourself and do these kind of things. And there’s actually good reasons for doing so.<br>文件描述符一不是此进程的标准输出，但它实际上是原始标准输出。但它实际上是应该写入的文件的描述符。同样，如果它正在进行输入重定向。但你可以自己打电话给公爵二，做这些事情。这样做实际上有很好的理由。</p>
<p>发言人   01:00:30<br>So in particular, imagine I open a file and standard output points to the sort of normal thing. And I open a new file, I call it B, and then I call Duke two, excuse me. And now what?<br>因此，特别地，想象我打开一个文件，标准输出指向那种正常的东西。我打开一个新文件，我称之为B，然后我打电话给两个公爵，对不起。现在怎么办？</p>
<p>发言人   01:00:48<br>Both file descriptor one and file descriptor 4 are sharing this entry in the file table. And you see the reference count of two. And so in order to really close it, then what would typically happen at this point is this happens before it starts your program. You’d want to close file descriptor for. And in fact, there’s a lot of bugs you can make by not closing files. And it’s easy to make mistakes when you have multiple entries in these tables. Don’t use the reference to standard out. No, see, if I close this one, it just decrements this reference count. But this remains a valid entry here.<br>文件描述符1和文件描述符4在文件表中共享此条目。你会看到引用计数为2。因此，为了真正关闭它，通常会在这一点上发生的是在它启动程序之前发生。您想要关闭的文件描述符。事实上，不关闭文件会造成很多错误。当您在这些表中有多个条目时，很容易出错。不要使用对标准输出的引用。不，看，如果我关闭这个，它只会减少这个引用计数。但这仍然是一个有效的入口。</p>
<p>发言人   01:01:42<br>Yes, but dupe 2 will decrement the reference count of the original. Dupe 2 goes backwards from where you would think it should. So Duke 2 is what I referred to, for example, file descriptor. I want file descriptor for to become what I can use and refer to with file descriptor one here, it will actually decrement the reference count of this before it then does the copy. Otherwise it would create. An orphan in this table, right? So anyways, dupe 2 also is a powerful but dangerous mechanism.<br>是的，但重复2将减少原始文件的引用计数。Dupe 2从你认为它应该的地方倒退。所以公爵2就是我所指的，例如文件描述符。我希望文件描述符能够成为我可以使用和引用的文件描述符之一，在进行复制之前，它实际上会减少引用计数。否则就会产生。这个桌子上的孤儿，对吧？所以无论如何，dupe 2也是一种强大但危险的机制。</p>
<p>发言人   01:02:48<br>So now finally, let me just mention the much more common IO that application programs use. It’s what’s known as the standard IO, and that’s what’s documented in K and R, and it’s actually part of the C standard, all these different functions. The main feature it adds is sort of like what you saw with the Rio package. It adds buffering. So it doesn’t have to do this low levels and it avoids all some of the nastiness.<br>所以现在最后，让我提一下应用程序使用的更常见的IO。这就是所谓的标准IO，这就是在K和R中记录的，它实际上是C标准的一部分，所有这些不同的函数。它添加的主要功能有点像你在Rio软件包中看到的那样。它增加了缓冲。所以它不必做这么低的水平，并且避免了所有的一些不健康。</p>
<p>发言人   01:03:23<br>And the way it works is what we’ve already seen. It uses buffering to do the IO. So just as an example.<br>它的工作方式是我们已经看到的。它使用缓冲来执行IO。这只是一个例子。</p>
<p>发言人   01:03:49<br>Here’s some code that calls printf one character at a time to print the word hello. But if I run that and I s traces it.<br>这里有一些代码，它一次调用一个字符printf来打印单词hello。但是如果我运行它并追踪它。</p>
<p>发言人   01:04:09<br>You see that there’s only one system called to write, and it works the same way you saw with the Rio code. It builds up a buffer. And it’s not until this call to F flush that forces the output to actually be a printed output. Usually that happens automatically, actually, if you print F up. Line feed, it will flush it. So I think that call to F flush is probably redundant here.<br>你会发现只有一个系统叫做 “写”，它的工作方式和你在Rio代码中看到的一样。它建立了一个缓冲区。直到调用了F flush，才强制输出实际上是打印输出。通常这种情况会自动发生，实际上，如果你打印出来的话。输入线路，它会冲洗它。所以我认为在这里调用F flush可能是多余的。</p>
<p>发言人   01:04:47<br>And so that’s the benefit. So buffered IO is much more. Efficient because of the buffering.<br>这就是好处。所以缓冲的IO更多。由于缓冲而高效。</p>
<p>发言人   01:05:05<br>So as a result, we’ve now seen three different types of IO. There’s the low level IO called referred to as Unix Iowa. You saw this package that was written specifically for the book and for the course called Rio. And then there’s a much larger and in fact, richer, a set of IO functions provided by the Unix standard library.<br>因此，我们现在已经看到了三种不同类型的IO。有一个低级别的IO，称为Unix Iowa。你看到了这个专门为这本书和名为 “Rio” 的课程编写的软件包。然后Unix标准库提供了一组更大、更丰富的IO函数。</p>
<p>发言人   01:05:30<br>So you might ask a couple questions. One is, well, why the heck did you write this when you’ve already got that? If Unix provides buffered IO, why did you do it yourself? And the reason is this stuff doesn’t, it works really well for the IO you do to a terminal or to files, but it doesn’t do very well with network connections. It wasn’t really designed for that. And so it gets really messed up. And so the main reason you’re going to find yourself using this when you’re starting to use network connections, the other thing is these do not co-exist very well buffered IO with Rio IO because they each maintain their own buffers and they don’t know about each other, and they get terribly confused. So you kind of have to pick one or the other with respect to any particular IO connection and don’t try to mix and match them.<br>所以你可能会问几个问题。一个是，既然你已经有了这个，你为什么还要写这个呢？如果Unix提供缓冲的IO，为什么要自己做呢？原因是这些东西不能，它对于你对终端或文件所做的IO非常有效，但对于网络连接来说并不是很好。它并不是为此而设计的。所以它真的一团糟。因此，当你开始使用网络连接时，你会发现自己使用这个的主要原因是，这些缓冲的IO与Rio IO不能很好地共存，因为它们各自维护自己的缓冲区，并且彼此不了解。他们变得非常困惑。所以你必须根据任何特定的IO连接选择一个，不要试图混合和匹配它们。</p>
<p>发言人   01:06:26<br>So like I said Unix IO, then the low level stuff from an application perspective, it’s like really painful to use, especially with short counts and error codes and all of that stuff. And so in general, you want to either write your own package or use some other package around it. And so as I said, standard IO gives you printf and scanf and all these nice features. It’s uniform, it exists on all systems. It’s reasonably standardized.<br>就像我说的Unix IO，然后是从应用程序的角度来看的低级东西，使用起来真的很痛苦，特别是在短计数和错误代码等情况下。因此，通常情况下，您希望编写自己的包或在其周围使用其他包。就像我说的，标准IO为您提供了printf和scanf以及所有这些不错的功能。它是统一的，存在于所有系统中。它是合理标准化的。</p>
<p>发言人   01:07:05<br>So in general, then use the standard IO for most year, day to day uses of files. Use raw IO for low level stuff like when you have to. And partly it turns out signals are not, You shouldn’t use standard IO when you’re writing signal handlers. And then the Rio you’re going to find useful in particular for doing networking.<br>因此，通常情况下，对于大多数年度的日常文件使用，请使用标准的IO。使用原始IO来处理低级别的事情，比如在必须的时候。部分结果表明信号不是，当你编写信号处理程序时，你不应该使用标准的IO。然后你会发现Rio对于建立人际关系特别有用。</p>
<p>发言人   01:07:34<br>One other thing that you should, one bug that students do over and over again in this course is they try to do line oriented IO on things that aren’t lines. So like a JPEG image or something like that. And the reason that it’s important is that these functions, the end of line character 0 A is a very special character. They’ll stop reading or something like that. Or if it’s going between Windows and Unix, it will actually change one from line feed to carriage return line feed. Similarly, functions like stirring land and steer copying will stop when they hit a null byte, and that’s not what you want to do when these are network packets you’re trying to send out. Be careful, some of the functions you’ve used a lot and you’re very familiar with, maybe completely inappropriate for things where you’re doing binary data or you’re communicating over networks and things like that. So be sure you understand what you’re doing when you start to use these kind of functions.<br>你应该做的另一件事是，学生在这门课程中一遍又一遍地做的一个错误是，他们尝试对不是线的东西进行线导向IO。像一个JPEG图像或类似的东西。这很重要的原因是这些函数，行尾字符0 a是一个非常特殊的字符。他们会停止阅读或类似的东西。或者如果它在Windows和Unix之间切换，它实际上会将换行更改为回车换行。同样，像搅拌土地和操纵复制这样的功能在它们命中空字节时将停止，当这些是你试图发送的网络数据包时，这不是你想要做的事情。要小心，一些你经常使用并且非常熟悉的功能，可能完全不适合处理二进制数据或通过网络通信等事情。因此，在开始使用这些功能时，请确保您理解自己在做什么。</p>
<p>发言人   01:08:48<br>So those of you who really want to know this stuff, there’s a fellow named Richard Stevens who unfortunately died. A while, quite a while ago. But his books live on and various people have signed up to become co-authors with him in his absence and creating new editions of these books that used to date back way far. And if you really want to know how this stuff works, you want to be the ace programmer, these books are the best you can get. But I’ll also warn you, your bookshelf will become very heavy laden because there’s the volumes 1, 2, and 3, and then there’s networking books. And Stevens is like encyclopedic reference, but they’re excellent books. If you really want to understand something, read Stevens, and there’s another book that is specific to Linux that’s fairly nice and somewhat ISS, very detailed. But since it’s only trying to deal with Linux, it’s a little bit less weird than trying to read Stevens.<br>所以那些真正想知道这些的人，有一个叫理查德·斯蒂文斯的人不幸去世了。一段时间，很久以前。但是他的书一直在继续，各种各样的人已经签约成为他不在的时候的合著者，并创造了这些书的新版本，这些书可以追溯到很远的地方。如果你真的想知道这些东西是如何工作的，你想成为王牌程序员，这些书是你能得到的最好的书。但我也要警告你，你的书架会变得非常沉重，因为有第一卷、第二卷和第三卷，还有网络书籍。和斯蒂文斯就像是百科全书式的参考资料，但它们是优秀的书籍。如果你真的想理解一些东西，可以阅读Stevens，还有另一本书是专门针对Linux的，它相当不错，有些不太详细。但由于它只是尝试处理Linux，所以比尝试阅读Stevens稍微少一些奇怪。</p>
<p>发言人   01:09:59<br>Because Stevens, we’ll say in this version of Unix, it works this way, and this version it works that way and blah, blah, blah, and it’s all different and it will drive you crazy. But Stevens is Still’s an outstanding set of books.<br>因为在这个版本的Unix中，我们会说Stevens是这样工作的，这个版本是这样工作的，等等，它们都不同，会让你发疯。但斯蒂文斯仍然是一本出色的书。</p>
<p>发言人   01:10:16<br>This is an example, and I’m not going to go through it, but these are the kind of things that we use to torture students, that you open some file descriptors and you do some dupes, and you do some forks, and so you end up with real spaghetti for all the pointers and what’s shared and what’s not shared. And then you ask, what will this print? And of course, you’ll have to trace through in great detail what’s really going on. So those are in the book, and I recommend you work on some of those. Okay, that’ll do us for today then.<br>这是一个例子，我不打算讲述它，但这些是我们用来折磨学生的东西，你打开一些文件描述符，做一些欺骗，做一些叉子，因此，你最终得到的是真正的意大利面条，用于所有指针以及共享和不共享的内容。然后你问，这个打印出来的是什么？当然，你必须非常详细地追踪到底发生了什么。所以这些都在书中，我建议你研究其中的一些。好的，那就今天了。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>深入理解计算机系统 017-System-Level I/O</div>
      <div>http://example.com/2025/10/12/15213-017/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月12日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/12/15213-018/" title="深入理解计算机系统 018-Virtual Memory, Concepts">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">深入理解计算机系统 018-Virtual Memory, Concepts</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/12/15213-016/" title="深入理解计算机系统 016-Exceptional Control Flow, Signals and Nonlocal Jumps">
                        <span class="hidden-mobile">深入理解计算机系统 016-Exceptional Control Flow, Signals and Nonlocal Jumps</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
