

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="发言人   00:00Well, good afternoon, everyone. So today we’re going to transition into a topic that, to me, is sort of the reward for having slogged through all the low level stuff you’ve done up to this">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解计算机系统 022-Network Programming, Part I">
<meta property="og:url" content="http://example.com/2025/10/12/15213-022/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="发言人   00:00Well, good afternoon, everyone. So today we’re going to transition into a topic that, to me, is sort of the reward for having slogged through all the low level stuff you’ve done up to this">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-12T02:00:21.000Z">
<meta property="article:modified_time" content="2025-10-19T11:16:51.138Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>深入理解计算机系统 022-Network Programming, Part I - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="深入理解计算机系统 022-Network Programming, Part I"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-12 10:00" pubdate>
          2025年10月12日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          16k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          131 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">深入理解计算机系统 022-Network Programming, Part I</h1>
            
            
              <div class="markdown-body">
                
                <p>发言人   00:00<br>Well, good afternoon, everyone. So today we’re going to transition into a topic that, to me, is sort of the reward for having slogged through all the low level stuff you’ve done up to this point to be able to really understand and become adept at programming network software. There’s a lot to networking that we’re not going to cover, but at least to have some familiarity with it. So I know that a lot of you are sort of in the midst of trying to figure out how to make mail run and make it run fast. And so this topic is really more pointing toward the future, but it’s very relevant to the final web you’ll do for the course. And so we’re starting to get ready for that.<br>大家下午好。所以今天我们要转换成一个话题，对我来说，这是一种奖励，因为你已经通过迄今为止所做的所有低级别的东西来真正理解并熟练编程网络软件。有很多关于网络的内容我们不打算涵盖，但至少需要对它有一些熟悉。所以我知道你们很多人都在试图弄清楚如何让邮件运行并让它运行得更快。因此，这个主题实际上更多地指向未来，但它与您将为课程所做的最终网页非常相关。所以我们开始为此做好准备。</p>
<p>发言人   00:57<br>So like I said, this course is not really a full course in networking. There’s many other courses at the university that are. And so what we’re going to try and do is give you just a little flavor of it, particularly as everything in the course, a programmer’s perspective. So how you as a software developer would make use of the C level Apis that are relevant to network programming? And why isn’t this working?<br>就像我说的，这门课程并不是一个完整的网络课程。这所大学还有许多其他的课程。所以我们将要尝试做的是给你一点味道，特别是在课程中的所有事情上，程序员的观点。那么，作为一名软件开发人员，您将如何利用与网络编程相关的C级API呢？这为什么不起作用？</p>
<p>发言人   01:31<br>So the idea behind most networking systems is what’s called the client server model. The idea is that there’s a service out there that you want access to, and you as a customer or a client or making a request to that server. So an example would be when you order something on Amazon. Amazon has a bunch of servers, and you go to your web browser and it contact the Amazon web server, and you make transactions. You request something, you provide information, and it gives you back pretty pictures of things you might want to buy. It acknowledges your credit card transactions. Those are all very classic client server types of interactions. You as the client Amazon is the server.<br>因此，大多数网络系统背后的想法就是所谓的客户端服务器模型。这个想法是，有一项服务是你想要访问的，而你作为客户或客户端或者向该服务器发出请求。一个例子是当你在亚马逊上订购东西时。亚马逊有一堆服务器，你进入你的网络浏览器，它会联系亚马逊网络服务器，你就可以进行交易。你要求某些东西，你提供信息，它会给你返回你可能想买的东西的漂亮图片。它确认您的信用卡交易。这些都是非常经典的客户端服务器交互类型。你作为客户端，亚马逊是服务器。</p>
<p>发言人   02:25<br>Another interesting example is a telephone. So if you think about it, a telephone is both a client and a server. When I’m placing a call to somebody else I’m the client and that person’s phone is the server, right? It’s sitting there waiting for calls to come in and when that call comes in, it makes a connection, we talk over the phone and then I hang up. Either side hangs up. So there’s a lot of instances out there of some variation of client and server, and it’s a much richer idea in that you can often switch back and forth the roles of those two parties, but is universal and a ubiquitous way of thinking about how to set up a network system. So in general, then, the idea is that it’s not.<br>另一个有趣的例子是电话。所以，如果你仔细想想，电话既是客户端又是服务器。当我给别人打电话时，我是客户，那个人的电话是服务器，对吧？它坐在那里等待电话进来，当那个电话进来时，它建立了联系，我们通过电话交谈，然后我挂断。双方都挂了。因此，有很多不同的客户端和服务器实例，这是一个更丰富的想法，因为您可以经常在这两方的角色之间来回切换，但这是一种通用且普遍的思考如何建立网络系统的方式。所以总的来说，想法是它不是。</p>
<p>发言人   03:21<br>Working the client is making some request to the server. The server does something locally to deal with it it. It gets information, retrieves from its database the things you might want to buy, and then it sends back information, say a nicely formatted web page with all kinds of shopping suggestions. And then the client decides what to do next.<br>工作的客户端正在向服务器发出一些请求。服务器在本地做一些事情来处理它。它获取信息，从数据库中检索你可能想买的东西，然后返回信息，例如一个格式优美的网页，其中包含各种购物建议。然后客户决定下一步做什么。</p>
<p>发言人   03:50<br>From a hardware perspective, the interface to A between the network and your computer is called the nicco network interface card, even though it’s not always on a card. We really won’t talk about hardware at all. But what’s most interesting from it is that it looks to your computer like an IO device. And in fact Unix API for dealing with networks makes it look like a file. So in particular, just as a disk sits off of a bus and you write data to a disk or you read it from a disk, similarly, the network sits off of a similar bus. And when you want to send a message, you actually do it by writing to a sort of virtual file that’s called the network. And when you’re receiving data, you do it by reading.<br>从硬件角度来看，网络和计算机之间的接口称为nicco网络接口卡，尽管它并不总是在卡上。我们真的根本不会谈论硬件。但最有趣的是，它在你的电脑上看起来就像一个IO设备。事实上，用于处理网络的Unix API使其看起来像一个文件。因此，特别是，就像磁盘坐在公共汽车上，你将数据写入磁盘或从磁盘中读取数据一样，网络也坐在类似的公共汽车上。当你想发送消息时，你实际上是通过写入一种称为网络的虚拟文件来实现的。当你接收数据时，你通过阅读来完成。</p>
<p>发言人   04:54<br>Several weeks ago, I gave the lecture on IO. It turns out that it’s extremely relevant to network programming’s, the basic model that was created by the early developers of the sort of standard Unix. And now that’s carried over not just to Unix, but it’s the same model for Windows and other operating systems.<br>几个星期前，我做了一个关于IO的讲座。事实证明，它与网络编程非常相关，这是由早期标准Unix开发者创建的基本模型。现在，这不仅适用于Unix，而且适用于Windows和其他操作系统。</p>
<p>发言人   05:20<br>And now let’s just talk a little about what computer networking means.<br>现在让我们稍微谈谈计算机网络的含义。</p>
<p>发言人   05:25<br>The idea of a network is it’s a collection of systems that are referred to as hosts that are able to communicate with each other over some kind of communication fabric. Let’s call it communication system. And they’re sort of partitioned into mostly referred to as lands or local area networks that you establish within a small region. And then a wide area network, which would be over something the size of a city or perhaps more, and over an enterprise such as CMU. It’s a very complex set of, for example, wireless base stations that right in this room that you’re interacting with when you’re using a wireless system or your phone. And then there’s a whole networking infrastructure within the university that then goes to some commercial providers At and T in particular that give it access to the commercial internet. And then there’s another set of network connections hosted by the supercomputing center that give you access to what’s called Internet too, which is the resource that’s used for communicating among universities. So underneath, when you’re doing your networking stuff, there’s this amazingly complex combination of things going on.<br>网络的概念是指能够通过某种通信结构相互通信的系统的集合，这些系统被称为主机。让我们称之为通信系统。它们被划分为您在一个小区域内建立的主要称为土地或局域网的部分。然后是一个广域网，覆盖城市大小甚至更大的城市，以及像CMU这样的企业。这是一组非常复杂的，例如，当您使用无线系统或手机时，就在这个房间里与您互动的无线基站。然后在大学内有一个完整的网络基础设施，然后提供给一些商业提供商，特别是为其提供访问商业互联网的机会。然后还有另一组由超级计算中心托管的网络连接，让你可以访问所谓的互联网，这是用于大学之间通信的资源。因此，在你进行网络工作时，下面会发生令人惊讶的复杂事情组合。</p>
<p>发言人   06:53<br>The idea of an internet supposed refers to the idea, the general idea of a network of networks taking, for example, the local area network that this base station provides and connecting it up to other networks on campus and across the world. And when we refer to the Capital I Internet, that refers to the one instance, the most significant instance of an internet, lowercase. I means the sort of general idea of creating a network of networks. Uppercase I is the specific example that we all know and use all the time. That’s organized by a certain set of principles that uses a particular set of protocols and so forth. And of course, we tend to just talk the internet. And most people know that what that really implies is the sort of existing network structure that there is. And that’s good enough for the purpose of this course.<br>所谓互联网的概念是指网络的一般概念，例如，该基站提供的局域网并将其连接到校园和世界各地的其他网络。当我们提到首都互联网时，它指的是一个互联网最重要的例子，小写。我指的是创建一个网络的一般想法。大写I是我们都知道并一直使用的具体例子。这是由一组特定的原则组织的，这些原则使用一组特定的协议等等。当然，我们倾向于只在互联网上交谈。大多数人都知道，这实际上意味着现有的网络结构。这对于本课程的目的来说已经足够了。</p>
<p>发言人   07:54<br>We’re not going to talk much about other possible designs one might have for a network. So most of the low level of networking is supported by something called Ethernet.<br>我们不会谈论太多关于网络的其他可能设计。因此，大多数低级别的网络都由称为以太网的东西支持。</p>
<p>发言人   08:05<br>And the term Ethernet actually has evolved tremendously over time so that it’s almost more like a brand name than it is a specific technology. And the version you’re familiar with, the wired version of it, you have a wire to some sort of a. Box like that you plug your ethernet jacks into. And historically, those were called hubs. And the idea of a hub was it was just a repeater that whatever came into it from one computer, it would broadcast to all the connected machines. And so you only want to do this for maybe a dozen or so machines. It’s like a party line. They’re all hearing what everybody else is saying.<br>以太网这个术语实际上随着时间的推移已经发生了巨大的演变，它几乎更像是一个品牌名称，而不是一种特定的技术。你熟悉的版本，它的有线版本，你有一个连线到某种类型的。盒子就像你插入以太网插孔一样。历史上，这些被称为枢纽。集线器的想法是它只是一个中继器，无论来自一台计算机，它都会广播到所有连接的机器。所以你只想为十几台左右的机器做这件事。这就像一条派对线。他们都在听别人在说什么。</p>
<p>发言人   08:51<br>And in fact, the original first version of the Ethernet did that by everyone interacting over a single cable carrying essentially radio signals. And similarly, when you’re in this room using a wireless Internet, a wireless internet is sort of like a hub and that all the packets that you’re sending. Across the room, they’re all sort of making use of the same radio frequencies, the same communication channel. And there’s a protocol for how they detect when two messages get sent at the same time and therefore interfere with each other. So that can only sort of scale up to maybe at most 100 different a host communicating because they’re all sharing a single communication channel.<br>事实上，以太网的最初版本是通过每个人通过一根传输基本上无线电信号的电缆进行交互来实现的。同样地，当你在这个房间使用无线互联网时，无线互联网有点像一个集线器，所有你发送的数据包都在这个集线器上。在房间里，他们都在使用相同的无线电频率，相同的通信渠道。有一个协议用于检测何时同时发送两条消息并因此相互干扰。因此，这只能扩展到最多100个不同的主机进行通信，因为它们都共享一个通信通道。</p>
<p>发言人   09:42<br>Now, in the wired world, what’s evolved is usually when you buy a box or you get one from your cable company with all those ports in it, it’s actually called a router or sometimes a switch. It doesn’t broadcast to everyone. It selectively tries to guess, is this particular message bound for this particular host and only send to that one? And as you know, you can take these and wire up, I think, about up to 6 levels deep in hops and basically create a network of wired connections, and they’ll all get from one to the other somehow. And then after that, it gets more complicated. You can add more sophisticated types of switching on top of it. But so the general idea of even an Ethernet is actually a fairly complex thing, but at some sort of conceptual level, we can just think of it as a bunch of hosts that can talk directly to one another.<br>现在，在有线世界中，发展的通常是当你购买一个盒子或者从有线电视公司得到一个带有所有这些端口的盒子时，它实际上被称为路由器，有时甚至被称为交换机。它并不向所有人广播。它有选择地试图猜测，这个特定的消息是否针对这个特定的主机，并且只发送到那个主机？正如你所知道的，你可以把这些连接起来，我想，在啤酒花的深度上最多可达6层，基本上创建一个有线连接网络，它们都会以某种方式从一个到另一个。然后在那之后，情况变得更加复杂。您可以在其上添加更复杂的开关类型。但是，即使是以太网的一般概念实际上也是相当复杂的，但在某种概念层面上，我们可以将其视为一群可以直接相互通信的主机。</p>
<p>发言人   10:50<br>And then an internet then refers to the idea of taking those local area networks and connecting them together via routers. And routers obey a particular protocol based on the address that you’re trying to send data to and. So what you end up with conceptually is a whole bunch of hosts spread potentially all across the world, and then some magical system of routers that we will get a message from one place to the other based on a mode of addressing where there’s some known address of the hosts that you’re trying to send to. And it will hop through multiple routers to get from one place to the other. And that’s true whether it’s on campus or whether it’s hopping all the way around the world. And so again, there’s this huge body of information and knowledge about how that routing works and how it’s reliable and all that, but we’re going to just assume that somebody else has figured that out.<br>然后互联网是指将这些局域网通过路由器连接在一起的想法。路由器遵循基于您尝试发送数据的地址的特定协议。所以从概念上讲，你最终得到的是一堆可能遍布世界各地的主机，然后是一些神奇的路由器系统，我们会基于一种寻址模式从一个地方收到一条消息，其中有一些您尝试发送的主机的已知地址。它将通过多个路由器从一个地方到达另一个地方。无论是在校园里还是在世界各地跳跃，都是如此。所以，关于路由如何工作以及它的可靠性等，有大量的信息和知识，但我们只能假设别人已经弄明白了。</p>
<p>发言人   11:57<br>And our job as programmers is just to be able to communicate from one host to another. And so how could you design a system where all these diverse systems made by computers, made by different manufacturers, operating under different countries with different telecommunications bodies, governing bodies, and so forth, how can they all work with each other?<br>作为程序员，我们的工作就是能够在不同主机之间进行通信。那么你如何设计一个系统，在这个系统中，所有这些由计算机制造的不同系统，由不同的制造商制造的，在不同的国家使用不同的电信机构、管理机构等等，它们如何能够相互协作？</p>
<p>发言人   12:25<br>And the requirement is you have to have a protocol. You have to have some common set of conventions for what messages look like, how they get sent, what happens if one of them doesn’t make it? How do you recover from that, and so forth. And so what does a protocol include? Well, it has to include some way of naming things. If I want to send to some host, I have some way of designating who that host is. And then the routing system has to have some reliable way of getting my data to that named host, and that’s the delivery mechanism. And that’s usually done.<br>要求是你必须有一个协议。你必须有一些通用的约定，比如消息是什么样子的，它们是如何发送的，如果其中一个没有成功会发生什么？你如何从中恢复，等等。那么协议包括什么？嗯，它必须包括一些命名事物的方式。如果我想发送到某个主机，我有一些方法可以指定那个主机是谁。然后路由系统必须有一些可靠的方法将我的数据传输到那个指定的主机，这就是传递机制。这通常是这样做的。</p>
<p>发言人   13:08<br>One of the things that we now accept as universal, but it really wasn’t when it first came out, was the idea of you would take all your data, you divide it into packets, and packets are typically about 1000 to 2000 B. So if you have a longer message, it chops it up into individual packets and sends it across. And all the communication occurs at a packet level. That’s different than the historic phone system was a connection based system, meaning that if I was calling somebody, there is a dedicated wire set of wires maintained by the phone company that would be reserved and locked down for our own use during the entire duration of that phone call.<br>我们现在普遍接受的一件事是，当它第一次出现时，实际上并不是这样的，那就是你会拿走所有的数据，将其分成数据包，数据包通常大约是1000到2000 B。因此，如果您有更长的消息，它会将其分成单独的数据包并发送。并且所有的通信都发生在数据包级别。这与历史上的电话系统不同，它是一个基于连接的系统，这意味着如果我打电话给某人，会有一个由电话公司维护的专用电线组，在整个电话通话期间将被保留和锁定供我们自己使用。</p>
<p>发言人   13:57<br>So to get then from one host, say A to B, what happens is we want to send a packet. And that packet will contain some amount of data. And the idea of packet communication then is you put little headers on that contains sort of routing information, the equivalent of what you’d see on the front of an envelope of a letter, perhaps. And so, and at different points in the way, they’ll have different numbers of headers and different protocols or formats for what those headers look like.<br>因此，从一个主机，比如一个面向企业，我们想要发送一个数据包。并且该数据包将包含一定数量的数据。那么分组通信的想法就是在上面放置一些包含路由信息的小标题，类似于您在信件信封前面看到的内容。因此，在不同的阶段，它们会有不同数量的标头以及不同的协议或格式来显示这些标头的外观。</p>
<p>发言人   14:32<br>So in particular, within, I wanted to send a message, and I’ll do that. And then the software that runs on my machine that handles this will put a header in front of that that describes the internet routing. And then it will tack a header in front of that that talks about the local area network routing that gets used. And that’s what’s referred to as P, the packet header for the Internet protocol, and FH one, the frame header for this particular message being sent within this local network. And then the network interface card or the adapter here is then responsible for putting that out over this local communication capability. And then that gets received at the other end by the network adapter at the receiver’s direction, It will put a its own frame header on it to. Pass it in. And that then gets stripped off so that all host B sees is the data that gets sent.<br>因此，特别是在内部，我想发送一条信息，我会这样做。然后运行在我的机器上处理这个问题的软件会在前面放一个标题，描述互联网路由。然后它会在前面添加一个标题，谈论所使用的局域网路由。这就是所谓的P，互联网协议的数据包头，以及FH一，在本地网络内发送的这条特定消息的帧头。然后，这里的网络接口卡或适配器负责将其输出到本地通信功能上。然后网络适配器在接收方的方向在另一端接收到它，它将在其上放置自己的帧标头。把它传递进去。然后它被剥离，这样所有主机B看到的都是被发送的数据。</p>
<p>发言人   15:50<br>But this idea of putting headers in front and at times sort of what they call encapsulation. I’ll take this big packet and I’ll just tack some more information on top to the front of it, header information, and I’ll send through the rest of it just as a set of bytes.<br>但是这种将标头放在前面的想法，有时会被称为封装。我会拿这个大数据包，在它的前面添加一些更多信息，标题信息，然后我将以一组字节的形式发送它的其余部分。</p>
<p>发言人   16:15<br>So the internet that we know and love, the capital I internet then has a particular set of protocols that are, you’ve probably heard the terms, one is called the IP, the Internet protocol, which is the one that defines ideas about how do you name hosts on the internet and how do you send packets?<br>所以我们所知道和喜爱的互联网，也就是互联网的首都，拥有一组特定的协议，你可能听说过这些术语，其中一个被称为IP，也就是互联网协议。哪个定义了如何在互联网上命名主机以及如何发送数据包的想法？</p>
<p>发言人   16:37<br>And they’re referred to sometimes as datagrams, meaning that a packet is just a single entity that gets sent from point A to point B, and the underlying IP doesn’t guarantee delivery. It’s based on what they call best effort communication, meaning that at each step along the way, if, for example, things are good, then it will just send this packet along. If there’s too much congestion, there’s been somebody’s turned on their microwave oven and it’s set up some radio frequency interface interference. Then at the IP level, it just drops that packet and says, whoops, I screwed up. Sorry, it doesn’t even say sorry. It just does it silently.<br>它们有时被称为数据报，意味着数据包只是从点a发送到点B的单个实体，并且底层IP不保证传递。它基于他们所谓的 “尽力而为” 的沟通，这意味着在过程中的每一步，例如，如果情况良好，那么它只会发送这个数据包。如果堵塞太多，则是有人打开了微波炉，并设置了一些射频接口干扰。然后在IP级别，它只是丢弃那个数据包并说，哎呀，我搞砸了。对不起，它甚至没有说对不起。它只是默默地做这件事。</p>
<p>发言人   17:30<br>And then you can, as a programmer, make use of that varying global level. So normally as a programmer, you don’t really want to program at that level. You’ll send packets and they will get there. But you can if you want to. And it’s called UDP protocol. It’s just a small software layer over IP, And there’s some applications that you’ll see, for example, in the computer game world, where you want to send information really fast. And if some information gets dropped, it’s not a big deal that people actually program at that level. We won’t really talk about that.<br>然后，作为一名程序员，你可以利用这种不同的全局级别。因此，作为一名程序员，你通常并不想在那个级别上编程。你会发送数据包，它们会到达那里。但是如果你愿意的话，你可以。它被称为UDP协议。它只是一个小的IP软件层，你会看到一些应用程序，例如在电脑游戏世界中，你想要非常快速地发送信息。如果某些信息被丢弃，人们实际上在那个级别编程并不是什么大问题。我们不会真正谈论那个。</p>
<p>发言人   18:03<br>The more common protocol that gets used and carries 99% of internet traffic is what’s called TCP, or transmission control protocol. And that provides reliable, the equivalent of a telephone connection. I can reliably send data from point A to point B as many bytes as I like, guaranteed delivery it’s. Sometimes fast and sometimes not. But it’s there and it’s built on top of the IP here, this datagram, meaning that it has to take whatever you’re sending and slice it up into these single packets. If one of them doesn’t get sent, it will resend it until it gets there. They have to deal with the fact that packets can travel different paths and one can get ahead of the other in transmission. And so it has to reorder them in the correct sequence.<br>被使用并承载99% 的互联网流量的更常见的协议是所谓的TCP，或传输控制协议。这提供了可靠的，相当于电话连接。我可以可靠地将数据从点A发送到点B，我喜欢多少字节，保证交付。有时快，有时不。但它就在那里，它是建立在这里的IP之上的，这个数据报意味着它必须接收你发送的任何东西，并将其分成这些单独的数据包。如果其中一个没有被发送，它会重新发送，直到它到达那里。他们必须处理这样一个事实，即数据包可以通过不同的路径传输，并且一个可以在传输中领先于另一个。因此它必须按照正确的顺序对它们重新排序。</p>
<p>发言人   18:58<br>And so there’s a lot of stuff under, but we’ll just assume that it kind of works. And so you can just think about it is I have a stream connection I can send from A to B, and B can send a stream of data back to me, and we’re all happy. And so that’s the version that looks like file IO. I just keep writing to a file, and it’s sending packets over the network to the other end. And then the other side can be sending stuff to me, and I’m just reading it, and I’m just reading bytes of data, not worrying about how that got broken up into individual packets. And so that’s referred to as the socket interface.<br>所以下面有很多东西，但我们假设它有点工作。所以你可以想一想，我有一个可以从面向企业发送的流连接，而B可以将数据流发送回给我，我们都很高兴。这就是看起来像file IO的版本。我只是不断地写入文件，它正在通过网络向另一端发送数据包。然后另一边可以发送东西给我，我只是在阅读它，我只是在阅读字节的数据，而不用担心它是如何被分解成单独的数据包的。因此，这被称为套接字接口。</p>
<p>发言人   19:41<br>You’ll hear the term socket programming, and that’s exactly what we’re talking about. And so from a sort of a system, software, hardware system, then the client and the server are both implemented as application programs at their respective endpoints. They’re hosts and they make use of software and libraries that run at some combination of the user level and at the kernel level. And therefore, you have access to direct resources. And so I, as a programmer, an application programmer, then make use of this software API that letsie do socket programming, and it’s based on directly supports tcp-ip.<br>你会听到术语套接字编程，这正是我们正在谈论的。因此，从某种系统、软件、硬件系统来看，客户端和服务器都在各自的端点上实现为应用程序。它们是主机，它们使用在用户级别和内核级别的某种组合上运行的软件和库。因此，您可以直接访问资源。因此，作为一名程序员，一名应用程序员，我可以使用这个软件API进行套接字编程，它基于直接支持tcp-ip。</p>
<p>发言人   20:44<br>So first of all, we’re going to talk most of the time about what’s called Ipv 4 version 4, which is the one that’s been running for since the 1980s, I think early 1980s, and is the standard. And we’ll talk very, only mention very briefly the idea of what’s called Ipv 6, which is sort of a next generation version. So the idea of Ipv 4, and this is now we’re talking about IP.<br>首先，我们大部分时间将讨论所谓的Ipv 4版本4，这是自1980年代初以来一直在运行的，并且是标准。我们将非常简单地谈谈所谓的Ipv 6的想法，这是一种下一代版本。所以Ipv 4的想法，现在我们正在谈论IP。</p>
<p>发言人   21:14<br>And this is true of TCP as well, that an address is actually just 32 b. But it’s usually expressed in what they call dotted decimal form. And you’ve seen these addresses before that it’s 4 decimal numbers. And they can only range between 0 and 255 because each one of them is a single bytes worth of information. So we’re used to writing things in hex. Now, in this course, we’re going to write it as each byte written as a decimal digit.<br>这也适用于TCP，一个地址实际上只有32 b。但它通常以他们所谓的点分十进制形式表示。你之前见过这些地址，它们是4个十进制数字。它们只能在0到255之间，因为每个都是一个字节的信息。所以我们习惯用十六进制写东西。现在，在本课程中，我们将把它写成每个字节都写为一个十进制数字。</p>
<p>发言人   21:48<br>Passed and stored in what’s called network byte order, which is big Indian byte order. And so we have to worry about the whole big Indian versus good old Indian thing when we’re doing network programming. And you can actually learn a lot. There’s a whole levels of how the different bytes mean. For example, any IP address that starts with 128.2 is at CMU. I think, and then, and so essentially CMU owns that part of the IP address space, which if you think about, that’s approximately 2 to the 64th, 2 to the. No, not two to the 64th, 2 to the 16th. Different IP address is available for use by campus.<br>以所谓的网络字节顺序传递和存储，这是一个大的印度字节顺序。因此，当我们进行网络编程时，我们必须担心整个大印度与古老的印度之间的差异。你实际上可以学到很多。不同字节的含义有完整的层次。例如，任何以128.2开头的IP地址都在CMU。我认为，然后，因此基本上CMU拥有IP地址空间的那部分，如果你考虑一下，这大约是2的第64个，2的。不，不是2到64号，2到16号。校园可以使用不同的IP地址。</p>
<p>发言人   22:49<br>And as I mentioned, there’s a newer version called Ipv 6 that gives you 128 b addresses.<br>就像我提到的，有一个更新的版本叫做Ipv 6，它给你128个地址。</p>
<p>发言人   22:56<br>You can imagine actually that if you think about how many nodes are there on the internet, if a 4 B address is only 2 to the 32 4 billion. And I don’t know about you, but I have a lot of different things that use IP. Have a phone, I have two laptops, I have a couple desktops. So all, if every one of us used multiple IP addresses, then actually the world would be out of them.<br>你可以想象，如果你考虑互联网上有多少节点，如果一个4 b地址只有2的342亿。我不知道你的情况，但我有很多不同的东西使用IP。有一个电话，我有两台笔记本电脑，我有几台台式机。所以，如果我们每个人都使用多个IP地址，那么实际上世界就不会有它们了。</p>
<p>发言人   23:27<br>There’s 7 billion people in the world, not all of whom have access to the internet, but a large fraction of them do. And so there’s a whole kind of crazy way of dealing with the multitude of possible IP addresses. So the obvious thing would be, well, allocate a lot more addresses, and let’s just skip 64 b and go right to 128. And that’s the idea behind Ipv 6. But quite honestly, this has been one of those technologies that’s been out there for over 15 years and still has a very low level of adoption. So it’s still a future technology. People have basically figured out all these crazy schemes to make use of, of just stick within the 4 B limit.<br>世界上有70亿人，并不是所有的人都能上网，但其中很大一部分人都能上网。因此，有一种疯狂的方式来处理众多可能的IP地址。所以显而易见的事情是，分配更多的地址，让我们跳过64 b，直接转到128。这就是Ipv 6背后的想法。但说实话，这是已经存在了超过15年的技术之一，但采用率仍然很低。所以它仍然是未来的技术。人们基本上已经想出了所有这些疯狂的计划来利用，只是坚持在4 B的限制内。</p>
<p>发言人   24:21<br>Okay, so let’s start talking the sort of programmer perspective on this and. This is one area where you’ll wish you weren’t programming in C, but you are. So there’s a lot of really Crufts stuff and it was all developed.<br>好的，那么让我们开始谈论程序员对此的看法。这是一个你会希望自己不是在用C语言编程的领域，但实际上你是在用C语言编程。所以有很多真正的东西都是开发出来的。</p>
<p>发言人   24:42<br>Most of these software protocols were conceived before C even was what it is today. So like the Cernan and Richie book you have is called the second edition, and it’s based on what was called ANCC or ISOC. But these all date before that. They date back to the original Cernan and Richie. So for example, Void Star did not exist in that era. And so you use K star as a generic pointer.<br>这些软件协议中的大多数都是在C甚至是今天之前构思的。所以像你有的那本Cernan和Richie的书叫做第二版，它是基于所谓的ANCC或ISOC。但这些都在那之前。他们的历史可以追溯到最初的Cernan和Richie。例如，虚空之星在那个时代并不存在。所以你使用K星作为通用指针。</p>
<p>发言人   25:09<br>And so there’s just a lot of stuff in this programming interface where you go, wow, that is really Cuffy. Truth is, yes, you’re right. So in particular, there’s a lot of different structs that are defined. In one of them is called an in adder, which means internet address, and it’s just defined to be a 32 b unsigned number.<br>所以这个编程接口里有很多东西，你会说，哇，这真的很Cuffy。事实是，是的，你是对的。所以特别地，有很多不同的结构被定义。其中一个被称为加法器，意思是互联网地址，它只是被定义为一个32 b的无符号数字。</p>
<p>发言人   25:31<br>In general, as I mentioned, the sorcellerie byte order, whoever designed the original protocols was a fan of big Indian addressing. And so what it is, even though actually most of the machines that are out there in this world are little Indian. And so there’s a set of standard library functions that you use to convert between network order and host order. And the idea of it is now, if I run my software on a little Indian or a big Indian machine, these functions will do the right thing. So if I just use these standard libraries, then I don’t have to worry about porting it every time I change the word ordering of a machine, one of the things you’ll notice here is there is no function to convert 64 b data between network order and host order. So I don’t know what people do when I do it. I just write my own functions to do it, or I don’t because I know my other end is a little Indian machine. So anyways, these are already some functions you’ll start seeing that look like network conversion software.<br>一般而言，正如我所提到的，sorcelerie字节顺序，原始协议的设计者是大印度寻址的粉丝。所以它是什么，即使实际上这个世界上大多数机器都是小印度。因此，有一组标准库函数可用于在网络顺序和主机顺序之间进行转换。现在的想法是，如果我在一个小印度或一个大的印度机器上运行我的软件，这些功能就会做正确的事情。因此，如果我只是使用这些标准库，那么我不必在每次更改机器的单词顺序时担心移植它，这里你会注意到的一件事是没有在网络顺序和主机顺序之间转换64 b数据的功能。所以我不知道人们在做什么。我只是编写自己的函数来做这件事，或者我不这样做，因为我知道我的另一端是一台小型印度机器。无论如何，这些已经是一些看起来像网络转换软件的功能了。</p>
<p>发言人   26:52<br>And as I mentioned, the addresses are written in dotted decimal form. And it’s also big Indian. So if I were to write in hex 128 is of course, 8 0. So that’s the most significant byte of the IP address.<br>正如我所提到的，地址以点分十进制形式书写。它也是大印度。所以如果我用十六进制128写，当然是80。所以这是IP地址的最高有效字节。</p>
<p>发言人   27:12<br>And then there’s a set of functions API calls you can use to convert between this dotted decimal format and the actual just a 32 b unsigned int. And actually, it used to be you might see some older presentations where they use different names for this, but the most recent version API calls this the presentation version, the dotted decimal. They referred to it as a presentation. And you can look up, and it’s in the book too, what the calls to these look like.<br>然后有一组函数API调用，您可以使用它们在点分十进制格式和实际的32 b无符号int之间进行转换。实际上，过去你可能会看到一些较旧的演示文稿使用不同的名称，但最新版本的API称此为演示文稿版本，用点分十进制表示。他们把它称为演示。你可以查找，也在书中，对这些调用的样子。</p>
<p>发言人   27:54<br>But you probably don’t are very seldom when you’re thinking about I want to go to Google, you don’t think about what its IP address is. You just go to WW dot Google dot com. And for everything you do, you refer to it by this, whatever called internet domain names, which is a hierarchical naming system. Whereas, you know, there’s dot edu is for educational institutions, is dot com is for commercial, dot net is general networking. Many countries have their own Suffolk. Dot D is for Germany and so forth. And so those are called the first level domain names. And then there’s a higher naming structure under that.<br>但是当你想到我想去谷歌时，你可能很少想到它的IP地址是什么。你只需转到WW.Google.com。对于你所做的一切，你都可以通过这个来引用它，无论所谓的互联网域名，这是一个分层命名系统。然而，你知道，有edu是用于教育机构的，dot com是用于商业的，dot net是用于一般网络的。许多国家都有自己的政策。点D代表德国等。因此，这些被称为第一级域名。然后下面有一个更高的命名结构。</p>
<p>发言人   28:47<br>There’s actually an interesting question of, okay, how do I then map from those hierarchical names, those domain names, into this dotted decimal or the 32 b IP address? And the job of that is by a very large distributed system called the DNS, the domain name system, where the only sort of centrally managed part of it is at the top level. So for each of these first level domain names, there’s a collection of very large collection of machines that keep track of all the all the IP addresses that map to one of those first level domain names. And then, for example, CMU maintains its own naming authority. So anything that says something do CMU doeu there’s local DNS servers within CMU that are picking apart. Okay, where should. If I say CS, do CMU do EU, what would be the IP address for that? And it’s actually pretty interesting how this is managed because it’s totally decentralized.<br>实际上有一个有趣的问题，好的，我如何从这些分层名称，这些域名映射到这个点分十进制或32 b的IP地址？而这项工作是由一个非常大的分布式系统，称为DNS，即域名系统，其中唯一集中管理的部分是在顶层。因此，对于这些一级域名中的每一个，都有一个非常大的机器集合，它们跟踪映射到这些一级域名之一的所有IP地址。然后，例如，CMU维护自己的命名机构。所以任何说做CMU的事情，CMU内的本地DNS服务器正在分裂。好的，应该在哪里。如果我说CS，CMU做EU，那么它的IP地址是什么？实际上，这是如何管理的非常有趣，因为它是完全分散的。</p>
<p>发言人   30:09<br>A whole set of protocols that govern how naming is done. But conceptually, we can think of it as just this big database that gives me a mapping. I can give a domain name, and it will get back to me one or more IP addresses. I can give an IP address, and it will come back with one or more domain names.<br>管理命名方式的一整套协议。但从概念上讲，我们可以把它想象成一个大的数据库，给我一个映射。我可以提供一个域名，它会返回给我一个或多个IP地址。我可以提供一个IP地址，它会返回一个或多个域名。</p>
<p>发言人   30:40<br>And so there’s actually an application you can run on most machines called nslookup. And there’s another one called Dig that you can use to find basically probe the DNS and find in either direction. You can look at the given a domain name, you can find its IP address. Given an IP address, you can find its domain name. And so I’ll show you some code just as an example of how you do the programming. I’ll just show that momentarily called hostna. So just some examples.<br>因此，实际上有一个应用程序可以在大多数机器上运行，称为nslookup。还有另一个叫做Dig的工具，你可以用来找到基本上探测DNS并在任一方向上找到。您可以查看给定的域名，找到其IP地址。给定IP地址，您可以找到其域名。因此，我将向您展示一些代码，以作为您如何进行编程的示例。我会暂时展示那个叫做hostna的东西。所以只是一些例子。</p>
<p>发言人   31:32<br>If I look up some address, like the website for the Science School of Computer Science. Using NS lookup, it comes back. Can people see this? Okay? Do you want it bigger?<br>如果我查找一些地址，比如计算机科学学院的网站。使用NS查找，它会返回。人们能看到这个吗？好吗？你要再大一点吗？</p>
<p>发言人   31:47<br>It’s OK, so this is what NSF looks like, and this stuff here just tells you where was the actual directory entry in the which DNS server actually gave this information back, and it says that WW docs docm u is actually a synonyms for a weirder one called web dash lb DOC dot CS dot CMU dot edu, and its IP address is 128.2, like you’d expect 2 17.13. And of course that works not just at CMU, but I can. You know, go ask what Stanford is up to. And it will come back. And its IP address is something 171.64. And that’s been managed by that. And you’ll see again it I asked for WW dot CS dot Stanford dot edu, it said, well, the real name of that is CS dot Stanford dot edu. And this actually is a point that the mapping between domain names.<br>没关系，这就是NSF的样子，这里的东西只是告诉你在哪个DNS服务器实际提供了此信息的实际目录条目在哪里，它说WW docs docm u实际上是一个更奇怪的叫做web dash的同义词，磅DOC dot CS dot CMU dot edu，它的IP地址是128.2，就像你期望的2 17.13一样。当然，这不仅仅是在CMU有效，而且我可以。你知道，去问问斯坦福在做什么。它会回来的。它的IP地址是171.64。这已经被那个管理了。你会再次看到我要求的WW点CS点斯坦福点edu，它说，嗯，它的真名是CS点斯坦福点edu。这实际上是域名之间的映射点。</p>
<p>发言人   33:08<br>Internet addresses is not one to one. You can have multiple domain names that refer to the same internet address, but you can also have multiple. Internet addresses. Excuse me?<br>互联网地址不是一对一的。您可以有多个域名引用同一个互联网地址，但也可以有多个。互联网地址。对不起？</p>
<p>发言人   33:32<br>That’s weird?<br>这很奇怪？</p>
<p>发言人   33:39<br>So like Twitter dot comma, when I ask for it, it comes back with four different addresses. And if I do the exact same thing again? Yeah, you see, it came back with. The same? No, not even the same addresses. It came back. For example, here, the one that ends with Dot 6, that wasn’t in that first twist. So it came back with a slightly different set of addresses and a somewhat different order. And the idea of that is that it actually has multiple servers.<br>就像Twitter的点逗号一样，当我要求它时，它会返回四个不同的地址。如果我再做同样的事情呢？是的，你看，它回来了。一样吗？不，甚至地址都不一样。它回来了。例如，这里以点6结尾的那个，不在第一个转折中。所以它返回了一组稍微不同的地址和稍微不同的顺序。这个想法是它实际上有多个服务器。</p>
<p>发言人   34:20<br>So when I send to Twitter dot com or Google or any of these major servers, there’s not just one place in the internet that’s handling everybody’s Google traffic. There’s thousands of places that spread around the world. And the way they get you there is by playing tricks with the DNS. Google is constantly sending updates to. It maintains its own DNS servers, so it’s constantly changing them. And it will actually give you different addresses depending on where in the world you’re located as well to try and provide a server that’s sort of reasonably close to you geographically. Just all kinds of tricks that happen through DNS. That is part of the way they can sort of manage this huge set of addresses.<br>所以当我发送到Twitter dot com或Google或任何这些主要服务器时，互联网上不只有一个地方处理每个人的谷歌流量。世界上有成千上万的地方。而他们带你到那里的方式是通过和DNS玩一些把戏。谷歌一直在发送最新进展。它维护自己的DNS服务器，因此不断更改它们。它实际上会根据您所在的位置为您提供不同的地址，以尝试提供一个地理上相当接近您的服务器。只是通过DNS发生的各种技巧。这是他们管理这一庞大地址集的方式的一部分。</p>
<p>发言人   35:10<br>And then there’s some other domain names that don’t have any IP address somewhere in the Hierarch, that hierarchical naming system. But they’re not actually referring to a particular host. So it’s a multi, multi mapping. In the? The API still reflects that.<br>然后还有一些其他的域名在等级命名系统中没有任何IP地址。但它们实际上并不是指特定的宿主。所以这是一个多，多映射。在？该API仍然反映了这一点。</p>
<p>发言人   35:42<br>So this is just going what I told you, sometimes one to one, sometimes many domain names refer to the same address. Sometimes one name maps to multiple addresses that change over time. And then there’s some where it’s a valid name, but it doesn’t have an IP address. It doesn’t have a host associated with a question IP address like given to a server.<br>所以这只是我告诉你的，有时是一对一，有时是许多域名引用同一个地址。有时，一个名称映射到多个随时间变化的地址。还有一些地方它是一个有效的名称，但它没有IP地址。它没有与问题IP地址相关联的主机，就像给服务器一样。</p>
<p>发言人   36:06<br>For example, let’s say I create my own server. How does that number, how’s that number generated? Oh, how do you get your own IP address? Well, to beg borrow, you have to either borrow them or buy them.<br>例如，假设我创建了自己的服务器。这个数字是如何产生的？哦，你怎么得到自己的IP地址？要借钱，你要么借，要么买。</p>
<p>发言人   36:20<br>For example, at CMU, there’s some number of what they call statically allocated IP addresses where it’s just fixed assign to that machine and you can register for and request them through computing services. But most of you don’t have that. Most of you get one that’s assigned dynamically. So there’s a pool of addresses that you basically, they call them leasing that you are assigned with for a while, but it could possibly be reassigned to someone else. And that’s part of the way it can manage a somewhat limited set of IP addresses.<br>例如，在CMU上，有一些所谓的静态分配IP地址，它们只是固定分配给该机器，您可以通过计算服务注册和请求它们。但你们大多数人都没有这个。你们大多数人都会得到一个动态分配的。所以有一个地址池，你基本上称之为租赁，你被分配了一段时间，但它可能会被重新分配给其他人。这是它管理有限的一组IP地址的一部分。</p>
<p>发言人   37:06<br>So the idea of, like I said, the main.<br>所以这个想法，就像我说的，主要的。</p>
<p>发言人   37:17<br>The way we’ll think about it is in terms of what’s called TCP. And it says connection oriented protocol, where I establish a connection from one host, establishes a connection to another host, and they can communicate to each other, sending arbitrarily long streams of bytes to each other. And so the connection is, and two hosts that can talk to each other. And each of those endpoints is referred to as a socket. And so, and a socket is both an IP address and what’s called a port number. So there’s a byte 16 b number for every that’s referred to as its port.<br>我们思考它的方式是根据所谓的TCP。它说面向连接的协议，其中我从一个主机建立连接，建立到另一个主机的连接，它们可以相互通信，相互发送任意长的字节流。因此连接是这样的，两个主机可以相互通信。每个端点都被称为一个套接字。因此，套接字既是IP地址又是所谓的端口号。因此，每个被称为端口的字节都有一个16 b的数字。</p>
<p>发言人   38:03<br>And the reason for that is just because I’m talking to a particular machine, that machine can support different services, it can provide SSH connections, it can provide FTP connections, it can a mail, it can host a web server. So a particular machine might have a multitude of different services. And so those are differentiated from each other with what are called port numbers. And similarly, Isaac client might have connections to dozens of hosts going at any given time.<br>其原因仅仅是因为我在与特定的机器交谈，该机器可以支持不同的服务，它可以提供SSH连接，它可以提供FTP连接，它可以发送邮件，它可以托管web服务器。因此，一台特定的机器可能有多种不同的服务。因此，这些彼此之间的区别在于所谓的端口号。类似地，Isaac客户端可能在任何给定时间都有与数十个主机的连接。</p>
<p>发言人   38:36<br>I’m cruising the web. I’m doing all that different stuff, and that’s all differentiated at the point. And there’s different ports associated with your different programs that are running. And so a port that is a 16 b integer that identifies which particular endpoint is being communicated with either the client side of the server side. And typically at the client side, these are assigned dynamically and they’re referred to as ephemeral ports, meaning they only are assigned for the limited duration that you have a connection with, that, that you’re maintaining that connection. And then there has to be some way, if I’m going to contact and I want to know, the DNS will tell me what the IP addresses of say Google dot com, but I have to know that am I communicating with its web service, which is port 80 or Https?<br>我正在浏览网页。我正在做所有不同的事情，而这一切都在这一点上有所区别。并且有不同的端口与正在运行的不同程序相关联。因此，端口是一个16 b整数，用于标识哪个特定端点正在与服务器端的客户端通信。并且通常在客户端，这些是动态分配的，它们被称为临时端口，这意味着它们只在您与之建立连接的有限时间内分配，即您维护该连接。然后必须有某种方式，如果我要联系并且我想知道，DNS会告诉我Google dot com的IP地址，但我必须知道我是否与其网络服务通信，即端口80或Https？</p>
<p>发言人   39:38<br>A secure socket is a different port number. So which service I’m asking for? And there’s a standard list, what are called well-known ports that are that I can contact at the server end to get the particular service I’m looking for and those are assigned there’s a big list of port assignments and so again, that’s part of the whole set of. Internet standards is the identifiable for the different ports, what services those are and how those particular protocols work. So when I have a connection then?<br>安全套接字是不同的端口号。那么我要求的服务是什么？并且有一个标准列表，称为众所周知的端口，我可以在服务器端联系它们以获取我正在寻找的特定服务，并且这些端口分配有一个很大的端口分配列表，因此，这是整个集合的一部分。互联网标准是对不同端口的可识别性，这些端口是什么服务以及这些特定协议如何工作。那么，当我有联系时？</p>
<p>发言人   40:30<br>As I mentioned, think of it as a connection, then as a link between two machines based on some known port, typically at the server end, and dynamically assigned or ephemeral port assigned at the coin end. And I can refer to them. That connection then is identified by the combination of the hosts at the two ends and the ports that they’re using.<br>正如我所提到的，将其视为一个连接，然后将其视为基于某个已知端口 (通常在服务器端) 和动态分配或临时端口 (在硬币端分配) 的两台机器之间的链接。我可以参考他们。然后，该连接由两端的主机和它们正在使用的端口的组合来标识。</p>
<p>发言人   41:01<br>And in general, then, it’s the job of the kernel to differentiate the different connections that are coming into a machine and figure out which software, which process to wake up data when. Some data arrives from another machine in which actual program running on that machine will make use of that data. And that’s done by associating for each of the ports a particular process executing program that’s going to handle those particular requests. And it’s totally possible for a client to be interacting with a single server over different ports. But those are considered to be different connections. And so they don’t really interfere with each other.<br>一般来说，内核的工作就是区分进入机器的不同连接，并找出哪个软件哪个过程在什么时候唤醒数据。一些数据来自另一台机器，在该机器上运行的实际程序将使用该数据。这是通过为每个端口关联一个特定的进程执行程序来处理这些特定的请求。客户端完全有可能通过不同的端口与单个服务器进行交互。但这些被认为是不同的联系。所以它们实际上并不互相干扰。</p>
<p>发言人   42:07<br>So that’s what I mentioned is this is what we refer to as sockets programming or the socket interface. And it was developed sort of as the internet was evolving in the late 70s and early 80s.<br>这就是我提到的，这就是我们所说的套接字编程或套接字接口。它的发展类似于互联网在70年代末和80年代初的发展。</p>
<p>发言人   42:22<br>So socket then, as I said, is certain, logically, one of the two ends of a connection. And from an application point of view, you’ll see it as a file descriptor, just the low level file stuff that you’ve already seen that you can do reading and writing from. And so that’s a sort of mental model that is provided by the socket interface. But it’s a very different the actual implementation of network. When you write to a socket, it’s firing up all kinds of networks. Whereas you write to a disk, it’s operating a disk controller. So at the hardware level, and even at the lower levels of software, they’re very different beasts. But you as an application programmer, see some commonality there.<br>所以套接字，正如我所说的，从逻辑上讲，是连接的两端之一。从应用程序的角度来看，您会将其视为文件描述符，只是您已经看到的低级文件内容，您可以从中进行读取和写入。所以这是一种由套接字接口提供的心理模型。但它与网络的实际实现非常不同。当您写入套接字时，它会触发各种网络。而你写入磁盘时，它正在操作磁盘控制器。所以在硬件层面，甚至在较低级别的软件上，它们也是非常不同的野兽。但作为一名应用程序员，你会看到一些共性。</p>
<p>发言人   43:15<br>Okay, so let’s jump right into the API. And again, this is a place where you’ll wish you were programming in a language that had type hierarchy, but you aren’t. You’re programming in C, so A, there’s 1 zillion strux that you kind of have to get familiar with, but one’s called a sock adder, and basically it’s just 16 B worth of stuff where the only thing that’s special here is the leading tube bytes designate what type of socket this is. In particular, it would be different whether it’s a TCP socket, an Ipv 6 socket UDP socket, and all those will have different numbers, a different constant in there that tells you which type of socket it is, and then at the high level socket, a lot of the programs don’t need to know which type of connection this is. They can just deal with. They basically call other software to deal with it.<br>好的，让我们直接进入API。再次强调，这是一个你会希望用一种有类型层次结构的语言编程的地方，但你不是。你正在用C编程，所以有1个无数的strux你必须熟悉，但有一个叫做袜子加法器，基本上它只有16 b的价值，这里唯一特别的是前导管字节指定了这是什么类型的套接字。特别是，无论是TCP套接字，Ipv 6套接字，UDP套接字，所有这些都将具有不同的数字，其中一个不同的常数告诉您它是哪种类型的套接字，然后在高级套接字处，很多程序不需要知道这是哪种类型的连接。他们只能处理。他们基本上会调用其他软件来处理它。</p>
<p>发言人   44:20<br>So that’s why it’s referred to as being family specifics, and then the socket stuff isn’t even necessarily referred to the internet, the capital I internet, and so there’s a more specific one called a sock add or underscore in that is used for Ipv 4 sockets. Not Ipv 6. And so in particular, it fills in fields. One is called the port, which as I mentioned, is 16 b. And then the IP address, the 4 B IP address, both of which are in, even if you’re running the software on a x 80 s machine, these should be in big Ind in order.<br>这就是为什么它被称为家庭细节，然后套接字的东西甚至不一定被称为互联网，首都互联网，因此有一个更具体的叫做袜子添加或下划线的东西用于Ipv 4套接字。不是Ipv 6。因此，特别地，它填充了字段。一个被称为端口，正如我所提到的，它是16 b。然后是IP地址，即4个IP地址，两者都在，即使您在x 80 s机器上运行软件，这些也应该按顺序进行。</p>
<p>发言人   45:08<br>And you’ll see that this is what I mean. This is sort of a C’s version of subtyping. If you know something like C++ or Java or a language with type inheritance that you can think of it as a sock adder in as sort of a subclass of a sock header, it has more information it’s compatible with, but has more information then a sock adder. And then there’s another type of, for Ipv 6 has a different kind of struck that they fill in for its information, and then they padded out with 8 B of zeros just because this particular protocol doesn’t require the full 16 B.<br>你会明白这就是我的意思。这是一种C版本的子类型划分。如果你知道像C ++ 或Java这样的东西，或者一种类型继承的语言，你可以把它看作是袜子头的子类，它有更多的信息兼容，但是比袜子加法器有更多的信息。然后还有另一种类型的，因为Ipv 6有一种不同的敲击，他们为其信息填写，然后他们用8 B的零填充，因为这个特定的协议不需要完整的16 B。</p>
<p>发言人   45:56<br>Okay, so this is sort of what it looks like to operate a full blown client server system from a programmer’s perspective. And we’re going to, for the rest of today and all of Thursday, go through all these steps. And you as a programmer are actually going to, you have to understand each of these steps, what they do, what they mean, and how to use them. The good news, there’s some pretty standard patterns here. And so you can often grab some existing code, say, out of the book to use that will make this not as painful as it might look. So, but the overall idea of this picture then is, sorry, I can’t get used to the fact my remote doesn’t work.<br>好的，从程序员的角度来看，这就是操作一个完整的客户端服务器系统的样子。在今天剩下的时间和周四的所有时间里，我们将经历所有这些步骤。而作为一名程序员，你实际上必须了解这些步骤，它们做什么，它们的含义以及如何使用它们。好消息是，这里有一些非常标准的模式。所以你可以经常从书中抓取一些现有的代码来使用，这将使它不像看起来那么痛苦。所以，但是这张照片的总体思路是，抱歉，我无法适应我的遥控器不工作的事实。</p>
<p>发言人   46:48<br>On the right hand side refers to the steps that the server has to go through, and the left hand side is what the client does. So the upper right is what it takes to set up a server. That is then a program that’s running there, ready to receive connections from a client and perform various services. And so obviously, before the client can do anything, the server has to exist. So that has to be the first step in setting things up. And then we’ll fire up a client that will make use of this service. And then there’ll be what’s referred to as a session, meaning a kind of back and forth communication between the client and server, doing whatever they’re going to do, not specific to any particular application. And like I said, it will involve, you’ll see Rio underscore.<br>右侧指服务器必须经过的步骤，左侧指客户端执行的操作。右上角是设置服务器所需的步骤。这是一个运行在那里的程序，准备接收客户端的连接并执行各种服务。所以很明显，在客户端可以做任何事情之前，服务器必须存在。所以这必须是设置事情的第一步。然后我们将启动一个使用此服务的客户端。然后会有所谓的会话，意思是客户端和服务器之间的来回通信，做任何他们要做的事情，而不特定于任何特定的应用程序。就像我说的，这将涉及，你会看到Rio下划线。</p>
<p>发言人   47:45<br>Remember, those were reliable IO functions that we talked about as part of the Unix IO. So it’s a way to read and write. And handle some of the quirks of low level IO. But basically, this is sending and receiving messages over the internet. And then once that’s done, typically then the client will close its connection, sort of the equivalent of hanging up its phone and say OK I’m done. And then sometime later, or maybe never, depending on what kind of web service this is, if the server wants to shut down, it has its own collection of calls that it makes to stop that service. So anyways, just to kind of give you the landscape of what this picture means.<br>请记住，这些是我们作为Unix IO的一部分谈到的可靠的IO函数。所以这是一种阅读和写作的方式。并处理低级IO的一些怪癖。但基本上，这是通过互联网发送和接收消息。然后一旦完成，通常客户端会关闭其连接，类似于挂断电话并说 “好的，我已经完成”。然后一段时间之后，或者也许永远不会，这取决于这是什么类型的web服务，如果服务器想要关闭，它会有自己的调用集合来停止该服务。所以无论如何，只是为了让你了解这张图片的意义。</p>
<p>发言人   48:44<br>So we’re going to sort of jump into the middle, the top level, and we’ll focus. Actually, which we focus on, Well, we’ll talk to some level in parallel because there’s a lot of commonality, as you can see, between what goes on with the server and what goes on with the client. And so actually the top level call, this one called Get adder info, is the way that it sort of. Initiates things and actually does the lookup to map from a domain name to an IP address. So we’ll cover that later.<br>所以我们要跳到中间，顶层，然后我们会专注。实际上，我们关注的是，嗯，我们将在某个层面上并行讨论，因为正如您所看到的，在服务器和客户端之间存在很多共性。所以实际上顶级调用，这个称为Get adder info，就是它的方式。发起一些事情，并实际进行查找以从域名映射到IP地址。所以我们稍后会覆盖它。</p>
<p>发言人   49:31<br>So the first step in on either side, then in creating a connection is a call to a function called socket. And the reason I wanted a blackboard was to help you keep track of this.<br>所以在任何一方的第一步，然后在创建连接时是调用一个名为套接字的函数。我想要一块黑板的原因是为了帮助你跟踪这个。</p>
<p>发言人   50:08<br>So the first call doesn’t do much. And that’s the function call is socket, but. It only happens within the application. It doesn’t make a use of any part of the operating system, doesn’t send anything over the network.<br>所以第一个电话没有做什么。那就是函数调用是套接字，但是。这只发生在应用程序中。它不使用操作系统的任何部分，也不通过网络发送任何内容。</p>
<p>发言人   50:28<br>And the idea is to basically say, hey, I want to create a socket. And it’s given three arguments, the first of which is AF underscore inett All these uppercase names are constants that are built in that are included in the various h files that you include in writing this code. And AF underscore, I just means it say Ipv 4, so 32 b addresses. And then the second parameter says, you want a sock stream. And that refers to a TCP connection. It’s referred to as a stream connection because, like I said, you get to send as many bytes as you like, a stream of bytes in either direction and then.<br>这个想法基本上是说，嘿，我想创建一个套接字。并且它给出了三个参数，其中第一个是AF下划线inett，所有这些大写名称都是内置的常量，这些常量包含在您编写此代码时包含的各种h文件中。和AF下划线，我只是意味着它说Ipv 4，所以32 b地址。然后第二个参数说，你想要一个sock流。这指的是一个TCP连接。它被称为流连接，因为就像我说的，你可以发送任意多的字节，字节流在任何方向上，然后。</p>
<p>发言人   51:19<br>Zero protocol. Well, I guess it must not be very interesting because I set it to 0. So we don’t need to do anything. In this particular case.<br>零协议。嗯，我想它一定不是很有趣，因为我将它设置为0。所以我们不需要做任何事情。在这种特殊情况下。</p>
<p>发言人   51:30<br>There are man pages on this, by the way, which if you just tried to learn all sockets programming by reading man pages, you’d go crazy. But once you kind of have the idea of it, the man pages are pretty useful. And then the next part, you’ll see we’re looking only now on the server side. It’s called bind.<br>顺便说一下，这里有手册页，如果你只是通过阅读手册页来学习所有套接字编程，你会发疯的。但是一旦你有了这个想法，手册页就非常有用了。然后在下一部分中，你会看到我们现在只在服务器端寻找。这叫做绑定。</p>
<p>发言人   52:02<br>What bind does then is that specific then to a server? And now this is this interfaces to the kernel I want to.<br>那么，什么绑定是特定于服务器的呢？现在这是我想要的内核接口。</p>
<p>发言人   52:24<br>Designate which IP address? Let me just, so I’m going to cheat a little bit by making sure I don’t see anything that’s not true. Yeah I’m right, sorry. I just wanted to make sure bind actually. Tells you? Oh, excuse me, You’ll see that it the call to socket returns an int, but what it’s returning is a file descriptor.<br>指定哪个IP地址？让我来，我打算作弊一点，确保我没有看到任何不真实的东西。是的，我是对的，抱歉。我只是想确保绑定。告诉你？哦，对不起，你会发现调用socket返回一个int，但它返回的是一个文件描述符。</p>
<p>发言人   52:58<br>Remember we said you refer to a file, a low level of file, just by an integer ID, typically a small integer value. There’s some standard ones for standard in, standard out standard air. And then beyond that, they’re just designed incrementally. So socket will return a number that you then use to refer to this as a file. So bind, then you pass in the name of your socket file descriptor, and you provide whether these socket at or ends. And I’m using the Not Sa as a shortcut for sock Add sock adder.<br>记得我们说过，你指的是一个文件，一个低级文件，只需要一个整数账号，通常是一个小的整数值。有一些标准的标准输入，标准输出标准空气。然后除此之外，它们只是逐步设计的。套接字将返回一个数字，您可以使用该数字将其引用为文件。所以绑定，然后您传入套接字文件描述符的名称，并提供这些套接字是在还是结尾。并且我正在使用非Sa作为袜子添加袜子加法器的快捷方式。</p>
<p>发言人   53:52<br>And then you have to also say what the length of the address is. So in the case of Ipv 4, that would be 4. But you don’t usually use that number directly. There’s we’ll talk about it. But that top level call called Get Editor info is a relatively new API was created and is in this addition to the book, but not in previous ones.<br>然后你还必须说出地址的长度。在Ipv 4的情况下，这将是4。但你通常不直接使用那个数字。我们会谈论它。但是称为Git Editor info的顶级调用是一个相对较新的API被创建，并且是在本书的这个补充中，而不是在以前的书中。</p>
<p>发言人   54:14<br>Is become now the standard way that you get all the parameters that you’re supposed to pass into all these different calls? And the idea of it then is it’s a pretty small adjustment to then write code that’s good for either Ipv 4 or Ipv 6. So you don’t normally give the actual number from that. You get it from another place and pass in.<br>现在成为您获取所有应该传递给所有这些不同调用的参数的标准方式？然后它的想法是，编写适合Ipv 4或Ipv 6的代码是非常小调整的。所以你通常不会给出实际的数字。你从另一个地方得到它并通过。</p>
<p>发言人   54:41<br>So binding then. Is it’s a kernel call?<br>那么具有约束力。这是一个内核调用吗？</p>
<p>发言人   55:05<br>That designates which particular service this program is going to be hosting or which will be the server for. And that’s given by its port number.<br>指定该程序将托管哪个特定服务或哪个服务器。这是由其端口号给出的。</p>
<p>发言人   55:27<br>And then the next step is to listen. And that’s just a call that says.<br>然后下一步是倾听。那只是一个电话而已。</p>
<p>发言人   55:44<br>Well, now convert this socket to a listening socket, which you need as a server.<br>好的，现在将这个套接字转换为监听套接字，这是您作为服务器所需要的。</p>
<p>发言人   55:58<br>So it’s a way of telling the kernel that this will. Be a server star.<br>所以这是一种告诉内核这将会发生的方式。成为服务器明星。</p>
<p>发言人   56:11<br>So obviously bind and Wi are related ideas, but you have to do both steps and in that particular order to create a listening socket or one for a server. And then the final part of that operator is to say accept.<br>所以显然bind和Wi是相关的概念，但是你必须执行这两个步骤，并以特定的顺序创建一个监听套接字或者一个用于服务器的套接字。然后该运算符的最后一部分是说接受。</p>
<p>发言人   56:36<br>And.<br>而且。</p>
<p>发言人   56:43<br>That means OK, now we’ve established this. Now I’m actually ready to receive phone calls. Essentially what it’s is this is the final step to say, okay, this one’s ready to accept connection requests. And it has a similar.<br>这意味着好的，现在我们已经建立了这个。现在我已经准备好接听电话了。基本上它是什么，这是最后一步说，好的，它已经准备好接受连接请求了。它也有相似之处。</p>
<p>发言人   57:06<br>Set of arguments to it socket, but slight difference. And now the interesting thing is, except we’ll return yet another file descriptor. So the first file descriptor is the sort of generic and. Basically, accept will just hang there and wait until some client makes a connection, and when it does, then it will set up a new socket and with a new file descriptor, then the server communicates to the client via that one. And I’ll talk about why it’s a different file descriptor in just a second. Over on the client side goes through similar steps of socket, but it doesn’t have to bind or listen, except because this is a client. And instead, what it does is it makes a call to connect. So let me finish this off.<br>套接字的参数集合，但略有不同。现在有趣的是，除了我们将返回另一个文件描述符。所以第一个文件描述符是通用的。基本上，accept只会挂在那里并等待某个客户端建立连接，当它建立连接时，它将设置一个新的套接字并使用新的文件描述符，然后服务器通过该套接字与客户端通信。我马上就会讨论为什么它是不同的文件描述符。在客户端上，执行类似的套接字步骤，但它不必绑定或侦听，除非这是一个客户端。相反，它所做的是拨打连接电话。那么让我把这件事说完。</p>
<p>发言人   58:25<br>So these are all on the server side.<br>所以这些都在服务器端。</p>
<p>发言人   58:36<br>And on the client side? It will make a call to connect. And its job of that is from a client side, is to set up a connection to a server.<br>在客户端？它将拨打电话连接。它的工作是从客户端开始，建立与服务器的连接。</p>
<p>发言人   59:19<br>It is argument. It’s a little easier to understand how connect works. So in particular, the call to socket that was made beforehand returns a file descriptor. And what says is I want to on that, using that particular socket, connect to this gives a combination of an address and a port number, and it has to give this address length, which I said, like I said, as before, it’s usually that number is filled in using the return value of Git add or info. But that’s sort of the equivalent of placing the call then. And it returns just a code, which is whether the connection was successful or not.<br>这是一种争论。理解连接的工作原理会更容易一些。因此，特别是预先进行的对套接字的调用会返回一个文件描述符。说的是，我想在上面使用特定的套接字，连接到这个给出地址和端口号的组合，它必须给出这个地址长度，就像我之前说的那样，通常，数字是使用Git add或info的返回值填充的。但这在某种程度上相当于打电话。并且它只返回一个代码，即连接是否成功。</p>
<p>发言人   01:00:09<br>So let me just talk about these different parts and what it all means when you set up a connection. So when the. Server went through bind and listen. It created a listening port from that, which is the one that it’s listening for connection requests on. And then the client, when it called socket, it was given a particular file descriptor for that, that socket, and it sends out a connection request that goes out over the network and lands the server. And then the kernel hands it off to the program that’s running on that particular port and hands it off to that call will be handled by the call to accept by the server. And then, as I mentioned, except actually returns a new file descriptor, which the server will then use as its connection point to this particular client.<br>所以让我谈谈这些不同的部分，以及当您建立连接时这一切的意义。所以当。服务器经历了绑定和侦听。它从那个端口创建了一个监听端口，这是它监听连接请求的端口。然后，当客户端调用套接字时，它被赋予了一个特定的文件描述符，即那个套接字，它发出一个通过网络发出的连接请求并登录服务器。然后，内核将其交给运行在该特定端口上的程序，并将其交给该调用，该调用将由服务器接受的调用来处理。然后，正如我提到的，除了实际上返回一个新的文件描述符，服务器将使用它作为连接到这个特定客户端的连接点。</p>
<p>发言人   01:01:23<br>And the theory of that is you want to be able to, in general, as a server, be handling multiple clients at the same time if I’m communicating with. Google or Amazon, you should be able to do so at the same time. So you want the possibility of from a single host to be able to serve multiple clients. And that’s why they’re all assigned different file descriptors at the server end for that particular connection. So you can think of it as the listening file descriptor is just listening for incoming requests for connections. But once it sets up a session and communicates back and forth, those are going through different ports on the server side of things or different file descriptors. I’m sorry, same port, different file descriptors from the software that’s running on the server.<br>其理论是，如果我在与服务器通信，您通常希望能够同时处理多个客户端。谷歌或亚马逊，你应该能够同时这样做。因此，您希望从单个主机中能够为多个客户端提供服务。这就是为什么在服务器端为该特定连接分配不同的文件描述符的原因。因此，您可以将其视为侦听文件描述符，仅侦听传入的连接请求。但是一旦它建立了一个会话并来回通信，这些就会通过服务器端的不同端口或不同的文件描述符。对不起，相同的端口，不同的文件描述符与服务器上运行的软件不同。</p>
<p>发言人   01:02:26<br>Okay, and then during the actual communication, then as I mentioned, it uses reads and writes as a way to send and receive messages. And that goes on for as long as you and according to whatever particular protocol is being supported by this application. And in the end, then? When the client is done, it closes the request and what that looks like from the server and is it tries to read from a file and it receives an end to file signal instead. And that tells the server OK, this particular connection is gone. And so now it will close that particular one.<br>好的，然后在实际通信中，正如我所提到的，它使用读取和写入作为发送和接收消息的方式。而且这种情况会持续很长时间，并且根据此应用程序支持的特定协议而定。最后呢？当客户端完成后，它会关闭请求，从服务器端看是什么样子，它会尝试从文件中读取，并接收到一个结束文件的信号。这就告诉服务器，这个特定的连接已经消失了。所以现在它将关闭那个特定的。</p>
<p>发言人   01:03:22<br>As this picture shows here, potentially, the server could loop back around and accept a connection from another program. In fact, this can be done. This is what we call a serial or an it a serial server where it can only manage one connection request at a time. And when we get later in the course and we talk about multithreading, we’ll be able to set it up so this thing can start accepting requests for another connection, even while it’s handling one particular client. But anyways, what it will look like is the server will read, attempt to read, it will get an end file, it will close that particular connection, and it will go back and it will accept a new connection from a new client.<br>正如这里的图片所示，服务器可能会循环回来并接受来自另一个程序的连接。事实上，这是可以做到的。这就是我们所说的串行或串行服务器，它一次只能管理一个连接请求。当我们在课程后期讨论多线程时，我们将能够对其进行设置，以便此设备可以开始接受另一个连接的请求，即使它正在处理一个特定的客户端。但是无论如何，它看起来像服务器将读取，尝试读取，它将获取一个结束文件，它将关闭那个特定的连接，然后它将返回并接受来自新客户端的新连接。</p>
<p>发言人   01:04:17<br>Okay I’m going to jump ahead and actually start talking about some slides from that. If you look online, they’re actually from Thursday’s lecture. There’s a lot of ground to cover in that lecture and I’d like to get a little head start. So I mentioned this function called get adder info, which is sort of the modern way in C, at least find information about that deals with all the funkiness of host names, host addresses, all the conventions about ports and some of these various structures and things like that. And the advantage of doing it instead of the old way is, first of all, now it of unifies.<br>好的，我要跳到前面，实际上开始谈论其中的一些幻灯片。如果你上网看，它们实际上是来自星期四的讲座。那堂课有很多内容要涵盖，我想先做点什么。所以我提到了这个叫做获取加法器信息的函数，这是C语言中的现代方式，至少可以找到有关该函数的信息，涉及主机名、主机地址、端口的所有约定以及一些不同的结构和类似的东西。这样做的好处是，首先，现在它是统一的。</p>
<p>发言人   01:05:04<br>Ipv 4 and Ipv 6 have very similar looking interfaces. And it’s fairly easy to write code that can handle either. And the other was there is problems with these old ones that they were designed in an era before multithreading. And so they have very statically allocated buffers, which gave a lot of bad conditions that you had to watch out for in writing code and were prone to errors of various sorts. And so this new format, it’s actually harder to use in many levels. It can’t hide away as many details as it used to, but it has the advantage. It works better in a multithreaded environment. The other thing that makes it hard is it’s trying to be sort of the kitchen sink of protocol managers, and that makes it a little bit nasty and messy.<br>Ipv 4和Ipv 6有着非常相似的界面。而且编写能够处理这两种情况的代码相当容易。另一个问题是这些旧的问题，它们是在多线程之前的时代设计的。因此，它们具有非常静态分配的缓冲区，这给了你在编写代码时必须注意的许多不良条件，并且容易出现各种错误。因此，这种新格式实际上在许多关卡中都很难使用。它无法像以前那样隐藏那么多细节，但它有优势。它在多线程环境中工作得更好。另一个让它变得困难的事情是它试图成为协议经理的厨房水槽，这使得它有点肮脏和混乱。</p>
<p>发言人   01:05:58<br>And so we’re only going to sort of focus in on the parts that we really need to make use of for this course.<br>因此，我们只会集中讨论本课程真正需要利用的部分。</p>
<p>发言人   01:06:06<br>So in particular, there’s this function called get adder info, where the information you’re passing is a host, which can be either it’s a string as it shows most of these are car stars or actual real strings, not fixed strings. It used to be back in the old days, you used Kara stars, a generic pointer because there weren’t void stars. But these are actual strings. So you give the name, like the domain name of a host, or you can give the dotted decimal name, but written as sequence of characters, 128 dot, so forth, a service, for example, this is Ipv 4 TCP service. Some other information that’s associated with this particular connection, they refer to as hints.<br>所以特别地，有一个名为get adder info的函数，其中您传递的信息是一个主机，它可以是一个字符串，因为它显示大多数都是汽车明星或实际的真正字符串，而不是固定字符串。它曾经是在过去，你使用卡拉星，一个通用的指针，因为没有虚空星。但这些是实际的字符串。因此，您可以提供名称，就像主机的域名一样，或者您可以提供点分十进制名称，但以字符序列形式书写，128点，依此类推，例如，这是Ipv 4 TCP服务。与这个特定连接相关的一些其他信息，它们称为提示。</p>
<p>发言人   01:06:59<br>Again, this is trying to be a very generic looking call. And then you pass in a pointer and it will fill in and return back a pointer to a data structure, which is essentially the way it’s returning results back to you. And then associated with that is a call called free adder info that will then deallocate the space that’s used by this data structure from the result. And then there’s one called get add or info string error, which letsgo interpret the various error codes that get created by this routine, the value that it returns.<br>再次强调，这是试图成为一个非常通用的呼叫。然后您传入一个指针，它将填充并返回一个指向数据结构的指针，这基本上就是它将结果返回给您的方式。然后与之关联的是一个名为自由加法器信息的调用，它将从结果中释放此数据结构使用的空间。然后还有一个名为get add或info string error的程序，letsgo会解释这个例程创建的各种错误代码，即它返回的值。</p>
<p>发言人   01:07:42<br>Let’s just look a little about this. And so the result let’s returned by get add or info is the link twist. That is null terminated, which is like most winquist, where it gives some combination.<br>让我们稍微看看这个。因此，让我们通过get add或info返回的结果是链接扭曲。这是以null结尾的，就像大多数的winquist一样，它给出了一些组合。</p>
<p>发言人   01:08:03<br>Name of this particular? Some naming information for the first top level 1 is what I showed you. The canonical name for this particular IP address. And then it gives some address information, which is. In Ipv 4, then it will encode the IP address and it has a next pointer to change this link interest together.<br>这个特别的名字？我向您展示了第一个顶级1的一些命名信息。此特定IP地址的规范名称。然后它会提供一些地址信息。在Ipv 4中，它将对IP地址进行编码，并且有一个下一个指针可以一起更改此链接兴趣。</p>
<p>发言人   01:08:35<br>And so this is actually one interesting thing about this is it takes care of that many, too many mapping potentially of. Name So if I give for example Google do Com, it will return a linked list of all however many you saw with Twitter, it was returning about four different addresses. So this will return actually five missed entries. The first will be the canonical name, and then it will give each of the four IP addresses that’s relevant at this particular time.<br>所以这实际上是一个有趣的事情，它照顾了太多可能的映射。所以如果我举个例子Google do Com，它将返回一个链接列表，其中包含你在Twitter上看到的所有地址，它返回了大约四个不同的地址。所以这实际上将返回五个错过的条目。第一个将是规范名称，然后它将给出在特定时间相关的四个IP地址中的每一个。</p>
<p>发言人   01:09:12<br>And then you as a programmer then sort of walk this list. You step down this list, and typically try to use each address one after the other. And if you fail on one, then you try next and try the next until you hit the end of the list, and then you say, oops, can’t do it. And that goes whether you’re writing a client or a server.<br>然后你作为一名程序员，就像走过这个清单一样。您向下列出此列表，通常一个接一个地尝试使用每个地址。如果你在一个项目上失败了，那么你就尝试下一个项目，并尝试下一个项目，直到你到达列表的最后，然后你说，哎呀，做不到。无论您是编写客户端还是服务器，都是如此。</p>
<p>发言人   01:09:37<br>So that adder info, let’s look back at what that is. So add info then is what gets returned is a list of adder info structs. And so the adder infostrada contains various fields.<br>所以那个加法器的信息，让我们回顾一下那是什么。所以添加信息，那么返回的是一个加法器信息结构列表。因此，加法器infostrada包含各种字段。</p>
<p>发言人   01:10:00<br>Which talks about what type of? Data is here. What type of socket is it? What its canonical name is, how long are its addresses? You saw that it’s an argument to some of the calls, a pointer to a sock adder stru that the way that is encoded for Ipv, what we’ve already seen in sock adders is a sort of low levels data structure that gets used and then a next pointer to chain the link to together. And so you’ll see some of these are the arguments then you will use to pass into the other functions like bind and with and connect.<br>哪一个谈论什么类型的？数据在这里。插座是什么类型的？它的规范名称是什么，它的地址有多长？你看到了一些调用的参数，一个指向袜子加法器结构的指针，它是以为Ipv编码的方式编码的，我们在袜子加法器中已经看到的是一种低级数据结构，它被使用，然后是下一个指针将链接链接到一起。所以你会看到其中一些参数，然后你将用来传递给其他函数，比如bind和连接。</p>
<p>发言人   01:10:51<br>And then there’s another version called get name info, which you use when you’ve got an IP address and you want to find what is domain name. Because you remember that mapping is also potentially a one domain. There can be multiple domain names associated with it. And so it has a general thing. We’ll just look right now at get adder info. So just as an example of how you’d write code to make use of this, essentially just as a way of probing the DNS server is, I want to set up an argument, a call to get adder info where string I’m going to pass the name is whatever I type in to this application to Maine.<br>然后还有另一个叫做获取名称信息的版本，当你有一个IP地址并且想要找到什么是域名时，你会使用它。因为你记得映射也可能是一个领域。可以有多个与之关联的域名。所以它有一个普遍的事情。我们现在就来看看获取加法器信息。因此，作为如何编写代码来利用这个的一个例子，基本上只是作为探测DNS服务器的一种方式，我想设置一个参数，调用以获取加法器信息，其中字符串我将传递名称是我在此应用程序中输入的任何内容。</p>
<p>发言人   01:11:52<br>For hints, just passes a bunch of zeros and list P again. This will just be a pointers that I haven’t actually.<br>对于提示，只需传递一堆零并再次列出P。这只是一个指针，我实际上没有。</p>
<p>发言人   01:12:14<br>So you’ll notice hints is actually a struct itself, whereas list p and star p are list P and P are just pointers destructs. They don’t have any allocated data. So the hints I’m just going to fill in that struct with all zeros because I don’t really need to provide any hints.<br>所以你会注意到，提示实际上是一个结构本身，而列表p和星号p是列表P，而P只是指针析构。他们没有任何分配的数据。所以我只需要用全零填充那个结构的提示，因为我真的不需要提供任何提示。</p>
<p>发言人   01:12:31<br>I am telling you that I want an Ipv 6 TCP connection here. And then so what it will do is it will return back what returns an error code, but it will fill in return to me a pointer to this linked twist data structure I showed before. And now I can step through that list using standard link list code and make calls to the get name info function, which will return back domain names. And then when it’s all done, I have to free up that list that got returned. Otherwise, I create memory stuff. So just as a demo.<br>我告诉你，我想在这里有一个Ipv 6 TCP连接。然后，它将返回返回错误代码的内容，但它将为我填充一个指向我之前展示的链接twist数据结构的指针。现在我可以使用标准链接列表代码逐步浏览该列表，并调用获取名称信息功能，该功能将返回域名。然后当一切都完成后，我必须释放那个返回的列表。否则，我会创造记忆的东西。所以只是作为一个演示。</p>
<p>发言人   01:13:31<br>What, where am I? Oh, host info area.<br>什么，我在哪里？哦，主机信息区域。</p>
<p>发言人   01:13:42<br>So you can think of it, this is like a. And not very fancy implementation of NS lookup. So the kind of stuff we already saw before, but let’. All it’s returning are the different addresses. And one of the things that I found curious is it returns them in the same order all the time. Instead of with its hookup, it kept changing it. And I think that has to do with caching.<br>所以你可以想象一下，这就像一个。并且不是很花哨的NS查找实现。所以我们之前已经看到的那种东西，但是让我们。它返回的只是不同的地址。我感到好奇的一件事是它总是以相同的顺序返回它们。它不停地改变它，而不是改变它的连接。我认为这与缓存有关。</p>
<p>发言人   01:14:29<br>No, that changed. I know, it’s kind of interesting. You might want to play with this code. It’s kind of you can see what’s going on in different places.<br>不，那改变了。我知道，这有点有趣。你可能想玩这个代码。你可以看到不同地方发生的事情。</p>
<p>发言人   01:14:48<br>And so you can see, though, that it’s basically getting the same kind of information that you would from nslookup. It’s really just querying the DNS server to do that. But that’s the start of what some of this code looks like.<br>因此，您可以看到，它基本上获得了与从nslookup中相同类型的信息。这实际上只是查询DNS服务器来做到这一点。但这就是这段代码的开头。</p>
<p>发言人   01:15:15<br>One of the things, by the way, when you’re writing your own code, you often make use of what’s called localho. And that always just refers to the machine that you’re running on. And it always has this particular IP address. So that address just refers to the machine. And as a programmer, you do all your testing on one machine. You just set up both the client and the server on the same machine and play with it. Local host is a very useful way of doing code development. And as this shows, you can request to stmp for others. Thanks GI, and you can also, by the way.<br>顺便说一下，当你编写自己的代码时，你经常使用所谓的localho。这总是只指你正在运行的机器。它总是有这个特定的IP地址。因此，该地址仅指机器。作为一名程序员，你在一台机器上完成所有的测试。你只需在同一台机器上设置客户端和服务器并使用它。本地主机是一种非常有用的代码开发方式。正如这所显示的，您可以请求为其他人stmp。谢谢镀锌，顺便说一下，你也可以。</p>
<p>发言人   01:16:03<br>Always give a dotted decimal address.<br>始终提供带点分的十进制地址。</p>
<p>发言人   01:16:13<br>And I’m just making it up here. And it’s not very interesting because it returns back to the same address. It’s more interesting to run ansco up on that.<br>我只是在这里制造出来的。这不是很有趣，因为它返回到相同的地址。在这上面运行ansco更有趣。</p>
<p>发言人   01:16:32<br>So? That just gives you a sense. And as you’ve seen, this code is pretty messy stuff to work with structs, you have to initialize. You don’t initialize, you pass pointers. And so the code always looks a bit Crufts. That’s sort of the interfaces, it exists, and you’ll just have to get somewhat comfortable with it. So that will do us for you today. Then, thanks.<br>所以呢？这只会给你一个感知。正如您所看到的，这段代码对于结构来说是相当混乱的东西，您必须初始化。你不初始化，你传递指针。所以代码看起来总是有点粗话。这就是接口的种类，它存在，你只需要稍微适应它即可。这样我们今天就可以了。那么，谢谢。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>深入理解计算机系统 022-Network Programming, Part I</div>
      <div>http://example.com/2025/10/12/15213-022/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月12日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/12/15213-023/" title="深入理解计算机系统 023-Network Programming, Part II">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">深入理解计算机系统 023-Network Programming, Part II</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/12/15213-021/" title="深入理解计算机系统 021-Dynamic Memory Allocation, Advanced Concepts">
                        <span class="hidden-mobile">深入理解计算机系统 021-Dynamic Memory Allocation, Advanced Concepts</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
