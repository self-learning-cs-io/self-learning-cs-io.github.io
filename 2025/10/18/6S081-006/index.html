

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="发言人   00:00Okay, good afternoon, wherever you are. Can everybody hear me? Quick sound check to make sure. Yeah, you’re fine.好的，下午好，无论你在哪里。大家都能听到我说话吗？快速声音检查以确保。是的，你很好。 发言人   00:10Okay, good, thank you.">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统工程 006-Lab Q&amp;A">
<meta property="og:url" content="http://example.com/2025/10/18/6S081-006/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="发言人   00:00Okay, good afternoon, wherever you are. Can everybody hear me? Quick sound check to make sure. Yeah, you’re fine.好的，下午好，无论你在哪里。大家都能听到我说话吗？快速声音检查以确保。是的，你很好。 发言人   00:10Okay, good, thank you.">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-18T02:00:06.000Z">
<meta property="article:modified_time" content="2025-10-25T05:03:39.717Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>操作系统工程 006-Lab Q&amp;A - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="操作系统工程 006-Lab Q&amp;A"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-18 10:00" pubdate>
          2025年10月18日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          20k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          166 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">操作系统工程 006-Lab Q&amp;A</h1>
            
            
              <div class="markdown-body">
                
                <p>发言人   00:00<br>Okay, good afternoon, wherever you are. Can everybody hear me? Quick sound check to make sure. Yeah, you’re fine.<br>好的，下午好，无论你在哪里。大家都能听到我说话吗？快速声音检查以确保。是的，你很好。</p>
<p>发言人   00:10<br>Okay, good, thank you. So today we’re going to talk, I don’t really have specific agenda, but basically the plan is to try to answer questions that you might have about the last lab or the previous labs. And so the approach I’m going to take today is I’m going to walk through the staff solutions. In particular, my own solutions and, you know, discuss them. And hopefully as we go through the staff solutions, you can jump in if I don’t answer a particular question or wait a little bit because I put all the questions that you’ve asked at least before 11 AM this morning in the lecture notes at the bottom. And we’ll try to go through that.<br>好的，好的，谢谢。所以今天我们要谈，我并没有具体的议程，但基本上计划是尝试回答你可能有关于上一个或以前的实验的问题。所以今天我要采取的方法是，我将逐步介绍员工解决方案。特别是我自己的解决方案，你知道的，讨论它们。希望在我们浏览员工解决方案时，如果我不回答特定的问题，您可以跳进去，或者稍等一下，因为我把您今天早上11点之前提出的所有问题都放在了讲义底部。我们会努力度过这个难关。</p>
<p>发言人   01:03<br>I’m going to start with the page table app because most questions were about the Page Table Lab. And partially because of Zoom with was the hardest laughs. And so maybe a couple of comments before diving into sort of the technical part of this, let’s talk a little bit about the page table lab in general. And as you’ve probably observed, there’s actually a few lines of code.<br>我将从页表应用程序开始，因为大多数问题都是关于页表实验的。部分原因是因为Zoom是最难笑的。在深入技术部分之前，也许有一些评论，让我们谈谈一般的页表实验。正如你可能已经观察到的那样，实际上有几行代码。</p>
<p>发言人   01:40<br>In terms of the solution, but unfortunately, it has hard to debug. Problem? And there’s one reason is that when actually the box shows up, the outcomes are pretty extreme. In the worst case, some of you observed that in the worst case Cm users stops or XV 6 that stops, there’s no output being printed anymore, and that’s it. And you know, that was your job to sort of figure out actually one that wrong. In the best case, you get sort of a kernel panic. But the panic, maybe there’s a starting point of sort of tracking down what the actual source of the problem is. Panic itself is probably related to something else, so invariant that endocrine got broken but somewhere else earlier, probably when you set up the page tables, you did something wrong that in the end caused this and it could go off and you have to track down what’s going on.<br>就解决方案而言，但不幸的是，很难调试。有问题吗？其中一个原因是，当盒子实际出现时，结果非常极端。在最坏的情况下，你们中的一些人观察到，在最坏的情况下，Cm用户停止或XV 6停止，不再打印任何输出，就是这样。你知道，你的工作就是找出一个错误的。在最好的情况下，你会得到一种内核恐慌。但是恐慌，也许有一个起点可以追踪问题的真正根源。恐慌本身可能与其他事情有关，内分泌系统被破坏是不变的，但在其他地方，可能是当你设置页表时，你做错了什么，最终导致了这一点，它可能会爆发，你必须追踪发生了什么。</p>
<p>发言人   02:47<br>So few lines of code, hard to debu problems, and it was just a harsh environment to debu in. You do in the kernel debugging or kernel programming, you use the programming environment debugging environment is is unfornately rapid mentioned in the first lecture.<br>这么少的代码行，很难开发问题，而且这只是一个苛刻的环境。你在内核调试或内核编程中使用的编程环境是调试环境，它在第一堂课中提到过。</p>
<p>发言人   03:07<br>And this is one of the hard parts about basically doing kernel programming. And that’s a, you know, just to make you maybe feel better. It’s not just hard for you, it’s actually really and hard for your staff. Both in terms of helping you and actually, you know, when we do these labs, you know, we make similar problems. And, you know, we probably have more experience in tracking bugs down. You know, they do take time. They’re helping you.<br>这是基本上进行内核编程的难点之一。你知道，那只是为了让你感觉更好。这不仅仅是对你来说很难，实际上对你的员工来说真的很难。无论是在帮助你方面，还是在实际上，你知道，当我们做这些实验室时，我们都会遇到类似的问题。而且，你知道，我们在追踪漏洞方面可能有更多的经验。你知道，他们确实需要时间。他们正在帮助你。</p>
<p>发言人   03:40<br>It tends to be hard, too, because there’s some small fraction of code. There’s one detail, something probably wrong, figuring out actually what that detail is is not that easy. Of course, some of the problems we’ve seen before, and we recognize, for example, we didn’t make the same mistake ourselves, but other ones, you discovered all kinds of different ways of sort of breaking the Kern that we hadn’t seen before. So this is just hard it in our experience.<br>这也往往很难，因为只有一小部分代码。有一个细节，可能有些问题，弄清楚这个细节是什么并不容易。当然，我们以前见过的一些问题，我们认识到，例如，我们自己没有犯同样的错误，但其他问题，你发现了各种不同的打破克恩的方式，我们以前没有见过。所以这在我们的经验中很难。</p>
<p>发言人   04:11<br>This is historically always hard virtual memory. So every time the first virtual memory lab you comes around, either in Soh one or its predecessor in six 828, it has to be the case that that tends to be the hardest lap. Of all the labs. And, you know, for a number of reasons. One, you know, the harsh environment, you know, the bugs are spectacular and partly because you haven’t had that much kernel program experience yet. And so this is sort of the first lab where all those things come together.<br>这在历史上一直是硬虚拟内存。因此，每当你遇到第一个虚拟内存实验室时，无论是在Soh 1还是其前身6 828中，情况都必须是最困难的一圈。所有的实验室。而且，你知道，有很多原因。一，你知道，恶劣的环境，你知道，错误是惊人的，部分原因是你还没有那么多的内核编程经验。因此，这是第一个将所有这些东西结合在一起的实验室。</p>
<p>发言人   04:49<br>This year, we tried to make the lab simpler, effective. This is a new lab. Last year, we did not have that lab in the hopes that actually make this introduction or the transition into virtual memory easier. In some ways, I think it was successful. In other ways, you know, it’s still hard, and so we don’t really know maybe what the easiest way to actually introducing virtual landing programming is.<br>今年，我们试图让实验室变得更简单、更有效。这是一个新的实验室。去年，我们没有那个实验室，希望能够真正使引入或过渡到虚拟内存更加容易。在某些方面，我认为它是成功的。在其他方面，你知道的，这仍然很困难，所以我们真的不知道实际上引入虚拟着陆编程的最简单方法是什么。</p>
<p>发言人   05:14<br>Number the lab next week. The lazy lab is actually the lab that used to be the first virtual memory lab. And my suspicion is that you’ll find it this year easier than the students found that last year, because when you now have much more background in virtual memory. Okay, so that’s maybe this a good point to stop. This is like a couple of high level points I wanted to make before jumping into the more technical or the more the details. So if you have any questions, this is a great time to ask questions.<br>下周对实验室进行编号。懒惰实验室实际上是曾经是第一个虚拟内存实验室的实验室。我怀疑你今年会比去年的学生更容易找到它，因为你现在有更多的虚拟记忆背景。好的，也许这是一个很好的停止点。这就像是我想在进入更技术性或更多细节之前提出的几个高层次点。所以如果您有任何问题，这是提问的好时机。</p>
<p>发言人   05:51<br>Okay, then let’s quickly, some of you asked for this very quick review, exactly why, what the setting is. And so basically the setting is page tables.<br>好的，那么让我们快点，你们中的一些人要求这个非常快速的回顾，确切地说为什么，设置是什么。所以基本上设置是页表。</p>
<p>发言人   06:12<br>Again, we have physical memory. We will drive here on the right side. You know, the physical memory consisting of partly of devices, and they live above this oax you 0 0 and many d more zeros. And then here is basically DRAM chips. And we know that qmu actually puts the kernel, the kernel text and data, right? Both above 0x 0 0 0 0. So that’s where the kernel lives. And you know, one way may be above re this a little bit to use the kernel and you know, basically literally what it means, You know, what is what the kernel is.<br>再次强调，我们还有物理记忆。我们将从右边开过来。你知道，物理内存部分由设备组成，它们位于这个oax之上，你0和许多更多的零。然后这里基本上是DRAM芯片。我们知道qmu实际上放置了内核，内核文本和数据，对吧？两者都高于0 x0 0 0。所以这就是内核所在的地方。你知道，一种方法可能比使用内核要高一点，你知道，基本上它的意思是什么，你知道，内核是什么。</p>
<p>发言人   06:57<br>Here are the instructions. The binary versions of the assembly and instructions that you have seen. And there’s also some data structures located at these addresses.<br>这是说明书。你看到的汇编和指令的二进制版本。还有一些数据结构位于这些地址处。</p>
<p>发言人   07:12<br>Okay, so that’s the memory part of it. Then on the other side, we got our CPU that executes instructions. And so the CPU has a bunch of internal state and has some registers, you know, whatever x 0 or R zero, blah, blah, blah, blah. And you know, they need a program counter. And then when XV 6 starts, you know, the proven encounter contains this value of x 0 0 0 0. And. And that’s the way, you know, the CPU knows that basically look at that address, define, you know, the first instruction and looks at the first instruction, decodes the instruction, and updates whatever CPU data that needs to be updated.<br>好的，这就是它的记忆部分。然后在另一方面，我们有了执行指令的CPU。因此，CPU有一堆内部状态和一些寄存器，你知道的，无论是x0还是r0，等等等等。你知道，他们需要一个程序计数器。然后当XV 6开始时，你知道，经过验证的遭遇包含这个值x 0。而且。这就是方法，你知道，CPU知道基本上查看该地址，定义第一个指令并查看第一个指令，解码指令，并最新进展需要更新的任何CPU数据。</p>
<p>发言人   07:58<br>You know, page tables and sort of component to it. You know the addresses. You know that the CPU. Others or the instructions were part of the instructions, like, you know, jump to some particular address. You know, those addresses are typically or most commonly or there will be virtual dresses. And those virtual dresses go to the fruit. So typically is called the MNU and the menu translates to physical addresses. That allows us to index into either the IO part of the memory or the VRM part of the memory to.<br>你知道，页表和它的组成部分。你知道地址。你知道那个CPU。其他人或说明是说明的一部分，就像，你知道，跳转到某个特定的地址。你知道，这些地址通常是或最常见的，否则会有虚拟礼服。而那些虚拟连衣裙走向了果实。通常被称为MNU，菜单翻译为物理地址。这允许我们对内存的IO部分或VRM部分进行索引。</p>
<p>发言人   08:40<br>Control how this translation happens. And there’s this satp register. We each contains the root of the page table of the current running page table. And if there’s 0, then there’s basically no translation going on. The virtual address is literally directly a physical address, so when the processor actually starts up, there’s no value in s.p.. And so when the program counter is that, you know, basically the physical addresses also away and basically the CPU whole, no, that’s just the instruction from that particular location as soon as the.<br>控制这种翻译如何发生。还有这个satp寄存器。我们每个都包含当前运行页表的根。如果为0，则基本上没有翻译。虚拟地址实际上是直接的物理地址，因此当处理器实际启动时，s.p.没有值。所以当程序计数器是，你知道的，基本上物理地址也离开，基本上是整个CPU，不，那只是来自那个特定位置的指令。</p>
<p>发言人   09:20<br>As soon as the satp actually contains a nonzero value, then you an example, maybe.<br>一旦satp实际上包含一个非零值，那么你可以举个例子。</p>
<p>发言人   09:27<br>So somewhere in here, like Theron makes extended picture a little bit further, we know that the Kern actually has a maximum of 128 MB. And so basically, this is all free memory from here to there is free memory. And free memory. Put it on the list in Cabo DOC, as you’ve seen before. And so somewhere in here is also the root page table for, you know, a kernel page table. So maybe here’s some page and then if the root. Page, table directory. And as soon as we load that value, the address of the physical address of that value into the Sap address and register.<br>所以在这里的某个地方，像塞林把扩展图片放得更远一点，我们知道克恩实际上最多有128个MB。基本上，这是从这里到那里的所有空闲内存。免费的记忆。把它放在cabodoc的清单上，就像你之前看到的那样。所以在这里的某个地方也是内核页表的根页表。所以也许这里有一些页面，然后如果根。页面，表目录。一旦我们将该值、该值的物理地址的地址加载到Sap地址和寄存器中。</p>
<p>发言人   10:14<br>So let’s say this humanity, this address is zerox 7, you know, f by the Bla, something just below 120 mega megabytes or in that free space of memory below that address in satp. At that point, you know, the processor or the MMU will use the root page table to actually do the translation, you know, from Virgil to physical dress.<br>所以假设这个人类，这个地址是zerox 7，你知道的，f通过Bla，略低于120兆字节的东西，或者在satp中该地址下面的可用内存空间中。在那一点上，你知道，处理器或MMU将使用根页表来实际执行从处女到物理着装的翻译。</p>
<p>发言人   10:42<br>And you can think of this, you know, this particular whole thing sort of being a single sort of box, you know, integrated, you know, together. Any sort of questions about this high level picture before? Keep them going. So one of the key points to sort of remember here is that the page data themselves also live in memory.<br>你可以把这个想象成一个整体，你知道，这个特定的整体有点像一个盒子，你知道，整合在一起。之前对这张高水平的图片有什么问题吗？让他们继续前进。所以在这里要记住的关键点之一是，页面数据本身也存储在内存中。</p>
<p>发言人   11:08<br>Okay? Okay, so let’s jump then to. The first part of the page table app, namely part 1, where you have to print, the page table for the init program. And you explain it basically in terms of this figure 3, 4, and the figure 3, 4 is right here. Three, 4, and this is figure 3.<br>好吗？好的，那么让我们跳到。页表的第一部分应用程序，即第1部分，您需要在其中打印init程序的页表。你基本上用这个图3、4来解释它，图3、4就在这里。三，四，这是图三。</p>
<p>发言人   11:43<br>Four shows the user address space. Just let’s look at the user address space for a second before we go into detail. So we have the text at the bottom, so this is the instructions of the program starting address 0. Above the instructions are data, global variables live there. Then there is something called the guard page we’ll talk about. And then there’s the stack of the user program. Kern has its stack, or multiple stacks, and user program has its own stack.<br>四个显示了用户地址空间。在详细讨论之前，让我们先看看用户地址空间。所以我们在底部有文本，这是程序开始地址0的指令。以上指令是数据，全局变量存在于其中。然后有一个叫做保护页面的东西我们会谈论。然后是用户程序的堆栈。Kern有它的堆栈，或者多个堆栈，用户程序也有自己的堆栈。</p>
<p>发言人   12:12<br>And above, again, is basically what’s called heap memory, you free memory that we can get more memory using S break. So S break basically points 2, the top of the user address phase, we want to grow it. We call the S break system call to grow the top of the grow the bottom part up into the heap.<br>再说一遍，上面的基本上是所谓的堆内存，您可以释放内存，我们可以使用S break获得更多内存。所以突破基本上是第2点，用户地址阶段的顶部，我们希望增长它。我们调用S break系统调用来将顶部和底部的部分向上扩展到堆中。</p>
<p>发言人   12:36<br>We also know that at the top there from the last lecture that there are two pages, 2 special pages, the trampoline and the tra frame track, frame page, and the trampoline page, you know, contains these instructions to basically transition in and out of the kernel and the trackplan is.<br>我们还知道，在上一节课的顶部有两页，两页特殊页，分别是蹦床和帧跟踪，帧页和蹦床页，你知道，包含基本上转换进出内核的指令，跟踪计划就是。</p>
<p>发言人   12:53<br>Convenient to place to store some state when we jump into the kernel because we need the kernel wants to use the registers. We can’t use the registers because the user phase program still has them in use. I’m not going to talk much about trampoline and trampoline at all, but you know, there, there, okay, so here, this picture a little bit below low, you know, is actually the.<br>当我们跳进内核时，存储一些状态很方便，因为我们需要内核要使用寄存器。我们不能使用这些寄存器，因为用户阶段程序仍然在使用它们。我不打算谈论蹦床和蹦床，但你知道，在那里，在那里，好的，所以在这里，这张照片有点低，你知道，实际上是。</p>
<p>发言人   13:17<br>Printout from when I read it from init. This the first successful call of exec. Like we know that in a code makes a system called exec for the program in it.<br>当我从init读取时打印输出。这是exec的第一次成功呼叫。就像我们知道的那样，在代码中制作一个名为exec的系统，用于其中的程序。</p>
<p>发言人   13:30<br>And just at the end of exit, we’re printing out that page table. And so there’s a couple of things that we, many things we can observe about this particular page table. So first of all, we, in addition to printing out the physical, the Ptes, and the physical addresses, mostly printing out the flags. And you can see here, here the flag is one. And it basically says that this translation or this intermediate page is valid. Similar here, that is valid in green page, and they basically correspond, you know, to the level of 2 page. And then the second one before corresponds to the level. So sorry, I just screw the arrows around. So that is why I paused for a second.<br>在退出的末尾，我们正在打印该页面表格。因此，关于这个特定的页表，我们可以观察到一些事情，很多事情。因此，首先，我们除了打印出物理地址、Ptes和物理地址外，主要是打印出标志。你可以看到，这里的旗帜是一个。它基本上说这个翻译或这个中间页面是有效的。在这里类似，这在绿页中有效，它们基本上对应于2页的级别。然后之前的第二个对应于级别。很抱歉，我只是拧了箭头。这就是我停顿一秒钟的原因。</p>
<p>发言人   14:17<br>Going to the top, this is the top level page table. This kind of points to this particular page table and this, you know, points to that particular pitch table, or that’s the address, you know, pointing to sort of a short time hand for Shane. That is the base address for that particular page. And as you know, these pages are 496 B. This is essentially page size, and so you divide it by 64 b where you get 5 into T’s entries, okay? So what c is the bottom part of this dress space now for init basically has actually, all this has three pages, only three pages.<br>转到顶部，这是顶级页面表。这种指向这个特定页表的指针，你知道，指向那个特定的推销表，或者那就是地址，你知道，指向一个短时间的手给Shane。这是该特定页面的基址。如你所知，这些页面是496 B。这基本上是页面大小，所以你把它除以64 b，你得到5到T的条目，好吗？那么c是什么呢？这个着装空间的底部现在对于init来说基本上已经有了，所有这些都有三页，只有三页。</p>
<p>发言人   15:02<br>And we got a couple things that we can discern from the free pages. We know that the bottom page, which basically corresponds to virtual address zero, lives at physical address 8 7 6 4 0. And, you know, we know from our previous picture that is somewhere in that free memory that the kernel has available to allocate pages from.<br>我们从免费页面中得到了一些东西。我们知道，底部页面基本上对应于虚拟地址0，位于物理地址8 7 6 4 0。而且，你知道，我们从之前的图片中知道内核可以从中分配页面的空闲内存中的某个地方。</p>
<p>发言人   15:28<br>And then the final of the things you see, we see the flags and we show you the flags have one. If so, it means that the read the valid set, the read set, the W data set, the X Cub data set, and the U bit set. So this page can contains both data and text. And these permissions allow the user program to execute a structure from it to view the right memory and do it from user space.<br>然后最后你看到的东西，我们看到旗帜，我们向你展示旗帜。如果是，则意味着读取有效集合、读取集合、W数据集、X Cub数据集和U位集合。所以这个页面可以包含数据和文本。这些权限允许用户程序从中执行结构，以查看正确的内存并从用户空间执行。</p>
<p>发言人   15:56<br>Okay, so then maybe the most interesting question is like, what’s up with page 1? And you know, as a hint, we see that page 1 only has f and not the u bit set. So you know, 1 is page 1.<br>好的，那么也许最有趣的问题是，第一页是怎么回事？而且你知道，作为一个提示，我们看到页面1只有f而没有设置u位。所以你知道，第一页是第一页。</p>
<p>发言人   16:11<br>Anybody? Is it the guard page? Yeah, the guard page, right. So the guard page is map because it has a VIP, but it has not the view bit set. So any user instruction that tries to, so if a user program runs off its stack, so stack grows from the top down, so even if it actually has more, you know, it’s stack is bigger than 496 or completely full. And it then the user program, you know, pushes something on the stack, stack on the ground, it will grow into the guard page. And because the Ubi is not set, we’re going to get a page-fault a tracking to the kernel because the MMU translate to address cannot translate any addresses on the guard page through physical dress, because the not having a unit basically forbids the translation. Okay, and what is done in page 2?<br>有人吗？是守卫页面吗？是的，守卫页面，对吧。所以保护页面是map，因为它有一个VIP，但它没有设置视图位。所以任何用户指令都试图这样做，所以如果用户程序在堆栈外运行，那么堆栈从上往下增长，所以即使它实际上有更多，你知道，它的堆栈大于496或完全满。然后用户程序就会在堆栈上推送一些东西，堆栈在地面上，它将成长为保护页面。并且由于Ubi未设置，我们将获得一个页面错误跟踪到内核，因为MMU转换为地址无法通过物理方式转换保护页上的任何地址，因为没有一个单元基本上禁止翻译。好的，第二页做了什么？</p>
<p>发言人   17:15<br>Any. The stack. Yep, that’s the stack page. And so again, the stack pages 4, 4, 4, 4, 5, 7, 96 B. And you would see that’s clearly elaborate in terms of permissions and has everything.<br>任何。堆栈。是的，这就是堆栈页面。再次，堆叠页面4、5、7、96 B。你会发现这在权限方面很清楚地阐述了，并且拥有一切。</p>
<p>发言人   17:32<br>Could we set it up tighter if we wanted to. Yeah, I think you could disable the executable a bit. Yeah, you probably could execute the X bit. That would forbid having any program code on the stack. So if you generate code on the fly and put it on the stack, you wouldn’t be able to execute it. You know, that’s maybe probably a good thing. And so we could have been a little bitd tium, okay, so that’s the basically the bottom part of this thing of the page table.<br>如果我们想的话，我们可以把它设置得更紧吗？是的，我想你可以稍微禁用一下可执行文件。是的，你可能可以执行X位。这将禁止在堆栈上有任何程序代码。因此，如果您即时生成代码并将其放在堆栈中，您将无法执行它。你知道，这可能是一件好事。所以我们可能有一点比特，好的，那基本上是页表这个东西的底部。</p>
<p>发言人   18:09<br>So now let’s look at the remaining entries. So the basically only two remaining entries and maybe the flag bits are the most telling part of this. So 7, you know, beans and wheat, right? And that work? And so what do we think that one is, and maybe I’ll do the other one too. So v is, I think, 1 0, 0, 1, so presumably x invalid. So what do we think 511 is. Anybody?<br>现在让我们看看其余的条目。因此，基本上仅剩下两个条目以及标志位可能是其中最具说服力的部分。所以7，你知道豆类和小麦，对吧？这项工作？那么我们认为一个是什么，也许我也会做另一个。所以我认为v是1 0，0，1，所以可能是x无效。那么我们认为511是什么呢？有人吗？</p>
<p>发言人   18:54<br>The trampoline and trap page. Yeah, the trampoline and probably 5 11 is definitely detract and correct because it has the exhibit set. So we must be executed or we’re allowing instruction to be executed from that page. So that must be the trampoline and allowing read and write to the to that page. So that’s probably the tracking page because that’s the one we use to restore and save register shape.<br>蹦床和陷阱页面。是啊，蹦床和可能的5 11绝对是减损和正确的，因为它有展览集。所以我们必须被执行，否则我们将允许从该页面执行指令。所以那必须是蹦床，并允许对该页面进行读写。这可能是跟踪页面，因为这是我们用来恢复和保存寄存器形状的页面。</p>
<p>发言人   19:24<br>Thing, the most important thing to notice is there’s no u bit. So what does that mean? That means that the user program can actually not execute the instructions that are actually at 510 at the trampoline page and can’t read rights to that page. So only the colonel can execute instructions from there and it can only read a write. So basically, like the kernel is going to be doing this before the while, still using the user page table, right? That’s kind of the point. Yeah, exactly as when, you know, sort of Robert explained in last lecture, this is like just for the transition from us to kernel and before we jump to before we load to the kernel page table in the satp register, we need a little bit of, you know, the colonel needs a little bit of memory to actually do his job.<br>最重要的是要注意没有u位。那意味着什么？这意味着用户程序实际上无法执行蹦床页面上实际位于510的指令，并且无法读取该页面的权限。所以只有上校才能从那里执行指令，并且只能读取写入内容。基本上，就像内核将在之前这样做，仍然使用用户页表，对吧？这就是重点。是的，就像罗伯特在上次讲座中解释的那样，这就像是从我们到内核的过渡，在我们跳转到加载到satp寄存器中的内核页面表之前，我们需要一点点，你知道，上校需要一点记忆才能真正完成他的工作。</p>
<p>发言人   20:12<br>Okay, so in a couple other things then maybe interesting of this picture. So all these addresses 8, 7, 6 3 0 8 6, 2 4, 7, 1, these are all pages or memory in that range of the kernel memory That is not, you know, that’s basically free, right? And are and these addresses contiguous?<br>好的，那么在其他几件事情上，这张图片可能会很有趣。所以所有这些地址8，7，6，3，0，8，2，4，7，1，这些都是内核内存范围内的页面或内存，你知道，这基本上是免费的，对吗？并且这些地址是连续的吗？</p>
<p>发言人   20:42<br>In physical memory? Anybody, no, they don’t have to be. No, they don’t have to be in the are, correct? You know, look at this, you know, 7006 4 0 0, if we can figure it now, the next address would have been 8, 7, 6, you know, 6 5 0, right? And it isn’t. So there’s no one of the cool things about page tables is that even though maybe the virtual address space, it contig, the physical dress space, or the physical pages that go along with the contiguous virtual dresses are not, don’t have to be contiguous. And so this gives the current a lot of flexibility in terms of allocation and threeing pages.<br>在物理记忆中？任何人，不，他们不必如此。不，他们不必在里面，对吗？你知道，看看这个，你知道，7006 4 0，如果我们现在能算出，下一个地址应该是8，7，6，你知道，6 5 0，对吧？但事实并非如此。因此，页表最酷的地方之一就是，即使虚拟地址空间、物理着装空间或与连续虚拟着装相伴的物理页面不一定是连续的。因此，这在分配和三页方面为当前提供了很大的灵活性。</p>
<p>发言人   21:25<br>Okay, any questions about this part 1? I had a question. Yeah, could you explain the sbrk a little also if we are going to cover it in a future lecture, then maybe we can like just a small. Yeah, actually we let me I’m going to talk about it on Wednesday and it actually will be the topic of the lazy lab, so let me maybe postpone that question a little bit to Wednesday. And then if that’s not clear enough, please ask it again.<br>好的，对这第一部分有什么问题吗？我有一个问题。是的，你能解释一下这个sbrk吗？如果我们要在将来的讲座中涵盖它，那么也许我们可以只是一个小问题。是的，实际上我们让我在星期三谈论它，它实际上将成为懒惰实验室的话题，所以让我把这个问题推迟到星期三。如果还不够清楚，请再问一遍。</p>
<p>发言人   21:54<br>Sounds good, thank you. So had a question. So I remember that the book said the trampoline and the trap frame were at the top of the address space. But here it stops at like the first, the root page table. It indexes at 2, 5, 5, not 5, 1, 1. Yeah, brilliant question, very good. I’m glad you asked it. I saw it in the Q&amp;A questions and I was planning to talk about it, but of course I’ve got, so yeah, what’s going on here? You know, why is 2 5 5 not 511?<br>听起来不错，谢谢。所以有一个问题。所以我记得书上说蹦床和陷阱框架位于地址空间的顶部。但这里它停在像第一个一样的根页面表。它的索引值为2、5，而不是5、1。是的，很棒的问题，很好。我很高兴你这么问。我在问答中看到它，我打算谈论它，但当然我得到了，所以，这里发生了什么？你知道，为什么是2 5 5而不是511？</p>
<p>发言人   22:35<br>We always say the trampoline lives at the top of the address space. Well, the top of the address space, correct, is, you know, point is actually entry 511 of the top level directory and it is only 255. Anybody any ideas why this is the case? We said that 1 b that we said we were going to use. We actually aren’t using because of sign extension problems is just mix it easier. And we also don’t need that memory. Yeah, so, so that is exactly the right answer. So basically stupid technicality.<br>我们总是说蹦床位于地址空间的顶部。嗯，地址空间的顶部，正确的，你知道，点实际上是顶层目录的条目511，它只有255。有人知道为什么会这样吗？我们说过要使用的1 b。我们实际上并没有使用符号扩展问题，只是更容易混合。我们也不需要那个记忆。是的，所以，这就是正确的答案。基本上是愚蠢的技术细节。</p>
<p>发言人   23:09<br>So the virtual dresses are in principle, I think 39 b correct? And but we actually in XV 6 only use 38 of them. And as a result, you know, the top of the max VA for us is basically the 255 entry. And the reason we don’t use the 39 b is for no particular good reason other than basically if you have the 39th bit set, then all the remaining bits in the 64 b address have to be once. And so we just didn’t want to deal with this problem that if we ever set the 49th bit, we also have to set the 40 41st, 42nd to 41st, etc., until the 64th. So that’s the explanation, does that make sense?<br>原则上，虚拟连衣裙是39 b，对吗？但是我们在XV 6中实际上只使用了其中的38个。因此，你知道，我们的max VA的顶部基本上是255个条目。我们不使用39 b的原因没有特别好的原因，除了基本上如果您设置了第39位，那么64 b地址中的所有剩余位必须是一次。所以我们只是不想处理这个问题，如果我们设置第49位，我们还必须将40设置为41，42到41，等等，直到第64位。这就是解释，这有感知吗？</p>
<p>发言人   24:00<br>Very good, very good observation Joe.<br>非常好，非常好的观察蔡崇信 (Joe)。</p>
<p>发言人   24:04<br>Sorry, I also had a question about why is the text and the data on the same page? Very good question. Also, that seems stupid, right? And you know, why not put them on separate pages so that you can actually set the permission bits more carefully? The main reason we’re not doing that is for simplicity, makes exec more complicated, and we wanted the simplest exec possible. So a real operating system would not have data and text in the same page. In fact, we have to specify. If you look at the loader flag in the make file, you’ll see that it has the desk in option and that forces is actually data and text to be in the contiguous are not a separate paters.<br>抱歉，我也有一个问题，为什么文本和数据在同一页上？很好的问题。而且，这似乎很愚蠢，对吧？你知道，为什么不把它们放在不同的页面上，这样你就可以更仔细地设置权限位了？我们不这样做的主要原因是为了简单，使exec更加复杂，我们希望尽可能使用最简单的exec。因此，真正的操作系统不会在同一个页面中包含数据和文本。事实上，我们必须具体说明。如果您查看制作文件中的加载程序标志，您会发现它具有desk in选项，并且力实际上是连续的数据和文本，而不是单独的模式。</p>
<p>发言人   24:53<br>Any more questions about this? I had a follow up question regarding the number of bits we were using. So you said we’re using just 38 b. Is it is like the hardware still provides for us to use 39 b, but we are designing our operating system such that we’re using 38? Yeah, so we basically, if the machine had more Ram than 2 to the 38, we would not be able to use that Ram. Now we’re already running, we’re assuming basically much less memory than 2 to the 38. So it’s not a big deal for us. But the real operating system would have done better.<br>还有什么问题吗？我有一个关于我们使用的位数的后续问题。所以你说我们只使用38 b。是不是就像硬件仍然为我们提供使用39 b，但我们正在设计我们的操作系统，以便我们使用38？是的，所以基本上，如果机器的内存超过2到38，我们将无法使用那个内存。现在我们已经在运行，我们基本上假设内存比2少得多，为38。所以这对我们来说没什么大不了的。但是真正的操作系统会做得更好。</p>
<p>发言人   25:36<br>So just pure for simplicity, we want to make it as easy for you as possible by reading the Fus lines of code possible. Okay, yeah, makes sense.<br>因此，为了简单起见，我们希望通过尽可能地阅读代码的Fus行来使其尽可能简单。好吧，是的，感知。</p>
<p>发言人   25:50<br>Okay, so now let’s switch to part 2. And so let’s bring up, you know, a picture you probably have looked at a lot, The kernel dress space. Right on the left is the virtual dress space, on the right is physical memory, and here, here are IO devices, and then from here on in DRAM and you know, and basically running until what, actually 120, 28 MB. For us, because we just assume that there’s no more than 2 128 MB of memory. And so this part of the physical memory is the free memory.<br>好的，现在让我们切换到第二部分。所以让我们提出一张你可能看过很多次的图片，内核连衣裙空间。左边是虚拟着装空间，右边是物理内存，这里是IO设备，然后从这里开始在DRAM中运行，基本上一直运行到120，28 MB。对我们来说，因为我们只是假设内存不超过2 128 MB。因此，这部分物理内存是空闲内存。</p>
<p>发言人   26:34<br>And from that is where the kernel, oops, I grew a little bit wrong, but be a little bit more careful. Here we basically have, you know, kernel text and data. And then, you know, this memory you buff, you know, is basically memory that the kernel allocator has. And from there, we allocate memory for user programs, we allocate memory for page tables, etc..<br>从那里开始内核，哎呀，我有点错了，但要小心一点。这里我们基本上有，你知道，内核文本和数据。然后，你知道，你buff的这种内存，基本上是内核分配器拥有的内存。然后，我们为用户程序分配内存，为页表分配内存，等等。</p>
<p>发言人   26:58<br>The kernel, all everything from down until it runs out of memory. When it runs out, it gets to 128 MB, and then it starts returning errors or system calls.<br>内核，所有东西从下到内存耗尽。当它耗尽时，它会得到128个MB，然后它开始返回错误或系统调用。</p>
<p>发言人   27:08<br>Okay, good. So let me pull up my. The first part, correct in some sense, of this assignment was the part two of the assignment was just to run with or copy the kernel page table so that every process has its own kernel page tables. And that was the basically, that’s the assignment here. So let me, for jumping into the code, let me actually say a couple things, more general things about it. So part 2.<br>好的，好的。所以让我把我的拉起来。这个赋值的第一部分，在某种感知上是正确的，是赋值的第二部分只是运行或复制内核页表，以便每个进程都有自己的内核页表。这就是基本上，这就是这里的任务。因此，为了跳进代码中，让我实际上说几件事情，更一般的事情。所以，第二部分。</p>
<p>发言人   27:52<br>And can maybe the first question really sort of get your head around is like, in some ways that this sounds trivial? We already have a Ch page table. We just have to make n copies of for one copy for each particular process. And you might say, well, how hard can that be? And it turns out, I think it was a little bit harder for a couple of reasons. Some good ones, some less good ones, harder than it seems to.<br>也许第一个问题真的能让你思考一下，在某些方面，这听起来很琐碎？我们已经有一个Ch页表了。我们只需要为每个特定进程制作n份副本。你可能会说，那有多难？事实证明，我认为这有点难，原因有几个。有些好的，有些不太好的，比看起来更难。</p>
<p>发言人   28:21<br>And one reason is that, you know, the XV 6 code. It sort of specialized for one kernel page table.<br>其中一个原因是，你知道，XV 6代码。它有点专门用于一个内核页表。</p>
<p>发言人   28:39<br>You saw that in KVM in it? And so that makes it a little bit generalizing. Is there actually a little bit of work? Because you actually have to modify the XV 6 code. Kva Minute, as you also saw, is not the full story, you know, for building the page table for the kernel. You know, there’s also stuff in proc in it that actually adds mappings to the kernel page table. And then there’s even something in virgin IO disk that actually interacts, you know, with the kernel page table. So basically, there’s no one single place in the kernel where actually the kernel page table actually is built.<br>你在KVM里看到了吗？这使得它有点泛化。实际上有一点点工作吗？因为你实际上必须修改XV 6代码。正如您所看到的，Kva分钟并不是构建内核页表的全部故事。你知道，在proc中还有一些东西实际上会将映射添加到内核页表中。然后，在原始的IO磁盘中甚至有一些东西实际上与内核页表交互。基本上，内核中没有一个地方实际上构建了内核页表。</p>
<p>发言人   29:22<br>Then the third reason why you know this is slightly complicated is because you also have to deal with cleanup. So there’s the aspect of actually creating these copies. But whenever time a user process exit, we always have to clean up those page tables that were in use because we want to return them to the pool of free memory so that we can use them later so that we can keep on running processes does. And that makes the things a little bit complicated because now we’ve got to be a little bit careful in actually freeing the kernel page table or copy of the kernel page table. But we certainly don’t want to free memory that’s actually still in use, or page table entries that’s still in use by other page tables. So we’ve got to be careful there. And then, you know, basically it’s easy to make a small error in your page table when you copy those page tables, if you get a little thing, basically you get a hard book.<br>你知道这有点复杂的第三个原因是你还必须处理清理。所以这就是实际创建这些副本的方面。但是每当用户进程退出时，我们总是必须清理正在使用的那些页表，因为我们想将它们返回到空闲内存池中，以便稍后可以使用它们，以便我们可以继续运行进程。而这使得事情有点复杂，因为现在我们在实际释放内核页表或内核页表的副本时必须要稍微小心。但我们肯定不想释放实际上仍在使用的内存，或者仍在被其他页表使用的页表条目。所以我们在那里必须小心。然后，你知道，基本上当你复制那些页表时，很容易在你的页表中犯一个小错误，如果你得到一个小东西，基本上你会得到一本很难的书。</p>
<p>发言人   30:25<br>And one of the problems here is, I said a little bit earlier, is the hard bar shows up. And much, much, much later, you built a kernel page tables, or you built a copy of the kernel page table. All looks fine. You load it in satp, and even maybe the criminal runs for a little while, and then it panics. And it turns out, you know, the reason it panics is because, you know, you made some small mistake in the page table a long, long, long time ago. And so this is one reason why it makes, makes life difficult, for kernel programming. And, you know, and basically, you know, these hard debus basically are just time consuming to track down.<br>这里的一个问题是，我之前说过，硬条出现了。并且在很多之后，您构建了一个内核页表，或者您构建了内核页表的副本。一切看起来都很好。你把它装入satp，甚至可能罪犯跑了一会儿，然后它就会恐慌。原来，你知道，它恐慌的原因是因为，你知道，很久很久以前，你在页表上犯了一些小错误。所以这就是它让内核编程变得困难的原因之一。而且，你知道，基本上，你知道，这些硬dedbus基本上只是耗时追踪。</p>
<p>发言人   31:11<br>Because at the point that the book no happens, that is actually not the real cost of the boat. But the real cost is way earlier when you set up the page tables.<br>因为当这本书没有发生时，这实际上并不是船的真正成本。但真正的成本要在设置页表时更早。</p>
<p>发言人   31:23<br>Okay, so it turns out there’s two approaches to go about it through these lab, which is sort of two solution approaches. In fact, some of you have probably used a mixture of them, but one you an approach, what I’ll call the copy approach. And the copy approach basically literally makes a copy of the kernel page table. So every time you can do a Kern page table, you allocate pages for the page table, you fill them in, etc., etc..<br>好的，所以结果是有两种方法可以通过这些实验室，这是两种解决方案的方法。事实上，你们中的一些人可能已经混合使用了它们，但有一种方法，我称之为复制方法。而复制方法基本上就是复制内核页表。所以每次你可以做一个页面表格，你为页面表格分配页面，你填写它们，等等。</p>
<p>发言人   32:05<br>That’s a one approach. The second approach. Is basically to share? The curva page table, and in this case, what you do is instead of trying to do make a literally nice, clean copy of the kernel page tables, you share all the entries that are basically are going to be unmodified, You know, from the assignments that basically anything above cleaned or a duplicates is actually going to be unchanged or unmodified. There’s nothing you have to load there in part 3. So you know, basically all the entries from above zero are going broadly identical, and so you can share those entries if you will. So both approaches are I think perfectly fine ABM andante clear, you know, which one is the better one my solution to take this approach. I don’t really have great justification for it, other than maybe.<br>这是一种方法。第二种方法。基本上是分享吗？在这种情况下，您所做的不是尝试制作一个字面上漂亮、干净的内核页表副本，而是共享所有基本上不会被修改的条目，您知道，从作业中，基本上清除或重复的任何内容实际上都将保持不变或未修改。在第三部分中没有什么需要加载的。所以你知道，基本上所有从零开始的条目都大致相同，所以如果你愿意，你可以分享这些条目。所以我认为这两种方法都非常好，并且行板清晰，你知道，我的解决方案采用这种方法哪种更好。我真的没有很好的理由，也许除了其他。</p>
<p>发言人   33:05<br>Part relations. I didn’t want to think too hard what’s in the kernel page table. And so I figure about all the things that are going to stay the same. Why did you do them, copying them over or copy the Ptes over? And then I’d to think too hard about they’re using that part of the kernel address space.<br>部分关系。我不想太认真地思考内核页面表中的内容。所以我认为所有的事情都将保持不变。你为什么要做这些，复制它们或者复制Ptes？然后我会认真考虑他们是否正在使用内核地址空间的那部分。</p>
<p>发言人   33:23<br>And leaks are short code, but I’m not sure it actually is shorter than, for example, the copy solution. But it’s important to realize that basically, there are two different ways of going about this particular problem. In either case, whatever approach you use, there’s sort of an implementation strategy to it. And you know, the implementation strategy that I use for almost any kernel program is to do everything in baby steps. So I might have for the general plan in my head about how I go over the whole, all the changes that I want to make. But once I start making those changes, I do like 1 or 2 and then make sure that those work first and then, you know, keep going.<br>泄漏的代码很短，但我不确定它是否比复制解决方案短。但重要的是要认识到，基本上有两种不同的方法来解决这个特定的问题。在任何一种情况下，无论您使用哪种方法，都有一种实现策略。你知道，我用于几乎任何内核程序的实现策略都是一步步地完成所有事情。所以我可能在脑子里有一个总体计划，关于我如何看待整个计划，我想做的所有改变。但是一旦我开始进行这些更改，我就会喜欢1或2，然后确保这些更改首先有效，然后你知道的，继续前进。</p>
<p>发言人   34:09<br>And the other thing I do is mostly, you know, there’s a strategy. Keep the existing code. Don’t really modify it, certainly not initially. I just add code and switch to this new code. And then there the little baby steps. And the reason I’m doing that is so I can easily compare all the new code. And I always have a working old solution that I can just roll back to. So in case of some strange buggy habits, and then I can go back maybe one step and then try again and sort of figure out like where my reasoning was wrong. But basically, you know, baby steps, partly because these bugs are so hard to track down.<br>我做的另一件事主要是，你知道，有一个策略。保留现有代码。不要真的修改它，当然不是最初的。我只是添加代码并切换到这个新代码。然后是小宝宝的脚步。我这样做的原因是我可以很容易地比较所有的新代码。我总是有一个工作的旧解决方案，我可以回滚到它。所以如果有一些奇怪的错误习惯，然后我可以回到可能的一步，然后再试一次，找出我的推理错在哪里。但基本上，你知道，这些小步，部分原因是因为这些虫子很难追踪。</p>
<p>发言人   34:53<br>Okay, let me switch to my code. So maybe starting in VM dot CD. So the here’s the existing KVM unit, and actually, can everybody see the code? And. The assignment that we’re asked for correctly is to make a copy of it. And the way I do that is, let me see where that is.<br>好的，让我切换到我的代码。所以可能从VM点CD开始。所以这是现有的KVM单元，实际上，每个人都可以看到代码吗？而且。我们被要求做的正确的作业是复制一份。我这么做的方式是，让我看看它在哪里。</p>
<p>发言人   35:39<br>So here is my UV m create, that was just the boring part. That’s basically creating, allocating the top level page directory for the L 2 page directory. And then here’s my KVM, the sort of equivalent of KVM in it. So I get the top of the patriarchy here in this site, then basically I copy the top 511 entry from the Chrono page table that was already set up by KVM in it. And so that gives me most of the kernel page table.<br>所以这是我的紫外线m创建，那只是无聊的部分。这基本上是为L2页面目录创建和分配顶级页面目录。然后这是我的KVM，相当于里面的KVM。所以我在这个网站上得到了父权制的顶部，然后基本上我从KVM已经设置的计时页面表中复制了顶部的511条目。这样就给了我大部分的内核页表。</p>
<p>发言人   36:15<br>And then I just have to mapping all the devices that live. In the zero entry. Because in the zero entry entry that we’re going to modify it later or we’re going to map the usual pages into the bottom. And there’s a couple devices that live in that in the zero of entry. And those devices need to be added to the to this per process page table, kernel page table. And so maybe I come back to this picture earlier. So let me pull it up the kernel page table again. Yeah, maybe this picture as good as any.<br>然后我只需要映射所有运行的设备。在零的条目中。因为在零条目中，我们稍后要修改它，或者我们要将通常的页面映射到底部。并且有几个设备生活在其中，处于入口的零点。并且这些设备需要添加到每个进程的页表内核页表中。所以也许我会早点回到这张照片。所以让我再次将其从内核页表中提取出来。是的，也许这张照片和其他照片一样好。</p>
<p>发言人   37:01<br>So if you think about my solution, basically these entries I just share with the existing kernel page table. So I don’t have to allocate any L 1 or L 2 or L 0 levels. They already exist. And the only thing I do is basically literally copy that PTV entry. And so only the bottom part or the bottom entry, that is the piece I need to actually rebuild or copy explicitly instead of copying Ptes.<br>所以，如果你考虑我的解决方案，基本上这些条目我只是与现有的内核页表共享。所以我不需要分配任何L 1、L 2或L 0级别。他们已经存在了。我做的唯一一件事基本上就是逐字复制那个PTV条目。所以只有底部或底部条目，这是我需要实际重建或复制的部分，而不是复制Ptes。</p>
<p>发言人   37:32<br>And that covers, you know, the bottom 1 GB, the address space, one page garfish in a 496. And so this, you know, this entry you covers 5 to 12. This is the 2 MB and this is 1 GB. And basically only one of these entries I need to fill in. Does that make sense? So returning to my code, and basically that’s all I do in KVM create 8.<br>这涵盖了底部的1个GB，即地址空间，one page在496中使用garfish。所以这个，你知道，这个条目涵盖了5到12个。这是2个MB，这是1个GB。基本上我只需要填写其中一个条目。感知了吗？所以回到我的代码，基本上这就是我在KVM中创建8所做的一切。</p>
<p>发言人   38:13<br>And KVM 3 is maybe not maybe cleanest solution, but I take full advantage of the knowledge that I don’t have to do anything from the entries 1 to 511 in the top 8 level directory. The only entry I can do anything about is the bottom entry of the kernel of the top level directory that points to 1 L 1 entry and dot 1 ln 1 tree. I usually need to go through three old L 2 or L 0 entries and then the end, you know, 3, the L 1, and then the kernel page table. And so that’s my KVM 3 and my KVM create, so that allows me to create a kernel page table per process. And then free one is when we’re done.<br>而KVM 3可能不是最干净的解决方案，但是我充分利用了知识，我不必对顶级8级别目录中的条目1到511做任何事情。我可以对其执行任何操作的唯一条目是顶级目录内核的底部条目，该条目指向1 L 1条目和点1 ln 1树。我通常需要浏览三个旧的L 2或L 0条目，然后是结尾，你知道的，3，L 1，然后是内核页表。这就是我的KVM 3和KVM创建，这样我就可以为每个进程创建一个内核页表。然后当我们完成时，免费的一个。</p>
<p>发言人   39:02<br>So quick question, Yeah, could you explain again the reasoning for only using one to 512 and not 0? Yes, okay, so maybe the easiest thing to do, actually, let me go back through the picture here. So we have a kernel dress base Rick. And you know, this is 0 eight zero zero zero, blah, blah, blah. What entry does 0 0 0 fall into for the top level page directory?<br>那么快速的问题，是的，你能再次解释一下只使用1到512而不是0的原因吗？是的，好吧，也许最容易的事情，实际上，让我回顾一下这里的图片。所以我们有一个内核连衣裙基里克。你知道，这是0 8 0，等等。对于顶级页面目录，0 0属于什么条目？</p>
<p>发言人   39:46<br>Slightly. Zeroth entry. No, not the zero entry, right? So what do we know? So zero entry, like this entry, how much does it cover this entry? How much address space does the bottom entry of the zero entry of the top level page Director toy cover?<br>稍微。第零个入口。不，不是零入口，对吧？那么我们知道什么？所以零条目，就像这个条目一样，它覆盖了这个条目多少？顶层页面的零条的底部条目董事多大的地址空间？</p>
<p>发言人   40:10<br>I think Clint is. It’s free between 0 and 0x 2 0 0 0. Yeah, so, okay, so many going into, I think you’re flowing in the right direction. So the bottom entry cup is 1 GB, right? And we know, I feel like maybe I can. We so the bottom entry is 1 GB, which. In that 1 GB, just the cleaned in the click correct UART vidio disk, I believe.<br>我认为克林特是。它在0和0 x2之间是免费的。是的，所以，好吧，这么多人进入，我认为你正朝着正确的方向流动。底部入口杯是1 GB，对吧？我们知道，我觉得也许我可以。我们，下面的条目是1个GB。在那1个GB中，我相信只是在点击正确的UART vidio磁盘中清洗过。</p>
<p>发言人   40:45<br>And then current base actually already sets up in a higher entry, right? And we could compute it if we wanted to. We could take 0x 8, 8 8 0 or x shifted 12, shifted 9, shifted 9. And I think I do remember at the top of the head what it is, but we could try to figure it out.<br>那么目前的基数实际上已经建立在更高的条目中了，对吗？如果我们愿意，我们可以计算它。我们可以取0 x8，8 8 0或x移位12，移位9，移位9。我想我确实记得它的顶部是什么，但我们可以尝试弄清楚。</p>
<p>发言人   41:05<br>One, 2, actually, maybe we’ll try. This is always very risky to do in lecture, but. So Dvb, I need to, so let’s go to. Layout here’s current B’s.<br>一，二，实际上，也许我们可以试试。在讲座中这样做总是非常冒险的，但是。所以Dvb，我需要，所以让我们去。布局这里是当前的B。</p>
<p>发言人   41:29<br>So we could print. So shift this 12 that gives us the bad offset’s.<br>所以我们可以打印。因此，将这个12移位，这会给我们带来坏的偏移。</p>
<p>发言人   41:46<br>Okay, this is that. So then we’ll shift that guy. I think you can say this 9, right, I guess is the next entry. One more. So this entry 2, does it make sense? So we go back to our picture here. Basically, Kern Base is entry 2 in the top level patriarch, right? So, and we know from the third part of the assignment that basically we don’t really have to worry about anything above click and, you know, all that stuff falls actually in entry 0.<br>好的，就是这个。那么我们就转移那个人。我想你可以说这9，对吧，我想这是下一个条目。还有一个。那么这个条目2，它有感知吗？所以我们回到这里的图片。基本上，克恩基地是顶级族长的第二入口，对吗？所以，我们从作业的第三部分知道，基本上我们不必担心点击以上的任何事情，你知道，所有这些东西实际上都在条目0中。</p>
<p>发言人   42:34<br>Okay, that should really requesting, yes, thank you. Okay, so now we, the only thing we have left to do is, you know, double check where we got the call dysfunction KVM create and. You know, that’s going to be in AOC PC and.<br>好的，那应该真的要求，是的，谢谢。好的，现在我们唯一剩下要做的就是，你知道，仔细检查我们在哪里得到了KVM创建的功能障碍。你知道，那将会在AOC PC上进行。</p>
<p>发言人   43:12<br>Whereas the new process initializes, and you know I’m sure all of you do this exactly the same way. You know, you entry, you allocate when you declare a field in the proc structure. And basically the result of it is actually what we stick in the kernel page table.<br>而新进程初始化了，你知道的，我相信你们所有人都是用同样的方式做的。你知道，当你在proc结构中声明一个字段时，你就会进行分配。基本上它的结果实际上就是我们粘贴在内核页表中的内容。</p>
<p>发言人   43:27<br>Okay, and then the only other thing that we have to worry about is, of course, we need to use the page table. And so we need to look at the scheduler. And basically the assignment more or less told you what to do, which is before you switch to that user process, you need to switch to kernel page tables, which basically means loading the disk, process kernel page table in satp. And then when you’re done switching and running the other processing, you can back from running the other process. And you’re going to go back and run the scheduler. You got to switch back to the main kernel page table, the D kernel page table, because that’s the one that actually use fetch your scheduler. And why do we need to do this switch? Why is this important?<br>好的，然后我们唯一需要担心的另一件事是，当然，我们需要使用页表。所以我们需要看看调度器。基本上，分配或多或少地告诉你该怎么做，也就是在你切换到那个用户进程之前，你需要切换到内核页表，这基本上意味着在satp中加载磁盘，处理内核页表。然后，当您完成切换并运行其他处理后，您可以从运行其他进程返回。然后您将返回并运行调度程序。你必须切换回主要的内核页表，即D内核页表，因为那是实际使用fetch你的调度器的页表。我们为什么需要进行这种切换？为什么这很重要？</p>
<p>发言人   44:16<br>Anybody? So it picks the right kernel page table because the Sat, when you go to the page table entries, it picks the right, it picks the right page table to pick from. Something, hold that in a second. Yeah, so, okay, so when we stop, okay, let me another way to ask this question. When is this kernel page staple freaked? When the user process is done. So if we didn’t switch, that would mean that we could be using a page table of a process that was being freed. So the page table was freed. So we don’t want to be dependent on the process we’re not running right now. Yeah, exactly correct.<br>有人吗？因此，它会选择正确的内核页表，因为当您转到页表条目时，它会选择正确的，它会从中选择正确的页表。有些东西，保持在一秒钟内。是的，所以，好的，当我们停下来的时候，好吧，让我用另一种方式问这个问题。这个内核页面钉什么时候被吓坏了？当用户进程完成时。因此，如果我们不切换，这意味着我们可以使用一个被释放的进程的页表。因此页表被释放了。所以我们不想依赖于我们现在没有运行的过程。是的，完全正确。</p>
<p>发言人   45:06<br>We can never free the page table of a process that’s currently running. So we have to have some plan, you know, to actually free processes at the point that they’re not running anymore. And the wage system call is a way out, basically wait calls, looks, if there’s any children that are that can be cleaned up and then it cleans them up. And but that means that basically when the you pair process, the please open process, we’re going to make absolutely sure that that the page table that’s loaded in the s.p. register one of the, it’s not that process pageable where are actually currently free. Now that could be the case. There’s no process running at all, right? And so the scheduler basically has his own page table so that all processes can actually be cleaned up. Does that make sense?<br>我们永远无法释放当前正在运行的进程的页表。所以我们必须有一些计划，你知道，在进程不再运行时释放它们。而工资系统的呼叫是一条出路，基本上是等待呼叫，看，如果有任何孩子可以清理，然后它会清理他们。但这意味着，基本上当您配对进程，请打开进程时，我们将绝对确保在s.p中加载的页表。 注册其中一个，该进程不是可分页的，实际上当前是免费的。现在可能就是这种情况。根本没有进程在运行，对吧？因此调度器基本上有自己的页表，这样所有进程都可以被清理。感知了吗？</p>
<p>发言人   46:06<br>Sorry, I had a question. Is it that you’re mapping the c.l. int into the new process kernel ph tables? I do, why? Because I think the assignment said like I only have to user processing will not be bigger than the client or static, both the click and the client, right? And so, but I think the assignment told us that. So what is the lowest one? I think the. Plik is the loads 1, and basically the sign told us that the user process will not be bigger than the click.<br>抱歉，我有一个问题。是你在映射c.l. 进入新的进程内核ph表？我知道，为什么？因为我认为分配所说的只是用户处理不会比客户端或静态更大，无论是点击还是客户端，对吧？所以，但我认为任务告诉了我们。那么，最低的是什么？我认为。Plik是负载1，基本上这个符号告诉我们用户进程不会比click大。</p>
<p>发言人   46:51<br>Just to make it easy. And we could have done, we wanted to make it as easy as possible for you clear. And you could have done better if you wanted to. But, you know, that was the simplest thing to do. So you have to make duse modifications to get it to work.<br>只是为了方便。而我们本可以做到的，我们想让你尽可能地清楚明白。如果你愿意，你本来可以做得更好。但是，你知道，那是最简单的事情。所以你必须对数据进行修改才能使其工作。</p>
<p>发言人   47:11<br>Any further questions? I have a question, is it possible that you can copy 0 to 512 and then every time you switch, so you’re still using like the global root page table, except you only copy the first root page table and every time you switch a process, you copy over the user’s addresses over to, yeah, is that possible to do principle?<br>还有什么问题吗？我有一个问题，是否有可能你可以复制0到512，然后每次切换，所以你仍然在使用像全局根页面表一样的东西，除了你只复制第一个根页面表，每次切换一个进程，你将用户的地址复制到，原则上可行吗？</p>
<p>发言人   47:39<br>I think you could do something like that. So instead of basically doing, when you allocate a process and free, you could do dynamically during scan or switch, it seems complicated. That might be more costly because that means that every time you switch between food processes, you have to make a copy of parts of the kernel page table. And so that might be to perform.<br>我觉得你可以做这样的事情。因此，当您分配进程并释放时，您可以在扫描或切换期间动态执行，而不是基本上这样做，这似乎很复杂。这可能更昂贵，因为这意味着每次在食品工艺之间切换时，都必须复制内核页面表的各个部分。这可能是要执行的。</p>
<p>发言人   48:06<br>It’s not an ideal thing. The assignment didn’t really say anything about it. You might have timed out in user test if you did that. I was just wondering because I tried that approach and it was a bad experience, I can imagine, but I think it’s in principle possible. You know, you could usually allocate a new page table correctly and switch every time and a free when you switch out.<br>这不是一件理想的事情。作业并没有说什么。如果你这样做，你可能会在用户测试中超时。我只是想知道，因为我尝试过那种方法，那是一次不好的经历，我可以想象，但我认为原则上这是可能的。你知道，你通常可以正确地分配一个新的页表并每次切换，当你切换时会释放一个空闲。</p>
<p>发言人   48:38<br>I don’t think it’s the simplest, but principle it’s possible. I think perhaps there’s some other modifications to XV 6, but. Any other questions?<br>我不认为这是最简单的，但原则是可能的。我想XV 6可能还有其他的修改，但是。还有什么问题吗？</p>
<p>发言人   48:56<br>Because the only other change that you, of course, have to make is you usually trap red. You got to make sure that actually you run with the processes kernel page table. Okay, okay, so let’s switch then to, I guess, part 3. So we’re switch back to actually. Here? Okay, so actually that’s maybe not a helpful picture that we see showing here. Okay, so part 3.<br>因为你唯一需要做的其他改变当然就是你通常会陷入困境。你必须确保你实际上使用进程内核页表运行。好的，好的，那么让我们切换到第三部分。所以我们实际上要切换回。这里？好的，实际上这可能不是我们在这里看到的一张有用的图片。好的，第三部分。</p>
<p>发言人   49:37<br>So basically what our plan is, is we have our kernel page table as before, and we have the click entry sitting somewhere. And what we’re going to do is we’re going to use every between glow click to actually store the user. Page table. Or we’re going to map the user page table into all the user. The user program actually in the kernel page table in the bottom. And that’s the goal.<br>所以基本上我们的计划是，像以前一样拥有我们的核心页表，并且我们将点击条目放在某个地方。我们要做的是，我们将使用每次发光点击来实际存储用户。页表。或者我们将用户页表映射到所有用户。用户程序实际上在底部的内核页面表格中。这就是目标。</p>
<p>发言人   50:10<br>And of course, the first question to ask, you know, why the heck do that? Is there any advantage of it? And I think there may be the easy way to see why it might be interesting is to compare the copy ends, the new copy in and the old copy in. So if you know, so what happens in copying, correct?<br>当然，第一个要问的问题是，你知道的，为什么要这样做？这样做有什么优势吗？我认为可能有一个简单的方法来理解为什么它可能很有趣，那就是比较副本结束，新的副本和旧的副本。如果你知道，那么复制会发生什么，对吗？</p>
<p>发言人   50:37<br>When copying copies data from the user space into the kernel address space? And, but, you know, if the kernel does not have the user address base mapped, basically the kernel has to do this page at a time because the pages in virtual space might be continuous when the physical address space, they’re not continuous. And basically, what the kernel does in copying, it basically translates the virtual user address into a physical address. Since the kernel has all physical memory mapped with an identity mapping, the physical dress is also a valve with kernel virtual dress. And then it basically moves whatever part of that page, physical page that needs to be copied, it actually copies it. And so if a data structure, for example, spans, you know, to a page bound reading, like for example, this is info structures that you used in Lab 2, maybe it spins a page table boundary, it will copy like maybe, you know, some bytes from the first physical page and then some bytes from second physical page. Does it make sense? So that’s what the current copying does.<br>当复制将数据从用户空间复制到内核地址空间时？并且，但是，你知道，如果内核没有映射用户地址库，基本上内核必须一次处理这个页面，因为虚拟空间中的页面可能是连续的，而物理地址空间中的页面不是连续的。基本上，内核在复制时所做的是，它基本上将虚拟用户地址转换为物理地址。由于内核的所有物理内存都映射为身份映射，因此物理着装也是一个带有内核虚拟着装的阀门。然后它基本上会移动该页面需要复制的物理页面的任何部分，实际上是复制它。因此，如果一个数据结构跨越了一个页面边界阅读，例如，这是你在实验2中使用的信息结构，也许它会旋转一个页表边界，它会像复制一样，你知道，第一个物理页中的一些字节，然后是第二个物理页中的一些字节。它有感知吗？这就是当前复制所做的。</p>
<p>发言人   51:54<br>And the goal was basically to get them to a new copying where the kernel program didn’t really have to worry. About the physical layout, basically off the usual address space. And in this new copy you we see, we basically do nothing, literally nothing else than just copy. From the user addresses straight into the kernel. And we don’t really have to call walk anymore because we can rely on we set up the page tables correctly and the page table hardware will do the work for us. And so that was the goal. And so it makes life of kernel programmers a little bit easier. Are there any other advantages to this approach?<br>目标基本上是让他们进行一个新的复制，内核程序不必真正担心。关于物理布局，基本上脱离了通常的地址空间。在我们看到的这个新副本中，我们基本上什么也不做，实际上就是复制。从用户地址直接进入内核。而且我们真的不需要再调用walk了，因为我们可以依靠正确设置页表，页表硬件将为我们完成这项工作。这就是我们的目标。因此，它使内核程序员的生活变得更加容易。这种方法还有其他的优点吗？</p>
<p>发言人   52:45<br>Is it also more performant because the hardware is going to do the walking and not software? Yeah, well, one way to, I think, their performance implications for sure, one way to think about this is that in copying, correct? If the kernel data structure or the data data that we copied from user space to kernel space is big, we have to do the page at a time. And every page, we have to call this functional walk adder then does the internal walking. This might actually be reasonable. Expensive, expensive. What are examples? Are there examples of where kernel copies a lot of data from user space?<br>它是否因为硬件来做行走而不是软件而性能更高？是的，嗯，我认为有一种方法可以肯定它们对性能的影响，一种思考方法是在复制中，对吗？如果内核数据结构或我们从用户空间复制到内核空间的数据很大，我们必须一次处理页面。每一页，我们必须称之为功能行走加法器，然后进行内部行走。这实际上可能是合理的。昂贵的，昂贵的。什么是例子？有没有内核从用户空间复制大量数据的例子？</p>
<p>发言人   53:33<br>Which system call might copy a ton of data from user space, right? Yeah, right, right, right. You can give an arbitrary number, an arbitrary buffer of an arbitrary site, and the kernel may have to copy this into, for example, the file system or into a pipe. And so that could be reasonably expensive. The other thing, what is another advantage? If the user, we didn’t explore that in this assignment, we could have what? Another advantage? So if you think about someone, this code here, Craig, when it takes a structure out of user space, it copies the whole structure into kernel space. If user space is mapped into the kernel page table, do we have to do that?<br>哪个系统调用可能会从用户空间复制吨数据，对吧？是的，对，对，对。您可以为任意站点指定任意数量的缓冲区，而内核可能需要将其复制到文件系统或管道中。所以这可能是相当昂贵的。另外一件事，另一个优势是什么？如果用户没有在这个作业中探索，我们可以得到什么？另一个优势？所以，如果你想想这里的代码，Craig，当它从用户空间取出一个结构时，它会将整个结构复制到内核空间中。如果用户空间映射到内核页表，我们必须这样做吗？</p>
<p>发言人   54:31<br>For example, if we have to update 1 field of the structure.<br>例如，如果我们必须更新结构的1个字段。</p>
<p>发言人   54:46<br>So if the data structure is just mapped into the kernel address space, then we can just read and write, you know, with storing structures through that particular data structure. And we can just update 1 field like what the kernel now does. Basically, it copies the structure from kernel space, the user space, and then maybe you back out using copy out. And so if we map the user space into the user program, into the kernel address space, we can just manipulate it much more freely than the way we do it now. Does that make sense in terms of motivation? Why many kernels actually have this particular structure where they map the? Bottom part of the us map the user programming to the bottom part of the kernel address space.<br>因此，如果数据结构只是映射到内核地址空间，那么我们就可以通过特定的数据结构读取和写入存储结构。我们可以像内核现在所做的那样更新1个字段。基本上，它从内核空间、用户空间复制结构，然后您可以使用复制输出回退。因此，如果我们将用户空间映射到用户程序，映射到内核地址空间，我们可以比现在更自由地操作它。这在动机方面感知吗？为什么许多内核实际上具有映射的特定结构？美国地图的底部将用户编程映射到内核地址空间的底部。</p>
<p>发言人   55:39<br>Okay?<br>好吗？</p>
<p>发言人   55:44<br>Okay, so, so let’s see. Let me look at my code and see if you understand what actually. I did, so there’s basically one function that is the key, correct? We were building somewhere around a user page table, and then we just have to map the entries from the user page table into the kernel page table or to process this kernel page table. That function Kv have map user that exactly does this, and it’s pretty boring.<br>好的，那么，让我们看看。让我看看我的代码，看看你是否真正理解了什么。我做了，所以基本上有一个功能是关键，对吗？我们正在围绕用户页表构建某个地方，然后我们只需要将用户页表中的条目映射到内核页面表或处理此内核页面表。这个函数Kv有地图用户，可以完全做到这一点，这很无聊。</p>
<p>发言人   56:16<br>But I made a couple interesting points to point out. In work, it has the same sort of interfaces, UV ML or whatever, or basically if you go from the old size up to the new size paint at the time you find the. Uke? Pointer to the Pte for that particular virtual address in the user page table, right? So we look at the if we look at the picture that we had a little while back, look at the this picture, basically what this is going to return, correct?<br>但我提出了一些有趣的观点来指出。在工作中，它具有相同类型的接口，紫外线ML或其他任何接口，或者基本上如果你在找到它时从旧尺寸上升到新尺寸油漆。Uke?指向用户页表中特定虚拟地址的Pte指针，对吗？所以如果我们看一下我们很久以前的图片，看看这张图片，基本上这将返回什么，对吗？</p>
<p>发言人   56:59<br>It is we’re going to walk the user page table and we’ll find, for example, the group Pte that maps, you know, that particular virtual address. And we got a basically pointer to that entry into the page table. So? That’s what Wa does. And so if the thing is mapped, if it’s zero, it’s not zero. That must mean, you know, these damage. This is just check, double check that actually the mapping is there. We check that valid, just there’s debugging help.<br>我们将遍历用户页表，例如，我们将找到映射特定虚拟地址的组Pte。我们得到了一个基本上指向页表条目的指针。所以呢？这就是Wa所做的。所以如果这个东西被映射了，如果它是零，它就不是零。那一定意味着，你知道，这些损害。这只是检查，仔细检查映射是否确实存在。我们检查有效，只是有调试帮助。</p>
<p>发言人   57:30<br>In some sense, it should be the case that it is valid, And then I do the same thing in the kernel page table and look up that virtual address also in the processor kernel page table. But I call this time walk with one. So that actually allocates intermediate pages if necessary.<br>在某些感知中，它应该是有效的情况，然后我在内核页表中执行相同的操作，并在处理器内核页表中查找该虚拟地址。但我称这次为 “与一个人同行”。以便在必要时实际分配中间页。</p>
<p>发言人   57:49<br>Then once I got the pointer to the kernel Pt, I just copy the user Pt into the kernel Pt. So probably a lot of you called map page, but I’m just copy directly the Pte into the kernel Pte. And of course, now I got to disable some bits, which we’ll talk about in a second. But the essence of it is I just copy the kernel page, the Pte entries. And so that means that, for example, all the physical memory for the user program is just shared between the kernel space and user space.<br>然后，一旦我得到了指向内核Pt的指针，我就将用户Pt复制到内核Pt中。所以可能很多人称之为地图页面，但我只是直接将Pte复制到内核Pte中。当然，现在我必须禁用一些位，我们稍后会讨论。但它的本质是我只是复制内核页面，Pte条目。这意味着，例如，用户程序的所有物理内存仅在内核空间和用户空间之间共享。</p>
<p>发言人   58:28<br>Okay, does that make sense? Okay, so in terms of switching up some bits I’m a little bit more than necessary, but I switch off the execute bit, switch up the right bit, just copy in, only needs to read, never writes to it or copy out, does that. And then you have to switch up to do bit and that is sort of risk by specific thing that if you’re running in kernel mode and the new bit is set in the Pt entry, the kernel can actually not access that particular page. In fact, you can. This is almost a choice.<br>好的，那感知吗？好的，所以在切换一些位方面，我有点不必要了，但我关闭执行位，切换正确的位，只需要复制，只需要读取，从不写入或复制，这样做。然后你必须切换到执行位，这是一种风险，如果你在内核模式下运行，并且在Pt条目中设置了新的位，内核实际上无法访问那个特定的页面。事实上，你可以。这几乎是一种选择。</p>
<p>发言人   59:13<br>You can also actually program the Race 5 hardware. And basically in kernel mode, it ignores the U bit. And but XV 6 doesn’t do that. And so you have to switch up to u bit. Any questions about the ubit because the required number of you are asked about it?<br>你也可以实际编程第五场比赛的硬件。基本上在内核模式下，它忽略了U位。但是XV 6并没有这样做。所以你必须切换到u位。有任何关于ubit的问题，因为要求的人数被问到吗？</p>
<p>发言人   59:40<br>So is this done just to make sure that the kernel doesn’t do anything bad to user memory? Yeah, so why is this the case? This, you know, so the question is like, is this for debugging reasons or is there sort of isolation reason to do so? And I think this is mostly for debugging regions because the kernel is in full control anyway, right?<br>那么这样做只是为了确保内核不会对用户内存做任何不好的事情吗？是啊，为什么会这样呢？你知道，所以问题是，这是出于调试原因还是出于隔离原因？我认为这主要是为了调试区域，因为内核无论如何都是完全控制的，对吗？</p>
<p>发言人   01:00:02<br>The kernel can change, the satp register, it will, it can disable paging if it wants to. So it’s not like, you know, the user space is protected from the kernel. I think it’s mostly to basically help kernel developer. So for example, in XV 6 case, correct, unmodified XV 6 should never dereference the usual page period. And so that, you know, basically this just helps if you happen to do that by accident anyway, you would get immediately a page-fault a Ke will panic and will help the Colonel Andel debugger or developer to debug the kernel.<br>内核可以更改satp寄存器，如果需要，它可以禁用分页。所以它不像，你知道，用户空间受到内核的保护。我认为这主要是为了帮助内核开发者。因此，例如，在XV 6的情况下，正确的、未修改的XV 6应该永远不会取消引用通常的页面周期。因此，你知道，基本上这只是有帮助，如果你碰巧碰巧这样做，你会立即得到一个页面错误，一个Ke会恐慌，并将帮助上校Andel调试器或开发人员调试内核。</p>
<p>发言人   01:00:41<br>Does that make sense? Yeah, thank you. I have a follow up question to that. I think the part about the user bit makes sense, but what about the write and execute bits? Yeah, so does the execute bid have to be on?<br>感知了吗？好的，谢谢。我有一个后续问题。我认为关于用户的部分是感知的，但是关于写入和执行的部分呢？是啊，那么必须执行出价吗？</p>
<p>发言人   01:01:07<br>What does the kernel do with this page? The only reach from it, correct, The only thing, the only instruction that basically grabs data from this page is this men move instruction and copy in. So it only know does execute load instruction from it or loads values, you know, from that particular page. And the page should only contain data. So there’s no reason that the kernel should be writing to that page. And so just to be conservative, I disabled the right bit and there should be Kern can beavor executed structure from that page. So I just able to execute bit too. Again, this is mostly, I think, for debugging reasons, not isolation reasons. Okay, makes sense, thanks.<br>内核对这个页面做什么？唯一能够从这个页面获取数据的指令是这个人移动指令并复制进来。所以它只知道从它那里执行加载指令或加载值，你知道，从那个特定的页面。并且该页面应仅包含数据。因此，没有理由内核应该写入该页面。所以为了保守，我禁用了正确的位，并且应该从该页面中有Kern可以执行的结构。所以我也能够执行一下。再次强调，我认为这主要是出于调试原因，而不是隔离原因。好的，感知一下，谢谢。</p>
<p>发言人   01:02:00<br>Okay, so now the only thing we need to do is basically there’s a bunch of places where this code is being, where this function is being called. And when you sort of look at these places where it’s called to how you understand what’s going on or how it should be used. And I think maybe you one of the interesting ones that a number of you asked about is fork and exec. And we’ll talk about both of them. The first fork.<br>好的，现在我们唯一需要做的就是基本上有很多地方正在调用这个代码和这个函数。当你看看这些地方，它被称为如何理解正在发生的事情或如何使用它。我想也许你是其中一个有趣的人，很多人问的是fork和exec。我们将谈论他们两个。第一个叉子。</p>
<p>发言人   01:02:34<br>So here is the call to fork or to call to KVM map user in fork. And it takes. So the main interesting question I think a lot of you asked is, why does it have to be the new process kernel page table? Why does it have to copy from the new processor page table instead of from maybe the current process page table? Because it’s anyway an identical regularly form, but basically do just replicates the here’s a part of the page table. And so why can’t we use the current page table for doing that? And why in actual third application you actually have to use new the child user part of the page, child’s user page table? And why is that the case?<br>所以这里是对fork或对KVM map用户的调用。这需要。所以我认为很多人问的主要有趣问题是，为什么它必须是新的进程内核页表？为什么它必须从新的处理器页表复制，而不是从当前的进程页表复制？因为它无论如何都是一个相同的常规表单，但基本上只是复制了页表的一部分。那么为什么我们不能使用当前页表来做这件事呢？为什么在实际的第三个应用程序中，您实际上必须使用页面的新的子用户部分，即孩子的用户页表？为什么会这样？</p>
<p>发言人   01:03:36<br>Who have you noticed? What bug do you get?<br>你注意到了谁？你得到什么bug？</p>
<p>发言人   01:03:44<br>Wouldn’t get a remap error? You maybe not a remap error? Well, the thing, maybe that too. But again, the book I’m thinking of is not the remap 1. Remember, if you tried it out, what was your personal experience?<br>不会出现重映射错误吗？你可能不是重新映射错误？那件事，也许也是这样。但是，我正在考虑的书并不是重新映射1。请记住，如果你尝试过，你的个人经历是什么？</p>
<p>发言人   01:04:06<br>Anybody on the call who tried to jump and remember what they resulting experiences? I did not have, I think the. Resulting experience is that some were in us test, particularly you test to do a lot of forking and exiting.<br>有没有人在通话中试图跳跃并回忆起他们带来的经历？我想我没有。由此产生的经验是，有些人在美国进行了测试，特别是你进行了大量的分叉和退出测试。</p>
<p>发言人   01:04:26<br>You’re going to get a problem and you get a the thing that goes wrong is that if you copy from the parent process, if the parent process exits before the child processes us, then the parent process page table will be completely cleaned up as we saw before. And but then the child still has pointers to the parent process. Page table. And so basically, you’re going to be basically page in this child’s process. Page table have been freed and they’re still in use. And so that results in all kinds of bad behavior because the kernel 1 that frees a page actually writes the ones in it everywhere for debugging reasons. And so now basically you have invalid, you know Ptes sitting in your kernel page table. Does that make sense?<br>你会遇到一个问题，如果你从父进程复制，如果父进程在子进程处理我们之前退出，那么父进程页面表将被完全清理，正如我们之前看到的那样。然后子进程仍然有指向父进程的指针。页表。因此，基本上，你将基本上成为这个孩子的进程中的页面。页表已被释放，它们仍在使用中。这样会导致各种不良行为，因为释放页面的内核1实际上会出于调试原因在任何地方写入页面。所以现在基本上你有无效的，你知道内核页表中的Ptes。感知了吗？</p>
<p>发言人   01:05:38<br>Okay, one more thing to look at is exec DOC in my solutions. Are pretty straightforward? I almost made no modifications to exe. The only exit medication we wait is of course, you know, the first thing for, you know, part 1 and then here for part 3, it’s just basically mapping the new user page table into the kernel page table and exit basically what it DOS, just basically build a new user address space. And you know, there’s one line copies of new user address phase into the kernel page table. And that’s it?<br>好的，还有一件事需要看，就是我的解决方案中的exec DOC。很简单吗？我几乎没有对exe进行任何修改。我们等待的唯一退出药物当然是，你知道的，第一件事，你知道，第一部分，然后在这里第三部分，它基本上只是将新的用户页表映射到内核页表中，并退出基本上它的操作，基本上只是构建一个新的用户地址空间。并且你知道，在内核页面表中有一个新用户地址阶段的行副本。就这样？</p>
<p>发言人   01:06:21<br>Any questions? So I hope in the meantime I’ve answered many of the questions that you submitted, but we can look and see which ones. There were a couple of more questions that I haven’t talked about yet, so maybe we can look at those unless you have questions right away.<br>有问题吗？所以我希望与此同时，我已经回答了您提交的许多问题，但我们可以看看哪些问题。还有一些问题我还没有讨论过，所以也许我们可以看看这些问题，除非你马上有问题。</p>
<p>发言人   01:06:47<br>Don’t we modify the growth proc as well? Yes, yeah, a couple more changes necessary. Know in ebre or group rock per. And in the line right here, similar style. And there’s presumably a similar change in. Again, that might be it, actually. Oh, usually in it, of course, probably has to change because you have to map that one page from the init code into the kernel page table for that process, because the first process is special.<br>我们不也修改了生长过程吗？是的，还需要做一些改变。知道在ebre或group rock per中。就在这一行，类似的风格。大概也有类似的变化。再说一遍，实际上可能就是这样。通常情况下，当然，可能需要进行更改，因为您必须将该one page从init代码映射到该进程的内核页表中，因为第一个进程是特殊的。</p>
<p>发言人   01:07:35<br>Okay, so I’m going to walk through some of the questions here that I put them on the screen so you can hopefully see them so I don’t have to fill read them out completely. I think the first question is a question that actually came up quite a bit about the p.t. you bit flag. I think we covered this also covered the fact that it’s not malicious, but it’s mostly for debugging reasons. Similar to question about like, well, if you’re in supervisor mode, can’t you do anything? Because you can switch to satp? You can, and the answer is yes, that’s all possible. So really, you know, the zoo bit is not about the user program being protected from the kernel was really as a flag to help the kernel developer build the kernel.<br>好的，我将浏览一下这里的一些问题，我把它们放在屏幕上，这样你就可以希望看到它们，这样我就不必完全读出来。我认为第一个问题实际上是关于p.t的很多问题。 你咬了一下国旗。我认为我们涵盖了这一点，也涵盖了它不是恶意的，但主要是出于调试原因。类似于这样的问题，如果你处于主管模式，你不能做任何事情吗？因为你可以切换到satp？你可以，答案是肯定的，那都是可能的。所以，你知道，动物园位并不是关于用户程序被保护免受内核的影响，它实际上是帮助内核开发人员构建内核的一个标志。</p>
<p>发言人   01:08:25<br>One other specific sort of risk 5 question, which is why are the interfering pro-ed age, why the register sort of in a strange order? And the reason for that is, I think we mentioned this a little while ago in the previous lecture, that there’s basically, there’s something that’s called the risk 5 compressed instruction set. And that has a set of few registers. And so do you have to have a more compact encoding of the instructions? The strange ordering reflects the fact that they’re basically two. There’s the compressed version, which is some sort of registers, and then sort of the uncompressed version, which is what we’re using that has the complete set of registers. And the compression version example has as one and a 0, as 0 and S 1, but not S 2 for S 11. So that’s the main reason, I think I went through most of these questions.<br>另一个特定类型的风险5问题是，为什么会出现干扰年龄，为什么寄存器的顺序奇怪？其原因是，我想我们在之前的讲座中提到过，基本上有一个叫做风险5压缩指令集的东西。这有一组几个寄存器。那么，您是否需要对指令进行更紧凑的编码？这种奇怪的顺序反映了它们基本上是两个的事实。有压缩版本，它是某种寄存器，还有未压缩版本，这是我们使用的具有完整寄存器集的版本。并且压缩版本示例的值为1和0，为0和s1，但对于s11没有s2。这就是主要原因，我想我回答了大多数问题。</p>
<p>发言人   01:09:29<br>If you see a question that I should have covered and I didn’t, please interrupt me. Or if you ask a question that I haven’t covered yet. Please ask. These questions were basically in order that you submitted them.<br>如果你看到一个我应该回答但我没有回答的问题，请打断我。或者如果你问了一个我还没有涵盖的问题。请问。这些问题基本上是按照你提交的顺序来的。</p>
<p>发言人   01:09:48<br>Okay, here, maybe. So here’s a question. Do operating systems use article page tables have to set up the page table pages so that the lower parts of the hierarchy are least partly shared? And you clear on my solution, correct? I share the entries 1 to 511. And so this is a standard trick and lots of operating systems do that.<br>好吧，这里，也许吧。所以这里有一个问题。操作系统是否使用物品页表必须设置页表页面，以便层次结构的较低部分至少被共享？你清楚我的解决方案，对吗？我分享了条目1到511。因此，这是一个标准的技巧，许多操作系统都这样做。</p>
<p>发言人   01:10:17<br>I think we talked a little bit about this particular issue that is important that you switch to this main kernel page table because there might be no user processors to run at all anymore, and the schedler course still needs a page table. And so it runs with the name kernel page table. Have a question in the chat? Ahead?<br>我想我们谈到了这个特定的问题，这对于切换到这个主要的内核页表非常重要，因为可能不再有用户处理器可以运行，并且schedler课程仍然需要一个页表。因此它以内核页表的名称运行。在聊天中有问题吗？前面？</p>
<p>发言人   01:10:55<br>I can read it, yeah. Yeah, I got it. So I think, you know, because the question is not from the risk brief specs say that part of the separation is to prevent bugs that allow user program to make the kernel jump to arbitrary coding user space. Yes, that’s a good point. And so you can debate here whether this is an isolation property or a kernel debugging property. Clearly, the kernels would never jump into any part of the user address space directly. And so. I view this as a tool to help the kernel debugger, those kinds.<br>我能读它，是的。是的，我知道了。所以我认为，你知道的，因为问题不是来自风险简报，规范说分离的一部分是为了防止允许用户程序使内核跳转到任意编码的用户空间的错误。是的，这是一个很好的观点。因此，您可以在这里辩论这是一个隔离属性还是内核调试属性。显然，内核永远不会直接跳转到用户地址空间的任何部分。所以。我将此视为帮助内核调试器的工具。</p>
<p>发言人   01:11:35<br>Of disable or set the U bit and don’t allow the kernel to refer to any pages? Do text you us know you did reference every user address that the kernel will actually fallulah?<br>是否禁用或设置U位，并且不允许内核引用任何页面？你是否知道你确实引用了内核实际上会fallulah的每个用户地址？</p>
<p>发言人   01:12:02<br>I think IA confident scheduler, point to.<br>我认为自信的调度器，指向。</p>
<p>发言人   01:12:13<br>So user question, how pipes implemented nextv 6 and should the change to page implemented in the page table app effective implementation? So pads are basically a buffering memory in the kernel write when you write to a pipe, basically calls copy in and copy in your copy debate from user space into the pipe. And in some ways, you, the whole part of this page shape lab, which basically streamlined that code so that you don’t have to do menu walks.<br>所以用户的问题是，管道如何在下一个6中实现，页表中对页面的更改应该应用程序有效的实现吗？所以Pad基本上是内核中的缓冲内存，当你写入管道时，基本上调用copy in并将你的副本辩论从用户空间复制到管道中。在某些方面，这个页面形状实验室的整个部分，基本上简化了代码，这样你就不必进行菜单遍历。</p>
<p>发言人   01:12:42<br>One, you actually write from user states into the. There’s an interesting question I think a lot of people ask you, like, why does UV and 3 and free walker reach and you panic at the leaf? And the reason is that we put that panic in there because in Baro, that was an indication that the new variant in XV 6 would be broken. And that’s the invariant for unmodified XV 6. In this particular case, that is not true. And so you have to basically get rid of the panic and realized that it was not important to panic there, or you should not panic there. I think we talked quite a bit about like, why VM copy news, why the new VM copy is a good 1, Okay, here’s another question.<br>一，你实际上是从用户状态写入。我想很多人会问你一个有趣的问题，比如，为什么紫外线加3和自由步行者伸手而你惊慌失措？原因是我们把这种恐慌放在了那里，因为在巴罗，这表明XV 6的新变体将被破坏。这就是未修改的XV 6的不变量。在这种特殊情况下，这不是真的。因此，你必须基本上摆脱恐慌，并意识到在那里恐慌并不重要，或者你不应该在那里恐慌。我想我们谈了很多关于为什么VM复制新闻，为什么新的VM副本是一个好的1，好的，这是另一个问题。</p>
<p>发言人   01:13:36<br>Let’s say, and this is maybe an interesting one question that was asked, or sort of more design question. And it helps to have a picture. We look at the kernel dress space, or we limit it. We user programs can be bigger. We said basically us programs can grow through the clean address no further. Let’s say we actually wanted to grow like all the way to here. How could we do that? How should we change the design that would allow that?<br>比方说，这可能是一个有趣的问题，或者更多的设计问题。有一张照片是有帮助的。我们看一下内核的着装空间，或者我们限制它。我们的用户程序可以更大。我们说过，基本上我们的程序不能通过干净的地址进一步增长。假设我们实际上想要一路成长到这里。我们怎么能这样做？我们应该如何改变允许这样做的设计？</p>
<p>发言人   01:14:18<br>Anybody? Could we remap the stuff like Clint and plic and you are, yeah, where would you map it? So where if you wanted to do free up, basically that part of the address phase where what could you do? Map it to like a custom thing before current base and after like before physical stop and after current base. Yeah, or maybe actually better to have fish stock.<br>有人吗？我们可以重新映射像Clint和plic这样的东西吗？是的，你会在哪里映射？那么，如果你想做 “释放”，基本上就是地址阶段的那部分，你可以做什么？将其映射到像当前基础之前和之后的自定义事物，在物理停止之前和当前基础之后。是的，或者实际上最好有鱼群。</p>
<p>发言人   01:14:51<br>Here’s a huge amount of free space, like address space that’s unused like this from here to there is basically used for physical memory. And we basically could set up mappings here, right? For example, we could put the UART here like UAR zero, we could put just about fish page and basically set up a mapping that maps through that particular physical address. And then that will free you up this mapping. And we could use it to the user space. So similarly, we could do that for Ur 0 or for luge IO disk for Blake and Clint and real kess do that. Does that make sense?<br>这里有大量的可用空间，例如从这里到那里未使用的地址空间，基本上用于物理内存。我们基本上可以在这里设置映射，对吗？例如，我们可以将UART放在这里，就像UAR zero一样，我们可以放置大约鱼页面，基本上建立一个映射，映射到该特定的物理地址。然后这将释放您这个映射。我们可以将其用于用户空间。同样地，我们可以为Ur 0或为Blake和Clint和real kess的luge IO磁盘这样做。感知了吗？</p>
<p>发言人   01:15:36<br>It isn’t that problematic though, because we would we want the same same mapping as the original kernel page table has. Well, we have to do it in every Kern, every kernel page table, correct? We have copy, We have to map it, oh, everywhere at that particular location.<br>但这并不是什么问题，因为我们希望得到与原始内核页表相同的映射。好吧，我们必须在每个克恩、每个内核页表中都这样做，对吗？我们有副本，我们必须将其映射到特定位置的每个地方。</p>
<p>发言人   01:16:00<br>I’m not sure that is a I’m not sure I answered your question, but I don’t think that’s a problem I see. So you do that mapping also in the original? Yeah? Yeah, we would have to do it also in the original one. And that’s easier. Like if the old kernel uniformly thinks about you are 0 sitting at the top.<br>我不确定这是一个我不确定是否回答了你的问题，但我不认为这是一个问题。所以你也在原始文件中进行映射吗？是吗？是的，我们也必须在原始版本中这样做。这更容易。就像老内核一致地认为你坐在顶部是0。</p>
<p>发言人   01:16:28<br>Now, a number of people ask this, like, why do we map the kernel stacks high up? What is the reason for that? Like so we can proc in it correctly, we map these kernel stacks high up. And if you did the copy approach, now you actually have to modify a cop proc in to actually copy over that mapping and. Why setting it up high in the virtual address space?<br>现在，很多人问这个问题，比如，为什么我们要将内核堆栈映射到高处？原因是什么？像这样我们可以正确地在其中进行proc，我们将这些内核堆栈映射到高处。如果你采用了复制方法，现在你实际上必须修改一个警察过程，以实际复制该映射和。为什么要将其在虚拟地址空间中设置得很高？</p>
<p>发言人   01:17:00<br>Anybody?<br>有人吗？</p>
<p>发言人   01:17:09<br>Is it specifically because the stacks in risk five grow downwards and so you place it high in the address space so that it has space to grow downwards? How much the direct right direction, how much phase does it have to grow downward? That shouldn’t matter because it’s just one page, right? Yeah, it’s only one page. So what happens if you grow, you own one page.<br>是否特别是因为风险为5的堆栈向下增长，因此您将其放置在地址空间较高的位置，以便有空间向下增长？直接的正确方向有多少，向下增长的阶段有多少？这不重要，因为这只是one page，对吧？是的，这只是one page。那么，如果你成长，你拥有one page会发生什么。</p>
<p>发言人   01:17:37<br>You run into the car page, correct? And the car page is not mapped. And so the kernel will panic, which is better than actually you’re writing over its data structures. And so the reason it’s high up is because we put a guard page below it. Is there actually any physical memory associated with that guard page? No, no, there’s no physical memory associated with the car page, right? So that’s one of the cool things about putting it high is that we can put a car page below that actually doesn’t consume any physical memory. Okay, does that make sense? Oh, so basically the kernel stock page will be physical somewhere, but the card page won’t exactly.<br>你碰到了汽车页面，对吗？并且汽车页面未映射。所以内核会崩溃，这比实际上你在写它的数据结构要好。所以它之所以高是因为我们在它下面放了一个保护页面。实际上是否有任何物理内存与该保护页面相关联？不，没有物理内存与汽车页面相关联，对吧？所以把它放在高处的一个很酷的事情是我们可以在下面放置一个实际上不消耗任何物理内存的汽车页面。好的，那感知吗？基本上，内核库存页面将是物理的某个地方，但卡片页面不会完全相同。</p>
<p>发言人   01:18:26<br>Again, one of the cool things you can do with virtual memory, is it possible to overshoot the guard page? Yeah, that’s a great question.<br>再次强调，你可以用虚拟内存做的很酷的事情之一，是否有可能超过保护页面？是的，这是一个很好的问题。</p>
<p>发言人   01:18:34<br>You know what, what example? If you know, you all get the guard a buffer around the stack that actually is way bigger than the guard page, correct, and sort of goes into the next kernel stack page. And yeah, then you won’t have a serious bug. Most likely you will run into that anyway, right? Because you presumably would use the first entries of that buffer, and then you would get the page font, but. You could get a lucky. So this, this is not a bullet proof kernel debugging technique, but it has proven to be extremely effective. Great question.<br>你知道吗，有什么例子吗？如果你知道的话，你们都会在堆栈周围得到一个保护缓冲区，它实际上比保护页面大很多，正确的，然后进入下一个内核堆栈页面。是的，那么你就不会有严重的错误了。无论如何，你很可能会遇到这个，对吗？因为您大概会使用该缓冲区的第一个条目，然后您将获得页面字体，但是。你可以得到一个幸运。所以，这不是一种防弹内核调试技术，但它已被证明是非常有效的。好问题。</p>
<p>发言人   01:19:18<br>Any more questions? I’ll go back to the list. So we have a couple more minutes. And then actually we have one more minute I have a question. So once we have our kernel page tables for the processes, does it mean that in the trap code we don’t need to switch page tables? I think a great question was a good design question. And the answer is yes, you don’t need it, right?<br>还有什么问题吗？我会回到名单上。所以我们还有几分钟的时间。然后实际上我们还有一分钟的时间，我有个问题。所以一旦我们有了进程的内核页表，这是否意味着在陷阱代码中我们不需要切换页表？我认为一个好问题就是一个好设计问题。答案是肯定的，你不需要它，对吗？</p>
<p>发言人   01:19:51<br>The main reason that the kernel or in the trampoline code we go for all this trouble is because we have to copy the user. We have to switch from the kernel page table to the user page table. And the user page table or a page table doesn’t have the rest of the kernel mapped. And so the downside I’m not sure if that’s true because the perell needs to have the user block user flag on set.<br>我们在内核或蹦床代码中遇到所有这些麻烦的主要原因是因为我们必须复制用户。我们必须从内核页表切换到用户页表。并且用户页表或页表没有映射内核的其余部分。所以缺点是我不确定这是否正确，因为perell需要在设置上设置用户阻止用户标志。</p>
<p>发言人   01:20:17<br>Yeah, okay, so there’s couple of points I wanted to make. So in principle, you could simplify the T, let me put it this way, you can simplify entry and exit if you have a single page table that maps the user and the kernel in a single page table, because then you don’t have to switch, you will have to make a couple more modifications to actually 6 to make that happen. But in principle you could. And in fact Linux, until very reasonably used, you know, this sort of strategy of where the kernel and the user code are sitting in a single page table and relying on the basically the U bit, you know, to make sure that the. The user program couldn’t actually modify any kernel pages and the entry exit code in that case is slightly simpler because you don’t have to switch page tables when you enter or leave the kernel.<br>是的，好的，所以我想提出几点。原则上，你可以简化T，让我这样说，如果你有一个将用户和内核映射到单页表中，你可以简化进入和退出，因为你不需要切换，你将不得不对6进行更多的修改才能实现这一点。但原则上你可以。实际上，直到Linux非常合理地使用了这种策略，即内核和用户代码都在一个页表中，并且依赖于基本上的U位，你知道，以确保.用户程序实际上无法修改任何内核页面，在这种情况下，入口退出代码稍微简单一些，因为您进入或离开内核时不需要切换页表。</p>
<p>发言人   01:21:11<br>One thing that happened with, for example, the meltdown attack, if you might have sort of off side channel attack in response to the actually side channel attack Linux switch, whereas other mode of running, there are two modes of running one ISS called the kpti mode. And in that mode, basically that reflects basically what XV 6 does, you having a separate page table for the kernel and a separate page table for user space. Wait, so I still don’t understand why that’s that work. So let’s say the user process and the Pernel use the same page table. If the user memory has to have the user bit set, Cornell will not be able to access that user memory, right? This is okay.<br>发生了一件事，例如，崩溃攻击，如果您可能有某种场外通道攻击来响应实际的Linux开关，而其他运行模式，有两种运行方式称为kpti模式。在这种模式下，基本上反映了XV 6所做的事情，您为内核有一个单独的页表，为用户空间有一个单独的页表。等等，所以我仍然不明白为什么那是工作。因此，假设用户进程和Pernel使用相同的页表。如果用户内存必须设置用户位，康奈尔将无法访问该用户内存，对吗？这没关系。</p>
<p>发言人   01:22:01<br>On Intel processors, that is not the rule. So for example, an Intel processor, if your bid is set, the kernel could still write and read that page. Oh, that’s just a risk 5 thing. And even on the risk five, you can change it. There’s a bit in status Manager, you can set the title some bit. And if you set that, then basically in kernel mode, the view bit is ignored.<br>在英特尔处理器上，这不是规则。例如，对于英特尔处理器，如果您设置了出价，内核仍然可以写入和读取该页面。哦，那只是一个风险5的事情。即使在风险五的情况下，你也可以改变它。在状态管理器中，您可以将标题设置一些位。如果您设置了这个，那么基本上在内核模式下，视图位将被忽略。</p>
<p>发言人   01:22:23<br>Okay, so you’re telling me that there’s just 1 b in this CMO processor that made me stay up four hours later. I’m very sorry about that. I shouldn’t realize. No, no, no, it’s okay.<br>好的，所以你告诉我这个CMO处理器中只有1个b，让我在四个小时后熬夜。我对此感到非常抱歉。我不应该意识到。不，不，不，没关系。</p>
<p>发言人   01:22:35<br>It was, it was a fun realization when you reported, it reminded me of a bug that I actually had during the summer. And it was exactly that bug, but I forgotten about it. So my apologies for that. No, no, it’s okay. It was, it was fun figuring it out for sure, but I, at some point, I was just like, okay, like either I’m crazy or something’s completely wrong, So I’m just gonna go to sleep and submit this Piazza post. And hopefully when I wake up, someone will answer. And fortunately that was the case. So I was able to just continue right off when I when I did.<br>当你报道的时候，这是一个有趣的认识，它让我想起了我在夏天实际上遇到的一个错误。这正是那个bug，但我忘记了。所以，我为此道歉。不，不，没关系。弄清楚这件事真的很有趣，但是我，在某个时候，我只是想，好吧，要么我疯了，要么事情完全不对劲，所以我要去睡觉并提交这个广场帖子。希望当我醒来时，有人会回答。幸运的是，情况确实如此。所以当我这样做的时候，我能够立即继续。</p>
<p>发言人   01:23:08<br>Okay, so I think we ran over time a little bit, but hopefully this was helpful and reaffirm things for virtual memory. I think it was important to do because we’re going to get three more labs involved in virtual memory. And my hope is that after this one, you know, those are going to be easier than this experience. Can I ask something very quick? Yeah, so I’m staying on. So everybody want to stay on and ask more questions. Please feel free to do so if you need to go to the next class, please go.<br>好的，我想我们跑了一段时间，但希望这对虚拟内存有帮助并重申了一些事情。我认为这很重要，因为我们将再参与三个虚拟内存实验。我的希望是，在这次经历之后，你知道，这些会比这次经历更容易。我能快速问点什么吗？是的，所以我要留下来。所以每个人都想继续问更多的问题。如果你需要上下一节课，请随时去。</p>
<p>发言人   01:23:40<br>So basically in all the labs, like there’s a lot of mention of like, oh, this might be useful in future labs, but we never actually use any of the code that we write. What’s what’s the plan on that? Like, should we just import our code from a previous lab? Or like, I don’t want to because what if it’s bugy? I don’t want to, you know, impact the next? Yeah, so the one reason we don’t do it, why the labs don’t build on each other even though they could, is to avoid basic dependencies. Like if you had a bug in the rural lab that was not exposed by user tests or any of our tests, but we would be exposed to that new lab, then be painful.<br>所以基本上在所有的实验室中，就像有很多提到的那样，哦，这在未来的实验室中可能很有用，但我们实际上从未使用过我们编写的任何代码。这个计划是什么？比如，我们应该从以前的实验室中导入代码吗？或者，我不想，因为如果它是马车呢？我不想，你知道，影响下一个？是的，所以我们不这样做的一个原因，即使实验室可以互相建立，也是为了避免基本的依赖关系。如果你在农村实验室里有一个bug，它没有通过用户测试或我们的任何测试暴露出来，但我们会暴露在那个新实验室里，那么会很痛苦。</p>
<p>发言人   01:24:17<br>The reason I’m mentioning that is that basically the real thing about what’s going on is we’re going to do more stuff, the page table. So for example, this lab looks at simplifying copying. Later labs can look at changed to S break. They’re basically or forgone to the changes you made to the kernel for this lab. But you know, the fact that you’ve been thinking about kernel page table, user pages table so much will help you bluff. Really what helps you is the experience of debugging these kinds of problems due to incorrect page tables.<br>我提到这一点的原因是，基本上正在发生的事情的真正原因是我们将做更多的事情，页表。例如，这个实验着眼于简化复制。以后的实验可以查看已更改的S break。他们基本上或放弃了您在本实验中对内核所做的更改。但是你知道，你一直在思考内核页表，用户页表的事实将帮助你虚张声势。真正对您有帮助的是调试由于不正确的页表而导致的这些问题的经验。</p>
<p>发言人   01:24:53<br>Okay, I just wanted to make sure that it’s not like I’m missing out because I didn’t copy over my XR code from lab one or something, decided to purpose that the labs are not dependent on each other. Okay, thanks, see you on Wednesday. Wednesday?<br>好的，我只是想确保这不是我错过了，因为我没有从实验室复制我的XR代码，决定使实验室之间不依赖于彼此。好的，谢谢，我们周三见。星期三？</p>
<p>发言人   01:25:12<br>I had a follow up on my question about mapping. Mapping using the modification from the page table app. Would it be then needed to have the trampoline mapped in the user page tables?<br>我对有关地图的问题进行了跟进。使用页表应用程序中的修改进行映射。那么是否需要将蹦床映射到用户页面表中？</p>
<p>发言人   01:25:31<br>Okay, so haven’t really thought this through. So if you kernels, let’s say the kernel exit, so let’s say we have a joint one single page table, that’s the one year shown, correct? And we’re jumping out of the kernel through eurt And our goal is to we’re still running in kernel mode.<br>好的，所以还没有真正考虑清楚。如果你是内核，假设内核退出，那么假设我们有一个联合的单页表，那就是显示的一年，对吗？我们通过eurt跳出了内核，我们的目标是仍然在内核模式下运行。</p>
<p>发言人   01:25:51<br>So this page certainly accessible, correct? In the Vita kernel, the guard page. I’m not the car page when I’m saying the trampoline page is there and presumably somewhere we need to map maybe the.<br>那么这个页面肯定可以访问，对吗？在Vita内核中，守卫页面。当我说蹦床页面在那里时，我不是汽车页面，大概是我们需要映射的某个地方。</p>
<p>发言人   01:26:12<br>Well, the usual trap train, we don’t really, we have access to any, right? Because we’re running kernel mode. We know where it sits in the proc structure, or we can get it. So I think we can just exit and when we return, the user code can just run.<br>嗯，通常的陷阱火车，我们没有，我们可以访问任何，对吧？因为我们正在运行内核模式。我们知道它在过程结构中的位置，或者我们可以得到它。所以我认为我们可以退出，当我们返回时，用户代码可以运行。</p>
<p>发言人   01:26:30<br>You know, we have, of course, the U bit is a bit of a. Well, the Ubi is always set in pages that actually sit in the user space. So that’s fine too. So when we enter the Cola back in, you know, we’re still with this page table. That page table already has all the kernel now mapped, and we could just copy the registers that we need to save into the proc structure directly instead of having to go through there, have a separate page with the Pro in it. So I believe the change would be pretty straightforward.<br>你知道，我们当然有U位有点。嗯，Ubi总是设置在实际位于用户空间的页面中。这也很好。所以当我们重新输入可乐时，你知道，我们仍然使用这个页表。该页表已经映射了所有的内核，我们可以直接将需要保存的寄存器复制到proc结构中，而不必浏览那里，而是创建一个带有Pro的单独页面。所以我相信改变会很简单。</p>
<p>发言人   01:27:05<br>Okay, I see, thank you, but you, of course I could be wrong. Oh yeah i’m now going to try it out.<br>好的，我明白了，谢谢，但是我当然可能是错的。哦，是的，我现在要尝试一下。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>操作系统工程 006-Lab Q&amp;A</div>
      <div>http://example.com/2025/10/18/6S081-006/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月18日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/18/6S081-007/" title="操作系统工程 007-PageFaults">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">操作系统工程 007-PageFaults</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/18/6S081-005/" title="操作系统工程 005-Isolation SystemCall Entry">
                        <span class="hidden-mobile">操作系统工程 005-Isolation SystemCall Entry</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
