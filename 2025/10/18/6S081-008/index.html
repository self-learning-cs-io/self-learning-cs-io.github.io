

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="发言人   00:00For folks who already signed in, there’s curiosity. How has your experience been with the Traps Lab? If you already started on the Lazy Allocation Lab, how is that going here? Here, or what">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统工程 008-Interrupts">
<meta property="og:url" content="http://example.com/2025/10/18/6S081-008/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="发言人   00:00For folks who already signed in, there’s curiosity. How has your experience been with the Traps Lab? If you already started on the Lazy Allocation Lab, how is that going here? Here, or what">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-18T02:00:08.000Z">
<meta property="article:modified_time" content="2025-10-25T05:03:39.718Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>操作系统工程 008-Interrupts - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="操作系统工程 008-Interrupts"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-18 10:00" pubdate>
          2025年10月18日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          22k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          184 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">操作系统工程 008-Interrupts</h1>
            
            
              <div class="markdown-body">
                
                <p>发言人   00:00<br>For folks who already signed in, there’s curiosity. How has your experience been with the Traps Lab? If you already started on the Lazy Allocation Lab, how is that going here? Here, or what it average was is less painful than the page table app. And Andrew, you want to say something about that?<br>对于已经注册的人来说，有好奇心。你对陷阱实验室的经验如何？如果你已经开始了懒惰分配实验室，那么这是怎么回事呢？在这里，或者说平均而言，比页表应用程序的痛苦要少一些。安德鲁，你想说点什么吗？</p>
<p>发言人   00:32<br>I thought the drop slob was okay. It was just making sure that I actually used the trampoline page properly was a little annoying. Yeah, but once I figured that out, then then it just like kind of worked. Yeah, the whole goal was a lot of what you to really expose you to the year trap handling entry and exit.<br>我觉得那个空降懒汉还可以。只是确保我确实正确地使用了蹦床页面，这有点烦人。是的，但一旦我弄清楚了，那么它就有点起作用了。是的，整个目标是让你真正了解陷阱处理进入和退出的年份。</p>
<p>发言人   01:02<br>How about Amir was your experience with? I thought the trap slab was good, very much more manageable than the page table lab. I noticed that there were like opportunities to be clever about some aspects of the implementation, which was nice. And the lazy lab is good so far debugging, but both better than the page table live in my opinion. Well, to hear that. I’m sure you were glad to hear that. But like the other two. Timi? Yeah, these two previous labs have been a lot better than the page table 1. I guess the hardest part for the latest lab, the lazy one, was the read and write and all that stuff, but it’s not, it’s not that bad in my opinion.<br>你和阿米尔的经历如何？我认为陷阱板很好，比页表实验室更易于管理。我注意到有机会在实现的某些方面表现得聪明，这很好。到目前为止，懒惰实验室的调试工作做得很好，但在我看来两者都比页表更好。好的，听到这个。我相信你很高兴听到这个消息。但和其他两个一样。蒂米？是的，这两个前两个实验室比页表1要好得多。我猜最新的实验室最难的部分，懒惰的那个，是读写和所有这些东西，但事实并非如此，在我看来也没那么糟糕。</p>
<p>发言人   02:11<br>You Catherine, there’s the detractious in the laser lab for you with comparison to the page table lab.<br>凯瑟琳，与页表实验室相比，激光实验室为你减少了一些东西。</p>
<p>发言人   02:33<br>Are you there? Catherine, I guess. Catherine Wicker, hello. I’m doing well, sorry. I didn’t know which Catherine you’re talking to. I guess there’s only 20 people, so probably not likely that there’s another one I’m doing quite well. Good, good, so this, this life is less painful than the Peak Table Lab, where yes, it is definitely less painful. Excellent, yeah. Yeah, the one, the one after page tables, what was that traps? That was definitely much simpler. Okay, great, we’re glad to hear that. I think just wanted to get sort of an informal poll. See, you know, the pitch table turned out harder than we thought it would. And so glad to know these ones are better.<br>你在吗？我想是凯瑟琳。凯瑟琳·柳条，你好。我做得很好，抱歉。我不知道你在和哪位凯瑟琳说话。我猜只有20个人，所以可能不太可能还有另外一个我做得很好。好的，好的，所以这种生活比高峰实验室的痛苦少，是的，它绝对不那么痛苦。很好，是的。是的，那个，那个在页表之后的，那些陷阱是什么？这绝对简单得多。好的，太好了，我们很高兴听到这个消息。我想我只是想做一个非正式的投票。看，你知道的，俯仰台比我们想象的要难。很高兴知道这些更好。</p>
<p>发言人   03:21<br>Okay, so why don’t we get going and welcome to the next lecture in 681, wherever you are. So the topic of today is about interrupts. But before jumping into sort of talking about interrupts, I wanted to share a little bit.<br>好的，那么为什么我们不开始欢迎来到681的下一节课，无论你在哪里。所以今天的主题是关于中断。但在开始谈论中断之前，我想分享一点。</p>
<p>发言人   03:37<br>One thing that I wanted to talk about last week, which I didn’t get around doing too, and you know what, you might find an interstate. When you see if you can get my right screen here up. So here, you know, you see my screen here on the bottom left. I’m long game to Athena through the dial up machines. And there’s a couple things I wanted to talk about in terms of how memory is being used by a real operating system, since we talked a lot about that last week, and particularly in the end of the lecture where a lot of questions about, you know, page out finding free memory and all that kind of stuff. So this is one of the Athena machines.<br>上周我想谈论的一件事，也是我没有去做的，你知道吗，你可能会找到一个州际高速。当你看到你能否把我的右屏幕放在这里时。所以在这里，你知道，你看到我的屏幕在左下角。我要通过拨号上网设备与雅典娜进行长时间的比赛。有几件事情我想谈谈关于内存如何被一个真正的操作系统使用的方面，因为上周我们谈了很多，特别是在讲座的最后，有很多问题，你知道的，分页查找空闲内存和所有类似的东西。这是一台Athena机器。</p>
<p>发言人   04:21<br>One thing to note, if you look at the memory line, if it tells you how much, okay, the program is running is called top. Probably many of you have used it. You see how much machine memory is in machine. And as you can see, there’s quite a bit of memory in this machine. And if you look at a little bit carefully, you actually most of it is used. A large part of the memory is actually not being used by applications, but it actually used by the buffer cache. So this is quite common in an operating system.<br>需要注意的一件事是，如果你看一下内存线，如果它告诉你程序运行的大小，那么它叫做top。可能你们中的很多人都使用过它。你看到了机器内存在机器里有多少。正如你所看到的，这台机器有相当多的内存。如果你仔细看，实际上大部分都被使用了。很大一部分内存实际上没有被应用程序使用，而是被缓冲区缓存使用。所以这在操作系统中很常见。</p>
<p>发言人   04:54<br>You don’t really want to leave your physical memory sitting idle and do nothing. You might as well use it for something useful. And so in this case, you know, a good chunk of it is actually used for the buffer cache.<br>你真的不想让物理内存闲置着什么也不做。你不妨将它用于有用的事情。因此，在这种情况下，你知道，其中很大一部分实际上被用于缓冲区缓存。</p>
<p>发言人   05:07<br>There’s a little bit of memory free, not much, you know, fractions of like from the total memory that actually is in the machine. And so this is a very common case, like most operating systems sort of run basically almost no memory free at any particular instant in time. And so that means, for example, if an application or the kernel needs some memory, and we’ll have to throw out something, maybe it has enough a few pages where a handful of pages, but at some point it needs a lot of free memory, it will ask the eviction something either from the applications or from the buffer cache, and so you sort of A, and so the main point here basically is that you, when you currently need to allocate memory, it’s actually not generally not a cheap operation because you know, the memory is not, there’s not a ton of memory free available the other thing that’s sort of interesting to look at is I shorted the output of top by the amount of resident memory, right? So you look at every line for every process, you know, you see that this the size of the address space and then the next line actually tells you how much memory is actually being used like the physical memory, you know, the fraction of the address beta actually is in physical memory and as you can see it actually, you know, is typically even way smaller than the address space. So the tricks that we talked about last year, the cool ideas and virtual memory provides are being used here, like is demand paging, the shared column is shared pages, you know, from the shared libraries, and you see in general that basically the resonant memory is much, much, much smaller than the virtual address space, maybe in a couple other interesting things to sort of note. And just looking at this machine, the load is very low, even though they’re 120 years, 102 users logged in and you can see there’s a lot of processes, you know, 950 or rough. Another thing to note is actually how long the machine has been up, like 2 to 40 five-nines you, your X 6 kernel is probably not up that long at all ever. Okay, so that’s, you know, any questions about this?<br>有一点点内存空闲，你知道，机器中实际存在的总内存中的分数并不多。因此，这是一种非常常见的情况，就像大多数操作系统在任何特定时刻基本上几乎没有内存可用。这意味着，例如，如果应用程序或内核需要一些内存，我们将不得不扔掉一些东西，也许它有足够的几页，但在某些时候它需要大量空闲内存，它会要求驱逐一些来自应用程序或缓冲区缓存的东西，所以你有点，所以这里的主要观点基本上是，当你当前需要分配内存时，这通常不是一个便宜的操作，因为你知道，内存不是，没有吨可用的内存可用，另一件有趣的事情是，我用驻留内存的数量缩短了top的输出，对吗？所以你查看每个进程的每一行，你知道，你会看到地址空间的大小，然后下一行实际上会告诉你实际使用了多少内存，就像物理内存一样，你知道，地址beta的部分实际上在物理内存中，正如你所看到的，它通常比地址空间还小。所以我们去年谈到的技巧，很酷的想法和虚拟内存提供的技巧正在这里使用，比如按需分页，共享列是共享页面，你知道，来自共享库，你可以看到，基本上共振内存非常多，比虚拟地址空间小得多，也许需要注意其他一些有趣的事情。仅仅看着这台机器，负载非常低，即使它们有120年历史，102个用户登录，你可以看到有很多过程，你知道，950或粗糙。另一件需要注意的事情是，实际上机器已经运行了多长时间，比如2到40个5个9, 你的X 6内核可能从来没有运行那么长时间。好的，所以你知道，对此有什么问题吗？</p>
<p>发言人   07:15<br>Just sort of the main point being that like most memory is in use and the resident memory is typically much smaller than virtual address space. And you can, of course, run this yourself if you want to and see what actual websites up. Any questions you see some of the 6 0 8 1 students being logged in. If you look around, you see a whole bunch of Qus running, okay? And no questions.<br>主要的一点是，像大多数内存都在使用中，常驻内存通常比虚拟地址空间小得多。当然，如果您想查看实际的网站，您可以自己运行此程序。您看到的任何问题，一些正在登录的6 0 8 1名学生。如果你环顾四周，你会看到一大堆Qus在跑，好吗？没有问题。</p>
<p>发言人   07:46<br>Let me go back to the topic for today, which interrupts. And the basic idea is very straightforward. Or what we want to enable is that there’s going to be cases where the hardware wants attention. Going to attention now. You know, a packet comes in from the network. So the network internet, the network cart, gen engine interrupt user type, a key on the keyboard, and the keyboard generates an interrupt. And what the chauffer has to do is the chauff has to save its work, whatever it was doing right now, put that on the site, you know, process the interrupt.<br>让我回到今天的主题，这个话题被打断了。基本思想非常简单明了。或者我们想要实现的是，有些情况下硬件需要关注。现在要引起注意。你知道，一个包是从网络进来的。因此，网络互联网、网络购物车、引擎中断用户类型、键盘上的一个键，键盘生成一个中断。司机需要做的是保存它的工作，无论它现在在做什么，把它放在网站上，你知道的，处理中断。</p>
<p>发言人   08:41<br>And then resume or restore into the work that it is doing.<br>然后恢复或恢复它正在做的工作。</p>
<p>发言人   08:51<br>And basically that saving and restoring is very, very similar to the mechanisms that we already have seen before, namely for system calls. And perhaps? Like page faults, they all use the same mechanism.<br>基本上，保存和恢复与我们之前已经看到的机制非常非常相似，即系统调用。也许？像页面错误一样，它们都使用相同的机制。</p>
<p>发言人   09:18<br>So in that sense, the interrupts are no different whatsoever compared to traps or a system calls. But a couple things that make them a little bit different and why we’re actually spending a lecture on them. So the free basically thinks, make interrupt.<br>因此，在这种感知下，中断与陷阱或系统调用没有任何不同。但是有一些事情使它们有些不同，以及我们为什么要花一个讲座来讨论它们。所以自由人基本上认为，制造中断。</p>
<p>发言人   09:35<br>Slightly different from system calls and exceptions. One, we’re for a bit of word, and we’re going to call their asynchronous. And without a mean that the system, the interrupt that happens when the hardware reduction generator interrupts, and then the interrupt handler runs, that interrupt handler might actually have nothing to do with the current running process on the CPU. So unlike, for example, when you do a system call, when the system call happens, and then you jump into the kernel, then we’re running into context of the calling process. And this is not true within Russia. They might have been completely unrelated to actually the process that, you know, is running in the CPU might actually have nothing to do with the internet and or may not even have costed. So that’s the difference.<br>与系统调用和异常略有不同。一，我们想说一点，我们要打电话给他们的异步的。如果没有这一点，就意味着硬件缩减生成器中断时发生的中断，然后中断处理程序运行，该中断处理程序可能与CPU上当前运行的进程实际上没有任何关系。因此，例如，当您进行系统调用时，当系统调用发生时，然后您跳入内核，那么我们正在运行到调用进程的上下文。而这在俄罗斯内部并非如此。它们可能与CPU中运行的过程完全无关，可能与互联网无关，甚至可能没有成本。这就是区别所在。</p>
<p>发言人   10:22<br>Second of all, there is much more concurrency that we have seen so far. In fact, you know, this is a starting place where we’re talking about concurrency, and we’ll talk about it in Wednesday lecture a lot more. But the basic observation is that basically the CPU and the device that generate interrupt operate in parallel. The UART or the network art is doing its thing. You picking packets are from the network and then its own point, generating an interrupt. And while at the same time, the CPU is running and it also is doing its own Santa Fe. So we have like true parallelism, you know, going on between the device and the CPU. And we have to manage that parallelism, as we’ll see in a second.<br>其次，到目前为止，我们看到的并发性要多得多。事实上，你知道，这是我们谈论并发性的起点，我们将在周二的讲座中更多地谈论它。但基本的观察是，基本上CPU和生成中断的设备是并行工作的。UART或网络艺术正在做自己的事情。你选择的数据包来自网络，然后它自己的点，生成一个中断。同时，CPU正在运行，它也在做自己的圣诞老人。所以我们有真正的并行性，你知道，在设备和CPU之间进行。我们必须管理这种并行性，正如我们稍后将看到的那样。</p>
<p>发言人   11:05<br>And then finally, you, we’re going to be focused mostly on external devices like network cards and uarch. And those would have to be programmed.<br>最后，我们将主要关注外部设备，如网卡和uarch。那些必须被编程。</p>
<p>发言人   11:21<br>And basically, every device has sort of its own programming manual in the same way that sort of risk 5 has a manual with the instructions and which registers do walk, every device actually has a similar sort of type manual with describing what register it has, what operations you can perform, and what the device does, you know, responds to reading and writing control editors. Unfortunately, often the manuals for the devices are less clear than the Risk five manual, which makes programming even more complicated. And so what I’m going to do in this lecture is actually pretty straightforward if you want to talk about how the prompt shows up when the shell prints the front if you type LS, you know, how do these characters, you know, get read and actually then being displayed in the console? And in fact, so basically the rest of those lectures about these three characters. But all the mechanism that’s necessary to actually make that happen. Any questions so far before I start to diving in more a little deeper?<br>基本上，每个设备都有自己的编程手册，就像风险5有手册，说明哪些寄存器可以运行一样，每个设备实际上都有类似的类型手册，描述它有什么寄存器，可以执行哪些操作。设备的作用是什么，你知道的，响应读写控制编辑器。不幸的是，设备的手册通常不如风险五手册那么清楚，这使得编程更加复杂。因此，如果您想谈论当shell打印正面时，如果您键入LS，提示符如何显示，那么在本次讲座中，我要做的实际上非常简单，您知道，这些字符如何被读取并实际显示在控制台中？事实上，这些讲座的其余部分基本上都是关于这三个角色的。但是所有必要的机制来实际实现这一点。在我开始深入探讨之前，到目前为止有什么问题吗？</p>
<p>发言人   12:38<br>Okay? So let’s so the first question we ask is where do the interrupts come from?<br>好吗？那么，我们问的第一个问题是，中断来自哪里？</p>
<p>发言人   13:00<br>And so since I’m going to be focusing mostly in this lecture on external interrupts, you know, not timer interrupts or software interrupts, you know, the external interrupts here come from devices that are sitting on the board, and here are sci-fi fi board c.u. more or less amylases know there some small modifications. And we see there’s actually, you know, you look around, there’s the BT, there’s a lot of actually different devices there that, you know, can be connected, know to this board. You know, here are even Itt Connector. In fact, here’s a micro USB that says over there there’s a micro SD card, there are reset buttons. And so there are all kinds of sort of lines that must be running from those devices into the CPU. And most of this lecture is basically sort of understanding what happens at the CPU when the device generates an interrupt, and how to read and write and information from the device.<br>因此，由于我在本次讲座中将主要关注外部中断，而不是计时器中断或软件中断，你知道，这里的外部中断来自板上的设备，这里是科幻板。 或多或少的淀粉酶知道有一些小的修饰。我们看到实际上有，你知道，你环顾四周，有很多不同的设备，你知道，可以连接到这个板。你知道的，这里甚至还有Itt连接器。实际上，这里有一个微USB，上面写着那里有一个微SD卡卡，有重置按钮。因此，必须从这些设备到CPU运行各种类型的线路。这堂课的大部分内容基本上是理解当设备生成中断时CPU会发生什么，以及如何从设备读取和写入信息。</p>
<p>发言人   14:00<br>I believe, like these lower the two pins here at this expansion connector. I think the one of them is UART is the UART synth or transmission, and the other one is the UART, you know, 0. Receive light. And I think it’s actually to connect to both sides to micro USB as well as to this expansion cord. And I think the UAR chip itself, you know, might actually be inside of this chip over there.<br>我相信，像这样，在这个扩展连接器上降低两个引脚。我认为其中一个是UART，它是UART合成器或传输，另一个是UART，你知道的，0。接收光。我认为实际上是将两侧连接到微型USB以及扩展线。我认为UAR芯片本身，你知道，可能实际上在那边的这个芯片里面。</p>
<p>发言人   14:37<br>Okay, so basically there’s a bunch of lines running on the board into the CPU, you know? So we go zoom in a little bit more in detail on the CPU.<br>好的，基本上有一大堆线路在板上运行到CPU中，你知道吗？所以我们在CPU上进行更详细的缩放。</p>
<p>发言人   14:49<br>You know, here’s a schema from the, you know, the Sci Fifi documentation for the board or the process or the court that we, the VIX 5 process we were using and we looked at this a little bit before. And you know, we see here basically here are the devices correct on the right side here that you are 0. And you know, we know that basically the zero are 0 memory mapped. Some were in the physical address space like all the DRAM you sits on this side. We know, we know the DRM sits above all x 0 0 0. And below all 0 are the different devices. And basically with loads of storms, instructions to. Those physical addresses, we can actually program the UART, and we’ll look at that in much more detail in a second.<br>你知道，这是一个来自科幻小说文档的架构，用于我们使用的VIX 5流程的董事会、流程或法庭，我们之前已经看过了。你知道，我们在这里看到的基本上是右侧的设备，你是0。而且你知道，我们知道基本上零是零内存映射。有些在物理地址空间中，就像你坐在这边的所有DRAM一样。我们知道，我们知道DRM位于所有x0 0 0之上。所有0以下是不同的设备。基本上伴随着大量的风暴，指示。对于这些物理地址，我们实际上可以对UART进行编程，我们稍后会详细了解。</p>
<p>发言人   15:37<br>All the devices basically come into the processor. And really what happens is this platform level in interrupt controller, which is called the plaque for short, is the one that sort of general managers that interrupt coming in, you know, from external devices? And so we can zoom in a little bit more. Here’s a diagram of the P in our on-chain devices. So here we see there’s 53 interrupt lines coming in from different devices, probably have devices that own in line, they come in through the click and then the click and route interrupts.<br>所有的设备基本上都进入了处理器。而真正发生的是这个平台级别的中断控制器，简称为牌匾，是指总经理从外部设备中断进来的那种类型？所以我们可以放大一点。这是我们链上设备中的P的图表。所以在这里我们看到有53条中断线来自不同的设备，可能有设备拥有线路，它们通过点击进入，然后点击路由中断。</p>
<p>发言人   16:24<br>So for example, you know, depending. So here our particular course, the way you rerun it, we run it in a free course and immediately the plate can be programmed so that the applicable route interrupts to either one of these core or to the first core that can take an interrupt and bit of flexibility. And none of the court can take an interruptive at this point, for example, to have disabled interrupts because they’re processing another interrupt and applicable. Just hold that interrupt tool across the She available to take the interrupt so applicable internal state and to keep track of that. And if you saw the documentation a little bit, the way relo things are happening is the CIC indicates that there’s interrupt pending.<br>例如，你知道，这取决于。所以在这里，我们的特定课程，你重新运行它的方式，我们在一个免费的课程中运行它，并且可以立即对板进行编程，以便适用的路由中断到这些核心中的任何一个，或者中断到第一个核心，并具有一定的灵活性。并且没有一个法院可以在这一点上采取中断，例如，禁用中断，因为他们正在处理另一个中断并且适用。只需将中断工具放在可用的范围内，以获取中断所适用的内部状态并跟踪该状态。如果你稍微看了一下文档，重新操作的方式是CIC指示有中断挂起。</p>
<p>发言人   17:15<br>One of the core, you know, basically claims it. So that will tell the plate not to give it to any other core. And once the core is completely done with it, it will say like, okay I’m done with this particular interrupt and the click will inform the point that narrow it can forget about this interrupt. Any questions about this sort of the internal risk 5 interrupt structure? Yeah, so when each heart holds the plaque, does the clique have some enforcement mechanism to ensure fairness?<br>其中一个核心，你知道，基本上声称它。这样可以告诉盘子不要把它交给任何其他核心。一旦核心完全处理完它，它会说，好的，我处理完这个特定的中断，点击就会通知这个点，狭窄的它可以忘记这个中断。对这种内部风险5的中断结构有疑问吗？是的，那么当每个人都拿着牌匾时，小团体是否有一些执行机制来确保公平？</p>
<p>发言人   17:53<br>It is all up to the kernel, the program, the clicks in whatever way you want. The plate doesn’t really, it’s just in service of delivering the interrupted routing then. But it is the kernel who programs the plate and tells where interrupt should be delivered etc. In fact, you know, interruption priorities, the kernel can decide which interrupt is more important than another interrupt. There’s a huge amount of flexibility.<br>这完全取决于内核、程序以及任何你想要的点击方式。盘子并不是真的，它只是在提供中断的路线服务。但是内核编程板并告诉中断应该在哪里传递等。事实上，你知道，中断优先级，内核可以决定哪个中断比另一个中断更重要。有很大的灵活性。</p>
<p>发言人   18:26<br>Any other questions about the hardware?<br>还有关于硬件的问题吗？</p>
<p>发言人   18:34<br>Okay? Okay, so that’s sort of the hardware side of it’ll talk a little bit here at a high level about the software side. So typically the code that manages the device is called the driver.<br>好吗？好的，那么这就是它的硬件方面，我们将在高层次上谈谈软件方面。因此，通常管理设备的代码称为驱动程序。</p>
<p>发言人   19:01<br>You know, basically, it is just code typically, of course, in the kernels that we’ll be looking at in C code and in X 6, all the drivers are inside of the kernel. And the code you basically managing or the drivers are all inside of the kernel. And so you, the one that we’re going to be looking at a little bit today know is like New York DOC is the driver for viewership. And if you look at the structure, sort of internal structure of the that code, most drivers have a structure. I’m going to draw this not as an address space or not intending to be using an address space. But typically when people talk about drivers, there’s a bottom part in the top part. And basically, the bottom part is the interrupt handler.<br>你知道，基本上，通常只是代码，当然，在我们将在C代码和x6中查看的内核中，所有驱动程序都在内核内部。而您基本上管理的代码或驱动程序都在内核内部。所以你，我们今天要看的那个，就像纽约文档是收视率的驱动力一样。如果你看一下代码的内部结构，大多数驱动程序都有一个结构。我不打算将此绘制为地址空间，也不打算使用地址空间。但通常当人们谈论司机时，底部是顶部。基本上，底部是中断处理程序。</p>
<p>发言人   20:03<br>So when the interrupt handler, when an interrupt comes in the processor, the CPU has interrupt enabled, the interrupt will fire. The processor will, as we see in the second, will actually call the interrupt handler for that of a device, basically calls into the code here. And the interrupt handler just runs in, doesn’t run in any context of any specific process.<br>因此，当中断处理程序进入处理器时，CPU已启用中断，中断将触发。处理器将，正如我们在第二个看到的那样，实际上会调用设备的中断处理程序，基本上会调用这里的代码。而中断处理程序只是在运行，不在任何特定进程的任何上下文中运行。</p>
<p>发言人   20:28<br>Process, just process the interrupt, the top part, if you will, the driver, where is where usual processes or the rest of the kernel call into, for example, in the console case where row York, the Reuter right interface. That actually.<br>进程，只需处理中断，顶部部分，如果你愿意，驱动程序，通常进程或内核的其余部分调用的位置，例如，在控制台案例中，row York，Reuter right接口。事实上。</p>
<p>发言人   20:49<br>The higher level code actually calls into. And so in typically cases, actually, there’s some cue often in the driver and the top level code, you know, calls in sticks characters into the into this queue. And the interrupt handler either, you know, puts also depending on sending or receiving. But if it’s receiving, maybe the interrupt hand, one else will stick actually characters into cues. And you’ll see that these cues basically used to decouple the top and the bottom part from each other in allowing the device to run in parallel with the rest of the code on the CPU. And the interrupt handler, typically there’s some restrictions on the internet handler because those are running in any context, you know, any process context example you can call copying or copy out because the current page table might actually not be reflective of the page table, the of the process to which character should be copied. So it’s the upper part of the driver. Generally, you know, does the interaction with usual level processes and maybe calls copying and copy out.<br>更高级别的代码实际上调用了。因此，在通常情况下，实际上，在驱动程序和顶级代码中经常会有一些提示，你知道，将棍子字符调用到这个队列中。而中断处理程序也取决于发送或接收。但如果它正在接收，也许是中断手，其他人会将实际字符粘贴到提示中。你会看到这些提示基本上用于将顶部和底部相互分离，以允许设备与CPU上的其余代码并行运行。和中断处理程序，通常对internet处理程序有一些限制，因为它们在任何上下文中运行，你知道，任何进程上下文示例都可以调用复制或复制，因为当前页表实际上可能不反映页表，要将字符复制到的过程。所以它是司机的上部。一般来说，你知道的，与通常级别过程的交互是否进行，可能会调用复制和复制。</p>
<p>发言人   22:01<br>Any questions about this sort of this high level picture? We’ll look at this in quite a bit of more detail, but this is sort of the main organization of a typical driver.<br>对这种高层次的图片有什么问题吗？我们将对此进行更详细的研究，但这是典型驾驶员的主要组织形式。</p>
<p>发言人   22:15<br>As you realize, there are many drivers in an operating system, in fact, quite common that, you know, the sum of the driver code is quite bigger or larger than the core kernel itself, mostly because for every device drive, you need a driver. And most computers have a lot of devices.<br>正如你所意识到的，操作系统中有许多驱动程序，实际上，这是相当普遍的，你知道，驱动程序代码的总和比核心内核本身要大得多，主要是因为对于每个设备驱动器，你都需要一个驱动程序。大多数计算机都有很多设备。</p>
<p>发言人   22:42<br>Okay, so let’s talk a little bit about programming devices.<br>好的，让我们稍微谈谈编程设备。</p>
<p>发言人   22:55<br>So the typically programming is done using memory mapped IO.<br>所以通常的编程是使用内存映射IO完成的。</p>
<p>发言人   23:06<br>So as we’ve seen in the Risk five or in the sci fi board, the devices show up at particular addresses in the physical address space. And this is decided by the device or the board manufacturer and the operating system need to know what those, where those devices are located in the physical naming space, and then basically programs them using ordinary loading store instructions to those addresses. But basically what these load distor structures do is they, they read and write. They read and write control registers. Off the device.<br>因此，正如我们在风险五或科幻板上看到的那样，设备显示在物理地址空间中的特定地址。这是由设备或板块制造商决定的，操作系统需要知道这些设备在物理命名空间中的位置，然后基本上使用普通的加载存储指令对这些地址进行编程。但基本上这些负载结构的作用是读取和写入。他们读取和写入控制寄存器。关闭设备。</p>
<p>发言人   24:00<br>And so typically, when you maybe store something in one of the controller editors, that causes a packet to be sent. So instead of reading, writing, memory, these loading storm instruction typically have side effects. The cost of the device to do something. And, you know, you have to look basically in the documentation of the device to actually figure out what the device does. And sometimes this documentation is very clear.<br>通常情况下，当您在一个控制器编辑器中存储某些内容时，会导致发送数据包。因此，这些加载风暴指令通常有副作用，而不是阅读、写作、记忆。设备做某事的成本。而且，你知道，你必须基本上查看设备的文档才能真正弄清楚设备的功能。有时候这些文档非常清晰。</p>
<p>发言人   24:25<br>Sometimes this documentation is less clear. Let’s give you a little bit of a sample. Two things I wanted to show you here On the right side of the screen, you see the memory map, physical memory map, space for the Sci Fifi board. And you see what the addresses are, where particular things are mapped, where they show up in the physical dress space. Should you uses the word map where they should actually show up in the physical address phase? And so for example, we see the clean, you know, is there at 200. We, let’s see, pick out another one. The clique was somewhere there too.<br>有时这个文档不太清楚。让我们给你一点样品。我想在屏幕右侧向您展示两件事情，您可以看到内存地图，物理内存地图，科幻板的空间。你可以看到地址是什么，特定的东西被映射到哪里，它们在物理着装空间中出现的地方。你是否应该使用单词地图，它们实际上应该出现在物理地址阶段？例如，我们看到清洁的，你知道，在200。我们，让我们看看，挑出另一个。这个小团体也在那里的某个地方。</p>
<p>发言人   25:09<br>Okay, here’s the plik at OC 0 0 0, that’s the platform, platform, the internet controller, and you, we see actually you are 0 here at this particular address. It turns out that on the qmu that we’re using, users has the UART actually at a different location. That’s because we use vert Q you, it doesn’t actually literally emulate the Sci Fifi board, but something that’s very close to the Sci Fifi board.<br>好的，这是OC 0 0的plik，那是平台，平台，互联网控制器，而你，我们看到实际上你在这个特定的地址是0。事实证明，在我们使用的qmu上，用户的UART实际上位于不同的位置。那是因为我们使用的是vert Q你，它实际上并不是字面上模拟sciffi板，而是非常接近sciffi板的东西。</p>
<p>发言人   25:41<br>Okay, so that’s the memory map. The memory map, you know, physical addresses, you know, to devices. And then on the left side is just a piece of documentation for the UART. This is the 1655 1 6 5 5 0. That’s actually the uer chip sits on that the C mu amylate is and that we’re using to actually interact with the keyboard and console. And this is a reasonable, simple chip.<br>好的，这就是记忆地图。内存地图，你知道的，物理地址，你知道的，到设备。然后左侧只是UART的一份文档。这是1655 1 6 5 5 0。这实际上就是uer芯片，它是C mu amylate，我们正在使用它来与键盘和控制台进行交互。这是一个合理、简单的芯片。</p>
<p>发言人   26:22<br>There’s not much going on in this device. There’s even then there’s sort of complications here on this table here shows the registers that the chip has, the controller registers. So for example, controller register 0, 0, 0. And when you do the load instruction, it holds, it will hold the data. If you do restore instruction, that’s the register that will basically the data will be copied into to be transmitted outside on the wire, the UART is.<br>这个设备没有太多的工作。甚至这个表格上还有一些复杂之处，这里显示了芯片拥有的寄存器，即控制器寄存器。例如，控制器寄存器0，0，0。当你执行加载指令时，它会保持数据。如果你执行恢复指令，那就是寄存器，基本上数据将被复制到其中，以便在电线上向外部传输，UART是。</p>
<p>发言人   26:58<br>Basically, a device that allows you to send bits over a serial line. The scent line is one line and the received line is another line. And basically, you take a bite, and basically they’re multiplexed or serialized on this single line, sent over to the other side. And there’s a UAR chip sitting on the other side. And basically it symbols the bit back into a single bite.<br>基本上，一种允许您通过串行线路发送位的设备。气味线是一行，接收线是另一行。基本上，你咬一口，基本上它们被多路复用或序列化在这条线上，发送到另一边。另一侧有一个UAR芯片。基本上它象征着把比特放回一口。</p>
<p>发言人   27:25<br>And a couple other things that you can control. You know, on this device, you can actually control the bot rate of the device to some degree.<br>还有其他一些你可以控制的事情。你知道，在这个设备上，你实际上可以在某种程度上控制设备的机器人率。</p>
<p>发言人   27:38<br>And you know, probably most important for us is the register. The register one, which is here, which is the interrupt enable register, we can program it to actually cost the UART to generate interrupts. So, and if you scroll down this document, you’ll see I will scroll down a bit. The document actually in more detail, basically describe what every bit in every register means in, for example, you in the interoperable registered Ier register, which is the acronym for it. Then basically, this is the shift line status is interrupt and transmit holding register interrupt. So that’s what the bits mean. And it goes on and on. And there’s a lot more documentation that tells you what more detail, what the registers are, how you can use it in polling mode or interrupt mode.<br>你知道，对我们来说最重要的可能是注册。寄存器一，也就是这里的中断使能寄存器，我们可以对其进行编程，使其实际消耗UART来生成中断。所以，如果你向下滚动这个文档，你会看到我会向下滚动一点。该文档实际上更详细地描述了每个寄存器中的每个位的含义，例如，您在互操作注册的寄存器中，这是它的首字母缩写。那么基本上，这是移位线状态中断和发送保持寄存器中断。这就是比特的含义。而且它还在继续。还有更多的文档告诉你更多的细节，寄存器是什么，如何在轮询模式或中断模式下使用它。</p>
<p>发言人   28:37<br>We’ll talk about it a little bit more, how how you have to program the internet, enable registers, etc, etc. So it turns out to be a short version of the real documents, you know, the real documents for the chip manufacturers, much more has much more stuff in it, much more detail, but is sort of sufficient for us to actually be able to talk about how to program the UART.<br>我们将更详细地讨论它，如何对互联网进行编程，启用寄存器等。所以它原来是真实文档的简短版本，你知道，芯片制造商的真实文档，里面有更多的内容，更多的细节，但对于我们实际上能够谈论如何编程UART已经足够了。</p>
<p>发言人   28:59<br>And you can see this is like one of the most simple devices. And even that document, you know, it’s quite a bit to it.<br>你可以看到这是最简单的设备之一。甚至那份文件，你知道的，也有相当多的内容。</p>
<p>发言人   29:10<br>Sorry, I was wondering if you write, So if you write something to the transmit holding register, and then you write again like right after that it, it makes her that like the previous number didn’t just like get overridden, right? Yes, Jesse, no, it’s part of you actually.<br>抱歉，我想知道你是否在写，所以如果你在传输保持寄存器中写了一些东西，然后你在那之后再次写，它会让她像之前的数字一样被覆盖，对吧？是的，杰西，不，这实际上是你的一部分。</p>
<p>发言人   29:36<br>And this is one of the things that we’re going to pay a bit of attention to. The you tell, basically, you load instruction, you load some value, you store instruction, you load some value in that register, and then the. Viewer chip goes off, and it’s going to send off that byte onto the line on the serial line, correct? And when it’s done, it will generate an interrupt saying to the kernel, okay I’m done with that byte. Now you can give me the next byte. And so the kernel and the device has to sort of follow a protocol to make sure that actually everything works out.<br>这是我们要注意的事情之一。你说，基本上，你加载指令，加载一些值，存储指令，加载一些值到那个寄存器中，然后执行。查看器芯片出现问题，它将把那个字节发送到串行线路上，对吗？当它完成时，它将生成一个中断告诉内核，好的，我已经完成了那个字节。现在你可以给我下一个字节。因此内核和设备必须遵循协议，以确保实际上一切正常。</p>
<p>发言人   30:10<br>This particular UAR you that we’re using has the, I think 1655, 550 A actually internally has a 5 0 and think it can buffer a bunch of characters like I think up to 16. But you still have to sort of play this game of like, you can’t stick more than 16 characters into it until the device actually has told you, well I’ve sinned one character. Does that make sense, okay? Yeah, thank you.<br>我们使用的这个特殊的UAR，我认为1655，550实际上在内部有一个50，并且认为它可以缓冲一堆字符，就像我认为的16个字符。但是你仍然需要玩这个游戏，在设备实际告诉你之前，你不能在其中插入超过16个字符，好吧，我已经犯了一个字符。那感知，好吗？好的，谢谢。</p>
<p>发言人   30:41<br>So let talk a little bit more, you know, before we look at a little more detail is, you know, the case study, you know, that we I’m going to go through for sort of explaining how devices and interrupts work is here’s dollar LS, what happens when actually how you print? And so basically what happens is that the device as we actually sort of discussed in a second ago as basically puts the character the dollar in this case into the UAR in fact in the register that we just looked at and then the UAR generate an interrupt that means that’s the way we can set things up generate an interrupt. When the character has to be sent?<br>所以让我们再多说一点，你知道，在我们看更多细节之前，你知道，案例研究，你知道，我们将会通过它来解释设备和中断是如何工作的，这是关键时刻。当你实际打印时会发生什么？所以基本上发生的情况是，我们实际上在一秒钟前讨论过的设备基本上把角色美元放入了实际上，UAR在我们刚刚查看的寄存器中，然后UAR生成一个中断，这意味着这是我们可以设置事情并生成中断的方式。什么时候必须发送角色？</p>
<p>发言人   31:42<br>And then on the other side. And so basically the way things are set up in q.u. is that on descent line, on the other side of descent line basically sits in another York ship. And that actually connects to the console, to the virtual virtual console. The other side, you know, what happens on LS is because you need your input. And so the keyboard actually is connected to the receive line.<br>然后在另一边。基本上就是q.u.事物的建立方式。 在下降线上，下降线的另一侧基本上是另一艘纽约船。并且它实际上连接到控制台，连接到虚拟控制台。另一方面，你知道，在LS上发生的事情是因为你需要你的输入。因此键盘实际上是连接到接收线路的。</p>
<p>发言人   32:16<br>There’s huge light. And so basically the keyboard, you know, you hit a key on the keyboard, keyboard, the virtual keyboard, in this case, your chip on that site will serialize the character L, send it to the viewer on the other side. The other side puts the bit together again into 1 B and then generate an interrupt. Generate an interrupt to tell the processor, hey, there’s a character available from the keyboard. And then the interrupt handles. The interrupt handle will reach the byte from the UART, as we will see in a second. And so those are the sort of two things that we want to sort of understand in more detail, actually how they work. Okay, any questions about this?<br>那里有巨大的光。基本上，键盘，你知道，你敲击键盘上的一个键，键盘，虚拟键盘，在这种情况下，你在那个网站上的芯片将序列化字符L，并将其发送给另一侧的查看器。另一端将该位再次组合到1 b中，然后生成一个中断。生成一个中断，告诉处理器，嘿，键盘上有一个可用的字符。然后是中断句柄。中断句柄将到达UART中的字节，正如我们将在一秒钟内看到的那样。因此，这是我们想要更详细地了解的两件事情，实际上它们是如何工作的。好的，对此有什么问题吗？</p>
<p>发言人   33:13<br>Okay, so? The Risk 5 has a bunch of support. Support for interrupts.<br>好吧，所以呢？风险5得到了很多支持。支持中断。</p>
<p>发言人   33:34<br>And there’s a number registers we’ll see in more detail as they could use, but it’s useful to know which ones there are.<br>还有一个数字寄存器，我们将更详细地看到它们可以使用，但知道有哪些是有用的。</p>
<p>发言人   33:42<br>There is the Sie supervisor interrupt enable register, and that has a bit, 1 b for external interrupt from devices like the UART from software interrupt, which I’m really going to talk about it. But it is possible from 1 CPU, from 1 risk 5 core to send an interrupt to another risk 5 core and timer interrupts. And I’m not really going to talk about either, you know, the supervisor of the software interrupts nor the timer interrupts. I’m going to focus on external interrupts.<br>有一个Sie监控器中断启用寄存器，其中有一个位，1 b用于来自设备的外部中断，例如来自软件中断的UART，我真的要谈论它。但是可以从1个CPU，从1个风险5个核心发送中断到另一个风险5个核心和计时器中断。我真的不打算谈论软件中断的主管或计时器中断。我将专注于外部中断。</p>
<p>发言人   34:24<br>Then there’s another register that we’ve seen before ISS called the Supervisor Staters Register, and that has a bit to disable and enable interrupts. This particular core. So every core has, you know, these registers and there’s a, in addition to these 3 b where the individual control, when you want to have external interrupts or sharpening interrupts or timer interrupts, there’s 1 b of digital controls that you’re going to receive interrupted all. And so you can atomically switch from not getting interrupt through having interruption, or the other way around and just changing that 1 b in the A state of register. And then there’s a separate register called the supervisor you in pending register.<br>然后还有一个我们之前看到过的寄存器，叫做Supervisor Staters寄存器，它有点禁用和启用中断。这个特别的核心。所以每个核心都有，你知道，这些寄存器，除了这些3 b的单独控制，当你想要外部中断或锐化中断或计时器中断时，还有1 b的数字控制，你将接收所有中断。所以你可以原子地从没有中断切换到中断，或者反过来，只是改变寄存器状态中的1 b。然后有一个单独的寄存器称为主管，您在待定的寄存器中。</p>
<p>发言人   35:21<br>And basically, the processor can use that. Once you interrupt, it can happen. The process can look at the Sip to see what what interrupt actually has come in. And in addition, there will be even interrupt happens in the S cause or Ad that we have seen a couple times before. Now there will be an indication of what interrupt actually came in. We will look in the second. And of course, there’s the St Vic register that basically holds the program or holds the address to which the processor switch once either a trapped or trap or system call or a page fault happens or an interrupt happens because basically it uses for all three cases the same mechanism.<br>基本上，处理器可以使用它。一旦你打断，它就会发生。该过程可以查看Sip以查看实际发生的中断情况。此外，在我们之前见过几次的S原因或广告中甚至会发生中断。现在将会有一个指示，说明实际发生了什么中断。我们会看第二个。当然，还有一个Vic寄存器，它基本上保存程序或处理器在被捕获、陷阱、系统调用、页面错误或中断发生时切换到的地址，因为它基本上在所有三种情况下都使用相同的机制。</p>
<p>发言人   36:06<br>I’m not going to talk too much about S cause and S because we’ve seen it in detail before and it basically operates exactly in the same way as. System calls and page faults or other exceptions.<br>我不会过多地谈论S原因和S，因为我们之前已经详细看过了，它的运作方式基本上完全相同。系统调用和页面错误或其他异常。</p>
<p>发言人   36:30<br>Okay, so let’s see, get a little bit of a sense how this stuff is sort of initialized. So we’re not talking even about how the drivers actually work, but just to see how XV 6 programs this these registers so that we’re going to be in a position you to take interrupts, see if there any questions in the chat. We can make sure that.<br>好的，让我们看看，感知一下这些东西是如何初始化的。所以我们甚至不是在谈论驱动程序的实际工作方式，而只是想看看XV 6如何编程这些寄存器，以便我们能够让您中断，查看聊天中是否有任何问题。我们可以确保这一点。</p>
<p>发言人   37:05<br>A little bit behind on the chat. So let’s see a little bit on the what, the how actually six programs. These registers pull up some code. Let me get rid of.<br>聊天有点落后。让我们来看看六个程序实际上是什么。这些寄存器提取一些代码。让我摆脱。</p>
<p>发言人   37:24<br>Is with New Yorker? I don’t really need that either, so I’m not going to run use DDB to walk through of. And so I’m just going to look at the particular functions that are relevant.<br>和纽约客在一起？我也不真正需要那个，所以我不会使用DDB来走走。所以我只打算看看相关的特定功能。</p>
<p>发言人   37:35<br>So probably the first thing is in start DOC. So when the machine boots or the processor boots the. Start function is called, it runs in M mode and you disables paging. So and right away, because sort of later on, the kernel can set up the page tables and we’ll see you that basically delegates all interrupts and exceptions to supervisor mode.<br>所以可能第一件事是在开始文档中。因此，当计算机引导或处理器引导时。启动函数被调用，它在M模式下运行，并且您禁用分页。这样马上，因为稍后内核可以设置页表，我们会看到基本上将所有中断和异常委托给主管模式。</p>
<p>发言人   38:04<br>And then it programs the supervisor enable interrupt, enable register to, you know, take software interrupts, timer interrupts, and external interrupts. And then if a grid measure, because timer interrupts actually happen to coming to n, are handled in N mode, the Mde code actually programs the.<br>然后它编程监控器启用中断，启用寄存器，以接受软件中断，计时器中断和外部中断。然后，如果网格测量，因为计时器中断实际上发生在n模式下处理，Mde代码实际上会编程。</p>
<p>发言人   38:34<br>Register and so that timers timer interrupts are generated. And I want to talk about that actually. So I’m going to go to the main DOC. And so see how external devices are handled. And so our first external devices, the console that is like where we print toe and you know, we can can see with console in it does. So here’s console in it. It initializes lock. You know, we actually care not much about that at all, at least not for this lecture. And it actually basically calls the UART in it, and you are in it. It is right here. It actually sets up the newer chip or configures the newer chip so that it is ready for use.<br>寄存器，以便产生计时器中断。我其实想谈谈这个问题。所以我要去主要的文档。所以看看外部设备是如何处理的。因此，我们的第一个外部设备，控制台就像我们打印脚趾的地方，你知道，我们可以在其中看到控制台。所以这里有控制台。它初始化了锁。你知道，实际上我们对此并不怎么关心，至少对于这次讲座来说不是这样。它实际上基本上称之为UART，而你就在其中。就在这里。它实际上设置了较新的芯片或配置了较新的芯片，以便它可以使用。</p>
<p>发言人   39:26<br>First actually disables interrupts. You know, there’s just a sequence you have to go through when you program it. Then you can set the bond rate, then you set it in six or, you know, 7 b, you know, 7 or 8 b bytes or repaired you not. And. You usually have the internal Fifos that the your house, you clear out anything that it actually might be in there. And then we receive we enable interrupts for transmission and interruption.<br>首先实际上禁用中断。你知道，当你编程时，你必须经历一个序列。那么你可以设置债券利率，然后你可以将其设置为六个或者，你知道的，7 b，你知道的，7或8 b字节或者不修复。而且。你通常会有内部的Fifos，在你的房子里，你清除了任何可能存在的东西。然后我们接收到允许传输和中断的中断。</p>
<p>发言人   40:03<br>Amir, I think you raised your hand. Yeah I’m wondering what the bar rate is exactly or the speed of which, you know, the mining road. I see, thanks. Okay, so that’s u word in it. Now at this point, the u word in principle can generate interrupt, but of course, we haven’t actually program the interrupt enabling stuff on the rich 5 process itself. You know, we haven’t programmed the P yet, so nothing really happens at this point yet. And so the next thing, if we’re going to look back to main dot c, we’ll see a little bit scroll down. We’ll see actually that the click is initialized. And so let’s look at that. And basically, click init code.<br>阿米尔，我想你已经举手了。是的，我想知道酒吧的确切价格或采矿道路的速度。我知道了，谢谢。好的，所以这是你的词。现在在这一点上，原则上u字可以生成中断，但当然，我们还没有实际编程在富5进程本身上启用中断的东西。你知道，我们还没有编程P，所以目前还没有真正发生任何事情。所以接下来，如果我们要回顾一下main.c，我们会看到一点点向下滚动。我们实际上会看到click已经初始化。所以让我们来看看这个。基本上，点击init代码。</p>
<p>发言人   40:56<br>If you looked at this table that I showed you a little while ago with the physical memory or the memory layout, the pic is in some particular location, correct? And the location is in kernel menu layout, we see the duplication 0 0 0 0 0 correct, literally copied from that document. And in a way, we write stuff to the plate is basically take the number or the dress for the plaque.<br>如果你看一下我刚才展示给你的这个表格，里面有物理内存或内存布局，图片在某个特定的位置，对吗？并且位置在内核菜单布局中，我们看到重复的0正确，从该文档字面上复制而来。在某种程度上，我们把东西写到盘子里基本上就是把号码或衣服作为牌匾。</p>
<p>发言人   41:25<br>Castes to a 32 pointer integer because the clicker registers are 32 b. And then, you know, basically write a one to it. So this cost is basically one to be written to the register. You are 0 Irq. And basically what this does is it enables interrupt requests from the UART. So remember to click, you know, basically routes the interrupts. And so the An interrupt might come in from the left side from that picture into the P, and the click says like this program is the click to actually accept those interrupts. Similarly, it actually programs the plate to X, excepting the Ris from the IO disk, which I’m not going to talk about at all.<br>转换为32指针整数，因为点击器寄存器是32 b。然后，你知道，基本上写一个。所以这个成本基本上是要写入寄存器的成本。你是0 Irq。基本上，它的作用是启用来自UART的中断请求。所以记住点击，你知道，基本上路由中断。因此，中断可能从左侧进入该图片的P，并且点击表明该程序实际上是接受这些中断的点击。同样地，它实际上将板编程为X，除了IO磁盘中的rise，我根本不打算谈论。</p>
<p>发言人   42:08<br>Okay, and then we go back, you know, to main dot c and. Right after the click in at the machine, you just click in at heart. And then basically for every core specifically. Every core individually. So the one core, the first core, actually initializes this aspect.<br>好的，然后我们回到你知道的，main dot c和。在机器上点击后，你只需要点击心脏即可。然后基本上针对每个核心。每个核心都单独。因此，第一个核心实际上初始化了这一方面。</p>
<p>发言人   42:30<br>So basically, we’re taking interrupts with those devices. And then every core individually has to say I’m interested in those devices too. And so for example, here, every core actually calls dy function. So every course says I’m interested in interrupt from the UART, and I’m interested in interrupt from the verril. And you can see here, basically the 0 0 I or Q basically is a unique number for the UART, the Irq for the UART, and I think it believe on on Cm is number 10. And we’re basically ignoring priorities, so we just set it to 0, okay? And so just every CPU or every core individually, you know, has to indicate to the click that it actually is interested in receiving interrupts.<br>基本上，我们正在使用这些设备进行中断。然后每个核心都必须说我对这些设备也感兴趣。例如，在这里，每个核心实际上都调用dy函数。所以每门课程都说我对UART的中断感兴趣，我对verril的中断感兴趣。你可以在这里看到，基本上0 0 I或Q基本上是UART的唯一编号，Irq是UART的，我认为on Cm是第10号。我们基本上忽略了优先级，所以我们把它设置为0，好吗？因此，每个CPU或每个核心都必须单独向点击表明它实际上对接收中断感兴趣。</p>
<p>发言人   43:22<br>Now, at this point, the flick, basically, we basically have to program the device to generate interrupts. We have program to plik to pass interrupts on to the individual Cpu’s. But the Cpu’s itself have actually are not accepting interrupt or of yet because we haven’t set the bid in the status register here yet.<br>现在，在这一点上，基本上，我们基本上必须对设备进行编程以生成中断。我们有程序需要plik来将中断传递给各个Cpu。但是Cpu本身实际上还没有接受中断或者，因为我们还没有在这里的状态寄存器中设置出价。</p>
<p>发言人   43:41<br>Let’s go back to main DOC. And whatever Maine does, he does a bunch of more immun. But the end, it actually calls the scheduler. And so let’s go look at proc DOC and the. Scheduler?<br>让我们回到主要文档。无论缅因州做什么，他都做得更多。但是最后，它实际上调用了调度器。所以让我们去看看proc DOC和。调度器？</p>
<p>发言人   44:04<br>And what we see here is like when the So now, basically the whole machine is sort of the processors has been set up, the scheduling schedules, the look for process to run. But before doing any of that, it actually enables interrupts. And so we look at risk 5, and we’ll see there’s a basically a decision. C function. And that basically enables interrupts. And if you can, not surprising, you know, basically the only thing it does, it sets the interrupt enable bit in the F status register.<br>我们在这里看到的是现在，基本上整个机器都是处理器已经设置好的，调度时间表，寻找要运行的进程。但在做任何这些之前，它实际上启用了中断。所以我们看一下风险5，我们会看到基本上有一个决定。C功能。这基本上可以实现中断。如果可以的话，这并不奇怪，你知道，它基本上唯一做的事情就是在F状态寄存器中设置中断使能位。</p>
<p>发言人   44:37<br>So this particular point in time, right? This instance, if there were an interrupt ending at the plaque, then know this particular core would be interrupted. And we’ll see that in a second later. But this, at this point, interrupts are enabled. And so those are the basic setup.<br>所以这是一个特定的时间点，对吧？在这种情况下，如果在斑块处有一个中断结束，那么就知道这个特定的核心会被中断。稍后我们会看到这一点。但是此时，中断是启用的。所以这些是基本设置。</p>
<p>发言人   44:56<br>Any questions about this? Oh sorry Wella, he interrupted when at that point. So every core runs the scalar or loop, correct? And whatever core calls interact on or all cores will call the interruption. But let’s say there’s only one chord gets there first, like chord 1. And if core 1 sets its interrupt enable bit, at that point, it could receive an interrupt. And we’ll see in second what happens exactly when an interrupt makes sense.<br>对此有什么问题吗？哦，对不起，威拉，在那个时候他打断了。所以每个核心都运行标量或循环，对吗？并且任何核心调用在交互或所有核心将调用中断。但假设只有一个和弦先到那里，就像和弦1一样。如果核心1设置了中断使能位，在这一点上，它可以接收中断。我们将在第二部分看到当中断感知时会发生什么。</p>
<p>发言人   45:33<br>Thank you, okay, Okay, so what I want to do is look at this, how to print the dollar, the prompt at the shell prompt. And so for that, we want to go back a little bit and I first want to look at in it again. So this was the first process that actually is being you in a code Xs in it, basically the first process running.<br>谢谢，好的，好的，我想要做的是看看这个，如何在shell提示符下打印美元提示符。因此，我们想回到过去，我首先想再看看它。所以这是第一个实际上在代码Xs中的进程，基本上是第一个运行的进程。</p>
<p>发言人   46:02<br>And one of the things that in it does, it makes a device that represents the console. So here that the is created using the McNaught and returns a file descriptor, you file descriptor 0 because it’s the first file descriptor open, and then adopts it, you know, for standard out and then for standard error adopts it again. And so this basically sets up file descriptors 0, 1, and 2 to corresponding to the console. And now, so you know, then it forks off the shell. And so let’s look at the shell for a second. So the shell opens or starts running with you found the script, theres 1, 2 and 3, sort of 0, 1 and 2 open. You pointed to the console and then the shell prints the character dollar in the space to file the scriptor 2. And so, so even though the whole in the view heartt, you know, sort of all, you know, below all this to the application programmer and went to show the person who wrote, wrote the show, it just looked like a record of file.<br>其中的一件事情是，它制造了一个代表控制台的设备。因此，在这里使用McNaught创建并返回文件描述符，您将文件描述符0作为第一个文件描述符打开，然后采用它，您知道，对于标准输出，然后对于标准错误再次采用它。因此，这基本上设置了文件描述符0、1和2以对应于控制台。现在，你知道了，它就会把壳分叉掉。那么，让我们先看看这个外壳。所以shell打开或开始运行，你发现脚本打开了1、2和3，有点像打开了0、1和2。你指向控制台，然后shell在空间中打印字符美元以提交scriptor 2。因此，即使在视图的中心，你知道，有点，你知道，在所有这些下面，向应用程序员展示编写节目的人，它看起来只是一个文件记录。</p>
<p>发言人   47:15<br>And so in fact, the shell itself, since it writes to file script 2, there’s no idea what actually sits on the other side. And we have seen in the U lab, and you can do all kinds of cool stuff with it. But here’s an example where basically the devising Unix is represented as a file that’s not different than anything else.<br>因此，实际上，由于shell本身写入文件脚本2，因此不知道另一侧实际坐在什么位置。我们在U实验室看到了，你可以用它做各种很酷的事情。但这里有一个例子，基本上设计的Unix被表示为一个与其他文件没有什么不同的文件。</p>
<p>发言人   47:33<br>Okay, so let’s see, you know, how this actually printing that works. So there’s a printf is in the x 6 user application with a tiny little C library, which includes printf. And you know, printf, as you’ve seen this sort of in the track lab, you know, sort of an instinct function in itself, but in int, and basically calls the right system call and in our case grego write system call would be you file descriptor 2 and C would be hold the character dollar. And so we passed the address of the memory location that holds the dollar to the file descriptor to write, and we ask to write one character. So basically every character written by the shell and it results in the system call. And so now we can go and see what actually happens.<br>好的，让我们看看，你知道，这实际上是如何打印出来的。所以在x6用户应用程序中有一个printf，带有一个很小的C库，其中包括printf。而且你知道，printf，正如你在轨道实验室中所看到的，你知道，它本身就是一种本能功能，但是在int中，并且基本上调用正确的系统调用，在我们的情况下，grego write系统调用将是您的文件描述符2，而C将保存字符美元。因此，我们将保存美元的内存位置的地址传递给文件描述符进行写入，并要求写入一个字符。基本上，shell写入的每个字符都会导致系统调用。所以现在我们可以去看看实际发生了什么。</p>
<p>发言人   48:28<br>So you have seen the system called before, but so sees file. Right, so here’s the right system. Call grabs his arguments, the file descriptor, the number of bytes to be written, and the address of the address that contains, you know, the character dollar calls them file, right?<br>所以你已经看到了之前调用的系统，但也看到了文件。好的，这是正确的系统。Call抓取他的参数，文件描述符，要写入的字节数，以及包含字符的地址，你知道，美元称之为文件，对吗？</p>
<p>发言人   48:58<br>So let’s quickly look at file, right? Okay, we’re getting close to actually where the thing that we want to talk about. And you know, here, if I write it looks what the type of the file description is. It’s a pipe or call the pipe functions. And if it’s a device which you make Nov do, then it will call the right function for that particular device. And so we know that, you know, that actually is going to call the right function into cazalla. And so let’s see what happens there.<br>让我们快速地看一下文件，对吧？好的，我们已经接近我们想要谈论的事情了。你知道，在这里，如果我写它，它看起来是文件描述的类型。它是一个管道或调用管道函数。如果它是您制作的设备，那么它将为该特定设备调用正确的功能。所以我们知道，你知道，这实际上是要将正确的函数调用到cazalla中。那么让我们看看那里发生了什么。</p>
<p>发言人   49:31<br>So here’s the solar right graphs lock, we’re really care about that right now. It copies in the one character user, either copy in and then because you are to C, so that basically calls into the uarc. And so you can think about together the console as being the driver. We’re looking sort of at the top end of the driver and now make a call into view arc to actually print the character. And so you or you are, let’s see, so this is going to be a little bit interesting.<br>所以这是太阳能正确的图形锁，我们现在非常关心它。它会复制一个字符用户，要么复制进去，要么因为你是面向消费者，所以基本上会调用uarc。因此，您可以将控制台视为驱动程序。我们正在寻找驱动程序的顶端，现在向view arc打电话以实际打印角色。所以你或你，让我们看看，这将会有点有趣。</p>
<p>发言人   50:08<br>Basically, internally, the UART keeps a buffer. So let’s go back, back up a little bit on the top. In fact, there’s a buffer for transmission, and the buffer size is 3 to two characters. And there’s a pointer, a right pointer in the reef pointer that are being used to put these characters into the circular buffer. I’ll talk a little bit about that in more detail. But so there’s a pointer for the producer, and there’s a pointer for the consumer. And in this case, you know, the shell, if you will, is the producer, and it actually checks the first thing it does, it actually checks whether the circular buffer is full so, and the way it checks with the circular reference for fool, so it starts out in the original state, is both the right pointer and the read pointer is 0 corrected zero index into that buffer.<br>基本上，在内部，UART保持一个缓冲区。所以让我们回去，在顶部往上一点。实际上，有一个用于传输的缓冲区，缓冲区大小为3到两个字符。并且有一个指针，珊瑚礁指针中的右指针用于将这些字符放入循环缓冲区。我将更详细地谈谈这个问题。但是，有一个针对生产者的指针，还有一个针对消费者的指针。在这种情况下，你知道，如果你愿意的话，shell就是生产者，它实际上会检查它做的第一件事，它实际上会检查循环缓冲区是否已满，以及它使用循环引用进行检查的方式。因此，它从原始状态开始，是正确的指针和读取指针都是0，更正后的零索引到该缓冲区。</p>
<p>发言人   50:59<br>If they’re equal, you know that the. Buffer is empty, but if you add one to the right pointer and it’s the same as the receive pointer, for example, you go, you fill in 0, 1, 2, 3, 4, 5, 6, 7, 8, 1931, and then you’re about to wrap around. If you add one, if then, and it’s still equal to the receive index or to read that, you know that the buffer is full. And so there’s no point, you know, you can’t write anything at that point because apparently New York is still busy.<br>如果他们相等，你就知道。缓冲区为空，但是如果您在右侧指针上添加一个，并且它与接收指针相同，例如，您进入，您填写0，1，2，3，4，5，6，7，8，1931，然后你就要结束了。如果您添加了一个，那么它仍然等于接收索引或读取它，您就知道缓冲区已满。所以没有意义，你知道，你不能在那个时候写任何东西，因为显然纽约仍然很忙。</p>
<p>发言人   51:30<br>You working its way through trying to send off the preceding 31 characters or 30 characters. So in this case, the doctor fool the shell. Basically we put put to sleep and put on the site and the Kern would run some other program until the shells be woken up and it’s actually ready to send or you are just ready to send more data. Now, of course, in this case, this is not the case because it’s like, is the first few characters that are being print, so there’s space in the buffer. And so basically the driver puts the character into the buffer, updates the right pointer to go to the next slot, and then call Xerox Start. And basically New York Stars, there’s nothing else, and sort of kicking the device and saying like, hey, go do some work for me and basically.<br>您通过尝试发送前面的31个字符或30个字符来工作。所以在这种情况下，医生愚弄了贝壳。基本上，我们进入睡眠状态，放到网站上，Kern会运行其他程序，直到shell被唤醒，它实际上已经准备好发送，或者你只是准备好发送更多数据。现在，当然，在这种情况下，情况并非如此，因为就像打印的前几个字符一样，因此缓冲区中有空间。基本上，驱动程序将字符放入缓冲区，最新进展正确的指针转到下一个插槽，然后调用Xerox Start。基本上是纽约明星，没有别的了，有点踢设备，说，嘿，去为我做一些工作，基本上。</p>
<p>发言人   52:29<br>At first checks if the device is still busy sending the current character. Recently, if the device is busy, you will just go back and it will go to sleep. Probably we won’t go to sleep and otherwise we’ll read the character out to the buffer in, put it in the transmission register that we saw earlier.<br>首先检查设备是否仍在忙于发送当前字符。最近，如果设备忙，你只需要返回，它就会进入睡眠状态。可能我们不会进入睡眠状态，否则我们会将字符读出到缓冲区中，将其放入我们之前看到的传输寄存器中。</p>
<p>发言人   52:54<br>And so the transmission registration like this before, let’s look at that for a second. You know, we basically write to register, you know, cast, you know, the particular register to the whatever register type and then writes the value into it. And you know, thr the transmit holding register is relatively 0 as we saw before from the documentation. Okay, so, so basically, you know the. Where I was in start, you should start basically kicks the device and saying like, hey, I got a register. I got a byte for you available to send off. And that’s basically all the.<br>所以之前像这样的传输注册，让我们看一下。你知道，我们基本上是写入寄存器，你知道，将特定的寄存器转换为任何寄存器类型，然后将值写入其中。你知道，正如我们之前从文档中看到的，传输保持寄存器相对为0。好的，基本上，你知道的。在我开始的地方，你应该基本上开始踢设备并说，嘿，我有一个寄存器。我有个字节可供发送。这基本上就是全部了。</p>
<p>发言人   53:43<br>Basically, if you will, the shell, the system called the shell called will do. And ones that actually kick the device and it will return to a user space and the shell can go on and do whatever it wants to do. And presumably, the next thing the shell will do is called the read system, called to actually read input for Nick. But so the shell will return to user space using the standard mechanism that we have seen before, like user It, and just goes off and does its thing.<br>基本上，如果你愿意的话，这个叫做shell的系统将会做。而那些真正踢了设备，它将返回用户空间，shell可以继续做任何它想做的事情。大概，shell接下来要做的事情是称为读取系统，被称为实际读取Nick的输入。但是，shell将使用我们之前见过的标准机制返回用户空间，就像用户一样，然后离开并执行它的事情。</p>
<p>发言人   54:08<br>And in the meantime, Greg, the device has not got any kick to actually send some bytes off.<br>同时，格雷格，该设备没有任何实际发送字节的功能。</p>
<p>发言人   54:16<br>And so? So at some point, you know, we’re going to get an interrupt, hopefully, you know, because we programmed the hardware to actually generate interrupts. Let’s go a little bit back and talk a little bit about that and what happens when an interrupt happens. Okay, so, so what does the hardware do? In this particular case, the risk 5 do when an interrupt actually happens? So we set this interrupt enable bid in the S status register so the processor can be interrupted.<br>所以呢？所以在某个时刻，你知道，我们希望会得到一个中断，因为我们将硬件编程为实际生成中断。让我们回头谈谈这个问题，以及当中断发生时会发生什么。好的，那么硬件是做什么的？在这种特定情况下，当中断实际发生时，存在风险5？因此，我们在S状态寄存器中设置了中断使能出价，以便处理器可以被中断。</p>
<p>发言人   54:55<br>Or let’s say the keyboard, you know, raises the interrupt line, you know, go through the click, the click routes the interrupt to particular core and that core half the Sie bit set. So interrupt enable bit set, the supervisor in, enable bit set. So if that bit is set, the following things happen and this will look very similar to, you know, what we’ve seen before. But the first thing the hardware do is clear the siie bit and this stops, you know, any further interrupts coming in so that we can just deal with these interrupt first. And then if we want more interrupts, we have to re-enable that bit. But, you know, this just stops further interrupts and basically interrupts, interrupting the interrupt. Then it sets the sepc to the accept program counter to the current PC.<br>或者让我们说键盘，你知道，打开中断线，你知道，经过点击，点击将中断路由到特定的核心，而该核心的一半位集。所以中断使能位设置，主管进入使能位设置。因此，如果设置了该位，将会发生以下事情，这将看起来非常类似于我们之前看到的。但是硬件做的第一件事是清除sie位，这将停止任何进一步的中断，以便我们可以先处理这些中断。然后，如果我们想要更多的中断，我们必须重新启用该位。但是，你知道，这只是停止进一步的中断，基本上是中断，中断中断。然后它将sepc设置为当前PC的接受程序计数器。</p>
<p>发言人   55:53<br>So for example, we were interrupted, let’s say the shell return to user space, like happily running a user space. And interrupt comes in because of that one character was sent. Then the program calendar shape is whatever program calendar was in user space. It saves the save the current mode. So in this case, it would be, in our example would be save that the processor in supervisor in user mode. Then it says the move, you know, to supervisor. And basically sets the program counter to SD VC, whatever value is in SD VC, then that’s going to be either user Trapp or user Vec or kernel Vec, depending whether the interrupt happened, you know, whether we’re in your kernel space or in user mode.<br>例如，我们被中断了，假设shell返回用户空间，就像愉快地运行用户空间一样。并且中断进来是因为发送了一个字符。那么程序日历形状就是用户空间中的任何程序日历。它保存保存当前模式。因此，在这种情况下，在我们的示例中，将处理器保存在用户模式下的主管中。然后它说这个动作，你知道的，是给主管的。并基本上将程序计数器设置为SD卡VC，无论SD卡VC中的值是什么，那么它将是用户traapp或用户Vec或内核Vec，具体取决于中断是发生的，你知道，无论我们是在内核空间还是在用户模式下。</p>
<p>发言人   56:44<br>But in our example, where maybe shell return to user space, you know, SDF will contain the user Fac address and basically the hard wheel whom the kernel at the instruction that is located svec. And then we remember from previous lecture, basically svec goes off, calls user trap, okay? So in the end, we’ll basically end up in user trap.<br>但在我们的示例中，shell可能会返回用户空间，您知道，SDF将包含用户Fac地址和基本上位于svec的内核的硬轮。然后我们记得之前的讲座，基本上svec关闭了，称之为用户陷阱，好吗？所以最终，我们基本上会陷入用户陷阱。</p>
<p>发言人   57:15<br>And that’s where we sort of pick up the story because like, I don’t really want to talk too much about the saving and restoring anymore because one, we explained it in detail in the previous lecture. Two, you already played with it also in this last trap lab. And so you know exactly what’s going on. Any questions?<br>这就是我们开始故事的地方，因为我真的不想再过多地谈论保存和恢复，因为我们在上一节课中详细解释了它。第二，你已经在这个最后的陷阱实验室里玩过了。所以你确切地知道发生了什么。有问题吗？</p>
<p>发言人   57:43<br>Okay, so? So here, back in user trap, you know, in function, you looked in detail at in the traps lab.<br>好吧，所以呢？所以在这里，回到用户陷阱，你知道，在功能方面，你在陷阱实验室里仔细查看了。</p>
<p>发言人   57:53<br>And we dealt with, is this a case of system calls? And what we’re going to do is like, basically, the only thing we’re going to do is look at this case, which is the device interrupt. So we’re going to, it’s a little bit lower here in the file. So here’s the divisor to interrupt. And it looks basically at the SCO register and sees if this is an external interrupt. And if it’s an external interrupt, it calls a function to click claim, basically that particular to claim the interrupt.<br>我们处理的是，这是系统调用的情况吗？我们要做的就是，基本上，我们唯一要做的就是看看这个案例，也就是设备中断。所以我们要，它在文件中的位置稍微低一些。所以这是要中断的除数。它基本上会查看SCO寄存器并查看这是否是外部中断。如果它是外部中断，它会调用一个函数来单击请求，基本上就是那个特定的请求中断。</p>
<p>发言人   58:35<br>Let’s go back to click. And look at the claim. And basically what it boils down to is that the it, the this particular CPU will tell on the PLA, hey I’m claiming, you know, it is a CPU 0 or CPU 1. It will tell the PLA that CPU 1 is claiming this particular interrupt. And once the claimant interrupt and the plate returns, which interrupts, it gets, or the IU Q for the interrupt that actually came in. And so in this case, that will be and interrupt through the UART and the IQ 10. So plaque plane will basically return 10.<br>让我们回到点击。看看索赔。基本上，它归结为，这个特定的CPU会在聚乳酸上告诉你，嘿，我声称，你知道，它是一个CPU 0或CPU 1。它将告诉聚乳酸CPU 1正在请求这个特定的中断。一旦请求人中断并且盘子返回，中断就会得到，或者是实际进入的中断的IU Q。因此在这种情况下，这将通过UART和IQ 10进行中断。因此，斑块平面基本上将返回10。</p>
<p>发言人   59:14<br>And then here in this code, you know, we look, you say, hey, is this in route 10? If it’s in interrupt 10, that must be you are interrupt. And we basically called UART interrupt function and the UART interrupt function.<br>然后在这段代码中，你知道，我们看，你说，嘿，这是在路线10吗？如果它在中断10中，那一定是你在中断。我们基本上称之为UART中断函数和UART中断函数。</p>
<p>发言人   59:32<br>Runs and basically gets the character off, you know, the UART and the way it gets the character viewed it register it looks in the first register, the receive register, and gets the character out of there. And that is an integer. And then it calls console interrupt to do the rest of the work.<br>运行并基本上从UART中获取字符，你知道，它获取字符的方式是在第一个寄存器中查看，在接收寄存器中查看，然后从那里获取字符。这是一个整数。然后它调用控制台中断来完成其余的工作。</p>
<p>发言人   59:58<br>Okay? Actually, sure, I just did the wrong thing. We were talking about transmission.<br>好吗？实际上，当然，我只是做错了。我们正在谈论传播。</p>
<p>发言人   01:00:11<br>So if there was a character on the Reed site, then, you know, we’ll call caole in. But there is no character, correct on the read side because we haven’t read any. The keyboard hasn’t done anything yet. We’re just transmitting a character. So this return -1 fall through. And then basically the only thing in the loop is called it will full view arch start to basically send any other characters that might be in the buffer that the shell that might be stuck in there.<br>所以如果里德网站上有一个角色，那么你知道，我们会叫caole进来。但是没有字符，在读取端是正确的，因为我们没有读取任何字符。键盘还没有做任何事情。我们只是在传递一个角色。所以这个return -1失败了。然后基本上循环中的唯一东西被称为它将全视图拱门开始基本上发送缓冲区中可能卡在那里的shell中的任何其他字符。</p>
<p>发言人   01:00:42<br>And presumably there’s another character in there because after the dollar is the space and the right system call might, you know, to write the space might have happened concurrently while the device was sending off. And so when you interrupt, transmit, interrupt, complete, it goes off. Or it will find in the buffer you another character, the space character, and will be send that space character off.<br>大概还有另一个字符，因为在美元之后是空间，而正确的系统调用可能会在设备发送时同时发生写入空间。所以当你中断、传输、中断、完成时，它就会停止。或者它会在缓冲区中找到另一个字符，即空格字符，并将该空格字符发送出去。</p>
<p>发言人   01:01:07<br>Okay, does that make sense? I have a high level question actually. So I understand the Urt is like useful if I’m like using a keyboard and like characters from the keyboard go through the UART and then through the CPU and then the kernel code that we wrote. But I’m not sure I understand what the point of the UART is when the shell is printing characters like the keyboard isn’t being interacted with. No, that’s correct, but the display is right. So there’s sort of two devices here. One is the keyboard and one is the display or the console, and the way qmu interacts with the console is by UART, by sending a character to the console. And then the console’s job is basically to draw that character on the display.<br>好的，那感知吗？我实际上有一个高层次的问题。所以我理解，如果我喜欢使用键盘，像键盘上的字符经过UART，然后通过CPU，然后是我们编写的内核代码，那么这个Urt就非常有用。但我不确定我理解UART的意义是什么，当外壳打印像键盘没有交互的字符时。不，这是正确的，但显示是正确的。所以这里有两种设备。一个是键盘，另一个是显示器或控制台，qmu与控制台交互的方式是通过UART，即向控制台发送字符。然后控制台的工作基本上是在显示屏上绘制该字符。</p>
<p>发言人   01:01:59<br>Oh, I see, okay, thanks. And it might take a time. That’s why, you know, the thing you’re sort of interrupt driven.<br>哦，我明白了，好的，谢谢。这可能需要一些时间。这就是为什么，你知道，你有点被打断驱动的事情。</p>
<p>发言人   01:02:08<br>Okay, so a couple things. Now I want to step back a little bit and think a little bit at higher level what’s going on. So we sort of walk through the code, we can sort of a feeling for delay of the land and like how the, you know, for the you the details, it’s worth Ile to step back in a second and think a little bit about what it all means. And in particular, what is interesting is interrupting concurrency. Sort of think about interrupting the perspective concurrency. And this is one of the things vaccine makes interrupts tricky or difficult to program. So first of all, as I mentioned a little bit earlier, the device, the UART, in our case device, and the CPU run parallel.<br>好的，有几件事。现在我想退后一步，在更高层次上思考正在发生的事情。所以我们通过代码，我们可以感受到土地的延迟，就像你知道的细节一样，值得退后一步，思考一下这一切的含义。特别有趣的是中断并发。有点考虑中断透视并发。这是疫苗使中断变得棘手或难以编程的原因之一。首先，正如我之前提到的，在我们的案例中，设备UART和CPU并行运行。</p>
<p>发言人   01:03:03<br>So for example, in this scenario we just talked about, the UAR is sending off, you know, the character, you know, through the cozol. And while that’s happening, the CPU is just going about its business and in this case, returning to the shell shelle may make another system call for them to write that space character. And all happens in parallel. And so we need to manage that parallelism a bit. And we already saw it a little bit, but I’m going to talk a little bit more in detail and the type of parallelism that actually shows up here is typically called producer consumer parallelism.<br>例如，在我们刚刚谈到的这种情况下，UAR正在通过cozol发送角色。当这种情况发生时，CPU只是在处理自己的业务，在这种情况下，返回外壳可能会再次发出系统调用，让它们编写那个空格字符。一切都是平行发生的。因此，我们需要稍微管理一下这种并行性。我们已经看到了一点，但我将更详细地谈论一下，这里实际出现的并行类型通常被称为生产者消费者并行。</p>
<p>发言人   01:03:48<br>And let me talk about it in a second. So we’re going to talk about that in a little bit more detail.<br>让我马上谈谈这个问题。所以我们将更详细地讨论这个问题。</p>
<p>发言人   01:03:53<br>The second is that the interrupt. Stops the current running program? Or the current program is running. So in the case of the shell you, the shell might be executing extraction, like, you know, 212 and boom, interrupt comes in. And immediately at that point, it just stopped. And that for the user space code, that’s not a particularly big deal because when we return from the interrupt, will we restore all the state of the usual level program? And it will resume, you know, at that, you know, address where which got interrupted. And so we have seen that with traps and page vault.<br>第二个是中断。停止当前运行的程序？或者当前程序正在运行。因此，在shell的情况下，shell可能正在执行提取，就像你知道的，212和boom，中断进来。就在那个时候，它停止了。对于用户空间代码来说，这并不是一个大问题，因为当我们从中断返回时，我们会恢复通常级别程序的所有状态吗？它将恢复，你知道，在那个被打断的地址。所以我们已经在陷阱和页面库中看到了这一点。</p>
<p>发言人   01:04:41<br>And so, you know, actually works out reasonable well, but there’s a little bit of a tricky case when the kernel itself is interrupted. So you’re running in kernel mode, and the kernel gets interrupted. That means that, and you’ll talk a little bit more detail, even the kernel doesn’t really sort of executed straight sequentially. If you see one kernel instruction followed by another in kernel instruction between those two instructions, an interrupt might happen depending whether interrupt are enabled or not, So whether some piece of code, it’s not good to have an interrupt in between. And in that case, the kernel might actually have to disable or enable interrupts to make basically code sequences atomic. So interrupt. Enable and disable. I’ll talk about it in a second in a more detail.<br>所以，你知道，实际上工作得合理，但是当内核本身被中断时，会有一些棘手的情况。所以你正在内核模式下运行，内核被中断。这意味着，你会更详细地说一点，即使内核并不是直接按顺序执行的。如果在这两条指令之间看到一条内核指令跟着另一条内核指令，可能会发生中断，具体取决于是否启用中断，因此无论是某些代码，在它们之间有一个中断都是不好的。在这种情况下，内核可能实际上必须禁用或启用中断，以使基本上代码序列原子化。所以，打断一下。启用和禁用。我一会儿会更详细地谈论它。</p>
<p>发言人   01:05:37<br>And then sort of the third sort of concurrency problem that shows up the interrupt handler. Or maybe you say, let me say it differently, the top of the driver. In the bottom of the driver may run in parallel.<br>然后出现中断处理程序的第三种并发问题。或者你可以说，让我换个说法，司机的顶部。在驱动程序的底部可以并行运行。</p>
<p>发言人   01:06:08<br>So for example, in our example, shell is going to call the white system called again, you have to the white space after it printed the dollar and while go back into the top level of the driver, it might, it may want to add this white space to that queue that the UART actually has. But at the same time, on another CPU, it might actually take the interrupt form, the uarctic. And basically also you’re running in parallel in that’s of roughly in the same code and looking at the same queue. And so it’s really true that basically the interrupt handler can run in parallel or the bottom half of the device driver might run in parallel and different Cpu’s on the different view with the top half of the driver. So we have to manage that a bit. And the way you know, we’re going to manage that is using locks. Because there’s a shared data structure here, namely the buffer. And we’re going to make sure that, you know, the buffer is updated correctly and you to make sure that the only one CPU at a time basically manipulates that that particular buffer, we’re going to use, lock and locks is going to be the topic of Wednesday’s lecture.<br>因此，例如，在我们的示例中，shell将再次调用白色系统，您必须在打印美元后进入空白区域，同时回到驱动程序的顶层，它可能想要将此空白添加到UART实际拥有的队列中。但同时，在另一个CPU上，它可能实际上采用中断形式，即北极。基本上，你也在并行运行，在大致相同的代码中查看相同的队列。因此，基本上中断处理程序可以并行运行，或者设备驱动程序的下半部分可能并行运行，并且在驱动程序的上半部分的不同视图上有不同的Cpu。所以我们必须稍微管理一下。而且你知道的方式，我们将使用锁来管理它。因为这里有一个共享的数据结构，即缓冲区。我们要确保，你知道，缓冲区被正确更新，你要确保每次只有一个CPU基本上操纵那个特定的缓冲区，我们将使用，锁定和锁定将是星期三讲座的主题。</p>
<p>发言人   01:07:25<br>I’m not going to talk much about it at all, but it will show up big time on Wednesday. The thing I want to focus on is actually just produce a consumer. Parallelism, and this is a typical thing that shows up in drivers. And it is extremely common to see this. So producer, consumer.<br>我完全不打算谈论它，但它将在星期三大展现出来。我想关注的事情实际上只是生产消费者。并行性，这是司机中常见的现象。这是非常普遍的现象。所以，生产者，消费者。</p>
<p>发言人   01:07:53<br>And I think it’s pretty straightforward. So you’ve seen, you know, there’s basically a buffer in the driver. You know, in our case, I think there were 32 entries in it, so 0 to 31. And there’s sort of two pointer, there’s a read pointer and a right pointer. If the right pointer, read pointer, if they’re equal, you know the buff is empty. And so when you know the shell, you know we do a right, you know, or a putsy that you basically puts the character dollar here and bumps up the right pointer to the next entry. So that’s sort of the producer part. And the producer can keep going, you know, filling up, you know, all these characters until you know it, until until if the next increment would hit the re pointer.<br>我认为这很简单。所以你已经看到了，你知道，在驱动程序中基本上有一个缓冲区。你知道，在我们的例子中，我想里面有32个条目，所以是0到31。有两个指针，一个读指针和一个右指针。如果指针正确，读取指针，如果它们相等，你就知道增益效果是空的。所以当你知道了这个外壳，你就知道我们做了一个正确的，或者一个putsy，你基本上将字符美元放在这里，并将正确的指针颠簸到下一个条目。这就是生产者的部分。并且生产者可以继续进行，你知道，填充所有这些字符，直到你知道它，直到下一个增量到达重新指针。</p>
<p>发言人   01:08:48<br>We know that this circle buffer is full. And at that point of the producer washed up and we saw that happening in the code a second ago where the user basically the user could call sleep. And we’ll put this the shell on the side and start running another process.<br>我们知道这个圆形缓冲区已满。就在那个时候，生产者被冲走了，我们在一秒钟前的代码中看到了这种情况，用户基本上可以调用sleep。我们将把这个shell放在一边，开始运行另一个进程。</p>
<p>发言人   01:09:07<br>So the interrupt handler, and they’re like, you aren’t in it or enter. And in this case, the consumer. And basically every time when it you start, basically when you interrupts, it will look at the re pointer, if the Re pointer is behind the right pointer or the right pointer already further, let’s say the space is here 2 now, or I can know how to draw space, but here’s the space. And so the right pointer might now be here. So after the dollar is being sent, you know, the EU series that are, you know I’m behind the right pointer, that means I got to send the next one. And so you can think about this as sort of the right pointer, the read pointers, changing the right pointer. And that’s what’s going on.<br>所以中断处理程序，他们就像，你不在其中或者进入。在这种情况下，消费者。基本上，每次启动时，基本上当您中断时，它都会查看重新指针，如果重新指针在正确的指针后面或已经在正确的指针后面，假设空间现在在这里2，或者我知道如何绘制空间，但这是空间。所以正确的指针现在可能在这里。所以在美元被发送之后，你知道，欧盟系列，你知道我在正确的指针后面，这意味着我必须发送下一个。所以你可以把这看作是一种正确的指针，读指针，改变正确的指针。这就是正在发生的事情。</p>
<p>发言人   01:09:56<br>Now it could be the case that at some point the UAR keeps up with the right pointer, correct? And when they’re equal and then it knows that the buffer is empty and there’s nothing to do. Does that make sense? Sorry, so this data structure is the same for all cores.<br>现在情况可能是，在某个时刻，UAR会跟上正确的指针，对吗？当它们相等时，它知道缓冲区为空，没有什么可做的。感知了吗？抱歉，这个数据结构对于所有核心都是相同的。</p>
<p>发言人   01:10:18<br>Okay, so let me go back to the code, right? And then the high level picture, and let’s go back to UART. So this data structure that we just talked about is this buffer. And the two pointers here on the right in the read pointer are these two indexes, these indices, okay? And this data structure lives in memory, and there’s only one Ram. And so all the core might be interacting with this data structure in parallel. That’s why we need locks. Okay, I see.<br>好的，那么让我回到代码，对吗？然后是高级图片，让我们回到UART。我们刚才谈到的这个数据结构就是缓冲区。这里右边的两个指针是这两个索引，这些索引，好吗？这个数据结构存在于内存中，并且只有一个Ram。因此，所有核心可能都并行地与这个数据结构进行交互。这就是为什么我们需要锁。好的，我明白了。</p>
<p>发言人   01:10:58<br>My other question was for sleep. How does it know to make the shell sleep? Like what is written? There is just the address. Okay, basically the sleep puts the current process running on the sleep in a sleep state. We’ll talk about it in next week or the week after in a great amount of detail. And it passes in the thing that it is waiting for. And in this case, that ISD, the dress, you know, basically it has a channel ID or like a way of communicating for what it actually sleeping on. And so in this case, it is txr it’s the address of ur t.x.r.h..<br>我的另一个问题是睡眠。它怎么知道让贝壳睡觉？像写什么？这里只有地址。好的，基本上睡眠将当前在睡眠状态下运行的进程置于睡眠状态。我们将在下周或后一周详细讨论它。它传递了它正在等待的东西。在这种情况下，这件衣服，你知道，基本上它有一个通道账号，或者一种沟通它实际睡觉的方式。所以在这种情况下，它是txr，它是ur t.x.r.h .. 的地址。</p>
<p>发言人   01:11:48<br>And the start function, it wants their space again in the buffer. It will wake up. It will call the corresponding call, wake up with the Urt RR to indicate that any process that’s actually sleeping on this address should be woken up. And how these exact is implemented is something that we’ll see a little bit later. Does that make sense? So these two calls go together, sleep and wake up.<br>和开始函数，它希望它们再次在缓冲区中占用空间。它会醒来的。它将调用相应的调用，以RR RR唤醒，以指示任何实际在该地址上休眠的进程都应该被唤醒。这些确切的实现方式我们稍后会看到。感知了吗？所以这两个电话一起走，睡觉和醒来。</p>
<p>发言人   01:12:21<br>Sometimes called conditional synchronization. Any other questions?<br>有时称为条件同步。还有什么问题吗？</p>
<p>发言人   01:12:36<br>Okay? Good, let’s see. So let’s see. So that’s basically the whole story for printing a dollar. And as you can see, it’s actually quite involved. There’s a lot of pieces that are working together to actually get this dollar out into the console. And something similar basically happens on the re size. So at some point, the shell has printed both the dollar and the white space.<br>好吗？好的，让我们看看。让我们看看。这基本上就是印刷美元的整个故事。正如你所看到的，这实际上相当复杂。有很多部分正在协同工作，以实际将这一美元投入控制台。类似的事情基本上发生在重新大小上。所以在某个时候，外壳同时印刷了美元和空白。</p>
<p>发言人   01:13:08<br>And then we call read to basically read input, you know, from the keyboard. So now we want to just see what happens when that happening. So that starts basically in the end, we’ve filed again, so now there’s a reach system call. If it’s reading from the console, it will, it will actually will, of course file read, sorry, right?<br>然后我们调用read来基本上读取输入，你知道，来自键盘。所以现在我们想看看当这种情况发生时会发生什么。所以基本上从最后开始，我们已经再次提交了，所以现在有一个reach系统调用。如果它是从控制台读取的，它会，它实际上会读取文件，抱歉，对吧？</p>
<p>发言人   01:13:35<br>If it’s a device, which in this case the case it’s a console, then we call the read method for that device. And that is in console DOC. And so we’re going to go to console read is being called.<br>如果它是一个设备，在这种情况下它是一个控制台，那么我们调用该设备的读取方法。这在控制台文档中。因此，我们将转到控制台，读取正在被调用。</p>
<p>发言人   01:13:49<br>And basically it has the same structure as this UART. You know, there’s a circular buffer, the top. Here it is, it’s an input buffer from the eight characters in it. And basically, it’s the same game. You know, it’s a producer consumer parallelism, but in this case, the shell is the consumer, right? It actually is reading, you know, characters off the buffer and the keyboard is the producer. It takes the characters into the buffer.<br>基本上它与这个UART具有相同的结构。你知道，有一个圆形缓冲区，顶部。这里是它，它是其中八个字符的输入缓冲区。基本上，这是同一个游戏。你知道，它是生产者消费者并行，但在这种情况下，shell就是消费者，对吧？它实际上正在读取缓冲区中的字符，而键盘是生产者。它将字符放入缓冲区。</p>
<p>发言人   01:14:18<br>Let’s go back to caole read if there’s nothing, if the read pointer or the read index and the right index are the same, you know, basically the buffer is empty and it goes back to sleep again. And so, so after it’s printed a dollar in the Amper, the shell is going to go to sleep or the colonel will put the shell to sleep until you, a character, comes in.<br>让我们回到caole read，如果什么都没有，如果read指针或read索引和正确的索引相同，你知道，基本上缓冲区是空的，它又回到睡眠状态。所以，在安珀打印了一美元之后，这个贝壳就会睡觉，或者上校会让贝壳睡觉，直到你这个角色进来。</p>
<p>发言人   01:14:44<br>And so at some point, let’s say, you know, a user types in L, you know, the first character from LS on the keyboard that will cost, you know, the L to be sent to the UART chip on the board that will be routed through the P, you know, to assume core, That core will take the interrupt that will go to dev in the def in, will see how you would interrupt, and then we’ll call the function that we looked at a second ago, it goes back to the bottom where I got my refused money selfish for second. So in this case, you know, it will write it will get a character from the device, from the EU device, correct? It will get the character L, and we’ll call the console inner function using with the character L, so we can go back to console. And so in, you know, thus, you know, gets the character. So now we have an L, if it’s a control P that actually prints in list, in the processing list, to implements c, h and c u to do backspace and control whatever. But in all other cases, basically what it does, it echoes the character back to the user by printing it to the console. And then it basically sticks the character into the buffer. So that wake up the process that’s waiting for that buffer.<br>因此，在某个时候，假设用户输入L，你知道，键盘上LS的第一个字符将花费L被发送到板上的UART芯片，该芯片将通过P路由，你知道，假设核心，该核心将接受中断，该中断将转到def中的dev，将看看您将如何中断，然后我们将调用我们一秒钟前看过的函数，它将返回到底部，在那里我得到了我拒绝的钱自私的第二个。所以在这种情况下，你知道，它会从设备中写入一个字符，从EU设备中获取，对吗？它将获取字符L，并且我们将使用带有字符L的调用控制台内部函数，以便我们可以返回控制台。所以，你知道，因此，你知道，得到了角色。所以现在我们有一个L，如果它是一个实际在列表中打印的控制P，在处理列表中，实现c，h和c，以执行退格和控制任何操作。但在所有其他情况下，基本上它的作用是通过将字符打印到控制台将其回显给用户。然后它基本上将角色插入缓冲区。这样就会唤醒等待该缓冲区的进程。</p>
<p>发言人   01:16:09<br>If there’s a process waiting, if it has hit new line and there’s a process waiting, it will wake up the waiting process, and then the waiting process will read, you know, the characters out of the buffer again.<br>如果有一个进程正在等待，如果它已经到达新行并且有一个进程正在等待，它将唤醒等待的进程，然后等待的进程将再次从缓冲区中读取字符。</p>
<p>发言人   01:16:22<br>So here again, we see this sort of decoupling using a buffer between the consumer and the producer so that the Pres and consumer can just run in parallel, independent each on their own speed. And if one goes very fast, you know, either the buffer will be empty or full and then will block or wait until the other guy catches up. Any questions about this?<br>因此，在这里，我们再次看到这种使用消费者和生产者之间的缓冲区进行解耦，以便Pres和消费者可以并行运行，独立运行各自的速度。如果一个人走得很快，你知道，缓冲区要么是空的，要么是满的，然后会阻塞或等待，直到另一个人赶上。对此有什么问题吗？</p>
<p>发言人   01:16:55<br>Okay? Okay, I want to talk basically about one more thing. And that is. You know I’m I being, I want to talk a little bit about sort of interrupt evolution like what has happened over the last decades?<br>好吗？好的，我想基本上再谈一件事。这就是。你知道我是，我想谈谈中断进化，就像过去几十年发生了什么？</p>
<p>发言人   01:17:25<br>So interrupt used to be relative to a process, reasonable, fast, in particular in.<br>所以中断过去相对于进程来说是合理的、快速的，尤其是在。</p>
<p>发言人   01:17:38<br>So in times the original units was developed, you know, that was the case. And that basically meant like that the hardware is very simple because it’s going to, if any, really sort of serious work need to be done, we could just interrupt the processor and the project would do it on the work. So, but the Hartford itself could be reasonable, straightforward. Now, interrupts are slow compared to the processor. You can see DOC because the interrupt handler, it means to save restore registers, it makes it take the interrupt. So there’s a couple of, you know, there’s a small budget of instruction that it is being used to actually serve as the internet. And so if a device generates interrupts at a high speed, and then the processor is going to have a tough time keeping up. And so you look at today’s devices, basically the hardware or the device, there’s a lot more work.<br>所以在最初的单位被开发出来的时候，你知道的，就是这样。这基本上意味着硬件非常简单，因为如果需要完成任何真正严肃的工作，我们可以中断处理器，项目会在工作上完成它。所以，哈特福德本身可能是合理的，直截了当的。现在，与处理器相比，中断速度较慢。你可以看到DOC，因为中断处理程序意味着保存恢复寄存器，它使得它需要中断。所以有几个，你知道，有一个小预算的教学，它被用来实际作为互联网。因此，如果设备以高速生成中断，然后处理器将很难跟上。所以你看看今天的设备，基本上是硬件或设备，还有很多工作。</p>
<p>发言人   01:18:40<br>And so basically a bunch of the work on the device itself before actually generating an interrupt. And so, and just to avoid interrupting the process too much, now if you really have a high performance device, like say you have a gigabyte, gigabit, even Itt. And you know that cart you use a lot? A lot of small packages, packets. Then, you know, you can actually generate or even itself could generate about 1, 1.5 million packs per second.<br>因此，在实际生成中断之前，基本上需要在设备本身上进行一些工作。因此，为了避免过多地中断过程，现在，如果你真的有一个高性能设备，比如你有一个千兆字节，千兆比特，甚至是Itt。你知道你经常使用的那辆车吗？很多小的包裹。那么，你知道，你实际上可以生成甚至自己每秒可以生成大约1，150万个包。</p>
<p>发言人   01:19:16<br>For minimal is like 64 B. Even in packets. You can do the math. You can roughly to basically you’re generating 1.5 million packets per second that you could receive. And so that basically means, you know, 1 interrupt. If you did it for every packet per microsecond. In fact, a little bit more than a. Little bit less than or a little bit more than. So you basically do, one way to think about it, if there’s one interrupter, microsecond is basically the operating system.<br>最小的就像64 B。甚至是包裹。你可以计算一下。你可以大致达到每秒生成150万个数据包的目的，你可以接收这些数据包。这基本上意味着，你知道，1个中断。如果你每微秒对每个数据包都这样做。事实上，比a稍微多一点。稍微小于或稍微大于。所以你基本上可以这样想，如果有一个中断器，微秒基本上就是操作系统。</p>
<p>发言人   01:19:50<br>The kernel basically has a budget of like 1 microseconds of structures is to actually process the packet. And the fact that it’s 1.5 million, it a little bit less than a budget of a microsemi. So you can compute out how many instructions that is. And it’s not going to be that much. And so in that case, know you need to have a different plant.<br>内核基本上有一个大约1微秒的预算结构，用于实际处理数据包。而且它是150万，这比微软的预算略少。所以你可以计算出这是多少条指令。不会有那么多。所以在这种情况下，知道你需要有不同的植物。</p>
<p>发言人   01:20:11<br>Like what do you do if the packets were an interrupter? The packs are coming in so fast that the pressure really can’t keep up. And the solution to that for? These fast devices, it’s actually something used. It’s called pulling.<br>比如，如果数据包是一个中断者，你会怎么做？背包进来得太快了，压力真的跟不上。解决这个问题的方法是什么？这些快速设备，实际上是二手的东西。这叫做拉动。</p>
<p>发言人   01:20:33<br>And instead of relying interrupts, what the CPU also could do is just keep reading that control register and to see if there’s a byte there, like in the UART register, we just keep reading that LHR register and just check if there’s a bike there and basically wouldn’t. What this bio boils out is that the CPU spins. Spins on the device until device has input. Test. Data and you know this waste CPU cycles, correct because.<br>而不是依赖中断，CPU还可以做的是继续读取控制寄存器并查看那里是否有一个字节，就像在UART寄存器中一样，我们只是继续读取LHR寄存器并检查那里是否有一辆自行车，基本上没有。这个生物的沸腾是CPU旋转。在设备上旋转，直到设备有输入。测试。数据，你知道这个浪费的CPU周期，正确的原因是。</p>
<p>发言人   01:21:17<br>While we’re sort of checking that register over and over and over again to see if there are actually any any data, we’re not using those cycles to run another application. And before, what you’ve seen is that if there’s nothing there, basically the colonel puts the shell to sleep, so then another application could run. But if we do pulling, then, you know, that wouldn’t happen. Now, for a slow device, you clearly want, you know, not spin forever until the finally gets around to actually doing its work. We really like to basically switch out the shells so that we can run something else. If the device is extremely fast, then the overhead of the interrupt temperature is high and we’re better off actually wasting basically pulling that device because very quickly, we’re going to get success. And so if but waste Cpos, the devices are slow.<br>当我们一遍又一遍地检查该寄存器以查看是否确实有任何数据时，我们不会使用这些周期来运行另一个应用程序。之前，你所看到的是，如果那里什么都没有，基本上上校会让外壳进入睡眠状态，这样另一个应用程序就可以运行了。但如果我们拉，那么，你知道，那就不会发生。现在，对于一个缓慢的设备，你显然希望，你知道，在最终实际完成工作之前，不要永远旋转。我们真的很喜欢基本上切换shell，以便我们可以运行其他东西。如果设备速度极快，那么中断温度的开销就很高，我们最好实际上浪费的是拉那个设备，因为很快我们就会成功。因此，如果浪费Cpos，设备就会很慢。</p>
<p>发言人   01:22:17<br>But you know?<br>但是你知道吗？</p>
<p>发言人   01:22:23<br>But if the device is fast?<br>但是如果这个设备很快呢？</p>
<p>发言人   01:22:30<br>It saves saving your story. Or since the whole entry, entry and exit costs?<br>保存你的故事。还是因为整个进入、进入和退出成本？</p>
<p>发言人   01:22:46<br>And so example, doing a high performing network car. Well, if there’s a stream of packets coming in and actually will use polling. And the most sophisticated drivers, basically, they dynamically switch. Switch between polling and interrupt.<br>例如，做一辆高性能的网络汽车。好的，如果有一个数据包流进来并且实际上会使用轮询。而最复杂的驱动程序，基本上是动态切换的。在轮询和中断之间切换。</p>
<p>发言人   01:23:18<br>Okay? Any questions? Close to my because my time budget is up. Any remaining questions?<br>好吗？有问题吗？接近我的时间，因为我的时间预算已经到了。任何剩余问题？</p>
<p>发言人   01:23:35<br>Okay, good. Then I’ll show you Wednesday. And basically Wednesday, we’re going to continue the story of concurrency and we’re going to show parallelism. We’re going to see some mechanisms to actually manage the parallelism to make sure the shared data structures get updated correctly. So see you on Wednesday.<br>好的，好的。然后我将在星期三给你展示。基本上，星期三我们将继续讲述并发性的故事，并展示并行性。我们将看到一些机制来实际管理并行性，以确保共享数据结构得到正确更新。所以我们周三见。</p>
<p>发言人   01:23:54<br>Oh I’m sorry, I just, I was trying to find where my question was because I lost it. My question was in the so I saw that your init is just being called once, Is that why there is just one buffer for all the course to share together? Well, there’s only only one U device. You know, corresponds, you know, to the one UART device that actually is being shared between all the core know, like there might be multiple processes are running on different courses, all trying to print to the console. Okay, I see. Oh, yeah, it makes sense, that makes sense. So like only one Cora will do stuff with you at the time. Yeah, well, it’s a slightly complicated, but let’s look at, so let’s say there’s multiple guys writing just for one experiment, correct?<br>哦，对不起，我只是想找到我的问题在哪里，因为我把它弄丢了。我的问题在，所以我看到你的init只被调用一次，这就是为什么只有一个缓冲区可以让所有的课程共享？嗯，只有一个U设备。你知道的，对应于一个在所有核心之间共享的UART设备，就像可能有多个进程在不同的球场上运行，都试图打印到控制台。好的，我明白了。哦，是的，这很感知，这很感知。所以当时只有一个科罗会和你一起做事情。是的，嗯，这有点复杂，但让我们来看看，假设有多个人只为一个实验写作，对吗？</p>
<p>发言人   01:25:04<br>And what we see, if there’s multiple, let me actually. So here’s huar putsy, because the first thing you see is actually, it actually acquires a lock. So if multiple cores are trying to put the character into the buffer, one of them is going to get the lock and none of the others are going to get to lock. And so that one guy know the 1 CPU that actually got the locker, acquired the lock successfully, is able to go in, look at the right pointer, stick a character in if possible, and otherwise go to sleep. And then if it’s done, you know, releases the lock and then the next, you know, core can go in and acquire the lock and do its work. So basically these lock will serializes the concurrent axis to the UART. That makes sense, yeah, thank you. And well, Wednesday, we’ll talk in detail about locks.<br>我们所看到的，如果有多个，让我来。这里是huar putsy，因为你看到的第一件事实际上是它实际上获得了一把锁。因此，如果多个内核尝试将字符放入缓冲区，其中一个内核将获得锁定，而其他内核都不会获得锁定。这样一个人就能知道实际上装了储物柜的1个CPU，成功地获取了锁，能够进入，查看正确的指针，尽可能地插入一个字符，否则就进入睡眠状态。然后，如果完成了，你知道，释放锁，然后下一个核心可以进入并获取锁并完成其工作。所以基本上这些锁会将并发轴序列化为UART。这很感知，是的，谢谢。好吧，星期三，我们将详细讨论锁。</p>
<p>发言人   01:26:07<br>Thank you any further questions?<br>谢谢您还有什么问题吗？</p>
<p>发言人   01:26:12<br>I have a question, so I, as far as I understand why we need the lock inside the interrupted because we there’s only one console and they can be multiple cores, right? You mean the this lock where I think so, right? Because usually we don’t want to lock things inside interrupts, right? Yeah, you asked this question by email. Yes, well, the issue is that, as I mentioned earlier, the bottom half or the interrupt handler could run in parallel with the top half. And so one chord could be doing uarc putsy, and another core could be you running, you aren’t. And we got to make sure that they sort of don’t get tangled up together, correct, that they serialized correctly. And the lock basically ensures that they get serialized.<br>我有一个问题，所以据我所知，为什么我们需要被中断的锁，因为我们只有一个控制台，它们可以是多个核心，对吧？你是指我想的那个锁，对吗？因为通常我们不想把东西锁在中断里面，对吧？是的，你通过电子邮件问了这个问题。是的，问题在于，正如我之前提到的，下半部分或中断处理程序可以与上半部分并行运行。所以一个和弦可以做uarc putsy，另一个核心可以是你跑步，你没有。我们必须确保它们不会纠缠在一起，正确地序列化。而锁基本上确保了它们被序列化。</p>
<p>发言人   01:27:05<br>Okay, that makes sense. But that that does mean that sometimes, like all cores could potentially be waiting for one of them to be handling this, right? Yeah, because the interrupt has to wait and then nothing else can get scheduled. Well, presumably there’s some other process may be running.<br>好吧，那很感知。但这确实意味着有时候，就像所有的核心一样，可能都在等待其中一个来处理这个问题，对吧？是的，因为中断必须等待，然后没有别的东西可以安排。嗯，大概有一些其他进程正在运行。</p>
<p>发言人   01:27:25<br>It’s unlikely there’s no deadlock. There is a risk of deadlock, but that’s not this one that we’ll talk about in Wednesday. And then presumably what this means, like if there’s multiple guys called, you are put, see the buffer is full. Then at some point, this interrupt, they actually will release the lock. So for example, let’s go back to uarp, see what actually will happen, correct, is that they will call sleep, and sleep actually takes the lockers in argument, and we’ll see later why. But internally, before sleep actually puts the process definitely to sleep and it will release the lock. Oh, I see, so basically you call sleep with the lock and then that means, okay, release the lock while you sleep, so someone else does it exactly, okay, interesting, and then when you return from sleep, you just re acquire it, okay, back, right, right?<br>不太可能没有僵局。存在死锁的风险，但这不是我们将在周三讨论的问题。然后大概是这意味着什么，就像如果有多个人被叫来了，你就会看到缓冲区已满。然后在某个时候，这个中断，他们实际上会释放锁。因此，例如，让我们回到uarp，看看实际会发生什么，正确的是，他们会称之为睡眠，而睡眠实际上在论证中使用了储物柜，我们稍后会看到为什么。但在内部，在睡眠之前实际上会让进程进入睡眠状态，它会释放锁。哦，我明白了，所以基本上你打电话给带锁的睡眠，这意味着，好的，在你睡觉的时候释放锁，让其他人完全做到这一点，好吧，很有趣，然后当你从睡眠中回来时，你就得到了它，好的，回来，对吧？</p>
<p>发言人   01:28:26<br>Yeah, makes has a separate story that we’ll talk about in a week or two weeks, that makes sense, Yeah? Yeah, so I guess, so I guess that wasn’t that clear to me that all Cpu’s get the interrupt when somebody like sent something through ur, no, well, depend depends on how you program the PLA The way X 6 is programmed, the plate is that only one CPU? Well, all CPU might get interrupted, but one is going to clean the interrupt, okay? If you go back to the plaque, you know, when you get an interrupt you call this claim and that CPU that particular core is going to get. The Irq and then basically the BC will remember that that IQ is now being served and won’t give it to anybody else. I see. Okay, so we’ll just one of them will get it randomly or no.<br>是的，制作有一个单独的故事，我们将在一周或两周后谈论，这很感知，是吗？是的，所以我想，我想我不太清楚，当有人通过你发送东西时，所有的Cpu都收到中断，不，这取决于你如何以x6的方式编程聚乳酸，板是只有一个CPU吗？所有的CPU都可能被中断，但其中一个会清理中断，好吗？如果你回到牌匾，你知道，当你得到一个中断时，你称之为这个声明，那个特定核心将得到的CPU。Irq和基本上BC会记得那个智商现在正在被服务，不会把它给其他人。我明白了。好的，所以我们只有其中一个会随机得到它，或者没有。</p>
<p>发言人   01:29:31<br>You can program the say or, you know, maybe prior to one. Oh, I see, I see, I see. So inside the, yeah, inside the PLA is the code that actually decides on who who to bother a circuit.<br>你可以编程说，或者你知道，也许在某个事情发生之前。哦，我明白了，我明白了。所以在聚乳酸里面，是的，里面是决定谁来打扰电路的代码。</p>
<p>发言人   01:29:46<br>There’s no code in the I think, right CPU program. Yeah, program. Yeah, I was just going to say, where does the play code run? But yeah, it’s not code, it’s hardware. Okay, that makes sense. All right, thanks.<br>在我认为正确的CPU程序中没有代码。是的，程序。是的，我只是想问，戏剧代码在哪里运行？但是，这不是代码，而是硬件。好吧，那很感知。好的，谢谢。</p>
<p>发言人   01:30:04<br>I’ll see you on Wednesday, no? So I got a question kind of related to the thinking about multiple cores running at the same time. So I think I recall in like one of the labs with, say, the primes question, we saw that print actually like interleaves that often. Is that because the locks are only around like the put C, but the putsy calls from multiple course credential leave, meaning that like a single print is not guaranteed to be atomic. You got it? Okay, that makes sense.<br>我会在星期三见到你，不是吗？所以我有一个问题，与思考同时运行多个内核有关。所以我想我记得在一个实验室里，比如说质数问题，我们看到那个印刷品实际上就像交错片一样经常出现。那是因为锁只是像put C一样围绕着，但是来自多个课程凭证的putsy调用离开了，这意味着像单个打印一样不能保证是原子的。你明白了吗？好吧，那很感知。</p>
<p>发言人   01:30:39<br>All right, thank you.<br>好的，谢谢。</p>
<p>发言人   01:30:42<br>I have a quick question. So I remember reading in the like that the reading said something about the timer interrupts being handled in machine mode and I was wondering where that was handled when we were doing the traps lab, like where the switch to machine mode was happening during the traps lab and then what we were doing. Yeah, okay, so great question. So I’m pulling up the code. So if you look at your start correct, and this start rooms in a mode at the beginning of time when the machine boots and it programs the timer check. And so your timer in it and timer in, and basically programs deploy the Clint, which is the local interrupter to generate interrupts when.<br>我有个简短的问题。所以我记得在类似的阅读中提到计时器中断在机器模式下处理，我想知道我们在进行陷阱实验时是在哪里处理的，比如在陷阱实验期间切换到机器模式的情况以及我们在做什么。是的，好的，很好的问题。所以我正在提取代码。所以，如果你看你的开始正确，并且这在机器启动时以一种模式启动房间，并且它对计时器检查进行编程。因此，你的计时器在里面，计时器在里面，基本上程序部署Clint，它是本地中断器，在发生中断时产生中断。</p>
<p>发言人   01:31:36<br>A clock interrupt happens. And basically, here is probably the most important function here. It sets the machine mode trap handler to a D function called timer vec. So that’s written assembly. And when the time interrupt happens, that function is being called. And so when your kernel is running user mode or in supervisor mode, and the clean generates an interrupt, raises the line, and, it will switch to machine mode and call this function time effect in the same way, basically as, almost equivalent to what we’ve seen for supervisor mode in user mode.<br>时钟中断发生。基本上，这里可能是最重要的功能。它将机器模式陷阱处理程序设置为一个名为timer vec的D函数。这就是编写的汇编。当中断发生时，该函数被调用。因此，当你的内核运行在用户模式或主管模式下时，clean生成一个中断，抬起线，它将切换到机器模式并以相同的方式调用这个函数time效果器，基本上就像，几乎相当于我们在用户模式下看到的主管模式。</p>
<p>发言人   01:32:18<br>Okay, check. And then if you look in kernel VC DOS, we looked at kernel vector watt, right? I mean, that’s that function that C, if it restores a lot. And here’s timer Vec, it’s basically the same sort of type of idea.<br>好的，检查一下。然后如果你看一下内核VC DOS，我们看了内核向量瓦特，对吧？我的意思是，这就是那个函数C，如果它能恢复很多。这里是计时器Vec，基本上是相同类型的想法。</p>
<p>发言人   01:32:34<br>Let’s say it’s a couple register so that it could do a job. And the only job it does is actually these sort of six lines of code here or whatever, 5, 7 lines of code. And basically what it does if, you know, reprograms the claims to generate future interrupts, and then basically raises a software interrupt to the supervisor. So that goes to supervisor mode.<br>假设它是一对夫妇注册，以便它可以完成一项工作。它唯一的工作实际上是这些六行代码或者其他什么，5、7行代码。基本上，如果你知道，重新编程声明以生成未来的中断，然后基本上向主管发出软件中断，它会做什么。这样就进入了主管模式。</p>
<p>发言人   01:32:57<br>And so then at the point at emir emir, let’s say the kernel was interrupted you during a timer chip, during the timer chip. So it went to machine mode, and red then returns from machine mode back to supervisor mode, right? And if the interrupt was enabled in supervisor mode at that point, immediately the supervisor in the supervisor software interrupt will be generated.<br>那么在埃米尔·埃米尔的时候，假设内核在定时器芯片中被中断了，在定时器芯片中。所以它进入机器模式，红色然后从机器模式返回到主管模式，对吧？如果此时在主管模式中启用了中断，则会立即生成主管软件中断中的主管。</p>
<p>发言人   01:33:21<br>Oh okay. And now basically the kernel will do the same thing, right? Basically will go to kernel vec, you know, save and store all the registers. And then go to kernel trap. And the colonel trap will see, that was the timer interrupt, I see. And so what was the point of switching to machine mode in the first place? Like what exactly does it do? I don’t know what the point is, but this is like the hardware works, okay? Actually work a little bit more, yeah.<br>哦，好的。现在基本上内核也会做同样的事情，对吧？基本上会转到内核vec，你知道，保存和存储所有寄存器。然后转到内核陷阱。上校陷阱会看到，那是计时器中断，我明白了。那么，一开始切换到机器模式的意义是什么？比如它的具体作用是什么？我不知道重点是什么，但这就像硬件工作一样，好吗？实际上工作稍微多一点，是的。</p>
<p>发言人   01:33:56<br>There are some reasons, I think, why the time of Chip X goes to machine mode, but from our perspective would be great if we could have delegated the timer to supervisor mode and never had to deal with time remote. But you know, doesn’t work for this particular chip. Okay, that makes sense, thank you so much. Oh, you’re, oh, I actually have a follow up on, this part of so keep asking questions, please.<br>我认为，芯片X的时间进入机器模式是有一些原因的，但从我们的角度来看，如果我们可以将计时器委派给主管模式，而不必处理时间远程，那就太好了。但是你知道，不适用于这个特定的芯片。好的，这就是感知，非常感谢。哦，你是，哦，我实际上有一个跟进，所以请继续问问题。</p>
<p>发言人   01:34:26<br>Yeah, I saw that it allocates 32, you went 64, but it only seems to be using 4, no, three of them, right? And start does see it and scratch. Yeah, I guess allocates more than it’s necessary scratches 32 the scratch area. The reason. So. So for every CPU, correct, there has to be some scratch space. I guess we have three or something like that Cpu’s. So it basically allocates a little bit too much.<br>是的，我看到它分配了32个，你分配了64个，但它似乎只使用了4个，不，是三个，对吗？并开始看到它并划伤。是的，我想分配的划痕超过了必要的32划痕区域。原因。所以。因此，对于每个CPU，正确的，必须有一些临时空间。我想我们有三个或类似的Cpu。因此它基本上分配得有点过多。</p>
<p>发言人   01:35:18<br>But there’s no harm allocating too much, okay? Okay, so like it only uses scratch 0, scratch 1, 1, so uses 3, okay, so 0, so 3, that’s 4, 4, 5, correct? So 6, so that’s 6 integers. And I guess we have, we were running, we could run with four Cpu’s, but we’re running with three, but we could run with four. So 6 times 424, I guess we’re definitely allocating a bit too much memory. I don’t remember, I thought about this a while back ago, and I don’t remember exactly where. Early 2 came from, so let me double check, see if I can reconstruct that.<br>但是分配太多也没有坏处，好吗？好的，所以它只使用了刮痕0，刮痕1，1，所以使用了3，好的，所以0，所以3，那是4，4，5，对吗？所以是6，所以是6个整数。我想我们有，我们正在运行，我们可以用四个Cpu运行，但我们正在运行三个，但我们可以用四个运行。所以6乘以424，我想我们肯定分配了太多的内存。我不记得了，我很久以前就想过这个问题，我不记得具体在哪里了。早2来自，所以让我仔细检查一下，看看我是否能重建它。</p>
<p>发言人   01:36:41<br>Oh, same resource. They’re all four. They’re all 8 B, correct, yeah. And it?<br>同样的资源。他们都是四个。它们都是8 B，正确，是的。然后呢？</p>
<p>发言人   01:37:04<br>Okay, let me get back to you. I can recall right at the top of my head, you know why it is the way it is. Okay, make sense? Thank you so much, you’re welcome. Good questions, thank you.<br>好的，让我回复你。我可以回忆起我的头顶，你知道为什么它是这样的。好的，做感知？非常感谢你，不客气。好问题，谢谢。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>操作系统工程 008-Interrupts</div>
      <div>http://example.com/2025/10/18/6S081-008/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月18日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/18/6S081-009/" title="操作系统工程 009-Multiprocessors and Locks">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">操作系统工程 009-Multiprocessors and Locks</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/18/6S081-007/" title="操作系统工程 007-PageFaults">
                        <span class="hidden-mobile">操作系统工程 007-PageFaults</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
