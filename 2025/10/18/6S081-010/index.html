

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="发言人   00:00Now you can hear me, can hear you, thank you. All right? I’d like to spend today’s lecture talking about threads and how Xb 6 does thread switching. This is sort of one of our under the hoo">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统工程 010-Thread Switching">
<meta property="og:url" content="http://example.com/2025/10/18/6S081-010/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="发言人   00:00Now you can hear me, can hear you, thank you. All right? I’d like to spend today’s lecture talking about threads and how Xb 6 does thread switching. This is sort of one of our under the hoo">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-18T02:00:10.000Z">
<meta property="article:modified_time" content="2025-10-25T05:03:39.719Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>操作系统工程 010-Thread Switching - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="操作系统工程 010-Thread Switching"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-18 10:00" pubdate>
          2025年10月18日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          22k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          181 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">操作系统工程 010-Thread Switching</h1>
            
            
              <div class="markdown-body">
                
                <p>发言人   00:00<br>Now you can hear me, can hear you, thank you. All right? I’d like to spend today’s lecture talking about threads and how Xb 6 does thread switching. This is sort of one of our under the hood lectures about X 6. We’ve had lectures before about how system calls interrupt page tables and locks work, And today we’re going to talk about how it is that Xb 6 switches among different processes now.<br>现在你能听到我，能听到你，谢谢。一切都好吗？我想在今天的讲座中谈论线程以及Xb 6如何进行线程切换。这是我们关于X 6的底层讲座之一。我们之前已经讲过系统调用是如何中断页表和锁的工作的，今天我们将讨论Xb 6现在是如何在不同的进程之间切换的。</p>
<p>发言人   00:32<br>The reason for this, the highest level reason for this, is that people like their computer to be able to do more than 1 task at the same time. So the reason might be that you’re supporting time sharing. Like Athena allows many users to log in at the same time and you know, they can all run processes or even on a single user machine or even your iPhone, you may run many different processes. Expect a computer to do all the things you ask of it, not just one thing.<br>造成这种情况的原因，最高级别的原因是人们喜欢他们的电脑能够同时完成多项任务。原因可能是你支持分时分享。像Athena一样，它允许多个用户同时登录，你知道，他们可以全部运行进程，甚至在单个用户的机器上，甚至在你的iPhone上，你可以运行许多不同的进程。期望计算机完成你要求它做的所有事情，而不仅仅是一件事。</p>
<p>发言人   01:00<br>Another reason that people like to support multiple tasks is because it can ease program structure. Threads, in particular, today’s topic are sometimes used as a way to help people, to help programmers put together a program in a sort of simple, elegant way to reduce complexity. Now, you actually saw an example of this in the first lab with the prime number sieve, which didn’t use threads exactly, but used multiple processes in order to help structure this, your prime number sort of software. And arguably, it’s sort of a more convenient or elegant or simpler way to write that software. And a final reason why people use threads is to get parallel speed up from multicore machines. So it’s common to break up your program in a way that using threads to allow different parts of the same program to run on different cores. And you know, if you can, maybe if you’re lucky, if you can split your program up to run on four threads, on 4 cores, you might be able to get a factor of four speed up and how fast it runs. And indeed, you can view the XV 6 kernel as a multi-core parallel program.<br>人们喜欢支持多个任务的另一个原因是因为它可以简化程序结构。特别是线程，今天的主题有时被用作帮助人们，帮助程序员以一种简单、优雅的方式组合程序以减少复杂性。现在，你实际上在第一个实验室中看到了质数筛的例子，它不完全使用线程，而是使用多个进程来帮助构建你的质数类软件。可以说，这是一种更方便、优雅或更简单的编写软件的方式。人们使用线程的最后一个原因是为了从多核机器中提高并行速度。因此，通常会以一种使用线程允许同一程序的不同部分在不同内核上运行的方式来分解程序。而且你知道，如果可以，也许你很幸运，如果你能把你的程序拆分成在四个线程上运行，在四个内核上，你可能能够获得四倍的速度和它的运行速度。实际上，您可以将XV 6内核视为多核并行程序。</p>
<p>发言人   02:12<br>So what threads are is an abstraction to simplify programming when you have many tasks, when you want to juggle many tasks. So what a thread is as you can think of a thread as just being a single serial execution, if you just write a program that does one thing after another and you run that program that you know, you can view the program as a sort of single thread of control. And this is a loose definition. Because there’s many different sort of flavors of what people mean by threads. But we’ll say it’s one serial execution. So it’s what you get if you fire up 1 CPU and have it execute one instruction after another in the ordinary way.<br>所以线程是当你有很多任务时简化编程的抽象，当你想要处理很多任务时。所以什么是线程，你可以把线程看作只是一个单独的串行执行，如果你只是写一个接一个做一件事的程序，然后运行那个你知道的程序，你可以把这个程序看作是一种单独的控制线程。这是一个松散的定义。因为人们所说的线索有许多不同的含义。但我们会说这是一次串行执行。所以如果你启动1个CPU并让它以普通方式执行一个接一个的指令，这就是你得到的。</p>
<p>发言人   03:05<br>We often talk about a thread having state because it’s going to turn out we’re going to want to save away a thread state and restore it later. And so the right way to think about a threat state, for the most part, the most important part perhaps of the thread state is its program counter. Because it’s an execution we care a lot about where is it in its execution and what address is it executing instructions. But also we care about the rest of the microprocessor state that’s required to support this execution. And so that means it.<br>我们经常谈论一个线程具有状态，因为结果是我们想要保存一个线程状态并在以后恢复它。因此，正确思考威胁状态的方法，在大多数情况下，线程状态最重要的部分可能是它的程序计数器。因为这是一个执行，我们非常关心它在执行中的位置以及它执行指令的地址。但我们也关心支持此执行所需的微处理器状态的其余部分。这意味着它。</p>
<p>发言人   03:38<br>The state of a threat includes the registers that the compiler uses to hold variables. It also, because just the way the compiler generates a code, a thread state includes a stack. So typically, each thread has its own stack dedicated to executing that thread. And the stack records the record of function calls. That reflect the current point in the execution of that thread. And so what?<br>威胁的状态包括编译器用来保存变量的寄存器。它也是因为编译器生成代码的方式，线程状态包括一个堆栈。通常，每个线程都有自己的堆栈，专用于执行该线程。堆栈记录了函数调用的记录。这反映了该线程执行中的当前点。那又怎样？</p>
<p>发言人   04:06<br>A threading system. The XV 6 includes a threading system inside it. What a threading system does is manage it, interleave M, the interleaving of multiple threads. We’d like to be able to fire up two or 4, 100 or 1000 threads and have the threading system figure out how to juggle all those threads and cause them all to make progress in all the x cube. And there’s really two main strategies. So we want to interleave.<br>线程系统。XV 6内部包括一个线程系统。一个线程系统所做的是管理它，交错M，多线程的交错。我们希望能够启动两个或4个，100个或1000个线程，并让线程系统弄清楚如何处理所有这些线程，并使它们在所有x立方体中取得进展。实际上有两种主要策略。所以我们想要交错。</p>
<p>发言人   04:39<br>This is going to be big topic here is how to interleave threads.<br>这将是一个大话题，这里是如何交错线程。</p>
<p>发言人   04:45<br>Many threads, One way to interleave execution of many threads is to have multiple Cpu’s, Maybe as on a multi-core processor? And then each CPU can run its own thread. So if you have 4 Cpu’s there, an obvious way to run, sorry, 4 threads is to run one thread per CPU, and then each thread automatically gets its own program counter and registers that is the program counter and registers associated with the CPU is running on. But if you have 4 Cpu’s and you have 1000 threads, then. You know, using one corporate thread is not going to be enough of an answer.<br>多线程，交错执行多个线程的一种方法是拥有多个Cpu，也许就像在一个多核处理器上一样？然后每个CPU可以运行自己的线程。所以如果你有4个Cpu，一个明显的运行方法，抱歉，4个线程是每个CPU运行一个线程，然后每个线程自动获取自己的程序计数器和寄存器，即与CPU运行相关的程序计数器和寄存器。但如果你有4个Cpu，有1000个线程，那么。你知道，使用一个企业线程是不够的。</p>
<p>发言人   05:26<br>And so the other main strategy that we’ll see, indeed, the topic of most of this lecture, is how each CPU is going to switch among different threads. So if I have 1 CPU and 1000 threads, we’re going to see how XV 6 builds a switching system that allows XV 6 to run 1 thread for a while and then switch, then set aside and save the state of that one thread and switch to executing a second thread for a while, and then the third thread, and so forth. And TS executed a little bit of each thread and then go back and execute more of the first thread and so on. And indeed, with XV six, like most operating system combines, the SV 6 will run threads on all the cores that are available. And each core will switch among threads because there’s typical, typically, although not always, there’s typically many more threats than there are Cpus.<br>因此，我们将看到的另一个主要策略，事实上，这个讲座的大部分主题，是每个CPU如何在不同的线程之间切换。所以，如果我有1个CPU和1000个线程，我们将看到XV 6如何构建一个切换系统，允许XV 6运行1个线程一段时间，然后切换，然后留出并保存那个线程的状态，并切换到执行第二个线程一段时间。然后是第三个线程，以此类推。和TS执行了每个线程的一小部分，然后返回并执行第一个线程的更多内容，依此类推。事实上，使用XV 6，就像大多数操作系统的组合一样，SV 6将在所有可用的内核上运行线程。并且每个核心都会在线程之间切换，因为通常情况下，虽然并不总是，但通常比CPU有更多的威胁。</p>
<p>发言人   06:25<br>One of the many ways in which different threading systems or instances of threading systems differ is in whether or not they shared memory, so this is a pertin. Point one possibility is that you could have a single address space with many threads executing in that address space, and then they see each other’s changes. If one of the threads sharing some memory modifies a variable, then the other thread sharing that memory will see the modification. And so it’s in the context of threads running and sharing memory that we need things like the locks you saw in the last lecture.<br>不同线程系统或线程系统实例的不同之处之一是它们是否共享内存，这是一个问题。第一种可能性是您可能有一个地址空间，其中有许多线程在该地址空间中执行，然后它们会看到彼此的变化。如果共享某些内存的其中一个线程修改了变量，则共享该内存的另一个线程将看到此修改。因此，在线程运行和共享内存的背景下，我们需要像你在上一节课中看到的锁这样的东西。</p>
<p>发言人   07:10<br>XV 6 kernel is shared memory. So XV 6 a XV 6 has supports the notion of kernel thread. There’s 1 kernel thread per process that executes system calls for that process. All those kernel threads share kernel memory, so XV 6 kernel threads do share memory. And on the other hand Xb 6 has another kind of threads. Each user process essentially has a single thread of control that executes the user instructions for that process. And indeed, a lot of the XV 6 kernel threading machinery is ultimately in support of being able to support and switch among many user processes. Each user process has a memory and a single thread that runs in that memory. So XV 6 user processes.<br>XV 6内核是共享内存。所以XV 6支持内核线程的概念。每个进程有1个内核线程，用于执行该进程的系统调用。所有这些内核线程共享内核内存，因此XV 6内核线程共享内存。另一方面，Xb 6有另一种线程。每个用户进程基本上都有一个控制线程，用于执行该进程的用户指令。实际上，许多XV 6内核线程机制最终是为了支持在许多用户进程之间支持和切换。每个用户进程都有一个内存和一个在该内存中运行的单个线程。所以XV 6个用户进程。</p>
<p>发言人   08:11<br>Each process has one thread, and so there’s no sharing a memory among threads within a single x 6 user process. Of course, you can have multiple processes, but each of those processes is in a dress space with a single thread. The processes in XP 6 don’t share memory in other more sophisticated operating systems, for example Linux. Linux at user level does allow multiple threads in the process and the processes, and those threads share the memory of that single process. And that’s super cool if you want to write user level programs that not use level parallel programs that get speed up from multiple cores, but requires sort of another uses a lot of the same basic techniques we’re going to talk about today. But there’s a certain amount more sophistication in Linux to get it to keep track of multiple threads per process instead of just one.<br>每个进程都有一个线程，因此单个x 6用户进程内的线程之间不会共享内存。当然，你可以有多个进程，但每个进程都在一个带有单个线程的着装空间中。XP 6中的进程在其他更复杂的操作系统 (例如Linux) 中不共享内存。Linux在用户级别上允许进程中有多个线程，这些线程共享该单个进程的内存。如果你想编写用户级程序，而这些程序不使用从多核加速的并行程序，而是需要另一种使用我们今天要讨论的许多相同基本技术的程序，那就太棒了。但是Linux中还有一些更复杂的功能，可以让它跟踪每个进程的多个线程而不是一个线程。</p>
<p>发言人   09:12<br>Okay, at a sort of high level, I just want to mention that there’s other ways to support the interleaving of multiple tasks on a single computer. And we’re not going to talk about them. But if you’re curious, you can look at things like event driven programming or state machines. And these are non thread techniques to share one computer among many different tasks. It turns out sort of on the spectrum of different schemes for supporting multiple tasks on a computer, threads are not very efficient. Those are the more efficient schemes, but threads are usually the most convenient way, the most programmer friendly way to support lots of different tasks. There’s a couple of challenges that we’re going to have to bite off if we want to implement a threading system. So this is just high level challenges.<br>好的，在某种高层次上，我只是想提一下，还有其他方法可以支持在一台计算机上交错处理多个任务。我们不打算谈论它们。但如果你很好奇，你可以看看事件驱动编程或状态机之类的东西。这些是非线程技术，用于在许多不同的任务之间共享一台计算机。事实证明，在支持计算机多任务的不同方案中，线程的效率并不高。这些是更有效的方案，但线程通常是最方便的方式，最程序员友好的方式来支持许多不同的任务。如果我们想要实现一个线程系统，我们将不得不克服一些挑战。所以这只是高层次的挑战。</p>
<p>发言人   10:22<br>One is, as I mentioned before, how to actually implement the switching for interleaf switching that allows us to interleave. The execution of multiple threads. Sort of broad name for this process of switching, deciding, oh I’m going to leave off one thread and start X in another thread. It’s often called scheduling. And we’ll see that XV 6 and D has the actual piece of code. That’s the scheduler D that has multiple schedulers, 1 per core. But the general idea of how do you drive the decision to switch from one to another, how to pick the next thread to run, it’s called scheduling.<br>正如我之前提到的，一个是如何实际实现交错切换，使我们能够交错。多个线程的执行。这种切换、决定过程的广义名称，哦，我要离开一个线程，在另一个线程中启动X。这通常被称为调度。然后我们会看到XV 6和D有实际的代码。这是具有多个调度程序的调度程序D，每个核心一个。但是，如何做出从一个线程切换到另一个线程的决定，如何选择下一个线程运行的一般想法，这被称为调度。</p>
<p>发言人   11:11<br>Another question is, if you want to actually implement the switch from 1 thread to another, you need to save and restore. So we need to decide what needs to be saved and where to save it when, what needs to be saved when we leave off executing one thread and restored when we want to resume executing that thread at some later time.<br>另一个问题是，如果你想实际实现从一个线程到另一个线程的切换，你需要保存和恢复。所以我们需要决定需要保存什么以及何时保存在哪里，当我们停止执行一个线程时需要保存什么，当我们想要在以后恢复执行该线程时需要恢复什么。</p>
<p>发言人   11:31<br>And final question is to what to do about compute bound threads. Many of the options, many of the most straightforward options for thread switching involve the thread sort of voluntarily saying, well I’m going to save away my state and sort of run another, you know, let another thread be run, but whatever. We have a user program that’s doing some long running calculation that might take hours. It’s not going to be particularly thinking about now. It would be good time to let something else run. So it’s most convenient to have some way of just sort of automatically revoke control from some long running compute bound process, setting it aside, and maybe running it later. All right, so I’m going to talk about these.<br>最后一个问题是如何处理计算绑定线程。许多选项，许多最直接的线程切换选项涉及线程自愿说，我要保存我的状态并运行另一个，你知道，让另一个线程运行，但不管怎样。我们有一个用户程序正在进行一些可能需要数小时的长时间运行的计算。现在不会特别考虑这个问题。现在是让其他东西运行的好时机。因此，最方便的方法是自动撤销对某个长时间运行的计算绑定进程的控制，将其放在一边，也许稍后再运行它。好的，那么我要谈谈这些。</p>
<p>发言人   12:19<br>I’m actually going to talk about the machinery for dealing with compute bound threads first. And the scheme for that is something you’ve come up before, and that’s timer interrupts. And the idea here is that there’s a little piece of hardware on each CPU, on each core, that generates periodic interrupts. And the XV 6, or any operating system really ranges to have those interrupts delivered to the kernel, even if we’re running at user level in some loop that’s, you know, computing the first billion digits of pi, nevertheless, the timer interrupts is going to go off at some point, maybe every 10 milliseconds, and transfer control from that user level code into the interrupt handler in the kernel. And so that’s the sort of first step in the kernel being able to gain control to switch among different user level processes of user level threads, even if those user level threads aren’t cooperative.<br>我实际上要先讨论处理计算绑定线程的机制。这个方案是你以前想出的东西，那就是计时器中断。这里的想法是，每个CPU、每个核心上都有一小块硬件，会生成周期性中断。而XV 6，或任何操作系统实际上都可以将这些中断传递到内核，即使我们在某个循环中运行在用户级别，即计算pi的前十亿位，尽管如此，计时器中断仍将在某个时刻停止，可能每10毫秒，将控制权从用户级代码转移到内核中的中断处理程序。因此，这是内核能够获得控制权以在用户级别线程的不同用户级别进程之间切换的第一步，即使这些用户级别线程不合作。</p>
<p>发言人   13:29<br>And the basic scheme is that in the interrupt handler, so we can have a kernel handler for these interrupts. And we’ll see that the kernel handler yields. This is the sort of name for this It yields. The kernel handler sort of voluntarily yields the CPU back to the scheduler and tells the scheduler, look, you can let something else run now. And this yielding is really a form of thread switch that saves away the state of the current thread and so can be restored leader.<br>基本方案是在中断处理程序中，因此我们可以为这些中断提供内核处理程序。我们将看到内核处理程序会产生。这就是它所产生的名称。内核处理程序自愿地将CPU返回给调度程序，并告诉调度程序，看，你现在可以让其他东西运行。这种让步实际上是一种线程切换的形式，它可以保存当前线程的状态，因此可以恢复领导者。</p>
<p>发言人   14:10<br>As we’ll see the full story here, actually, you’ve seen a lot of the full story here because it involves an interrupt, which you already know about the full story, somewhat complex. But the basic idea is that a timer interrupt gives control to the kernel, and the kernel voluntarily yields the CPU. This is called, as a piece of terminology, preemptive scheduling.<br>因为我们将在这里看到完整的故事，实际上，你已经在这里看到了很多完整的故事，因为它涉及一个中断，你已经知道完整的故事，有点复杂。但基本的想法是定时器中断将控制权交给内核，内核自愿产生CPU。这被称为，作为一个术语，先发制人的调度。</p>
<p>发言人   14:39<br>And what that means is what the preemptive means is that even if the code that’s running doesn’t, doesn’t want to, you know, doesn’t explicitly yield the CPU, the timer interrupt is going to take control away. And we’re going to yield for it. And the opposite of preemptive scheduling might be called maybe voluntary scheduling. And the interesting thing is that the implementation in XV 6 and other operating systems of preemptive scheduling is this timer interrupt, interrupt, which forcibly takes away the CPU. And then the kernel basically does a voluntary yield or thread switch on behalf of that process.<br>这意味着先发制人意味着，即使正在运行的代码不希望，你知道，没有明确放弃CPU，计时器中断也会夺走控制权。我们将为此屈服。抢先式调度的相反部分可能被称为自愿调度。有趣的是，在xv6和其他操作系统中，抢占式调度的实现是这种定时器中断，中断，它强制拿走了CPU。然后内核基本上代表该进程进行自愿的yield或线程切换。</p>
<p>发言人   15:24<br>Now, another just piece of terminology that comes up here is that while the thread’s running, we need distinguish, the system needs to distinguish between threads that are currently actually running on some CPU versus threads that would like to run, but aren’t currently running on any CPU, but, you know, could run if a CPU became free versus threads that actually don’t want to run because they’re waiting for IO or waiting for some event. And unfortunately, this distinction is often called state, even though the full state of a threat is actually much more complicated than that.<br>现在，这里出现的另一个术语是，当线程正在运行时，我们需要区分，系统需要区分当前实际在某些CPU上运行的线程与想要运行但当前未在任何CPU上运行的线程，但是，你知道，如果CPU变得免费，则可以运行，而线程实际上不想运行，因为它们正在等待IO或等待某些事件。不幸的是，这种区别通常被称为状态，即使威胁的完整状态实际上比那复杂得多。</p>
<p>发言人   16:10<br>Since this is going to come up, I just want to list out a couple of states that we’ll be seeing. And these are states that XV 6 actually maintains. There’s a state called running, which means, it’s actually executing on core on some CPU right now, there’s runnable. Which means not currently executing anywhere, just a saved state, but would like to run as soon as possible? And then it turns out there’s a state which won’t come out much today, but won’t come up next week called sleeping, which is means the threads waiting for some IO event and only wants to run after the IO event occurs. So today we’re mostly concerned with running and runable threads and what this preemptive switch does, what this timer interrupt does. And the yield is basically convert a running thread, whatever thread was interrupted by the timer into a runnable thread that is a thread that’s by yielding you’re in that thread into a thread that’s not running right now would actually like to clearly, because it was running at the time of the timer, interrupt Upt.<br>由于这个问题即将出现，我只想列出几个我们将会看到的州。这些是XV 6实际维护的状态。有一个叫做running的状态，这意味着它现在实际上在某个CPU的核心上执行，可以运行。这意味着当前没有在任何地方执行，只是保存状态，但想尽快运行？然后发现有一个状态今天不会出现很多，但下周不会出现，称为睡眠，这意味着线程等待一些IO事件，只希望在IO事件发生后运行。所以今天我们主要关心运行和可运行的线程，以及这个抢占式开关做什么，这个计时器中断做什么。并且yield基本上是将正在运行的线程转换为可运行的线程，无论哪个线程被计时器中断，都可以通过将该线程中的线程转换为当前未运行的线程来实现，因为它在计时器运行时正在运行，打断Upt。</p>
<p>发言人   17:14<br>Okay, so running thread, it’s program counter and registers are actually in the CPU, in the hardware registers of the CPU that’s executing it. A runable thread though, has no, doesn’t have a CPU associated with it. And therefore, we need to say for every runable state, we need to save whatever CPU state, whatever state the CPU was keeping when that thread was running. So we need to copy the CPU contents, which is not Ram, but just registers really from the CPU into memory somewhere to save them when we turn a thread from running to runnable. And again, basically the state we have to explicitly say here is just the state, the executing state, and the CPU, which is the program counter and the registers in the CPU. So these need to be saved when we convert a thread to Runnable, when some scheduler finally decides to run a runnable thread, then as part of the many steps and getting that thread going again and resuming it, we’re going to see that the program count, the saved program counter registers are copied back into the Cpu’s actual register on the CPU that the scheduler decides to run it on. All right, any questions about these terminology?<br>好的，所以运行线程，它的程序计数器和寄存器实际上在CPU中，在执行它的CPU的硬件寄存器中。但是，一个可运行的线程没有关联的CPU。因此，我们需要说对于每个可运行的状态，我们需要保存任何CPU状态，当该线程运行时CPU保持的任何状态。所以我们需要复制CPU内容，这不是Ram，而只是从CPU真正注册到内存中的某个地方，以便在我们将线程从运行转为可运行时保存它们。而且，基本上我们在这里必须明确说明的状态只是状态，执行状态和CPU，即程序计数器和CPU中的寄存器。因此，当我们将线程转换为可运行线程时，需要保存这些线程，当某个调度程序最终决定运行可运行线程时，作为许多步骤的一部分，让该线程再次运行并恢复它，我们将看到程序计数。保存的程序计数器寄存器被复制回调度程序决定运行它的Cpu上的实际寄存器。好的，对这些术语有什么问题吗？</p>
<p>发言人   18:49<br>All right I’m going to now sort of talk about a sort of more XV 6 oriented view of things. I’m going to draw two pictures really of threads in X 6, a kind of simplified picture and a more detailed picture. So as usual of the user stuff up here and the kernel down here. We might be running multiple processes at user level, maybe the C compiler and the LS and the shell. They may or may not be all wanting to run at the same time at user level each of these processes.<br>好的，我现在要谈谈一种更面向XV 6的事物视图。我打算在x6中绘制两张真正的线程图片，一种是简化图片，一种是更详细的图片。像往常一样，用户的东西在这里，内核在这里。我们可能在用户级别运行多个进程，可能是C编译器、LS和shell。他们可能希望也可能不希望在用户级别同时运行这些进程中的每一个。</p>
<p>发言人   19:38<br>It has memory. And of particular interest to us, each of these processes has a user stack. And while it’s running, it has registers in the risk 5 hardware, so PC plus registers, right? While the program is running, it’s essentially a thread of control that’s running up at user level. And the way I’m going to talk about it is as if there’s a user thread that consists of the user stack, user memory, user program counter user registers.<br>它有记忆。我们特别感兴趣的是，每个进程都有一个用户堆栈。并且在运行时，它在风险5硬件中具有寄存器，因此PC加寄存器，对吗？当程序正在运行时，它本质上是一个在用户级别运行的控制线程。我要谈论的方式是，就好像有一个用户线程，由用户堆栈、用户内存、用户程序计数器、用户寄存器组成。</p>
<p>发言人   20:13<br>If the program makes a system caller is interrupted and has goes into the kernel, then this stuff saved away. In this program’s trap frame, a kernel, the kernel thread for this program is activated. So this is the trap frame holds saved user stuff. After we saved the way the user program counter registers, then we switch the CPE to using the kernel stack. And we don’t need to restore registers because the kernel thread for a process isn’t really running and has no real safe state when the user thread is running. Instead, it’s sort of the kernel thread is kind of activated on its stack the first time in the trampoline user trap code. And then the kernel runs for a while.<br>如果程序使系统调用程序中断并进入内核，那么这些东西就被保存了。在这个程序的陷阱帧中，一个内核，这个程序的内核线程被激活。所以这是陷阱框架保存了用户的东西。在我们保存了用户程序计数器寄存器的方式之后，我们将CPE切换到使用内核堆栈。而且我们不需要恢复寄存器，因为进程的内核线程并没有真正运行，并且在用户线程运行时也没有真正的安全状态。相反，它有点像内核线程，在蹦床用户陷阱代码中第一次在堆栈上被激活。然后内核运行一段时间。</p>
<p>发言人   21:13<br>Maybe you running a system call or an interrupt handler or whatever it may. And sometimes if it’s a system call in particular, we’ll just simply return from this point back to the same process. The return to user space will restore this program’s program counter registers. But it could also be that instead of simply returning for one reason or another, maybe because it was a timer interrupt, we’re actually going to switch to another process And a very high level view of that is that if the Xb 6 scheduler decides to switch from this process to a different process, the first thing that really happens is that we’re going to switch kernel threads from this process is kernel thread to the other processes, kernel thread, and then the other processes, kernel code will turn back to user space.<br>也许你正在运行系统调用或中断处理程序或任何其他程序。有时候，如果它是一个系统调用，我们只是从这一点返回到同一个进程。返回用户空间将恢复此程序的程序计数器寄存器。但也可能是因为我们实际上要切换到另一个进程，而不是简单地出于某种原因返回，可能是因为这是计时器中断，我们实际上要切换到另一个进程，对此的一个非常高层次的看法是，如果Xb 6调度程序决定从这个进程切换到另一个进程，真正发生的第一件事是我们将内核线程从此进程的内核线程切换到其他进程的内核线程，然后其他进程的内核代码将返回用户空间。</p>
<p>发言人   22:01<br>So supposing that the C compiler say needs to read the disk, and so it’s going to yield the CPU while it’s sleeping to wait for the disk read to complete, maybe ALS wants to execute and is in runnable state. What the XV 6 scheduler maybe may do is that, well, if LS is in runnable state, that means it left off somewhere and its state was saved away, possibly by a timer interrupt, and so the LS will actually have a saved track frame with user registers and its own kernel stack, and as it turns out a seed set of. Kernel registers associated with the kernel thread, which is going to be called the context. So if XV six switches from the compiler kernel thread to Lscs, kernel thread XV 6 will save away the kernel registers in a context for the see, the compiler’s kernel thread switch to the LS thread complex scheme, which I’ll describe a little bit later, We restore els’s kernel thread registers from the previously saved context from when LS last left off. Maybe LS will finish whatever system call it was executing, you know, on the lsss kernel thread stack, and then return back to LS when the system call it on the way to returning the user space that’ll restore these previously saved user registers for LS and then resume executing LS. There’s a bunch of details here, which we’ll talk about, but maybe the main point here is that we never in XV 6 see direct user to user context switches when we’re switching from 1 process to another, always the sort of strategy by which ex switches from executing one process to another process is you jump into the kernel, save the process state, run this processes kernel thread, switch to the kernel thread of it, another process that suspended itself, and then return and restore user register. So it’s always the sort of indirect strategy actually even more indirect than this to threat switch where the net effect is to switch from one user process to another user references.<br>因此，假设C编译器说需要读取磁盘，因此它将在睡眠时产生CPU以等待磁盘读取完成，可能ALS想要执行并处于可运行状态。XV 6调度器可能会做的是，如果LS处于可运行状态，这意味着它在某个地方中断并且其状态被保存，可能是由计时器中断，因此LS实际上将有一个保存的跟踪帧，带有用户寄存器和自己的内核堆栈，结果变成了一套种子。与内核线程相关联的内核寄存器，将被称为上下文。因此，如果XV 6从编译器内核线程切换到Lscs，内核线程XV 6将在上下文中保存内核寄存器，以便查看，编译器的内核线程切换到LS线程复杂方案，稍后我会稍微描述一下，我们从LS上次中断的时间开始，从先前保存的上下文中恢复els的内核线程寄存器。也许LS将完成它正在执行的任何系统调用，你知道，在lsss内核线程堆栈上，然后在系统调用它时返回到LS，以返回用户空间，这将恢复这些先前保存的LS的用户寄存器，然后继续执行LS。这里有很多细节，我们将会讨论，但也许这里的主要观点是，当我们从一个进程切换到另一个进程时，我们从来没有在XV 6中看到直接的用户到用户的上下文切换。执行一个进程到另一个进程的策略通常是: 跳入内核，保存进程状态，运行这个进程的内核线程，切换到它的内核线程，另一个暂停自己的进程，然后返回并恢复用户注册表。因此，威胁切换总是一种间接策略，实际上比这更加间接，其最终效果是从一个用户进程切换到另一个用户引用。</p>
<p>发言人   24:23<br>Questions about this diagram or anything? The switch to the scheduler that happens in between those two, right? Yep, all right, let me talk about the scheduler. So the real picture is actually significantly more complex than that.<br>有关于这个图表或其他东西的问题？在这两者之间发生的调度器切换，对吧？是的，好吧，让我谈谈调度器。所以真实的情况实际上比这复杂得多。</p>
<p>发言人   24:42<br>This is a more. Going to be a more full diagram. Let’s say we have process one, which is executing, and process 2, which is runnable, but not currently running. Now, the additional layer of details, we actually have multiple cores in XP 6. Let’s say we have 2 cores. So that means that sort of at the hardware level, we have CPU 0, which is one of the cores, and let’s say CPU 1. And the more full story about how we get from executing user space to in one process, to executing a user spaces in another runnable, but not yet running process.<br>这是一个更多。将会是一个更完整的图表。假设我们有一个正在执行的进程1和进程2，该进程可运行，但当前未运行。现在，在额外的细节层，我们实际上在XP 6中有多个内核。假设我们有两个核心。这意味着在硬件层面上，我们有CPU 0，这是其中一个核心，让我们说CPU 1。还有更完整的故事，关于我们如何从执行用户空间到在一个进程中，再到在另一个可运行但尚未运行的进程中执行用户空间。</p>
<p>发言人   25:34<br>The first part is about the same as I talked about. They say a timer interrupt forces transfer control from the user process into the kernel. Trampoline code saves the user registers in the trap frame for process 1 and then executes user trap, which figures out what to do with this trap or interrupt you system call, Let’s say it. So for a little while, we’re executing ordinary kernel C code on the kernel stack of process 1.<br>第一部分与我谈论的大致相同。他们说一个计时器中断强制将控制权从用户进程转移到内核。蹦床代码将用户注册保存在进程1的陷阱帧中，然后执行用户陷阱，这将决定如何处理这个陷阱或中断您的系统调用，比如说。所以有一段时间，我们在进程1的内核堆栈上执行普通的内核C代码。</p>
<p>发言人   26:10<br>Let’s say process one, the kernel code for process wants to decides. It wants to yield the CPU. It does a bunch of things, which we’ll see the details of that end up in a call to this routine switch, just sort of the one of the central routines in this story. Switch saves away this context. The registers for the kernel thread that’s running in context one. So there’s two sets of registers. The user registers the trap frame, the kernel thread registers in the context.<br>假设进程一，进程的内核代码想要决定。它想要产生CPU。它做了很多事情，我们将在调用这个例程开关中看到最终的细节，这只是这个故事中的中心例程之一。Switch保存此上下文。在上下文1中运行的内核线程的寄存器。所以有两组寄存器。用户注册陷阱帧，内核线程在上下文中注册。</p>
<p>发言人   26:42<br>Switch doesn’t actually switch switches from content from 1 thread to another, but in fact, the way Xd 6 is designed, the only place that a user thread, sorry, the kernel thread running on a CPU can switch to is what’s called the scheduler thread for that CPU. So we can’t even switch directly to another process. We can only switch to the scheduler thread. So there’s a the complete thread apparatus dedicated to the scheduler for CPU 0. Since we’re running on CPU, is this switch is going to switch to the previously saved registers for the scheduler thread? So let’s say it’s scheduler 0. And in the scheduler for CPU 0 switch will by restoring these registers, since the registers include the stack pointer, the return from switch, as we’ll see, well now actually return up to the scheduler function.<br>Switch实际上并不会将内容从一个线程切换到另一个线程，但实际上，Xd 6的设计方式是，用户线程 (抱歉，在CPU上运行的内核线程) 唯一可以切换到的地方就是所谓的调度器线程。所以我们甚至不能直接切换到另一个进程。我们只能切换到调度程序线程。所以有一个完整的线程装置专用于CPU 0的调度程序。由于我们正在CPU上运行，此开关是否会切换到先前保存的调度程序线程的寄存器？那么让我们假设它是调度器0。而在CPU 0交换机的调度器中，由于寄存器包括堆栈指针，因此将通过恢复这些寄存器来从交换机返回，正如我们所看到的，现在实际上返回到调度器函数。</p>
<p>发言人   27:52<br>On CPU 0 and the scheduler function, we’ll do some cleanup to finish putting process one to sleep. It’ll look in the process table for another process to run a runable process. And if it finds one, so we’ve sort of gone down here and up into the scheduler.<br>在CPU 0和调度程序函数上，我们将进行一些清理以完成将进程1置于睡眠状态。它将在工艺表中查找另一个要运行可运行进程的进程。如果找到一个，那么我们就会在这里和上面进入调度程序。</p>
<p>发言人   28:10<br>If the scheduler finds another process to run, or even finds process 1 is runable and still wants to run, I may find process 1, nothing else. Nothing else wants to run. But in any case, the scheduler will call switch again to switch contexts to say process 2, in the process of which it’ll save its own registers. Again, in its own context. There’ll be a previously saved context to from whenever process 2 left off, the set of registers will be restored.<br>如果调度程序找到另一个要运行的进程，或者甚至发现进程1可以运行但仍想运行，我可能会找到进程1，没有其他任何东西。没有其他人想要奔跑。但在任何情况下，调度器都将再次调用switch来切换上下文，例如进程2，在此过程中它将保存自己的寄存器。再次，在自己的背景下。每当进程2停止时，将会有一个以前保存的上下文，寄存器集将被恢复。</p>
<p>发言人   28:42<br>Process 2 will have made a previous call to switch. To switch to the scheduler thread, just like process 1 did when it left off, that called a social return to whatever system call or interrupt process 2 was in. When that’s finished, there will be a previously saved trap frame for process 2 that’ll continue user registers. Those will be restored and will return back up into user space. And there’s a complete, a separate scheduler thread for each CPU, So it’ll also be saved.<br>进程2将已经进行了先前的调用来切换。切换到调度程序线程，就像进程1在停止时所做的那样，这调用了对任何系统调用或中断进程2的社交返回。完成后，进程2将有一个先前保存的陷阱帧，它将继续用户注册。这些将被恢复并返回到用户空间。每个CPU都有一个完整的、单独的调度程序线程，因此它也将被保存。</p>
<p>发言人   29:20<br>Context for the scheduler thread for CPU 1 and scheduler loop. Running on scheduler one and whatever process, you know, process 3 or something is running on CPU 1, when it decides to give up the CPU, it’ll switch into the scheduler thread for it for its CPU.<br>CPU 1和调度器循环的调度器线程的上下文。在调度器一和任何进程上运行，你知道，进程3或某些东西在CPU 1上运行，当它决定放弃CPU时，它将切换到它的CPU的调度器线程。</p>
<p>发言人   29:43<br>All right, there’s a question. Where are the context stored? It turns out that for the operations I’ve been talking about, the saved, in fact, always the for a thread switch, these contexts, these saved register sets for kernel threads are in the process structure. So any given kernel thread can only have one set of saved kernel registers because each thread is only executing at sort of a single place in its context, kind of reflects that place that it was executing when it left off.<br>好的，有一个问题。上下文存储在哪里？事实证明，对于我一直在谈论的操作，实际上总是保存的线程切换，这些上下文，这些保存的内核线程的注册集在进程结构中。因此，任何给定的内核线程只能有一组保存的内核寄存器，因为每个线程只在其上下文中某种程度上执行，这反映了它停止时正在执行的位置。</p>
<p>发言人   30:21<br>A thread is a single thread of control. So a thread, I really only needs one context full of registers. So it’s in the process structure, it’s prorogue. P context and the Scheduler Each scheduler thread has its own context, which is actually not in the there’s no process associated with this scheduler thread. So there’s actually the scheduler is contacts is stored in the struct CPU for that core. There’s an array of these CPU structs, 1 per core, each one has a context.<br>线程是单个控制线程。所以一个线程，我只需要一个充满寄存器的上下文。所以它在流程结构中，是按进度安排的。P上下文和调度程序每个调度程序线程都有自己的上下文，实际上并不在与此调度程序线程关联的进程中。因此，实际上有一个调度器，联系人存储在该核心的结构CPU中。有一个这些CPU结构的数组，每个核心一个，每个都有一个上下文。</p>
<p>发言人   30:58<br>Question, why can’t we include the registers in the trap frame for the process That is, you know, actually the those registers could be stored in the trap frame, which is made, you know, because there’s only one saved set of kernel thread registers per process, we could save them in any data structure for which there’s one element instance of that data structure per process. Now there’s one per process, there’s one trap frame per process. We could store the registers in the trap frame. But I mean, just sort of for maybe simplicity or clarity of code, the trap frame, I think, entirely consists of data that’s needed when entering and leaving the kernel. And struct context is consists of the stuff that needs to be saved and restored when switching to and from between the kernel thread and the scheduler thread.<br>问题是，为什么我们不能将寄存器包含在进程的陷阱框架中，也就是说，你知道，实际上这些寄存器可以存储在陷阱框架中，这是因为每个进程只有一个已保存的内核线程寄存器集，我们可以将它们保存在任何数据结构中，每个进程只有一个该数据结构的元素实例。现在每个进程都有一个陷阱帧，每个进程都有一个陷阱帧。我们可以将寄存器存储在陷阱帧中。但我的意思是，也许为了代码的简单性或清晰度，陷阱框架完全由进入和离开内核时所需的数据组成。和结构上下文由在内核线程和调度器线程之间切换时需要保存和恢复的内容组成。</p>
<p>发言人   31:54<br>Okay, question is yield something that’s called by the user or the kernel? It’s called by the kernel threads. There’s not really a direct way in XV 6 for user threads to talk about yielding the CPU or switching. It’s done by the kernel kind of transparently, you know, at points in time when the kernel feels that it needs to happen, there are threads.<br>好的，问题是产生用户调用的东西还是内核调用的东西？它由内核线程调用。在XV 6中并没有一个真正直接的方式让用户线程谈论放弃CPU或切换。它是由内核透明地完成的，你知道，在内核认为需要发生的时候，有线程。</p>
<p>发言人   32:18<br>There’s some times when you can sort of guess that probably a certain system call will result in a yield if a process does a read on a pipe where it knows that really nothing is waiting to be read on that pipe and the read will block, you can predict that the read will block and that the kernel will run some other process while we’re waiting for data to appear on the pipe. And so the times when yield is called in the kernel, there’s really two main times. One is if a timer interrupt goes off, the kernel always yields just on the theory that we should interleave the execution of all the process that want to run on timer interrupt periods. So time runner also always calls yield. And whenever a process, a system calls waiting for IO, like waiting for you to type the next keystroke, you know, does a read of the console and you haven’t typed a key yet, then the machinery to wait for IO calls yield is called from sleep, something we’ll talk about next week.<br>有时候，你可以猜测，如果一个进程在管道上进行读取，可能某个系统调用会导致yield，它知道在该管道上实际上没有什么等待被读取，并且读取将会阻塞。你可以预测读取将会阻塞，在等待数据出现在管道中时内核将运行其他进程。因此，在内核中调用yield的时间实际上有两个主要时间。一种是，如果计时器中断停止，内核总是基于这样的理论: 我们应该交错执行所有想要在计时器中断期间运行的进程。所以时间跑者也总是称之为屈服。每当一个进程，系统调用等待IO，就像等待你输入下一次击键一样，你知道，读取控制台，但你还没有输入键，那么等待IO调用的机器就会从睡眠中调用yield，下周我们将谈论一些事情。</p>
<p>发言人   33:29<br>All right? Okay, so can ask another question. Yes, if it is asleep, is it going to do the same thing roughly? So it’s going to be some system call and then is going to save the trial frame and then basically the same picture. But it’s just that the thing that made the process go into the kernel was not a timer interrupt, but the process, his own decision. Yeah, so if the process make, there’s a read system call and that’s why it’s in the kernel. And the read requires the process to wait for the disk to finish reading or to wait for data to appear in a pipe, then actually the diagram is exactly the same as this And with the kernel, with a system call the trap frame or the save user register will execute the system call. The system call will be, I need to wait for the disk to finish reading something, the system called code we’ll call sleep, which ends up calling switch, which saves away the kernel thread registers in the processes context and switches to this current CPU schedule to let some other thread run while this thread is waiting for the discrete to finish.<br>一切都好吗？好的，那么可以再问一个问题。是的，如果它睡着了，它会大致做同样的事情吗？所以这将是一些系统调用，然后将保存试镜架，然后基本上是相同的图片。但只是让进程进入内核的不是计时器中断，而是进程自己的决定。是的，所以如果进程做了，有一个读系统调用，这就是它在内核中的原因。而读取需要进程等待磁盘完成读取或等待数据出现在管道中，那么实际上图表与内核完全相同，使用系统调用陷阱帧或保存用户寄存器将执行系统调用。系统调用将是，我需要等待磁盘完成读取某些内容，系统调用代码，我们将调用sleep，最终调用switch，这会保存进程上下文中的内核线程寄存器，并切换到当前的CPU调度，以让其他线程在该线程等待离散线程完成时运行。</p>
<p>发言人   34:46<br>So everything we’re going to talk about now, except for the timer interrupt, is pretty much the same if what’s going on is where in a system call and the system call needs to wait for IO and give up the CPU.<br>所以我们现在要谈论的一切，除了计时器中断，如果发生的事情是系统调用中的位置，并且系统调用需要等待IO并放弃CPU，则几乎是相同的。</p>
<p>发言人   35:02<br>For the purposes of today’s discussion, two situations are almost identical. Okay, so the question, does each per CPU scheduler have its own stack? Yes, there’s a stack. For this scheduler and a stack for this separate stack for the scheduler for CPU 1.<br>出于今天讨论的目的，两种情况几乎相同。好的，那么问题来了，每个CPU调度器都有自己的堆栈吗？是的，有一个堆栈。对于此调度器，以及用于CPU 1的调度器的此单独堆栈的堆栈。</p>
<p>发言人   35:31<br>Yeah, and indeed the stacks for this guy’s large show set up. In fact, all this stuff, you know, the contexts and the stacks for the scheduler threads are set up in a different way than for user processes. They’re set up at boot time. If you poke around in start DOS or start DOC startups, probably you’ll see some of the setup for each course scheduler thread. There’s a place where very early in the assembly code during boot where the stack is set up for each CPU, and it’s on that stack that the CPU boots on and then runs its scheduler thread.<br>是的，的确，这个家伙的大型演出设置的堆栈。事实上，所有这些东西，你知道，调度程序线程的上下文和堆栈的设置方式与用户进程不同。它们是在启动时设置的。如果您在开始DOS或开始DOC startup中四处寻找，可能您会看到每个课程安排程序线程的一些设置。在启动期间的汇编代码早期，有一个地方是为每个CPU设置堆栈的地方，CPU就在该堆栈上启动，然后运行其调度程序线程。</p>
<p>发言人   36:15<br>Okay? One piece of jargon, when people talk about context switch, they’re talking about usually. This act of switching from 1 thread to another by saving one set of register sets for the old thread and restoring previously saved registers for the thread we’re switching to. That’s what’s usually meant by context, which also, though sometimes it’s applied to the complete dance that goes on when switching from one user processes to another. And occasionally you’ll see context switch apply to switching between user and kernel. But for us, we mostly mean it for switching from 1 kernel thread, typically to a scheduler thread.<br>好吗？一个行话，当人们谈论上下文切换时，他们通常在谈论。通过为旧线程保存一组寄存器并恢复之前为我们要切换到的线程保存的寄存器，从而从一个线程切换到另一个线程的行为。这就是上下文通常的含义，尽管有时它也适用于从一个用户进程切换到另一个用户进程时发生的完整舞蹈。偶尔你会看到上下文切换适用于用户和内核之间的切换。但对我们来说，我们主要指的是从1个内核线程切换为一个调度线程。</p>
<p>发言人   37:06<br>Just some pieces of information. That are handy to keep in mind.<br>只是一些信息。记住这些是很方便的。</p>
<p>发言人   37:14<br>Every core just does one thing at a time. Each core it was either it just running one thread. At any given time. It’s either running some processes, user thread, some process kernel thread, or that course scheduler thread. So at any given time, the course is not doing multiple things. It’s just doing one thing. It’s this switching that sort of creates the illusion of multiple threads running at different times on that core.<br>每个核心一次只做一件事。每个核心要么它只运行一个线程。在任何给定的时间。它要么运行某些进程、用户线程、某些进程内核线程，要么运行那个课程调度程序线程。因此，在任何给定的时间，课程都不会做多种事情。它只是做一件事。正是这种切换产生了在该核心上不同时间运行多个线程的错觉。</p>
<p>发言人   37:39<br>Similarly, each thread is running on is either running on exactly one core or its state has been state has been saved and we’ve switched away from it. So, so you know a thread, just to be clear, a thread never runs on more than one core. Thread is either running on just one core or it’s not running at all. It has, it has saved state somewhere.<br>同样，每个运行的线程要么在一个核心上运行，要么其状态已经被保存，我们已经将其切换。所以，你知道一个线程，只是为了明确一点，线程永远不会在多个核心上运行。线程要么只在一个核心上运行，要么根本没有运行。它有，它已经在某个地方拯救了状态。</p>
<p>发言人   38:07<br>Another interesting thing about the XV 6 setup is that these contexts that hold saved kernel thread registers, they’re always produced by a call to switch. And so these contexts basically always refer to the state of the thread as it was executing inside a call to switch. And you know, the way we’ll see that come up is that when we switch from from one thread to another and restore the target threads context, the first thing it will do is return from a previous call to switch. So these contexts sort of always save state in as it is in Switch.<br>XV 6设置的另一个有趣的事情是，这些保存内核线程寄存器的上下文总是由调用switch产生的。因此，这些上下文基本上总是指线程在调用switch时的状态。你知道，我们看到的方式是，当我们从一个线程切换到另一个线程并恢复目标线程上下文时，它将做的第一件事是从之前的调用中返回switch。因此，这些上下文总是像在Switch中一样保存状态。</p>
<p>发言人   38:52<br>Okay? Any more questions about the of diagram level situation? I have a question, so we’re using the term thread all the time, but it seems to me like our implementation for XV 6 A process is is only one thread. So like, could it be possible that one process could have multiple threads or I wrong here in Xb 6, right?<br>好吗？还有关于图表级别情况的问题吗？我有一个问题，所以我们一直在使用术语线程，但在我看来，我们对XV 6的实现过程只有一个线程。就像，一个进程可能有多个线程，或者我在Xb 6中弄错了，对吗？</p>
<p>发言人   39:25<br>There’s definitely some confusing things about the way we use the words here in XV 6 a process. A process is either executing instructions, user level, or it’s executing instructions in the kernel, or it’s not executing at all. And it stated has been saved away into this combination of a context and a trap frame. So that’s the actual situation.<br>在XV 6中，我们使用这些词的方式肯定有一些令人困惑的事情。进程要么执行用户级别的指令，要么在内核中执行指令，要么根本不执行。它说已经被保存在上下文和陷阱框架的组合中。这就是实际情况。</p>
<p>发言人   40:04<br>Now, what you want to call that? You can call what you like. I don’t know of a simple explanation for this structure. We’ve been calling it. I’ve been calling it. I’ve been saying that each process has two threads, a user level thread and a kernel level thread, and that the process, there’s this restriction that a process is only execute, is either executing in the kernel in the user space, or executing in the kernel in the interrupt your system call that never Bos. Okay, that makes sense you? Yeah, I apologize for the kind of complexity of this. Okay, okay, so let me switch to code looking at the XV 6 code.<br>现在，你想叫它什么？你喜欢什么就叫什么。我不知道这个结构的简单解释。我们一直在称呼它。我一直在叫它。我一直在说每个进程都有两个线程，一个用户级线程和一个内核级线程，并且这个进程有这样的限制，即一个进程只能执行，要么在用户空间的内核中执行，或者在中断系统调用的内核中执行，这永远不会导致问题。好吧，那就感知你了？是的，我为这件事的复杂性道歉。好的，让我切换到代码，查看XV 6代码。</p>
<p>发言人   41:02<br>So, first of all.<br>所以，首先。</p>
<p>发言人   41:10<br>I just want to just to show some of the stuff we’ve been talking about. I’m going to look at the. Process structure. And we can see in the process structure a lot of the things we’ve been talking about.<br>我只是想展示一些我们一直在谈论的东西。我要去看看。过程结构。我们可以在流程结构中看到很多我们一直在谈论的事情。</p>
<p>发言人   41:25<br>Just for review. There’s the. Trap frame that saves the user level registers. There’s a context here that saves the kernel thread registers. When we switch to the scheduler thread, there’s a pointer to this process is kernel stack, which is where the function calls are saved while we’re executing in the kernel, there’s the state variable, which records whether this process is running or runable or sleeping or not allocated at all. And then finally, there’s a lock that protects various things, as we’ll see. For now, we can observe that it at least protects changes to the state variable so that, for example, two scheduler threats don’t try to grab a runable process and run it at the same time. One of the many things this lock does is prevent that from happening.<br>只是为了审查。就是这样。保存用户级寄存器的陷阱帧。这里有一个保存内核线程寄存器的上下文。当我们切换到调度器线程时，有一个指向此进程的指针内核堆栈，这是我们在内核中执行时保存函数调用的地方，还有一个状态变量，它记录此进程是否正在运行或可运行或休眠或根本没有分配。最后，有一个锁可以保护各种东西，我们将会看到。目前，我们可以观察到它至少保护了对状态变量的更改，例如，两个调度程序威胁不会试图获取可运行的进程并同时运行它。这个锁的许多作用之一是防止这种情况发生。</p>
<p>发言人   42:35<br>I’m going to run a simple demo program for you. This spin program I’m using it mostly just to drive to sort of create the predictable situation in which we switch from 1 thread to another. But this is this program, Spin program creates two processes, and the processes both compute forever, you know, called fork ear, I make a child and then forever both children. Both children just sit in this loop. And every once in a while, they’ll print a character just so we can see they’re making progress, but they don’t print characters very often, and they never sort of intentionally give up the CPU.<br>我将为您运行一个简单的演示程序。这个旋转程序，我主要使用它来驱动，以创建可预测的情况，在这种情况下，我们从一个线程切换到另一个线程。但这是这个程序，Spin程序创建了两个进程，这两个进程都永远计算，你知道，叫做fork ear，我做一个孩子，然后永远都是孩子。两个孩子都坐在这个循环中。而且每隔一段时间，他们会打印一个字符，这样我们就可以看到他们正在取得进展，但他们不经常打印字符，而且他们从来没有故意放弃CPU。</p>
<p>发言人   43:17<br>So what we have here is two, essentially two compute bound processes And in order for both of them to run I’m going to run them on a single CPU XV 6. That is only one core. And so in order for both of them to execute, it’s going to be necessary to switching between the two processes. Let me fire up the spin program under Gdb.<br>所以我们这里有两个，本质上是两个计算绑定进程，为了让它们都运行，我将在单个CPU XV 6上运行它们。这只是一个核心。因此，为了使它们两个都能执行，有必要在这两个进程之间切换。让我启动Gdb下的自旋程序。</p>
<p>发言人   43:51<br>Run the spin program and you can see it’s printing one of the two processes prints forward slash and the other prints backward slash. And you can see that every once in a while XV 6 is switching between them. It only has one core the way I’ve configured it. So we see a bunch of forward slashes printing and then apparently a timer interrupt mosts, go off, switch the 1 CPU to the other process, and then prints the other kind of slash for a while.<br>运行旋转程序，您可以看到它正在打印两个进程中的一个，其中一个打印正斜杠，另一个打印反斜杠。你可以看到，每隔一段时间，XV 6就会在它们之间切换。它只有一个核心，我配置它的方式。所以我们看到一堆正斜杠打印，然后显然是一个计时器中断，关闭，将1 cpu切换到另一个进程，然后打印另一种斜杠一段时间。</p>
<p>发言人   44:18<br>And so what I want to observe is the timer interrupt going off. So I’m going to put a breakpoint and trap. And in particular, at line 207 and trap, Which is the code in? Trap and Dev enter that recognizes that, we are interrupt, and the interrupt was cos, barite heimer interrupt. So I’m going to put a breakpoint here at trap DOC to 7 and continue.<br>所以我想要观察的是定时器中断关闭。所以我要设置一个断点和陷阱。特别是在207行和陷阱，代码在哪？Trap和Dev enter可以识别出我们是中断，中断是cos，barite heimer中断。所以我将在陷阱文档到7处放置一个断点并继续。</p>
<p>发言人   45:02<br>Boom, the trap point triggers right away because timer maps are pretty frequent and we can tell from where that indeed we’re in User Trap. And User Trapp has called Dev Enter to handle this interrupt. I want to kind type finish to get out of Devon back into user trap because in fact, we don’t the code endeavor interval timer nodes is almost nothing. However, once we’re back at. In. User trap. We can see that from this line here that we just returned from Dev Enter.<br>Boom，陷阱点会立即触发，因为计时器地图非常频繁，我们可以从用户陷阱的位置看出我们确实处于哪个位置。用户traapp调用了Dev Enter来处理这个中断。我想通过键入finish来摆脱Devon回到用户陷阱，因为实际上，我们的代码努力间隔计时器节点几乎没有什么。然而，一旦我们回到了。在。用户陷阱。我们可以看到，从这里我们刚刚从Dev Enter返回的这一行。</p>
<p>发言人   45:47<br>And the interesting thing about this is that. What we’re about to do, I mean, looking forward, we’re currently at this line here and we’re looking forward to this call the yield when dividend for return to. You can see from this you return is 2. Two is basically the device number. And we’re going to see by and by because which device is to user perhaps is going to call yield, which will give it the CPU and allow us to switch to another process. So we’ll see that in a moment.<br>关于这个有趣的事情是。我们即将要做的事情，我的意思是，展望未来，我们目前在这条线上，我们期待着在股息返回时调用这个产量。你可以从这里看到你返回的是2。2基本上是设备编号。我们将逐步了解哪个设备对用户来说可能会调用yield，这将为其提供CPU并允许我们切换到另一个进程。我们一会儿就会看到。</p>
<p>发言人   46:24<br>Meantime, let’s look at what was currently executing when the interrupt happened. So I’m going to print p, the variable of p holds a pointer to the current processes struct, proc. Okay, we have a question. What makes each process’s kernel thread different? Every process has a separate kernel thread. So there’s really two things that differentiate different processes. Kernel thread, because more than one could be executing on different cores. When it’s indeed that every process has a separate kernel stack. And that’s what’s pointed to by that k stack element of struct proc. And the other is that.<br>同时，让我们看看中断发生时当前正在执行什么。所以我要打印p，p的变量保存着一个指向当前进程结构proc的指针。好的，我们有一个问题。是什么让每个进程的内核线程不同？每个进程都有一个单独的内核线程。所以，有两件事情可以区分不同的过程。内核线程，因为多个线程可以在不同的内核上执行。当每个进程确实都有一个单独的内核堆栈时。这就是struct proc的k个堆栈元素所指向的内容。另一个是那个。</p>
<p>发言人   47:14<br>Early in, we’re in user trap, which is now the C code that’s called by trampoline when an interrupt occurs. We can tell by this call by any. Any kernel code can tell by calling my proc what the process is. It’s running on the current CPU. And that’s another thing that differentiates that. Allow each, that allows kernel code to tell what process it’s part of that is which processes kernel thread is executing.<br>早些时候，我们处于用户陷阱中，现在是当中断发生时由蹦床调用的C代码。我们可以通过这个电话告诉任何人。任何内核代码都可以通过调用我的proc来判断进程是什么。它正在当前CPU上运行。这是另一个不同之处。允许每个，这允许内核代码告诉它是哪个进程的一部分，哪个进程的内核线程正在执行。</p>
<p>发言人   47:48<br>And what my proc does is basically use the TP register, which you may recall is set up to contain the current cores, heart ID or core number. It uses that to index into an array of structures that say for each core that the scheduler sets whenever it switches processes to indicate for each core which process is running on that core. So that’s how different kernel threads are differentiated.<br>而我的proc基本上是使用TP寄存器，您可能还记得，它设置为包含当前内核、核心账号或核心编号。它使用它来索引结构数组，这些结构表示调度程序在切换进程时为每个核心设置的索引，以指示每个核心上运行的进程。这就是不同内核线程的区别。</p>
<p>发言人   48:15<br>Okay, so I was going to use that p value, the name, and that p value to figure out what process is running. XV 6 remembers the name it, that spin process, just exactly as expected. There were two of them, I think, with process Id’s 3 and 4. We’re currently executing in process ID 3. So after the switch, we’d expect to be in process ID 4. The other spin process, how can we can look at the saved user registers in the trap frame?<br>好的，所以我打算使用那个p值、名称和那个p值来确定哪个进程正在运行。XV 6记得它的名字，即旋转过程，完全符合预期。其中有两个，我想，进程Id是3和4。我们目前正在执行进程账号3。因此，在切换之后，我们期望在4账号进行。另一个旋转过程，我们如何在陷阱框架中查看保存的用户寄存器？</p>
<p>发言人   48:54<br>And these are just the 32 registers that the trampoline codes saves a way to save the user state. There’s the user RA return address register, user stack pointer, user program counter at hex 62. These are all familiar things from when we looked at traps. And, you know, maybe of the most interest is that. The trap frame saves the user program counter ends at value 62 if we cared. We can look in the assembly code for spin DOC. Just spin, do ASM and look for 62. And we can see that, oh, the interrupt timer, interrupt, interrupt occurred during this add instruction in that infinite loop. In spin, it’s not too surprising.<br>这些只是蹦床代码保存用户状态的32个寄存器。这里有用户RA返回地址寄存器、用户堆栈指针、用户程序计数器 (在十六进制62处)。这些都是我们在研究陷阱时所熟悉的东西。而且，你知道，也许最感兴趣的是那个。陷阱帧保存用户程序计数器的值为62，如果我们关心的话。我们可以查看spin DOC的汇编代码。只需旋转，做ASM并寻找62。我们可以看到，在那个无限循环中，中断计时器、中断发生在这条添加指令的过程中。在旋转中，这并不太令人惊讶。</p>
<p>发言人   49:55<br>Okay, so back to the trap code Daven just returned. I’m going to type step a few times to get us to the. Just being about to execute this yield. And yield is sort of the first step in the process. Giving up the CPU, switching to the scheduler, or letting the scheduler choose another kernel thread and process to run. All right, so let’s actually step into yield. Now we’re in yield. Yields Have a question, no?<br>好的，那么回到Daven刚刚返回的陷阱代码。我将输入步骤几次，让我们进入。只是即将执行这个产量。产量是这个过程的第一步。放弃CPU，切换到调度器，或让调度器选择另一个内核线程和进程来运行。好的，那么让我们实际上进入产量。现在我们有收益了。产量有一个问题，不是吗？</p>
<p>发言人   50:43<br>Okay, we’re in yield. Yield does just a couple things. It acquires the lock for this process because it’s about to make a bunch of changes to this process. It doesn’t want any other. And in fact, until it gives up the lock, the state of this process will be sort of inconsistent.<br>好的，我们有收益。Yield只会做几件事情。它获得了这个进程的锁，因为它即将对此进程进行一系列更改。它不想要任何其他的。事实上，在它放弃锁定之前，这个过程的状态会有点不一致。</p>
<p>发言人   51:04<br>Like, for example, yield is about to change. The state of the process to Runnable would, you know, indicates that the process is not running, but would like to, but this process is running, right? I mean, we’re running the process right now. That’s what’s executing is the kernel thread for this process. And so the one of the many things that acquiring this lock does is makes it so that even though we’ve just changed the state to runable, no other core scheduling thread will look at this process.<br>例如，产量即将改变。进程的可运行状态，你知道，表示该进程没有运行，但希望运行，但该进程正在运行，对吗？我的意思是，我们现在正在运行这个过程。这就是正在执行的是这个进程的内核线程。因此，获取此锁所做的众多事情之一就是使其变得即使我们刚刚将状态更改为 “可运行”，也不会有其他核心调度线程查看此进程。</p>
<p>发言人   51:33<br>And because of the lock and see that it’s runable and try to run it while we’re still running it on this core, which would be a disaster, right?<br>因为这个锁，看看它是可运行的，并尝试在我们仍在这个核心上运行它时运行它，这将是一场灾难，对吧？</p>
<p>发言人   51:41<br>Running the same process on two different cores. And that process has only one stack. So that means like two different cores are, you know, calling subroutines on the same stack, which is just a recipe for disaster. So we take a walk out. We yield changes the state to Runnable. And what this means is that, you know, when we finally given up the.<br>在两个不同的核心上运行相同的进程。而这个过程只有一个堆栈。这意味着两个不同的核心在同一堆栈上调用子程序，这只会导致灾难。所以我们出去散步。我们将状态转变为可运行的。这意味着，你知道，当我们最终放弃了。</p>
<p>发言人   52:12<br>We finally yield the CPU and give it up and switch to the scheduler process. This state will be left in this runable state so that it will run again. Because after all, this was a timer interrupt that interrupted a running user level process that would like to continue computing. We’re going to leave it in state runable so that it will run again as soon as the scheduler decides to. And then the only other thing that.<br>我们最终放弃了CPU并切换到调度程序进程。此状态将保留在此可运行状态，以便它将再次运行。因为毕竟这是一个计时器中断，中断了正在运行的用户级进程，该进程希望继续计算。我们将让它处于可运行状态，以便调度程序决定再次运行。然后是唯一的另一件事。</p>
<p>发言人   52:44<br>Ule does is call this scheduler function. So I’m going to step into the scheduler function. I’ll show this whole thing here.<br>Ule所做的就是调用这个调度器函数。所以我要进入调度程序功能。我会在这里展示整个事情。</p>
<p>发言人   53:03<br>This schedule there is something does almost nothing. It does a bunch of checks. It does a whole bunch of sanity checks and panics. And the reason for that is actually that this code in XV 6, over its many year lifetime, has had a been among the most bug prone and had most surprises, unhappy surprises. And so there’s a lot of sanity checks and panics here because because there’s often been bugs associated with this code. All right I’m going to skip over these sanity checks and proceed to the.<br>这个时间表有一些几乎什么都不做的东西。它会做很多检查。它进行了大量的理智检查和恐慌。原因实际上是，XV 6中的这段代码，在其多年的生命周期中，一直是最容易出现错误和最令人惊讶的，令人不快的惊喜之一。所以这里有很多健全性检查和恐慌，因为经常有与此代码相关的错误。好的，我要跳过这些健全性检查，继续进行。</p>
<p>发言人   53:46<br>Call to switch This call to switch is where the real action happens. This is called a switch is going to save away the current kernel threads registers in pro context, which is the current processes.<br>Call将此调用切换到switch是真正的操作发生的地方。这被称为开关，它将在pro上下文中保存当前内核线程寄存器，即当前进程。</p>
<p>发言人   53:59<br>Save kernel thread context, save set of registers C arrow context C is the pointer to this core struct CPU and struct CPU has the context. The save registers of this core scheduler thread. So we’re going to be switching from this thread and saving this thread state, restoring the threat state of this course scheduler and sort of continuing the execution of this course scheduler thread. Okay, so let’s see what? Let’s do a quick preview at the context that we’re going to be switching to. And I can get that. Turns out that I can’t actually print CR context, but I happen to know that C prints to Cpu’s 0 just because we’re on the zero with core, there’s only one core, and I can print its context. And so this is the saved registers from this course scheduler threat.<br>保存内核线程上下文，寄存器存储集C箭头上下文C是指向此核心结构CPU的指针，结构CPU具有上下文。此核心调度程序线程的保存寄存器。所以我们将从此线程切换并保存此线程状态，恢复此课程调度程序的威胁状态，并继续执行此课程调度程序线程。好的，让我们看看是什么？让我们快速预览一下我们要切换到的上下文。我可以理解。原来我实际上不能打印CR上下文，但我碰巧知道C会打印到Cpu的0，只是因为我们在带有核心的零上，只有一个核心，我可以打印它的上下文。因此，这是此课程调度程序威胁中保存的注册表。</p>
<p>发言人   55:10<br>And of particular interest is the RA, because the RA register is where the current function call is going to return to. So we’re going to switch to the scheduler thread, and it’s going to do a return and return to that RA. And we can find out where that return address is by looking in Chrome do ASM. Actually that’s.<br>特别有趣的是RA，因为RA寄存器是当前函数调用将要返回的地方。所以我们将切换到调度程序线程，它将返回并返回到该RA。我们可以通过查看Chrome do ASM来找出返回地址在哪里。实际上就是这样。</p>
<p>发言人   55:44<br>And as you can see, this X slash I prints instructions that are in certain address, but it also prints the label of the name of the function that those instructions are in it. So we’re going to be returning to schedule or buy and buy. That’s just, you know, as you might expect. Okay?<br>正如您所看到的，这个X斜杠I打印出位于特定地址的指令，但它也打印出这些指令在其中的函数名称的标签。所以我们将返回时间表或购买和购买。那只是，你知道，正如你所期望的那样。好吗？</p>
<p>发言人   56:11<br>I want to look at what Switch actually does. We’re about to call Switch. Again I’m putting a breakpoint on switch. I’m putting a breakpoint because there’s a bunch of setup code like that pulls the values of context out of those structures. Let’s skip over it.<br>我想看看Switch实际上是做什么的。我们要呼叫交换机了。我又在switch上放了一个断点。我设置了一个断点，因为有一堆类似的设置代码会从这些结构中提取上下文的值。让我们跳过它。</p>
<p>发言人   56:29<br>Okay, so now or the breakpoint and switch, the gdb won’t show us the instructions, but we can look and switch DOS to look at the instructions we’re about to execute. So as you can see, we’re on the very first instruction, the store of RA 2, the address pointed to by a 0. You may remember in the call to switch that the first argument was the current threads context, and the second argument was the context of the thread. We’re switching to the two arguments go in a 0, a 1. And so the reason why we see all these stores through register a 0 is because we’re storing away a bunch of registers in the memory that a zero points to that is in the context of the thread we’re switching from. And the loads load from address A one, because that’s a pointer to the context of the thread we’re switching to.<br>好的，现在或者断点和开关，gdb不会向我们显示指令，但我们可以查看并切换DOS来查看我们即将执行的指令。所以你可以看到，我们在第一个指令上，RA 2的存储，地址指向0。你可能记得在调用switch时，第一个参数是当前线程的上下文，第二个参数是线程的上下文。我们正在切换到两个参数，分别是0和1。因此，我们看到所有这些通过寄存器a 0存储的原因是因为我们在内存中存储了一堆寄存器，在我们从中切换的线程的上下文中零点指向那个。并且加载从地址加载一个，因为这是指向我们要切换到的线程的上下文的指针。</p>
<p>发言人   57:26<br>Okay, so thread, you know, switch saves, registers loads registers from the target threads context, and then return. And that’s why the RA was interesting because it’s going to return to the place that RA pointed to, namely, and to schedule it. All right, so one question is, you may notice here that while switch saves Rasp and a bunch of S registers, one thing that does not save is the program counter. There’s no mention of the program counter here. So why is that?<br>好的，所以线程，你知道，开关保存，寄存器从目标线程上下文中加载寄存器，然后返回。这就是为什么RA很有趣，因为它会回到RA所指向的地方，即，并安排它。好的，有一个问题是，你可能会注意到，虽然switch保存了Rasp和一堆S个寄存器，但有一件事没有保存，那就是程序计数器。这里没有提到程序计数器。那么为什么呢？</p>
<p>发言人   58:04<br>Is it because the program header is updated with like the function calls anyway? Yeah, it’s the program counter. There’s no actual information value in the program counter. We know that where we’re executing right now is in Switch, so there’ll be no point in saving the program counter because it has an extremely predictable value, namely this instruction.<br>是因为程序标题被更新了，就像函数调用一样吗？是的，这是程序计数器。程序计数器中没有实际的信息值。我们知道现在执行的位置在Switch中，因此保存程序计数器没有意义，因为它有一个非常可预测的值，即此指令。</p>
<p>发言人   58:27<br>The rest of this instruction and switch we really care about is where we were called from. Because when we switch back to this thread, we want to continue executing whatever point switch was called from, and it’s RA that holds the address of the instruction that switch was called from. So it’s RA that’s being saved away here, and RA is the point at which we’ll be. Executing out again, let switch returns. So we can even print that. We can print RA. We can print RA and we haven’t actually switched threads yet. Remember, we came here from the scheduled function. So Ras, as you might expect, the pointer back into the scheduling.<br>这个指令和开关的其余部分，我们真正关心的是我们从哪里被调用的。因为当我们切换回这个线程时，我们希望继续执行调用switch的任何点，而RA保存了调用switch的指令的地址。所以这是RA正在这里被拯救，RA是我们将要到达的点。再次执行out，让switch返回。所以我们甚至可以打印出来。我们可以打印RA。我们可以打印RA，但实际上我们还没有切换线程。记住，我们是从预定功能来到这里的。因此，正如您所期望的那样，将指针返回到调度中。</p>
<p>发言人   59:15<br>Another question is how come switch only saves 14 registers? I counted them, it only saves and restores 14 registers, even though the risk 5 has 32 registers available for code to use. Why? Why only half the registers received? Well, when switch was called, it was called as a normal function, so whoever called Switch already assumed, well switch might modify those so that that function already saved that on its stack, meaning that like when we jump from one to the other, that one’s going to self restore it. Call or safe registers, that’s exactly right. The switch is a called from C code.<br>另一个问题是，为什么switch只保存14个寄存器？我数了数，它只保存和恢复14个寄存器，即使风险5有32个寄存器可供代码使用。为什么？为什么只收到一半的记录？好吧，当调用switch时，它被称为普通函数，所以无论谁调用Switch都已经假定，switch可能会修改它们，以便该函数已经将其保存在其堆栈上，这意味着当我们从一个跳转到另一个时，那个将自行恢复它。呼叫或安全注册，这完全正确。开关是从C代码中调用的。</p>
<p>发言人   59:58<br>We know that the C compiler saves on the current stack, any caller saved registers that have values in them that the compiler is going to need later, and those caller saved registers actually include I think there’s 18 or depending on how you count them, there’s somewhere between 15 and 18 caller saved registers. And so the registers we see here are all the registers that aren’t callers saved and that the compiler doesn’t promise to save, but nevertheless may hold values that are needed by the calling function, so we only have to save the call saved registers when we’re switching threads.<br>我们知道C编译器保存在当前堆栈上，任何具有编译器稍后需要的值的调用方保存的寄存器，而这些调用方保存的寄存器实际上包括18或取决于你如何计数它们，有15到18个呼叫者保存寄存器。因此，我们在这里看到的寄存器是所有未被调用方保存的寄存器，编译器也不承诺保存这些寄存器，但它们仍然可能保存调用函数所需的值，因此我们只需要在切换线程时保存调用保存的寄存器。</p>
<p>发言人   01:00:46<br>Okay? Final thing I want to print is the we do save and restore the stack pointer, the current stack pointer. It’s like hard to tell from this value what that means, but it’s the kernel stack of the current process. I don’t know if you recall, but is allocated, is mapped by the virtual memory system in high memory. Okay, so?<br>好吗？我想打印的最后一件事是我们保存和恢复堆栈指针，即当前的堆栈指针。很难从这个值中看出这意味着什么，但它是当前进程的内核堆栈。我不知道你是否记得，但是被分配了，被高内存中的虚拟内存系统映射。好吧，所以呢？</p>
<p>发言人   01:01:12<br>Okay, so we’re going to save away the current registers and restore registers from the scheduler threads context. I don’t want to like execute every single one of these loads in store. So I’m going to step over all the 14 loads, the 14 stores, and the 14 loads going to proceed directly to the return instructions. Okay, so we executed everything and switch except the return.<br>好的，我们将保存当前寄存器并从调度线程上下文中恢复寄存器。我不想在商店里执行这些负载中的每一个。所以我将对所有14个货物、14个商店进行逐级检测，这14个货物将直接进行退货说明。好的，所以我们执行了所有操作并切换了，除了return。</p>
<p>发言人   01:01:37<br>Before we do the return, we’ll just print the interesting registers again to see where we are. So stack pointer now is has a different value, stack pointer now points into the stack 0 area in memory, and this is actually the place very, very early in the boot sequence where start dot S puts the stack so it can make call the very first C function. So actually back on the original boot stack for this CPU, which just happens to be where the scheduler runs.<br>在我们进行返回之前，我们将再次打印有趣的寄存器以查看我们的位置。所以堆栈指针现在具有不同的值，堆栈指针现在指向内存中的堆栈0区域，这实际上是启动序列中非常早期的位置，start dot S将堆栈放置，以便它可以调用第一个C函数。所以实际上回到了这个CPU的原始启动堆栈上，这恰好是调度程序运行的地方。</p>
<p>发言人   01:02:10<br>Okay, the program counter, not very interesting we’n switch because we haven’t returned yet. And the RA register now points the scheduler because we’ve loaded, we’ve restored the register set previously saved by the scheduler thread. And indeed, we’re really now in the scheduler thread. If I were on where that where now looks totally different from the last time we ran it, we’re now indeed in a call to switch, but now we’re in a call from switch to switch that the scheduler made some point in the past and the schedule was run long ago during boot was called as the last thing that Maine did during the boot process. So I’m going to execute one instruction to return from switch now into scheduler. So now we’re in this course scheduler. Let’s look at the full code.<br>好的，程序计数器，不是很有趣，我们要切换，因为我们还没有回来。并且RA寄存器现在指向调度器，因为我们已经加载了，我们已经恢复了调度器线程先前保存的寄存器集。事实上，我们现在真的处于调度器线程中。如果我所在的地方现在看起来与我们上次运行它时完全不同，我们现在确实在呼吁切换，但是现在我们在一个交换机的呼叫中，调度程序在过去做了一些事情，并且调度程序在启动期间运行了很久，这被称为缅因在启动过程中做的最后一件事。所以我将执行一条指令，从交换机返回到调度器。所以现在我们在这个课程安排中。让我们来看看完整的代码。</p>
<p>发言人   01:03:08<br>So this is the scheduler code, this function called scheduler. And now we’re executing in the scheduler thread for the CPU. And we’re just at the point we just returned from a previous call to switch that the scheduler made a while ago when it decided it was going to start running that process, you know pip 3, which was the spin process that was interrupted. So it’s this switch process ID 3, that spin called switch, but it’s not switch. That switch that’s returning, that switch hasn’t returned yet, it’s still saved away in process. Id’s, threes, stack and context just returned from this earlier call to switch.<br>所以这是调度程序代码，这个函数称为调度程序。现在我们正在CPU的调度线程中执行。而且我们刚刚从调度器不久前决定开始运行该进程时所做的切换调用中返回，你知道pip 3，这是被中断的旋转进程。所以这个切换过程账号3，旋转称为switch，但它不是switch。那个正在返回的交换机，那个交换机还没有返回，它仍然在保存过程中。Id、threes、stack和context刚刚从之前的switch调用中返回。</p>
<p>发言人   01:03:53<br>All right, so the stuff that happens here in the scheduler, we’re stopped running this process. So we want to forget about the various things we did in the process of running this process. We want to forget c arrow proc equals 0 basically means that we’re forgetting that we’re no longer running this process in this course. So we don’t want to and have anybody be confused about that. Let me set this per core proc pointer to 0 instead of this process.<br>好的，所以在调度程序中发生的事情，我们将停止运行此进程。所以我们想忘记在运行这个过程中所做的各种事情。我们想要忘记c箭头proc等于0基本上意味着我们忘记了我们在本课程中不再运行这个过程。所以我们不想让任何人对此感到困惑。让我将这个每个核心进程的指针设置为0，而不是这个进程。</p>
<p>发言人   01:04:23<br>The next thing that happens is that you remember yield acquired the lock for this process because it didn’t want any other core scheduler to look at this process and maybe run it until the process was completely put to sleep. We’ve now completed the switch away from this process, and so we can release the lock on the process that just yielded. That’s the release. And at this point, we’re still in the scheduler If there was another core, at this point, some other core scheduler could find that process because it’s runnable and but that’s okay because we’ve completely saved its registers, We’re no longer executing on it. That processes stack because we’re now executing on the this core scheduler stack. So it’s actually fine if some other core decides to run that process, okay? But there is no other core, so that doesn’t actually happen in this demonstration.<br>接下来发生的事情是你记得yield为此进程获取了锁定，因为它不希望任何其他核心调度程序查看此进程，并可能运行它直到进程完全进入睡眠状态。我们现在已经完成了与此进程的切换，因此我们可以释放刚刚产生的进程的锁。这就是解放。此时，如果还有另一个核心，我们仍然在调度器中，此时，其他核心调度器可能会找到该进程，因为它是可运行的，但这没关系，因为我们已经完全保存了它的寄存器，我们不再在其上执行。它处理堆栈，因为我们现在正在这个核心调度器堆栈上执行。因此，如果其他核心决定运行该过程，实际上也没问题，好吗？但没有其他核心，所以在这个演示中实际上不会发生这种情况。</p>
<p>发言人   01:05:26<br>I actually want to spend a moment talking about the PR lock a little bit more.<br>我实际上想花一点时间更多地谈论一下PR锁。</p>
<p>发言人   01:05:33<br>Pierre Locke actually does a couple of things. It does really two things from the point of view of scheduling. One is that yielding the CPU involves multiple steps. We have to set the state to run up, change the state from running to runable We save the registers in the yielding processes context, and we have to stop using the yielding processes, stack at least three steps, know which take time in order to do all the steps required to yield the CPU. And so one of the things that Locke does, as I mentioned, is prevent any other course scheduler from looking at our process until all three steps I have completed. So the lock is basically making those steps atomic, they either all happen from the point of view of other cores, or none of them have happened.<br>皮尔·洛克实际上做了几件事情。从日程安排的角度来看，它确实做了两件事情。其一是产生CPU涉及多个步骤。我们必须将状态设置为启动，将状态从运行更改为可运行，我们将寄存器保存在屈服进程上下文中，并且我们必须停止使用屈服进程，至少堆叠三个步骤，知道哪个需要时间才能完成屈服CPU所需的所有步骤。因此，正如我所提到的，洛克做的一件事是防止任何其他课程安排人员在我完成所有三个步骤之前查看我们的流程。因此，锁基本上使这些步骤原子化，它们要么从其他内核的角度发生，要么都没有发生。</p>
<p>发言人   01:06:26<br>It’s going to turn out also when we start running a process that the P like is going to have a sort of similar protective function. We’re going to set the state of a process to running. When we start executing a process, and we’re going to move its registers from its process context into the risk five registers. But if an interrupt should happen in the middle of that process, the interrupt is going to see the process in a weird state, like maybe in the state of Mark running, but hasn’t yet finished moving its registers from the context into the risk five registers. And so that would be a disaster if the timer interrupt happened then because we might switch away from that process before it had restored its registers. And switching away from that process would save now uninitialized risk five registers into the context processes, context overwriting its real registers. So indeed, we want starting a process to also be effectively atomic, and in this case, holding the lock, holding P lock across, switching to a process, as well as preventing other cores from looking at that process also turns off interrupts for the duration of firing up, of switching to that thread, which prevents a timer interrupt from ever seeing a process that’s only midway through being switched to.<br>当我们开始运行一个进程时，P也将具有类似的保护功能。我们将设置一个进程的状态为正在运行。当我们开始执行一个进程时，我们将把它的寄存器从它的进程上下文移到风险五寄存器中。但是如果在该过程中间发生中断，则中断将会看到该进程处于一种奇怪的状态，例如可能处于标记运行状态，但尚未完成将其寄存器从上下文中移动到风险五寄存器。如果计时器中断发生，那将是一场灾难，因为我们可能会在恢复其寄存器之前从该进程切换出去。并且从该过程中切换将现在未初始化的风险五寄存器保存到上下文过程中，上下文覆盖其真实寄存器。因此，我们确实希望启动一个进程也是有效地原子的，在这种情况下，持有锁，持有P锁，切换到一个进程，以及防止其他核心查看该进程，也会在触发期间关闭中断，切换到该线程，这可以防止计时器中断看到仅在切换过程中途的进程。</p>
<p>发言人   01:07:51<br>Okay? So we’re in the scheduler. We’re executing this loop in the schedulers, loop in the scheduler that looks at all the processes in turn to find one to run. And in this case, we know there’s another process because there’s that other spin process that we’ve ked. But there’s a lot of process, lots to examine. So I want to skip over the actual, the scanning of process table and go to the point at which the scheduler finds the next process. So I’m going to put a breakpoint.<br>好吗？所以我们在日程安排中。我们在调度器中执行这个循环，在调度器中循环，依次查看所有进程以找到一个运行。在这种情况下，我们知道还有另一个过程，因为还有我们已经完成的其他旋转过程。但是有很多过程，很多要检查。所以我想跳过实际的进程表扫描，并转到调度程序找到下一个进程的点。所以我要设置一个断点。</p>
<p>发言人   01:08:26<br>At line 474, where it’s actually found a new process to run, here we are, the scheduler is scan the process table and found another the process to run. And it’s going to cause that process to run. You can see at line 400 and sixty-eighth acquired, that process is lock. So now it’s entitled to do the various steps are required to switch to that process.<br>在第474行，它实际上找到了一个新的进程来运行，在这里，调度器扫描进程表并找到了另一个要运行的进程。这将导致该过程运行。你可以看到在400行和第六十八行收购时，这个过程是锁定的。所以现在它有权执行切换到该过程所需的各个步骤。</p>
<p>发言人   01:08:51<br>In line 473, it set the process of state to running. It’s now at 474 going to record in the CPU structure, which process the CPU is executing, and then call switch to save the schedulers registers and restore the target processors registers so we can see what process it found by looking at the new processes name. Surprisingly, it spin. This process ID is now 4, used to be running three, now running, running four. And we’ve already set the state to running so. The state’s running.<br>在第473行，它将状态进程设置为正在运行。现在474将记录在CPU结构中，CPU正在执行哪个进程，然后调用交换机来保存调度器寄存器并恢复目标处理器寄存器，以便我们可以通过查看新进程名称来查看找到了哪个进程。令人惊讶的是，它在旋转。这个进程账号现在是4，以前运行3，现在运行4。我们已经将状态设置为运行状态。国家在奔跑。</p>
<p>发言人   01:09:32<br>We can see where this thread is going to switch to in the call to switch at line 475. Print this context. You saved registers. So where is the RA, the person we’re going to call switch? Switch, as we know, returns. When it returns, it returns to the restored RA. So we really care about is where is it that RA points to, we can find that out by. Using x slash I. It’s going to return RA points to some point in Scad. That’s not too surprising, since presumably that other spin process was suspended due to a timer interrupt, which as we know, calls skid, which call switch.<br>我们可以在第475行的调用switch中看到这个线程将切换到哪里。打印此上下文。您保存了注册表。那么RA (我们要呼叫的人) 在哪里？开关，正如我们所知，返回。当它返回时，它返回到恢复的RA。所以我们真正关心的是RA指向哪里，我们可以通过它找到答案。使用x斜杠I。它将使分数返回到分数的某个点。这并不太令人惊讶，因为可能另一个自旋过程由于计时器中断而暂停，正如我们所知，它调用了switch。</p>
<p>发言人   01:10:26<br>All right, so we’re about to call switch. Let me just bring up the switch code again.<br>好的，那么我们就要调用交换机了。让我再次调出切换代码。</p>
<p>发言人   01:10:38<br>Actually, enter switch. We still where shows that we’re still in the scheduler’s. I want to again execute all of the instructions to switch, this time switching from the scheduler to the new process. So we skip over the 28 stores and loads.<br>实际上，进入开关。我们仍然在哪里显示我们仍然在调度程序中。我想再次执行所有切换指令，这次是从调度程序切换到新进程。所以我们跳过了28个商店和货物。</p>
<p>发言人   01:11:00<br>Just convince ourselves that we are actually about to return to Scad. So now, since we’re about to return to skeidi, not scheduler, we must now be in the processes kernel thread and no longer in the scheduler thread. And indeed, if we look at the back trace, we had a user trap call that must have been a timer interrupt from you sometime in the past that, as we’ve seen, called yield and scale. But it was the timer. It interrupted the other process. Now, not in the process that we originally looked at.<br>只要说服自己，我们实际上即将回到斯德。所以现在，由于我们要返回skeidi，而不是调度程序，我们现在必须在进程内核线程中，不再在调度程序线程中。事实上，如果我们看回溯，我们有一个用户陷阱调用，一定是过去某个时候来自您的计时器中断，正如我们所看到的，称为产量和规模。但这是计时器。它中断了另一个过程。现在，不在我们最初看到的过程中。</p>
<p>发言人   01:11:35<br>Okay, any questions about? I think I’m going to leave off stepping through the code at this point.<br>好的，有什么问题吗？我想在这一点上我将停止逐步通过代码。</p>
<p>发言人   01:11:44<br>Any questions about any of the material that we’ve seen? Oh, sorry, if it was, for example, this coyot, then we would see that our r.y. would point somewhere to like sleep or something like that, right? Yes, well, we’d see the where at this point would include some system called implementation functions and a call to sleep as it happens, I think, I mean, you’re basically the answer to your question is yes, left off executing this process for some reason other than time or interrupt switch would be basically returning to some system call code instead of to ski. As it happens, I think sleep may call ski. The back trace would look different and it would just happen include Scad. But yes, so I’ve chosen just one way of, you know, just one way of switching between processes due to timer. It interrupts the, but you also get switches to wait for user IO or to wait for other processes to do things like write to a pipe.<br>对我们看到的任何材料有疑问吗？哦，对不起，如果它是，例如，这个coyot，那么我们会看到我们的r.y。 会指向某个地方，比如睡眠或类似的东西，对吧？是的，我们会看到在这一点上，将包括一些称为实现函数的系统以及在发生时调用sleep，我认为，我的意思是，你的问题的答案基本上是肯定的，由于时间或中断开关之外的其他原因，如果不执行此过程，基本上会返回到某些系统调用代码，而不是返回到ski。事实上，我认为睡眠可以称之为滑雪。回溯轨迹看起来会有所不同，它只会发生包括Scad。但是，是的，所以我只选择了一种方式，你知道，由于计时器而只是一种在进程之间切换的方式。它会中断，但您也可以使用开关来等待用户IO或等待其他进程执行诸如写入管道之类的操作。</p>
<p>发言人   01:12:58<br>Okay, one thing to you probably noticed is that scheduler called Switch. And we’re about to return from Switch here, but we’re returning really from a different call to Switch than the one the scheduler made. We’re returning from a call to Switch that this process made a long time ago. So, you know, this is potentially a little bit confusing. But now this is how the guts of a thread switch work.<br>好的，你可能注意到的一件事是调度程序被称为交换机。我们即将从这里的交换机返回，但实际上我们是从与调度器所做的不同的交换机调用返回。我们从很久以前的一个电话中返回来切换这个过程。所以，你知道，这可能有点令人困惑。但现在这就是线程开关的工作原理。</p>
<p>发言人   01:13:25<br>Another thing to notice is that the code we’re looking at, the switch code, this is really the heart of thread switching. And really all you have to do to switch switch threads is save registers and restore registers. Now, Now threads have a lot more state than just registers. They have variables and stuff in the heap, and who knows what all that other state is in memory and isn’t going to be disturbed. We’ve done nothing to disturb any of these threads, stacks, for example, or heap values. So the registers in the microprocessor are really the only kind of volatile state that actually needs to be saved and restored to do a thread switch. All this stuff’s in memory stack, for example, will still be in memory on undisturbed. And so it doesn’t have to be explicitly saved and restored.<br>另一件需要注意的事情是，我们正在查看的代码，切换代码，这实际上是线程切换的核心。切换线程所需要做的就是保存寄存器和恢复寄存器。现在，线程拥有的状态远不止是寄存器。它们在堆中有变量和东西，谁知道内存中的其他状态是什么，并且不会受到干扰。我们没有做任何事情来干扰这些线程、堆栈或堆值。因此，微处理器中的寄存器确实是唯一需要保存和恢复以进行线程切换的易失性状态。例如，所有这些东西都在内存堆栈中，仍然会在不受干扰的情况下保留在内存中。因此它不必明确地保存和恢复。</p>
<p>发言人   01:14:16<br>Now we’re only saving and restoring microprocessor, the CPU registers, because we want to reuse those very registers in the CPU for the new thread and overwrite whatever values they have. So that’s why we have to see the old threads registers.<br>现在我们只保存和恢复微处理器的CPU寄存器，因为我们希望在新线程中重用这些寄存器并覆盖它们所拥有的任何值。这就是为什么我们必须看到旧线程注册的原因。</p>
<p>发言人   01:14:33<br>What about other processor? So I don’t know if the risk 5 processor that we’re using has other flags, but I know like some x 86 Intel chips have like like the floating point unit state and like things like that do, do we just not have that in spin in Arbor? Your point very well taken.<br>其他处理器怎么样？所以我不知道我们正在使用的风险5处理器是否有其他标志，但我知道像一些x86英特尔芯片一样有浮点单元状态等类似的东西，我们只是没有在Arbor中旋转吗？你的观点被很好地采纳了。</p>
<p>发言人   01:14:51<br>On other microprocessors like x 86, the details of switching are a bit different because, you know, they have different registers in different state. And so the code, you know, this is very, very risk 5 dependent code. And the switch routine for some other or processor might look quite different, like indeed might have to save floating point registers. Now risk 5 actually uses the general purpose register. Actually I’m not sure what it does for floating point, but the kernel doesn’t use floating point, so it doesn’t have to worry about it. But yeah, this is totally microprocessor dependent.<br>在其他微处理器 (如x86) 上，切换的细节有些不同，因为你知道，它们在不同状态下有不同的寄存器。所以这些代码，你知道，这是非常依赖于风险5的代码。并且某些其他处理器或处理器的开关例程可能看起来完全不同，例如确实可能需要保存浮点寄存器。现在风险5实际上使用通用寄存器。实际上我不确定它对浮点有什么作用，但内核不使用浮点，所以它不必担心它。但是，是的，这完全依赖于微处理器。</p>
<p>发言人   01:15:31<br>A question about the timer interrupts. So it sounds like the core of all of the scheduling working is that there will be a timer interrupt. What happens in cases where that malfunctions? There is going to be a timer interrupt. So, okay, so the.<br>关于计时器中断的问题。所以听起来所有调度工作的核心是会有计时器中断。发生故障的情况下会发生什么？将会有一个计时器中断。所以，好吧，所以。</p>
<p>发言人   01:15:55<br>Reasoning for how come preemptive scheduling of user processes works is that user processes execute with interrupts turned on. Always you execute 6 just ensures that interrupts are enabled before returning to user space. And that means that a timer interrupt can happen if you’re executing a user space. So there’s nothing a user process. If we’re in user space, the timer interrupt just will happen when the time comes.<br>对用户进程抢占式调度工作原理的推理是，用户进程在中断打开的情况下执行。总是执行6只是确保在返回用户空间之前启用中断。这意味着如果您正在执行用户空间，可能会发生计时器中断。所以没有什么是用户进程。如果我们在用户空间中，计时器中断只会在时间到来时发生。</p>
<p>发言人   01:16:24<br>It’s a little trickier when the kernel, the kernel sometimes turns off interrupts. Like when you acquire lock, the interrupts are going to be turned off until you release it so. So if there were some bug in the kernel, you know, if the kernel turned off interrupts and never turn them back on, and the code in the kernel never gave up the CPU, you know, never called sleep or gave up the CPU for any other reason, then indeed a timer interrupt wouldn’t occur. And that would mean that this kernel code may, you know, we would never give the CPU. But in fact, as far as we know Xb six wrote Xb 6 that it always turns interrupts back on. Or, you know, if there’s code in Xd 6 that turns off interrupts, it either turns them back on. And so timer interrupt can then occur in the kernel. And we can switch away from this kernel thread, or the code returns back to user space.<br>当内核时，有时内核会关闭中断，这有点棘手。就像当你获得锁时，中断将被关闭，直到你释放它。因此，如果内核中有一些错误，如果内核关闭了中断并且从未重新打开它们，并且内核中的代码从未放弃CPU，您知道，从未调用sleep或出于任何其他原因放弃了CPU，那么实际上就不会发生计时器中断。这意味着这个内核代码可能，你知道，我们永远不会给CPU。但事实上，据我们所知，Xb six写了Xb 6，它总是把中断重新打开。或者，你知道，如果Xd 6中的代码关闭中断，它要么将它们重新打开。这样，内核中的计时器中断就会发生。我们可以从这个内核线程切换，或者代码返回到用户空间。</p>
<p>发言人   01:17:23<br>Kernel code returns back to user space. We believe there’s never a situation in which kernel code will simply like loop with interrupts turned off forever.<br>内核代码返回到用户空间。我们相信，在内核代码中永远不会像循环一样关闭中断。</p>
<p>发言人   01:17:33<br>I got it, my question was more about like, so I assume the interrupts are actually coming from some piece of hardware. Like what if that piece of hardware malfunctions, no? No, it’s then your computer is broken and you should buy a new 1, okay? I mean, that’s a valid question for there’s, you know, 10 billion transistors in your computer. And indeed, sometimes the hardware that has bugs in it, but that’s beyond our reach for I, if you add one on one and the computer says three, then you just have deep problems XV 6 can’t help you with. So we’re assuming that the computer works.<br>我明白了，我的问题更多是关于像，所以我假设中断实际上来自某个硬件。比如，如果那个硬件出现故障怎么办，不是吗？不，那么你的电脑坏了，你应该买一个新的，好吗？我的意思是，这是一个有效的问题，因为你的电脑里有100亿个晶体管。事实上，有时硬件会出现错误，但这超出了我们的能力范围，如果你一对一地添加，而计算机显示为三，那么你就会遇到深层次的问题，XV 6无法帮助你。所以我们假设计算机正常工作。</p>
<p>发言人   01:18:20<br>The only time when that when software, there are times when software tries to compensate for hardware level errors. If you’re sending packets across a network, you always send a checksum so that if the network hardware flips a bit, malfunctions, and flips a bit, then you can correct that. But for stuff inside the computer that people tend not to. People basically don’t try to make the software compensate for hardware errors.<br>只有在使用软件时，有时软件会尝试补偿硬件级别的错误。如果您通过网络发送数据包，您始终发送校验和，以便如果网络硬件翻转一点，故障，翻转一点，那么您可以纠正。但是对于计算机内部的东西，人们往往不会使用。人们基本上不会试图让软件补偿硬件错误。</p>
<p>发言人   01:18:54<br>Oh, I have a question. Why? So like in trampoline DOC in Switch, we write the code in assembly. Is that why is that? Because we want to make sure that exactly this thing’s happening? So we can not, we can not write it and see because we just need those like those exact things to happen, basically. Yeah? Certainly, we want this exact sequence to happen.<br>哦，我有一个问题。为什么？就像在蹦床文档中的开关一样，我们用汇编编写代码。这是为什么？因为我们想确保这件事正在发生？所以我们不能，我们不能写出来看，因为我们基本上只需要那些确切的事情发生。是吗？当然，我们希望这个确切的顺序发生。</p>
<p>发言人   01:19:26<br>And in C, it’s very hard to talk about things like RA and C or Sp. Certainly there’s no way within the C language to talk about changing the stack pointer or the RA register. So these are things that just can’t be, you can’t say it ordinary C, the only way you can say it and see is there is it’s possible in C to sort of embedded assembly instructions in C code. That’s we could have just embedded these assembly instructions in AC function, but it would amount to the same thing. We’re basically we’re operating at a level below below C, so we can’t really use C here.<br>在C中，很难谈论像RA和C或Sp这样的事情。当然，在C语言中没有办法谈论更改堆栈指针或RA寄存器。所以这些是不能存在的东西，你不能说普通的C语言，你能说出和看到的唯一方法是在C语言中是否有可能在C语言代码中嵌入汇编指令。我们可以将这些汇编指令嵌入到交流函数中，但这相当于同样的事情。我们基本上是在低于C的水平下操作，所以我们在这里不能真正使用C。</p>
<p>发言人   01:20:14<br>I have a question about when a thread finishes executing. I’m assuming that happens in the user space when we call the exec. I’m sorry, exit system call. And that also ends the process. The thread I’m assuming in the kernel space, but if the thread ends within before a new time interrupt happens, does it still like? Is this like the CPU still acquired by that thread? Or do we end that thread and start a new one before the new time interrupt? Oh yeah?<br>我有一个关于线程何时完成执行的问题。我假设当我们调用exec时，这发生在用户空间中。我很抱歉，退出系统呼叫。这也结束了这个过程。我假设的线程在内核空间中，但是如果线程在新的时间中断发生之前结束，它仍然像吗？这就像那个线程仍然收购的CPU吗？或者我们在新的时间中断之前结束那个线程并开始一个新的线程？是吗？</p>
<p>发言人   01:20:49<br>The thread yields the CPU, the exit, exit yields the CPU. So there’s actually many points, even though I’ve been driving this discussion with the timer interrupt. In fact, in almost almost all cases where XV six switches between threads, it’s not due to timer interrupts, it’s because some system call is waiting for something or decides that that needs to give up the CPU. And so for example, exit does various things and then calls yield to give up the CPU, and it does that. It’s really nothing. It does that independently of whether there’s a timer interrupt.<br>线程产生CPU，退出产生CPU。所以实际上有很多要点，尽管我一直在用计时器中断推动这个讨论。事实上，在几乎所有的情况下，XV 6在线程之间切换，这不是由于计时器中断，而是因为一些系统调用正在等待某些东西或决定需要放弃CPU。例如，exit会做各种事情，然后调用yield放弃CPU，它会这样做。真的没什么。它的作用与是否有计时器中断无关。</p>
<p>发言人   01:21:31<br>Yes?<br>是的？</p>
<p>发言人   01:21:37<br>All right, the time is up for this lecture. I think I’ll continue some of this discussion next week, but I’m happy to take more questions right now if people have them.<br>好的，这个讲座的时间到了。我想下周我会继续一些讨论，但如果人们有更多的问题，我很乐意现在回答更多的问题。</p>
<p>发言人   01:21:52<br>So let’s say the operating system actually takes on the thread implementation. For example, you want to run multiple threads of a process on multiple CPU is like that has to be handled by the OS. That can not be handled in user space, right? How does that kind of switching work? Is each thread now becomes the same as the process? Like, is there always going to loop through all existing threads? Or, you know, because like each CPU will still switch between even if 1 process has give me 8 cores, like it’s still going to switch, switch each of the Cpu’s between those and then couple of other processes. And then also we don’t want to really switch like between one and the other thread on the same CPU.<br>因此，假设操作系统实际上采用了线程实现。例如，您想要在多个CPU上运行一个进程的多个线程就像必须由操作系统处理一样。这无法在用户空间中处理，对吗？这种切换是如何工作的？现在每个线程都变得与进程相同了吗？就像，总是要循环遍历所有现有的线程吗？或者，你知道的，因为就像每个CPU仍然会切换，即使一个进程给了我8个核心，就像它仍然会切换一样，每个Cpu在这些进程和几个其他进程之间切换。然后我们也不想在同一CPU上的一个线程和另一个线程之间真正切换。</p>
<p>发言人   01:22:36<br>Or do we, I don’t know, wait, can. I’m not sure what the question is. Yeah, I guess, I guess, can you just explain more like how does that happen? How does, so how does that happen?<br>或者我们，我不知道，等待，可以。我不确定问题是什么。是的，我想，我想，你能解释一下这是怎么发生的吗？这是怎么发生的呢？</p>
<p>发言人   01:22:51<br>Let’s say we have multiple threads per process so that they can, they can run on different Cpus. How do, what do we go? How do we go about there? Yeah, so Linux, for example, supports multiple threads per process. And in Linux, the implementation, it’s a complex implementation, but maybe the simplest way to explain it is that each it’s almost as if each thread in Linux is a complete process, the threads of a given, what we would call the threads of a particular process, are essentially separate processes that share the same memory. So Linux has sort of separated out the notion of thread of execution from address space. And you know, you have them separately. And if you make 2 threads in one process, it basically makes two processes that share one address space, and then from then on, the scheduling is not unlike what XV 6 does for individual processes I see.<br>假设我们每个进程有多个线程，以便它们可以在不同的CPU上运行。怎么做，我们该怎么办？我们该怎么去那里？是的，所以Linux，例如，支持每个进程有多个线程。在Linux中，实现是一个复杂的实现，但也许最简单的解释方式是，Linux中的每个线程几乎都是一个完整的进程，给定的线程，我们称之为特定进程的线程。本质上，它们是共享相同记忆的独立进程。Linux已经将执行线程的概念从地址空间中分离出来了。而且你知道，你把它们分开。如果你在一个进程中创建两个线程，它基本上会使两个进程共享一个地址空间，从那时起，调度就像我看到的XV 6对单个进程所做的那样。</p>
<p>发言人   01:23:52<br>And then the, is there anything like, does the user have to specify like, okay, pin each thread to a CPU or or how does the OS make sure that different threads of the same process don’t run on the same core? Because that’s kind of defeating the purpose or not, I guess. I don’t know the, it’s actually just like, it’s much like Xb 6, namely the, you know, there’s 4 cores and Linux will just find 4 things to run on those 4 cores. They may be, you know, if there’s not much going on, then maybe there’ll be 4 threads of the same process or if there’s 100 users logged in on an Athena machine, maybe it’s one thread each from multiple different processes, you know? There’s not any one answer. Or the colonel basically finds something for each core to do, and then that court does that thing. Okay, that makes sense. You can, you know, if you’re, if you want to do careful measurements, there is a way to pin threads to cores, but people only do it when they’re up to something strange.<br>然后，用户是否必须指定，例如，好的，将每个线程固定到一个CPU，或者操作系统如何确保同一进程的不同线程不在同一核心上运行？因为那有点违背目的，我猜。我不知道，实际上就像，它很像Xb 6，也就是说，你知道，有4个核心，Linux只会找到4个东西在这4个核心上运行。它们可能是，你知道，如果没有太多的事情进行，那么可能会有相同进程的4个线程，或者如果有100个用户登录到Athena机器上，可能每个线程来自多个不同的进程，你知道吗？没有任何一个答案。或者上校基本上为每个核心找到一些事情要做，然后法院来做那件事。好吧，那很感知。你可以，你知道，如果你想进行仔细的测量，有一种方法可以将线程固定在内核上，但人们只有在做一些奇怪的事情时才会这样做。</p>
<p>发言人   01:25:00<br>So they share the same virtual table, you say again. So they say they have the same page table threads. Yeah. If you’re on Linux, if you create 2 threads in one process, then you have these two threads that. I don’t know if they like literally share the exact same page table or whether their page tables are identical, one or the other. Is there a reason why they would have to be separate ever?<br>所以它们共享同一个虚拟表，你再说一遍。所以他们说他们有相同的页表线程。是的。如果你在Linux上，如果你在一个进程中创建了2个线程，那么你就有了这两个线程。我不知道他们是否真的共享完全相同的页表，或者他们的页表是相同的，一个还是另一个。他们为什么必须分开吗？</p>
<p>发言人   01:25:32<br>If you manually map memory or I don’t know enough to know whether which Linux does?<br>如果您手动映射内存，或者我不知道哪个Linux会做什么？</p>
<p>发言人   01:25:44<br>Okay, I have another question about like a small detail. So basically, like from my understanding, when you call switch, you switch from one call to switch to another. So the first time you call switch, you have to like kind of artificially create other endpoint to come back to, right? Yes, because you can’t just randomly jump into any code. Yes, you want to know where that, where that fake, where that context is cooked up? Probably somewhere where the process is created. Now, I guess, I don’t know. Yeah, maybe user in it or not user in alloc proc.<br>好的，我还有一个关于小细节的问题。基本上，就像我的理解一样，当你呼叫开关时，你从一个呼叫切换到另一个呼叫。所以当你第一次呼叫交换机时，你必须人为地创建其他端点才能返回，对吧？是的，因为你不能随意跳入任何代码。是的，你想知道那个在哪里，那个假的，那个背景是在哪里炮制的吗？可能是创建流程的某个地方。现在，我想，我不知道。是的，可能是用户在其中，也可能不是分配过程中的用户。</p>
<p>发言人   01:26:31<br>There’s something called fork trap or something. Yeah, look at this. Yeah, fork red.<br>有一种叫做叉子陷阱或其他东西的东西。是啊，看看这个。是，叉子红色。</p>
<p>发言人   01:26:39<br>Okay, so in alloc proc, which is called both for the very first process at boot time and by fork, alloc proc sets up the critical elements of the context for the new processes, it sets up the new processes context, It actually doesn’t matter what most of the registers are, but it doesn’t matter what RA is because that’s where the switch, the very first switch in that process is going to return to RA. And that process is going to need to use its own stack. So rnsp are set up or faked, essentially, so that the very first switch or process works. So if I understand this correctly, like when the switch will happen, then it’ll basically just start executing the first instruction inside of the four cred, as if for cred just called switch and return from. Yeah. The return from switch is going to be a jump to the beginning of fork red, right?<br>好的，在alloc proc中，它在启动时被第一个进程调用，也被fork调用，alloc proc为新进程设置上下文的关键元素，它设置新进程的上下文，实际上大多数寄存器都是什么并不重要，但RA是什么并不重要，因为那是开关的地方，这个过程中的第一个开关将返回RA。并且该过程将需要使用自己的堆栈。因此，rnsp基本上是设置或伪造的，因此第一个切换或进程就能正常工作。所以如果我正确理解了这一点，比如开关什么时候发生，那么它基本上就会开始执行四个cred中的第一个指令，就好像cred只是调用switch并从中返回。是的。开关的回归将是跳转到分叉红色的开始，对吧？</p>
<p>发言人   01:27:39<br>Interesting, do we ever call for credit or is it always happen? I think it always happens like this. I don’t think anything ever calls for CT for real. I think it’s just, yeah, it’s only executed in this weird way from the first time a process is run. And it’s really his job is to release the lock that the scheduler took and then return. And then this user trap red, of course, is also fake that it’s, you know? Yeah, it’s like it’s as if returning from a trap except the trap frame is faked also to have to like jump to the first instruction and the user right code. Oh, but the trap frame, it’s again the same, like you don’t need to initialize any registers because it’s like, well, we’re going to the beginning, so you don’t need to assume anything.<br>有趣的是，我们曾经呼吁信用还是总是会发生？我认为它总是这样发生。我不认为任何事情都需要真正的CT。我认为这只是，是的，它只是在进程第一次运行时以这种奇怪的方式执行。他的工作实际上是释放调度程序所使用的锁定，然后返回。然后这个用户陷阱红色，当然也是假的，你知道吗？是的，就像从陷阱中返回一样，除了陷阱框架是伪造的，还必须跳转到第一个指令和用户正确的代码。哦，但是陷阱帧还是一样的，就像你不需要初始化任何寄存器一样，因为它就像我们要从头开始，所以你不需要假设任何东西。</p>
<p>发言人   01:28:34<br>Yeah, the program counter, I think. Needs to be initialized to 0. I don’t know what else. Yeah, maybe, Maybe it. And probably if we call them, it doesn’t, right? Because if we already do the call, then that’s going to set the program counter, yeah, so here’s that. This only happens. Oh, because fork copies, fork copies the program counter, the user program counter. And so the only time when we’re not doing a fork is for the very first process where it’s like explicitly to set design and stack pointer.<br>是的，我想是程序计数器。需要初始化为0。我不知道还有什么。是的，也许，也许吧。也许如果我们打电话给他们，就不会了，对吧？因为如果我们已经进行了调用，那么这将设置程序计数器，是的，这是那个。这只是发生了。哦，因为fork复制，fork复制程序计数器，用户程序计数器。因此，我们唯一不进行分叉的时候是在第一个过程中，就像明确设置设计和堆栈指针一样。</p>
<p>发言人   01:29:08<br>Yeah, so needs to be set up. Oh yeah, because it’s that’s EPC, that’s not PC, that’s the one that’s going to get swapped by the trampoline, yes. Oh, I see because the real PC is actually going to be INRA like inside traveling, but then we’re going to switch it to jump to there. Yeah, interesting. Can I just ask like, can you go back to the AOC proc?<br>是的，所以需要设置。哦，是的，因为那是EPC，那不是PC，那是要被蹦床交换的，是的。哦，我明白了，因为真正的电脑实际上将像内部旅行一样INRA，但是我们将把它切换到那里。是的，有趣。我可以问一下，你能回到AOC proc吗？</p>
<p>发言人   01:29:44<br>I think there’s, oh, no, sorry for Cre. There’s something there that happens. I think for the first process only. What’s this for a first call? I wasn’t really sure what happened.<br>我认为有，哦，不，对不起。那里发生了一些事情。我认为这只是第一个过程。第一次打电话给你是什么意思？我不是很确定发生了什么。</p>
<p>发言人   01:29:59<br>Let’s see the file, the file system needs to be initialized and in particular, some stuff needs to be read off the disk in order to get the file system going. Either like the there’s this thing called the super block, which describes like how big the file system are, is and where the various things are in the file system. And there’s also a crash recovery log that needs to be replayed in order to recovered from a previous crash if there was one, but in order to do anything in the file system, you need to be able to wait for disk operations to complete. But the way XV 6 works, you really can only execute the file system code in the context of a process. In order to like wait for IO, and so therefore, the initialization of the file system has to be deferred until we, the first time we have a process running. And that occurs in the very first process in fork ret. I see, and I’m guessing we’ll learn more about this later.<br>让我们看看文件，文件系统需要初始化，特别是需要从磁盘读取一些内容才能启动文件系统。像有一个叫做超级块的东西，它描述了文件系统的大小以及各种东西在文件系统中的位置。还有一个崩溃恢复日志需要重播，以便从之前的崩溃中恢复，但是为了在文件系统中执行任何操作，您需要能够等待磁盘操作完成。但是XV 6的工作方式，您实际上只能在进程的上下文中执行文件系统代码。为了喜欢等待IO，因此文件系统的初始化必须推迟到我们第一次运行进程时。这发生在fork ret的第一个过程中。我明白了，我猜我们稍后会了解更多。</p>
<p>发言人   01:31:05<br>Yeah, not about this horrible about how file systems work, all right, okay, well, thank you. I’m sorry for holding off you not so long, sorry for all the answers. Sorry, is that going in that process when this thing is executed?<br>是的，不是关于文件系统如何工作的可怕之处，好的，好的，谢谢。对不起，我没有等你那么久，对不起所有的答案。抱歉，当这个东西执行时，它会进入那个过程吗？</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>操作系统工程 010-Thread Switching</div>
      <div>http://example.com/2025/10/18/6S081-010/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月18日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/18/6S081-011/" title="操作系统工程 011-QA2 COW lab">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">操作系统工程 011-QA2 COW lab</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/18/6S081-009/" title="操作系统工程 009-Multiprocessors and Locks">
                        <span class="hidden-mobile">操作系统工程 009-Multiprocessors and Locks</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
