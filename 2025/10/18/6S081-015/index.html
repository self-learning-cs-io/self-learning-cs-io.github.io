

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="发言人   00:02All right, actually, it’s time to start. All right, okay, as Franz was saying, feel free to interrupt with questions and feel free to leave your camera on so that we can see each other as p">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统工程 015-FileSystem Performance and Fast Crash Recovery">
<meta property="og:url" content="http://example.com/2025/10/18/6S081-015/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="发言人   00:02All right, actually, it’s time to start. All right, okay, as Franz was saying, feel free to interrupt with questions and feel free to leave your camera on so that we can see each other as p">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-18T02:00:15.000Z">
<meta property="article:modified_time" content="2025-10-19T11:16:51.143Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>操作系统工程 015-FileSystem Performance and Fast Crash Recovery - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="操作系统工程 015-FileSystem Performance and Fast Crash Recovery"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-18 10:00" pubdate>
          2025年10月18日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          23k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          189 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">操作系统工程 015-FileSystem Performance and Fast Crash Recovery</h1>
            
            
              <div class="markdown-body">
                
                <p>发言人   00:02<br>All right, actually, it’s time to start. All right, okay, as Franz was saying, feel free to interrupt with questions and feel free to leave your camera on so that we can see each other as people.<br>好的，实际上，是时候开始了。好的，好的，就像弗兰兹说的，随时可以打断别人提问，也可以随时把相机放下，这样我们就可以像人一样互相看到了。</p>
<p>发言人   00:19<br>This is going to be another lecture about logging, this time a case study of the current logging since the system in linuxes ext 3 file system, which is extremely widely used. And we’ll try to dip into some of the kind of real world design problems that a high performance file system has to deal with when it adds a log into the file system I’m just going to.<br>这将是另一场关于日志记录的讲座，这次是对linuxes ext 3文件系统中当前日志记录系统的案例研究，该系统被广泛使用。我们将尝试探讨一些现实世界的设计问题，这些问题是高性能文件系统在向文件系统添加日志时必须处理的。</p>
<p>发言人   00:43<br>I’m going to spend a few minutes basically reviewing why we’re talking about logging. The reason we feel logging is pretty important is that it’s been a tremendously successful and important idea. It’s almost like logging is kind of a magic way to add crash recovery to any, almost any existing storage system. It’s sort of a, in many ways, pretty orthogonal to whatever it is you’re actually trying to store. And so you see logging applied in a huge number of different storage situations, certainly databases and file systems, but also many very specialized systems that need to store things and recover after crashes. You also see logging used a lot in distributed systems as a way of organizing the recovery from failure.<br>我将花几分钟时间基本上回顾一下为什么我们在谈论日志记录。我们认为伐木非常重要的原因是这是一个非常成功和重要的想法。这几乎就像日志记录是一种神奇的方式，可以为任何现有的存储系统添加崩溃恢复功能。在很多方面，它与你实际尝试存储的任何东西都相当正交。因此，您可以看到日志记录应用于大量不同的存储情况，特别是数据库和文件系统，但也有许多非常专门的系统需要存储内容并在崩溃后恢复。您还可以看到，日志记录在分布式系统中被广泛用作组织故障恢复的一种方式。</p>
<p>发言人   01:34<br>Because among other things, logging is kind of a structured way of saying, well, here’s all the things that happened just before the crash. If we can understand them, then maybe we can recover from the crash more easily. Plus, there’s a huge amount of it. Interesting stuff to chew on when you try to build high performance logging systems.<br>因为除其他事项外，日志记录是一种结构化的方式，表示以下是崩溃前发生的所有事情。如果我们能够理解它们，那么也许我们可以更容易地从崩溃中恢复过来。另外，还有很多。当你试图构建高性能日志系统时，需要考虑的有趣的东西。</p>
<p>发言人   01:57<br>And as I mentioned a few minutes ago, just as terminology, when we talk about log, it’s talking about this exactly the same thing as today’s reading was talking about when it said use the word journal, just synonym. And furthermore, today’s reading talked about adding a journal to Ex two, The modern name for the resulting file system is Ex 3. Which is how I’m going to refer to it, okay? So I want to spend the way I’m going to kind of talk about Ex 3 is by contrasting it to some extent with XV 6 and explaining ways in which Ex 3 fixes some performance problems that XV 6 logging has. And along the way, it changes a few of the semantics of.<br>正如我几分钟前提到的，就像术语一样，当我们谈论日志时，它所谈论的与今天的阅读完全相同，当它说使用 “journal” 这个词时，只是同义词。此外，今天的阅读还讨论了在Ex two中添加一个日志，生成的文件系统的现代名称是Ex 3。这就是我将如何引用它，好吗？所以我想用这种方式来谈论Ex 3，将它与XV 6进行一定程度的对比，并解释Ex 3如何解决XV 6日志记录的一些性能问题。一路上，它改变了一些语义。</p>
<p>发言人   02:52<br>What happens during crashes? All right, so this is sort of XV 6 log review, if you remember. We have a disk, the file system disk for XV 6 know. You can think of it as having two parts. It’s got a file system tree on it with a root directory. And under the root directory, maybe there’s other directories. And in those, so this might be directory 1 and directory 2, we can think of this as the file system is just a data structure.<br>崩溃期间会发生什么？好的，如果你还记得的话，这有点像XV 6的日志审查。我们有一个磁盘，XV 6的文件系统磁盘知道。你可以把它想象成有两部分。它有一个具有根目录的文件系统树。在根目录下，可能还有其他目录。在那些中，这可能是目录1和目录2，我们可以将其视为文件系统只是一个数据结构。</p>
<p>发言人   03:31<br>It’s a tree structured data structure. Maybe it has files sitting in the directories, and each file has block numbers of a bunch of blocks in it. And there’s some other data that’s not really tree structure, like there’s the bit map that indicates for every block whether that block is free or allocated. And the inodes and the directory contents and the bit that blocks, we’re going to refer to as metadata.<br>它是一种树状结构的数据结构。可能它在目录中有文件，每个文件都有块编号，其中有一堆块。还有一些其他数据不是真正的树结构，就像有一个位图指示每个块是空闲的还是已分配的。以及索引节点、目录内容和阻塞的位，我们将其称为元数据。</p>
<p>发言人   04:02<br>In contrast to blocks that hold file content, which we’ll call file content blocks.<br>与保存文件内容的块相反，我们将其称为文件内容块。</p>
<p>发言人   04:08<br>Okay? So in addition to the file system XP 6 has a log. It’s near the beginning of the disk. And XV 6 log is relatively simple, it has this header block. And then some number of blocks that contain updated versions of blocks from the file system, both data blocks and metadata blocks. And in this initial header block, there’s the block numbers where these blocks in the log ought to be written to, like maybe the first one should go to block 17 and then 29, who know, whatever it might be.<br>好吗？因此，除了文件系统之外，XP 6还有一个日志。它接近磁盘的开头。XV 6日志相对简单，它有这个头块。然后是一些包含文件系统块更新版本的块，包括数据块和元数据块。在这个初始标头块中，有日志中这些块应该写入的块编号，就像也许第一个应该转到第17块，然后是29，谁知道呢，不管它是什么。</p>
<p>发言人   04:51<br>And then in the computer, we have some user process that’s maybe calling write or create or some other system call that modifies the file system. And there’s a block cache in the computer. And initially, the rights just go to the block cache. Those are just copies of blocks from the disk. So initially, write or update some file blocks or inodes or whatever those rates go there. And then at the end of an operation, these blocks are copied to the log. And when we’ve copied all the blocks to the log, then we write the block numbers of the header block to indicate that this transaction’s worth of updates is complete.<br>然后在计算机中，我们有一些用户进程，可能调用write或create或其他修改文件系统的系统调用。并且计算机中有一个块缓存。最初，权限只转到块缓存。这些只是磁盘块的副本。所以最初，编写或更新一些文件块或索引节点或其他速率。然后在操作结束时，这些块被复制到日志中。当我们将所有块复制到日志中时，我们写下标题块的块数，以指示此交易的最新进展价值已完成。</p>
<p>发言人   05:39<br>And in the code for the file system, you’ll see that every system call that modifies the file system somewhere has a begin up, which says I about to start a group of updates to the file system. Please don’t do any of them until I’m finished. So we have A, and then there’s a bunch of blocked reads and writes and then end up, which tells the file system, logging system I’ve completely done all the rights I’m going to do. So between the begin op and the end up, the rights only go to the cache. And when the system call makes this end up call, then the file system copies the modified blocks from the cache into the log. And after it’s written, all these modified blocks into the log, only then does the file system write the block numbers in a single disk rate to the header block. And that’s called the commit point. This is the point before the file system wrote these block numbers to the header block.<br>在文件系统的代码中，您将看到每个修改文件系统的系统调用都有一个起点，表示我即将启动一组最新进展到文件系统。请在我完成之前不要做任何事情。所以我们有一个，然后有一堆被阻止的读取和写入，然后最终告诉文件系统，日志系统我已经完全完成了我要做的所有权利。因此，在开始操作和结束之间，权限只会转到缓存。当系统调用完成此最终调用时，文件系统会将修改后的块从缓存复制到日志中。并且在将所有这些修改的块写入日志之后，文件系统才会以单个磁盘速率将块编号写入标题块。这就是所谓的提交点。这是文件系统将这些块号写入标头块之前的要点。</p>
<p>发言人   06:43<br>If a crash had happened, then none of these rights would have been applied after the crash and reboot.<br>如果发生了崩溃，那么在崩溃和重新启动后，这些权利都不会被应用。</p>
<p>发言人   06:50<br>After the file system writes these block numbers of the header block after that disk graded is complete, then it’s guaranteed that even if there’s a crash at this point, the recovery software will look at the log, see that there’s block numbers in the header block, and write all these blocks that are mentioned in the header block to their home locations in the file system. And so what’s going on in here is this is a technique to allow all of the rights that happen in the system between the begin up and the end up to be atomic with respect to crashes that is either all of them happen because the file system got as far as rating the header block before the crash, or none of them happened because the crash happened before the file system wrote the header block. And so it’s important that after a crash and restart, there’s some recovery software that runs that reads the log looks at the header block and decides is the header block actually have block numbers in it or not? If it does it write, it is possibly rewrites all these blocks to their home locations. If the header blocks doesn’t have any block numbers in it, then the recovery software does nothing. Any questions about this quick review?<br>在磁盘分级完成后，文件系统写入标题块的这些块号后，可以保证即使此时发生崩溃，恢复软件也会查看日志，查看标题块中的块号。并将标头块中提到的所有块写入文件系统中的主位置。因此，这里发生的是一种技术，它允许系统中发生的从开始到结束之间的所有权利都具有原子性，以避免崩溃。要么是因为文件系统在崩溃前对标头块进行了评级，要么是因为在文件系统写入标头块之前发生了崩溃，所以这些都没有发生。因此，重要的是，在崩溃并重新启动后，会有一些恢复软件运行，读取日志并查看标题块，并决定该标题块是否实际包含块编号？如果它这样做了写入，它可能会将所有这些块重写到它们的主位置。如果标题块中没有任何块编号，则恢复软件不执行任何操作。对这个快速回顾有什么问题吗？</p>
<p>发言人   08:10<br>Okay, there’s a couple of super important points. To remember about XV 6, and indeed most logging systems, 1 is that XV 6, all logging systems essentially obey what’s called the right ahead rule, that is. Whenever you have a bunch of rights done by some operation, and those rights all need to be atomic. The system has to write all of these updated, all the updated data to the log before it is allowed to apply any of those updates to the home locations in the file system. That is the we’re required to sort of prede all the updates that we want to have the atomic prede them in a log before we can apply any of them to the file system. That’s called the right ahead rule. And this is really the foundation of how logging allows crash recovery. The writer head rule allows this collection of updates to appear atomic with respect to crashes.<br>好的，有几个超级重要的点。要记住XV 6，实际上大多数日志系统，1是XV 6，所有日志系统基本上都遵守所谓的右前规则。每当您拥有由某个操作完成的一堆权限时，这些权限都需要是原子的。系统必须先将所有这些更新的数据写入日志，然后才能将任何这些最新进展应用到文件系统中的主位置。这就是我们需要先将所有我们想要的最新进展保存在日志中，然后我们才能将它们中的任何一个应用到文件系统。这被称为正确的前进规则。这实际上是日志记录允许崩溃恢复的基础。写入器head规则允许这个最新进展集合在崩溃时看起来是原子的。</p>
<p>发言人   09:19<br>There’s another rule I haven’t talked about. Which is that we can’t free or reuse the log? You know, we XV 6 uses the log over and over again, once for every system call. We can not allowed to reuse the log until all of the rights that are in the log have actually been written to their own locations on the disk. So there’s also what I’ll call a freeing rule. Which says we can’t overwrite or reuse the log until or the part of the log that holds a particular transaction set of rights that need to be atomic, we can’t reuse that part of the log until all of the rights that are in that part of the log, all of them had been reflected into the.<br>还有一条我没有谈论过的规则。这就是我们不能释放或重复使用日志的原因？你知道，我们XV 6一遍又一遍地使用日志，每次系统调用一次。在日志中的所有权限都被写入到磁盘上自己的位置之前，我们不能重复使用该日志。所以还有一个我称之为释放规则。这意味着我们不能覆盖或重用日志，直到包含特定事务权限集的日志部分需要是原子的，我们不能重用日志的这一部分，直到该部分日志中的所有权限为止。所有这些都反映在里面了。</p>
<p>发言人   10:11<br>Actual home locations of the file system. So the deal in XV 6 is that what endophyte enhances a whole lot of work? First file system, you know, as I mentioned, writes all the blocks to the log, writes the header log, writes the header log, and then the file system writes all these blocks to their home locations. This is assuming no crash, which is the ordinary case. So then the file system writes a second time, you know, all these blocks to the home locations on the disk, And then after the all the home locations have been updated, only then does the file system go XV 6 file system erase these block numbers from the header block indicate that we’re done with this transaction, and we can reuse the log and it’s critical to erase of the block numbers before writing anything new to the log because we wouldn’t want to be in a position where there were some block numbers from a previous transaction in the header, but blocks from a new transaction with presumably different block numbers sitting in the log, because then a crash would might apply these contents to the stale block numbers left over in the header block. So we have to erase the header block first. So this is freeing rule.<br>文件系统的实际主位置。所以在XV 6中的处理是什么内生真菌增强了大量的工作？第一个文件系统，你知道，正如我所提到的，将所有块写入日志，写入头日志，写入头日志，然后文件系统将所有这些块写入它们的主位置。这是假设没有崩溃，这是普通情况。然后文件系统第二次写入，你知道，所有这些块都写入磁盘上的主位置，然后在所有主位置更新后，只有这样，文件系统才会进行XV 6，文件系统从标头块中擦除这些块号表明我们已完成此事务，并且我们可以重用日志，并且在将任何新内容写入日志之前擦除块号是至关重要的，因为我们不想处于一个位置，其中有一些来自标题中前一个交易的区块编号，但来自一个新交易的区块编号可能不同，因为崩溃可能会将这些内容应用于标题块中留下的陈旧区块编号。所以我们必须首先删除标题块。这就是解放规则。</p>
<p>发言人   11:23<br>This is before we’re allowed to erase a transaction from the log, we have to write all of this block to the file system. Okay, so the net effect of this is to make file system updates, which can be complicated and require many writes. The net effects is to make each system called essentially be atomic. All its rates are none of them with respect to crashes.<br>这是在我们被允许从日志中删除交易之前，我们必须将所有这些块写入文件系统。好的，这样做的实际效果是使文件系统变得最新进展，这可能很复杂并且需要许多写入。净效应是使每个被称为基本上是原子的系统。所有的速率都不是关于崩溃的。</p>
<p>发言人   11:50<br>So the sort of bridge to Linux’s logging scheme is the question of what’s wrong with Xu 6 logging you. Why doesn’t Linux just use this? The same scheme that XV 6 DOS? And the answer is basically that it’s slow. The XV 6 scheme is quite slow. Every system call before a system call, like write or create, can return in XV 6.<br>因此，Linux日志计划的桥梁就是Xu 6日志出了什么问题的问题。为什么Linux不直接使用这个？XV 6做的是同样的方案？答案基本上是它很慢。XV 6方案相当慢。在系统调用之前的每个系统调用，如write或create，都可以在XV 6中返回。</p>
<p>发言人   12:14<br>All of this stuff I just talked about has to complete. So before your file creation system call can return to user space. It has to finish all the stuff that end up does, which means write every block to the block, write the header block, write all those blocks to the locations here, and then erase the header block. And then you can return. And during that time, not only does each system call take a long time, but nothing else could happen in the file system while any system call is committing and then writing its blocks to their home location. So the system calls really occur one at a time. And each system call requires many disk rights. And the technical term for every system call is to wait for all of its disk rates to complete is called synchronous.<br>我刚才谈到的所有东西都必须完成。因此，在您的文件创建系统调用可以返回用户空间之前。它必须完成所有最终完成的事情，这意味着将每个块写入块，写入标头块，将所有这些块写入此处的位置，然后擦除标头块。然后你就可以回去了。在此期间，不仅每个系统调用需要很长时间，而且当任何系统调用正在提交并将其块写入其主位置时，文件系统中不会发生其他任何事情。因此，系统调用确实一次发生一个。并且每个系统调用都需要许多磁盘权限。每个系统调用的技术术语是等待其所有磁盘速率完成，称为同步。</p>
<p>发言人   13:09<br>Probably spelled differently from that anyway. XV 6, the system calls are synchronous with respect to disk, right? So they’re very, very slow, horribly slow with mechanical hard drives because each write, you know, basically would take 10 milliseconds. We’re talking about many writes for system calls. So XV 6 could only do a few file system modifying system calls per second. If you ran XV 6 on a solid state drive, it’d be faster, but still like not nearly as efficient as it could be.<br>可能与那个拼写不同。在XV 6中，系统调用相对于磁盘是同步的，对吗？所以它们非常非常慢，使用机械硬盘时非常慢，因为每次写入基本上需要10毫秒。我们正在谈论许多针对系统调用的写入。因此，XV 6每秒只能执行几个文件系统修改系统调用。如果你在固态硬盘上运行XV 6，它会更快，但仍然不像它所能达到的那么高效。</p>
<p>发言人   13:40<br>Another more detailed thing to notice about this is that every block is written twice. In the XV 6 scheme, it’s written once to the log and then a second time to the disk. And so this is also something that there’s good reasons for that, but it’s something that Ex three partially fixes. Okay, so on the Linux is onto today’s reading and it’s sort of I’m going to talk about the.<br>另一个需要注意的更详细的事情是，每个块都被写入两次。在XV 6方案中，它被写入一次日志，然后第二次写入磁盘。因此，这也是有充分理由的，但这是经过三个部分修复的。好的，那么Linux已经进入今天的阅读，我将谈论它。</p>
<p>发言人   14:10<br>Ext 3 file system, which is what the today’s reading had turned into a few years later after a bit more development and was widely used.<br>Ext 3文件系统，这是今天的阅读在几年后经过更多的开发和广泛使用而变成的。</p>
<p>发言人   14:26<br>Ext 3, it’s actually a modification previous log list file system. And so they really did play this game of taking an existing storage system and sort of layering logging on top of it in a way that left the underlying Ex two file system almost unmodified, although not quite. And so in a sense, the logging was a very kind of, at least in principle, easy upgrade for them.<br>分机3，它实际上是对先前日志列表文件系统的修改。因此，他们确实玩了这个游戏，将现有的存储系统分层并在其上进行日志记录，以使底层的Ex 2文件系统几乎没有被修改，尽管不是完全没有修改。因此，在某种感知上，日志记录对于他们来说至少在原则上是一种非常容易的升级。</p>
<p>发言人   15:00<br>Pxt 3 keeps data structures that are similar to. To XV 6 S in memory, there’s a block cache. It’s a write back CA. So there’s a bunch of cache blocks. Some of them are clean in the sense that they haven’t been modified since, you know, identical to what’s in the disk, some of them dirty that they’ve been written to since they were read from the disk, and some of them were pinned and that they’re not allowed to be written back to the disk because of the write back rule. I mean, because of the freeing rule, the right ahead rule.<br>Pxt 3保持了类似于的数据结构。对于内存中的XV 6 s，有一个块缓存。这是一个回信的CA。所以有一堆缓存块。它们中的一些在感知上是干净的，因为它们没有被修改过，你知道，与磁盘中的内容相同，其中一些是脏的，因为它们是从磁盘中读取的，其中一些被固定了，由于写回规则，它们不允许写回磁盘。我的意思是，由于自由规则，提前权规则。</p>
<p>发言人   15:41<br>Ext 3 also maintains some transaction information. It can maintain information actually about multiple transactions that are concurrently in different stages of execution. So there might be a number of different transactions that the Ex 3 system is keeping track of each one.<br>Ext 3也维护一些交易信息。它可以维护有关同时处于不同执行阶段的多个事务的信息。因此，可能有许多不同的交易，前3系统正在跟踪每个交易。</p>
<p>发言人   16:07<br>Each transaction has a sequence number. A set of block numbers that the transaction system is logging system is remembering are blocks modified by that transaction. So these are. A set of block numbers. And this really refers to cache blocks because any modifications, at least initially, you happen only in the cache. And then a set of what are called handles. Which are information about system calls that are still currently executing? And as part of this transaction and reading and writing cached blocks? And on the disk.<br>每笔交易都有一个序列号。事务系统正在记录的一组块编号是由该事务修改的块。这些就是。一组区块编号。这实际上指的是缓存块，因为任何修改，至少最初只发生在缓存中。然后是一组所谓的手柄。哪些是关于当前仍在执行的系统调用的信息？作为此事务的一部分，读取和写入缓存块？在磁盘上。</p>
<p>发言人   16:56<br>On the disk, just like XV 6, there’s the usual file system tree with the inodes and directory blocks and files and whatnot. And there’s bitmap blocks indicating whether each block is data block is allocated or free. And so these are what I’ll be calling the home locations file system blocks.<br>在磁盘上，就像XV 6一样，有通常的文件系统树，包含inode、目录块、文件等等。并且有位图块指示每个块是否为数据块已分配或空闲。所以这些就是我将称之为家庭位置文件系统块的内容。</p>
<p>发言人   17:17<br>And then on a sort of designated part of the disk, there’s the log. And so, so far, this is pretty similar to XV 6. The main difference is the Ex three’s ability to keep track of multiple transactions at the same time, sort of different stages of their execution. Now I want to look more closely at what’s inside the log. In ext 3, it’s a bit different from what’s in the XV 6 log.<br>然后在磁盘的一种指定部分上，有日志。所以，到目前为止，这与XV 6非常相似。主要区别在于前三名能够同时跟踪多个交易，执行阶段有所不同。现在我想更仔细地看看日志里面有什么。在ext 3中，它与XV 6日志中的内容有点不同。</p>
<p>发言人   17:58<br>Really, the log format? At the beginning of the log, there’s something called the super block. And the super block, This is the log super block. Different from the file system super block, the log super block contains the offset and sequence number of the first valid transaction in the log. So it’s going to have an offset is just a byte number or block number in the log. And then the sequence number, remember I said that every transaction has its own sequence number. And then the rest of the log, the log is just a bunch of sequential blocks on disks of a known size.<br>真的吗，日志格式？在日志的开头，有一个叫做超级块的东西。超级块，这是日志超级块。与文件系统超级块不同，日志超级块包含日志中第一个有效事务的偏移量和序列号。因此它将有一个偏移量，它只是日志中的一个字节数或块号。然后是序列号，记得我说过每笔交易都有自己的序列号。然后日志的其余部分，日志只是已知大小的磁盘上的一堆顺序块。</p>
<p>发言人   18:46<br>Every transaction, The rest of the log consists of transactions. Each transaction consists of a descriptor block. Which contains block numbers? Just as in the much like the header block in the XV 6 and then the set of for, you know, for each of these block numbers, the actual updated content block corresponding that block number? And then finally, for the transaction of this actually finished and committed, there’ll be a commit block. And this is a separate block in the log. And because there can be more than one transaction in the log, that a commit block may be followed by the next transactions descriptor block, and then some data blocks, and then maybe the next transmission transactions commit block. So we get a multiple.<br>每个事务，日志的其余部分由事务组成。每个交易由一个描述符块组成。哪些包含区块编号？就像XV 6中的标题块以及每个块号的集合一样，实际更新的内容块对应于该块号？最后，对于实际完成并提交的事务，会有一个提交块。这是日志中的单独块。由于日志中可能有多个事务，因此提交块后面可能跟着下一个事务描述符块，然后是一些数据块，然后可能是下一个传输事务提交块。所以我们得到一个倍数。</p>
<p>发言人   19:46<br>The log file can be quite long and contain many transactions in it. So this, we can think of this offset and sequence numbers basically between them pointing to the very, the first, the beginning of the earliest, lowest numbered valid transaction of the log.<br>日志文件可能很长，其中包含许多事务。因此，我们可以想到这个偏移量和序列号，基本上它们之间指向日志的最早、最低编号的有效事务的第一个、开始。</p>
<p>发言人   20:08<br>A little detail here that’s will become important in a little while is that these, the descriptor blocks and the commit blocks in order to be able to help distinguish them from data blocks when they’re scanning log after a crash and recovery, the descriptor in the commit blocks start with a magic number, which is just some 32 b number that. Is unlikely to occur in data and that helps the log software distinguish descriptor and commit blocks from data blocks.<br>这里有一个小细节，很快就会变得很重要，那就是这些描述符块和提交块，以便能够在崩溃和恢复后扫描日志时帮助将它们与数据块区分开来，提交块中的描述符以幻数开头。这只是一些32 b的数字。不太可能出现在数据中，这有助于日志软件区分描述符和提交块与数据块。</p>
<p>发言人   20:52<br>Okay, with this in mind, with this structure in mind I’m going to talk about at a high level the ways that Exe 3 gets good performance. And there’s really three main a question, is it possible for losing in this system to have the cryor block before they commit block, let’s say two transactions going on at the same time?<br>好的，考虑到这一点，考虑到这种结构，我将在高层次上讨论EXE3获得良好性能的方式。实际上有三个主要的问题，在这个系统中，是否有可能在提交块之前就有cryor块，比如说同时进行两个交易？</p>
<p>发言人   21:14<br>There can be multiple transactions in the log. Does the transaction need to finish before the next one can start? Yeah, we will talk in a moment about that. But it is the case, yes, that there’s only one open transaction at a time. And this is really not quite the right picture for that because the current open transaction, the current open transaction is the transaction into which system calls are performing their rights. And so the current open transaction really only exists in memory. And because current system calls are sort of updating, they’re just updating the cached block file system blocks in memory when the Ex 3 system decides to finish the current open transaction, you after it decides to finish it, it’ll do 2 things.<br>日志中可以有多个事务。这项交易需要在下一个交易开始之前完成吗？是的，我们过一会儿再谈这个。但情况确实如此，是的，一次只有一个开放的交易。这确实不是完全正确的情况，因为当前开放的交易，当前开放的交易是系统调用执行其权利的交易。因此，当前打开的事务实际上只存在于内存中。并且因为当前系统调用有点更新，当Ex 3系统决定完成当前打开的事务时，它们只是更新内存中缓存的块文件系统块，当它决定完成它时，它会做两件事情。</p>
<p>发言人   22:10<br>One is it’ll start a new open transaction, which will be the next transaction, and it will then write the just finished transaction. It will start writing the just finished transaction to disk, which may actually take quite a while so. So, you know, the full story is that there’s a bunch of older transactions on disks that all of which are closed, plus one open transaction that really only exists in memory. And at least initially, these transactions that are on disk may only exist in the form of the log records and haven’t initially at least been written to their home locations. And then after a while in the background, the starting with oldest transaction, the logging system will, you know, write these updated blocks in a log to their home locations. And then once that’s been done, for each complete transaction, then the login system can free and reuse this space in the log. And so this is really a circular log. When you get to the end of the log, logging system starts using the blocks at the beginning and has to free them, free these blocks by writing them to their home locations before can reuse them.<br>一是它将开始一个新的开放交易，这将是下一个交易，然后它将写入刚刚完成的交易。它将开始将刚刚完成的事务写入磁盘，这实际上可能需要相当长的时间。所以，你知道，完整的故事是磁盘上有一堆旧的交易，所有这些交易都关闭了，加上一个真正只存在于内存中的开放交易。至少在最初阶段，这些在磁盘上的事务可能只以日志记录的形式存在，至少在最初阶段没有被写入它们的主位置。然后在后台运行一段时间后，从最早的交易开始，日志系统会将这些更新的块写入日志到它们的主位置。然后一旦完成，对于每个完整的事务，登录系统可以释放并重新使用日志中的这个空间。所以这实际上是一个圆形日志。当您到达日志的末尾时，日志系统开始使用开头的块，并且必须释放它们，通过将这些块写入其主位置来释放这些块，然后才能重复使用它们。</p>
<p>发言人   23:29<br>Okay, okay, so there’s three ways that the system gets Exe, 3 gets good performance. One is that it has asynchronous system calls. That is, system calls return before they’ve written the disk. The system called just updates cache blocks in memory and then returns never, never has to write the disk, never has to wait for disk rights, although may wait for discretes. The next big idea for performance is batching. We can batch many system calls into a single transaction. And the final big idea for performance is concurrency. And these are all the things. These are basically the things that ext 3 does, that XV 6 doesn’t do. Okay, so I’m going to talk about each one of these three performance techniques.<br>好的，好的，系统有三种方法可以获取Exe文件，3种方法可以获得良好的性能。一个是它有异步的系统调用。也就是说，系统调用在写入磁盘之前返回。系统调用只是在内存中最新进展缓存块，然后从不需要写入磁盘，从不需要等待磁盘权限，尽管可能会等待离散块。性能的下一个重要想法是批处理。我们可以将许多系统调用批处理到一个事务中。性能的最后一个重要理念是并发性。这些就是所有的东西。这些基本上是ext 3做的事情，XV 6不做。好的，我将逐一讨论这三种表演技巧。</p>
<p>发言人   24:28<br>Oh, sorry, I wanted to ask about batching. Doesn’t XV 6 allow for there to be multiple system calls that do start off end up like at kind of at the same time? So then they will commit together? Yeah, and that’s true. XV 6 is a limited amount of batching. Thank you? Okay, so first.<br>哦，抱歉，我想问一下批处理。XV 6不允许有多个系统调用，它们一开始就会同时结束吗？那么他们会一起承诺吗？是的，这是真的。XV 6是有限数量的批处理。谢谢？好的，首先。</p>
<p>发言人   25:00<br>Asynchronous system calls. This just means the system calls return, but they modified blocks and the cache and then return. Don’t, don’t trigger disc rights. So this has the obvious advantage of the system calls return quickly. It also allows for IO concurrency. That is, the application can make some file system system calls that imply that the file system ought to do a bunch of disk operations, disk writes, but the application can then return to computing in parallel with a file system doing whatever the rights are that are required by those system calls. So this is called IO concurrency. And without asynchronous system calls, it’s hard to get IO concurrency, hard to get overlap between disk operations and application computing if the applications always have to wait for the disk writes to complete.<br>异步的系统调用。这仅仅意味着系统调用返回，但它们修改了块和缓存，然后返回。不要，不要触发光盘权利。因此，这具有系统调用快速返回的明显优势。它还允许IO并发。也就是说，应用程序可以进行一些文件系统调用，这意味着文件系统应该执行一堆磁盘操作，磁盘写入，但应用程序然后可以返回与文件系统并行计算，执行这些系统调用所需的权限。所以这被称为IO并发。如果没有异步的系统调用，就很难获得IO并发，如果应用程序总是必须等待磁盘写入完成，那么磁盘操作和应用程序计算之间就很难重叠。</p>
<p>发言人   26:06<br>And the other thing that’s nice about asynchronous system calls is that they allow, they make it easier to do large amounts of batching. So there sort of help batching.<br>异步的系统调用的另一个好处是，它们允许大量的批处理工作变得更加容易。所以有一些帮助批处理。</p>
<p>发言人   26:19<br>The downside of asynchronous system calls is that. It means that just because a system calls return doesn’t mean that the work that you, the system call ought to have done has actually been completed. So for example, if you write a program that creates a file and writes some data to it, and then closes the file and then prints done on the console to the user, and then you pull out the power plug on your computer. After you restart the computer, your data may not be there, even though all the system calls returned, and even though the programs are just said, look, you know, I called those system calls and they returned. And this means that in a world with asynchronous system calls, applications have to be written more carefully if they care about their behavior with respect to crashes. This is actually kind of a big deal in. XV 6. If a rate returned, the data was on the disk and it would be there after a crash, and eest 3, if a rate returns that you don’t know anything about, what’ll happen after a crash may or may not be there.<br>异步的系统调用的缺点是。这意味着仅仅因为系统调用返回并不意味着你的系统调用应该完成的工作实际上已经完成了。因此，例如，如果您编写一个程序，创建一个文件并向其中写入一些数据，然后关闭该文件，然后在控制台上向用户打印完成，然后拔出计算机上的电源插头。重新启动计算机后，您的数据可能不在那里，即使所有系统调用都返回了，即使程序只是说，看，你知道，我调用了那些系统调用，它们就返回了。这意味着在一个异步的系统调用的世界中，如果应用程序关心它们在崩溃方面的行为，就必须更加谨慎地编写应用程序。这在中国实际上是一件大事。XV 6。如果速率返回，数据将在磁盘上，并且在崩溃后它将在那里，并且eest 3，如果速率返回您不知道任何信息，则崩溃后可能会发生什么，也可能不会发生。</p>
<p>发言人   27:33<br>So it is possible, despite asynchronous system calls, to write. Careful programs like databases need to be careful. Text editors need to be careful. I write out a file, you know I do not want if there’s a power failure while I’m writing out a file in my text editor, I don’t want to, after restarting to see garbage or a partial file, and I want to see either the old file or the new file.<br>因此，尽管有异步的系统调用，仍有可能写入。像数据库这样的谨慎程序需要小心。文本编辑需要小心。我写了一个文件，你知道我不想在我用文本编辑器写一个文件时断电，我不想在重新启动后看到垃圾或部分文件，我想看到旧文件或新文件。</p>
<p>发言人   27:55<br>And so the file system also provides some techniques for careful applications to get predictable behavior despite crashes.<br>因此，文件系统还为谨慎的应用程序提供了一些技术，以便在崩溃的情况下获得可预测的行为。</p>
<p>发言人   28:05<br>And the main tool for that is called, it’s a system called called fsync, which all Unix systems have. And what this basically says is that you pass it a file descriptor, and it tells the file system, look, actually do all of the rights. You know, I may have called write a bunch of and called fsync. I now want you to actually do the rights and don’t return from this system call until the rights are on disk and are guaranteed to be still there if there’s a crash. So if you look at the source code for databases or text editors, a number of other programs that really care about their data, you’ll see sort of carefully placed calls to fsync in order to sort of overcome this sort of fight back against these asynchronous system calls. Most programs, though, like your compiler, know it’s no big deal. The output of the compiler goes away if there’s a crash. And therefore, many, many programs, you know, don’t call fsync are very happy to get the good performance of asynchronous system calls.<br>主要的工具是fsync系统，所有的Unix系统都有。这基本上说的是，你传递一个文件描述符给它，它告诉文件系统，看，实际上做所有的权利。你知道吗，我可能已经写了一堆，称之为fsync。我现在希望你实际执行权利，直到权利在磁盘上并且保证在崩溃时仍然存在，才从这个系统调用返回。因此，如果您查看数据库或文本编辑器的源代码以及其他一些真正关心其数据的程序，您会看到一些精心放置的对fsync的调用，以克服对这些异步的系统调用的反击。不过，大多数程序，比如你的编译器，都知道这没什么大不了的。如果发生崩溃，编译器的输出就会消失。因此，很多程序，你知道的，不调用fsync的，很高兴能够获得异步的系统调用的良好性能。</p>
<p>发言人   29:07<br>And I’m not worried about their crash behavior. Okay, so this is this also called like flush sometimes because I think that that word I’ve heard that word before a lot. Yeah, you could A reasonable way to explain what esync does is that it flushes all previous writes to this file to the disk and only returns that, so flushes a reasonable word for this flashing rights to disk. Okay, so that’s the asynchronous system calls.<br>我不担心他们的撞车行为。好的，所以这有时也被称为 “flush”，因为我认为这个词我以前听过很多次。是的，你可以用一个合理的方式来解释esync的作用是，它会将之前所有对此文件的写入刷新到磁盘，并且只返回它，因此为磁盘的闪烁权限刷新一个合理的单词。好的，这就是异步的系统调用。</p>
<p>发言人   29:38<br>The next technique that axt 3 uses is batching. And. The game here is that there’s at any one time, there’s always one open transaction in Ex Ex. A transaction in Ex three can actually hold the rights of many, many distinct system calls. So what the Xt 3 does is says, well I’m going to start a new transaction now. And then for the next couple of seconds, all system calls that execute are their rights are part of that one big transaction.<br>axt 3使用的下一个技术是批处理。而且。这里的游戏是，在任何时候，在Ex中总是有一个未结的交易。在第三种情况下，交易实际上可以拥有许多不同系统调用的权利。所以Xt 3的作用是说，我现在要开始一个新的交易。然后在接下来的几秒钟内，所有执行的系统调用都是其权利的一部分，都是一个大交易的一部分。</p>
<p>发言人   30:22<br>I think by default Ex three only creates a new transaction every 5 seconds. So each transaction can have up to 5 seconds worth of system calls in. It all has a huge batch. And then at the end of the five seconds Ex 3 will commit this single big transaction that may have hundreds of updated blocks in it, Commit this transaction to disk as a single transaction.<br>我认为默认情况下，Ex 3只会每5秒创建一个新交易。因此，每笔交易最多可以进行5秒的系统调用。这一切都有一个巨大的批次。然后在五秒结束时，ex3将提交这个可能包含数百个更新块的大事务，将此事务作为单个事务提交到磁盘。</p>
<p>发言人   30:46<br>And so the reason why this is a win, first of all, it spreads some fixed transaction costs, amortizes some fixed transaction costs across many system calls. For example, you have to write the descriptor block and the commit block, and you have to seek on a mechanical drive, at least you have to seek and let the drive rotate to the place where the log is. And those are significant costs, and they only have to be done once per batch instead of once per system call. So it lowers the impact of those those costs. The other big deal is that.<br>所以这是一个胜利的原因，首先，它分散了一些固定的交易成本，在许多系统调用中摊销一些固定的交易成本。例如，您必须写入描述符块和提交块，并且必须在机械驱动器上进行查找，至少您必须查找并让驱动器旋转到日志所在的位置。这些都是显著的成本，每个批次只需要完成一次，而不是每个系统调用一次。因此，它降低了这些成本的影响。另一个重要的问题是。</p>
<p>发言人   31:19<br>Another big deal is that it allows rate absorption, that is.<br>另一个重要的问题是它允许速率吸收。</p>
<p>发言人   31:28<br>It’s often the case that you have a whole sequence of system calls that end up modifying the very same blocks over and over again. So for example, if I create a whole bunch of files, I need to allocate a bunch of inodes. And that means all the inodes are small, maybe 64 B. So many, many inodes fit in the block. So creating a bunch of files in a row is going to dirty many inotes in a few blocks because there’s many in notes for block. Similarly, if I’m writing a bunch of data to a file, I may need to allocate a lot of data blocks. I may flip many of the bits in the block free map, and if I allocate blocks that are next to each other, their bits are going to be in the same block. And so I may flip many bits in just one block.<br>通常情况下，您有一整个系统调用序列，最终会一次又一次地修改相同的块。因此，例如，如果我创建了一大堆文件，我需要分配一堆inode。这意味着所有的inode都很小，可能是64 b。这么多的inode适合在这个区块中。因此，连续创建一堆文件会在几个块中脏很多inotes，因为块的notes中有很多。同样，如果我正在将一堆数据写入一个文件，我可能需要分配大量的数据块。我可以翻转无块映射中的许多位，如果我分配相邻的块，它们的位将在同一个块中。所以我可以在一个块中翻转许多位。</p>
<p>发言人   32:17<br>So many system calls, again, being operating the same blocks over and over again. And in the system with batching those many, many rates of the same blocks just happen very quickly to the cached, just to the cached copies of the blocks, because we’re not rat the disk. And then we write those small number of blocks to the disk only once at the end of the transaction. And the single block, right? Writing it into the log reflects many, many system calls where the modifications of the same block. So this rate absorption can be reduce the amount of the total number of times we have to write the block dramatically compared to a synchronous system like XV 6.<br>如此多的系统调用，一遍又一遍地操作相同的块。在系统中，批量处理相同块的许多速率非常快地发生在缓存中，只是发生在缓存块的副本上，因为我们没有占用磁盘。然后我们在交易结束时只将这些少量的块写入磁盘一次。只有一个街区，对吧？将它写入日志反映了许多系统调用，其中修改了同一个块。因此，与像XV 6这样的同步系统相比，这种速率吸收可以显著减少我们必须写入块的总次数。</p>
<p>发言人   33:06<br>And the final big win is disk scheduling. In general? Even if we suppose we have to write a thousand blocks to the disk, it turns out to be much more efficient, certainly in mechanical drives, but even in solid state drives, to write 1000 blocks all at once to sequential locations, as you would do to a log, it’s much faster to do that than to write 1000 blocks 1 at a time, to different locations or even 1000 blocks, you know, even write the same block a thousand times in a log, so by handing the disc large batches of rights to do the disk can be much more efficient. There’s also not only do we get an efficiency from writing a large number of blocks sequentially in the log, but even when we go to write the home locations for this for a batch of the rights resulting from a batch of operations in a single big transaction, even then, if we can hand a very large number of rights to the drive, even if they’re to different locations, because they’re to the home locations of, you know, referred to by many different system calls, if we allow the disk to schedule a large number of distinct writes, it can pick an order to do them in, that’s particularly efficient and on a mechanical drive, this would involved sorting them and you know, sorting them by track number on the drive and doing, you know, just a little seek from one to the next and they can do this sort if you give it all of the blocks at the same time, but even on a solid state drive, it turns out there’s smaller winds to be gotten from giving the disk lots of work to do anyway. So this you can only really get this kind of dis scheduling if you have very large batches of rights to give to the drive. So that’s another win from batch.<br>最后的大胜利是磁盘调度。总的来说？即使我们假设我们必须向磁盘中写入一千个块，事实证明在机械驱动器中效率更高，但即使在固态驱动器中，一次性将1000个块全部写入顺序位置，就像您对日志所做的那样。这样做比一次将1000个块写入不同的位置甚至1000个块快得多，你知道，甚至在日志中写入同一个块一千次，因此通过移交磁盘大批量的权限来执行磁盘可以更加高效。我们不仅可以从在日志中顺序写入大量的块中获得效率，而且即使我们在单个大事务中写入一批操作所产生的权限的主位置，即使这样，如果我们可以将大量的权限授予驱动器，即使它们位于不同的位置，因为它们位于许多不同的系统调用所引用的家庭位置，如果我们允许磁盘安排大量不同的写入，它可以选择一个特别高效的订单来完成它们，在机械驱动上，这将涉及对它们进行排序，你知道，按照驱动器上的轨道编号对它们进行排序，你知道，只需稍微从一个到另一个寻找，如果你同时给它所有的块，它们就可以做到这一点，但即使在固态驱动器上，事实证明，给磁盘大量的工作可以得到更小的风。所以，只有当你拥有非常大的批量权限可以授予驱动器时，你才能真正获得这种调度。这是批次的另一个胜利。</p>
<p>发言人   35:09<br>All right, and a final big win from. That ext 3 gets this concurrency. It’s really got two kinds of concurrency that it benefits from. Compared to XV 6. One is that it can allow many system calls to execute at the same time. So we can have many individual system calls in parallel because at least Ex 3 decides to. Close out and commit the current transaction. The system calls don’t have to wait for each other. They can all modify blocks that are part of the current transaction.<br>好的，最后的大胜利。ext 3获取此并发性。它实际上有两种并发性，它从中受益。与XV 6相比。其一是它可以允许同时执行多个系统调用。因此，我们可以并行进行许多单独的系统调用，因为至少由Ex 3决定。关闭并提交当前事务。系统调用不必相互等待。它们都可以修改作为当前事务一部分的块。</p>
<p>发言人   36:02<br>And all these many, many system calls can execute in parallel, contribute blocks to the current transaction. That’s particularly important on a multicore machine where we don’t want to have the different courses to be waiting for a lock. In XV 6, it’s often the case that you’re not allowed a system called can’t proceed because the current transaction is busy doing something else. Most of the time.<br>所有这些许多系统调用可以并行执行，为当前事务贡献块。这在多核机器上尤其重要，因为我们不希望等待锁的不同过程。在XV 6中，通常情况下，您不允许名为 “无法继续” 的系统，因为当前事务正忙于执行其他操作。大部分时间。</p>
<p>发言人   36:27<br>In Ex three, many system calls can modify the current transaction The other way that Ext 3 gets concurrency is that there can be multiple transactions, older transactions in different stages of execution. So it’s true, a system calls only one open transaction can receive system calls, but the other transactions that are writing things to disk can go on in parallel. So many older transactions. And the different sort of stages in a transaction’s life that can go on in parallel.<br>在Ex 3中，许多系统调用可以修改当前事务，而Ext 3获得并发的另一种方式是可以有多个事务，旧事务处于不同的执行阶段。所以这是真的，一个系统只能调用一个打开的事务，可以接收系统调用，但其他将东西写入磁盘的事务可以并行进行。那么多旧交易。以及交易生命中可以并行进行的不同阶段。</p>
<p>发言人   37:07<br>First, there’s the one open transaction. There can be some number of transactions that are recent and the file system is committing them, still rating their blocks to the disk. So we have some number of transactions that are currently committing to the log. And we don’t have to wait for these to finish. That is, we can continue with system calls in the new open transaction while the previous transaction action still writing to the log and hasn’t actually finished committing yet. Of course, this stage ends when the transaction writes its commit block to the disk.<br>首先，有一个开放的交易。可能有一些交易是最近的，文件系统正在提交它们，仍将它们的块评级到磁盘。因此，我们有一些当前正在提交到日志的事务。我们不必等待这些完成。也就是说，我们可以在新打开的事务中继续系统调用，而之前的事务操作仍在写入日志，并且尚未真正完成提交。当然，当事务将其提交块写入磁盘时，此阶段结束。</p>
<p>发言人   37:47<br>The log. There can be transactions that are even older, transactions that are writing, that are blocks from the CA to the home locations of the modified blocks. And finally, this doesn’t take much work. There can be the oldest transactions are being freed. This doesn’t really take work itself. The work is really writing transactions to the blocks of their home locations, but anyway, there’s typically multiple transactions in existence in these different stages. And so in particular, new system calls can to execute without waiting for older transactions to either finish committing to the log or finish writing their blocks to their home locations.<br>日志。可能存在甚至更老的交易，即正在写入的交易，这些交易是从CA到修改后块的主位置的块。最后，这不需要太多的工作。可能会释放最早的事务。这并不真正需要工作本身。这项工作实际上是将交易写入他们家所在地的区块，但无论如何，在这些不同的阶段通常存在多个交易。因此，特别是，新的系统调用可以执行，而无需等待旧的事务完成对日志的提交或完成将其块写入其主位置。</p>
<p>发言人   38:40<br>In contrast to XV 6, where new system calls had to wait for this to complete for all for the one previous transaction. I have a quick question. So how does it work? When does an operation or when something is writing to a CA block and the block is also being written to the disk? Okay, so there’s, so that is indeed a problem and the?<br>与XV 6相反，新的系统调用必须等待此操作完成前一个事务的所有操作。我有个简短的问题。那么它是如何运作的呢？什么时候执行操作或有什么东西正在写入CA块并且该块也正在写入磁盘？好的，所以这确实是一个问题，还有什么？</p>
<p>发言人   39:10<br>There’s a potential difficulty here because a transaction, the stuff that a transaction writes to the log, should only include updates made by a system. Calls that were in that transaction shouldn’t include any, any block updates made by system calls that came after that transaction. Because if you did, you’d risk sort of commit having in the log updates that only represent partial system calls. Whereas we want to make sure that the transaction only contains all of any given system calls updates. So we can’t afford to have a transaction include updates made by anything that happened after the transaction started to close.<br>这里有一个潜在的困难，因为一个事务，一个事务写入日志的东西，应该只包括由系统进行的最新进展。该交易中的调用不应包括该交易之后的系统调用所发出的任何阻塞最新进展。因为如果你这样做了，你可能会冒着在日志中只代表部分系统调用的最新进展的风险。而我们希望确保事务只包含最新进展的所有给定系统调用。所以我们不能让一个交易包括在交易开始结束后发生的任何事情所产生的最新进展。</p>
<p>发言人   40:00<br>And the way Ex three deals with that is that at least notionally, it makes a copy when it decides to wrap up the current open transaction, it makes a copy of all the blocks for that transaction as of the time it closed out this transaction. So it sort of makes copies of all the blocks. And then it’s though that copy of the blocks that the transaction commits into its log, and any newer transactions have their own copy of that block, that they modify different copy from the moment we comedian to the log. And in order to make this efficient, the system actually uses a kind of copy on write scheme. Avoid making the copies until it actually notices that a newer transaction is needs to write that block.<br>而第三个处理的方式是，至少在理论上，当它决定结束当前开放的交易时，它会复制该交易的所有区块，直到它关闭该交易时。所以它有点复制所有的块。然后，尽管该事务提交到其日志中的块的副本，并且任何较新的事务都有该块的自己副本，但它们会从我们喜剧演员到日志中修改不同的副本。为了提高效率，系统实际上使用了一种写时复制方案。避免复制，直到它真正注意到需要一个新的事务来写入该块。</p>
<p>发言人   40:46<br>Cool, that makes sense.<br>酷，这很感知。</p>
<p>发言人   40:51<br>Okay? Good, and so the reason why concurrency helps performance again is that it can help us. We can run system calls in parallel. We can get multicore parallelism. If we can run applications and system calls at the same time we’re rating of the disk, then we can get IO concurrency that is overlap between CPU and CPU execution and disk IO, and all these sort of help use the hardware resources, the machine more efficiently, more intensively.<br>好吗？很好，因此并发性再次帮助性能的原因是它可以帮助我们。我们可以并行运行系统调用。我们可以获得多核并行。如果我们可以同时运行应用程序和系统调用，我们可以获得在CPU和CPU执行以及磁盘IO之间重叠的IO并发性，所有这些都有助于更有效地使用硬件资源，使机器更高效，更密集。</p>
<p>发言人   41:27<br>All right, any questions about concurrency?<br>好的，有关于并发的问题吗？</p>
<p>发言人   41:35<br>I want to just give you a taste of what the actual file system code, If you look at the Linux source for the file system. Sort of at a somewhat abstract level, this is the way each system call looks. So you might have a unlink system call. And this is, you know, can be pretty familiar from XV 6.<br>如果您查看文件系统的Linux源代码，我想让您体验一下实际的文件系统代码。在有些抽象的层面上，这是每个系统调用的外观。所以你可能有一个取消链接的系统调用。这一点，你知道，可以从XV 6中非常熟悉。</p>
<p>发言人   42:03<br>We need to, every system call needs to say, here’s the beginning of the sequence of writes. You know I’m about to do a sequence of rights and they need to be atomic with respect to crashes. So every system call, in any transaction system, there has to be a clear sort of begin, end. You know, everything between these two points needs to be atomic. And there’s a start call that system call code makes. And it turns out that Ex 3 has to be aware of the different system calls that are active, for reasons I’ll explain in a minute or two.<br>我们需要，每个系统调用都需要说，这是写入序列的开始。你知道我将要做一系列权利，它们需要在崩溃方面是原子的。因此，在任何交易系统中，每个系统调用都必须有一个清晰的开始和结束。你知道，这两点之间的一切都需要是原子的。并且有一个系统调用代码发出的开始调用。事实证明，Ex 3必须意识到处于活动状态的不同系统调用，原因我将在一两分钟内解释。</p>
<p>发言人   42:40<br>So every system called what it calls start, it actually gets what’s called a handle. That’s a sort of unique identifier of this particular system call. And the rights that it makes are loggings. The file system sort of keeps track. Oh yeah, that right was done by this particular system call.<br>因此，每个系统都称之为 “开始”，它实际上会得到所谓的句柄。这是这个特定系统调用的一种唯一标识符。它所赋予的权利是loggings。文件系统有点像跟踪。哦，对了，这个特定的系统调用完成了这个权利。</p>
<p>发言人   42:59<br>And then the system called needs to read and write blocks. And so it makes it to get hold of a block or really a buffer. The block CA buffer makes a get call and it tells that the handle and then the block number it needs to be to write. And I may do a bunch of these, right? If you need to modify many blocks. And then when modifies, then it will modify the blocks in the cache. And when it’s done, this particular system call is done. It makes a stop call. And passes the handle to the stop call? So?<br>然后调用的系统需要读取和写入块。因此，它使得获取一个块或真正的缓冲区成为可能。块CA缓冲区发出get调用，它告诉句柄，然后告诉它需要写入的块编号。我可能会做很多这些，对吧？如果您需要修改许多块。然后当修改时，它将修改缓存中的块。当完成时，这个特定的系统调用就完成了。它发出停止呼叫。并将句柄传递给停止呼叫？所以呢？</p>
<p>发言人   43:49<br>A lot of what this is about is informing the logging system. You know, once the system called starts, a transaction is not allowed to commit until all the system calls that started in that transaction have finished. So, and because there can to be multiple transactions, the system has to be able to one of the reasons for the handles, So the system, the file system can remember for each system called which transaction it was part of. So it knows, oh, and this call finishes. That’s one of the system calls a particular transaction was waiting for before it could actually come in.<br>这很大程度上是关于通知日志系统。你知道，一旦系统调用启动，在该事务中启动的所有系统调用完成之前，事务不允许提交。因此，由于可以有多个事务，系统必须能够处理其中一个原因，因此系统，文件系统可以记住每个系统调用哪个事务的一部分。所以它知道，哦，这个电话结束了。这是特定交易在实际进入之前等待的系统调用之一。</p>
<p>发言人   44:26<br>We pass the handle to the Get system because so that every transaction has a bunch of blocks that are associated with the blocks modified as part of that transaction. So what we’re saying here among as well as getting a pointer to the block, is we’re telling the logging system, look, this block number is part of the transaction that this handle refers to. This stop call doesn’t actually cause a commit. It just tells the logging system, look, you know, you have one fewer system calls that are active in this transaction. And so a transaction can only commit if all of the system calls that started in this transaction have called stops. So the transaction has to do some bookkeeping, has to remember all the handles that started so that it can sort of check them off as those system calls finish.<br>我们将句柄传递给Get系统，因为每个交易都有一堆与该交易中修改的块相关联的块。所以我们在这里所说的以及获得一个指向块的指针，是我们告诉日志系统，看，这个块号是这个句柄所指的事务的一部分。这个停止调用实际上不会导致提交。它只是告诉日志系统，看，你知道，你在这个事务中只有一个活跃的系统调用。因此，只有在该事务中启动的所有系统调用都停止时，该事务才能提交。因此，交易必须进行一些簿记，必须记住所有开始的句柄，以便在这些系统调用完成时可以对其进行核对。</p>
<p>发言人   45:20<br>So with this structure in mind I’m just going to lay out the complete sequence of what it takes to commit a transaction. So at some point when all the every 5 seconds, the file system is going to think to itself, oh, now would be a good time to commit the current open transaction. And so here’s what happens when the here’s what’s involved in the file system committing a transaction. So these are like steps.<br>因此，根据这种结构，我将列出提交交易所需的完整顺序。所以在某个时候，当所有的每5秒钟，文件系统会想到自己，哦，现在是提交当前打开的事务的好时机。因此，当文件系统提交事务涉及以下内容时，会发生以下情况。所以这些就像步骤。</p>
<p>发言人   45:56<br>So first, we have to block any new system calls. We need to have our transaction reflect only entire system call. So we don’t really want to let anything new start when we’re trying to commit this transaction. We want to only include system calls that have already started. So you need to block new system calls. There’s actually another reason I’ll talk about. Why we need to block new system calls? This is actually a little bit of a performance defect. There’s going to be a period of time here when system calls have to wait and are not allowed to execute. So that’s too bad.<br>首先，我们必须阻止任何新的系统调用。我们需要让我们的交易只反映整个系统调用。所以当我们试图提交这个交易时，我们真的不想让任何新的事情开始。我们只想包括已经开始的系统调用。所以你需要阻止新的系统调用。实际上，我还要谈论另一个原因。为什么我们需要阻止新的系统调用？这实际上是一点性能缺陷。这里将会有一段时间，系统调用必须等待并且不允许执行。那太糟糕了。</p>
<p>发言人   46:40<br>The second step is that there are a bunch of system calls that already started that are part of this transaction that we need to wait for them to finish. So we need to wait for the outstanding system calls that are in this transaction. Because of course, we want the transaction to reflect all of their rights. So we need to wait for them to finish. The next thing happens is once all the system calls for this transaction are finished, and I have done their rights into the cache, it turns out then it’s okay to start a new transaction and let these blocked system calls continue. So now we’re going to open a new transaction for these, for any subsequent system calls.<br>第二步是有一堆已经启动的系统调用，它们是我们需要等待它们完成的事务的一部分。所以我们需要等待此事务中未完成的系统调用。当然，我们希望交易能够反映他们的所有权利。所以我们需要等待他们完成。接下来发生的事情是，一旦此事务的所有系统调用都完成了，并且我已经完成了对缓存的权限，那么就可以开始一个新的事务并让这些被阻止的系统调用继续进行。所以现在我们将为这些打开一个新的交易，用于任何后续的系统调用。</p>
<p>发言人   47:28<br>But now this. I’m continuing the story with our original transaction, which is now closed. So remember, the log next in ext 3 contains descriptors and data blocks and commit blocks. So now we know the full set of blocks modified by all the system calls that were in this transaction because they all called get with a handle that told us about what transaction they were part of. So we know the full set of modified blocks for this transaction. So now we can write the descriptor block. It has all the block numbers. For all the blocks of dirty in this transaction.<br>但是现在这个。我正在继续我们最初的交易故事，该交易现已结束。因此请记住，ext 3中的日志next包含描述符、数据块和提交块。所以现在我们知道了在此事务中的所有系统调用修改的完整块集，因为它们都使用一个句柄调用get，该句柄告诉我们它们是哪个事务的一部分。所以我们知道此交易的完整修改块集。所以现在我们可以编写描述符块了。它有所有的区块编号。对于此交易中的所有脏块。</p>
<p>发言人   48:17<br>We’re also going to write the actual modified blocks from the disk cache into the log. And in fact, if somebody asked a question about, oh, what happens if the next transaction modifies this book? What we’re actually writing in this stage is the sort of saved copies of this transaction blocks as of the time when it finished. So we’re going to write the actual blocks to the log.<br>我们还将把磁盘缓存中实际修改的块写入日志。事实上，如果有人问一个问题，哦，如果下一笔交易修改了这本书，会发生什么？我们在这个阶段实际要写的是这个事务块在完成时的保存副本类型。所以我们将实际的块写入日志。</p>
<p>发言人   48:52<br>And now we’re going to wait for these rights to finish. So these need to finish before we can proceed. Once the descriptor and the data blocks are guaranteed to be on the disk, then we can write the commit record to the log.<br>现在我们要等待这些权利完成。所以这些需要在我们继续之前完成。一旦描述符和数据块保证在磁盘上，我们就可以将提交记录写入日志。</p>
<p>发言人   49:21<br>And once that write is finished, we have to wait for it to finish.<br>一旦写完了，我们就必须等待它完成。</p>
<p>发言人   49:31<br>We’re waiting for the commit rate to finish at this point. Once the commit rate is finished, this transaction, sort of technical term, is that this transaction has reached its commit point. That is, it’s guaranteed.<br>我们正在等待提交速率在这一点上完成。一旦提交率完成，这个事务，有点技术术语，就是这个事务已经达到它的提交点。也就是说，这是有保证的。</p>
<p>发言人   49:47<br>The rates in this traction are guaranteed to survive a crash at this point, if the crash that occurred before, before righting the commit block, the rights of the transaction would not appear. After a crash and reboot and running the recovery software. If a crash occurs now after the commit point, after the commit block is written to the disk, then they’re guaranteed to those rights. All the rights in the transaction are guaranteed to appear after crash, reboot and recovery, okay, and now, and only now in the background, all of this kind of happened in the background. No process was really waiting for this stuff. Now we can write to the transactions blocks to their home locations in the file system.<br>这种牵引力的费率保证在此时能够在崩溃中存活下来，如果在纠正提交块之前发生的崩溃，则交易的权利不会出现。在崩溃并重新启动并运行恢复软件后。如果在提交点之后，在提交块写入磁盘之后发生崩溃，则保证它们具有这些权利。交易中的所有权利都保证在崩溃、重新启动和恢复后出现，好的，现在只是在后台，所有这些都在后台发生。没有任何进程真正在等待这些东西。现在我们可以将交易块写入文件系统中的主位置。</p>
<p>发言人   50:43<br>And as I’ll talk about in a few minutes, after all of these rights have completed, for all the blocks that are part of this transaction, then only then can we reuse that part, the log. So in a very busy system, if the head of the log catches up with the tail, there may actually, we may not be able to start a new transaction in tow. All of these rights have finished with the oldest transaction because we may need log space and we won’t.<br>正如我将在几分钟后谈到的那样，在所有这些权利完成之后，对于属于此交易一部分的所有块，只有这样我们才能重用那部分日志。因此，在一个非常繁忙的系统中，如果日志的头部赶上了尾部，实际上可能我们可能无法开始一个新的事务。所有这些权利都已在最早的事务中完成，因为我们可能需要日志空间，而我们不会。</p>
<p>发言人   51:18<br>We need to reuse the oldest transaction stock space. We have to write for it to write all the its cache blocks, their home locations. This usually people try to make the log big enough that this happens pretty rarely so that this stuff can go on in the background. Any questions about these steps? Oh sorry, where are those run right for doing this file system stuff? Can you say that again? Oh, so you said that no process is waiting for those things to get down. So where, where are they scheduled? Where are they on? Oh, there’s a background thread, is it a background thread in the colonel dedicated, thank you?<br>我们需要重复使用最老的交易库存空间。我们必须为它编写所有的缓存块，即它们的主位置。这通常是人们试图使日志足够大，以至于这种情况很少发生，以便这些东西可以在后台继续进行。对这些步骤有任何问题吗？哦，对不起，这些文件系统的东西在哪里运行？你能再说一遍吗？哦，所以你说没有进程在等待这些事情下来。那么，他们的日程安排在哪里？他们在哪里？哦，有一个背景线程，是上校专用的背景线程吗，谢谢？</p>
<p>发言人   52:18<br>I got a question actually about reusing part of the log. Let’s say eventually we start using a particular section of log and the that I think just mentioned, that particular log of particular part of the log actually in my new transaction section, actually ends up using the whole log part that was just freed up. And there’s nothing else. There’s number space for the lock with the lock, then like with the system, just wait until another portion of luck is freed up, or would it do something else too? Yes, it’ll wait, let me just draw a picture to help me, make sure I’m answering the right question here.<br>我有一个关于重复使用原木部分的问题。假设最终我们开始使用日志的特定部分，而我认为刚刚提到的，日志的特定部分的特定日志实际上在我的新事务部分中，最终实际上使用了刚刚释放的整个日志部分。没有别的了。锁的编号空间，然后像系统一样，等待运气的另一部分被释放，或者它也会做其他事情吗？是的，它会等待，让我画一幅画来帮助我，确保我在这里回答正确的问题。</p>
<p>发言人   53:08<br>We can think of the log as just this linear part of the disk. And at any given time, maybe the oldest valid transaction is T 7. And then there’s T 8 in this region, and we have T 9. And you know, we want to start, you know, we want to put T 10 here. The.<br>我们可以把对数看作仅仅是磁盘的线性部分。在任何给定时间，可能最早的有效交易是T 7。然后这个区域有T 8，我们有T 9。你知道，我们想要开始，你知道，我们想要把T 10放在这里。这个。</p>
<p>发言人   53:39<br>Let’s see one you. We’d like to start a new transaction and put it here.<br>让我们来看看你。我们想开始一个新的交易并把它放在这里。</p>
<p>发言人   53:46<br>We may have to wait for T 7 to write all that’s blocked to their home locations so that we can free it. And that may mean that transaction stuff in transaction 10 may have to pause waiting for this space in the log to free up. Is that what you’re talking about? Yeah, so let’s say that. So it could be the case at the beginning, the I can put in blocks for transaction 10 in the actual free space right now. But eventually, if the lock grows big enough, it’s just going to run out of free space. And at that point, it’s just going to wait for transaction 7 to, yes, be recorded.<br>我们可能不得不等待T 7将所有被阻止的内容写入他们的主位置，以便我们可以释放它。这可能意味着事务10中的事务内容可能需要暂停，等待日志中的此空间来释放。这就是你所说的吗？是的，那么我们就这么说吧。因此，一开始可能就是这种情况，我现在可以在实际可用空间中为交易10放入区块。但最终，如果锁变得足够大，它将耗尽可用空间。此时，它只会等待交易7被记录下来。</p>
<p>发言人   54:28<br>Okay, Yes, yes, certainly if there’s enough activity going on and the log wraps around quickly enough, you may end up having to wait for new, new system calls. We may not even be able to start the system calls because before we can free up space in the log for the blocks that they’re going to modify, you know, if you care about the diesels of this, it turns out there’s some potential deadlocks here that require meaning that Ex 3 ends up system calls have to prede how many blocks they’re going to need so that the logging system knows sort of how much can reason about whether there’s enough space for this transaction because we don’t want to allow a transaction to start that we wouldn’t actually be able to commit into the log.<br>好的，是的，当然，如果有足够的活动正在进行，并且日志包装得足够快，您可能最终不得不等待新的系统调用。我们可能甚至无法启动系统调用，因为在我们为他们将要修改的块释放日志空间之前，你知道，如果你关心这个柴油，事实证明，这里存在一些潜在的死锁，这意味着Ex 3最终系统调用必须prede他们将需要多少块，以便日志系统知道有点关于是否有足够的空间进行此交易的原因，因为我们不想允许一个我们实际上无法提交到日志。</p>
<p>发言人   55:26<br>Okay, let’s, let’s say it’s the new log or the new transaction you’re trying to put goes to like 8, transaction 8. So you will have to wait for 7 and 8, right? So how does that work?<br>好的，让我们假设它是新的日志或你试图放入的新交易，就像8一样，交易8。所以你必须等待7和8，对吧？那么这是如何运作的呢？</p>
<p>发言人   55:40<br>You mean, okay, so transaction 7 and transaction 8 and transaction 9, at least in this diagram, have all completed or all the system calls have finished. And these transactions are committed in the log because these are the old transactions. So in this picture, at least, we’re just starting transaction 10. And so new system calls are going to be writing into transaction 10.<br>你的意思是，好吧，所以交易7、交易8和交易9，至少在这个图表中，都完成了或者所有的系统调用都完成了。这些事务将在日志中提交，因为这些是旧事务。所以在这张图片中，至少我们刚刚开始交易10。因此，新的系统调用将写入交易10。</p>
<p>发言人   56:11<br>Right, but you said that transaction 10 is not big enough to fill that space, so you need to free transaction 7, right? You need to wait for that to like commit to disk. Yes, but what happens if you if it’s if 10 is like bigger than like 7, like it goes to 8 transactions, then we have to wait for two. Yeah, we have, we may have to wait for however big transaction 10 is, you know, we need, we need enough space on the disk to fit it and not enough space in a log to fit it. And so indeed, if transaction 10 that turns out being big, it may need to force multiple multiple of the oldest transactions to write to their home locations and free themselves.<br>没错，但是你说交易10不够大，无法填满那个空间，所以你需要免费交易7，对吧？你需要等待那个提交到磁盘。是的，但是如果10比7大，就像8笔交易，那么我们必须等待2笔交易。是的，我们有，无论交易10有多大，我们可能都要等它，你知道，我们需要磁盘上有足够的空间来容纳它，而不是日志中有足够的空间来容纳它。因此，如果交易10变得很大，它可能需要强制多个最老的交易写入到他们的主位置并释放自己。</p>
<p>发言人   57:03<br>I guess how, how does code for that work? Like, does it like just run through how big it is and like say, hey, there’s a transaction here and a transaction here? And it’s like, I have to wait for both of them?<br>我想知道，这个代码是如何工作的？就像它有多大，就像说，嘿，这里有一个交易，这里有一个交易吗？这就像是，我要等他们两个？</p>
<p>发言人   57:14<br>The file system knows. Knows how big all the transactions in a log are and remembers and remember? I mean, actually, the file system remembers quite a bit about each of these older transactions. It knows for each one whether it’s written for the file system keeps track of for every block in all of each of these older transactions, whether it has written that block to the home location so that it can know, oh I’ve written, it can know whether or not and recognize the point at which is finished writing all the transaction sevens blocks or transaction CS blocks. So there’s quite a lot of bookkeeping going on here for the file system to understand in detail the state of every old transaction.<br>文件系统知道。知道日志中所有交易的大小并记住和记忆？我的意思是，实际上，文件系统对这些旧的事务都有相当多的记忆。它知道每个是否为文件系统编写，跟踪所有这些旧事务中的每个块，是否已将该块写入主位置，以便它可以知道，哦，我已经写了，它可以知道是否并识别完成写入所有交易的7个块或交易的CS块的点。因此，这里进行了相当多的记账工作，以便文件系统详细了解每个旧事务的状态。</p>
<p>发言人   58:07<br>Okay, okay, so indeed’s on the topic of how to reuse log space, there’s one little detail here that needs to be said. If you remember at the beginning of the let me write a new diagram, there’s actually a super block, the log super block at the beginning of the log. And so at any given time, you might have the log super block and then some set of transactions. You know, maybe those transaction 4, which is a the newest transaction, and then transaction one. The older transactions. And so what this means is, of course, the log is wrapped around.<br>好的，好的，确实是关于如何重用日志空间的话题，这里有一个小细节需要说明。如果您还记得在 “让我写一个新图表” 的开头，实际上有一个超级块，日志超级块位于日志的开头。因此，在任何给定时间，您都可能拥有日志超级块和一些事务集。你知道的，也许是那些交易4，这是最新的交易，然后是交易1。旧的交易。所以这意味着，当然，日志是环绕着的。</p>
<p>发言人   59:01<br>And the rule for whether we could reuse a part of the log. Now I’ve mentioned this before, I just want to say it again, is that we can reuse the log. Say we can reuse this part of the log that transaction 2 is in if T 2 has committed and all of T two’s blocks have been written to their home locations in the file system so that there can never be any need after a crash to replay these blocks. And if all transactions prior to transaction 2 have also been freed. So if those conditions are all true, then we can free and reuse the part of the log that T 2 sits in. So we can only use T 2. And after T 2 is after T 1 is finished, all committing and writing its blocks to the log, to the home locations also.<br>以及我们是否可以重复使用日志的一部分的规则。现在我之前提到过这个，我想再说一遍，我们可以重复使用日志。说，如果T 2已提交，并且所有T 2的块都已写入文件系统中的主位置，则我们可以重用事务2所在的日志部分，以便在崩溃后永远不需要重放这些块。如果事务2之前的所有事务也都被释放。因此，如果这些条件都成立，那么我们就可以释放并重用日志中包含T 2的部分。所以我们只能使用T 2。在t2之后是在t1完成之后，所有提交并将其块写入日志，也写入主位置。</p>
<p>发言人   59:55<br>And then this super block for the convenience of the recovery software after a crash, if we decide that we can, if the file system decides, it can free and reuse up particular part of the log, it rewrites the super block to the super block, has a pointer to the first transaction of the log. And so as part of freeing part of the log, the file system modifies a super block to point to the new, the beginning of the now oldest transaction in the log. And then versus crash, the recovery software reads the super block, finds the beginning of the log.<br>然后，为了方便恢复软件崩溃后的超级块，如果我们决定可以，如果文件系统决定，它可以释放和重用日志的特定部分，它会将超级块重写为超级块，有一个指向日志的第一个事务的指针。因此，作为释放日志部分的一部分，文件系统修改超级块以指向日志中新的、现在最旧的事务的开始。然后与崩溃相比，恢复软件读取超级块，找到日志的开头。</p>
<p>发言人   01:00:42<br>Okay, so if there’s a crash, of course a crash causes everything in Ram to evaporate. So all that bookkeeping that the file system is keeping about what blocks have been written to their home locations, that’s all lost. If there’s a crash or a power failure, however, so that one of the assumptions is there’s nothing useful in Ram, the only stuff that’s be preserved across the crash is whatever’s on the disk. But we are absolutely in all these discussions about logging, assuming that the disk is completely intact, nothing went wrong with the disk. So maybe the right model for you to think in terms of is that there was a power failure, that everything was humming along, and then the power failed and the system just stopped at some point, and the disk is after power is restored, the disc just has whatever it had on it at the point of the power failure. So we’re absolutely not considering situations in which the disk was somehow corrupted or destroyed by the crash.<br>好的，如果发生崩溃，当然崩溃会导致内存中的所有东西蒸发。所以文件系统保存的所有关于哪些块已写入其主位置的簿记都已丢失。然而，如果发生崩溃或电源故障，其中一个假设是Ram中没有任何用处，那么在崩溃中唯一保留的东西就是磁盘上的东西。但是我们绝对会参与所有关于日志记录的讨论，假设磁盘完全完好无损，磁盘没有任何问题。所以也许你应该考虑的正确模型是电源故障，一切都在嗡嗡作响，然后电源故障，系统在某个时候停止，磁盘在电源恢复后，在断电时，光盘上只有它所拥有的任何东西。所以我们绝对不会考虑磁盘因崩溃而损坏或破坏的情况。</p>
<p>发言人   01:01:51<br>And so the crash, of course, may interrupt whatever transactions were in the middle of committing or not yet committing. Yet whatever crash may interrupt either the commit of a transaction or the writing of a transactions blocks into their home locations. So what that means is that the on disk log, when the power is restored and recovery software is run, it’s going to have a bunch of complete, older, complete transactions.<br>因此，崩溃当然可能会中断正在提交或尚未提交的交易。然而，任何崩溃都可能中断交易的提交或将交易块写入其主位置。所以这意味着磁盘上的日志，当电源恢复并运行恢复软件时，它将包含一堆完整的，旧的，完整的交易。</p>
<p>发言人   01:02:21<br>Maybe T 1 and T 2? Actually, let me think of a new example for recovery. Let’s say we have the, again, the super block. And maybe at the time of the crash, the oldest transaction. Was T 6, and then there’s T 7. Then we wrapped around still before the crash to T 8 and there was a T 5. But T 8, let us imagine, has has overwritten the first part of T 5 because T 5 was, we know that T 5 was freed before the crash, but the recovery software doesn’t necessarily know that. And let’s say the super block points to T 6 as being the start of the oldest valid transaction, you know, so T 5 s, it’s free.<br>也许是T 1和T 2？实际上，让我想出一个新的恢复例子。假设我们有超级区块。也许在崩溃发生时，最古老的交易。是T 6，然后是T 7。然后我们在崩溃之前仍然缠绕在T 8上，并且有一个T 5。但是让我们想象一下，T 8已经覆盖了T 5的第一部分，因为我们知道T 5在崩溃之前被释放了，但是恢复软件不一定知道这一点。假设超级块指向t6作为最早的有效交易的开始，你知道，所以t5是免费的。</p>
<p>发言人   01:03:30<br>We’re going to reboot with an attack disk. The recovery software reads the super block. And so then it knows where the beginning of the log is. Then the recovery software is going to scan forward in the log to try to find the end of the log. But we need to have a way for it to actually figure out, oh, you know, that’s the end of the log.<br>我们将使用攻击磁盘重新启动。恢复软件读取超级块。这样它就知道日志的开头在哪里。然后恢复软件将在日志中向前扫描以尝试查找日志的末尾。但我们需要有一种方法让它真正弄清楚，哦，你知道，那就是日志的结束。</p>
<p>发言人   01:03:53<br>The way it does that is we know that every transaction consists of a descriptor block that indicates how many data blocks that are on the transaction. So descriptor blocks says, oh, yeah, there’s 17 data blocks, and we expect 17 data blocks, and finally a commit record, and then another descriptor record. And then the number of data blocks implied by the descriptor block, and then another commit block. And so the log softwares in the scan forward, maybe T 6 and T 7 are fine. Then it’s going to look at T 8.<br>它的实现方式是我们知道每个事务都由一个描述符块组成，该描述符块指示事务上有多少数据块。描述符块表示，哦，是的，有17个数据块，我们预计有17个数据块，最后是一条提交记录，然后是另一条描述符记录。然后是描述符块隐含的数据块数量，然后是另一个提交块。因此，向前扫描中的日志软件可能可以使用T 6和T 7。然后它会看T 8。</p>
<p>发言人   01:04:26<br>T eight’s got some descriptor block, and then the recovery software is going to look forward to where the end of transaction H should be and look for A. Commit block. And so, you know, there’s a couple of things that may have happened here. It could be that transaction A did commit and that the recovery software finds the commit block. It’ll then look for another, you know, it doesn’t know that transaction. ACS transaction needs to figure that out, so it’s going to look at the very next block to see if this is a valid descriptor block. Now we know that this block was really just a random block in the middle of transaction 5 and not a descriptor block at all.<br>第八个有一些描述符块，然后恢复软件将期待交易H的结束位置，并寻找A。提交块。所以，你知道，这里可能发生了几件事情。可能是交易A确实提交了，并且恢复软件找到了提交块。然后它会寻找另一笔交易，你知道，它不知道那笔交易。ACS交易需要弄清楚这一点，因此它将查看下一个块，以查看这是否是有效的描述符块。现在我们知道这个区块实际上只是交易5中间的一个随机区块，根本不是描述符区块。</p>
<p>发言人   01:05:16<br>And the question is, how can the recovery software reliably distinguish between, oh, this is a some data block in the middle of an old transaction, or it’s the maybe the descriptor block for transaction 9? Any guesses for a reliable method to do that?<br>问题是，恢复软件如何可靠地区分这是一个旧交易中的数据块，还是可能是交易9的描述符块？有没有可靠的方法来做这件事？</p>
<p>发言人   01:05:34<br>Is that the magic number for, or is there just a reserve bit? There is indeed. Every descriptor and commit block starts with some magic number, just a 32 b value that the recovery software is looking for. I don’t actually know what it is. So definitely the game is that we come to the end of transaction 8.<br>这是神奇的数字吗，还是只有一点备用位？确实有。每个描述符和提交块都以一些神奇的数字开头，恢复软件正在寻找的32 b值。我实际上不知道它是什么。因此，游戏绝对是我们来到交易8的结尾。</p>
<p>发言人   01:05:55<br>If the very next block starts with the magic number, then the recovery software is going to assume that, oh, this is a valid descriptor block. Could you or sorry, quick question, would it be unreliable to try to like interpreted as a descriptor block, try to read the number of data blocks that it specifies, then see if there’s a commit block at the expected location after that number of blocks? If, well, certainly if this block does look like a descriptor block, then it will skip forward and try to read the corresponding commit block. And if that commit block doesn’t look like a commit block with the right magic number, it will not believe in this transaction.<br>如果下一个区块以幻数开头，那么恢复软件将假设，哦，这是一个有效的描述符区块。你能或抱歉，快速的问题是，尝试将其解释为描述符块，尝试读取它指定的数据块数量，然后查看在该数量块之后的预期位置是否有一个提交块是不可靠的吗？如果这个块看起来像一个描述符块，那么它将向前跳并尝试读取相应的提交块。如果该提交块看起来不像具有正确幻数的提交块，它将不会相信此事务。</p>
<p>发言人   01:06:43<br>The thing that’s the one little remaining detail here is that this block that we’re looking at here and we’re wondering, or the recovery software is wondering if it’s a descriptor block, this could be just a block right in the middle of transaction 5 containing any arbitrary bit pattern. And it could be just like the data block from a file that just happens to begin with the magic number. So, you know, as a final detail, the logging system needs to be able to distinguish between a valid descriptor block that starts with this magic number and just some data block that starts with the magic number. And now you can imagine various ways of doing that.<br>这里剩下的一点细节是，我们在这里看到的这个块，我们想知道，或者恢复软件想知道它是否是一个描述符块，这可能只是一个包含任意位模式的交易5中间的块。它可能就像一个文件中的数据块，而这个文件恰好以幻数开头。所以，你知道，作为最后一个细节，日志系统需要能够区分以这个幻数开头的有效描述符块和以这个幻数开头的某些数据块。现在你可以想象各种各样的方法来做这件事。</p>
<p>发言人   01:07:27<br>In fact, what Ex 3 does is whenever it’s going to write a block to the log, that’s not a descriptor block or a commit block, if that block starts with the magic number, it replaces that with 0 and sets a bit corresponding to that block in that transaction descriptor block, then that bit means this particular data block started with the magic number, and we replaced it with 0. And then if the recovery software ever needs to replay that block. So let’s say transaction 8 had one of these blocks that originally started with the magic number. It’s going to set the bit, this magic flag corresponding to that block and the descriptor block, and replace magic number with 0. If recovery has to replay this block, it’ll see that flag. And before replaying this block to its own location will replace the zero with the magic number, and therefore no block other than a descriptor or commit block can possibly start with the magic number in this logging system.<br>实际上，ex3所做的是每当它将一个块写入日志时，这不是描述符块或提交块，如果该块以幻数开头，它将其替换为0，并在该事务描述符块中设置与该块相对应的位，那么该位意味着这个特定的数据块以幻数开始，我们将其替换为0。然后，如果恢复软件需要重新播放该块。因此，假设交易8有一个最初以神奇数字开始的块。它将设置位，这个魔法标志对应于那个块和描述符块，并将魔法数字替换为0。如果恢复必须重新播放此块，它将看到该标志。并且在重新播放此块到自己的位置之前，将用幻数替换零，因此在此日志系统中，除了描述符或提交块之外，没有其他块可以以幻数开头。</p>
<p>发言人   01:08:26<br>So we never have this ambiguity if the block after a commit block starts with a magic number, then it must be a descriptor block.<br>所以，如果提交块之后的块以幻数开始，那么它必须是描述符块，我们永远不会有这种歧义。</p>
<p>发言人   01:08:39<br>Okay, all right, so recovery, we were doing recovery. It starts at the block that the super block says is the beginning of the oldest transaction. It scans forward and it’ll scan forward and tell you, look at the descriptor, is there a corresponding commit block? And it’ll stop as soon as it sees, oh, the block following a commit block wasn’t a descriptor block at all. Or yeah, the block following a commit block is a descriptor block. But what should have been the corresponding commit block is not, in fact, a valid commit block, doesn’t have the magic number. So at that point, it’ll stop, and recovery software would declare the lock to have ended at the point where the last valid commit block. And it will ignore.<br>好的，好的，所以恢复，我们正在进行恢复。它从超级块所说的最早交易开始的区块开始。它向前扫描，它会向前扫描并告诉你，看看描述符，是否有相应的提交块？它一看到就会停止，哦，提交块后面的块根本不是描述符块。或者，提交块后面的块是描述符块。但实际上，相应的提交块并不是一个有效的提交块，也没有幻数。因此，在那一点上，它将停止，恢复软件将声明锁在最后一个有效提交块的位置结束。它会忽略。</p>
<p>发言人   01:09:31<br>There may be a partial transaction after this that started to commit but didn’t finish. But the recovery software ignores that partial transaction because it doesn’t have all the rights, so it can’t restore it atomically. And then the recovery software will go through, go back to the beginning of the log and replay each block, rewrite each block to its own location all through the log to the last, up to the last valid commit block. And then it can restart the of the operating system, start the rest of the operating system.<br>在此之后，可能会有一个部分事务开始提交但没有完成。但恢复软件会忽略该部分事务，因为它没有所有权限，因此无法原子地恢复它。然后恢复软件将通过，返回到日志的开头并重放每个块，将每个块重写到自己的位置，直到最后一个有效提交块。然后它可以重新启动操作系统的，启动操作系统的其余部分。</p>
<p>发言人   01:10:07<br>Ordinary programs can run, of course, before recovery finishes. You can’t, you know, you can’t run any programs because the file system isn’t valid. Any questions about recovery?<br>当然，普通程序可以在恢复完成之前运行。你不能，你知道，你不能运行任何程序，因为文件系统无效。有任何关于恢复的问题吗？</p>
<p>发言人   01:10:22<br>I have a quick question. I think you mentioned this before, but what parts of this logging transaction scheme is missing and XV 6? The main thing in this is missing an XV 6 is the ability to have multiple transactions in the log. So in XV 6, there’s only ever at most one transaction in the log. And so you can’t, you don’t get this currency in XV 6, where while I’m executing system calls from transaction 7 that are going to go into transaction 7, in parallel with that ex 3 can be committing transaction 6 to the disk, that’s not available. Concurrency is not possible in exts in XV 6 because the log holds just the one transaction. So we have to completely do all the work for one transaction before we’re allowed to start anything with the next transaction. So it’s correct and simple, but you don’t get a lot of parallelism out of XV 6.<br>我有个简短的问题。我想你之前提到过这一点，但是这个日志事务方案的哪些部分缺失了，XV 6呢？缺少XV 6的主要原因是日志中具有多个事务的能力。所以在XV 6中，日志中最多只能有一个事务。所以你不能，你不会在XV 6中获得这种货币，当我从交易7执行系统调用并将进入交易7时，与前3并行的是可以将交易6提交到磁盘，这是不可用的。并发在XV 6的exts中是不可能的，因为日志只保存一个事务。因此，我们必须先完成一笔交易的所有工作，然后才能在下一笔交易中开始任何事情。所以这是正确和简单的，但你不会从XV 6中得到很多并行。</p>
<p>发言人   01:11:30<br>Okay, thank you. Are you saying that it can still have multiple transaction blocks, but it just can’t execute them asynchronously? That be correct?<br>好的，谢谢。你是说它仍然可以有多个事务块，但它只是不能异步执行它们？正确吗？</p>
<p>发言人   01:11:42<br>X 3 6 and x 3, 6, yeah. Yeah, it only has the once it decides to. I mean, the picture is a little bit confused because can allow more than one system call into a single transaction. So x 3 6 actually does have some of this concurrency in it and some of this batching.<br>X 3 6和x 3，6，是的。是的，它只有决定一次。我的意思是，情况有点混乱，因为可以允许多个系统调用到一个事务中。因此，x 3 6实际上确实有一些并发性和一些批处理。</p>
<p>发言人   01:12:06<br>But once Se 6 decides to start committing a transaction, it has to completely finish with that transaction, commit it to disk, you know, write the header block, write the blocks to the home locations, and then erase the transaction from the log. It has to do all that stuff before it can execute any new system calls because there’s nowhere to put the modifications for the new system calls until the previous transaction is completely finished. So XV 6 sort of, you know, alternates between it can run a few system calls and then commit a transaction and then run a few more system calls. But they can’t sort of overlap those two. Exe 3 can thank you.<br>但是一旦Se 6决定开始提交事务，它必须完全完成该事务，将其提交到磁盘，你知道，写入标头块，将块写入主位置，然后从日志中删除事务。它必须先完成所有这些操作，然后才能执行任何新的系统调用，因为在以前的事务完全完成之前，没有地方可以为新的系统调用进行修改。所以XV 6可以交替运行几个系统调用，然后提交一个事务，然后再运行几个系统调用。但它们不能重叠在这两者之间。Exe 3可以谢谢你。</p>
<p>发言人   01:12:58<br>Okay, so that was a relatively straightforward part of Ex 3 design. It turns out there’s also a bunch of tricky details, a few of which I want to talk about.<br>好的，这是Ex 3设计中相对简单的一部分。事实证明，还有一些棘手的细节，其中一些我想谈谈。</p>
<p>发言人   01:13:12<br>So I mentioned before that you there’s an open transaction, but when Ex 3 decides that it wants to close the open transaction, it has to wait for all system calls in that transaction to finish before it any new transactions are allowed to start. So that maybe a picture for that is that we had original old transaction T 1 and there were, you know, multiple system calls that executing in transaction one. If we want to close transaction one, we have to stop accepting new system calls because we want to wait for the existing ones to finish before we can commit. But until all these system calls finished, no new system calls are allowed to start in ext 3. So if there’s some transaction 2 here, nothing is allowed to happen in transaction 2. Nothing’s allowed to system calls are allowed to start until these system calls have finished, and only then can transaction to start accepting system calls. So there’s a period of time here in which new system calls are all blocked. That reduces performance because it could have been shooting system calls, but we’re not allowed to.<br>所以我之前提到过有一个开放的交易，但是当Ex 3决定关闭这个开放的交易时，它必须等待该交易中的所有系统调用完成，然后才允许启动任何新交易。因此，可能的情况是，我们有原始的旧交易t1，并且在交易一中执行了多个系统调用。如果我们想要关闭第一个事务，我们必须停止接受新的系统调用，因为我们想要等待现有的调用完成后才能提交。但是在所有这些系统调用完成之前，不允许在ext3中启动新的系统调用。因此，如果这里有一些交易2，那么在交易2中不允许发生任何事情。在这些系统调用完成之前，不允许任何系统调用启动，只有这样事务才能开始接受系统调用。所以在这里有一段时间，新的系统调用都会被阻止。这会降低性能，因为它可能会发出系统调用，但我们不允许这样做。</p>
<p>发言人   01:14:28<br>And the question is, how come Ex 3 doesn’t allow new system calls to start in transaction 2 until all system calls in transaction one are finished? You know, it’s a good question because it limits performance. So let me give you an example. If ext 3 didn’t do this, then the following bad situation could arise. So let’s suppose transaction one just has one system call in it, and it’s a create a system called the create a file, maybe a file called x, and the idea is that before this create is finished, the file system decides it wants to start a new transaction, open up a new transaction, and it’s going to accept any system calls after the create in this new transaction t, so we’re going to say t 2 starts before t 1 finishes, and we start executing system calls now in transaction 2, and maybe transaction T 2 calls unlink on some other file. Well, then unlink will free the inode associated with y, right? And so maybe I’m having time go this way in my diagram. Maybe at this point in time, transaction two marks the IO is free, marks the IO for Y is free.<br>问题是，为什么在事务1中的所有系统调用完成之前，ex3不允许在事务2中启动新的系统调用？你知道，这是一个好问题，因为它限制了性能。让我给你举个例子。如果ext 3没有这样做，那么可能会出现以下糟糕的情况。因此，让我们假设交易只有一个系统调用，并且它是一个创建一个称为创建文件的系统，可能是一个称为x的文件，其想法是在此创建完成之前，文件系统决定它想要开始一个新的交易。打开一个新的交易，并且它将在这个新事务t中创建后接受任何系统调用，因此我们将说t 2在t 1完成之前开始，我们现在开始在事务2中执行系统调用，并且可能在某些其他文件上执行事务T 2调用unlink。那么取消链接将释放与y关联的inode，对吗？所以也许我有时间在我的图表中走这条路。也许在这个时间点，交易2标记IO是免费的，标记IO为Y是免费的。</p>
<p>发言人   01:15:55<br>Create, of course, has to allocate an inode for x, maybe it allocates an inode at this point in time. Well, because the Cre is allocating after the unlinked freed, it might reuse the same inode, So maybe x gets is going to get the same Iode that Y had, say, maybe iode 17, and then which is okay because unlink free design notes doesn’t look like a problem yet.<br>当然，Create必须为x分配一个inode，也许它会在这个时间点分配一个inode。好吧，因为Cre是在未链接的释放之后分配的，它可能会重用相同的inode，所以可能x gets会得到与Y相同的Iode，比如iode 17，然后这是可以的，因为取消链接免费的设计笔记看起来还没有问题。</p>
<p>发言人   01:16:22<br>You know, the point is we’re trying to close transaction one, so then when the create finishes, we close transaction one, we’re going to write, let’s say transaction one actually commits.<br>你知道，重点是我们试图关闭事务一，所以当创建完成时，我们关闭事务一，我们将编写，假设事务一实际提交。</p>
<p>发言人   01:16:30<br>We write all of its modifications to disk, fantastic. However, after the unlink takes a while, it hasn’t finished yet. Supposing after this commit finishes, there’s a crash, right? When the recovery software runs, it’s going to see that transaction one committed and that transaction 2 didn’t. So the recovery software is going to just completely ignore transaction 2. So that means the unlink never took place it, right?<br>我们把它的所有修改都写在磁盘上，太棒了。然而，在取消链接需要一段时间之后，它还没有完成。假设在这次提交完成后，发生了崩溃，对吗？当恢复软件运行时，它会看到事务1已提交，事务2未提交。所以恢复软件将完全忽略事务2。这意味着取消链接从未发生过，对吗？</p>
<p>发言人   01:17:02<br>The recovery software won’t do, won’t perform. The unlinks writes to the disk, therefore will not free the inode, won’t delete Y after the crash, and recovery y will still exist. It’ll still be using inode 17. However, the creates transaction did complete, and therefore x is going to be using inode 17 as well. And so now we mistakenly have two files that happen to be using the same inode, which means they’ll share content to write to one will mysteriously show up in the other file, which is completely the wrong thing, right?<br>恢复软件无法执行，无法执行。取消写入磁盘的链接，因此不会释放inode，不会在崩溃后删除Y，并且恢复y仍然存在。它仍将使用inode 17。然而，创建事务确实完成了，因此x也将使用inode 17。所以现在我们错误地拥有两个恰好使用相同inode的文件，这意味着它们将共享要写入的内容，其中一个将神秘地显示在另一个文件中，这是完全错误的事情，对吗？</p>
<p>发言人   01:17:39<br>The whole point was when we wanted it to unlink Y and use a freed iode in X, not a iode that was already in US. So something’s gone terribly wrong here, And one way of thinking about it is that that unlink in what should have been transaction to wrote a block, modified a block. And essentially that modified block was used by an earlier transaction. So a later transaction modified a block. And that modified block was seen by an earlier transaction. And indeed, information base. And this modification from transaction 2 was incorporated into transaction one. But that means that we’ve lost atomicity here because the whole know the goal of this was that all of the modifications for the unlink should occur or none of them not, not just some of them, But what’s essentially happened here is because transaction one committed the free of this inode, it means that some of transaction two’s modifications actually occurred, but others did not.<br>整个重点是当我们希望它取消链接Y并在X中使用已释放的iode，而不是已经存在于我们中的iode。所以这里出了一些可怕的问题，一种思考方式是，取消链接应该是写一个块，修改一个块。基本上，修改后的块被早期的交易使用。所以后来的交易修改了一个区块。并且修改后的区块在之前的交易中被看到。事实上，信息库。而这个对交易2的修改被整合到交易1中。但这意味着我们在这里失去了原子性，因为所有人都知道，这样做的目标是所有针对取消链接的修改都应该发生，或者不应该发生任何修改，而不仅仅是其中的一些，但这里基本上发生的是，事务一提交了这个inode的自由，这意味着交易二的一些修改实际上发生了，但其他的没有发生。</p>
<p>发言人   01:18:47<br>We broken atomicity by including later transactions, right? In an earlier transaction, you can actually imagine multiple different ways of dealing with this, right? You know, maybe create could notice that 17 have been freed by a future transaction and not use that inode in fact, ex 3 takes a sort pretty simple approach to this. It doesn’t allow any system call to start until all system calls from the previous transaction have finished. So there’s no possibility transaction a system call from transaction one seeing a mod, seeing an update from a system calling a future transaction, and essentially all of the unlink is pushed is blocked not allowed to start until T 1 commits any questions about this.<br>我们通过包含后来的交易打破了原子性，对吗？在早期的交易中，你实际上可以想象出多种不同的处理方式，对吧？你知道，也许create可能会注意到17个已被未来的事务释放，而不是使用那个inode，事实上，ex 3采取了一种非常简单的方法来实现这一点。它不允许任何系统调用启动，直到前一个事务的所有系统调用完成。因此，不可能发生事务，事务中系统调用看到一个mod，看到一个系统更新调用一个未来事务，并且基本上所有被推动的取消链接都不允许启动，直到T 1提交任何有关此问题的问题。</p>
<p>发言人   01:19:47<br>So I have a question about what exactly happens when you close an open transaction. Does it like snapshots? Like the current state of like the cash? Yes, that’s exactly right. So when we close this transaction, at least in principle, the system makes a copy of all the blocks that were modified by system calls in this transaction. The logging system makes a copy of them in the cache, sort of private copy just for so this transaction can commit them. And then future transactions execute sort of on the real cached blocks this transaction commits from its private copy of the blocks are modified. And then when it’s done committing those, it’s private copy of those blocks to disk, you can throw those copies away.<br>所以我有一个问题，当你关闭一个未结交易时究竟会发生什么。它像快照吗？就像现在的现金一样？是的，完全正确。因此，当我们关闭此事务时，至少原则上，系统会复制在此事务中被系统调用修改的所有块。日志系统在缓存中复制它们，这种私有副本只是为了让这个事务可以提交它们。然后，未来的事务在实际缓存的块上执行，该事务从其私有副本提交，块被修改。然后当它完成提交后，它就是这些块的私有副本到磁盘上，你可以扔掉这些副本。</p>
<p>发言人   01:20:43<br>Yes? Okay, there’s it. Turns out this is one of about half a dozen or a dozen sort of similar little quirks that Ex 3 has to deal with because in order to support Concur, there’s a whole bunch of similar little ordering niggles that have to be that sort of special cases that Ex 3 has to get right. Which we don’t have time to talk about, but the take home points that I want people to remember about logging and about Ex 3.<br>是的？好的，就这样。事实证明，这是前3必须处理的大约六个或十几个类似的小怪癖中的一个，因为为了支持一致意见，有一大堆类似的小订购小黑鬼，必须是前3必须正确处理的那种特殊情况。我们没有时间谈论这个问题，但是我希望人们记住的关于日志记录和Ex 3的要点。</p>
<p>发言人   01:21:20<br>First, just the general point that what logs are all about is making multi-step disk updates atomic, all or nothing with respect to crashes. Like, you know, that’s the main thing to remember about logging. The logging, the correctness of logging depends on this right ahead rule. That’s not critical thing to remember. You’ll hear write ahead log and right ahead rule a lot in the kind of crash recovery business. And the writer head rule says that you have to commit all changes to the log before you’re allowed to make any of the modifications to the home locations in the file system. And recovery absolutely relies on this rule.<br>首先，日志的一般意义在于使多步磁盘最新进展原子化，要么全部，要么完全不考虑崩溃。就像，你知道，这是关于记录要记住的主要事情。日志记录，日志记录的正确性取决于此正确的提前规则。这不是要记住的关键事情。你会在这种崩溃恢复业务中听到提前登录和提前规则。而writer head规则规定，在允许对文件系统中的主位置进行任何修改之前，您必须提交对日志的所有更改。恢复绝对依赖于这个规则。</p>
<p>发言人   01:22:02<br>A lot of the point, at least the file systems, a lot of the point of logging, is it simply fast recovery. The log may have a couple hundred blocks in it. You can play a couple hundred blocks in way under a second, and then boom, your file system, even a very large one, is now fit for use.<br>很大程度上，至少在文件系统和日志记录方面，就是快速恢复。日志中可能有几百个区块。你可以在一秒钟内玩几百个积木，然后突然，你的文件系统，即使是非常大的文件系统，现在也适合使用。</p>
<p>发言人   01:22:22<br>And a final point for more detailed point about exxtacy is that it uses batching and concurrency to get considerably better performance than XV 6 does, although the case of considerably higher complexity to support concurrency than XV 6 had. And that’s all for today.<br>关于exxtacy更详细的最后一点是，它使用批处理和并发来获得比XV 6更好的性能，尽管支持并发的复杂性比XV 6高得多。今天就到这里。</p>
<p>发言人   01:22:44<br>I’m happy to take questions. Hi, I had another question it about so you said that things that there’s a file like a file system thread that does all this stuff, there must be only one of this threads because otherwise it could, it could do basically what you just talked about, right? It may indeed be that there’s just one. I actually don’t know how many there are. One is certainly a particularly attractive number because a lot of the rationale for why the logging is correct is that the older transactions no committed before newer transactions. I don’t think it’s a logical necessity that there’d be only one thread, though. You could imagine old transactions committing in an overlapped way, you know, essentially using multiple threads, one for each transaction. Oh, okay, I see.<br>我很乐意回答问题。嗨，我还有一个问题，所以你说有一个文件系统线程来做所有这些事情，必须只有一个线程，否则它可以，它可以基本上做你刚才谈到的事情，对吗？可能确实只有一个。我其实不知道有多少。一个肯定是一个特别有吸引力的数字，因为记录正确的很多理由是旧的交易在新的交易之前没有提交。我认为逻辑上并不需要只有一个线程。你可以想象旧交易以重叠的方式提交，你知道，基本上使用多个线程，每个线程代表一个交易。哦，好的，我明白了。</p>
<p>发言人   01:23:57<br>Okay, I see. In when you’re talking about crashes and you have that diagram of T 8 rewriting T 5 that was being freed. So what happens if T 8 hasn’t actually committed at the point of the crash? Because there could be maybe T 5 if it’s being freed as something needs to rewrite it, then there could be a commit block from T 5 that exists and maybe a location where T 8 would have predicted it to exist. And then couldn’t that inaccurately represent that T 8 was actually had actually been committed.<br>好的，我明白了。当你谈论崩溃时，你有t8重写被释放的t5的图表。那么，如果T 8在崩溃时没有真正投入，会发生什么？因为如果需要重写它而被释放，可能会有T 5，那么可能会有一个来自T 5的提交块存在，并且可能会有一个位置，在那里T 8会预测它存在。然后不能不准确地表示T 8实际上已经被提交了。</p>
<p>发言人   01:24:40<br>Okay, so let me try to draw out the scenario separate. So we have this ancient transaction T 5. And, you know, maybe a T 6. And then we’ve wrapped around a T 8 and T 8 started somewhere. Now it, because T 5 is free. T 8 is starting eat up. T 5, that is, the end of T 8 is overrun. The beginning of T 5 is that. And the worry is, okay, if, of course, the T did commit, then it’ll end up in a commit block. It’ll look pretty reasonable if there’s a crash in recovery. And the scenario you’re worried about is that T did not commit, right? And maybe right before writing the block. Okay, so the juicy, yeah, exactly.<br>好的，让我试着把这个场景分开画出来。所以我们有了这个古老的交易t5。而且，你知道的，也许是T 6。然后我们围绕着T 8展开，T 8从某个地方开始。现在它，因为T 5是免费的。T 8开始吃起来了。T 5，即T 8的结尾是超支。T 5的开头就是这样。而担心的是，好吧，当然，如果T确实提交了，那么它最终会成为一个提交块。如果恢复出现崩溃，看起来会相当合理。你担心的情况是T没有承诺，对吗？也许就在写区块之前。好的，所以多汁的，是的，没错。</p>
<p>发言人   01:25:38<br>T got T 8 just happens to be going to put its commit block in exactly the same place where T 5 put its commit block, but it didn’t quite get the rating, the commit block. It’s all good, except this, we have a totally correct T 8, but it’s T five’s commit block. Yeah, and you’re wondering, gosh, looks just like a commit block. Okay, the answer is that the descriptor blocks and commit blocks, as well as everything else, have the sequence number of the transactions. So this descriptor block has an 8 in it, and but T 5 s commit descriptor doesn’t matter, but T five’s commit block has a five in it and. So it’s looking for 8 as well as the magic number.<br>T得到了t8，只是碰巧要把它的提交块放在t5放置其提交块的完全相同的位置，但它并没有完全得到评级，即提交块。这一切都很好，除了这个，我们有一个完全正确的t8，但它是t5的提交块。是的，你想知道，天哪，看起来就像一个提交块。好的，答案是描述符块和提交块以及其他所有内容都有事务的序列号。因此，这个描述符块中有一个8，但是T 5的提交描述符并不重要，但是T 5的提交块中有一个5。所以它在寻找8以及神奇的数字。</p>
<p>发言人   01:26:25<br>Wait, but in this case, well, then you also have the descriptor block of T 5. So you don’t really need the numbers. Well, in this particular case, so yeah, t 5 used to have a descriptor block here with a five in it. However, T 8 is so large that T 8 overwrote this descriptor block with one of its own data blocks. So that T 5 descriptor block has now gone and been replaced by a T 8 data block. So, yeah, it used to be evidence for transaction 5, but now it’s gone. So do we know the size of transaction 8 before we started?<br>等待，但在这种情况下，那么你也有T 5的描述符块。所以你真的不需要数字。在这种情况下，是的，t 5曾经有一个带5的描述符块。然而，t8太大了，以至于t8用它自己的一个数据块覆盖了这个描述符块。因此，t5描述符块现在已经消失并被t8数据块替换。所以，是的，它曾经是交易5的证据，但现在它已经消失了。那么在我们开始之前，我们知道交易8的大小吗？</p>
<p>发言人   01:27:21<br>Sorry, this is a complex question. It’s probably the case that that. Okay, when T 8 was opened as the active transaction that system calls were writing into at that point in time, the system didn’t know how big T 8 was going to be. When the system starts committing T 8, it doesn’t. It does know how t, how big T 8 is. The system doesn’t start committing T 8 until after T 8 is closed and all of its system calls are finished. And at that point, the system knows. I mean, it saw all the rights that were done, all the rights for have completed, all the system calls are completed. So the system knows how big it is.<br>抱歉，这是一个复杂的问题。这可能是事实。好的，当系统调用在那个时间点写入的活动事务打开T 8时，系统不知道T 8会有多大。当系统开始提交T 8时，它不会。它确实知道t有多大，T 8有多大。系统在T 8关闭并完成所有系统调用之前不会开始提交T 8。到那时，系统就知道了。我的意思是，它看到了所有完成的权利，所有完成的权利，所有系统调用都完成了。这样系统就知道它有多大。</p>
<p>发言人   01:28:07<br>And one reason why that must be is that the descriptor block holds the complete list of blocks in that transaction. So at the time the descriptor block was written, which is first, the logging system knew how many blocks that were going to be in T 8.<br>其中一个原因是描述符块保存了该事务中完整的块列表。因此，在写入描述符块时，即第一个，日志系统知道将在t8中包含多少个块。</p>
<p>发言人   01:28:24<br>Yeah, okay, I see. I see, thank you. Why don’t we just kind of like have the commit information in the descriptor block and avoid this kind of problem? Because I know, I know, it’s not great that we have to go back and like right back to a location, like not in sequence, but wouldn’t that help?<br>是的，好的，我明白了。我明白了，谢谢。为什么我们不把提交信息放在描述符块中，避免这种问题呢？因为我知道，我知道，我们必须回到一个地方并不是很好，就像没有顺序一样，但是这不会有帮助吗？</p>
<p>发言人   01:28:46<br>Okay, so the proposal is that instead of having a commit block, we basically have the descriptor block act as a commit block. And Xb 6 actually is very much like this. And you know, you could do it. In fact, I think you can do it without, at least in Ex 3 without sacrificing efficiency. However, you have to play the same. You have to structure this in the same way that XV 6 does, namely.<br>好的，所以我们的提议是，我们基本上将描述符块作为提交块，而不是使用提交块。而Xb 6实际上非常像这样。你知道，你可以做到。事实上，我认为你可以在不牺牲效率的情况下，至少在Ex 3中做到这一点。然而，你必须玩同样的游戏。你必须以与XV 6相同的方式来构建它，即。</p>
<p>发言人   01:29:19<br>You, if there’s a, you know, there have to be something in the descriptor block that indicates this is a committed transaction and we’re not allowed to set whatever that flag is until after all of the data blocks have been written. So the routine would have to be we don’t rate the commit block first. Instead, we write all the data blocks for transaction 8 first, and then we go back and write the commit block with the block numbers or a descriptor block, whatever it is now, and some kind of magic.<br>你，如果有，你知道，在描述符块中必须有一些东西来指示这是一个提交的事务，并且在所有数据块写入之前，我们不允许设置任何标志。因此，例程必须首先不评估提交块。相反，我们首先编写事务8的所有数据块，然后我们返回并写入具有块编号或描述符块的提交块，无论它现在是什么，以及某种魔法。</p>
<p>发言人   01:29:49<br>This is really a committed transaction. So we could write all the data blocks and then go back and write the commit block descriptor, commit block, whatever. I don’t know any. I don’t know any reason why this couldn’t be made to work. I don’t think it, I don’t think it really eliminates any of the problems we’ve discussed because we still have this problem.<br>这实际上是一个承诺的交易。所以我们可以写入所有数据块，然后返回并写入提交块描述符、提交块等。我什么都不认识。我不知道为什么这不能工作的原因。我不认为，我认为它并没有真正消除我们讨论过的任何问题，因为我们仍然有这个问题。</p>
<p>发言人   01:30:18<br>The original problem was, was, gosh, how do we distinguish this commit, this stale commit block from transaction 5, from a true commit block? For transaction 8? We’re going to have the same problem here. This, it could be that what’s sitting here just happens to be the descriptor block from transaction 5. And so, you know, maybe we’ve gone ahead and written all the data blocks for transaction 8. And then there was a crash.<br>最初的问题是，天哪，我们如何区分这个提交，这个陈旧的提交块与事务5，和一个真正的提交块？对于交易8？我们这里也会遇到同样的问题。这可能是这里恰好是交易5的描述符块。所以，你知道，也许我们已经为交易8写入了所有的数据块。然后发生了撞车事故。</p>
<p>发言人   01:30:41<br>The recovery software still needs to be able to tell the difference between to be able to look at this descriptor block and say, wait a minute, you know, there’s something wrong here. Even though this looks like a valid descriptor block, it’s not really. And so we’d still have to have the magic number and the transaction number, the sequence number.<br>恢复软件仍然需要能够区分两者之间的差异，以便能够查看此描述符块并说，等一下，你知道这里有问题。尽管这看起来像一个有效的描述符块，但实际上并不是。因此，我们仍然需要有神奇的数字和交易编号，即序列号。</p>
<p>发言人   01:31:01<br>Oh yeah, that makes sense. Yeah, I was just thinking like we have, we kind of have like the commit part in the description block, but obviously like when we start here, we write the descriptive block saying it’s uncommitted. Then we write the data blocks, then we say it’s a committed this right?<br>哦，是的，那很感知。是的，我只是想，我们在描述块中有点像提交部分，但显然，当我们从这里开始时，我们写描述性块说它是未提交的。然后我们写数据块，然后我们说它是一个提交的，对吗？</p>
<p>发言人   01:31:16<br>Now, the thing that could be saved here is the expense of waiting for these rights and then writing a commit block. That weight is quite expensive. We’re not allowed to start the rate of the commit block until the data blocks or on the disc. And I don’t think we have to have the same weight before we in the sort of new single block scheme. We have to have the same rate weight before we’re allowed to write this new descriptor block. So it saves a block, but it doesn’t save. I don’t think it would save much time.<br>现在，可以保存的是等待这些权限然后编写提交块的开销。这个重量相当昂贵。我们不允许在数据块或光盘上启动提交块的速率。我认为在新的单一区块方案中，我们不需要拥有相同的权重。在允许编写这个新的描述符块之前，我们必须具有相同的速率权重。所以它保存了一个块，但它不保存。我认为这样做不会节省很多时间。</p>
<p>发言人   01:31:48<br>The trick that later versions of the Linux file system play? That sort of does do what I think you’re hoping for.<br>后续版本的Linux文件系统的诀窍是什么？这确实做了我认为你所希望的事情。</p>
<p>发言人   01:31:59<br>You know, this is sort of looking into the ext 4 does the following for better efficiency of writing the commit blocks. It Ex 4 will write out all the data blocks and the commit block at the same time. That is, it doesn’t wait for the data block rates to finish before it writes the commit block. So it doesn’t have this long pause. But then there’s this terrible issue of what happens if the disc, the disk is free to do rights out of order?<br>你知道，这是在某种程度上研究ext 4的以下功能，以提高编写提交块的效率。它将同时写出所有数据块和提交块。也就是说，它不会等待数据块速率完成后才写入提交块。所以它没有这么长时间的停顿。但是有一个可怕的问题，即如果光盘可以自由地按顺序执行权利会发生什么？</p>
<p>发言人   01:32:32<br>What if the disk writes the commit block first before it actually performs the rights for the data blocks, and then there’s a crash? Then we have a commit block without having the discover having written the data blocks. And the way Ex 4 solves that. Is it has a checksum in the commit block over a checksum over all the data blocks? And so if there’s a crash happens after the commit block was written but before the data blocks were written, the checksum won’t work out the recovery software, look at this checksum, and then it’ll compute the checksum over the data blocks that are actually in the log. If they’re not the same, it knows that something went wrong. And so by doing this, x 4 basically saves another, a mechanical drive saves an entire rotation that would happen if it had to wait for the data box before it commits. Okay, thanks, sure.<br>如果磁盘在实际执行数据块的权限之前先写入提交块，然后发生崩溃怎么办？那么我们有一个提交块，而没有发现程序写入数据块。以及Ex 4解决这个问题的方式。它在提交块中的校验和是否超过了所有数据块的校验和？因此，如果在提交块写入之后但在数据块写入之前发生崩溃，校验和将无法处理恢复软件，请查看此校验和，然后它将计算日志中实际数据块的校验和。如果它们不一样，它就知道出了问题。因此，通过这样做，x 4基本上可以保存另一个，机械驱动器可以保存整个旋转，如果它必须等待数据框才能提交，就会发生这种情况。好的，谢谢，当然。</p>
<p>发言人   01:33:35<br>That’s cool? I love this stuff, but this is pretty cool. I wanted to ask also about the data blogs, just the content blogs. So I think I got confused. But where in this task that we were talking about on your one of your previous boards, where would that be done? Where would we be done? So like not the metadata blocks, but the actual file content, right? Okay, this is, there’s sort of multiple answers to this in.<br>这很酷？我喜欢这个东西，但这很酷。我也想问一下数据博客，只是内容博客。所以我想我搞混了。但是，在我们在你之前的董事会上讨论的这项任务中，将在哪里完成？我们将在哪里完成？所以不像元数据块，而是实际的文件内容，对吧？好的，这个问题有多个答案。</p>
<p>发言人   01:34:18<br>Ext 3 has multiple modes. For what happens to the data blocks? There’s 3, 2 of which I remember. There’s journaled data. And order data in the and you when you configure an Ex three file system, you tell Linux which you want.<br>Ext 3有多种模式。对于数据块会发生什么变化？有3个，其中2个我记得。有日志数据。然后在中排序数据，当您配置一个Ex三文件系统时，您告诉Linux您想要哪个。</p>
<p>发言人   01:34:47<br>If you ask for journal data, then file content just goes right into the log. There’s nothing special going on. If you write data to file and that causes the inode to be updated, then the log is going to contain your data and the updated. Inode, everything that’s modified goes in the log. So that’s journal data. But of course, it’s quite slow or slower than you might hope because. Know now, if you write a whole bunch of data, it has to be written once to the log and then a second time to the home location. So the journal data schema, sort of straightforward, but slow.<br>如果您要求提供日志数据，那么文件内容就会直接进入日志。没有什么特别的事情发生。如果您将数据写入文件并导致inode更新，则日志将包含您的数据和更新的数据。Inode，修改的所有内容都在日志中。这就是日志数据。但当然，它比你希望的要慢或慢，因为。现在知道了，如果你写入一大堆数据，它必须写入一次日志，然后第二次写入主位置。所以日志数据架构有点简单，但很慢。</p>
<p>发言人   01:35:29<br>Then there’s this other ordered data scheme. The people, it’s actually the most popular mode. That doesn’t write the data to the log in the order data scheme. Only metadata like inodes and directory blocks are written to the log file. Content block is just written directly to the home locations in the file system. And so it’s a lot faster. You don’t have to write the file content twice. It does lead to more complexity though, because.<br>然后还有另一个有序数据方案。对于人们来说，这实际上是最流行的模式。它不会将数据写入订单数据方案中的日志。只有像inode和目录块这样的元数据被写入日志文件。内容块直接写入文件系统中的主位置。所以它的速度要快得多。你不需要将文件内容写入两次。但这会导致更多的复杂性，因为。</p>
<p>发言人   01:36:02<br>You can’t just write the file data anytime you want, because then there’s a risk that if you don’t worry about the order in which you write the inodes versus the file data, there’s the risk that you might do a write that causes a new block to be allocated for a file and have the updated inode be written into the log and committed, and then have a crash happen before you get around to writing the actual file content to the disk. And then after recovery, what you would see is the inode with the new newly allocated data block, but the old contents of that data block from whatever file previously used that data block. And so if you’re running a system that has multiple users, like in Athena system, then it could be that one user will end up having a file that contains contents from another user’s deleted file.<br>你不能随时随意写入文件数据，因为如果你不担心写入索引节点和文件数据的顺序，就会有风险。存在这样的风险，即您可能会进行写入，导致为文件分配新的块，并将更新的索引节点写入日志并提交，然后在您将实际文件内容写入磁盘之前发生崩溃。然后在恢复后，您会看到带有新分配的数据块的inode，但是来自先前使用该数据块的任何文件的该数据块的旧内容。因此，如果您运行的系统有多个用户，例如在Athena系统中，那么一个用户最终可能会拥有一个包含另一个用户删除文件内容的文件。</p>
<p>发言人   01:36:58<br>If we’re not careful about the order in which we write the data versus the inotes. Aex D3 order data mode solves this by not committing the modified inode until after the file content that has been written to disk. So if you’re an application and you write to a file, and that right causes a new block to be allocated, the file system will write the new file content to the newly allocated block. And once that write is finished, only then will it commit the transaction that causes the inode to be updated to have the new block number. And that means that a crash, if there’s a crash, it’s going to be happened between when you wrote the data or after you wrote the data and before you wrote the inode, and therefore, it won’t reveal somebody else’s old deleted data block to the new user file.<br>如果我们不小心写入数据与inotes的顺序。Aex D3顺序数据模式通过在写入磁盘的文件内容之前不提交修改过的inode来解决这个问题。因此，如果您是一个应用程序，您写入了一个文件，并且该权限导致分配了一个新块，则文件系统会将新文件内容写入新分配的块。一旦写入完成，它才会提交导致inode更新为新块编号的事务。这意味着崩溃，如果发生崩溃，它将发生在您写入数据的时间之间，或在您写入数据之后，以及在您写入inode之前，因此，它不会将其他人的旧删除的数据块显示给新的用户文件。</p>
<p>发言人   01:37:57<br>Okay, I see. Okay, I see. But you could still have the data, but not the Iode. Yeah, you might.<br>好的，我明白了。好的，我明白了。但你仍然可以拥有数据，但没有Iode。是的，你可以。</p>
<p>发言人   01:38:06<br>If there’s a crash after you wrote the data block, before you wrote the inode, then you’ll have updated the data block. But it doesn’t matter because not only did you not write the inode, you also didn’t write the updated block, free bitmap block. And so that block will still be free and be allocated for something else. So you don’t even lose a block, all right? And if it was an old blog, then it’s still okay, right? Say that again, if it was just just the same, the same block, you just write some new data to it, but same block, same size, same same location, but we already wrote like it’s not that we created a new block, but in the old block, we just wrote some extra data, but it was a little bit, so it didn’t need to create a new one. Yeah, we wrote data, we ended up writing to a data to a block that was not in use by any file, so it it’s not visible, right? Okay, I see you thank you, goodbye.<br>如果在您写入数据块后、写入inode之前发生崩溃，那么您将更新数据块。但这并不重要，因为您不仅没有编写inode，也没有编写更新的块和空闲的位图块。因此，该块仍将是免费的，并被分配用于其他用途。所以你连一个区块都不会丢失，好吗？如果它是一个旧博客，那么它仍然没问题，对吧？再说一遍，如果它只是同一个块，你只需向它写入一些新数据，但是相同的块，相同的大小，相同的位置，但我们已经写入了，好像不是我们创建了一个新的块，而是在旧的块中，我们只是写了一些额外的数据，但是有一点，所以不需要创建新的数据。是的，我们写了数据，最终我们把一个数据写到一个没有被任何文件使用的块中，所以它是不可见的，对吧？好的，我看到了，谢谢你，再见。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>操作系统工程 015-FileSystem Performance and Fast Crash Recovery</div>
      <div>http://example.com/2025/10/18/6S081-015/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月18日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/18/6S081-016/" title="操作系统工程 016-VirtualMemory for Applications">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">操作系统工程 016-VirtualMemory for Applications</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/18/6S081-014/" title="操作系统工程 014-Crash Recovery">
                        <span class="hidden-mobile">操作系统工程 014-Crash Recovery</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
