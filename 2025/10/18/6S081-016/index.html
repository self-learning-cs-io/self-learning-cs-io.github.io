

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="发言人   00:00Lab compares to, say, the locking lab.实验室与锁定实验室相比。 发言人   00:07Seems a bit more straightforward. Good, are you completed? Have you finished the La where you’re? I just started yesterday. I’m">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统工程 016-VirtualMemory for Applications">
<meta property="og:url" content="http://example.com/2025/10/18/6S081-016/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="发言人   00:00Lab compares to, say, the locking lab.实验室与锁定实验室相比。 发言人   00:07Seems a bit more straightforward. Good, are you completed? Have you finished the La where you’re? I just started yesterday. I’m">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-18T02:00:16.000Z">
<meta property="article:modified_time" content="2025-10-19T11:16:51.144Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>操作系统工程 016-VirtualMemory for Applications - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="操作系统工程 016-VirtualMemory for Applications"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-18 10:00" pubdate>
          2025年10月18日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          19k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          162 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">操作系统工程 016-VirtualMemory for Applications</h1>
            
            
              <div class="markdown-body">
                
                <p>发言人   00:00<br>Lab compares to, say, the locking lab.<br>实验室与锁定实验室相比。</p>
<p>发言人   00:07<br>Seems a bit more straightforward. Good, are you completed? Have you finished the La where you’re? I just started yesterday. I’m halfway. So okay, I guess that’s good news for other people that are starting. Anybody finished it yet? I have I finished any any nasty surprises or work that reason all well, I think it worked out okay. Yeah, great, it easier than the log La I think so at least. Well, hopefully it’ll be the case for everybody else too let. Me get started?<br>似乎稍微简单一些。好的，你完成了吗？你在哪里，你已经完成了吗？我昨天才开始。我走了一半。所以好吧，我想这对其他正在开始的人来说是个好消息。有人完成了吗？我已经完成了任何令人讨厌的惊喜或工作，我认为这一切都很好。是的，太好了，至少我认为它比日志更容易。好吧，希望其他人也会这样。我开始吗？</p>
<p>发言人   00:51<br>The topic I want to talk about today is virtual memory for user applications on. Guided by this paper from 91 by appellant Lee. And so the starting point basically is that, as you well know now, that OS kernels. Use virtual memory page tables in Creative Wave.<br>今天我想谈论的主题是用于用户应用程序的虚拟内存。在上诉人李先生的指导下，从91年开始。所以起点基本上是，正如你现在所知道的，OS内核。在创意浪潮中使用虚拟记忆页表。</p>
<p>发言人   01:26<br>You’ve seen that we have a lazy allocation lab copy and write lab, as well as many other sort of features that, you know, implementation two or aspects of the implementation in XV 6.<br>你已经看到我们有一个懒惰的分配实验室副本和编写实验室，以及许多其他类型的功能，你知道，在XV 6中实现的两个方面或两个方面。</p>
<p>发言人   01:42<br>Basically the argument that the paper makes the. Paper argues that the user application should actually benefit too, or should have the same power. These user apps, you can use VM 2. And I mean, the VM, of course, here’s application you’re running with virtual memory. But what I really, really mean with VM is that they would like to have the same mechanisms that the kernel has at least access in user application, in user modes, for example, being able to take page faults and then, you know, respond to those page faults, you know, be able to change the protection bits or the privileged level levels in the page table.<br>基本上是这篇论文提出的论点。论文认为用户应用程序也应该真正受益，或者应该具有相同的能力。这些用户应用程序，您可以使用VM 2。我的意思是，虚拟机，当然，这是您使用虚拟内存运行的应用程序。但是我对VM真正的意思是，他们希望拥有与内核在用户应用程序中至少访问相同的机制，例如，在用户模式下，能够处理页面错误，然后，你知道，响应这些页面错误，你知道，能够更改页表中的保护位或特权级别级别。</p>
<p>发言人   02:33<br>The paper argues this case by looking at a bunch of different applications. Like 6 or 7 different types of applications. And maybe it will ask you like, what was your sort of favorite application that you encountered in the paper? Anybody want to chime in and fight the? Where? They can allow the user application to decide at a page is going to be, I guess, change the access bits for some particular page. Yeah, that’s one of the mechanisms. I’m just curious, like which applications, you know? So they make the case we have a bunch of different applications, correct? Like the garbage collector. Or occurrent cars collector and had a couple other ones? And I was just wondering which ones you thought were most interesting?<br>这篇论文通过研究一堆不同的应用来论证这个案例。像6或7种不同类型的应用程序。也许它会问你，你在报纸上遇到的最喜欢的应用是什么？有人想插嘴打吗？在哪里？它们可以允许用户应用程序决定一个页面是否要更改某个特定页面的访问位。是的，这是其中一个机制。我只是很好奇，像哪些应用程序，你知道吗？所以他们让我们有很多不同的应用程序，对吗？就像垃圾收集器一样。或者是收藏汽车的收藏家，还有其他几辆？我只是想知道你认为哪些是最有趣的？</p>
<p>发言人   03:40<br>So what other applications did they use or did they use to make that case? I thought the data compression application was pretty cool. Any other that were. People were compelled by.<br>那么他们使用了哪些其他应用程序或者使用了哪些应用程序来制作这个案例？我觉得数据压缩应用程序很酷。任何其他的。人们是被强迫的。</p>
<p>发言人   04:04<br>I thought the sort of shared virtual memory between multiple different systems, that was pretty cool. I didn’t, I don’t think I fully understood how it, how it worked, but the general idea of using the protection bits to make sure that different machines are using that shared memory in the right way and protecting invariance makes sense. Basically, turns out that that whole area developed in that one paper that originally described Sbm developed in a whole research area and where the people have all kinds of clever tricks to try to make that scheme to fly any other.<br>我认为在多个不同系统之间共享虚拟内存非常酷。我没有，我认为我没有完全理解它是如何工作的，但是使用保护位来确保不同的机器以正确的方式使用共享内存并保护不变性的总体思路是感知的。基本上，原来整个领域都是在那篇论文中发展的，这篇论文最初描述了Sbm在整个研究领域的发展，那里的人们有各种聪明的技巧来尝试使这个计划飞行到其他任何领域。</p>
<p>发言人   04:50<br>Because so to go off, they do a couple other applications. And they basically argue, you know, if you look at all these different, quite different applications, like the shared through memory, the data comparison garbage collector, you know, very different in nature. But it turns out that all of them might actually rely on a small number of virtual memory primitives to actually make it work. And so the first question to the paper addresses is like, okay, what should the primitives look like user application needs if they want to implement one of those applications? And so let me talk a little bit about that first. You know what room it is.<br>因为这样下去，他们会做一些其他的应用。他们基本上认为，你知道，如果你看看所有这些不同的，非常不同的应用程序，比如通过内存共享，数据比较垃圾收集器，你知道，性质非常不同。但事实证明，它们实际上可能依赖于少量的虚拟内存原语来使其工作。所以论文地址的第一个问题是，好吧，如果用户想要实现其中一个应用程序，原语应该是什么样子？所以让我先谈谈这个问题。你知道这是什么房间。</p>
<p>发言人   05:33<br>And so the. Ones, the obvious one, of course you need something of pre manipulate kind, what I call trap, basically to allow a page fault that happens sort of inside the kernel to be propagated up to user space. And then in your space, you know, the handler, you know, can then deal with the it’s page faults and then of course, return in the usual way back to the kernel. And then you resume the instruction. So clearly in the primitive, like that is necessary because otherwise you couldn’t do anything in response to page fault.<br>所以。显然，你当然需要一些预先操作的东西，我称之为陷阱，基本上是为了允许内核内部发生的页面错误传播到用户空间。然后在你的空间中，你知道，处理程序可以处理它的页面错误，当然，以通常的方式返回到内核。然后你继续执行指令。所以在原语中很明显，像这样是必要的，因为否则你不能做任何事情来响应页面错误。</p>
<p>发言人   06:07<br>The other primitive that they talk about is prop 1, which. Decreases the accessibility of the page. They talk a lot about accessibility. And what do you mean with accessibility? Anybody? Oh, well, there’s Reed, right? Or for user, yeah. So different ways in which you can decrease the accessibility. You know, you go from a page that maybe has read the right, you go to just read only, or maybe you go through, you know, read only to actually have no access at all.<br>他们谈论的另一个原始人是道具1。降低了页面的可访问性。他们经常谈论无障碍性。你说的可访问性是什么意思？有人吗？哦，好吧，有芦苇，对吧？或者对于用户来说，是的。因此，您可以通过不同的方式降低可访问性。你知道，当你从一个可能已经阅读正确的页面进入只读页面，或者你通过只读页面实际上根本没有访问权限。</p>
<p>发言人   06:56<br>They also proposed that basically there should be one for each individual page that proc 1. There also should be one that actually you can do for that. The application can call for a collection of pages and basically pro n boils down in principle to calling Pro 1 n times.<br>他们还提出，基本上每个proc 1页面都应该有一个proc 1。也应该有一个你可以为此做的事情。该应用程序可以调用页面集合，基本上可以将其归结为调用pro 1 n次。</p>
<p>发言人   07:13<br>But why do they argue that we should have actually a pro N version of this primitive 2? Is it because actually it’s more efficient? Because the overhead of protecting the end pages is not much more than protecting one? Because they talked about something like amortizing the work of. Yeah, you have absolutely right. So basically, if you do a product 1, basically you have to change the page table bits and do some work. And then at the end of that problem one, you know, typically we want to have to flush the Tob. You may remember this from the X 6 implementation and flushing the Dob is expensive and so it would be nice if you could amortize basically flushing the Tov over you.<br>但为什么他们认为我们应该有一个原始版本的2呢？是因为它更有效率吗？因为保护结束页面的开销并不比保护一个页面多得多？因为他们谈论了一些类似于摊销工作的事情。是的，你完全正确。所以基本上，如果你做一个产品1，基本上你必须改变页表位并做一些工作。然后在第一个问题的结尾，你知道，通常我们想要刷新Tob。你可能还记得这个来自x6实现的东西，并且刷新Dob是昂贵的，所以如果你可以摊销基本上刷新Tov就太好了。</p>
<p>发言人   08:05<br>The page table changes. And so basically n boils down to n n times changing page table bits plus 1 Tob flush. And if you did n times plot one, you would have one page table switch plus or one page table table modification plus 1 Tob flush for each page. And so you can see if the Pob flushes, does it make sense?<br>页表发生变化。因此基本上，n归结为n n次改变页表位加上1个定制表刷新。如果您进行了n次绘图，您将为每页one page表开关加上或one page表修改加上1次Tob刷新。所以你可以看到如果Pob冲洗，它会感知吗？</p>
<p>发言人   08:37<br>Okay, then you know the a primitive called unprotected, Basically this increases accessibility, as they call it. Basically meaning, you know, if they, for example, have Washington read only access, now we’re just going to promote it to actually have read and write access. And there are two other primitives that are mentioning. One is primitive to actually find out which whether paint too dirty and another primitive, you map 2, which allows to allows an application to the map a particular range twice in the same address space, same address space, the different degrees of accessibility. And we’ll see that showing up in a second. So you look at these primitives, you know those x 6 support any of these for usual level applications.<br>好的，那么你知道一个叫做unprotected的原语，基本上这会增加可访问性，就像他们所说的那样。基本上，你知道，如果他们，例如，华盛顿州只读访问，现在我们只会将其提升为实际的读写访问。这里还提到了另外两个原语。一个是原语，用于实际发现油漆是否太脏，另一个是原语，您可以映射2，它允许应用程序在相同的地址空间、相同的地址空间和不同的可访问度中两次映射特定的范围。我们很快就会看到它出现。所以你看看这些原语，你知道那些x 6支持普通级别应用程序中的任何一个。</p>
<p>发言人   09:46<br>Not out of the box, but maybe the alarm handler that we implemented feels close. Good, good, yeah. Keep the alarm handler in their mind. That certainly feels very close. Correctly related to the trap 1. But other than that, x 3, 6 ports, none of these x 6 has a very minimal Unix interface and doesn’t support any sort of more advanced virtually or prim diffs, even though internally the kernel itself does have all the mechanism available, but it’s just not exposed in user space and to inform what system calls.<br>不是开箱即用，但也许我们实现的警报处理程序感觉很接近。好的，好的，是的。让警报处理程序保持在他们的脑海中。这当然感觉非常接近。正确地与陷阱1相关。但除此之外，x3，6个端口，这些x6都没有非常小的Unix接口，也不支持任何更高级的虚拟或原始差异，即使内核本身具有所有可用的机制，但它并没有暴露在用户空间中，也没有告知系统调用的内容。</p>
<p>发言人   10:24<br>So even what the paper is arguing is that any sort of good operating systems should provide, you know, these premium minister system calls so that applications can use them. So naturally, it relates to the question like what’s this group with Unix today are are these available? And it turns out that basically, you know, any if you look at the modern units like say Linux, you know, these primitives are Danner, maybe not exactly in the same flavor as argued in the paper, but they are there. And you even saw it in the paper correct there. Some of the operating system did have some version has a subset of them, But today they basically, you know, sort of whitening support it. So if you look at Unix today, let’s see how to vaccinate or instantiate it.<br>因此，甚至这篇论文所主张的是，任何一种好的操作系统都应该提供这些高级部长系统调用，以便应用程序可以使用它们。所以很自然地，它涉及到这个问题，比如今天的Unix小组有什么可用的吗？事实证明，基本上，你知道，如果你看一下现代单位，比如Linux，你知道，这些原语是Danner，可能与论文中提到的风格不完全相同，但它们确实存在。你甚至在报纸上看到它是正确的。一些操作系统确实有一些版本，其中有一个子集，但今天他们基本上，你知道，有点白化支持它。所以，如果你今天看Unix，让我们看看如何接种疫苗或实例化它。</p>
<p>发言人   11:12<br>And so one of the first ones, there’s probably the most important one, is something system called called Nmap. That can be used to take some object and map it into the address space of the color. So for example, if you want to map a file. Then the system calls something of this following form you call a map.<br>因此，最早的一个，可能是最重要的一个，是一种叫做Nmap的系统。这可以用于获取一些对象并将其映射到颜色的地址空间。例如，如果您想映射一个文件。那么系统调用以下形式的东西，你称之为地图。</p>
<p>发言人   11:37<br>NMAC actually has quite a bewildering number of arguments. The first basically says, like whether you can specify a particular address you would like it to be map 2, or you can collect the kernel, the site to choose the address. And in that case, you specify just null and the curtain will pick an address where to map object. You specify the length, you specify the protection bits. You know, for example, the read slash, right? And then, you know, some argument I don’t really want to talk about, but there’s something called like math private. Basically, you have to say something about how. What happens if you have to write to that particular object? Skipped up, mostly.<br>NMAC实际上有相当多令人困惑的论点。第一个基本上是说，你是否可以指定一个特定的地址，你希望它是地图2，或者你可以收集内核，网站来选择地址。在这种情况下，只需指定null，窗帘就会选择一个地址来映射对象。您指定长度，您指定保护位。例如，你知道斜杠，对吧？然后，你知道的，有些争论我真的不想谈论，但是有一种叫做数学私有的东西。基本上，你必须说一些关于如何做的事情。如果你必须写入那个特定的对象会发生什么？基本上跳过了。</p>
<p>发言人   12:28<br>And then you can, we can do actually pass in the file descriptor and then offset. And basically what this says is that you should map the content of the file object pointed to by the file descriptor. And you take the file content to that object at offset and map that basically that that particular address from them with that length. And so this basically allows you to sort of what is called memory map a file.<br>然后你可以，我们可以实际传递文件描述符，然后是偏移量。基本上，这就是说，您应该将文件描述符所指向的文件对象的内容映射起来。然后你将文件内容带到偏移位置的对象，并从它们那里基本上映射那个长度的特定地址。因此，这基本上允许您对所谓的内存映射文件进行排序。</p>
<p>发言人   12:55<br>So you can basically bring the contents of the file into your address space with actually having to call, read, and write system calls. And it’s sort of convenient, correct? Because then you can manipulate the file just, you know, with ordinary pointers, you can write at particular locations. And then, you know, at some point, you can write the content back to the to the disk. And so this is a convenient interface to manipulate data structures that we might be stored, might be stored in a file.<br>因此，您基本上可以将文件的内容带入您的地址空间，而实际上需要调用、读取和写入系统调用。而且有点方便，对吗？因为这样你就可以只使用普通的指针来操作文件，你可以在特定的位置写入。然后，你知道，在某个时候，你可以将内容写回磁盘。因此，这是一个方便的界面，可以操作我们可能存储的数据结构，也可能存储在文件中。</p>
<p>发言人   13:22<br>In fact, you will be implementing this specific version of nmap or some version, the file based nmap actually in the next lab. So this basically integrates know the file system part of XV 6, you know, the virtual memory part of XV 6, and you get sort of hooked them up. And by surprising, by actually implementing MMA. And that can also be used in other ways. So you can use the map file. You can also use it to map anonymous memory. And that’s basically sort of an alternative to S break, where basically you can sort of ask, you know, the kernel trees, you know, give me a bunch of memory and map this particular address.<br>事实上，您将在下一个实验室中实现这个特定版本的nmap或某个版本，实际上是基于文件的nmap。所以这基本上集成了XV 6的文件系统部分，你知道，XV 6的虚拟内存部分，你可以将它们连接起来。令人惊讶的是，通过实际实施MMA。这也可以用于其他方面。这样你就可以使用地图文件了。你也可以用它来映射匿名内存。这基本上是一种替代sbreak的选择，基本上你可以问内核树，给我一堆内存并映射这个特定的地址。</p>
<p>发言人   14:07<br>So the artist is one of the core system calls and we related back to the priime is in a second. Okay, there’s a couple more calls that are necessary to actually support the primitives that the paper argued for, and Unix has them. So for Unix today.<br>所以艺术家是核心系统调用之一，我们在一秒钟内回到了原始状态。好的，还有几个必要的调用来实际支持论文所主张的原语，Unix有它们。今天的Unix也是如此。</p>
<p>发言人   14:30<br>There’s an mprotect system called, so once you have something mapped in you, the address space, you can actually, you know, change. The permissions. So whatever you can make and protect a particular. So you map something in the address space and you can n protect, for example, for a subset of that part over all of it, and mapping at a particular protection level. And so for example, if you did this, you know, basically loads could be executed, but stores change into would change into patrol. Similarly, if you want to make sure that range in address space is completely inaccessible. And protected with numb and, you know, basically then both ever being basically any access know to that particular page or to that dress range, starting from address plus link will result in a page fault.<br>有一个名为mprotect的系统，所以一旦你有了地址空间的映射，你就可以改变它。权限。所以无论你能做什么，都要保护特定的东西。因此，您可以在地址空间中映射某些内容，并且可以保护该部分的子集，例如在整个地址空间中进行映射，并以特定的保护级别进行映射。因此，例如，如果您这样做，基本上可以执行加载，但商店变成会变成巡逻。同样，如果您想确保地址空间中的范围完全无法访问。并且用麻木和保护，你知道，基本上无论是对该特定页面或该着装范围的访问，从地址加链接开始，都会导致页面错误。</p>
<p>发言人   15:29<br>There’s a similar, there’s a corresponding call to n map called N map. It allows you to basically remove a mapping or move in a dress range.<br>有一个类似的，有一个对应的对n个map的调用叫做N个map。它允许您基本上删除映射或在着装范围内移动。</p>
<p>发言人   15:43<br>Initial, if you cur exactly how these calls work, know you should look up the end page of these system calls. And then finally, you know, the one that we really need is a system called called sick action. And basically, this is a signal handler.<br>最初，如果你确切地了解这些调用的工作方式，你应该查找这些系统调用的结束页面。最后，你知道，我们真正需要的是一个叫做 “病态行为” 的系统。基本上，这是一个信号处理程序。</p>
<p>发言人   16:11<br>And it allows the application to say like, you know, if a particular signal happens, then you call this particular function. And so can install basically a function f as the signal handler for a particular signal. And in the case of page faults, the signal that is generated, something that’s called SEC fault. Typically, you might have seen SEC folds you in user code before. You know, typically what happens in the SEC fold is basically the application stops and crashes. But if the application had installed and a handler for, you know, a SEC fault event or SEC fault signal, then instead of the application being stopped, then the handler would be called by the kernel. And then the application can maybe respond, you know, to that particular, SEC fault in the same way, in some sense that the kernel respond to a page fault and, you know, maybe, you know, fixes up the page table so that, you know, the execution can continue. And in this case, maybe the handler will actually call and protect or and change the permissions so that actually the instruction can be resumed and continue.<br>它允许应用程序说，你知道，如果发生特定的信号，那么你可以调用这个特定的函数。因此，可以安装一个函数f作为特定信号的信号处理程序。在页面错误的情况下，生成的信号称为秒错误。通常情况下，您可能之前在用户代码中看到过SEC folds。你知道，通常在证券交易委员会中发生的事情基本上是应用程序停止和崩溃。但是如果应用程序已经安装并且有一个针对秒故障事件或秒故障信号的处理程序，那么内核将调用该处理程序，而不是停止应用程序。然后应用程序可能会以同样的方式响应特定的SEC故障，就像内核响应页面故障一样，在某些感知中，你知道，也许，你知道，修复页表，这样，你知道，执行可以继续。在这种情况下，也许处理程序将实际调用并保护或更改权限，以便实际恢复和继续指令。</p>
<p>发言人   17:21<br>And. So in this respect, you know, if you were the most familiar version that we were, the thing that we have seen like a sick action was like sick alarm, as AMI mentioned a little bit earlier, where in the circular arm lab where you could install the alarm program, basically installed a handler that will have to be called at every clock tick or every, you know, period of time. And, you know, basically sick action is sort of the equivalent of that, but the general version of it narrative where it basically can respond to different type of signals any questions about.<br>而且。因此，在这方面，你知道，如果你是我们最熟悉的版本，我们看到的像生病的行为就像生病的警报，正如AMI之前提到的，在圆形手臂实验室中，你可以安装警报程序，基本上安装了一个处理程序，必须在每个时钟滴答或每个时间段调用。而且，你知道，基本上生病的行为就是那种等价物，但它的一般版本的叙述基本上可以回应不同类型的信号，任何问题都可以回答。</p>
<p>发言人   18:03<br>It seems like mprotect implies that you can add different permission levels on individual addresses, whereas in like XV 6 that we’ve been working with, you can only apply permissions on full pages. Is that, is that a difference? That’s a no. It’s real different, you know, that works at a page level granularity and it does an expose. You know, there’s a separate call to find out what the page size is if you’re curious about it.<br>似乎mprotect暗示您可以在各个地址上添加不同的权限级别，而在我们使用的XV 6中，您只能在整页上应用权限。有区别吗？这是一个不。这是真正的不同，你知道的，它在页面级别的粒度上工作，并且会进行暴露。你知道，如果你对页面大小感到好奇，还有一个单独的电话来了解它。</p>
<p>发言人   18:33<br>Thank you, so if you think about, you know, these, the primitives that were in the paper, you know, we can sort of map them, correct? To like what currently Unix or Unix typically provides. So equivalent graphic trap that we’re in Unix that provide is something called the sick action call. And how about, you know, pro in and prod 1? What is the equivalent that?<br>谢谢，所以如果你想想，你知道，这些，论文中的原语，我们可以对它们进行映射，对吗？喜欢当前Unix或Unix通常提供的东西。我们在Unix中提供的等效图形陷阱是称为 “生病操作调用” 的东西。你知道的pro in And prod 1怎么样？那等价物是什么？</p>
<p>发言人   19:07<br>Basically all three of them, correct, basically, or it can be implemented using mprotect. And m-protein flexible enough that you could do it by a single page, just ask. Or you can actually provide something that consists of multiple pages. And then you could do you get the same benefit of like one TB flush for a changing definitions and on a whole series of pages.<br>基本上所有三个，基本上正确，或者可以使用mproect实现。而m蛋白足够灵活，只需一页就可以做到，只需询问即可。或者您可以实际提供由多个页面组成的内容。然后，您可以获得相同的好处，例如在更改定义和整个系列页面上进行一次TB刷新。</p>
<p>发言人   19:35<br>Okay, these calls sort of almost directly map into some of the primitives. Turns out, you know, dirty actually is a little bit harder to do, and there’s not a direct primitive for or system call for, although you can sort of more or less get it done with some tricks. And I’ll talk a little bit later about map 2. There’s also not sort of, there’s a way to do it, but it’s not completely, you know, sort of there’s a system called just directly maps onto Map 2. It turns out that if you with multiple N maps. You can actually achieve this particular functionality to, okay, so you know, one way to think about this paper is the, you know, kernel developers, you know, maybe not totally driven by this paper, but Colonel de Velours. Have extended to these or have provided these primitives actually to, you know, today’s user applications? Okay, I want to say a few words about the implementation, just much more at the sketch level, and then talk a little bit about, you know, the applications themselves and see how they use these particular primitives.<br>好的，这些调用几乎直接映射到一些原语中。原来，你知道，脏实际上有点难做到，而且没有直接的原语或系统调用，尽管你可以通过一些技巧或多或少地完成它。我稍后会谈到地图2。也没有，有一种方法可以做到这一点，但它并不完全，你知道，有一个称为 “直接映射到地图2” 的系统。事实证明，如果你有多个N个映射。你实际上可以实现这个特定的功能，好的，你知道，考虑这篇论文的一种方式是，你知道，内核开发人员，你知道，也许并不完全受这篇论文的驱动，但是de Velours上校。已经扩展到这些或者实际上提供了这些原语，你知道，今天的用户应用程序？好的，我想就实现说几句话，只是更多关于草图层面的内容，然后再谈谈应用程序本身，看看它们如何使用这些特定的原语。</p>
<p>发言人   21:01<br>Okay, so let’s talk about there’s two aspects that are sort of interesting. One is actually what actually happens, you know, inside the virtual memory system to actually support this. I’m just going to sketch this out like what the most important pieces are. And in fact, you know, this is sort of a little bit relevant to the Nmap lab that is coming up because you’re going to do something similar. So address space, typically in the Unix today is represented by, you know, of course, the hardware page table, which contains the translations. But typically it’s augmented with a set of sort of OS data structures not unrelated to any specific hardware design. These are called, virtual virtual memory.<br>好的，让我们来谈谈有两个方面是有点有趣的。一个是实际发生的事情，你知道，在虚拟内存系统内部实际上是为了支持这个。我只是要勾勒出最重要的部分是什么。事实上，你知道的，这与即将到来的Nmap实验室有点相关，因为你将要做类似的事情。因此，通常在Unix中，地址空间通常由硬件页表表示，其中包含翻译。但通常它会增加一组与任何特定硬件设计都无关的操作系统数据结构。这些被称为虚拟内存。</p>
<p>发言人   21:54<br>Errors? Or short vmas? And basically what a VMA, what a VMA represents is just record some information about a contiguous range of addresses.<br>错误？还是简短的vmas？基本上，VMA所代表的只是记录有关连续地址范围的一些信息。</p>
<p>发言人   22:20<br>So if you think about an address space, it might have number of sections in the address space. Each form, you sort of configure range. Basically, for each section, there would be a VMA. And the VMA basically said, you know, the VMA also has all the same permissions through all the pages in that range at the same permissions. And they’re backed by the same object.<br>因此，如果考虑一个地址空间，它可能在地址空间中有多个段。每个表单，您可以配置范围。基本上，对于每个部分，都会有一个VMA。而VMA的基本意思是，你知道，VMA在该范围内的所有页面都具有相同的权限。它们由同一个物体支撑。</p>
<p>发言人   22:54<br>For example, if you have me an MMA file, then there would be VMA for that file that describes, you know, whatever the permissions for the file as well, the information about the file itself, the file descriptor, for example, that goes along with that particular VMA and the offset in the file that VMA corresponds to. And in fact, you know, in the lab, upcoming lab, you know, you will implement a very simple version of you Vmas and use that to actually implement. The MMA system call for files where basically you can record in the VMA and literally the file descriptor and the offset that corresponds to that particular N map call or the range that have been mapped. Any questions about this?<br>例如，如果你有一个MMA文件，那么该文件就会有一个VMA，它描述了文件的任何权限，以及有关文件本身的信息，例如文件描述符，这与特定的VMA以及VMA对应的文件中的偏移量一起使用。事实上，你知道，在实验室里，即将到来的实验室里，你将实现一个非常简单的Vmas版本，并使用它来实际实现。MMA系统调用文件，基本上您可以在VMA中记录文件描述符以及与该特定N映射调用或已映射范围相对应的偏移量。对此有什么问题吗？</p>
<p>发言人   23:57<br>Okay, so then the second piece, you know, the sort of important, and we have a little bit of experience with it, it’s probably worthwhile going through, is actually how trap or sick action? The handler How an actual trap will work? A little bit more careful. So how usual level traps are implemented? And this follows follows very much the same outline as actually the sick alarm system call, the up call that happened when a clock tick actually. Past the time limit. And so the sort of setting here is not, you know, clock takes, but, you know, page tables.<br>好的，那么第二件事，你知道的，那种重要的，我们对此有一点经验，可能值得一试，实际上是陷阱或病态行为？一个实际的陷阱将如何工作？再小心一点。那么如何实施常规级别陷阱呢？这遵循与实际生病警报系统呼叫非常相同的大纲，即时钟滴答作响时发生的向上呼叫。超过时间限制。所以这里的设置不是，你知道，时钟需要，而是，你知道，页表。</p>
<p>发言人   24:48<br>So let’s assume there are some Pte Pte that has that’s marked, you know, you know, invalid or maybe it’s not read only only and you actually store to it. And so what happens, you know, when the application, you know, accesses that Pte that actually is basically invalid or doesn’t result in a valid translation? Well, as we know, then the CPU jumps into kernel mode.<br>因此，让我们假设有一些Pte被标记为无效或者可能不是只读的，并且您实际上存储到其中。那么，当应用程序访问实际上是无效的或没有导致有效翻译的个人信息时，会发生什么呢？嗯，正如我们所知，然后CPU会跳入内核模式。</p>
<p>发言人   25:20<br>Injunction through the girdle had a fixed address, you know, looked at the think, the trampoline code, the kernel, you know, save state. So for example, saves the trap frame. And then basically asks, you know, the VM system. And what now? What to do? And the VM system actually might do something. So for example, in case of like this happened in the laser lab and in the copy and write lab where, you know, you’re, you know, the trap handler code, you know, sort of looks at the P data structures and in this case pred, it will look at the eass and, you know, see, you know, what the group is is for the address that were we that was, where the processor folded on and see what it needs to be done. And so for example, if it is a SEC fault and the application had installed, you know, a handler to deal with it, then basically that up call or the handler, the event would be propagated to use space.<br>禁令通过腰带有一个固定的地址，你知道，看看思考，蹦床代码，内核，你知道，保存状态。例如，保存陷阱帧。然后基本上会问，你知道的，VM系统。而现在呢？该怎么做？而且VM系统实际上可能会做一些事情。例如，如果在激光实验室和复制和写入实验室中发生这种情况，你知道，你知道，陷阱处理程序代码，你知道，有点看P数据结构，在这种情况下，pred，它会查看eass，你知道，看看这个组是什么，因为它的地址就是我们，处理器折叠起来，看看需要做什么。因此，例如，如果它是一个秒错误，并且应用程序已经安装了处理程序来处理它，那么基本上，这个向上调用或处理程序，事件将被传播以使用空间。</p>
<p>发言人   26:25<br>And so basically, let’s say there was a handler installed. Then basically we can get an up call to into user space. In the same way as in the sickle arm lab. And that will run, you know, the handler in user space. The handler, you know, might call, you know, and protect, you know, to change the protections. And then theler returns us handler returns to kernel code.<br>所以基本上，假设安装了一个处理程序。然后基本上我们可以向用户空间发出向上呼叫。以与镰刀臂实验室相同的方式。这将运行用户空间中的处理程序。处理者，你知道，可能会打电话，你知道，保护，你知道，改变保护。然后thler返回我们处理程序返回到内核代码。</p>
<p>发言人   27:00<br>Mr colonel. And then the kernel basically resumes, you know, the interrupted process. Okay, and you know the if the when the kernel resumes that interrupted process, you know, if example, the handler fixed up sort of the address phase of the user program, then, you know, might actually the instruction might just executed correctly. Or if you know something is wrong, you know, maybe trap back into the kernel right away again if you know the. Hardware still can translate that particular virtual address. Does this make sense? Maybe this, Remember again, the sickle r block. And then this should be quite familiar.<br>上校先生。然后内核基本上恢复了被中断的进程。好的，你知道如果内核恢复中断的进程，例如，如果处理程序修复了用户程序的地址阶段，那么，你知道，实际上指令可能会正确执行。或者如果你知道有什么问题，你知道，也许马上又回到内核中。硬件仍然可以转换该特定的虚拟地址。这有感知吗？也许这个，再次记住，镰刀r块。然后这应该很熟悉。</p>
<p>发言人   27:53<br>Yeah, I have a question. What kind of, I think when we’re allowing the user to effectively run handler code on a page fault, aren’t there additional like security vulnerabilities that could result as a part of this? So I was wondering if you could speak to that. Yeah, it’s a great question. By the way, can like maybe everybody turn on their cameras to see you? If possible, if you’re comfortable doing that? We appreciate it. I think many students in the class will appreciate it too. Yeah, so is there a security issue? The first, what do people think? You know, does this break use kernel or, you know, the isolation between different processes?<br>是的，我有一个问题。我认为当我们允许用户在页面错误上有效地运行处理程序代码时，是否有其他安全漏洞可能会导致这种情况？所以我想知道你是否能谈谈这个问题。是的，这是一个很好的问题。顺便说一下，可能每个人都打开相机看到你吗？如果可能的话，如果你愿意这样做吗？我们很感激。我认为班上很多学生也会欣赏它。是啊，那么有安全问题吗？第一，人们怎么想？你知道，这个中断使用内核还是不同进程之间的隔离？</p>
<p>发言人   28:49<br>Another way you’re asking that question, did sick of arm break isolation?<br>你问的另一种方式是，生病的手臂是否会打破隔离？</p>
<p>发言人   29:00<br>Would it be okay because that code that the handler would still have access to the same virtual? I mean, if there are different virtual memories for the process and for like for each of the processes, and that handler shouldn’t be able to look into other processes, memory, Okay, yeah, when we do the up call, right, we make the upcoming that specific user space that actually install the handler. So the handler basically runs in the same context as runs with the same page table as the application that installed the handler. And so the only thing it really can do is you affect that application, but you know, that’s the application problem can’t really affect anybody any other application, because it not, it doesn’t have any access to it. The other applications page tables or can force switch into them. So turns out to be fine. Of course, if the handmer doesn’t return or does something bad in the end, the kernel just can always kill the process. So nothing really, you know, you know, the only thing that can go bad is, you know, the process can hurt itself, but it can’t hurt any other processes does.<br>可以吗？因为处理程序仍然可以访问同一虚拟的代码？我的意思是，如果每个进程都有不同的虚拟内存，并且该处理程序不应该能够查看其他进程，内存，好的，是的，当我们进行向上调用时，对吧，我们创建即将到来的、实际安装处理程序的特定用户空间。因此，处理程序基本上与安装处理程序的应用程序在相同的上下文中运行，并使用相同的页表。所以它唯一能做的就是你影响那个应用程序，但你知道，这个应用程序问题不能真正影响任何人，任何其他应用程序，因为它没有访问它的权限。其他应用程序可以分页或强制切换到它们。结果很好。当然，如果处理器最终没有返回或做了一些不好的事情，内核就可以杀死进程。所以没有什么真正的事情，你知道，唯一可能出错的是，你知道，这个过程会伤害自己，但它不会伤害任何其他过程。</p>
<p>发言人   30:13<br>That make sense. Yes, thank you. Okay, so now I want to go through a couple examples. And so to see how you could use it. And I’ll start out with a very simple example to get ours into it. And then I’ll move to the garbage collector because lots of people ask questions about the garage collector. So that seems like a good one to dive into.<br>这使感知。好的，谢谢。好的，现在我想通过几个例子。所以看看你如何使用它。我将从一个非常简单的例子开始，以便深入了解我们的想法。然后我会转向垃圾回收器，因为很多人都会问关于车库回收器的问题。所以这似乎是一个可以深入研究的好方法。</p>
<p>发言人   30:40<br>Okay, the first example I want to talk about a trivial idea, but you know, in fact, it’s not even mentioned in the paper, but it is sort of a cool way of illustrating know the power that applications get if they actually have these primitives available to them. And the basic idea is to actually build a huge.<br>好的，第一个例子我想谈谈一个微不足道的想法，但你知道，事实上，它甚至没有在论文中提到，但这是一种很酷的方式来说明如果应用程序实际上具有这些原语可用，它们将获得的能力。基本的想法是实际建造一个巨大的。</p>
<p>发言人   31:04<br>Minimization. Table. And the minimization table is basically what it does. It just remembers, you know, the result of some computation. And so, for example, you can think about it in the following way. Let’s say we have, here’s our table and now table start, whatever, 0 to some n and what the table storage is the result of running some expensive function. For that argument 0 or for whatever fn. So if you wanted to, if this table was sort of pre computed once in the beginning of time and then you wanted to look up like you wanted to know what like the value for Fi was, well, what you just do is you just look up in the table, you know, in the slot I, and basically you get the value that if I would have computed.<br>最小化。桌子。最小化表基本上就是它的作用。它只是记得，你知道，一些计算的结果。因此，例如，您可以用以下方式考虑它。假设我们有，这是我们的表，现在表开始，无论是0到一些n，表存储是运行一些昂贵函数的结果。对于该参数0或任何fn。所以，如果你想的话，如果这个表是在时间的一开始就预先计算过一次，然后你想要查找，就像你想知道Fi的值是什么一样，那么，你所要做的就是在表中查找，你知道，在插槽I中，基本上你会得到如果我将计算的值。</p>
<p>发言人   32:01<br>And so basically your turn maybe an expensive computation, you know, maybe F is very expensive into basically a table lookup sort of a cool trick you to basically. Stored results for pre-computer and stored results in the expensive computation. And if that same computation is executed many, many times, then a pre computing at once might be an advantage.<br>基本上，你的回合可能是一个昂贵的计算，你知道，也许F非常昂贵，基本上是一个表格查找，这是一个很酷的技巧。为预计算机存储结果，并在昂贵的计算中存储结果。如果同样的计算被执行了很多次，那么一次预计算可能是一个优势。</p>
<p>发言人   32:27<br>Smart thing to do. Does that setup make sense? Okay, so then the issue you of course, see is that the table or the challenge?<br>聪明的事情要做。这样的设置有感知吗？好的，那么你当然看到的问题是桌子还是挑战？</p>
<p>发言人   32:43<br>Now, the table might be big. It might be actually, in fact, very big. It might be bigger. And then measuring your physical memory. But it’s still nice to have it. So the solution, you know one solution, you know that you could. Use to solve this problem is to basically use the virtual memory primitives as described in the paper Premium. And what you do is, first of all, you allocate a huge range.<br>现在桌子可能很大。事实上，它可能非常大。可能会更大。然后测量你的身体记忆。但拥有它仍然很好。所以解决方案，你知道一个解决方案，你知道你可以。用于解决此问题的方法基本上是使用纸质Premium中所述的虚拟内存原语。你要做的是，首先，你分配一个巨大的范围。</p>
<p>发言人   33:26<br>But don’t really map. You don’t actually allocate any physical memory corresponding to that range.<br>但不要真的去地图。实际上，您并没有分配与该范围相对应的任何物理内存。</p>
<p>发言人   33:30<br>Just just take a huge part of your address space and say like I’m going to use that part of my address space to that to store the table. And then on so the page, there’s no content in the table, the address range that exists. And so if you do like a table lookup, like the table I, that will result into page fault. And so the basic plan then is on the page folder, you compute all the entries, where all the page basically covers a bunch of entries in the table. If each one of them, you’re basically you compute the function fi to store it in the slot table I, and then basically resume the application right now of.<br>只需拿出你的地址空间的很大一部分，并说我将使用我的那部分地址空间来存储这个表。然后在这样的页面上，表格中没有内容，存在的地址范围。因此，如果你喜欢表查找，比如表I，那将导致页面错误。因此，基本计划就在页面文件夹中，您计算所有条目，其中所有页面基本上覆盖了表中的一堆条目。如果它们中的每一个，你基本上是计算函数fi以将其存储在插槽表I中，然后基本上立即恢复应用程序。</p>
<p>发言人   34:20<br>Course and map the physical page. Basically, you take the page fault you allocate a page. And basically restore in that page the results of Fi for all the slots in the page. And the advantage of it is correct. If you know a couple of advantages of if you have to ever compute fi, I, again, you’re going to actually do the table lookup. And you don’t actually have to do any expensive computation just with table loop up. And in fact, even if you do a table I plus one, like presumably going to be a bunch of entries in that particular page, they’re all basically going to now be free just table lookups.<br>课程并映射物理页面。基本上，你采取页面错误，你分配了一个页面。并基本上在该页面中恢复页面中所有插槽的Fi结果。它的优点是正确的。如果你知道如果你必须计算fi有几个优点，那么你将再次进行表格查找。而且你实际上不需要进行任何昂贵的计算，只需要使用表格循环即可。事实上，即使你做了一个表I加一，就像可能会在那个特定的页面上有一堆条目一样，它们现在基本上都是免费的，只是表格查找。</p>
<p>发言人   34:59<br>Of course, you keep doing this, then you’re going to consume all physical memory. And so the patwa handler also has to throw out some pages if you’re going to run out of memory, if you know much memory in use. You use free sh of them, free shumbhan. And of course, then you have to change the protection level or to make sure that you’re going to get in the future a page fault you for those entries. So you have to presumably call, you know, prot one or prod in to reduce the accessibility of the page. And the terminology of the paper. Does this make sense as sort of a plan?<br>当然，如果你继续这样做，那么你将消耗所有物理内存。因此，如果您要用完内存，如果您知道使用的内存很多，patwa处理程序也必须丢弃一些页面。你使用免费的shumbhan，免费的shumbhan。当然，您必须更改保护级别，或者确保将来会为这些条目发生页面错误。因此，您可能必须调用prot one或prod in来减少页面的可访问性。以及论文的术语。这是否让感知成为一种计划？</p>
<p>发言人   35:49<br>All right, yeah, we would need to map. It, would need to request from the operating system to map it to a particular address, right? Because it can anywhere, okay? Yeah, could be anywhere as long as, you know the operating tables where it actually is. Maybe to make a little bit more concrete, actually have a little implementation of this plan. And we can just look at it and see whether how you actually do that using existing the unit primitives. Let me.<br>好的，是的，我们需要绘制地图。它需要从操作系统请求将其映射到特定的地址，对吧？因为它可以在任何地方，好吗？是的，可以在任何地方，只要你知道手术台在哪里。也许更具体一些，实际上对这个计划有一点实施。我们可以看看它，看看你是否真的使用现有的单元原语来做到这一点。让我来。</p>
<p>发言人   36:32<br>Okay? Can everybody see the Emx buffer? Is the font large enough? Assume that is a yes. So here’s the application. Let you go to the bottom. So here is main. Main basically sets up the square root region, basically allocates address space, but then we really allocates the physical pages belonging to it, and then it calls dysfunction test square root region that basically goes through that table in sort of a random order. And you basically checks whether the square root entry in the table for that position is indeed the correct, you know, square root value by just computing it literally before that.<br>好吗？每个人都可以看到Emx缓冲区吗？字体足够大吗？假设这是肯定的。所以这是应用程序。让你去底部。所以这里是主要的。Main基本上设置了平方根区域，基本上分配地址空间，但我们实际上分配了属于它的物理页面，然后它调用功能障碍测试平方根区域，基本上以随机顺序通过该表。基本上，你通过在此之前直接计算平方根值来检查表格中该位置的平方根条目是否确实是正确的。</p>
<p>发言人   37:24<br>Okay, so basically test square Re is going to run and it’s going to presumably generate page faults because none of the tables actually filled in so far. So how does it, you know, how do we get those page faults?<br>好的，基本上测试square Re将运行，它可能会产生页面错误，因为到目前为止还没有真正填写任何表格。那么，你知道，我们如何得到这些页面错误呢？</p>
<p>发言人   37:36<br>Well, here, the sort of the fragment of code that you need to basically install a handler, a signal handler for a particular event, we were basically saying here install for sick, the sick executive V event, the handler take a SEC V, and so when a SEC fold happens or a page fault happens, basically the function, the kernel will call handle 6 SEC v, and basically you can extract, you know, the faulting address. You know, this looks very similar to your sort of trap code that you’ve seen many, many times before. And basically the plan is very straightforward, we map a page at that particular address. So because we, that’s the address that we want to fill in, we have so my expansion function here or the replacement for the expensive function or the role of the expensive function is the square root function. And so we want to basically fill in, you know, the square root of whatever value has to be there at that particular location in the table. So we allocate a page and map it there. And then, you know, we calculate for that page all the square root entries, and then we’re done.<br>在这里，你需要基本上安装一个处理程序的代码片段，一个特定事件的信号处理程序，我们在这里基本上是说安装生病的执行V事件，处理程序需要一个秒，因此，当发生秒折叠或页面错误时，基本上该函数，内核将调用处理6秒v，基本上您可以提取错误地址。你知道，这看起来与你以前看到过很多次的陷阱代码非常相似。基本上这个计划非常简单，我们在该特定地址映射一个页面。因为我们，那是我们想要填写的地址，所以我在这里有扩展函数，或者昂贵函数的替代品或昂贵函数的作用是平方根函数。所以我们想基本上填写，你知道，任何值的平方根必须在表格中的特定位置。所以我们分配一个页面并将其映射到那里。然后，你知道，我们计算了该页面所有的平方根条目，然后我们就完成了。</p>
<p>发言人   38:49<br>And this application is a little bit extreme. What I did is basically I run this table with only one physical page allocated. So whatever the last page was, we just release it by unmapped in it. And so we have a gigantic table that’s basically representing it by one physical page. And we can just run you.<br>这个应用有点极端。我所做的基本上是在只分配一个物理页的情况下运行这个表。所以无论最后一页是什么，我们只是通过未映射的方式释放它。因此，我们有一个巨大的表，基本上用一个物理页面来表示它。我们可以直接管理你。</p>
<p>发言人   39:11<br>We wanted, we could run this application. It’s not going to be that particularly exciting, but you know, why not? So compiled it, you know, and basically go through and just randomly bounces around in that table, presumably you costing a lot of different page faults in all the entries you know, actually work out. And so even though there’s this gigantic square with page table, table, virtual square, root table, the actually physical representation of that table just consists of a single page and this sort of an example of like one of the, a very simple example of one of the sort of cool things you can do if these virtual memory payment is available to user applications.<br>我们想要，我们可以运行这个应用程序。它不会特别令人兴奋，但是你知道，为什么不呢？所以编译它，你知道的，基本上只是在那个表格中随机反弹，大概你在所有你知道的条目中花费了很多不同的页面错误，实际上是可以解决的。因此，即使有一个巨大的正方形，带有页表、虚拟正方形、根表，但该表格的实际物理表示仅包含一页，这是一个例子，一个非常简单的例子，如果这些虚拟内存支付可供用户应用程序使用，你可以做一些很酷的事情。</p>
<p>发言人   39:56<br>Any questions about this? You over at last point on why there’s only one fiscal page? Because I guess I was thinking like doing it like, oh, like this sounds similar to like lazy allocation. Why is it different? And I think that like answered my question, but I didn’t quite follow.<br>对此有什么问题吗？你最后谈了一下为什么只有一个财政页面？因为我想我在想，就像这样，哦，这听起来类似于懒惰分配。为什么不同？我认为这回答了我的问题，但我没有完全理解。</p>
<p>发言人   40:13<br>Okay, okay, the reason, Okay, so we start when we set it up, we have no pages. So this set of square root of region actually allocates address space, but then unmatched all the physical memory associated with that address immediately. So the point of startup, there’s no physical pages allocated to this particular table, does that make sense? Yeah, okay, then we get it.<br>好的，好的，原因是什么，好的，所以我们在设置时就开始了，我们没有页面。因此，这一组区域的平方根实际上分配了地址空间，但随后与该地址相关的所有物理内存立即无法匹配。所以启动的时候，没有物理页面分配给这个特定的表，这是否感知呢？是的，好的，那我们就明白了。</p>
<p>发言人   40:40<br>When we get a page fault, that means there’s like one page, the whole table that we have not mapped and we have map, no pages, but we’re going to page fault, and now we’re going to map 1 page. And in that one page, we’re going to fill in whatever the square root of I plus 1 I plus whatever, just you for that particular page. And then if we had a page mapped, which in this case, the first time around we didn’t, there’s nothing to be done.<br>当我们得到一个页面错误时，这意味着像one page一样，我们还没有映射整个表，我们有map，没有页面，但我们将进行页面错误，现在我们将映射1个页面。在那个one page中，我们将填写任何I加1 I加任何东西的平方根，只为你那个特定页面。然后，如果我们有一个页面映射，在这种情况下，我们第一次没有，没有什么可做的。</p>
<p>发言人   41:06<br>So now the application runs, you know, and looks up some more interest in the page in the square root table. And then you get another page table, another page fault, because it’s looking up a square root entry that actually is not not on the allocated page. Okay? So at that point, we get another page fault, and then we allocate a second page. We calculate the square roots for that particular page, and then we unmap the last page. And of course, like in practice, we would never do this.<br>所以现在应用程序运行，你知道的，并在平方根表中查找更多的兴趣页面。然后你会得到另一个页表，另一个页面错误，因为它正在查找一个实际上不在分配页面上的平方根条目。好吗？所以在那一点上，我们得到另一个页面错误，然后我们分配第二个页面。我们计算该特定页面的平方根，然后取消映射最后一页。当然，就像在实践中一样，我们永远不会这样做。</p>
<p>发言人   41:35<br>In practice, we would try to keep like a working set, set of pages or something like that. But just to show that you can go pretty extreme, that you can represent like this huge page, this huge table with a single page of memory, this particular fragment of code, unmas that last the one, but last page, and then it keeps running. And so at any point, in instance, any point in time, there’s only one physical page being used. Does that answer your question? Yeah, I think so, thank you. Just like it’s more like there’s clearly not something you would do in practice. Maybe there’s more sort of like to show, you know, the power of the primitives, you know, that you can represent this gigantic table using one single physical page. Any other questions?<br>在实践中，我们会尝试保持像一个工作集、一组页面或类似的东西。但只是为了表明你可以走得相当极端，你可以表示像这个巨大的页面，这个带有单页内存的巨大表格，这个特定的代码片段，最后一页的unmas，然后它继续运行。因此，在任何时候，例如任何时间点，都只有一个物理页面被使用。这回答了你的问题吗？是的，我想是的，谢谢。就像它更像是在实践中显然没有你会做的事情。也许还有更多的方式来展示，你知道，原语的力量，你知道，你可以用一个物理页面来表示这个巨大的表格。还有什么问题吗？</p>
<p>发言人   42:30<br>Okay, what I would like to do next then is talk about another example. And in particular, I want to talk about the garbage collector You, since a lot of questions were about the garbage collector.<br>好的，接下来我想谈另一个例子。特别地，我想谈谈垃圾收集器，因为很多问题都是关于垃圾收集器的。</p>
<p>发言人   42:59<br>And so, so the idea garbage collectors are a way of basically for programming languages or languages that basically do memory allocation and freeing on behalf of the programmer. So the programmer doesn’t have to call like, and you see, correct? You have to call Malik, and then you have to call free explicitly to free to memory languages that use garbage collectors. Basically, the application only has only can basically call meoc, but never has to worry about actually freeing the memory. Basically, if the garbage collector will do the work to determine if the memory still is in use and if the memory is not in use, then it actually will free it.<br>因此，垃圾回收器的想法基本上是编程语言或基本上代表程序员进行内存分配和释放的语言的一种方式。所以程序员不必像这样打电话，你看，对吗？你必须调用Malik，然后你必须显式调用free以释放使用垃圾收集器的内存语言。基本上，应用程序只能基本上调用meoc，但永远不必担心实际释放内存。基本上，如果垃圾回收器将完成工作以确定内存是否仍在使用中，如果内存未被使用，则它实际上将释放它。</p>
<p>发言人   43:36<br>And so it is nice, you know, you know, what are some example programming languages that have garbage collectors? Java, yeah, java, python, you know, go many of them actually correct almost, you know, other than ABC and Rust, every other programming language basically has a garbage collector. And so just as you can imagine, there’s a huge literature design space for garbage collectors. And the point of this paper is not like sort of say, well, here’s the best garbage collector possible, but here basically illustrate the garbage collectors could take advantage of these usual levels of memory primitives. And so the particular garbage collector the paper discusses is a copy and garbage collector.<br>所以这很好，你知道，你知道，有哪些具有垃圾回收器的编程语言示例？Java，对，java，python，你知道，它们中的许多实际上几乎是正确的，你知道，除了ABC和Rust，其他编程语言基本上都有一个垃圾回收器。正如你所想象的那样，垃圾收集器有巨大的文学设计空间。本文的重点并不是说，这里有最好的垃圾回收器，但这里基本上说明了垃圾回收器可以利用这些通常级别的内存原语。因此，本文讨论的特定垃圾回收器是复制和垃圾回收器。</p>
<p>发言人   44:31<br>And the basic plan is sort of, you know, the top level outline is as follows. You know, you basically have a memory, a heap from which memory is allocated. You divide memory and a heap in two pieces. One is the front piece, or what the paper calls the front space, and the other is the two space.<br>基本计划有点，你知道，顶层大纲如下。你知道，你基本上有一个内存，一个从中分配内存的堆。你将内存和堆分成两部分。一个是前片，或者说是纸张所称的前空间，另一个是两个空间。</p>
<p>发言人   44:53<br>And let’s say we’re having started, you know, with the applications are starch. And so all memory is free. And basically we start allocating memory in the from space.<br>假设我们已经开始了，你知道，应用是淀粉。因此，所有内存都是免费的。基本上我们开始在空间中分配内存。</p>
<p>发言人   45:02<br>So let’s say we’re allocated maybe like data structure, you know that either the root of the tree and that maybe has a pointer, you know, to another object and that maybe has a pointer to another object. And that is also pointed to by the root, you know, sort of a this little cycle of objects. And maybe the application used a lot of other memory too, but there’s no nothing pointing to it anymore. And so basically, the only the life objects are the ones that actually are basically accessible from the root. So at some point, like maybe I’ve allocated lots of memory here before, and we allocate one more object. And it turns out there’s no space anymore where the application ask for one more object. Turns out there’s no space anymore for it because the whole from spaces basically has tot been used. And so then the basic idea is in this copy and guard collector is to take objects and copying them over to the two space.<br>所以假设我们分配的可能像数据结构一样，你知道树的根可能有一个指向另一个对象的指针，也可能有一个指向另一个对象的指针。这也被根指向，你知道，有点像这个物体的小循环。也许这个应用程序也使用了很多其他内存，但现在已经没有任何东西指向它了。基本上，唯一的生命对象是那些实际上可以从根访问的生命对象。所以在某些时候，比如我之前在这里分配了大量内存，我们再分配一个对象。结果发现应用程序不再要求多一个对象了。事实证明，它已经没有空间了，因为整个空间基本上已经被使用了。因此，这个复制和保护收集器的基本思想是将对象复制到两个空间中。</p>
<p>发言人   46:05<br>And the way you do it is you start from the root because that so every application where every house a set of registers where basically the top level pointers are stored, or maybe the local variables on the stack.<br>而你的做法是从根开始，因为每个应用程序都有一组寄存器，其中基本上存储了顶级指针，或者可能是堆栈上的局部变量。</p>
<p>发言人   46:20<br>And basically there’s a set of roots there For simplicity I’m just going to assume there’s one root. And you start tracing basically from the top level. And so, you know, you copy the root of object over to the true space. And you know, and that’s the only thing you do at that point. And then, you know, of course, that leaves, you know, the pointers, you know, still pointing to whatever objects there were there before.<br>基本上有一组根，为了简单起见，我假设只有一个根。你基本上从顶层开始追踪。所以，你知道，你将对象的根复制到真实的空间中。你知道，那是你在那个时候唯一要做的事情。然后，你知道，当然，留下了指针，你知道，仍然指向以前存在的任何物体。</p>
<p>发言人   46:46<br>And then, you know, once you copy the object over, you go along and inspect. You scan the object. And you know, of course, the language runtime knows exactly, you know, what type the object is and knows where the pointers are, and just looks at these pointers and says like, okay, maybe, you know, I should copy some more pointers over because those are actually part of a live data structure. And so basically, you know, maybe we can take the top level pointer, look at that object, you know, copy that object over, you know, to.<br>然后，你知道的，一旦你复制了这个对象，你就可以继续检查。你扫描物体。你知道，当然，语言运行时确切地知道对象是什么类型，知道指针在哪里，只是看着这些指针说，好吧，也许，你知道，我应该复制更多的指针，因为它们实际上是实时数据结构的一部分。基本上，你知道，也许我们可以拿顶级指针，看那个物体，你知道，复制那个物体，你知道。</p>
<p>发言人   47:16<br>The two space update the pointer here to actually indicate that actually it has been pointing it to the now copied version of the object. And then of course, you later on, we need to remember that actually this object has been copied. And so we stored a little bit of extra information. And remember that there’s object accession now stored there. And this process, you know, of sort of moving an object from the from space to the two space and leaving a forwarding pointer in the from space is called forwarding.<br>这两个空间更新了这里的指针，以实际指示它实际上一直指向现在复制的对象版本。当然，稍后我们需要记住这个对象实际上已经被复制了。所以我们存储了一点额外的信息。请记住，现在有存储在那里的对象加入。这个过程，你知道的，将一个物体从空间移动到两个空间，并在其中留下一个转发指针的过程叫做转发。</p>
<p>发言人   47:59<br>Okay, so we now, so we did this, you know, we did fix this pointer. We fixed that pointer. There’s one more left, so we’ll look up that object and we copy it over like before, and it still has a particular pointing to this object. So now we look at that particular pointer, look at that point to see, you know, that actually has already been copied. And in fact, we know what the new location is. And so we can just straight update it to point to the right place, okay? And so at this point, you know, all the pointers have been, you know, correctly updated, you know, the whole structure, you know, the whole cycle, basically of objects as we moved from the from space to the two space. And so at this point, we’re done.<br>好的，所以我们现在，我们做了这个，你知道，我们确实修复了这个指针。我们修好了指针。还有一个左边，所以我们将查找该对象并像以前一样复制它，它仍然有一个特定的指向该对象。所以现在我们看看那个特定的指针，看看那个点，你知道，它实际上已经被复制了。事实上，我们知道新的位置是什么。所以我们可以直接更新它以指向正确的位置，好吗？因此，在这一点上，你知道，所有的指针都已经正确更新了，你知道，整个结构，你知道，整个周期，基本上是物体从空间移动到两个空间。所以在这一点上，我们完成了。</p>
<p>发言人   48:54<br>At this point, we’re done. We forwarded all the objects and basically the from space. Now you all the objects in the front space are being discarded. And it’s now free space.<br>在这一点上，我们已经完成了。我们转发了所有的物体，基本上是从太空转发的。现在，前面空间中的所有对象都被丢弃了。现在是免费空间。</p>
<p>发言人   49:17<br>And does that make sense? And that’s the basic plan in a copy and garbage collector. Okay, now the scheme that definitely is used in the paper has a couple sophistications, so I want to talk about them. The first sophistication is that they actually, we called this is called Biggers algoth, and it’s an old algorithm. And one of the nice features it has is that sometimes it’s originally called real time. And real, what it meant is sort of it’s an incremental garbage collector. So, and the main idea is that.<br>这就感知了吗？这就是复制和垃圾收集器的基本计划。好的，现在论文中肯定使用的方案有一些复杂之处，所以我想谈谈它们。第一个复杂之处在于，我们实际上称之为大数算法，它是一种古老的算法。它的一个不错的特点是，有时它最初被称为实时。实际上，它的意思是一种增量垃圾收集器。所以，主要思想是这样的。</p>
<p>发言人   50:11<br>Here we have our two from space and through space. The main idea is that, you know, we have our route again, here’s our root. It had two pointers. And it’s pointing it back.<br>在这里，我们有来自太空和穿越太空的两个。主要思想是，你知道，我们再次有我们的路线，这是我们的根。它有两个指针。它正在指向它。</p>
<p>发言人   50:34<br>The main idea is that it’s not really necessary to stop the world and copy everything over and then basically resume comput. The only thing really necessary is to actually move copy over the root. And basically, we do nothing else. And so basically, you know, at this point, you know, the root has been copied, but, you know, it’s no pointers are still pointing, you know, the year because that object has not been scanned. And it has nott been its point haven’t been updated yet. And the basic idea is then whenever the application calls new. On every new call, you scan a few more objects, or you forward a couple more objects.<br>主要思想是没有必要停止世界并复制一切，然后基本上恢复计算机。唯一真正需要做的是将副本移动到根目录上。基本上，我们不做任何其他事情。基本上，你知道，在这一点上，你知道，根已经被复制了，但是，你知道，没有指针仍然指向年份，因为那个对象还没有被扫描。这不是它的重点，还没有更新。基本思想是每当应用程序调用new时。在每个新呼叫中，您可以扫描更多的对象，或者转发更多的对象。</p>
<p>发言人   51:34<br>And that’s sort of nice, Greg, because basically you spread out the cost of actually, you know, copying the complete, you know, active or life heap from the application in incremental steps. Know every meal, every call allocates, you know, contributes a little bit, you know, to actually the complete copy operation.<br>这有点不错，格雷格，因为基本上你可以分摊实际的成本，你知道，以增量的方式从应用程序中复制完整的活动或生命堆。知道每顿饭，每次呼叫都会分配，你知道，对实际上完整的复制操作有一点点贡献。</p>
<p>发言人   51:53<br>Now, of course, the application might also be using of some of these pointers. For example, if you know the root, we’ll be dereferencing like, say, this second red pointer, It’s still actually pointing into the from space. And of course, that is dangerous because we shouldn’t be tracking pointers in the from space.<br>当然，现在应用程序也可能使用了其中一些指针。例如，如果您知道根，我们将取消引用，例如，第二个红色指针仍然指向来自空间的指针。当然，这很危险，因为我们不应该跟踪来自太空的指针。</p>
<p>发言人   52:10<br>And so basically this means that like every time you do your reference. You reference a pointer. You need to check. Check if it’s in the front space. If in front space, and if so, you know, do the forwarding. And so the application is allowed to use like the pointers, but basically to run, you know, the compiler has to instrument the application that basically every pointer access is sort of surrounded by that check so that we basically maintain the invariant that all any point in the two space points to optics in the two space.<br>所以基本上，这意味着每次你做参考时。你引用了一个指针。你需要检查。检查它是否在前面空间。如果在前面空间，如果是这样，你知道，进行转发。因此，应用程序可以像指针一样使用，但基本上可以运行，你知道的，编译器必须检测应用程序，基本上每个指针访问都被检查包围，以便我们基本上保持两个空间中的所有点都指向两个空间中的光学元件的不变性。</p>
<p>发言人   52:56<br>And we need to do. And that’s correct because when we in the end, we’re done, you know, we want to remove the from space and have so that we can discard it and reuse it as free space. Okay, any questions about this? This is sort of the basic setup.<br>这是我们需要做的。这是正确的，因为当我们最终完成时，你知道，我们想要从太空中移除它并将其丢弃并重新用作自由空间。好的，对此有什么问题吗？这是基本设置的一种。</p>
<p>发言人   53:20<br>Okay, if there are no questions, the paper makes two points about this scheme. One is, you know, it’s annoying or too bad that you actually have to do this dereference every time. So basically this means load or store instruction instead of being single instruction. It actually, there’s a bunch of instructions, namely a branch instruction. And perhaps you in calling a function to actually do the forwarding. And so, you know, that increases the cost of the application. And the second thing that it actually sort of points out is that it is not that easy to paralyze this, the garbage collector, like maybe in a nice setting, it’s like you’re running in a multicore machine where you have a lot of free Cpu’s, basically.<br>好的，如果没有问题，这篇论文对这个方案提出两点。一个是，你知道，每次都必须这样做解引用，这很烦人或者太糟糕了。所以基本上，这意味着加载或存储指令而不是单个指令。实际上，有一堆指令，即分支指令。也许你需要调用一个函数来实际进行转发。所以，你知道，这增加了应用程序的成本。它实际上指出的第二件事是，瘫痪垃圾回收器并不容易，就像在一个很好的环境中一样，就像你在一个有很多空闲Cpu的多核机器上运行一样。</p>
<p>发言人   54:08<br>Now you have the collector, you know, just in the background, you know, traverse the object graph and copy things incrementally over as it continues. But if the application at the same time, you know, is using the graph, there’s a risk, you know, that the application may be, you know, there’s one of the reference check, one of these checks, it starts copying an object while at the same time the collect results are copying the object. And we’re not very carefully. We may end up with the object cop twice and the pointer not pointing in the right places. You can easily see correct that there is a race condition possible of a possibility of a race condition. And so the paper basically describes a scheme, says like, if you had the usual level of primitives, then actually you can do something different. You can do, you know, a cool trick, and you can actually use VM you. Know through your memory to basically reduce the cost of the check and almost gets, you know, concurrency for free.<br>现在你有了收集器，你知道，就在后台，你知道，遍历对象图并在继续的过程中增量复制事物。但是如果应用程序同时使用图形，就存在风险，你知道，应用程序可能存在一个参考检查，其中一个检查，它开始复制对象，同时collect结果也在复制该对象。我们并不是很谨慎。我们可能会导致对象cop两次，并且指针没有指向正确的位置。你可以很容易地看到有竞争条件的可能性，也可以看到有竞争条件的可能性。因此，这篇论文基本上描述了一个方案，比如，如果你有通常水平的原语，那么你实际上可以做一些不同的事情。你可以做，你知道，一个很酷的技巧，你实际上可以使用VM。通过你的记忆，基本上可以减少检查的成本，几乎可以免费获得并发。</p>
<p>发言人   55:13<br>And so, and the basic idea is as follows. You know, we have our. Same setup are from and here’s our 2.<br>因此，基本思想如下。你知道，我们有我们的。相同的设置来自，这是我们的2。</p>
<p>发言人   55:27<br>What we’re going to do is we’re going have, we’re going to have a region, you know, we’re going to actually divide the two space, sort of virtually or literally divide the two space in an area that is unscanned. So I mean, be a little bit more clearer. We have an area basically of the area of East Scant. And has an area that’s unscanned? And initially, basically, you know, the whole area is unscanned, you know? So when you start out, you know, you make the flip from the front to the two space.<br>我们要做的是，我们将拥有一个区域，你知道，我们将实际划分这两个空间，在一个未扫描的区域中虚拟或字面上划分这两个空间。所以我的意思是，再清晰一点。我们的面积基本上是东部地区的面积不足。并且有一个未扫描的区域？最初，基本上，你知道，整个区域没有被扫描，你知道吗？所以当你开始时，你知道，你从前面翻转到两个空间。</p>
<p>发言人   56:09<br>Nothing has been scanned yet because there’s no objects yet in it. And so, but basically scheme starts in the same way, and we copy over the root object. It used to be there, you know, copy it over.<br>还没有扫描任何内容，因为其中还没有对象。所以，基本上scheme以相同的方式开始，我们复制根对象。它曾经在那里，你知道的，复制它。</p>
<p>发言人   56:22<br>You had to have some pointers. You know, basically these pointers point still back into the, So yeah, these pointers want to point back into the old from space. And so that’s it. And now we’re basically saying, and what we’re going to do is for the unscanned area, which is in this everything, we’re going to just basically map them, map them with no permission, map them none. And so what it was that means? Well, that means that the first time around the application, you know, after we did the flip, the garbage collector did the flip. The first time the applications used the root pointer, it will get a paid fault because you know, the that part of the address range is actually in mapped. And so basically then the idea is in the fold handler.<br>你必须有一些指点。你知道，基本上这些指针仍然指向回，所以是的，这些指针想要从太空指向回旧的。就是这样。现在我们基本上是说，我们将要做的是对于未扫描的区域，也就是所有的东西，我们将基本上映射它们，没有许可就映射它们，也没有映射它们。那么这意味着什么呢？这意味着第一次在应用程序中，你知道，在我们进行了翻转之后，垃圾回收器进行了翻转。应用程序第一次使用根指针时，它将获得付费错误，因为您知道，地址范围的那部分实际上是在映射中的。基本上，这个想法就在折叠处理器中。</p>
<p>发言人   57:22<br>Scan, you know, one page of objects.<br>扫描，你知道的，one page物体。</p>
<p>发言人   57:32<br>And for the ones that need to be forwarded? So basically, you know, we in this particular setting where we’re only copied over just the route so far, you we have, we’re going to copy over the root.<br>对于那些需要转发的？所以基本上，你知道，我们在这个特定的设置中，到目前为止我们只复制了路由，我们已经复制了根目录。</p>
<p>发言人   57:47<br>We’re going to scan the pointer in the object to which the root is pointing. In this case, there are only two of them. We kind of copy over those two objects, you into the unscanned space. Or maybe let me draw them this way. Different here. Just make it look like we can copy the overdose to objects, you know, that we’re pointing to. And basically we update the, we move the scan line from here, do it air. So this is no skinned. And so after we scan the page, you know, we can actually increase, you know, basically protect or basically unprotected. You can protect the page, protect the scan page.<br>我们将扫描根所指向的对象中的指针。在这种情况下，只有两个。我们有点将这两个对象复制到未扫描的空间中。或者让我这样画它们。这里不同。只是让它看起来像我们可以将过量的药物复制到我们所指向的物体上。基本上，我们更新了，我们从这里移动扫描线，做空气。所以这不是剥皮。所以在我们扫描页面之后，你知道，我们实际上可以增加，你知道，基本上保护或基本上不受保护。您可以保护页面，保护扫描页面。</p>
<p>发言人   58:42<br>Okay, and you know, the and then the application, you can just, you know, access that particular object because, you know, we translate it, you know, the point that’s inside of the objects are safe to ex it to the application. The application can traverse those pointers. Of course, if those pointers are still pointing to objects haven’t been scanned, then we’ll get a page fold again, and then we scan in a little bit more. And so it basically has the benefits still incremental. We can still do a little bit of work, you know, every time. And we can also do it every time on a new. We can actually allocate you do some work, but it has the additional benefit.<br>好的，你知道，然后应用程序，你可以，你知道，访问那个特定的对象，因为，你知道，我们翻译它，你知道，对象内部的点是安全的，可以将其传递给应用程序。应用程序可以遍历这些指针。当然，如果那些指针仍然指向尚未扫描的对象，那么我们将再次折叠页面，然后再扫描一点。因此，它的好处基本上仍然是递增的。我们仍然可以做一点点工作，你知道的，每次都可以。我们也可以每次都在新的地方做。我们实际上可以分配你做一些工作，但它有额外的好处。</p>
<p>发言人   59:19<br>There’s no, no point of check anymore. The point of check is still there, but it’s done in hardware. The page, the VM hardware does it for us.<br>现在已经没有检查的地方了。检查点仍然存在，但它是在硬件中完成的。页面、虚拟机硬件为我们完成。</p>
<p>发言人   59:39<br>Does that make sense, any questions about this, about this plan? I have a question. So in the handler, you’re saying that you can one page of objects, but how do you know that the object that the root has references to will be will fall into the same? Like, how do you know that the objects that really need to be forwarded in order to not violate invariant will be in the same page?<br>那对这个计划有感知吗？有什么疑问吗？我有一个问题。所以在处理程序中，你说你可以one page对象，但你怎么知道根引用的对象将会落入相同的情况呢？你怎么知道真正需要转发以不违反不变性的对象将在同一页面中？</p>
<p>发言人   01:00:16<br>There’s some set of objects in the page starting, let’s say. Okay?<br>在页面开始处有一些对象集，比如说。好吗？</p>
<p>发言人   01:00:27<br>At the beginning, when we flip the spaces, there’s nothing into two space. What we could do is like what the run thing could do is just copy. I described to just copy one page, but basically to copy over a forward 1 page, basically copy n objects over so that they fill a complete page. So now we have in object sitting on that one page, all unscanned. Then at some point, the patro handler will happen, and then the garbage collector or the collector go through each object on that one page and looks, you know, for its pointers. And for its pointers, it copies over those, you know, objects into the. Unskinned part of the two space so that if anybody or the application ever use one of those unscanned objects will get a page fault and then can scan dose, etc., etc..<br>一开始，当我们将空间翻转时，没有任何东西被分成两个空间。我们所能做的就像跑步的东西所能做的就是复制。我描述了只是复制one page，但基本上是复制前向1页，基本上是复制n个对象，以便它们填满整个页面。现在我们有个物体坐在那个one page上，都没有扫描过。然后在某个时候，patro处理程序会发生，然后垃圾回收器或回收器会遍历该one page上的每个对象，并查看其指针。而对于指针，它将那些你知道的对象复制到中。两个空间的未外皮部分，以便如果任何人或应用程序使用其中一个未扫描的对象将获得页面错误，然后可以扫描剂量等。</p>
<p>发言人   01:01:23<br>Does that answer the question? Yeah, good, okay. Oh, sorry, I also had a question. Yeah, so after you do this, do flip the to and the from, or okay, so you start out in the from space, you filled it up, you flipped to the, you copied over to the two space, and then you called it. Once you’re done with the complete with scanning and you’re done with the front case is completely clear, you flip the names and you start using the two space to actually do the allocations until it’s full and then you flip again. Thank you? Any further questions?<br>这回答了问题吗？是的，好的，好的。哦，对不起，我还有一个问题。是的，所以在你这样做之后，做翻转和从，或者好吧，所以你从从空间开始，你填满它，你翻转到，你复制到这两个空间，然后你打电话给它。一旦你完成了完整的扫描并且完成了正面案例的完全清除，你翻转名称，然后开始使用两个空格来实际分配，直到它满了，然后你再次翻转。谢谢？还有什么问题吗？</p>
<p>发言人   01:02:13<br>So one, the things that one of the arguments the paper also makes is that one.<br>所以，这篇论文的一个论点也是这样的。</p>
<p>发言人   01:02:18<br>Other thing that the VM system or using VM simplifies is basically concurrency. The argument is that basically the collector, you know, it can just go through the unscanned pages. So we have, we can go through the unscanned pages and basically scan 1 page you at a time. And if it’s guaranteed that the application has no pointer or can not access in the same time that page because it’s unmapped. And so, you know, as long as, and so the paging hardware basically sort of introduces sort of an explicit synchronization or protection against races because only the collector can access that page and from and the application can actually not access the page. So it gets sort of a nice automatic sort of parallelism where the application can run and do its business, the collector can do its business, and they will never step on each other’s toes because if the application ever will touch an UN scan page and we get a page fault and the collector never touches scan pages, and so it will never interfere with the application. So you get sort of.<br>VM系统或使用VM简化的另一件事基本上是并发性。论点是基本上收集器，你知道，它可以浏览未扫描的页面。所以我们可以浏览未扫描的页面，基本上一次扫描1个页面。如果保证应用程序没有指针或不能同时访问该页面，因为它是未映射的。所以，你知道，只要分页硬件基本上引入了一种显式同步或针对竞争的保护，因为只有收集器可以访问该页面，而应用程序实际上无法访问该页面。所以它得到了一种不错的自动并行机制，应用程序可以运行并处理其业务，收集器可以处理其业务，而且它们永远不会互相踩脚，因为如果应用程序接触到一个未扫描的页面，我们会得到一个页面错误，收集器永远不会接触到扫描页面，所以它永远不会干扰应用程序。所以你会有点。</p>
<p>发言人   01:03:38<br>Concurrency for free. But it actually has a tricky issue.<br>并发免费。但它实际上有一个棘手的问题。</p>
<p>发言人   01:03:47<br>So although it’s almost for free, you know, there’s actually one thing you actually have to arrange, which is the area correct in the unscanned area, which actually unmapped. So we look at our a picture from you before, here’s our two, or here’s our from use our 2. And you know, we have, you know, that sort of split into unscanned and scanned area and unscanned. It has no, you know, if not protected none. So that raises the question, you know, how does actually do collector you go through? Because you can’t actually access those pages because no, they’re unmatched or they’re the they’re inaccessible. And so the trick is basically as follows. And this is where map 2 comes in.<br>所以虽然它几乎是免费的，但实际上有一件事你必须要安排，那就是在未扫描的区域中正确的区域，这实际上是未映射的。所以我们之前从你那里看了我们的照片，这是我们的两个，或者这是我们的使用我们的2。而且你知道，我们有，你知道，那种分裂成未扫描和扫描的区域和未扫描。它没有，你知道的，如果没有保护，也没有。所以这就提出了一个问题，你知道，收藏家实际上是如何经历的？因为你实际上无法访问这些页面，因为不，它们是不匹配的，或者它们是不可访问的。因此，诀窍基本上如下。这就是地图2出现的地方。</p>
<p>发言人   01:04:38<br>What we’re going to do is actually we’re going to map that same physical memory. We mapped it once, Greg, we mapped it once in this way, and we’re going to map it in a second time in the collector view, sort of the collector’s view of the to space. So here’s the collector’s view, here’s the apt view, and in the collector’s view, you know, where where I still have to and from exactly like before you try, we have two from and what we’re doing actually, you know, here’s our unscanned area. But in the collector, you, we map actually the unscanned data to read and write, and so that the collector actually can go through, look at the scan, the objects, and forward point is just necessary. And so this is really good.<br>我们要做的是实际上我们将映射相同的物理内存。格雷格，我们映射了一次它，用这种方式映射了一次，我们将在收集器视图中第二次映射它，收集器的空间视图排序。所以这是收集器的观点，这是一个恰当的观点，在收集器的观点中，你知道，在你尝试之前，我仍然需要从哪里开始，我们有两个从哪里开始，实际上我们正在做的是，你知道，这是我们未扫描的区域。但是在收集器中，我们实际上将未扫描的数据映射到读取和写入，因此收集器实际上可以查看扫描对象，并且向前点是必要的。所以这真的很好。</p>
<p>发言人   01:05:29<br>The place where this map to call is necessary, where range piece of physical memory is actually mapped twice in the address space of an application, one at two different levels of protection to basically make scenario like this work. Any questions about this?<br>需要调用这个映射的地方，物理内存的范围部分实际上在应用程序的地址空间中被映射两次，一次处于两种不同的保护级别，基本上使这样的场景工作。对此有什么问题吗？</p>
<p>发言人   01:05:58<br>I have a question, do you do you kind of give each like the collector and the app? Different versions of the page, table or no, they have the same page table, correct? But they have the memory mapped in two places, the physical memory mapped in two different places in the dress space, places in page table. And in one place, you basically the mapping is invalid. And in the other address range, you make the mapping read, right? Okay?<br>我有一个问题，你会分别给收藏家和应用程序吗？页面的不同版本，表或否，它们具有相同的页表，对吗？但是它们将内存映射到两个地方，物理内存映射到衣服空间中的两个不同地方，页表中的位置。在一个地方，基本上你的映射是无效的。而在另一个地址范围内，您使映射读取，对吗？好吗？</p>
<p>发言人   01:06:39<br>Okay, let make this a little bit more clear since there were so many questions about it, I sort of a trivial implementation of actually. This basic ID, the ID that was described in the paper to make it a little bit more concrete. And so let me walk through this and ask. Feel free to jump in.<br>好的，让我们更清楚一点，因为关于它有很多问题，实际上我只是一个微不足道的实现。这个基本的账号，是论文中描述的账号，使其更加具体一些。所以让我走过这个并问一下。随意跳进去。</p>
<p>发言人   01:07:06<br>This is basically toy implementation of what is described in the paper, and I’m sure it has bugs. I mean, I haven’t really tested this in any way seriously. But, and it’s mostly there to just illustrate, to make everything slightly more concrete. So the collector, the API, if you will, that the application uses is a new and re pointer. And re pointer is that basically does the check whether pointer in the from space And if it is in the front space, then it needs to be copied. And of course, when we’re using VM tricks, then basically this weak point is going to be very cheap. It is going basically return the existing attorneys argument.<br>这基本上是论文中所描述的玩具实现，我确信它有错误。我的意思是，我还没有真正认真地测试过这个。但是，它主要是为了说明，使一切变得更加具体。因此，应用程序使用的收集器，即API，是一个新的和重新指针。和重新指针是基本上检查指针是否在f距空间中，如果在前面的空间中，则需要复制它。当然，当我们使用VM技巧时，基本上这个弱点将非常便宜。它基本上会回归现有的律师论点。</p>
<p>发言人   01:07:45<br>Just for this simple application, I have a linked list and it has two roots pointing, one to the head and one to the last node of the linked list to a circular. The linked list. And nothing really too exciting going on.<br>仅针对这个简单的应用程序，我有一个链表，它有两个根指向，一个指向链表的头部，一个指向链表的最后一个节点，形成一个循环。链接列表。没有什么真正激动人心的事情发生。</p>
<p>发言人   01:07:58<br>Basically, what the application threat does is a thousand times makes the list and makes the list and then checks the list. And so it generates a lot of garbage like every time after to make list is done, it was going to make a new one. And so the last list is basically garbage. And so the collector actually has something to do and then make a list, you know, is basically a little bit of ugly code, mostly because every pointer needs to be wrapped in this re pointer check. So normally, of course, is generated by a compiler, but I don’t really have a compiler for a garbage collected language. And I’m just simulating what may be a copil that might have generated. And basically what, you know, the code does goes through the builds a list of at least list size, allocates a new element, and sticks prepense it at the beginning of the list, and then updates the last pointer to point basically to the beginning of the list. So that’s circular.<br>基本上，应用程序威胁所做的就是一千次列出列表，然后列出列表，然后检查列表。因此，它会生成很多垃圾，就像每次完成制作清单后，它都会制作一个新的。所以最后一个列表基本上是垃圾。因此，收集器实际上有一些事情要做，然后制作一个列表，你知道，基本上是一些丑陋的代码，主要是因为每个指针都需要被包装在这个重新指针检查中。因此，通常情况下，当然是由编译器生成的，但我实际上没有针对垃圾收集语言的编译器。我只是在模拟可能产生的copil。基本上，你知道，代码会构建一个至少具有列表大小的列表，分配一个新元素，并将其预先添加到列表的开头，然后最新进展最后一个指针基本上指向列表的开头。所以这是循环的。</p>
<p>发言人   01:09:00<br>Any questions about this little fragment of code? So the most interesting question, of course, what goes on exactly in the collector? Let’s look at the case where there’s no virtual memory, where we’re not using these tricks. And so we just have to look at 2 Apis. One is new and read pointer. So use mu. If we get the mutexes, that is for the VM based solution. And basically we get that we’re assuming that we’re actually not scanning, we’re not collecting for a while.<br>对这段代码有什么问题吗？当然，最有趣的问题是，收集器中到底发生了什么？让我们来看看没有虚拟内存、我们没有使用这些技巧的情况。所以我们只需要看看2个api。一个是新的和读取指针。所以使用亩。如果我们得到互斥锁，那就是基于VM的解决方案。基本上我们得到的是，我们假设我们实际上没有扫描，我们暂时没有收集。</p>
<p>发言人   01:09:34<br>We basically, we check if there’s enough space left in free space. If there’s enough in a free space plan left you, we just bump up the pointer a little bit to allocate that object and return it. And if there’s not enough space less left, then we basically have to flip and we have to do a garbage collection run. And so we have to look at flip. Flipped basically switches to two and from pointers around. And then basically forward the two routes that this application has, you know, from space to the two space. So let’s look at forward.<br>我们基本上是检查自由空间中是否有足够的剩余空间。如果有足够的空闲空间计划留给你，我们只需稍微增加指针来分配该对象并返回它。如果没有足够的剩余空间，那么我们基本上必须翻转并进行垃圾收集运行。所以我们必须看看翻转。翻转基本上切换到两个，并从指针周围切换。然后基本上转发这个应用程序的两条路线，你知道，从空间到两个空间。让我们向前看。</p>
<p>发言人   01:10:25<br>So for it looks if the object that is pointed to by O, it looks if O is actually in the front space. If it is in the front space and it has not been copied before, then we’re going to copy it. And then we’re done. And we move the object from space to the two space. If we already copied it, then basically we can replace the pointer, you know, with the new pointer, actually the pointer to the already moved object, and we return that. Okay, so that’s forwarding. And so then re pointer, you ever? We point to basically go through.<br>因此，对于它看起来是否由O指向的对象，它看起来是否O实际上在前面的空间中。如果它在前面空间，并且之前没有被复制过，那么我们将复制它。然后我们就完成了。我们将物体从空间移动到两个空间。如果我们已经复制了它，那么基本上我们可以用新的指针替换指针，实际上是指向已经移动的对象的指针，然后我们返回它。好的，那就是转发。然后再重新指针，你有过吗？我们指出基本上要通过。</p>
<p>发言人   01:11:17<br>Let’s see what the read pointer with the garbage collector, just with weak pointer. It’s like right here. If we’re we’re not using VM, basically what it does, it does a forward operation. In the forward operation is checking if it’s in the front space. If it’s not in the front space, then do nothing. If it is in the front space, then do this copy again. So here, residency is sort of the expensive check is really, you know, checking if the object actually sits in the front space.<br>让我们看看读取指针与垃圾回收器，只是弱指针。就像这里一样。如果我们不使用VM，基本上它所做的是一个前向操作。在前进操作中，正在检查它是否在前面空间。如果它不在前方空间，那就什么也不做。如果它在前面空间，请再次进行此复制。所以在这里，居住是一种昂贵的检查，你知道，检查物体是否真的坐在前面的空间。</p>
<p>发言人   01:11:48<br>Any questions before I jump into sort of the version that actually uses the VM? Tricks, okay, Let’s look at actually the VM tricks. So the setup is a little bit is here.<br>在我进入实际使用VM的版本之前，有任何问题吗？技巧，好吧，让我们来看看实际上的VM技巧。所以设置有点在这里。</p>
<p>发言人   01:12:08<br>Basically, you know, there’s a call called shipment open that allows you to create a shared memory object. It’s a Linux call or a Unix call, and it just almost behaves like a file, but it’s not, you know, it behaves like a file, but it is not a file. It just sits in memory. There’s no disk space associated with it or anything. It’s like an in-memory file system, if you will. And basically, you know, what we’re doing is we allocate one of the shared memory objects, we truncate the shared memory object, act 2 to be the size of the sum of the two in the from space. So we have space, and then we map it once in for the mutator, and we map it once for the collector. And so this is basically, you know, this sort of sequence of operations here, the shared me open, the truncate, and the 2 M maps basically sort of the equivalent of the map 2 calls.<br>基本上，你知道，有一个名为shopen的调用，允许你创建共享内存对象。它是一个Linux调用或Unix调用，它的行为几乎像一个文件，但它不是，你知道，它的行为像一个文件，但它不是一个文件。它只是坐在记忆中。没有与之相关的磁盘空间或任何东西。如果你愿意的话，它就像一个内存文件系统。基本上，你知道，我们正在做的是分配一个共享内存对象，截断共享内存对象，第2行是这两个对象在空间中之和的大小。这样我们就有了空间，然后我们将其映射到mutator中，然后将其映射到收集器中。所以这基本上就是，你知道，这里的这种操作序列，共享我打开，截断和2 m地图基本上相当于地图2调用。</p>
<p>发言人   01:13:04<br>And so we look at, you know, let’s go back up to our implementation. Read pointer in the VM case does nothing. You know, there’s no check whatsoever, which is return a pointer straight. And then know, Of course, if we use a pivot pointer, we’re going to get a page fault like as before in the Sig root table application here, the page fault handler.<br>所以我们看看，你知道，让我们回到我们的实施。在VM的情况下读取指针什么也不做。你知道，没有任何检查，就是直接返回一个指针。然后当然知道，如果我们使用透视指针，我们将像在这里的Sig根表应用程序中一样得到一个页面错误，页面错误处理程序。</p>
<p>发言人   01:13:30<br>So if it is a, if it’s a page on and actually let me I’m running a little bit ahead here. If the object was moved somewhere earlier and sitting in the unscanned area, we’re getting a page fault. And basically the scanned page function runs. And but the scan page function runs actually with the address ranges of the collector. And so it actually can work because otherwise what the mutator correct, the application can not touch those pages because that would result in a page fault.<br>所以，如果它是一个，如果它是一个页面，实际上让我在这里领先一点。如果对象之前被移动到某个地方并且位于未扫描的区域中，则会出现页面错误。基本上，扫描页面功能运行。但是扫描页面功能实际上是在收集器的地址范围内运行的。因此它实际上可以工作，因为否则，mutator是正确的，应用程序无法接触这些页面，因为这将导致页面错误。</p>
<p>发言人   01:14:07<br>And once, once we have scanned all the pages, then you know, the collector actually makes the page actually accessible to the user application.<br>一旦我们扫描了所有页面，你就会知道，收集器实际上使页面能够被用户应用程序访问。</p>
<p>发言人   01:14:24<br>May be helpful to look at flip again just to see what happens. Actually, that flip, what happens? We switch from the, so the front space is full. We make basically we mark the whole two space is non accessible, you know, to the application and then we move the collector moves actually the root head and the root last, you know, to the two space that the application can not access, or at least not directly. And you know, that will resolve whenever the application access is rooted ahead or route last, it will actually result in a page vault and then the collector can copy things over and then only protect the one page. Does it make sense?<br>再次看一下翻转可能会有所帮助，只是为了看看会发生什么。实际上，这种翻转会发生什么？我们从切换，所以前面的空间已经满了。我们基本上标记整个两个空间不可访问，你知道，对于应用程序来说，然后我们移动收集器实际上移动了根头和根最后，你知道，到应用程序无法访问的两个空间，或者至少不能直接访问。并且你知道，每当应用程序访问权限被根植或路由最后时，这将解决问题，它实际上会导致一个页面保管库，然后收集器可以复制内容，然后只保护one page。它有感知吗？</p>
<p>发言人   01:15:17<br>Noting a handler, correct? There’s actually crucial that first, the page is scanned before you know, you make, you know, the page accessible to the application. Because if you were to make it accessible before you scanned it, and if there were multiple application fres, then those applications might be looking at objects on the unscanned area. For that, we need to forbid that that’s over. This code basically first scans and then raises the protection level so that the application can access the pages. Any questions about the collector and the tricks to use virtual memory?<br>注意一个处理者，对吗？实际上至关重要的是，首先，在您知道之前扫描页面，您可以使该页面对应用程序可访问。因为如果您要在扫描之前使其可访问，并且如果有多个应用程序，那么这些应用程序可能正在查看未扫描区域中的对象。为此，我们需要禁止结束。此代码基本上首先扫描，然后提高保护级别，以便应用程序可以访问页面。对收集器和使用虚拟内存的技巧有任何疑问吗？</p>
<p>发言人   01:16:07<br>Okay, well, in that case, want to wrap up? And a couple points? I want to make one point, basically. Before wrapping up, You know, one of the questions you ask, you know, should you use the yam for this? And really, is that, doesn’t these trick pay off? And because many of the you example, the garbage collectors, many garbage collectors out there that actually don’t use virtual memory at all, but you basically instrument the compiler is actually very aware of the code generated and instrument the code correctly. And as all kinds of other tricks to reduce performance, solf rat. So you ation is that in most cases it can be, most cases could have been implemented with extra instructions.<br>好的，在这种情况下，想要结束吗？还有几点？我想提出一个观点，基本上。在结束之前，你知道，你问的一个问题，你知道，你应该使用山药吗？真的，就是这样，这些把戏难道没有得到回报吗？并且因为你们中的许多例子，垃圾回收器，许多垃圾回收器实际上根本不使用虚拟内存，但你基本上是编译器非常了解生成的代码并正确地处理代码。以及各种其他降低表现的技巧，solf老鼠。所以你认为，在大多数情况下，它可以是，大多数情况下可以通过额外的指令来实现的。</p>
<p>发言人   01:17:14<br>And you know that, you know, if you’re basically it’s a compiler of a runtime or for a programming language, and then maybe that’s not not so bad because the compiler can do the instrumentation. But if you know there’s not a runtime, it’s not a compiler application or programming language sort of setting, then that might be painful. And so it turns out that for, you know, some of these applications where, you know, like there’s no compiler involved at all, for example, like you checkpointing or. Shared virtual memory. Those actually really need these kind of primitives. And so in practice, now it is the case that enough application programmers that find these primitive worthwhile that basically today’s operating systems support them.<br>而且你知道，如果你基本上是运行时或编程语言的编译器，也许这并不是那么糟糕，因为编译器可以进行检测。但是如果你知道没有运行时，也不是编译器应用程序或编程语言之类的设置，那么这可能会很痛苦。所以事实证明，对于其中一些应用程序，你知道，根本不涉及编译器，例如，检查点或。共享虚拟内存。那些实际上确实需要这些原语。因此在实践中，现在有足够的应用程序员发现这些原语是值得的，基本上今天的操作系统支持它们。</p>
<p>发言人   01:18:05<br>Okay? Some people ask, or a lot of people actually ask you, what has changed, you know, since. What’s the change since 91? One thing that S changes, of course, like, you know, most units do support the primitives now. In fact, there are many changes now since 91, you know, maybe hard to imagine, but basically there’s a continuous development in the VM system. So if you look at like the Linux and Git log, you’ll see, you know, there’s you, there’s continues developing the all aspects of the kernel, but including contiguous development of the VM system and, you know, some of the bigger changes, you know, what are some big changes in the last, you know, whatever in years?<br>好吗？有些人问，或者很多人实际上问你，自那以后发生了什么变化。91年以来有什么变化？当然，有一件事发生了变化，就像你知道的，大多数单元现在都支持原语。事实上，自91年以来，现在有许多变化，你知道，也许很难想象，但基本上，VM系统在不断发展。所以如果你看一下Linux和Git日志，你会看到，你知道，内核的所有方面都在不断发展，包括VM系统的连续开发，还有一些更大的变化，你知道，在过去的几年里，有哪些大的变化？</p>
<p>发言人   01:18:59<br>There’s a, you know, there’s now a five level page table, you know, to deal with really large, you know, bigger redresses. There’s address space identifiable to deal with Tob, the cost of Tob flushes. More recently, a year ago, something like that or something that’s called introduced is called kpti kernel page table isolation. Which, you know, is there because of the meltdown attacks and we’ll talk about later in the semester.<br>有一个，你知道，现在有一个五级页表，你知道，用来处理非常大的，你知道的，更大的纠正。有可识别的地址空间来处理Tob，Tob刷新的成本。最近，一年前，类似的东西或被称为引入的东西被称为kpti内核页表隔离。你知道的，是因为熔毁攻击，我们将在本学期晚些时候讨论。</p>
<p>发言人   01:19:33<br>So, you know, the virtual memory system is absolutely not a static system. Almost after no aspect of any kernel, the Lin kernel is static. There’s a dramatic amount of changes like almost every couple months in different aspects of the criminal. And so systems once in a while actually completely rewritten. So it’s always in flux. Okay, let me stop with that. And you know, if anybody has more questions from there, please feel free to ask them, or if you have to go, feel free to go.<br>所以，你知道，虚拟内存系统绝对不是静态系统。几乎在没有任何内核的任何方面之后，Lin内核是静态的。犯罪分子的不同方面几乎每隔几个月就会发生巨大的变化。因此，系统偶尔会完全重写。所以它总是在不断变化。好的，让我就此打住。而且你知道，如果有人有更多问题，请随时问他们，或者如果你必须走，随时走。</p>
<p>发言人   01:20:12<br>Could I ask about one? Of the first slides, where, sorry I’m trying to see it, it’s VM implementation, like two slides after this one. Yes, that one.<br>我可以问一个吗？第一张幻灯片，抱歉我试图看到它，它是VM实现，就像这张幻灯片后面的两张幻灯片一样。是的，那个。</p>
<p>发言人   01:20:26<br>What do you mean exactly by contiguous range for dresses? Oh yeah, katri’s range of virtual dresses. So you know the VMA, you know the VMA covers a range from 1000 to 2000. And if you had another address range like 2100 or something like that, that would be has its own VMA. So every vama covers continuous range of addresses, no holes in it, okay? And it makes it easier, as you will see in the. As you’ll see in the MF lab, that will make it much easier to reason about things. Because you see any stress in the range of the VMA has no hole in it.<br>你所说的连衣裙的连续范围是什么意思？哦，是的，katri的虚拟连衣裙系列。所以你知道VMA，你知道VMA覆盖范围从1000到2000。如果你有另一个地址范围，如2100或类似的东西，那将有自己的VMA。所以每个vama都覆盖了连续的地址范围，没有漏洞，好吗？这使得它更容易，正如您将在中看到的那样。正如您将在MF实验室中看到的那样，这将使推理变得更加容易。因为你看到VMA范围内的任何应力都没有空洞。</p>
<p>发言人   01:21:14<br>Okay, okay, so those are for this particular use case for MMA, I guess, right? Okay, see, thank you. So basically, you can think about it like for every n map called, there’s one VMA. If the N maps don’t overlap. Oh, okay, okay, I think, I think I understand, thank you, welcome. I wanted to ask so for. For hi the to and from like garbage collection, when do you stop and start again? Like I guess collector runs can run all the time if it’s concur. Yeah, that’s like one of the cool things about the VM solution. The collector can just run all the time and it can stop once.<br>好的，好的，那些是针对MMA的这个特定用例的，我猜，对吧？好的，看，谢谢。所以基本上，你可以把它想象为对于每个被调用的n个map，都有一个VMA。如果N个映射不重叠。哦，好的，好的，我想我明白了，谢谢，欢迎。我想这样问。嗨，垃圾收集之类的，你什么时候停止并重新开始？就像我猜收集器运行可以一直运行，如果它是一致的。是的，这就像是关于VM解决方案的很酷的事情之一。收集器可以一直运行，并且可以停止一次。</p>
<p>发言人   01:22:07<br>Basically it has, there’s no more unscanned objects. Okay? So you have, but you have to go through. That means you so, so you’ll go through all of the stuff, like all of the objects in the front section and all you’re either like going to collect them or copy them over. How do you know if can’t throw all of them? At some point you trace the object graph down, correct? And at some point, you’re not adding any objects anymore because you’re already copied them in the past. Okay, okay, that makes sense. You don’t add anymore.<br>基本上它有，没有更多的未扫描的对象。好吗？所以你有，但你必须经历。这意味着你就是这样，所以你会浏览所有的东西，比如前面部分的所有对象，你要么收集它们，要么复制它们。你怎么知道不能把它们都扔掉呢？在某个时候，你追踪物体图，对吗？在某个时候，你不再添加任何对象，因为你已经在过去复制了它们。好的，好的，那很感知。你不再添加了。</p>
<p>发言人   01:22:39<br>You know, basically your unscanned area is not growing. So if your unscanned grade is not growing anymore, you aren’t, okay, okay? And then when you copy it over you on map it. So if someone tries to like access the old pointer, it’s going to be invalid. Yeah, right, okay, that makes sense. Thanks, all right I’ll see you guys later. Yeah, to. Thank you, you’re welcome.<br>你知道，基本上你未扫描的区域没有增长。所以，如果你未扫描的成绩不再增长，那你就不会了，好吗，好吗？然后当你把它复制到地图上时。因此，如果有人试图访问旧指针，它将是无效的。是的，对，好吧，那很感知。谢谢，好吧，我待会见你们。是的，要。谢谢，你太客气了。</p>
<p>发言人   01:23:12<br>Okay, I think that may be it for today.<br>好的，我想今天可能就到这里了。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>操作系统工程 016-VirtualMemory for Applications</div>
      <div>http://example.com/2025/10/18/6S081-016/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月18日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/18/6S081-017/" title="操作系统工程 017-OS Organization">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">操作系统工程 017-OS Organization</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/18/6S081-015/" title="操作系统工程 015-FileSystem Performance and Fast Crash Recovery">
                        <span class="hidden-mobile">操作系统工程 015-FileSystem Performance and Fast Crash Recovery</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
