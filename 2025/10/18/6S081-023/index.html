

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="发言人   00:07Good afternoon, quick sound check. Can, can people hear me? Yes, thanks, Okay, so I guess today a so far, it’s the last lecture or so one this semester and we don’t really have a formal top">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统工程 023-Final QA">
<meta property="og:url" content="http://example.com/2025/10/18/6S081-023/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="发言人   00:07Good afternoon, quick sound check. Can, can people hear me? Yes, thanks, Okay, so I guess today a so far, it’s the last lecture or so one this semester and we don’t really have a formal top">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-18T02:00:23.000Z">
<meta property="article:modified_time" content="2025-10-25T05:03:39.725Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>操作系统工程 023-Final QA - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="操作系统工程 023-Final QA"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-18 10:00" pubdate>
          2025年10月18日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          20k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          166 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">操作系统工程 023-Final QA</h1>
            
            
              <div class="markdown-body">
                
                <p>发言人   00:07<br>Good afternoon, quick sound check. Can, can people hear me? Yes, thanks, Okay, so I guess today a so far, it’s the last lecture or so one this semester and we don’t really have a formal topic. There’s a Q&amp;A lecture, so feel free to ask questions about anything. This is, I guess, the last, the last gen, at least this semester for this class.<br>下午好，快速检查声音。人们能听到我说话吗？是的，谢谢，好的，我想今天到目前为止，这是这学期的最后一堂课左右，我们还没有正式的话题。有一个问答讲座，所以随时可以问任何问题。我猜，这至少是本学期这门课的最后一代。</p>
<p>发言人   00:42<br>By default, my plan was to go over a couple topics based on questions over email. One is going to talk a little bit about the network lab, the solutions, if possible, also a little bit time about the MMA La, and again, talking about the solutions. And then there were a lot of questions about the follow on classes, and in fact, I think will cover that first. But before we dive them in any of these three topics, let me remind you there’s a subject evaluation.<br>默认情况下，我的计划是根据电子邮件中的问题来复习几个主题。其中一个将会稍微谈谈网络实验室，解决方案，如果可能的话，也会稍微谈谈MMA La，然后再谈谈解决方案。然后有很多关于后续课程的问题，实际上，我认为将首先涵盖这一点。但在我们深入探讨这三个主题之前，让我提醒你有一个主题评估。</p>
<p>发言人   01:23<br>Ongoing and the staff as we want. We appreciated you give you a feedback on SOA and hopefully it’s positive and we get a chance to teach it again next year. And maybe this is also a good time to, you know, actually thank you for attending today’s lecture, even though there’s not a sort of very formal program. But I also appreciate the fact that the staff in general appreciate the fact that, you know, you’re being very engaged and particularly with the paper, not directly to the labs, it’s clear that many of you dove into the papers and try to really understand them and ask great, great questions of over email. So we very much appreciate the engagement. Any questions before I go over these set of topics?<br>持续的和我们想要的员工。我们非常感谢您对SOA的反馈，希望是积极的，明年我们有机会再次教授它。也许这也是一个很好的时间，你知道，实际上感谢你参加今天的讲座，即使没有一种非常正式的计划。但我也很感激工作人员普遍欣赏这样一个事实，你知道，你非常投入，特别是与论文，而不是直接到实验室，很明显，你们中的许多人都深入研究论文，并试图真正理解它们，并提出了很好的要求。关于电子邮件的好问题。所以我们非常感谢你们的参与。在我讨论这些话题之前，有什么问题吗？</p>
<p>发言人   02:21<br>Okay, let me start then with the question that probably came up most in email, what next? There’s quite a number of classes that systems oriented focused, and I’m sure I missed a number of classes that I should have listed here, you know, immediately sort of straightly related to operating systems.<br>好的，让我从电子邮件中最常出现的问题开始，接下来呢？有相当多面向系统的课程，我相信我错过了一些我应该在这里列出的课程，你知道，这些课程与操作系统直接相关。</p>
<p>发言人   02:44<br>You know, clearly, you know, if you haven’t taken 0 3 3 yet, you know, it’s a great class to take, particularly to read, read or learn how to read papers, 6808 was the originally the only OS class the we offered this year or this is the second year. This year is the year, first year that we’re offering both. So s.a. one is sort of undergrad OS and Sa 2 a 2 8 has the GT level OS class, and basically a 2 8 assumes you’ve taken OA one or red OS and goes off and doing projects, you know, building interesting OS artifacts and reading more papers from the literature, more of the modern research literature. Then maybe you are more the OS sort of know there’s a lot of innovation with the hardware, a little have been more of the hardware side of systems. You know, the computer architecture class A 2, 3, which I believe is offered to the coming spring. And of course, the 6001 11, you know, sort of the you building something hardware devices on the sort of performance sites and the compiler sites 6172 and 6035 for good places in the number of you are taking 6172 in parallel with SOA 1. But if you haven’t taken, for example, the Pi class of 3, 5 or dynamic coil class, both of them are also great classes.<br>你知道，很明显，你知道，如果你还没有上0 3 3，你知道，这是一个很好的课程，特别是阅读，阅读或学习如何阅读论文，6808最初是我们今年提供的唯一操作系统课程，但今年是第二年。今年是我们提供这两种服务的第一年。所以s.a. 一个是本科操作系统，而2 a 2 8具有GT级别的操作系统类，基本上，2 8假设你已经采取了OA 1或red操作系统并开始做项目，你知道，构建有趣的操作系统文物并阅读更多文献中的论文，更多的是现代研究文献。那么也许你更像是操作系统，知道硬件有很多创新，更多的是系统的硬件方面。你知道，计算机体系结构a2、3班，我相信是为即将到来的春天提供的。当然，6001 11，你知道，你在某种性能站点上构建一些硬件设备，编译器站点6172和6035在你的数量中占据了很好的位置，与SOA 1并行使用6172。但是，如果你还没有上过，例如3，5的Pi类或动态线圈类，它们都是很棒的课程。</p>
<p>发言人   04:11<br>Systems is a broad topic. So like there’s networking and there’s a whole branch of classes, a whole stream of classes around networking with a whole stream of class around databases, which are all good and important And aspects that you’ve seen in Sua 1 will show up in much more prominent ways in those classes. So for example, networking, clearly there’s a great topic of, you know, 8 to 9. And so you will see a lot more about networking there then you’ve seen in So 0 8 1 6830, you know, we talked about file systems, you know, clearly another important class of storage systems and probably in some ways more important for many applications is databases. So 6 is a great topic class to learn a lot more about databases in terms of like classes that are sort of you sometimes called whatever the Pdos classes, there’s a number of them, 824, the distribute systems class. We’ll be offering that coming semester, spring semester, and section of the number of the staff involved this semester in there. So it 1 will be involved in a 2, 4, there’s 858, which is the computer security class, we won’t be offering in that coming this spring, but we hope to offer it next academic year. And there’s 826, which is the principles of computer system.<br>系统是一个广泛的话题。就像有网络和整个课程分支，围绕网络的整个课程流和围绕数据库的整个课程流，这些都是好的和重要的，你在Sua 1中看到的方面将在这些课程中以更突出的方式出现。例如，网络显然是一个很好的话题，你知道，从8到9。所以你会在那里看到更多关于网络的知识，比你在0 8 1 6830中看到的要多，你知道，我们谈论了文件系统，你知道，显然另一类重要的存储系统，可能在某些方面对许多应用程序更重要的是数据库。所以6是一个很棒的主题课程，可以学习更多关于数据库的知识，就像你有时称之为Pdos类的类一样，有很多，824，分布式系统类。我们将提供即将到来的学期和春季学期，以及本学期涉及的员工人数部分。所以1将参与2，4，有858，这是计算机安全课程，我们不会在今年春天提供，但我们希望在下一学年提供。还有826，这是计算机系统的原理。</p>
<p>发言人   05:41<br>So a number of people ask about verification and system software. This is the class to take if you’re interested in that topic.<br>因此，许多人询问验证和系统软件。如果你对这个话题感兴趣，这就是你要上的课程。</p>
<p>发言人   05:49<br>More broadly speaking, a lot of people wondering like what is actually going on in research? If you’re interested, you know, the almost all the papers in the systems literature are publicly available. The ones at the recent conferences, for example, the Oci conference happened a couple weeks ago. And you can just look at the see what kind of topics are covered and read the papers that you find it interesting. All the talks are published One of the venues, I guess, the Covid period is that all these conferences are virtual. And so all the conferences talks are recorded and you can just watch them and see what’s going on.<br>更广泛地说，很多人想知道研究中实际发生了什么？如果你感兴趣，你知道，系统文献中几乎所有的论文都是公开的。例如，在最近的会议上，Oci会议发生在几周前。你可以看看涵盖了哪些主题，并阅读你觉得有趣的论文。所有的谈话都发表了，我想，在Covid时期，所有这些会议都是虚拟的。因此，所有会议的谈话都被记录下来，你可以观看它们，看看发生了什么。</p>
<p>发言人   06:24<br>If you’re interested in, there’s sort of two parts, you know, is the research part, then of course, now there’s what’s going on in practice and you’re sort of interested in keeping track of what’s happening with Linux and how that’s how it’s evolving, lwn dot net actually publishes at a very regular page, very interesting articles about sort big changes or topics that are around the Linux kernel. Finally, you know, if you’re excited about like doing the labs, you know, just keep, keep hacking. I think you can use easily to cook up projects or either by doing extension of labs or just trying things out on your own and is a great way to really learn, appreciate how things work. You probably have gotten good sense of doing gallops. We’re sort of big fans of learning by doing and a. Lot of that you can do it on your own.<br>如果你感兴趣的是研究部分，那么当然，现在实践中正在发生的事情，你对跟踪Linux发生的事情以及它是如何发展的感兴趣。Lnndot net实际上在一个非常普通的页面上发布了关于Linux内核的重大变化或主题的非常有趣的文章。最后，你知道，如果你对做实验室感到兴奋，你知道，就继续，继续黑客攻击。我认为你可以轻松地制作项目，或者通过扩展实验室或自己尝试，这是真正学习、欣赏事物运作的好方法。你可能已经有了很好的感知去骑马。我们是 “边做边学” 的忠实粉丝。很多事情你可以自己做。</p>
<p>发言人   07:22<br>Any questions about? What next after in 8 1?<br>有什么问题吗？8 1之后的下一个是什么？</p>
<p>发言人   07:41<br>Okay, well, let’s talk about the Net lab. It was due, like I said yesterday.<br>好的，让我们谈谈网络实验室。就像我昨天说的那样，它已经到期了。</p>
<p>发言人   07:56<br>And so as I said, there’s a couple things. So maybe I’ll start there, dive in sort of slowly and start a little bit at the top. And let me talk a little bit in generic terms about the lab. There’s a couple of things. I first, I want to talk a little bit about just sort of structural things that sort of influenced the design of the lab or know the coding of the lab. And those are four different things. Aspects.<br>就像我说的，有几件事情。所以也许我会从那里开始，慢慢潜水，从顶部开始。让我笼统地谈谈实验室。有几件事情。首先，我想谈一点影响实验室设计或了解实验室编码的结构性因素。这些是四件不同的事情。方面。</p>
<p>发言人   08:26<br>One is I just want to talk a little bit about hardware. You know, this is one of the labs where we there’s a lot of interaction between the software and hardware. And in fact, the hardware determines for a great part like how the structure of the software, then a little bit about software structure. And this comes sort of back to this general topic that we covered in sort of like somewhere in the middle of the term about, you know, the organization of drivers relative to the rest of the operating just mcconell then talk a little bit more specific about hardware structure of the rings and the descriptors. The two primary sort of hardware structures that the driver deals with or must deal with. And then I’ll talk a little bit and talk about the code and particularly the solutions and sort of focusing on talk a little bit about the role of in buffs.<br>其中一个是我只想稍微谈一下硬件。你知道，这是一个实验室，在那里我们有很多软件和硬件之间的交互。实际上，硬件在很大程度上决定了软件的结构，然后是软件的结构。这又回到了我们在术语的中间提到的一般话题，你知道，相对于其他操作的驱动程序的组织，然后更具体地谈谈环的硬件结构和描述符。驱动程序处理或必须处理的两种主要的硬件结构。然后我会稍微谈谈代码，特别是解决方案，并重点谈谈在爱好者中的作用。</p>
<p>发言人   09:19<br>You walking a lot of questions over email about, you know, why not a walk in the chief lock in the receive function while loop in the receive handler? And you know what exactly, you know, do the flags meaning the command command field of the structure of the descriptor. And so we’ll get to those issues as we look at the talk, as we look at the code, the just before we drive in, like it may be worthwhile to reminding ourselves here what the challenges are, although they’re probably fresh in your head, but like more the more high level and what are the sort of core challenges that you have to deal with in this lab? If you’ll jump in to add any ones that I might have missed and you’re struggled with.<br>你在电子邮件中提出了很多问题，你知道，为什么不在接收函数的主锁中行走，同时在接收处理程序中循环？而且你知道，你知道，标志意味着描述符结构的命令命令字段。因此，当我们看演讲时，当我们看代码时，我们会讨论这些问题，就在我们开始之前，提醒自己这里的挑战是什么可能是值得的，虽然它们可能是新鲜的在你的脑海中，但是更高水平，你在这个实验室中必须处理的核心挑战是什么？如果你愿意加入任何我可能错过而你挣扎的内容。</p>
<p>发言人   10:07<br>So first of all, you know, there’s the hardware specification. This is a, you know, it’s a PDF, is a pretty serious document. And this network card, the E1 thousand, even though it’s a reasonable simple network card, is still a very sociated piece of hardware that offers a lot of different features and ways you can program. And so just getting on top of actually what the car does and how do you program it, just internalizing all that, it is difficult and poses a challenge.<br>首先，你知道，这是硬件规格。这是一份，你知道，这是一份PDF格式的文件，是一份相当严肃的文件。这张网卡e1000，即使它是一张合理简单的网卡，仍然是一个非常相关的硬件，提供了许多不同的功能和编程方式。因此，仅仅了解汽车的实际功能以及如何对其进行编程，将所有这些内化，这是困难的，也是一个挑战。</p>
<p>发言人   10:46<br>Second, I think major challenge is the concurrency side of things and the sort of two parts of the concurrency that makes this a lot challenging. One is just the concurrency between the hardware and the star. Like the network card is just doing things like sending packets, receiving packets at the same time, you know, the OS current was running and the driver is running. And so there has to be some coordination plan know between the heart range software to actually make sure that everything works out and a large part of the driver is dealing with that coordination.<br>其次，我认为主要的挑战在于事物的并发方面，并发的两个部分使得这很有挑战性。一个只是硬件和星形之间的并发。就像网卡只是在做发送数据包和接收数据包的事情一样，你知道，操作系统当前正在运行，驱动程序正在运行。因此，必须在心脏范围软件之间建立一些协调计划，以确保一切正常，并且大部分驾驶员都在处理这种协调。</p>
<p>发言人   11:24<br>There’s also the software, software coordination, the driver, multiple threats or multiple kernel threats might be ending or out handler run inside of the driver. And we’ve got to make sure that they don’t step on each other’s toes. Everything else happens. And this comes a lot to like, you know, the locking topic. Even in this driver, things are reasonable, straightforward in terms of the for the software concurrency, but nevertheless, you know, it’s something that requires attention and a little bit of thinking.<br>还有软件，软件协调，驱动程序，多个威胁或多个内核威胁可能会结束或在驱动程序内运行处理程序。我们必须确保他们不会踩到对方的脚趾。其他一切都会发生。这很大一部分是关于锁定的话题。即使在这个驱动程序中，在软件并发性方面，事情也是合理、简单的，但你知道，这是需要注意和一些思考的事情。</p>
<p>发言人   11:59<br>And then finally, I guess the As, that’s probably on the top of your list or many of your list is, you know, just debugging this is a little bit hard or a little bit sometimes more challenging software debugging because you can’t set breakpoint inside of the network cart, know you’re in program the registers, and then they will give the car a kick and say like, you know, please do your work. And then if the car doesn’t do anything or you don’t see your packet coming out on the other side, you know, in the log, you know, pack a trait, then you basically you have to scratch your head and sort of start thinking about like what, what might you have gone wrong or what might you have missed in the hardware specification? And so you have to go circle back and forth. And there’s no sort of easy way. You can just can’t not single step, you know, through the network card. Does that make sense in terms of challenges? You know, does that line up with your own experience? Or am I missing some of the missing one of the core challenges that you dealt with.<br>最后，我猜那个可能在你的列表顶部，或者你的列表中有很多是，你知道，只是调试这有点困难，或者有时更具挑战性的软件调试，因为你不能在网络购物车内设置断点，知道你在对寄存器进行编程，然后它们会踢汽车并说，你知道，请做好你的工作。然后，如果汽车没有做任何事情，或者你没有看到你的数据包从另一边出来，你知道，在日志中，你知道，包装一个特征，那么你基本上必须挠头，开始思考像什么，你可能出错了什么，或者在硬件规格中可能遗漏了什么？所以你必须来回盘旋。并没有简单的方法。你不能只是一步一步地穿过网卡。这在挑战方面有感知吗？你知道，这与你自己的经验相符吗？还是我错过了你所应对的一些缺失的核心挑战之一。</p>
<p>发言人   13:18<br>Okay? Let’s talk to, let’s start with the hardware side of things. The reason I want to start there because, you know, it’s easy to keep or lose track of the fact that actually we’re dealing with hardware here. You know, even though, you know, sort of verticalized where it is emulated by qmu and you’re just running it on your on Afina or on your laptop, the actual thing that’s implemented by q.u. is hardware. So it should just remind you again, you’ve seen this picture before you.<br>好吗？让我们谈谈，让我们从硬件方面开始。我想从那里开始的原因是因为，你知道，很容易记住或忘记我们在这里处理硬件的事实。你知道，即使，你知道，有点垂直化，它被qmu模拟，你只是在Afina或笔记本电脑上运行它，q.u实际实现的东西。 硬件。所以它应该再次提醒你，你之前已经看过这张照片了。</p>
<p>发言人   13:51<br>The way to think about it is that, you know, you emulates a complete board of devices and the processor and. And so again, as we all know I’ll talk a little bit before about it, like the process. Actually, these are like almost like a small piece of the whole board, you know, is the thing that sits under the fan here. But then you, there’s a range of devices, you know, that are, you know, connected or can be connected to this board and then interact, you know, with the code running on the processor. You know, here, you know, for this particular lab, you know, what is interesting sort of, and the actually the eett jack, you know, where you can pluck in thatt cable and then the other actually the thing that the network cart sends its packets over. Now Pp doesn’t emulate exactly with this board, so things are slightly differently. But again, know, at least exceptionally, this is like at the picture you should have in your head. And so when the process writing registers of the device driver that cost some stuff to happen that actually in the end, some packet comes out of this cable that’s connected to the e-net connector in a slightly more, you know?<br>思考它的方式是，你知道，你模拟了一个完整的设备板和处理器。所以，我们都知道，我会在讨论这个过程之前谈一点。实际上，这些几乎就像是整个木板的一小块，你知道，就是坐在风扇下面的东西。但是接下来，有一系列设备，你知道，它们可以连接或可以连接到这个板，然后与处理器上运行的代码进行交互。你知道，在这里，你知道，对于这个特定的实验室，你知道什么是有趣的，实际上是eett插孔，你知道，在那里你可以拔出电缆，然后另一个实际上是网络车发送数据包的东西。现在Pp没有完全模仿这个板，所以事情略有不同。但是，再一次，知道，至少在特殊情况下，这就像你应该在脑海中想象的那样。因此，当编写设备驱动程序的寄存器需要花费一些事情时，实际上最终会有一些数据包从连接到电子网络连接器的电缆中出来，你知道吗？</p>
<p>发言人   15:13<br>In slightly more in a schematic diagram, you know, this is the same picture basically in here, you know, we’re seeing here’s our processor board that has 4 cores on it. It has one of the L 1 and L 2 caches and then has like link going to memory and random access memory. And we’ll see in a second. You know, that plays actually a big role. And then here, like, you know, actually the link, you know, to the Or here actually to link to the gigabit, even a controller now it’s a little bit messy.<br>在原理图中稍微多一点，你知道，基本上在这里是相同的图片，你知道，我们看到这里的处理器板有4个内核。它有一个L 1和L 2缓存，然后有将连接到内存和随机访问内存的链接。我们将在一秒钟内看到。你知道，这实际上起到了很大的作用。然后在这里，就像你知道的，实际上是链接，你知道，或者这里实际上是链接到千兆位，甚至是控制器，现在它有点混乱。</p>
<p>发言人   15:47<br>You know, sort of think about this level of detail, what exactly is going on? Like for the rest of the lecture, a little bit more simpler picture. And the picture does really, you’re in your head and you probably developed while doing the lab is just follows.<br>你知道，想想这种程度的细节，到底发生了什么？就像讲座的其余部分一样，有一个更简单的画面。而且图片确实如此，你在脑海中，你可能在做实验室时开发了它。</p>
<p>发言人   16:08<br>Basically, we have our risk for processors for course. So here’s our risk 5. And describe course, execute instructions, your writing. And you can just think about them. They’re sort of all connected to your boss. And there’s a little bit of a simplification, but like, and it makes it easier to explain things. And so like on the bus, you know, there’s the random access memory. Where all the data, you know, the current election we uses is stored, you know, the current Texas itself is stored.<br>基本上，我们当然有处理器的风险。这就是我们的风险5。并描述课程，执行指令，你的写作。你可以只考虑它们。他们都跟你的老板有联系。并且有一些简化，但是这使得解释事情更容易。就像在公共汽车上一样，你知道，有随机存取存储器。所有数据，你知道的，我们使用的当前选举存储在那里，你知道，当前的德克萨斯州本身被存储在那里。</p>
<p>发言人   16:45<br>You know, we’ve looked at a great amount of detail in the beginning of the semester and then in this know for this particular lot, the thing that’s interesting is that on the bus is actually network arc, you know, that you 1000. And, you know, the Ram is generally more connected to the risk fly processor directly with some private bus and network. The divisors will tend to be on the slower type of bus. And in particular, the in the lab, there’s a Pcie Pcie bus that actually connects the processor part, you know, with the network car.<br>你知道，在学期开始的时候，我们已经看了很多细节，然后在这个特定的地段，有趣的是，在公共汽车上实际上是网络弧，你知道，你1000。而且，你知道，内存通常更多地通过一些私人总线和网络直接连接到风险飞行处理器。这些乘员将倾向于乘坐速度较慢的公交车。特别是，在实验室中，有一个Pcie Pcie总线实际上将处理器部分与网络汽车连接起来。</p>
<p>发言人   17:28<br>To get the network card to do something, the network card has controller inside of it. And these controller has registers. And you can one of the cool aspects of these registers there called Nami mapped IO registers. And so you could just write them with, you know, whatever star, you know, x and whatever the value is, you know, for in the physical memory space what the value is for that particular retic, you know, like might have our head, our tail register. And, you know, we can driver can, you know, write those by executing, you know, a load or restore instruction, you know, to the address, you know, that corresponds, you know, in the physical address phase to the location of that register. And the hardware will ensure when we do load to store, you know, that store will either go, you know, will go through the if it is to one of the controller register, it will go to the controller registers, if it goes one of the rests in Ram, we can all go to the Ram, and so you can just manipulate or program network card by loading, reading, and writing these controller registers And basically the bits in these controller registers have special meaning as you have seen.<br>为了让网卡做点什么，网卡内部有控制器。这些控制器有寄存器。你可以使用这些寄存器的一个很酷的方面，称为Nami映射IO寄存器。所以你可以用任何星星，你知道，无论x和任何值是什么，你知道，因为在物理内存空间中，那个特定的实体的值是什么，你知道，就像我们的头，我们的尾寄存器一样。并且，你知道，我们可以驱动程序通过执行加载或恢复指令将其写入地址，你知道，在物理地址阶段对应于该寄存器的位置。并且硬件将确保当我们进行加载到存储时，存储将要么经过，如果它是到控制器寄存器之一，它将进入控制器寄存器，如果它进入了内存中的一个休息部分，我们都可以进入内存，因此您可以通过加载、读取和写入这些控制器寄存器来操作或编程网卡，基本上这些控制器寄存器中的位具有特殊的意义，正如您所看到的。</p>
<p>发言人   18:44<br>Now, for this particular car network card, you need to send, of course, packets across the network and it needs to get the packet somewhere. And so the packets actually live in, or you’ve allocated, as we’ll see in a second, usually live somewhere in memory. And what we do is, and in fact, in addition to these packets, you know, there are sort of two ring structures that also live in memory. And. And we can program and we can tell the cart, you know, the car knows, knows what these ring structures are, you know, that has a address where, where to, you know, TX ring is it has an address where where Rx ring is And, you know, the hardware cart, you know, looks at donge addresses to actually see which packets need to be sent.<br>现在，对于这个特定的汽车网卡，您当然需要通过网络发送数据包，并且它需要在某个地方获取数据包。因此数据包实际上位于内存中，或者您已经分配了，正如我们稍后将看到的那样，通常位于内存中的某个地方。我们所做的是，事实上，除了这些数据包之外，你知道，还有两种环形结构，它们也存在于内存中。而且。我们可以编程并告诉车，你知道，汽车知道，知道这些环结构是什么，你知道，它有一个地址，在哪里，你知道，TX环是它有一个地址，其中Rx环是，你知道，硬件推车会查看donge地址，以实际查看需要发送哪些数据包。</p>
<p>发言人   19:39<br>And so here we might have a queue of you packets that need to be transmitted or a queue of packets that need to be received. And. You know the E1 thousand, you know DMA, you for example, like, you know, it’s going to work on like the first faculty you sent DMA basically, you know, packets, the data associated it with the packets and no straight from Ram to the network without actually having the process involved at all. So this is what it called DMA direct memory access.<br>所以在这里，我们可能有一个需要传输的数据包队列或一个需要接收的数据包队列。而且。你知道的E1，000，你知道的DMA，例如，你知道的，它会像你发送的第一个教员一样工作，基本上，你知道的，数据包，数据与数据包相关联，而不是直接从Ram到网络，而实际上根本不涉及这个过程。这就是所谓的DMA直接内存访问。</p>
<p>发言人   20:19<br>Okay, does this make sense in terms sort of a more abstract picture for the organization of the risk 5 Ram and year 1000. Any questions about this?<br>好的，这是否使得感知在某种程度上更抽象地描述了风险5 Ram和1000年的组织情况。对此有什么问题吗？</p>
<p>发言人   20:41<br>So one thing in the talking about sort of the hardware of hardware and hardware software concurrency, clearly, you know the E1 thousand and you know, the processor are both manipulating these transmission and reception queues rings. And so there has to be some protocol sort given, taken, give and take protocol At some point, particular parts of the ring are operated, are owned or operated by the network car and parts that are maybe under control of the software or the OS or the kernel. And, you know, we’ll see in a second how that is arranged. But, you know, we got a little bit careful and again, that the car doesn’t triple over or triple over the operating system or the other way around.<br>所以在谈论硬件硬件和硬件软件并发时，有一件事显然，你知道e1000，你知道，处理器都在操纵这些传输和接收队列环。因此，必须有一些协议排序，在某个时刻，环的特定部分被操作，由网络汽车拥有或操作，而部分可能在软件、操作系统或内核的控制下。而且，你知道，我们一会儿就会看到这是如何安排的。但是，你知道，我们有点小心，再次，汽车不会在操作系统或相反的情况下三倍或三倍。</p>
<p>发言人   21:28<br>A quick question. So is there a separate like transmit ring and receive ring in the Ram and then also in the E 101000 driver? Yeah, well, the one week thing.<br>一个快速的问题。那么在内存中以及在e101000驱动器中是否有一个单独的传输环和接收环？是的，一周的事情。</p>
<p>发言人   21:41<br>Okay, so there’s two things going on and we’ll look at the code in a second, The transmission ring and the receiver ring basically live in Ram, and both the E1 thousand in the risk 5 manipulate, you know, the ring that actually stored in Ram. And those are the rings that you saw in the hardware documentation. It happens to be the case is that XV 6 also has you, the driver maintains, and sort of a ring of mbos separately of the transmit ring and the Rx ring, so like there’s something called TX emboss. And that’s, you know, that is a data structure only the operating system really knows about. You know, the network card doesn’t really know about it. Network card only knows about the TX ring and Rx ring because those are the values that were programmed into the registers saying like, here’s where you can find, here’s the address where you can find the transmitter ring. Here’s the address where you can find the receiver. Okay, yeah, that makes sense, that makes sense.<br>好的，有两件事情在进行中，我们稍后会看一下代码，传输环和接收环基本上生活在内存中，而风险5中的E1千人操纵，你知道，实际存储在内存中的环。这些是您在硬件文档中看到的环。它恰好是这样的，XV 6也有你，驱动程序维护着，以及一种独立于传输环和Rx环的mbos环，就像有一种叫做TX浮雕的东西。你知道，这是一种只有操作系统真正知道的数据结构。你知道，网卡并不真正知道这件事。网卡只知道TX环和Rx环，因为这些值被编程到寄存器中，比如说，这里是您可以找到的地址，这里是您可以找到发射器环的地址。这是你可以找到接收者的地址。好的，是的，这就是感知，这就是感知。</p>
<p>发言人   22:49<br>Okay, so that’s sort of the hardware picture in a more schematic version.<br>好的，这是硬件图片，更具原理图的版本。</p>
<p>发言人   22:55<br>Next, let’s a little bit about the software structure. And there’s a big refusing actually in this lab. Software structure. So, you know, let’s draw the thing that we most care about, of course, is the driver. Here’s our driver, the E1 thousand driver. And so it basically has only two functions. It has the transmit function. And it has the receive function. And the Re function runs in responses to interrupts and interrupt happens. Then you know XV 6, you know, we’ll use if the usual mechanism, you know, trap will happen, the trap will look, you know, to see if there’s an interrupter in the network card. If there’s an interrupter in the network card that we’ll call the receive function.<br>接下来，让我们稍微了解一下软件结构。在这个实验室里实际上有一个很大的拒绝。软件结构。所以，你知道，让我们画出我们最关心的东西，当然是司机。这是我们的司机，E1，000名司机。因此它基本上只有两个功能。它具有传输功能。它具有接收功能。并且Re函数在对中断和中断发生的响应中运行。那么你知道XV 6，你知道的，如果通常的机制会发生陷阱，陷阱会检查网卡中是否有中断器。如果网卡中有中断器，我们将调用接收功能。</p>
<p>发言人   24:02<br>And as you remember, you know, we’re to one of the previous lectures about device drivers. You know, it’s often helpful to think of the device driver split in two parts. You know, the bottom half, which runs in the context of an interrupt handler, typically for used in the top half. Generally, it runs in the context of kernel process or like a usual alpha process.<br>正如你所记得的，你知道，我们之前的讲座之一是关于设备驱动程序的。你知道，将设备驱动程序分为两部分通常是有帮助的。你知道的，下半部分，在中断处理程序的上下文中运行，通常用于上半部分。通常，它在内核进程或像通常的alpha进程一样运行。</p>
<p>发言人   24:29<br>So example, if you’re thinking about, you know, things that sit on top of here, there’s the network stack, the code that actually implements IP UDP. And so sort of above this. And then, you know, there’s, you know, our usual, you know, sort of line, you know, kernel space below user space blow up. And this is a very OS view of the world where like use space is not particularly that big or important. And, you know, example, our whatever net test, if a user level program or runs user space and it makes system calls, assistant goals go to the network stack. And for example, like if you calls the rights system call, we have a file descriptor. The kernel knows, you know, for DOC file descriptor, if you do a right, then you know the rights, you go through the network stack, the network stack builds up the packets, and then it calls transmit, and then transmit whatever manipulates the transmission queue, the TX queue or ring, and that actually gets back off the network.<br>举个例子，如果你正在考虑，你知道，位于这里的东西，有网络堆栈，实际实现IP UDP的代码。而且有点超过这个。然后，你知道，我们通常的，你知道，有点行，你知道，用户空间下面的内核空间爆炸了。这是一个非常操作系统的世界观，在这个世界中，使用空间并不是特别大或重要。而且，你知道的，例如，我们的任何网络测试，如果用户级别编程或运行用户空间并进行系统调用，则助理目标将转到网络堆栈。例如，如果您调用权限系统调用，我们就有一个文件描述符。内核知道，你知道，对于DOC文件描述符，如果你做对了，那么你就知道权利，你穿过网络堆栈，网络堆栈构建数据包，然后它调用transmit，然后传输操纵传输队列的任何东西，TX队列或环，这实际上从网络上返回。</p>
<p>发言人   25:40<br>At some point, the response might come back, that will generate an interrupt, and then the receive function will run and inspect, know the receive ring.<br>在某个时刻，响应可能会返回，这将生成一个中断，然后接收函数将运行并检查，了解接收环。</p>
<p>发言人   25:50<br>So there’s a couple things that we want to, I want to point out in terms of concurrency. So first of all, the interrupt handler basically can run at any instant in time. We might be in user space. And if interrupt comes in mechanism will cost, you know, the current user program to switch to the kernel mode, you know, the trap functionality code that we’ve seen before it runs and it will all receive. So we might be in the middle of some, usually if a processing boom, you know, we get an interrupt and suddenly we’re in the receive function. And even in the kernel, like if we’re not holding locks, you know, locks turn interrupts off, but we’re not holding locks, you know, we could get an interrupt, the Kern may change the program calendar basically to the interrupt handler around the receive function.<br>所以在并发性方面，我们想要指出一些事情。首先，中断处理程序基本上可以在任何时刻运行。我们可能在用户空间。如果中断进入机制将花费当前用户程序切换到内核模式，你知道，我们在运行之前看到的陷阱功能代码，它将全部接收。所以我们可能正处于一些中间状态，通常如果处理繁荣，你知道，我们得到一个中断，突然我们进入了接收功能。甚至在内核中，如果我们没有持有锁，你知道，锁会关闭中断，但我们没有持有锁，你知道，我们可能会得到一个中断，Kern可能会将程序日历基本上更改为接收函数周围的中断处理程序。</p>
<p>发言人   26:39<br>So this code sort of runs, you know, the things that in the bottom have, you know, completely basically run instantly almost any time in the code that in the top half, it really operates on behalf of usual level of processes or kernel threads that actually make calls into the top half. And, you know, usually it could have the case, correct? In fact, this is the case even in net test, you know, we might actually have netex actually the forex, you know, a whole bunch of processes we have actually many instances in one of the tests, we have many instances of net test running. And they all jump into, you know, the network stack and they all, you know, then call transmit, right? So that is the case looking at this from the perspective of concurrency, multiple Xs can be actually in the context, can be in the top half. And so it’s pretty clear we need some locking scheme or discipline to at least make sure that the different senders don’t trip over each other.<br>因此，这段代码运行，你知道，在底部的东西，你知道，在代码的上半部分中，它实际上代表通常的进程或内核线程运行，这些进程或线程实际上调用了上半部分。而且，你知道，通常它可能会有案例，对吗？事实上，即使在网络测试中也会出现这种情况，你知道，我们实际上可能有netex外汇，你知道，一大堆进程，我们实际上在其中一个测试中有许多实例，我们有许多运行网络测试的实例。他们都跳进了网络堆栈，然后呼叫传输，对吧？因此，从并发的角度来看，多个Xs实际上可以在上下文中，可以在上半部分。因此，很明显，我们需要一些锁定方案或纪律，至少确保不同的发送者不会相互绊倒。</p>
<p>发言人   27:40<br>Then in the bottom half, there’s only one interrupt handler directive. There’s never the case that chief is going to be called by multiple. They’re multiple received running at the same time in parallel on different courses. You know, the interrupt handler, when an interrupt happens, the processes alerted. And if future interrupts happen, they’re actually blocked until the current interrupt actually is dealt with. And so, in fact. When the receive function runs, there’s actually only one in run hand running at the time that it calls receive. So there’s no real immediately concurrency in receive itself, although of course, the transmit, you know, frets can run currently in with the interrupt handler.<br>那么在下半部分，只有一个中断处理程序指令。从来没有这种情况，酋长会被多人召唤。它们是多个接收同时在不同课程上并行运行的。你知道，中断处理程序，当中断发生时，进程会发出警报。如果将来发生中断，它们实际上会被阻塞，直到当前中断得到处理。所以事实上。当接收函数运行时，实际上在调用receive时只有一个在运行中。所以接收本身并没有真正的立即并发，尽管当然，传输，你知道，烦恼当前可以在中断处理程序中运行。</p>
<p>发言人   28:31<br>For example, we might have one core running in the interrupt handler, and we may have another core, you know, it actually is is about to transmit. Any questions about this? Sort of important to have. To understand, it’s a bit of review, but it’s important to.<br>例如，我们可能有一个内核在中断处理程序中运行，并且我们可能有另一个内核，你知道，它实际上即将传输。对此有什么问题吗？这样很重要。要理解，这有点审查，但重要的是。</p>
<p>发言人   29:00<br>Okay, so I guess I have a general question. How do we know what is supposed to be classified as a bottom half and a top half? So, yeah, I think the way to think about it is that anything that runs in the context of an interrupt handler, that’s the bottom half and in this case is basically just receive. And anything that runs in the context of a regular process or Fred or Colonel Fred, you know, that’s the top half. Okay, so if you look at this picture.<br>好的，我想我有一个一般性的问题。我们怎么知道什么应该被分类为下半部分和上半部分？所以，是的，我认为考虑它的方法是，在中断处理程序的上下文中运行的任何东西，都是下半部分，在这种情况下基本上只是接收。以及在常规流程或弗雷德上校上下文中运行的任何东西，你知道，那是上半部分。好的，如果你看这张照片。</p>
<p>发言人   29:37<br>A little bit more since we’re actually, let me make a high level statement here.<br>稍微多一点，因为我们实际上是，让我在这里发表一个高级别的声明。</p>
<p>发言人   29:42<br>A lot of people ask, you know, why no lock and receive and where is a lock needed? And sort of at first glance, it might not be necessary that the walker necessary, correct? Because there’s only one instance of receive running. So there’s not multiple instances of receive running at the same time. And so these receives, since there’s only one receive, you know, it doesn’t share data structures with any other receive because there’s only one of them right now.<br>很多人问，你知道，为什么没有锁和接收，在哪里需要锁？乍看之下，步行者可能不一定必要，对吗？因为只有一个receive实例在运行。所以并没有多个receive实例同时运行。所以这些接收，因为只有一个接收，你知道，它不与任何其他接收共享数据结构，因为现在只有其中一个。</p>
<p>发言人   30:09<br>Of course, it could be the case that we receive in the transmitter shared data structure, but as we see in a second, that actually is not the case. Basically, the remiss part of the driver is completely separate from the reception part of the driver or the receiving packets. And so as a result is we received really doesn’t need absolute locks. It’s not sharing data structures with any other concurrent activity.<br>当然，这可能是我们在发射器中接收共享数据结构的情况，但正如我们在一秒钟内看到的那样，实际上并非如此。基本上，驱动程序的疏忽部分与驱动程序的接收部分或接收数据包完全分离。因此，我们收到的结果是不需要绝对锁。它不与任何其他并发活动共享数据结构。</p>
<p>发言人   30:35<br>The weird part is that you, some of you, found out if you do use a lock, you actually get a panic. So let me say a little bit about that, because the reason that panic happens is a little bit because there’s a the software structure actually in the E1 in XV 6 kernel slightly. Slightly more complicated, you might think. And the reason is that basically the receive interrupt handling does quite a bit of work or can do quite a bit of work. So let me talk a little bit about it. In the particular case that actually where it does quite a bit of work is for example ARP.<br>奇怪的是，你们中的一些人发现，如果你使用锁，实际上会引起恐慌。所以让我说一下，因为发生恐慌的原因有点是因为在XV 6内核的E1中实际上有一个软件结构。你可能会想稍微复杂一些。原因是基本上接收中断处理做了相当多的工作，或者可以做相当多的工作。让我稍微谈谈这个问题。在特定情况下，它实际上做了相当多的工作，例如ARP。</p>
<p>发言人   31:16<br>Requests? So art is one of those packet types that Robert talked about a little while ago. But basically what happens, like interrupt comes in. So an Arf request for to discover what the e-net address is for an IP address comes in, you know, that will call, you know, E1 thousand receive. And you know, we’ll call whatever net Rx. So that will go call into the network stack on the previous picture so that receive calls, calls into this code over here, net retrieve, you know, calls the. Which of courses net Rx? Up. And it looks, you know, there’s an AR packet and basically sends back, you know, even at the dress 340 this particular.<br>请求？所以艺术是罗伯特刚才谈到的那些包装类型之一。但基本上发生了什么，就像中断进来了。因此，一个Arf请求来发现IP地址的电子网络地址是什么，你知道，它将调用，你知道，E1千接收。你知道，我们称之为网络Rx。这样就会调入上一张图片上的网络堆栈中，以便接收调用，调用到这里的代码中，网络检索，你知道的，调用。哪些课程属于net Rx？上。看起来，你知道，有一个AR数据包，基本上发回来，你知道，即使在这个特定的裙子上。</p>
<p>发言人   32:23<br>For X 3, 6. And the way it does that, of course, to send the packet, it will call, you know, eat 1000. Transmit? And we know that will actually need to acquire a lock. All of you did that. You know, whenever there’s the E1 thousandth lock.<br>对于X 3，6。当然，它这样做的方式是发送包裹，它会打电话，你知道，吃1000。传输？我们知道这实际上需要获取一个锁。你们都这样做了。你知道的，每当有第一千分之一锁时。</p>
<p>发言人   32:50<br>And the reason that it actually has to walk is because there might be multiple senders. And, you know, the senders should not trip over a trip over each other. So that’s sort of the picture.<br>它实际上必须行走的原因是因为可能有多个发送者。而且，你知道，发送者不应该在彼此的旅行中绊倒。这就是这样的情况。</p>
<p>发言人   33:02<br>And so what we’re basically, in terms of this previous picture, what we’re seeing here is that the bottom half may end up, you know, called coding the top half, and then come back into the driver through the top half. And a number of, you know, you run into trouble with that because, you know. 100% clear that you didn’t need locks in the receiving part quantum. And you run into this particular bug where you actually acquired. The E1 files lock. In re. And that worked all fine, correct? Except that once in a while you got to panic. And why do you get the panic? Hopefully with this picture, that’s pretty clear.<br>所以基本上，就之前的图片而言，我们在这里看到的是下半部分可能最终被称为编码上半部分，然后通过上半部分回到驱动程序中。而且有一些，你知道，你会遇到麻烦，因为，你知道。100% 清除您不需要在接收部分量子中锁定。并且你在实际获取的地方遇到了这个特定的错误。E1文件锁定。在re中。而且效果很好，对吗？除了偶尔你会恐慌。为什么你会感到恐慌？希望通过这张照片，这很清楚。</p>
<p>发言人   33:59<br>I mean, isn’t it going to be the same lock that E1 thousand transmit is going to try to acquire down the stack? Yeah, exactly correct. So E 5000 here at this point now almost lock holds, it calls net Rx, calls net RXR. Then even if I was to transmit, then it calls a car again. And as you might remember from previous labs, if a chor is called and is already held, that’s a deadlock, and so the XV 6 kernel penix.<br>我的意思是，这不就是E1千传输试图从堆栈中获取的锁吗？是的，完全正确。所以这里的e5000现在几乎被锁持有，它调用net Rx，调用net RXR。那么即使我要进行传输，它也会再次呼叫汽车。你可能还记得，在之前的实验中，如果调用chor并且已经持有，那就是死锁，所以XV 6内核penix。</p>
<p>发言人   34:28<br>A question, let’s assume you had a slightly different implementation of log such that those pads are not a carer. Like let’s assume like if I wanted to acquire a lot that already nothing happened. Yeah, so these are, these are were called recursive locks. Or re-entering blocks? There is another way named for them. And so if you have recursive locks or re-entering blocks, then you know you could freely do this and it would be no problem. And I think one of you over email mentioned to me that actually they implemented recursive lock to actually deal with this particular problem. And so they acquired the locks in the year 1000 Re function.<br>一个问题，让我们假设您对日志的实现略有不同，使得那些垫不是照顾者。就像让我们假设如果我想获得很多东西，而现在什么都没有发生。是的，这些被称为递归锁。还是重新进入街区？还有另一种方式来命名它们。因此，如果您有递归锁或重新进入块，那么您知道您可以自由地执行此操作，并且没有问题。我想你们中的一个通过电子邮件向我提到，实际上他们实现了递归锁定来实际处理这个特定的问题。因此，他们在1000年重新获得了锁的功能。</p>
<p>发言人   35:12<br>And half the dependent basically fixed acquiring lease in Xg 6 production and support recursive flux and review solution. Simple solution. It’s a fine solution. The solution that we intended and the staff solution has is that basically it just doesn’t require locks in chief at all because it’s actually turned out not to be necessary.<br>一半的依赖基本固定了Xg 6生产中的获取租赁，并支持递归通量和审查解决方案。简单的解决方案。这是一个很好的解决方案。我们预期的解决方案和员工解决方案基本上根本不需要锁定，因为实际上它不是必要的。</p>
<p>发言人   35:40<br>Sorry, can you say again why there can 2 threads in receive? There’s only one thread that receive the interrupt handler runs. There’s only one receive function ever running at the time on any core that actually calls into the top half of the top half of the operating system and that calls back out into the bottom half, or sorry, not in the bottom. That calls back into the transmit. And transmit definitely meets the Cho lock. So even receive E1 thousand receive while holding the lock calls E1 thousand transmit, which tries to acquire the same lock that the interrupt handler in holds if you have if you walked in the chief handler. I see so. So it is the case that like one interrupt can go off and then while it’s still running, another interrupt could go off as well.<br>抱歉，你能再说一遍为什么接收中可以有2个线程吗？只有一个线程接收中断处理程序运行。在任何核心上，只有一个接收功能在当时运行，它实际上调用到操作系统上半部分的上半部分，并且调用回操作系统的下半部分，或者抱歉，不是在底部。呼叫返回到传输。传输肯定符合Cho锁。所以即使在保持锁调用的同时接收E1千发送，它尝试获取与中断处理程序保持相同的锁，如果您在主处理程序中行走。我看到了。因此，在这种情况下，一个中断可能会中断，当它仍在运行时，另一个中断也可能会中断。</p>
<p>发言人   36:39<br>Is no, no, no, no, no, the picture maybe go back to this picture.<br>不，这张照片可能会回到这张照片。</p>
<p>发言人   36:43<br>So interrupt happens that calls the receive function. There’s only one receive function running. That receive function calls, you know rx net receive that calls Rx net ARP, and then that ARP function calls transmit. And if you were using the same lock in transmit and receive, you would get a deadlock. Okay, I see, thank you. And that’s what, okay. And so basically the two solutions to this one is to use recursion FX. Other solution was no locks in receive or, you know, have two locks. All three of them are totally reasonable solutions.<br>所以发生中断时会调用接收函数。只有一个接收功能在运行。接收函数调用的函数，您知道rx net receive调用Rx net ARP，然后ARP函数调用transmit。如果您在传输和接收中使用相同的锁，则会出现死锁。好的，我明白了，谢谢。这就是，好的。因此，基本上有两种解决方案，即使用递归FX。另一个解决方案是在接收中没有锁，或者你知道，有两个锁。这三个都是完全合理的解决方案。</p>
<p>发言人   37:37<br>Any questions about this? Would there be a reason to have a lock around receive at all? No, there’s in this particular case, there’s no reason to have luck at all.<br>对此有什么问题吗？有理由在接收周围设置锁吗？不，在这种特殊情况下，根本没有理由运气。</p>
<p>发言人   37:49<br>What would be, could, could we think of a situation where you would want a receive lock? Would it be like if you had two network hearts or something? Yeah, if you remember in UART code.<br>什么是，我们能否想到一个你想要接收锁的情况？如果你有两颗社交网络的心，会是这样吗？是的，如果你还记得在UART代码中。</p>
<p>发言人   38:06<br>The common reason why you might want to have the locking shared is because the bottom half in the top half share data structures. So for example, the receive and the transmit might manipulate the same shared data structure. At that point, you need, you need a walk. And so for example, you remember from the console driver, they shared the queue. And so there hendler needed to get a queue, needed to get the lock to actually get access to that queue. Does that then answer your question? Thanks, and so this brings me up with a second sort of point that I wanted to make that.<br>您可能希望共享锁定的常见原因是，上半部分的下半部分共享数据结构。例如，接收和发送可能操纵相同的共享数据结构。在那个时候，你需要，你需要散步。例如，你记得在控制台驱动程序中，他们共享队列。因此，hendler需要获取队列，需要获取锁才能实际访问该队列。那么这能回答你的问题吗？谢谢，这给我带来了我想提出的第二点。</p>
<p>发言人   38:51<br>Let me actually draw a new picture because it gets a little bit crowded. So think about the bottom half again, in the top half. Here’s the bottom. Is it a little bit abstract? But, you know, it may helpful?<br>让我画一幅新画，因为它有点拥挤。所以再想想下半部分，在上半部分。这是底部。这有点抽象吗？但是，你知道，这可能会有帮助？</p>
<p>发言人   39:07<br>In much typically in muhoho or driver chauffer, the bottom half basically doesn’t even really call in the top half at all. So for example, if you go back and you look at the console code, this sequence of this sequence can not happen there. The reason doesn’t happen is because the bottom half, typically there’s very little work. The only thing it does maybe is grab the packet, stick the packet in a Cub. And then at some point later, you know. The top half, you know, there’s a separate Fred in the top half that basically looks at that queue and then grabs packets out of the queue and then keeps on doing whatever needs to be done.<br>在muhoho或司机chauffer中，下半部分基本上甚至根本没有真正呼叫上半部分。因此，例如，如果您返回并查看控制台代码，此序列的此序列在那里不会发生。没有发生的原因是因为下半部分通常几乎没有什么工作。它唯一可能做的事情就是抓住小包，把小包放在幼崽里。然后在某个时候，你知道的。上半部分，你知道，上半部分有一个单独的Fred，基本上看着那个队列，然后从队列中抓取数据包，然后继续做任何需要做的事情。</p>
<p>发言人   39:46<br>Now in this for simplicitate in the reduced the amount of code, that is not the structure that this particular driver follows. This driver once in a while may actually call up in at co-op. Actually, sometimes this structure is followed by the driver, but once in a while it can actually go into the top half and come back out into the bottom half.<br>现在为了简化代码量的减少，这不是这个特定驱动程序遵循的结构。这个驱动程序可能偶尔会在合作社打电话。实际上，有时这个结构后面跟着驱动程序，但偶尔它可能会进入上半部分，再回到下半部分。</p>
<p>发言人   40:15<br>Any questions about this?<br>对此有什么问题吗？</p>
<p>发言人   40:23<br>Okay, so that’s sort of, I guess, software concurrency. And we’ll come back to it more later. If we look at the code in a little bit more detail and talk a little bit about the rings. And so basically, you know, the way to think about it, you know, there’s a ring, two rings, you know, one for receiving and one for sending.<br>好的，我猜这就是软件并发。我们稍后会再回来讨论它。如果我们更详细地查看代码并稍微谈论一下环。所以基本上，你知道，思考这个问题的方式，你知道，有一个戒指，两个戒指，你知道，一个用于接收，一个用于发送。</p>
<p>发言人   40:47<br>TX Rx both lift in Ram and you know, they’re manipulated by, you know, code running on the risk five course and by, you know, the network card itself. So there has to be some protocol between the network card and the risk five course about, you know, who gets a look at what. And so the way, and this is a very common organization in hardware devices, the way that typically is done, you know, there’s sort of like, let’s look at the transmit queue. There’s basically a queue or some fixed size structure descriptors as we will look in a second. These are the descriptors. And the organization or the coordination that is actually that’s happening between the driver and the network card is in the consumer producer.<br>TX Rx都在内存中提升，你知道，它们被风险五课程上运行的代码和网卡本身操纵。所以网卡和风险五课程之间必须有一些协议，关于谁能看到什么。因此，这是硬件设备中非常常见的组织方式，通常是这样做的，你知道，有点像，让我们看看传输队列。基本上有一个队列或一些固定大小的结构描述符，我们稍后会看到。这些是描述符。而组织或协调实际上是在驾驶员和网卡之间发生的，是在消费者生产者中。</p>
<p>发言人   41:45<br>Coordination and basically, you know, one way to think about it, you know, there is a, if it is the transmit cube, you know, there’s maybe there’s a head pointer.<br>协调，基本上，你知道，有一个思考它的方法，你知道，如果它是传输立方体，你知道，可能有一个头部指针。</p>
<p>发言人   41:56<br>There’s a tail pointer. And you know, the tail pointer is controlled by the software. And so the software looks at the tail pointer. And if it wants to send another packet, you know, it sticks it, you know, in the ring at the location of t plus 1, and then moves up in the tail pointed in that direction. And the head pointer is basically controlled by the hardware. So tail by software, head by hardware, basically the, you know, the hardware basically looks at the head. And this is the first packet that is going to be sent, you know, and there’s a little bit of information in the descriptor or enough information in the descriptor for the network card to look at it and say like, oh, this is the bytes that I need to, move on to the cable. And once it’s done, you know, it moves the head pointer in that direction.<br>有一个尾部指针。而且你知道，尾部指针是由软件控制的。因此，软件会查看尾部指针。如果它想发送另一个包，你知道，它会把它粘在t加1位置的环中，然后沿着那个方向向上移动。头部指针基本上是由硬件控制的。所以软件的尾巴，硬件的头部，基本上，你知道，硬件基本上看着头部。这是要发送的第一个数据包，描述符中有一点点信息，或者描述符中有足够的信息让网卡可以查看并说，哦，这是我需要的字节，转向电缆。一旦完成，你知道，它会将头部指针向那个方向移动。</p>
<p>发言人   42:49<br>Once it’s consumed, you know, one of the packets out of the transmission cube, and one way to think about it is that all the descriptors between here, you know, between the tail and so all the things that are actually being filled in, so like the tails moved up, maybe be through here.<br>一旦它被消耗掉，你知道，传输立方体中的一个数据包，有一种思考它的方式是，所有在这里之间的描述符，你知道，在尾部和所有实际被填充的东西之间，就像尾部向上移动一样，可能是通过这里。</p>
<p>发言人   43:12<br>You all the packets that are all the descriptor entries that are actually filled in, the way you think about them is they’re sort of owned by the hardware or owned by the network cart. The network card is allowed to read them, you know, do things with them, but the software and the software is not allowed to do anything with that. If the software would be scribbling over these descriptors while they really sort of owned orre by network cart, that would change the data, the network car seats. And so that would be pretty undesirable.<br>您所拥有的所有数据包都是实际填充的描述符条目，您考虑它们的方式是，它们在某种程度上属于硬件或属于网络购物车。网卡被允许读取它们，你知道，用它们做事情，但软件和软件不允许用它们做任何事情。如果软件在这些描述符上涂写，而它们实际上有点被网络购物车所拥有，那将改变数据，网络汽车座椅。所以这将是相当不可取的。</p>
<p>发言人   43:45<br>And so the protocol basically is that like once you know, the software moves the tail pointer 1 up, then you know that point, you know what? I just moved into the network queue and the transmission queue is now owned by the hardware and it will stick in, you know, will be owned by the Hartford It O tool, you know, that has to be sent. And basically the head pointer move past to that particular structure. Does that make sense?<br>因此，协议基本上是这样的，就像一旦你知道了，软件将尾部指针向上移动1，然后你就知道了那个点，你知道吗？我刚刚进入了网络队列，传输队列现在归硬件所有，它会一直存在，你知道，将归哈特福德it O工具所有，你知道，它必须被发送。基本上，头指针会移动到那个特定的结构。感知了吗？</p>
<p>发言人   44:19<br>For the transmission, basically, it’s the same story. You know, there’s a, you know, there’s a head pointer, you know, that’s. That’s controlled by the hardware. And there’s a tail pointer that is controlled by sort of software pointer and the patient, the packets in between. Are the packets that actually? Have been received by the hardware? And you know, by inspecting the tail pointer, the software can see if there’s actually a new packet, you know, that is ready to be consumed. And if it’s ready to be consumed, the heart will indicate that by showing that DD bit in the status field. And so when the DD bit is set, you know, the hard software see are good.<br>对于传输，基本上是相同的故事。你知道，有一个，你知道，有一个头部指针，你知道，那就是。这是由硬件控制的。还有一个尾部指针，由软件指针和患者之间的数据包控制。这些数据包实际上是这样的吗？硬件已经收到了吗？你知道，通过检查尾部指针，软件可以查看是否真的有一个新的数据包，你知道，它已经准备好被消费了。如果它已准备好被消费，心脏将通过在状态字段中显示该DD位来指示。所以当DD位被设置时，你知道，硬件软件是好的。</p>
<p>发言人   45:06<br>You know this packets, you know, the hardware is done with it. And so it can take it out and move the tail pointer 1 up. And so there’s sort of this give and take between the driver and our hardware to actually coordinate that they don’t trip over each other.<br>你知道这个数据包，你知道硬件已经完成了。因此它可以把它取出来并向上移动尾部指针1。因此，司机和我们的硬件之间存在一种相互协调的互动，以确保它们不会相互绊倒。</p>
<p>发言人   45:27<br>Any questions about the? Rings? Is this like, is this like a universal way to kind of implement like hues or any kind of communication between two things that have shared memory? Yeah, there’s a pretty certainly also in software QC, but many hardware devices play this sort of trick where there’s sort of producer, consumer style, a coordination between the hardware so.<br>有什么问题吗？戒指？这是一种通用的方式来实现颜色或任何类型的两个共享记忆的事物之间的通信吗？是的，软件质量控制也是相当肯定的，但是许多硬件设备都在玩这种把戏，其中有生产者，消费者的风格，硬件之间的协调。</p>
<p>发言人   46:05<br>So, yeah, it was a very common structure. Maybe, maybe one or two questions that we can ask about it. Like, why is there actually even a queue? Why is there a ring? The reason there’s a incorrect because the Q cue wraps around is to make it fix sites. Why not have cue 1 entry, one entry?<br>是的，这是一种非常常见的结构。也许，也许我们可以问一两个问题。比如，为什么实际上会有一个队列？为什么会有戒指？出现错误的原因是因为Q cue包装是为了修复网站。为什么没有提示1条目，一个条目？</p>
<p>发言人   46:27<br>Like almost like the UART, if you remember the UART driver and controller, it’s basically only one register, you know, to send the byte, and there’s another register to receive a byte. And so why have, you know, why go with this complicated scheme if you could have just have a single register? And then you could basically say, you know, hardware, this register is now ready, send it. And then you just wait until the it’s done.<br>就像几乎像UART一样，如果你还记得UART驱动程序和控制器，基本上只有一个寄存器来发送字节，还有另一个寄存器来接收字节。那么，如果你只有一个寄存器，为什么要采用这个复杂的方案呢？然后你可以基本上说，你知道的，硬件，这个寄存器现在准备好了，发送它。然后你只需等到它完成。</p>
<p>发言人   46:55<br>To allow for when there are bursts of packets. Yeah, exactly.<br>以允许发生数据包突发时。是的，没错。</p>
<p>发言人   47:03<br>You know, the network interface or the network card cable is pretty high performance. In fact, very high performance, correct? Gigabits per second. And so it can be hard for the core, the processor, to actually keep up with it. So you would like to give it a whole bunch of packets. You know, the network, so the network card can chunk along and all send them out at high speed. And similarly, you know, in the reception, you might get a burst of packets coming in and you usually want to place them into queue, and then the operating system can start them processing into queue. All right? And so this is a common. This is the reason that these queues are common.<br>你知道，网络接口或网卡电缆的性能相当高。实际上，性能非常高，对吗？每秒千兆比特。因此，处理器的核心可能很难跟上它的发展。所以你想给它一大堆的包。你知道，网络，因此网卡可以分块并以高速发送它们。同样地，你知道，在接收时，你可能会收到大量数据包，你通常想将它们放入队列中，然后操作系统可以开始将它们处理到队列中。一切都好吗？所以这是常见的。这就是这些队列普遍存在的原因。</p>
<p>发言人   47:44<br>To handle birth? What happens if the Q is full, like under reception?<br>处理出生？如果Q已满，像接收不足一样会发生什么？</p>
<p>发言人   47:59<br>I think the document mentioned that it does some form of a drop tail scheme.<br>我认为该文件提到它做了某种形式的落尾方案。</p>
<p>发言人   48:07<br>Yeah, basically the packs get dropped. So any future incoming packets, if the queue is full, the packets, there’s no room anymore, and they’re wrong. The network card can’t do anything that’s correct. And so the only the option to actually has is to basically delete the packet or not add it to the ring, and therefore it disappears. And so one reason the packet loss sometimes is that an operating system is overloaded. You know, we packet can’t keep up and the ring fills, and then, you know, the packets get dropped. Now, higher level software, of course, may, like a TCP connection, might retransmit those backups. But this is one reason why packets can get dropped.<br>是的，基本上背包掉了。因此，如果将来传入的数据包队列已满，那么这些数据包就没有空间了，它们就错了。网卡不能做任何正确的事情。因此，唯一的选择实际上是基本上删除数据包或不将其添加到环，因此它会消失。所以有时数据包丢失的一个原因是操作系统过载。你知道，我们的数据包无法跟上，环填满了，然后，你知道，数据包被丢弃了。当然，更高级别的软件可能像TCP连接一样重新传输那些备份。但这就是数据包可能被丢弃的原因之一。</p>
<p>发言人   48:52<br>So even if the hardware sort of works all perfectly fine, you know, because of these burstiness, you know, it can happen. The packet section might get dropped. So you had a really, really big burst.<br>因此，即使硬件工作得非常好，你知道，由于这些爆裂，它也可能发生。数据包部分可能会丢失。所以你有一个非常非常大的爆发。</p>
<p>发言人   49:07<br>The head and tail pointers, they’re all software abstractions, right of the cue. Okay? So these are actually, turns out that those are these control registers, right? So there’s control registers for the hardware. We head pointer control register for the, basically, you know, detail pointer, you know, there’s no real distinction between hardware shop. Basically the driver knows about the tail pointer and it knows about the hardware-store tail pointer and head pointer. And these are basic controller that, right?<br>头部和尾部指针，它们都是软件抽象，就在暗示的右边。好吗？这些实际上是控制寄存器，对吧？所以有硬件的控制寄存器。我们是指针控制注册表的负责人，基本上，你知道细节指针，你知道硬件商店之间没有真正的区别。基本上驱动程序知道尾部指针，并且知道硬件存储尾部指针和头部指针。这些是基本的控制器，对吧？</p>
<p>发言人   49:38<br>Okay, and we’ll see the code in second, how that shows up. We could go back to our maybe, let’s see if I have this picture still here, here’s the earlier picture that we looked at and here’s controller register that holds the head. Here’s the controller register that holds the tail. And of course, there’s one for both reception and one for sending.<br>好的，我们将在第二步看到代码，看看它是如何显示的。我们可以回到我们的也许，让我们看看这张照片是否还在这里，这是我们之前看过的照片，这里是持有头部的控制器寄存器。这是保存尾部的控制器寄存器。当然，有一个用于接收和一个用于发送。</p>
<p>发言人   50:04<br>Okay? Let’s go back here. Okay, so let’s talk a little bit about the descriptors. And so the descriptor are defined by the hardware. And so the hardware says like, here’s how descriptor should look like. And you driver, you know, these are the bit you can fill in, and if you fill in that bit, that tells me the following. And so here’s the two descriptors are important. You know, here’s the. Receive descriptor Rx, and here’s the TX, one of the TX descriptors. So let’s look a little bit.<br>好吗？让我们回到这里。好的，让我们谈谈描述符。因此，描述符由硬件定义。所以硬件说，描述符应该是这样的。你的司机，你知道，这些是你可以填写的部分，如果你填写了那个部分，那就告诉我以下内容。所以这里有两个重要的描述符。你知道，这就是。接收描述符Rx，这是TX，其中一个TX描述符。让我们看一下。</p>
<p>发言人   50:49<br>Probably the most important, important part is this address. And that is the address that the software filled in to say like where they should, where the car should dump in the packet, you know, where in Ram? Driver Where should the network card put the data that it receives into Ram? So it’s the address or the reception buffer, if you will. And then you probably the most important part in is the stages field, as you’ve seen. So when the driver basically still continues to look sort of at the tail and sees that there’s a new packet has been received, and the way it tells whether there’s a new package we received is that the DD bit correct is set by the hardware and, you know, the shaded areas or the fields of the packet descriptor. Descriptor that actually the hardware fills in and the white, you know, the non shade ones are the fields that are actually shaded are filled in by the software.<br>可能最重要、最重要的部分是这个地址。这是软件填写的地址，用于说明应该在哪里，汽车应该在哪里倾倒，你知道，在内存中应该在哪里？驱动程序网卡应该把它接收到的数据放在哪里？所以它是地址或接收缓冲区，如果你愿意的话。然后你可能最重要的部分是阶段领域，正如你所看到的。因此，当驱动程序基本上仍然继续查看尾部并看到收到了一个新包时，它告诉我们是否收到了新包的方式是由硬件设置的DD位正确，数据包描述符的阴影区域或字段。实际上硬件填充的描述符和白色的非阴影字段是由软件填充的实际阴影字段。</p>
<p>发言人   51:57<br>Again, here we see this clear distinction about some things are owned by shop. Some things are owned by. The hardware? Okay, and there’s a similar, you know, descriptor, very similar descriptor that Luke, that’s the hardware scriptor for the transmission. It has an address. And that address, of course, is the address where the data is in memory that needs to be sent. And then it has a bunch of, you know, it has a command field.<br>再一次，在这里我们看到了一些东西被商店拥有的明显区别。有些东西是属于自己的。硬件？好的，还有一个类似的，你知道的，描述符，非常类似于Luke的描述符，那是传输的硬件脚本。它有一个地址。当然，这个地址就是内存中需要发送数据的地址。然后它有一堆，你知道，它有一个命令字段。</p>
<p>发言人   52:29<br>And here’s how the software tells the driver, tells the network art, this is what you should do with this particular packet. Or, you know, this is what you should know about this particular packet. And so one thing we, I think we fill in two pack, 2 things. We fill the AEO that says you the end of packet, and that basically tells the driver this is the last descriptor of a particular packet. And now it can, you know, send off, you know, whatever data that’s in these descriptors. And I think we set the. Response requested. Command bit or Rs, I think it is. They basically tells the network card when you’re done transmitting this thing, you know the.<br>这就是软件如何告诉司机，告诉网络艺术，这就是你应该对这个特定数据包做的事情。或者，你知道，这就是你应该知道的关于这个特定包的事情。所以有一件事我们，我想我们要填写两包，两件事。我们填写了表示您是数据包结尾的AEO，这基本上告诉驱动程序这是特定数据包的最后一个描述符。现在它可以，你知道，发送，你知道，这些描述符中的任何数据。我认为我们已经设定了。要求答复。命令位或Rs，我想是这样。它们基本上告诉网卡当你完成传输这个东西时，你知道的。</p>
<p>发言人   53:18<br>So the bit that it actually has been transmitted, we’ll see in a second how that shows up, any questions?<br>因此，它实际上已经传输的位，我们将在一秒钟内看到它是如何显示的，有问题吗？</p>
<p>发言人   53:32<br>So one thing to keep in mind, you know, with the structure, these are defined by the hardware, right? Like so the software has no control over their structure, you know, is literally defined by the hardware or by the network card.<br>所以有一件事需要记住，你知道，关于结构，这些是由硬件定义的，对吧？像这样的软件无法控制它们的结构，你知道，字面上是由硬件或网卡定义的。</p>
<p>发言人   53:45<br>Okay, let’s look at a little bit of code and see what the solution looks like. And we’ll look at a couple issues that we haven’t looked at yet. You know, the end buffs sort of issues and during transmission and issues during receiving. And this would be presumably all well familiar with to you, given the fact that I could just finished the lab.<br>好的，让我们看一些代码，看看解决方案是什么样的。我们将研究一些我们还没有研究过的问题。你知道，最终爱好者会在传输和接收期间出现问题。考虑到我刚刚完成了实验室，这大概对你来说都很熟悉。</p>
<p>发言人   54:08<br>Okay, so here, just to go to the top, here’s the transmitter ring. And that’s basically the ring of descriptors that we drew off in the last couple slides. There’s a separate, you know, we talked briefly about this, there’s a separate basically ring of Em buffs, but that ring is completely a software or driver only abstraction. Harper, this is defined by this structure, is defined by the Harper, correct? And if you look at OS.<br>好的，所以在这里，回到顶部，这是发射器环。这基本上就是我们在最后几张幻灯片中画出的描述符环。有一个单独的，你知道，我们简要地谈到了这个，有一个单独的基本上是Em爱好者的戒指，但这个戒指完全是一个软件或驱动程序的抽象。哈珀，这是由这个结构定义的，是由哈珀定义的，对吗？如果你看操作系统。</p>
<p>发言人   55:02<br>You look at the definition square here is to struct TX desk, and that corresponds the C version of exactly to the structure that actually was defined by the hardware, the 64 b address, you know, the length field, the CEO byte, the command byte, the status byte, the c.c.s. byte, you know, to a word for special. And there’s a similar ring that is literally defined by the hardware or similar descriptor received descriptors as defined by hardware. And we just have C decorations corresponding to these hardware structures.<br>你看这里的定义方块是struct TX desk，这对应于C版本与实际由硬件定义的结构，64 b地址，长度字段，首席执行官字节，命令字节，状态字节，c。c。s。 字节，你知道的，变成一个特殊的词。并且有一个类似的环，字面上是由硬件定义的或类似的描述符接收到的描述符是由硬件定义的。我们只有与这些硬件结构相对应的C装饰。</p>
<p>发言人   55:35<br>Okay, let’s look at transmit. So mirrors, that’s the sort of staff solution for transmit. Acquires a lock? And the reason we asked, we said before that it needed a lock is because multiple functions or multiple frets, kernel frets, might call transmit at the same time.<br>好的，我们来看看传输。所以镜子，这是传输人员的解决方案。获得一把锁？我们问的原因是，我们之前说过它需要锁，因为多个函数或多个烦恼，内核烦恼，可能同时调用传输。</p>
<p>发言人   55:53<br>And then it looks at the tail, you know, to see if there’s any, if there’s room to actually send a new packet because, you know, the network car might got behind and all the descriptors actually are being in use. So the way it checks where actually the descriptor is in use is by checking whether the DD bit, is that set? And if it is set then? If it’s not set, then it returns immediately, not sending the packet at all, and in any other case keeps all on going.<br>然后它会观察尾部，你知道，看看是否有空间发送一个新的数据包，因为你知道，网络汽车可能会落后，所有的描述符实际上都在使用中。所以它检查描述符实际使用位置的方法是检查是否设置了DD位？如果它被设置了呢？如果未设置，则立即返回，根本不发送数据包，在任何其他情况下都继续进行。</p>
<p>发言人   56:34<br>And actually we’ll the end buff. So if there’s still an M buff in this position in TX M buff, that this is an M buff for a while back, you know, we free that M buff because we’re going to actually stick in a new M buff into this descriptor. And we just need to remember which you Mbo, we stuck in that descriptor. And so the way we do that is by keeping that in the TX M buff. And then we fill in the descriptor in.<br>实际上，我们将成为最终的爱好者。因此，如果在TX M buff的这个位置上仍然有一个M buff，那么这是一段时间以前的M buff，你知道，我们释放了那个M buff，因为我们实际上会在这个描述符中加入一个新的M buff。我们只需要记住你的Mbo，我们卡在那个描述符中。所以我们做到这一点的方法是将其保持在TX M buff中。然后我们填写描述符。</p>
<p>发言人   57:02<br>So the first thing we can fill in is the head. And we fill in, we put in the address, the start of the first header in the embos and then put the length, set the status to 0, put the command field in place by sending both the r.s. and the EOP did as we discussed in second.<br>所以我们可以填写的第一件事是头部。我们填写并输入地址，即实施例中第一个头的开头，然后输入长度，将状态设置为0，通过发送两个r.s来将命令字段放置到位。 EOP做的正如我们在第二部分讨论的那样。</p>
<p>发言人   57:26<br>And then basically, we synchronized to make X, ensure that there’s no reordering of, you know, that all these instructions were performed before the next instruction. And what the next instruction does, it actually updates the tail pointer. And so the updates the tail pointer in the tail pointer, right, is a controller register in the network cart. And so basically, when we update the tail pointer, the network cart knows, aha, something changed. And it’s going to read, you know, the data at that descriptor. And it’s going to basically read that these fields will just fill.<br>然后基本上，我们同步到X，确保没有重新排序，你知道，所有这些指令都在下一条指令之前执行。以及下一条指令所做的事情，它实际上最新进展尾指针。因此，尾部指针最新进展的是右侧的尾部指针，是网络购物车中的控制器寄存器。基本上，当我们更新尾部指针时，网络车知道，啊哈，有些事情发生了变化。它将读取，你知道，描述符处的数据。它基本上会读取这些字段将填充的内容。</p>
<p>发言人   58:00<br>So we got to basically make absolutely sure that all these, you know, rights, all these stores are materialized in memory before the network card actually reached them. And so this is why the thing synchronizes there. And then we release about a lot.<br>所以我们必须基本上确保所有这些，你知道的，权利，所有这些存储在网卡实际到达它们之前在内存中实现。这就是为什么那里的东西同步的原因。然后我们发布了很多。</p>
<p>发言人   58:14<br>And that’s basically all we have to do, you know, transmit a packet. Can you explain the Syn synchronize again? Like what? Yeah, it’s mostly a memory ordering technicality, correct?<br>这基本上就是我们所要做的，你知道的，传输一个数据包。你能再次解释一下同步同步吗？像什么？是的，这主要是内存排序的技术性问题，对吗？</p>
<p>发言人   58:30<br>Like compilers are free to reorder instructions, The writes might actually sit in the L 1 cache or the L 1 2 cache. And basically this synchronizes sort of a memory fence that tells the hardware and the compiler, please don’t move any instructions across this barrier and make sure that all the data that, you know, all the stores before this barrier are actually actually materialized in ramp.<br>就像编译器可以自由地重新排序指令一样，写入可能实际上位于L 1缓存或L 1 2缓存中。基本上，这同步了一种内存栅栏，它告诉硬件和编译器，请不要越过这个屏障移动任何指令，并确保在此屏障之前所有存储的数据实际上都在斜坡上实现。</p>
<p>发言人   58:58<br>And the reason that is important is because, you know, go back to our picture from a little while ago. All the way back here, actually, both, you know, the risk five course that in the driver code, you know, basically put values here in rent, correct? You know, those values are first in the L 1 cache and the L 2 cache and the memory flush and the intru stuff that actually show up in the Ram. This is important because as soon as we update the tail pointer, E1 thousand is going to look into Ram for these two descriptors. And we’ve got to make sure that all the fields are indeed set, otherwise would reach state values. Does that make sense? Yep, thank you. So why do embos exist?<br>这很重要的原因是因为，你知道，回到我们不久前的照片。一直回到这里，实际上，你知道，风险五当然，在驱动程序代码中，你知道，基本上把价值放在租金中，对吗？你知道，这些值首先在L 1缓存和L 2缓存以及内存刷新和实际上显示在Ram中的intru内容中。这很重要，因为一旦我们更新尾指针，E1千就会查看这两个描述符的内存。我们必须确保所有字段确实设置，否则将达到状态值。感知了吗？是的，谢谢。那么，为什么存在体现呢？</p>
<p>发言人   01:00:00<br>Why have these sort of separate structure of, you know, why have these two sort of corresponding structures? So I guess part of it is it’s all nice and well, if the driver needs to talk to the hardware about where things are. But at the end of the day, we do need to store the packet to hand off to the network stack somehow. Yeah, exactly, you know, so the one way to think about it is that you, the M buffs, are completely in OS extraction, nothing to do with really the network card at all. And it is there because like, you know, if at some point, you know, the maybe we receive a packet, you know, we hand it off to the network stack and the network stack sticks in some queue so that when later a user process calls read, you know, that actually can read. In the meantime, we need to have some structure that sort of holds that data that we actually received. And that’s exactly what those m-box structures are.<br>为什么会有这些独立的结构，你知道，为什么会有这两种相应的结构？所以我想部分原因是，如果司机需要与硬件谈论事情的位置，一切都很好。但最终，我们确实需要存储数据包以某种方式移交给网络堆栈。是的，确切地说，你知道的，所以思考这个问题的一种方法是，你们这些M爱好者，完全处于操作系统提取阶段，与真正的网卡没有任何关系。它在那里是因为，你知道，如果在某个时候，你知道，也许我们收到了一个数据包，你知道，我们将它交给网络堆栈，网络堆栈粘在某个队列中，以便以后用户进程调用读取，你知道，实际上可以阅读。与此同时，我们需要有某种结构来容纳我们实际收到的数据。而这正是那些m-box结构。</p>
<p>发言人   01:01:01<br>Sorry, can you talk about the like, how do you use the link list structure in your code? Because I was trying to understand it and to track it down. And it seems like there is some push tail or push head, but I don’t ever call it in my code. Oh, maybe it might be in the net DOC file when the network C files are filed and we gave you together, yeah?<br>抱歉，你能谈谈如何在代码中使用链接列表结构吗？因为我试图理解并追踪它。而且似乎有一些推尾巴或推头，但我从来没有在我的代码中调用过它。也许它可能在net DOC文件归档时出现，我们把你放在一起，是吗？</p>
<p>发言人   01:01:39<br>And where you’re thinking, if you look for something like Paul Pop, I think pop. Yeah, so this is, this is the only place where it looks like it does things with the linked list structure of MB. And if you don’t ever call this function or the pushta, you basically just treat the M buff as an array of like, how many characters? So, so why is m above there? Because here.<br>你在想什么，如果你寻找像保罗·波普这样的东西，我认为是波普。是的，这是唯一一个看起来像用MB的链表结构做事的地方。如果你从来没有调用这个函数或pushta，基本上你只是把M buff当作一个像数组一样的字符来处理，有多少个字符？那么，为什么上面还有m呢？因为这里。</p>
<p>发言人   01:02:26<br>When you receive a UDP packet, so the UDP packet comes in from the network card, it goes into the network stack, then the UDP packet, the M buff for that UDP that holds that UDP packets, it’s actually stuck in the queue right here on the socket for the receiver. And so this is the reason that you can have queues with M buffs. And the reason it’s stuck in the queue there, correct, is because who knows? Know the usual process that’s going to read know from this particular shock-cut you might be doing something else and at some point later you, it’s going to call the reed system call. And then the reed system call is going to remove you that the MBA from that socket. And so the point of each socket can have a list of M buffs for reception.<br>当您收到一个UDP数据包时，UDP数据包从网卡进来，进入网络堆栈，然后是UDP数据包，即容纳UDP数据包的UDP的M buff，它实际上卡在接收方套接字上的队列中。因此，这就是您可以使用M buff队列的原因。而它被卡在队列中的原因，正确的，是因为谁知道呢？知道通常的过程，这将从这个特定的震惊中读取，知道你可能正在做其他事情，稍后你会调用里德系统调用。然后，reed系统调用将从该套接字中删除MBA。因此，每个套接字的点可以有一个用于接收的M个buff列表。</p>
<p>发言人   01:03:22<br>I see, thank you. Okay, let’s go back to the driver. So that transmit. So then receive, you know, almost similar, not that much different.<br>我明白了，谢谢。好的，我们回到司机那里。所以传输。所以然后接收，你知道的，几乎相似，没有太大的不同。</p>
<p>发言人   01:03:38<br>You know, basically you read the tail pointer from the network cart. You see if there actually is a packet. And if there’s a packet, then the DD field would be set. If the DD field is not set, then we know there’s no packet, and so we’re done. If it is set, then we’re going to read it. And read the link, you know? And when we and then we call and that Rx know to do up call into the higher level stack. And when we’re done, you know, we’re basically free up, you know, that entry so that the driver can use it to actually receive more packets in it.<br>你知道，基本上你从网络购物车中读取尾部指针。你看看是否真的有一个包。如果有一个数据包，那么DD字段将被设置。如果DD字段未设置，那么我们知道没有数据包，所以我们完成了。如果它被设置好，那么我们将阅读它。阅读链接，你知道吗？当我们然后我们调用并且Rx知道要做什么时，就会调用到更高级别的堆栈中。当我们完成后，你知道，我们基本上释放了那个入口，这样司机就可以使用它来实际接收更多的数据包。</p>
<p>发言人   01:04:23<br>And the real crucial operation there is, correct, When we bump up basically the tail, you know, to tell the driver, okay, you know, we’re done with it. You can use it again, You know, it’s yours again. That’s what? And so maybe the most interesting question is, and the number of key questions you asked is, why is the wild there?<br>真正关键的操作是，当我们基本上撞上尾部时，你知道，告诉司机，好的，你知道，我们已经完成了。你可以再次使用它，你知道，它再次属于你。那是什么？所以也许最有趣的问题是，你问的关键问题的数量是，为什么那里有野生动物？</p>
<p>发言人   01:04:45<br>P this in a loop? And don’t you get an interrupt? And then, you know, you grab the one packet, then you’ll be done.<br>P这个在一个循环中？难道你没有被打断吗？然后，你知道，你拿起那一包，然后你就完成了。</p>
<p>发言人   01:04:50<br>Or like a number of people that actually forgot the while loop first, you know, notice that basically at some point you don’t receive packets anymore during that tests. Is it because you would like to transmit as many packets that are ready as possible with only one interrupt so that you can kind of amortize the cost of the interrupt? Yeah, this is absolutely part of it.<br>或者像一些实际上忘记了while循环的人一样，你知道，请注意，在测试期间，基本上在某些时候你不再收到数据包了。这是因为您希望在只有一个中断的情况下传输尽可能多的准备好的数据包，以便您可以分摊中断的成本吗？是的，这绝对是其中的一部分。</p>
<p>发言人   01:05:15<br>You know, you get to the let’s first talk about the root cause is right. If the number, the burst of packets comes in and the network card will generate, you know, the interrupt, but more packets are coming in, and so it will just put them in the free descriptors that it actually can use. It can generate more interrupts because it’s already generated interrupt. And at some point, you know, you know, whatever the processor, you know, maybe like we were, the core was just in the section of code that turned off interrupts because it was doing something atomic. So at the end of it, you know, there’s a release from some lock that actually turns interruption on it. And that point in time, then basically the receive handler is the interrupt handler is going to run, but between the period when like that first packet comes in and before we receive handler runs, there, a whole bunch of other packets might have come, have, could have come in. And so we don’t run in the while loop.<br>你知道，让我们先谈谈根本原因是正确的。如果数据包的突发数量进来，网卡会产生中断，但是会有更多的数据包进来，因此它会将它们放入实际可以使用的自由描述符中。它可以生成更多的中断，因为它已经生成了中断。在某个时候，你知道，你知道，不管处理器是什么，你知道，也许像我们一样，核心只是在关闭中断的代码部分，因为它正在做一些原子的事情。所以在结束时，你知道，有些锁会释放，实际上会中断它。在那个时间点，基本上接收处理程序就是中断处理程序将要运行，但是在第一个数据包进入和我们接收处理程序运行之前的时间段之间，可能会有一大堆其他数据包进入。所以我们不会在while循环中运行。</p>
<p>发言人   01:06:10<br>We’ll leave those packets, we’ll grab the first one, and we’ll grab in the later ones. They’re stick there in the queue, right? They’re just sitting there in that ring. Now, if a subsequent interrupt would come in, we’ll grab the next one.<br>我们会留下这些数据包，我们会抓取第一个数据包，然后抓取后面的数据包。他们会一直排队，对吧？他们只是坐在那个戒指里。现在，如果后续中断进来，我们将抓住下一个。</p>
<p>发言人   01:06:24<br>But like the tests, you know what they do? They can run the udb packets. So they send out a whole bunch, like one of the tests since like 10 ping request in parallel, you know, the 10 responses come in parallel back, you know, correct, the first one receives, generates an interrupt, the other 9 go into the queue. The higher level of software, you know, reach the first one and then, you know, returns just like it’s done. And at that point, nothing happens anymore because the receiver is waiting for more receive packets, they happen to be there.<br>但是就像这些测试一样，你知道它们是做什么的吗？他们可以运行udb数据包。所以他们发送了一大堆，就像其中一个测试一样，因为像10个ping请求并行，你知道，10个响应并行回来，你知道，正确的，第一个接收，生成一个中断，其他9个进入队列。更高级别的软件，你知道，达到第一个，然后，你知道，回报就像它完成的一样。此时，什么也没有发生，因为接收方正在等待更多的接收数据包，它们恰好在那里。</p>
<p>发言人   01:06:57<br>They’re saying in the ring except you know, you they received didn’t do them in a while loop and so they didn’t pick them up. Doesn’t that make sense?<br>他们在擂台上说，除了你知道，他们收到的你并没有在一段时间内完成，所以他们没有接他们。这不是很感知吗？</p>
<p>发言人   01:07:13<br>So for example, if the test programs would have sent one request, waited for response, one request, waited for response, then you would never notice that you need to do the while loop. And it is because like there’s a burst of responses might come back and then only generate together one interrupt. Any questions about that? I have a question. So for example, if instead of while one, we would have a for loop that just goes through the whole cub, that would also be wrong for the same reason?<br>例如，如果测试程序发送了一个请求，等待响应，一个请求等待响应，那么你永远不会注意到你需要执行while循环。这是因为像有一个突发的响应可能会回来，然后只生成一个中断。有什么问题吗？我有一个问题。因此，例如，如果我们有一个遍历整个幼崽的for循环，而不是while 1，那么出于同样的原因，这也是错误的？</p>
<p>发言人   01:07:50<br>No, as long as we skip all the ones that have the DD nots yet. Okay, well, only look at packets that actually we should only look at the table. But in principle, you could scan the whole queue and I guess look at the DD packet and let it see if the DD bit is set. And that might work. I don’t know, I haven’t tried that.<br>不，只要我们跳过所有尚未有DD结的。好的，只看数据包，实际上我们应该只看表格。但原则上，您可以扫描整个队列，我猜会查看DD数据包，让它查看是否设置了DD位。这可能会奏效。我不知道，我还没有尝试过。</p>
<p>发言人   01:08:14<br>Okay, but isn’t the device able to put more M buffs in the receive after we read Sta? Yes, yeah. Okay? And we have to.<br>好的，但是在我们阅读完Sta之后，这个设备难道不能在接收中放入更多的buff吗？是的，是的。好吗？我们必须这样做。</p>
<p>发言人   01:08:42<br>It’s very dangerous, like this proposal of like sort of looping around and you seeing the Db be the same because you we should do, we should not look at buffers that really are controlled by the driver or by the hardware. Only look at buffers that are actually available to us, to the software, which is indicated by the DD bit, and basically by looking at the tail pointer. Because basically anything owned between the tail and the head is owned by the hardware. Going back to the MBF, like the reason we need the MBF, why do we need the other information in the buffer, like the care array? I think it’s called the backing store. I think it’s in net dot h.<br>这非常危险，就像这个循环的提议一样，你看到数据库是一样的，因为我们应该这样做，我们不应该看真正由驱动程序或硬件控制的缓冲区。只看我们实际可用的缓冲区，软件，由DD位表示，基本上通过查看尾部指针。因为基本上，尾巴和头部之间的任何东西都归硬件所有。回到MBF，就像我们需要MBF的原因一样，为什么我们需要缓冲区中的其他信息，比如care数组？我认为它被称为后备商店。我想它在net.h中。</p>
<p>发言人   01:09:40<br>So we need the buff field, correct? Because it actually contains the data. I thought the head contained a pointer to the data. Yeah, okay. But the buff actually is actually allocate space, you know, the whole packets, correct? And then head points into buff to basically the start of the packet.<br>所以我们需要buff字段，对吗？因为它实际上包含了数据。我认为头部包含一个指向数据的指针。是的，好的。但是buff实际上是分配空间，你知道，整个包，对吗？然后头部指向buff，基本上就是数据包的开始。</p>
<p>发言人   01:10:01<br>Okay? And this is okay. So a little bit more context here. And buff is a structure that you see in a lot of network stacks. So you look in the Linux kernel, you’ll see structure similar like this. And it’s typically, and so we have to, we could have simplified the structure quite a bit if we wanted to. And maybe in subsequent years we should. But this is sort of the standard way in which packets are represented in operating system kernels.<br>好吗？这没关系。所以这里有更多的背景。和buff是您在许多网络堆栈中看到的结构。所以你看看Linux内核，你会看到类似这样的结构。它通常是这样的，所以我们必须这样做，如果我们想要的话，我们可以大大简化结构。也许在随后的几年里，我们应该。但这是在操作系统内核中表示数据包的标准方式。</p>
<p>发言人   01:10:39<br>Okay, any further questions about this?<br>好的，还有其他问题吗？</p>
<p>发言人   01:10:50<br>So I have a choice. Now, there’s a couple more things that I could say about the network driver, but then I won’t have any time to talk about N map. I could also talk a little bit about M map and stop here in terms of talking the network driver. Any preferences?<br>所以我有一个选择。现在，还有一些关于网络驱动程序的事情我可以说，但是我没有时间谈论N map。我也可以稍微谈一下M map，并在此停止谈论网络驱动程序。任何优惠？</p>
<p>发言人   01:11:24<br>No preferences.<br>没有偏好。</p>
<p>发言人   01:11:31<br>Let me talk a little bit about Nmap, because there was a question that came up a couple times we were addressing. It’s almost more a question about why m-map exists, then you know, actually how to implement it. So there’s no real objections, which is science revision. Let me talk a little bit more about M map. So this is your last chance to ask any questions about the network driver until the end of class.<br>让我谈谈Nmap，因为有一个问题我们已经讨论过几次了。这几乎是一个关于为什么m-map存在的问题，然后你知道实际上如何实现它。所以没有真正的反对意见，这是科学修正。让我再谈谈M map。所以这是您在课程结束前询问有关网络驱动程序的任何问题的最后机会。</p>
<p>发言人   01:12:06<br>Okay? Let’s say talk about inbox of M map.<br>好吗？假设我们谈论M个地图的收件箱。</p>
<p>发言人   01:12:19<br>Staff? Okay? Okay, so the question really relates to sort of the file system API. The file system has a reasonable broad API, you supporting directories, symbolic links, hard links, etc., etc.. But presumably the main, the main part of it is the file API correcting the API.<br>员工？好吗？好的，所以这个问题实际上与文件系统API的排序有关。文件系统具有合理的广泛的API，您支持目录、符号链接、硬链接等。但大概主要的，它的主要部分是文件API，纠正API。</p>
<p>发言人   01:12:47<br>You know, it’s probably well familiar to you by now, you can open the file. With some from permissions. And once you have opened the file, you know you can read you from the file. Into a buffer, read some data and you can write you through the file. You know, whatever file, script or buff, you know La. So let’s say we, and then we can close the file script.<br>你知道的，现在你可能已经很熟悉了，你可以打开这个文件了。有一些权限。一旦你打开了文件，你就知道你可以从文件中读取你的信息了。写入缓冲区，读取一些数据，然后您可以通过文件写入。你知道的，无论是文件、脚本还是buff，你都知道La。所以假设我们，然后我们可以关闭文件脚本。</p>
<p>发言人   01:13:25<br>Now let’s say we want to write an application and you can think about the, you know, maybe as the file, as the files normally in array of bytes, but like maybe this application has sort of, it’s an array of struct that are stored in it. And let’s say the application wants to update the struct. So you know, we have the file right here, a file, and sort of divide it in, you know, struct scale, whatever, zero to you. Here’s the file length and you know, we maybe like in the middle, you know, let’s restruct 16 B or something. And you know, we want to like update one of these, or maybe you want to update the first one. And so in a way, we could do that correctly. We read and we opened the file. We read, you know, the first, you know, whatever 16 B correspond to this.<br>现在假设我们想要编写一个应用程序，你可以把它看作一个文件，就像文件通常以字节数组的形式一样，但也许这个应用程序有某种，它是存储在其中的结构数组。假设应用程序想要更新结构。所以你知道，我们在这里有一个文件，一个文件，然后把它分成结构规模，无论什么，对你来说都是零。这是文件长度，你知道，我们可能喜欢在中间，你知道，让我们重组16 b或者其他什么。你知道，我们想更新其中一个，或者你想更新第一个。因此，在某种程度上，我们可以正确地做到这一点。我们阅读并打开了文件。我们读到的，你知道的，第一个，你知道的，无论是16 b还是16 b都对应于此。</p>
<p>发言人   01:14:14<br>You know, we, let’s say, update, you know, the first field or struct, the third byte of Dutch truck-transported Then we call right to basically write it back. And then we close the file. So when does it right happens? Where does it actually write?<br>你知道，比如说，我们更新第一个字段或结构，即荷兰卡车运输的第三个字节，然后我们调用right基本上把它写回。然后我们关闭该文件。那么什么时候发生是正确的呢？它实际上写在哪里？</p>
<p>发言人   01:14:41<br>So we have set this memory above the one you know will this first by change to one? If we call, right?<br>所以我们将这个内存设置在你知道的上面，这将首先变成一个吗？如果我们打电话，对吧？</p>
<p>发言人   01:15:08<br>So remember, the file descriptor has an offset she associated with it for. And pushes that offset, you know, forward? In this case, if we had read 16 B, the offset goes from 0 to 16. And so where does right write? As you notice, there’s no offset argument in the right system call. So where does it right? Write le. Bytes and which offset? In the file room, we had land exactly at 16, right? Yes, it will right here. So which, so this byte will change to one, correct? Not the actual thing that we were actually were trying to modify, does that make sense?<br>所以请记住，文件描述符有一个与其关联的偏移量。推动这个偏移，你知道，向前？在这种情况下，如果我们读取了16 B，偏移从0到16。那么，正确的写作在哪里？正如你所注意到的，在正确的系统调用中没有偏移量参数。那么它在哪里正确呢？写吧。字节和偏移量是多少？在档案室里，我们的土地正好是16，对吧？是的，就在这里。所以这个字节会变成1，对吗？这并不是我们试图修改的真实事物，感知吗？</p>
<p>发言人   01:16:02<br>So the way you would written this application, turns out there’s one system call that we didn’t really talk much about at all. But every operating system, unit operating system is a system called called lseq. And LC allows you basically to change the offset to some position. And so in this particular case, we want to do half the effect that we’re going to write this struct and not that one. Then we would have said like, you know LC, you know zero, you know, basically resetting the offset to actually the zero. And so then this right would actually so here now offset the zero and then this right actually, you know, would write actually at the first 16 B, does that make sense?<br>所以你编写这个应用程序的方式，原来有一个系统调用我们并没有真正谈论太多。但是每个操作系统，单元操作系统都是一个叫做lseq的系统。信用证允许您将偏移量更改到某个位置。因此，在这种特殊情况下，我们想要做一半的效果，即我们要编写这个结构而不是那个结构。那么我们会说，你知道信用证，你知道零，你知道，基本上是将偏移量重置为零。那么这个权利实际上会偏移零，然后这个权利实际上会在前16 B处写入，这感知吗？</p>
<p>发言人   01:16:51<br>So this is slightly inconvenient, correct? If you think about this, like you look at this interface, there’s actually quite a bit of stuff going on. You know, you got to open, you got to read it, and then you’re going to seek it, and then you can write it. And so one reason that MMA is popular is you can sort of avoid, you know, these complications because if you would write this using MF, you know, you would do FD is open and we have opened the file as before. And then, you know, we just call m-f.<br>所以这有点不方便，对吗？如果你考虑一下，就像你看这个界面一样，实际上有相当多的事情正在发生。你知道，你必须打开它，你必须阅读它，然后你要寻找它，然后你才能写出来。所以MMA受欢迎的一个原因是你可以避免这些复杂性，因为如果你用MF写这个，你知道，你会做FD是打开的，我们像以前一样打开了文件。然后，你知道的，我们就叫m-f。</p>
<p>发言人   01:17:26<br>It’s going to be like whatever our struct, let’s say our struct age, you know, blah, blah, blah, you know, whatever. Some link for the file, you know, read. Right, permissions, you know, maps shared. And file descriptor comma 0. And then so now, so basically with this dot, correct, we’re in mapping, you know, the file f at the location h, you know, in memory. Now we can just like say h, you know, one of our first byte is 0 or one that we did before. And then, you know, at some point, you know, we can unmap.<br>它就像我们的结构，比如说我们的结构，你懂的，你懂的，随便什么。文件的一些链接，你知道的，阅读。对，权限，你知道的，地图共享。和文件描述符逗号0。然后现在，基本上就是用这个点，正确的，我们在映射，你知道，文件f在位置h，你知道，在内存中。现在我们可以像说h一样，你知道，我们的第一个字节之一是0或者我们之前做的那个字节。然后，你知道，在某个时刻，你知道，我们可以取消地图。</p>
<p>发言人   01:18:16<br>The map? H, right? And so if you think about this, we look in memory where if you get this from perspectives of the file, you know what this do, correct? This because literally did is basically you got a pointer, you know, to this H, and it can just update here, you know, that thing to one and be done with it, right? And so if we sort of need to manipulate file structure, data structure that sit inside of a file, this M map interface is much more convenient than this previous interface where we have to read, manipulate it in memory, you know, when we, you know, shake back and then we actually write the information and in this particular case, you know, we’re really, you can think about the file as being an array of bytes, You know, that we can write willy nnal it without actually having to navigate or jump around. Do people see what the advantage of the Nmap interface is.<br>地图？对吧？因此，如果你思考这个问题，我们会在内存中查看，如果你从文件的角度得到这个，你知道它有什么作用，对吗？因为字面上所做的基本上就是你有一个指针，你知道，指向这个H，它可以在这里更新，你知道，那个东西到一个并完成它，对吧？因此，如果我们需要操作文件内部的文件结构和数据结构，这个M map接口比以前的接口要方便得多，我们必须在内存中读取和操作它，当我们，你知道，然后我们实际上写入信息，在这种特定情况下，你知道，我们真的可以将文件视为一个字节数组，你知道，我们可以随意写入它，而无需实际导航或跳转。人们看到Nmap接口的优点了吗？</p>
<p>发言人   01:19:24<br>Any questions about this? Do any big storage systems? I use this like, I don’t know, like databases, do they use this a lot or not really? They use this a lot here. I think a lot of applications will use MMA because for these kinds of things, like a database is much more convenient.<br>对此有什么问题吗？有没有大型存储系统？我使用这个就像，我不知道，就像数据库一样，他们是否经常使用这个？他们在这里经常使用这个。我认为很多应用程序会使用MMA，因为对于这些类型的事情，数据库更加方便。</p>
<p>发言人   01:19:47<br>Then this interface. This interface is great, correct? If you need to read from standard input and there’s a stream of bytes coming in, you just read, you read, you read, and then you produce some output on some other stream. That interface for that interface is very suitable for here. You don’t have to update offset. You know, you read can offset immediately update, you read again, you read a little bit further, etc., etc.. So it’s really good for sort of the stream oriented inputs. Well, this is really good thing, you know, if the file has sort of the data structure and you just want to sort of update bits and pieces of the file at arbitrary locations.<br>然后是这个界面。这个界面很棒，对吗？如果你需要从标准输入读取，并且有一个字节流进来，你只需读取，你读取，然后在其他流上产生一些输出。那个接口非常适合在这里使用。你不需要更新偏移量。你知道，你阅读可以立即更新，你再读一遍，你再读一点，等等。所以这对于面向流的输入来说真的很好。嗯，这真的是件好事，你知道，如果文件有某种数据结构，而你只想在任意位置更新文件的部分或片段。</p>
<p>发言人   01:20:32<br>Okay? Let’s see, so I’m going to start I I’m about to run out of time, so let me stop here. Hopefully this one sort of tidbit about nmap is useful to know and tells you why, you know, that sort of is a popular scheme. Let’s see, so I think for that actually, you know, were basically we come to the end of this lecture and I guess the end of The end of 6 6 0 0 8 1. And so again, you know, if you have not filled out the feedback survey, you know, please do so. You know, we really appreciate if you fill out the subject evaluation. And again, I want to thank you for your attention.<br>好吗？让我们看看，我要开始了，我的时间快耗尽了，所以让我在这里停下来。希望这一关于nmap的小道消息是有用的，并告诉你为什么，你知道，这种是一种流行的方案。让我们看看，所以我认为实际上，你知道，基本上我们已经到了这节课的结尾，我猜测结尾是6 6 0 8 1。所以，你知道，如果你还没有填写反馈调查，请填写。你知道，如果你填写学科评估，我们真的很感激。再一次，我想感谢您的关注。</p>
<p>发言人   01:21:34<br>Again, it is a strange semester. I wish I could have met you all in person, talk to you in person, either in class or before class or after class. Unfortunately hasn’t happened, but I hope you got quite a bit of out of SOA one, certainly with the staff. Want to thank you for the engagement. You guys have been wonderful this semester. So with that, thank you and if you have any questions, please hang around, but I’m sure some of you have deadlines want to say on behalf of the Tas as well, we’ve really enjoyed all the time we spend with you guys in office hours and doing check-offs.<br>再说一次，这是一个奇怪的学期。我希望我能亲自见到你们所有人，亲自与你们交谈，无论是在课堂上，课前还是课后。不幸的是，还没有发生，但我希望你能从SOA中得到很多，当然还有工作人员。我想感谢您的订婚。你们这个学期表现得非常出色。所以，谢谢你们，如果你们有任何问题，请闲逛，但我确信你们中的一些人也想代表Tas说最后期限，我们真的很享受我们在办公室时间和你们在一起做核对的所有时间。</p>
<p>发言人   01:22:18<br>And this is the first semester where we’ve done check offs. And I think David and I both found it a really enjoyable process. And, you know, hopefully we were able to help you guys out and have some good conversations as well. So thanks for making it a great semester and adjusting on the fly with us with all of the remote learning problems we’ve, you know, run into and had to deal with. It’s been an absolute pleasure to take this course.<br>这是我们进行核对的第一个学期。我认为大卫和我都觉得这是一个非常愉快的过程。而且，你知道，希望我们能够帮助你们并进行一些良好的对话。所以，感谢您让这个学期过得愉快，并与我们一起快速调整我们遇到的所有远程学习问题，您知道，我们必须处理这些问题。参加这门课程绝对是一件乐事。</p>
<p>发言人   01:22:46<br>Any further questions? Or again, feel free to hang around.<br>还有什么问题吗？或者再次，随意闲逛。</p>
<p>发言人   01:23:00<br>Oh, I had a question. So it’s, oh, yeah, thank you so much for the class.<br>哦，我有一个问题。所以，哦，是的，非常感谢你的课。</p>
<p>发言人   01:23:08<br>I really like the class, the best class this semester. I wanted to ask about the interrupts, the receive of interrupts. How does the hardware knows when the software has finished handling the previous interrupt to not issue another one? Because there’s multiple steps. One is you look. You 1000 at the bottom, we Rena interrupts, or we tell the car, you know, we’re ready to receive further interrupts that will tell the car to generate. And interrupts, of course, at this point, interrupts actually not really turn on and we just tells the card you can generate interrupts again, the interrupts get turned on, correct?<br>我真的很喜欢这门课，这是这学期最好的课。我想问一下中断和接收中断的情况。硬件如何知道软件何时完成前一个中断的处理而不发出另一个中断？因为有多个步骤。一个是你看。你1000在底部，我们Rena中断，或者我们告诉汽车，你知道，我们准备接收进一步的中断，告诉汽车生成。当然，在这一点上，中断实际上并没有真正打开，我们只是告诉卡你可以再次生成中断，中断被打开，对吗？</p>
<p>发言人   01:24:00<br>Like, you know, by know these functions interrupt enable. And at that point, if you turn on the interrupter able, if this field is set plus, you know, at the point where you turn on interruption able and actually interrupt might happen again, right? I forgot about this register, thank you so much. Yeah, it’s like one instruction, easy to miss. Any other questions? All right, thank you all, thank you. Thank you, thank you, thank you so much.<br>就像，你知道，通过知道这些功能中断启用。在那一点上，如果你打开中断器，如果这个字段被设置，你知道，在你打开中断器的时候，实际上中断可能会再次发生，对吧？我忘了这个收银机，非常感谢。是的，这就像一个指令，很容易错过。还有什么问题吗？好的，谢谢大家，谢谢。谢谢，谢谢，非常感谢。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>操作系统工程 023-Final QA</div>
      <div>http://example.com/2025/10/18/6S081-023/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月18日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/25/CMU15445%20P10F202309-IndexConcurrencyControl/" title="CMU15445 P10F202309 IndexConcurrencyControl">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CMU15445 P10F202309 IndexConcurrencyControl</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/18/6S081-022/" title="操作系统工程 022-RCU">
                        <span class="hidden-mobile">操作系统工程 022-RCU</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
