

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="发言人   00:00In this video I’m going to start out by telling you some of the shortcomings of a FIFO output queue and some of the problems that it causes. And I’m going to describe two alternatives, swit">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络 039 Packet Switching Strict priporities and guaranteed flow rates">
<meta property="og:url" content="http://example.com/2025/10/19/cs144-039/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="发言人   00:00In this video I’m going to start out by telling you some of the shortcomings of a FIFO output queue and some of the problems that it causes. And I’m going to describe two alternatives, swit">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-19T02:00:38.000Z">
<meta property="article:modified_time" content="2025-10-19T13:35:20.214Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>计算机网络 039 Packet Switching Strict priporities and guaranteed flow rates - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="计算机网络 039 Packet Switching Strict priporities and guaranteed flow rates"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-19 10:00" pubdate>
          2025年10月19日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.6k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          47 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">计算机网络 039 Packet Switching Strict priporities and guaranteed flow rates</h1>
            
            
              <div class="markdown-body">
                
                <p>发言人   00:00<br>In this video I’m going to start out by telling you some of the shortcomings of a FIFO output queue and some of the problems that it causes. And I’m going to describe two alternatives, switches that provide strict priorities to give high priority and low priority traffic, and those that can give a guaranteed rate to each of the flows passing through it.<br>在这个视频中，我将首先告诉你FIFO输出队列的一些缺点以及它引起的一些问题。我将描述两种替代方案，一种是提供严格优先级的开关，以提供高优先级和低优先级的流量，另一种是可以为通过它的每个流提供有保证的速率。</p>
<p>发言人   00:21<br>Let’s start by reviewing what an output CD packet switch looks like. This is an example we saw before where we had three packets arriving. Their addresses will be looked up and they will be switched to the correct output. In this particular case, two red packets, meaning they’ll go to the middle red output and blue 1 to the top. One of the red packets gets to go. The other one is held back, waiting for the link to be free, and then it goes on its way afterwards.<br>让我们先回顾一下输出CD数据包交换机的样子。这是我们之前看到的一个例子，我们有三个数据包到达。他们的地址将被查找并切换到正确的输出。在这种情况下，有两个红包，这意味着它们将被分配到中间的红色输出，蓝色1被分配到顶部。其中一个红包就可以走了。另一个被阻碍，等待链接免费，然后继续前进。</p>
<p>发言人   00:46<br>So implicit here is the assumption that the output queue is a FIFO first in, first out. And that’s a pretty reasonable assumption for most router queues, but in what we’re going to be looking at next, we’re going to be focusing on this output cue and seeing what some of the consequences are of it being a FIFO.<br>这里隐含的假设是输出队列是一个FIFO先入先出的队列。这对于大多数路由器队列来说是一个相当合理的假设，但在我们接下来要看的地方，我们将专注于这个输出提示，并看看它成为FIFO的一些后果是什么。</p>
<p>发言人   01:07<br>So a FIFO Q is sometimes called a free for all cue if there are many packets flowing through this queue coming from the different inputs. So I’ve drawn here 3 inputs to the queue representing the three inputs to the other inputs to the switch. So these are all packets that are coming through that are part of flows that are going to this one output. So we’ll see packets coming out of here, coming from all of those inputs. And presumably at any one time when we have congestion, we’ll see packets cubed up in this FIFO Q If there are many flows passing through, the queue ever sends at the highest rate, whoever sends the most packets, we’ll in fact receive the highest usage of this output link. So in other words, if this one up here is able to get a whole load of packets into here, well, this one down here, this the bottom input is only able to get a small number up here is going to hog this output link. So if there’s a really big hog of a flow going through, a little flow could easily get squeezed out completely.<br>因此，如果有许多来自不同输入的数据包流经此队列，则FIFO Q有时称为 “全部自由” 提示。所以我在这里画了3个输入到队列，代表交换机的其他输入的三个输入。所以这些都是经过的数据包，它们是流向这个输出的流的一部分。所以我们会看到数据包从这里出来，来自所有这些输入。并且大概在任何一个时候，当我们有拥塞时，我们会看到数据包在这个FIFO Q中被立方化，如果有许多流通过，队列以最高速率发送，无论谁发送最多数据包，我们实际上都会收到这个输出链接的最高使用率。换句话说，如果这里的这个能够将整个数据包负载传输到这里，那么在这里的这个，底部输入只能获得一小部分，这会占用这个输出链接。因此，如果有一个非常大的水流通过，那么一个小水流很容易被完全挤出。</p>
<p>发言人   02:10<br>People say that this, this kind of FIFO Q, well, it’s nice and simple, it encourages bad behavior because the best thing for a flow to do is to try and crowd out every other flow by sending as fast as it can. It would be a little bit like when you’re downloading a web page, the thing to do would be to try and get your packets sent towards you at the highest possible rate to maximize the amount of the amount of the queue that you can get. It’s not very friendly behavior, and it doesn’t provide a good incentive for good, good behavior.<br>人们说这种FIFO Q，嗯，它很好而且简单，它鼓励了不良行为，因为对于一个流程来说，最好的做法是通过尽可能快地发送来排挤其他流程。这有点像当你下载网页时，要做的事情是尝试以尽可能高的速率向你发送数据包，以最大化你可以获得的队列数量。这不是非常友好的行为，也不能为良好的行为提供良好的激励。</p>
<p>发言人   02:40<br>Now, imagine that some of the traffic was very urgent. For example, some control traffic. So let’s say we had some urgent red packets here, and then we had some less urgent green packets elsewhere. Maybe there’s another one that squeezed in front of that and a green packet down here and a green packet down here. Maybe let’s just add in another red packet for good measure. So if these ones were more important, what the FIFO Q will do, simply send them out in the order in which they came in. So if we were to number the order in which they arrived, so this was number one, this was number two, this was the third one to arrive, this one was the fourth one, this the fifth one, and the 6 1, they’re obviously just going to go out in that order of 1, 2, 3, 4, 5, 6 on the outgoing line. So not very good for the urgent control traffic or perhaps it’s some important video traffic, So the FIFO doesn’t have any way to distinguish important.<br>现在，想象一下有些流量非常紧急。例如，一些控制流量。所以假设我们在这里有一些紧急的红包，然后在其他地方有一些不那么紧急的绿色包。也许还有另外一个挤在前面，这里是绿色的包，这里是绿色的包，这里是绿色的包。也许让我们再加上一个红包，以便更好地衡量。如果这些更重要，那么FIFO Q会做什么，只需按照它们进来的顺序发送它们。所以如果我们要对他们到达的顺序进行编号，那么这是第一个，这是第二个，这是第三个到达的，这是第四个，这是第五个，还有6个1，很明显，它们只会在传出线路上按照1、2、3、4、5、6的顺序进行输出。所以不太适合紧急控制流量，或者可能是一些重要的视频流量，所以FIFO没有任何方法来区分重要的事情。</p>
<p>发言人   03:36<br>It just says if you got here first and there was room in the queue, you are the most important packet. So we can’t say anything meaningful about the rate of each flow sharing this queue.<br>它只是说，如果你先到这里，队列中有空间，你就是最重要的包。所以我们不能说有关共享此队列的每个流的速率有什么意义。</p>
<p>发言人   03:49<br>One little observation that’s going to prove useful later, and it’s why I’ve labeled this as the size of the queue as B and the rate at which it’s being served, the outgoing link r, notice that if a packet does make it into the queue, so if I have a packet that does make it into the queue, let’s say this one ends up at the tail of the queue, the maximum time it has the weight is B over r, so the delay through that q we know is less than or equal to b over Rs. So we’re going to remember this we’re going to use this observation later in this video I’m going to describe two alternatives to simple FIFO cueing. The first one is called strict priorities where we give higher priority to some flows over others, and the second one is rate guarantees where we give a guaranteed rate or a guaranteed fraction of the outgoing link to each of the flows. So basically, we’re going to take our single FIFO that we had before and replace it with a more complicated mechanism.<br>有一点观察将在以后证明是有用的，这就是为什么我将其标记为队列大小B和被服务的速率，即传出链路r，请注意，如果一个数据包确实进入了队列，因此，如果我有一个数据包确实进入了队列，假设这个数据包最终到达了队列的尾部，它拥有权重的最大时间是B over r，因此通过该q的延迟小于或等于b over Rs。所以我们将记住这一点，我们将在本视频的后面使用这个观察结果，我将描述简单的FIFO提示的两种替代方案。第一个被称为严格优先级，我们给某些流高于其他流的优先级，第二个是速率保证，我们给每个流输出链路的保证速率或保证部分。所以基本上，我们将采用之前的单一FIFO，并用更复杂的机制代替它。</p>
<p>发言人   04:47<br>Here, we’ve simply replaced it with a high priority queue and a low priority queue. So the inputs are just the same as before.<br>在这里，我们简单地将其替换为高优先级队列和低优先级队列。所以输入和以前一样。</p>
<p>发言人   04:54<br>These are where packets arrive from the incoming links. But now as the packet arrives, we’re going to decide whether we’re to place it into the high priority queue or into a low priority queue. And we do this based on bits in the header. So when a packet arrives, it might have a bit in the header. And in IP, there’s a specific field for this. It’s called the type of service field.<br>这些是来自传入链接的数据包到达的地方。但是现在当数据包到达时，我们将决定将其放入高优先级队列还是低优先级队列。我们根据标头中的位来做这件事。因此，当数据包到达时，标头中可能会有一个位。在IP中，有一个特定的字段用于此。这被称为服务领域的类型。</p>
<p>发言人   05:15<br>And we might use that to decide which traffic is high priority and which is low priority. We might do this, for example, to say that video traffic is more important than email. So we might want to put the video in the high priority queue and the in the email in the low priority queue, Or we might say that control traffic is more important than data because we always want to have high priority for the management traffic on the network.<br>我们可以用它来决定哪个流量是高优先级的，哪个是低优先级的。我们可以这样做，例如说视频流量比电子邮件更重要。因此，我们可能希望将视频放在高优先级队列中，将电子邮件放在低优先级队列中，或者我们可以说控制流量比数据更重要，因为我们总是希望网络上的管理流量具有高优先级。</p>
<p>发言人   05:42<br>Or an operator might say that their gold users, that their traffic takes strict preference over their silver customers. And so that’s a way of classifying users and giving preference to those who pay more. The way that this actually works is when the packets arrive. So they would be placed. And I’m going to put the I’m going to put red packets in here, and I’m going to put green packets in here for lower priority.<br>或者运营商可能会说他们的黄金用户，他们的流量对他们的白银客户有严格的偏好。因此，这是一种对用户进行分类并优先考虑支付更多费用的人的方式。这实际上是在数据包到达的时候工作的。这样他们就会被安置。我要在这里放红包，在这里放绿色的包，优先级较低的包。</p>
<p>发言人   06:08<br>The basic discipline is, is this, There’s a scheduler that sits at the output here, and it’s always going to take packets from the high priority if they are prior. And it’s only going to serve the low priority if there’s nothing in the high priority queue. The consequence is that high priority traffic doesn’t see the low priority traffic. It’s unaffected by it because we only serve the low priority queue. If the high priority queue is empty, it’s as if the high priority traffic has its own private network and doesn’t see the low priority traffic at all. This is great for many types of many occasions where we want to give strict preference to another one, but it does run the danger of starving out the low priority traffic. So you can only use it when there’s a reasonably small amount of high priority traffic. We don’t want to completely on the hog the link and starve out this low priority traffic at all, but it is quite widely used and many switches and routers support this capability today.<br>基本的规则是，这里有一个位于输出处的调度器，如果数据包优先，它总是会从高优先级中接收数据包。并且只有在高优先级队列中没有任何内容时，它才会服务于低优先级。结果是高优先级的流量看不到低优先级的流量。它不受它的影响，因为我们只服务于低优先级的队列。如果高优先级队列为空，就好像高优先级流量有自己的私有网络，根本看不到低优先级流量一样。这在我们想要严格优先考虑另一种情况的许多类型的情况下非常好，但它确实存在缺乏低优先级流量的危险。因此，您只能在只有相当少量的高优先级流量时使用它。我们并不想完全控制链路并使低优先级的流量无法使用，但它的使用非常广泛，许多交换机和路由器今天都支持这种功能。</p>
<p>发言人   07:05<br>What if instead of strict priorities, we wanted to have weighted priorities? What I mean by that is if a packet arrives into this queue here and packets arrive into this queue here, I want the in some sense, for the traffic here to be considered to be twice as important as this here. Not not always having strict preference, but having twice as many opportunities to send. More precisely I’m going to say that the rate at which this query served is going to be two over two plus 1. So in other words, 2 is a fraction of the total rate of the egress link. Likewise I’m going to say that the rate that this one is going to be served one, that’s its weight divided by the total weight times the outgoing link rate, okay? That’s what I’m trying to accomplish.<br>如果我们想要加权优先级，而不是严格的优先级呢？我的意思是，如果一个数据包到达这里的队列，而数据包到达这里的队列，我希望在某种感知，这里的流量被认为是这里的两倍重要。并不总是有严格的偏好，但有两倍的发送机会。更确切地说，我将说这个查询的服务速率将是二比二加1。换句话说，2是出口链路总速率的一小部分。同样地，我要说的是，这个服务的速率是它的重量除以总重量乘以出站链接速率，好吗？这就是我想要实现的。</p>
<p>发言人   08:00<br>I can generalize this to many cues as follows. This is simply a just increasing it from two to n, where qi is going to receive w sub I. Bits of service. And that’s the, that’s its weight. So for example, w 1 here will have a rate R 1 is w 1 divided by the sum of all of the weights. I’ll write that as the sum over I of wi times r all the way down to, of course, w sub n, just as before, r of n equals w over n over the sum. I’ll just write it like that times r of the outgoing link.<br>我可以将这一点概括为许多线索，如下所示。这只是简单地将它从2增加到n，其中qi将接收w sub I。服务的碎片。这就是它的重量。例如，这里的w 1将有一个比率，R 1是w 1除以所有权重的总和。我将把它写成I的总和，乘以r，一直到，当然，像以前一样，n的r等于w乘以n的总和。我会把它写成出站链接的r倍。</p>
<p>发言人   08:45<br>If all the packets were of the same length, this would actually be pretty easy.<br>如果所有数据包的长度都相同，这实际上会非常容易。</p>
<p>发言人   08:50<br>We would simply visit each of the queues in turn, and we will call that a round. So one round is when we visited all of the cues in turn. And then we would send W sub I units. So they could be bits or complete packets from each queue in each round. So on the outgoing line, we could have w sub 1 b from here. Then we would have all the way through to w sub n bits from this one, and then all the intervening queues as well. And so this would be around when we’ve visited all of the queues. And you can see that the proportion that each queue has been served in that round is in proportion to the weights, which is exactly what we wanted.<br>我们只需依次访问每个队列，我们就会称之为一轮。所以一轮是我们依次访问所有提示的时候。然后我们会发送W个子单位。因此，它们可以是每一轮中每个队列中的位或完整数据包。因此，在传出线路上，我们可以从这里获得w sub 1 b。然后，我们将从这个一直到w个sub n位，然后是所有的中间队列。因此，当我们访问所有队列时，这就会出现。你可以看到每个队列在那一轮中得到服务的比例与权重成正比，这正是我们想要的。</p>
<p>发言人   09:35<br>So if we could serve the packets as bits at a time and actually send them out as bits at a time, which of course we can’t. But if we could, then this would actually pretty easy to accomplish what we wanted. We would simply classify the packets as they arrive into the queue that they are destined for. And then we would serve those queues according to the W sub I bits in each round, and then send them out.<br>所以如果我们可以一次将数据包作为位发送，实际上一次将它们作为位发送，这当然是我们不能的。但如果我们能做到，那么实际上很容易实现我们想要的。我们只会在数据包到达它们的目的地队列时对其进行分类。然后我们会根据每轮的W sub I位为这些队列提供服务，然后将它们发送出去。</p>
<p>发言人   10:01<br>Of course, packets are variable length and they don’t consist of single bits. And the problem is that real packets vary in size from something like 64 B all the way to, in the case of Ethernet, about 1500 B. There are jumbo frames that are even longer than this. But even even here, we’ve got two orders of magnitude difference in packet size. So if we were to serve this packet by packet instead of bit by bit, it would really mess up the weights and we wouldn’t accomplish what we were trying to do.<br>当然，数据包的长度是可变的，它们不是由单个位组成的。问题是，实际数据包的大小从大约64 B一直到以太网的大约1500 B不等。还有比这更长的巨型帧。但即使在这里，我们在数据包大小上仍有两个数量级的差异。所以，如果我们按分组而不是按位提供这个分组，它会真的弄乱权重，我们无法完成我们想要做的事情。</p>
<p>发言人   10:34<br>Clearly, we must take into account the packet lengths if we want to prevent long packets from creating out the short ones.<br>显然，如果我们想防止长数据包产生短数据包，我们必须考虑数据包的长度。</p>
<p>发言人   10:42<br>So let me describe how we how we do this. I’m going to first describe it in terms of a kind of a thought experiment. I’m going to use this notion of rounds again, where we visit each cue in turn in a round. And then we’re going to send W sub I bits from each query that round. But I’m going to assume that in addition to the queues that I have here, I have another. I’m going to call it a magic cue just to remind us that this isn’t really a cue. It’s just going to be a processing element just to help us think about the problem.<br>让我描述一下我们是如何做到这一点的。我将首先用一种思想实验来描述它。我将再次使用这个轮次的概念，即我们在一个轮次中轮流访问每个球杆。然后我们将从这一轮的每个查询中发送W个sub I位。但我假设除了我在这里的队列之外，我还有另一个。我将称之为魔法提示，只是为了提醒我们这并不是一个真正的提示。这只是一个处理元素，只是为了帮助我们思考问题。</p>
<p>发言人   11:19<br>We’re going to get rid of this in a minute. So in a round, the first q gets to send w sub 1 b, and the last q gets to send w n bits. And what we’re going to do is we’re going to imagine that we’re going to serve each of these queues by that number of bits in each round. And then when we get to an end of packet marker, which is the last bit in the last bit in a packet. So this would be the end of packet here. And then let’s say this is the end of packet here.<br>我们马上就把它处理掉。因此，在一轮中，第一个q发送w sub 1 b，最后一个q发送w n位。我们要做的是想象一下，我们将在每轮中以该位数为每个队列提供服务。然后当我们到达数据包标记的末尾时，即数据包中最后一位的最后一位。所以这将是这里的数据包结束。然后让我们假设这是数据包的结尾。</p>
<p>发言人   11:49<br>Once we’ve got to that end of packet marker, we will construct complete packets and send them on to the outgoing link. So that’s what this magic queue is going to do. It’s going to turn those bit by bit into packet by packet, and so this will be the end of packet bit here. And this is the end of packet bit here.<br>一旦我们到达数据包标记的那一端，我们将构建完整的数据包并将它们发送到出站链路。这就是这个神奇队列将要做的事情。它将把这些比特位变成一个数据包，所以这将是这里的数据包位的结尾。这里是数据包的结尾。</p>
<p>发言人   12:08<br>But this is recognizing that we can’t send them out as bits. We wait until a full packet is accumulated and then send them out. So the question is, in what order should we be sending these out onto the line? When should we send them? Because our goal is to meet the rate guarantees where each Q gets that weighted fair share of the outgoing line. So in what order should we send this packet in order to accomplish that?<br>但这是认识到我们不能将它们作为比特发送出去。我们等待积累完整的数据包，然后将它们发送出去。所以问题是，我们应该以什么顺序将这些发送到线上？我们应该什么时候发送它们？因为我们的目标是满足速率保证，每个Q都获得传出线路的加权公平份额。那么我们应该以什么顺序发送这个数据包来完成这个任务？</p>
<p>发言人   12:35<br>I’m going to describe that next. So just as before, we’re going to assume that time proceeds in rounds, so our unit of time is going to be rounds, and we’re going to figure out if we were to service the packets bit by bit, which round would they have finished in. Okay, so if we were to serve them bit by bit, which round would they have finished in.<br>我接下来会描述这个。因此，和以前一样，我们将假设时间以轮为单位进行，因此我们的时间单位将是轮，并且我们将弄清楚我们是否要一点一点地为数据包提供服务，它们将在哪一轮中完成。好的，如果我们一点一点地为他们服务，他们会完成哪一轮。</p>
<p>发言人   13:04<br>Well I’m going to start by making an observation that will give you a, give you a clue as to how we’re going to use this.<br>好吧，我将从观察开始，给你一个线索，让你知道我们将如何使用它。</p>
<p>发言人   13:10<br>Let’s consider a packet here that’s waiting to go. And let’s consider the round in which it starts. We’ll call that s of k and the round in which it finishes. And we’ll call that f sub k, because we’re serving everything in rounds and time progresses in rounds. We can say the finishing time of this packet, is it starting time in rounds plus the length of the packet divided by w of one. That’s because that first q will receive exactly w sub 1 b of service in each round. So its finishing round is its starting round, plus its length divided by the number of bits it gets served per round. So this is the finishing time here.<br>让我们考虑一个等待离开的包。让我们考虑它开始的那一轮。我们称之为s of k和它结束的回合。我们将其称为f sub k，因为我们以轮次为所有服务，并且时间在轮次中进行。我们可以说这个包的完成时间，是从几轮开始的时间加上包的长度除以w为一。这是因为第一个q将在每轮中准确地获得w sub1 b的服务。所以它的结束轮是它的起始轮，加上它的长度除以每轮服务的位数。所以现在是结束的时间。</p>
<p>发言人   13:56<br>Now let’s think about what happens when a packet arrives. So we’re going to try and calculate the starting time of that packet when it arrives. In other words, what time will it enter service and what time will it finish? Service might be surprising that we can do this, but I’m going to show you a way we can calculate both its starting time and its finishing time when it arrives.<br>现在让我们考虑一下当数据包到达时会发生什么。所以我们将尝试计算数据包到达时的开始时间。换句话说，它什么时候进入服务，什么时候完成？服务可能会让我们感到惊讶，但我将向您展示一种方法，我们可以在它到达时计算它的开始时间和结束时间。</p>
<p>发言人   14:18<br>So the starting time of that packet, the time at which it starts to end a service, it’s going to depend on what’s ahead of it in the queue. So if we’re keeping track of the finishing time of this packet in rounds and we want to know what the starting time of this next packet here and its finishing time, we can do the following calculation.<br>因此，该数据包的开始时间，它开始结束服务的时间，将取决于队列中它前面的内容。因此，如果我们以轮跟踪此数据包的完成时间，并且想知道此处下一个数据包的开始时间和完成时间，我们可以进行以下计算。</p>
<p>发言人   14:40<br>So this is the finishing time of the k -1 packet. It’s the one that’s ahead of it. In Q, we can say that the starting time of the packet k is going to be simply the finishing time of the packet ahead of it, because we’re proceeding in rounds. So it will be immediately entering service as soon as the one ahead of it is finished, unless the queue happens to be empty and there’s nothing ahead of us, in which case it will enter service. Now there’s going to be the max of these two values, the max of the finishing time of the packet ahead of it. And now the second thing that we can say is that the finishing time of k is it’s starting time plus l over w 1, just as before, because we know that’s how much service. So the combination of these two gives us a recursion that so long as we keep calculating the finishing time and keep track of that, we can calculate the starting time and the finishing time of packets as they arrive as a pretty neat property.<br>所以这是k -1数据包的结束时间。它是前面的那个。在Q中，我们可以说包k的开始时间只是前面包的结束时间，因为我们正在进行轮次。因此，一旦前面的队列完成，它将立即进入服务，除非队列恰好是空的，并且我们前面什么都没有，在这种情况下，它将进入服务。现在将有这两个值的最大值，即数据包在其前面的完成时间的最大值。现在我们可以说的第二件事是，k的完成时间是它的开始时间加上l和w1，就像之前一样，因为我们知道这是多少服务。因此，这两者的结合为我们提供了一个递归，只要我们不断计算完成时间并跟踪它，我们就可以计算数据包到达的开始时间和完成时间，这是一个非常整洁的属性。</p>
<p>发言人   15:42<br>And then what we’re going to do is we’re going to service the packets. In other words, we’re going to take the packets from head of line. So here is a scheduler. It’s going to be examining the head of line packets, and it’s going to pick the one with the lowest F, the lowest finishing time. So it’ll pick the packet with the lowest finishing time. So that’s what the scheduler. So we calculated the f of k when the packet came in, and then when it gets to the head of line, it’s competing with all the head of line packets to leave, and the scheduler is simply going to pick the one with the lowest finishing time. This has the nice property that finishing times can be determined when the packet arrives and the packets are served in order of their finishing time, which at least intuitively seems like the best thing to do.<br>然后我们要做的是为数据包提供服务。换句话说，我们将从行首接收数据包。所以这是一个调度器。它将检查线头数据包，并选择F值最低、完成时间最短的数据包。这样它就会挑选完成时间最短的数据包。这就是调度器的作用。因此，当数据包进入时，我们计算k的f，然后当数据包到达行首时，它与所有行首数据包竞争离开，调度器只会选择完成时间最短的那个。这具有很好的特性，即完成时间可以在数据包到达时进行确定，并且数据包按照完成时间的顺序被送达，这至少在直觉上似乎是最好的做法。</p>
<p>发言人   16:26<br>Turns out that it’s more more than just intuitively a good thing to do. I’ll show you why it actually is the right thing to do. If we plot the finishing time of the packets, if they were being served bit by bit, in other words, the time that the end of packet bit would leave on the outgoing line if the packet was being served. But it might look something like this. This is just something I sketched.<br>事实证明，这不仅仅是直觉上的一件好事。我会告诉你为什么这实际上是正确的事情。如果我们绘制数据包的完成时间，如果它们被按位提供，换句话说，如果数据包被提供，数据包末尾位在传出线路上留下的时间。但它可能看起来像这样。这只是我勾画的东西。</p>
<p>发言人   16:52<br>If we look at the finishing time of the packet by packet scheme, where each packet goes and must wait for the packet head of it to finish before it can go on the line, packets could end up actually departing a little bit later because they could be held up by a packet that’s still in service. So there could be a little bit of a delta between when the packet would finish bit by bit.<br>如果我们看每个分组方案的完成时间，每个分组的去哪里，必须等待分组头完成才能上线，数据包最终可能会稍微离开，因为它们可能会被仍在使用的数据包所阻碍。因此，数据包完成的时间可能会有一点增量。</p>
<p>发言人   17:12<br>And we know if it’s bit by bit, then the rate that it will receive q I would receive will be w sub I over the sum of the wj’s In other words, the weight that we’re looking for of the outgoing line. So if this was being met, then we know that would be true in the packet by packet scheme, it can be proved there the difference in the time that it will depart under the packet by packet scheme is no more than L max.<br>并且我们知道如果它是按位的，那么它将收到的速率q I将是w sub I超过wj的总和，换句话说，我们正在寻找的出线的权重。因此，如果满足了这一点，那么我们知道在逐包方案中是正确的，可以证明在逐包方案下它将离开的时间差异不超过L max。</p>
<p>发言人   17:41<br>The maximum length packet divided by R later than under the bit by bit scheme. And that’s true for every single packet in the system. So this is really useful because over a long period of time, this tells us that the same number of bits will have departed as under the bit by bit scheme. They’ll just be jiggled around a little bit. There’ll be a little variance in the actual departure time, but measured over a long period of time. So under this packet by packet, same RF of I will be the same as it was before. So it’ll be that weight of I divided by the sum over a WJ of r, so this will accomplish exactly the rates that we want.<br>最大长度数据包除以R晚于在比特对比特方案下。这适用于系统中的每个数据包。所以这非常有用，因为在很长一段时间内，这告诉我们相同数量的比特将会像在比特方案下那样消失。他们只会被稍微左右移动一下。实际出发时间会有一些差异，但要经过长时间的测量。因此，在这个分组下，相同的I的RF将与之前相同。因此，它将是I的权重除以r的总和，因此这将完全实现我们想要的比率。</p>
<p>发言人   18:25<br>This scheme is often called Wf queue or weighted fair queueing. Weighted fair queueing is a pretty famous technique, you can find lots of references to it, it’s also known as packet by packet generalized processor sharing. But if you look under wfq, you can find lots of references to it. But what it essentially tells us is tells us a specific mechanism for calculating the finishing time of packets and scheduling them so that we can give weighted fairness, weighted usage of the outgoing link and rate guarantees to each of the flows.<br>这个方案通常被称为Wf队列或加权公平队列。加权公平排队是一项非常著名的技术，你可以找到很多对它的参考，它也被称为分组通用处理器共享。但如果你看看wfq下面，你会发现很多关于它的参考资料。但它基本上告诉我们的是告诉我们一种特定的机制，用于计算数据包的完成时间并调度它们，以便我们可以为每个流提供加权的公平性、加权的使用情况和速率保证。</p>
<p>发言人   18:59<br>In summary FIFO QS are a bit of a free for all. They have no priorities, no guaranteed rates, and there’s an incentive A for a flow to send as many packets as it can into the queue so that it maximizes its share of the outgoing link. So they kind of encourage band behavior. So instead, it’s quite common to use strict priorities.<br>总之，FIFO QS对所有人来说都有点自由。它们没有优先级，也没有保证速率，并且有一个激励流将尽可能多的数据包发送到队列，以便最大化其对外链接的份额。所以他们有点鼓励乐队行为。因此，使用严格优先级是很常见的。</p>
<p>发言人   19:19<br>High priority traffic could see or experience a network with which appears to have no low priority traffic at all. It’s unaffected by it. This is useful if we have limited amounts of high priority traffic, like control traffic in the network. But if we want to do something that is more of a weighted priority, then we need to use something like weighted for queueing, which letsie give each flow a guaranteed service. And we do that by scheduling the packets in order of their bit by bit finishing times. That’s the end of the video.<br>高优先级的流量可以看到或体验到一个似乎根本没有低优先级流量的网络。它不受其影响。如果我们的高优先级流量数量有限，比如网络中的控制流量，这将很有用。但是如果我们想做一些更具有加权优先级的事情，那么我们需要使用加权队列之类的东西，这样就可以为每个流提供保证的服务。我们通过按数据包的完成时间顺序安排数据包来做到这一点。视频到此结束。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>计算机网络 039 Packet Switching Strict priporities and guaranteed flow rates</div>
      <div>http://example.com/2025/10/19/cs144-039/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/19/cs144-040/" title="计算机网络 040 Packet Switching Guaranteed Delay">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">计算机网络 040 Packet Switching Guaranteed Delay</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/19/cs144-038/" title="计算机网络 038 Principles Packet Switching How a packet switch works(2)">
                        <span class="hidden-mobile">计算机网络 038 Principles Packet Switching How a packet switch works(2)</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
