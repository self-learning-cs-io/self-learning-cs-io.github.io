

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="发言人   00:00In this video I’m going to continue the description of packet switching and in particular I’m going to tell you about how we can guarantee delays from one end of a network to another. This">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络 040 Packet Switching Guaranteed Delay">
<meta property="og:url" content="http://example.com/2025/10/19/cs144-040/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="发言人   00:00In this video I’m going to continue the description of packet switching and in particular I’m going to tell you about how we can guarantee delays from one end of a network to another. This">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-19T02:00:39.000Z">
<meta property="article:modified_time" content="2025-10-19T13:41:21.600Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>计算机网络 040 Packet Switching Guaranteed Delay - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="计算机网络 040 Packet Switching Guaranteed Delay"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-19 10:00" pubdate>
          2025年10月19日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.7k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          48 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">计算机网络 040 Packet Switching Guaranteed Delay</h1>
            
            
              <div class="markdown-body">
                
                <p>发言人   00:00<br>In this video I’m going to continue the description of packet switching and in particular I’m going to tell you about how we can guarantee delays from one end of a network to another. This may come as a bit of a surprise because in earlier videos I was telling you about how the queueing delay is variable and so we generally can not control the delay through the network. But we’re going to use special techniques that rely on the weighted fair queueing that we learned in the rate guarantee video. So you should make sure you watch that one first.<br>在这个视频中，我将继续描述分组交换，特别是我将告诉你如何保证从网络的一端到另一端的延迟。这可能有点令人惊讶，因为在之前的视频中，我告诉过你排队延迟是可变的，所以我们通常无法通过网络控制延迟。但是我们将使用依赖于我们在速率保证视频中学到的加权公平队列的特殊技术。所以你应该确保你先看那个。</p>
<p>发言人   00:29<br>Let me start with giving you some intuition on how delay guarantees are going to work. So recall our end to end delay equation, which tells us the delay from one end of the network to the other as a function of the packetization delay. That is the fixed component of the packet length divided by the rate plus the propagation delay, which is the length of the link divided by the propagation delay, or the speed of light plus the queueing delay. And the first two terms are defined as fixed, fixed functions of the network. They depend on things under our control.<br>让我先给你一些关于延迟保证将如何运作的直觉。所以回想一下我们的端到端延迟方程，它告诉我们从网络一端到另一端的延迟是分组延迟的函数。它是数据包长度的固定部分除以速率加上传播延迟，后者是链路长度除以传播延迟，或者光速加上排队延迟。前两个术语被定义为网络的固定功能。他们依赖于我们控制下的事物。</p>
<p>发言人   01:08<br>Normally, the queueing delay is not under our control, so if we want to provide an end to end delay guarantee, then we’re going to have to provide a delay for the queue through every router along the path, okay?<br>通常情况下，排队延迟不在我们的控制范围内，因此如果我们想提供端到端的延迟保证，那么我们将不得不通过路径上的每个路由器为队列提供延迟，好吗？</p>
<p>发言人   01:20<br>So the basic idea is if we know the upper bound on Q1, Q2, and Q3, then we know the upper bound of the end to end delay overall from this equation. So how do we do that? So if in a router, I know which queues a packet passes through, and I know the size of the buffer. So let’s say I’m looking at packets that I’m going to go through this queue here inside the router. I know the size of the buffer it’s going to go through, and I know the rate at which that buffer is going to be served. Then I know the maximum delay that a packet can encounter through this router because wfq weighted for queueing that we saw in the in the rate guarantee video gives me a rate R 1. And then I can simply say that the delay through this router will be bounded by the size of the buffer divided by R 1, the rate that it achieved. So and remember that that R 1 equals the weight that I was going to give to that first one divided by the sum of all the weights times r, so I can CRL RR 1, I can pick AB, therefore I can pick the delay through the router.<br>因此，基本思想是，如果我们知道Q1、Q2和Q3的上限，那么我们就知道端到端延迟总体上的上限。那么我们该怎么做呢？所以如果在路由器中，我知道数据包通过哪个队列，也知道缓冲区的大小。假设我正在查看数据包，我将在路由器内穿过这个队列。我知道缓冲区的大小，也知道缓冲区的服务速率。然后我知道数据包通过此路由器可能遇到的最大延迟，因为我们在速率保证视频中看到的wfq加权排队给我的速率为R 1。然后我可以简单地说，通过此路由器的延迟将受缓冲区大小除以R 1的限制，即它达到的速率。所以请记住，r1等于我要给第一个权重除以所有权重的总和R，所以我可以CRL RR 1，我可以选择AB，因此我可以通过路由器选择延迟。</p>
<p>发言人   02:42<br>How do I actually do this in practice? Let’s take a look at that so we can control the delay of the packets from things that we already know, what we already know how to control is the rate at which a query served using wfq and the size of each queue. This suggests a model for a router where we classify the packets as they come in. So this is the arriving packets, and I’m going classify them. I’m going to decide the flow to which they belong, and then I’m gonna stick them into that queue, right? So if they had gone into another Q down here, that might have been possible, which is going to be serviced at that rate R 1, and this one would be at rate RN And then they’re going to come together and go on to the outgoing line of rate r? So if I can set this at the correct rate, I can set the size of the buffer, then I can control the delay.<br>我在实践中是如何做到这一点的？让我们来看看，这样我们就可以控制来自我们已经知道的事物的数据包的延迟，我们已经知道如何控制使用wfq提供查询的速率和每个队列的大小。这为路由器提出了一个模型，我们在数据包进入时对它们进行分类。这是到达的数据包，我要对它们进行分类。我要决定他们属于哪个流程，然后我会把他们放入那个队列，对吗？所以，如果他们在这里进入了另一个Q，这可能是可能的，这将以该速率R 1提供服务，而这一个将以速率RN提供服务，然后他们将聚集在一起，继续到速率r的输出线？所以如果我能将此设置为正确的速率，我就可以设置缓冲区的大小，然后我就可以控制延迟。</p>
<p>发言人   03:37<br>Any packing packet arriving to the router will have a bounded delay. And if we add up all the components of delay correctly using our equation, then we can make it work end to end according to what we know. This works for packets that make it all the way through.<br>任何到达路由器的打包数据包都将有一定的延迟。如果我们使用等式正确地将延迟的所有组成部分相加，那么我们就可以根据我们所知道的来使它端到端地工作。这适用于能够通过所有方式传输的数据包。</p>
<p>发言人   03:51<br>But here’s the problem. What if a packet arrives at such a rate that it overflows the buffer here and falls under the ground, in other words, that we fill up this buffer just because of the arrival process to this queue? So this is really the remaining problem that we have to solve because there’s no point in having an end to end delay guarantee if packets are going to get dropped along the way. That’s not really a delay guarantee. So we need to figure out how we can prevent that buffer from overflowing. And if we can do this, then we’ve solved our overall problem.<br>但问题是。如果一个数据包到达的速率如此之高，以至于它溢出了这里的缓冲区并落在地下，换句话说，我们仅仅因为到达该队列的过程而填满了这个缓冲区？所以这确实是我们必须解决的剩余问题，因为如果数据包在此过程中会被丢弃，则端到端延迟保证是没有意义的。这并不是一个真正的延迟保证。所以我们需要弄清楚如何防止缓冲区溢出。如果我们能做到这一点，那么我们就解决了我们的整体问题。</p>
<p>发言人   04:27<br>So how do we make sure that no packets are dropped? So we’re going to zoom in on one cue and take a look at this.<br>那么我们如何确保没有数据包被丢弃？所以我们要放大一个提示，看看这个。</p>
<p>发言人   04:33<br>And we’re going to go back to something that we saw before, which was our simple deterministic model of the dynamics of a queue. So you’ll remember that we had for a Q like this, we could model it as the cumulative bytes. Cumulative bits or bytes, actually I’ll say bits because it’s going to make it a little easier to explain as a function of time. So this is the time evolution.<br>我们将回到之前看到的东西，即队列动态的简单确定性模型。所以你会记得，对于像这样的Q，我们可以将其建模为累积字节。累积位或字节，实际上我会说位，因为这将使它更容易解释为时间的函数。这就是时间的演变。</p>
<p>发言人   05:01<br>And you remember that we, that we said we have the cumulative arrival process, which might look something like this, and then we’re going to have the cumulative departure process, which is going to be the times at which the queue is empty. We’re going to serve it at some fixed rate, and then it’ll pause until there’s enough accumulated, some accumulate it, and then so on, and then it’ll pause. And so the rate at this point is slightly less than the arrival rate. So here we have A of T, the arrival process, the cumulative arrival process. And here we have d of t, the cumulative departure process.<br>你记得我们说过，我们有累积到达过程，它可能看起来像这样，然后我们将有累积离开过程，这将是队列空着的时间。我们将以固定的费率提供服务，然后它会暂停，直到有足够的积累，有些积累，然后依此类推，然后它会暂停。因此，此时的速率略低于到达率。这里我们有一个T，到达过程，累积到达过程。这里我们有t的d，即累积离开过程。</p>
<p>发言人   05:40<br>And you’ll remember that if we are interested in the delay of individual packets through this query, in this case, individual bits, we take the horizontal distance. This is the time that a bit arrived. This is the time that that bit departed because it’s a FIFO Q that we have. Then the little DT, the delay is simply the horizontal distance and the maximum size of the buffer that we need is the maximum horizontal distance between these two lines, because that’s the maximum distance between what’s arrived and what’s the. So if that vertical distance grows too big, grows to larger than b, so this here is q of t, right? The amount that we have in the q at only one time. If q of t grows to b greater than or equal to b, then we’re going to have packets that are going to get dropped onto the floor. How are we going to make sure that this doesn’t happen?<br>你会记得，如果我们对通过此查询的单个数据包的延迟感兴趣，在这种情况下，单个位，我们采用水平距离。这是有点到来的时间。这是那个位离开的时间，因为它是我们拥有的FIFO Q。那么小DT，延迟只是水平距离，我们需要的缓冲区的最大大小是这两行之间的最大水平距离，因为这是到达的内容和当前内容之间的最大距离。所以如果垂直距离变得太大，会增长到大于b，那么这就是t的q，对吗？我们只有一次在q中的数量。如果t的q增长到b大于或等于b，那么我们将会有数据包被丢弃到地板上。我们如何确保这种情况不会发生？</p>
<p>发言人   06:38<br>This is what we’re going to look at next. And as I said, if we can solve this, then we can provide the delay guarantee through the router that we’re looking for The way that we’re going to approach it is as follows. I’m going to resket-e this deterministic cue model, so this is our I’m going to focus now just on the arrival process.<br>这就是我们接下来要看的。就像我说的，如果我们能解决这个问题，那么我们可以通过路由器提供延迟保证，我们正在寻找的方法如下。我要重新定义这个确定性线索模型，所以这是我们现在要关注的到达过程。</p>
<p>发言人   07:03<br>So this is a cumulative arrival process A of T, it just needs to be non de greasing to be plausible. And we’re going to say that in any time interval. So in any time interval, let’s take a time interval like this. If we can guarantee that no more than b plus r 1 real times t, where t is the time interval, we can say that no more than b plus r 1 times t bits arrive, then the buffer can’t possibly overflow. So this would be over any time interval t, because we know it’s being drained at rate R 1. So R 1 times t will have departed.<br>所以这是一个T的累积到达过程，它只需要不润滑才能合理。我们将在任何时间间隔内这么说。所以在任何时间间隔内，让我们这样取一个时间间隔。如果我们能保证不超过b加上r 1的实际时间t，其中t是时间间隔，我们可以说不超过b加上r 1乘以t位到达，那么缓冲区不可能溢出。所以这将在任何时间间隔t上，因为我们知道它以r1的速率被耗尽。所以R 1次t将已经离开。</p>
<p>发言人   07:52<br>We just need to make sure that we haven’t accumulated more than b in any time interval. So if we make this t any value and we never violate, then we can be sure that we’ve never overflowed the queue. So in other words, a of t? At the time, t plus capital T minus the occupancy or the cumulative arrivals at time, little t is less than or equal to this expression here, b plus R 1 times t? So if we can make sure that this guarantee is met, in other words, this expression defined here is met, then the queue will never overflow. So we know the delay is guaranteed because we’re serving at rate R 1. And we’ve given quite a lot of leeway to the arrival process A of T, we’ve constrained it to make sure that it must fit within this requirement that in this time frame, no more than B plus R 1 t, but we’ve given it some leeway on how it accomplishes this.<br>我们只需要确保在任何时间间隔内我们没有积累超过b。因此，如果我们将此t设置为任何值并且我们从未违反，那么我们可以确保我们从未溢出队列。换句话说，一个t？在当时，t加上大写字母T减去占用率或累计到达次数，小t小于或等于这里的表达式，b加上R乘以t？因此，如果我们能确保满足这个保证，换句话说，满足这里定义的这个表达式，那么队列将永远不会溢出。所以我们知道延迟是有保证的，因为我们以r1的速率提供服务。我们给了相当大的余地给到达过程a的T，我们对它进行了限制，以确保它必须符合这个要求，在这个时间框架内，不超过B加r1t，但我们给了它一些余地，让它如何实现这一点。</p>
<p>发言人   08:59<br>So let’s look at this in a bit more, in a bit more detail. We’re going to constrain the traffic and we’re going to use use a fairly well known technique for doing this, something that’s called sigma r regulation.<br>让我们更详细地看一下这个问题。我们将限制流量，并且我们将使用一种相当知名的技术来做到这一点，这就是sigma r调节。</p>
<p>发言人   09:14<br>I’ll tell you what sigma row is. It’s basically the idea I just told you. So if this blue squiggly line here is our arrival process, our cumulative arrival process A of T I’m going to say that the number of bits that can arrive in any period of length t is bounded plus by sigma plus rho t, so this is just like my b plus rho 1 t equation.<br>我来告诉你什么是sigma行。这基本上就是我刚才告诉你的想法。所以，如果这里的蓝色波状线是我们的到达过程，我们的累积到达过程是A，我要说的是，在任何长度T的周期内可以到达的位数是有界的加上sigma加上rho，所以这就像我的b加rho 1 t方程一样。</p>
<p>发言人   09:37<br>Just now we can think of this as in any time we can draw that sigma plus rho t by this blue line here. And we could start it at any point. And you can see that it’s basically saying that if we touch it down on any point of a, of t, a of t in the future must lie below that line. So wherever we start, wherever we slide this, it must always lie. The A of t must always lie underneath it. If that is true, then this equation holds.<br>刚才我们可以认为，在任何时候，我们都可以通过这条蓝线来画出sigma加上rhot。我们可以在任何时候开始。你可以看到，这基本上是说，如果我们在t的任何一点上触及它，未来t的a必须低于这条线。因此，无论我们从哪里开始，无论我们在哪里滑动，它都必须始终说谎。t的A必须总是在它下面。如果这是真的，那么这个方程成立。</p>
<p>发言人   10:10<br>And we say that A of t is sigma rho regulated. You can see that A of t has quite a lot of leeway on how it fits under that. It just must never exceed it starting from any one point.<br>我们说t的A是sigma rho调节的。你可以看到，t的A在如何适应它下面有相当大的余地。它绝不能从任何一个点开始超过它。</p>
<p>发言人   10:23<br>So in our example, sigma equals b and rho equals r 1. And the only reason I’m telling you about sigma r is that you’ll find it commonly described in textbooks as sigma r regulation. And in our example, I just happen to use B and R 1 for the Q I was looking at.<br>在我们的例子中，sigma等于b，rho等于r 1。我告诉你关于sigma r的唯一原因是，你会发现它通常在教科书中被描述为sigma r监管。在我们的例子中，我只是碰巧使用B和R 1来表示我正在查看的Q。</p>
<p>发言人   10:39<br>Okay, to reiterate this point, then if I’ve got sigma rho constrained arrivals and a minimum service rate, so my minimum service right here is R 1. That’s the rate at which the queue is being served.<br>好的，重申一下这一点，如果我有西格玛限制到达和最低服务费率，那么我这里的最低服务费率是R 1。这就是队列被服务的速率。</p>
<p>发言人   10:52<br>I’ve got a cumulative arrival process here, the green blue line, and then the departure process here, the red line, and I’m going to constrain a of t to always lie below the sigma rho line, the sigma plus RT line. Remember that this constraint must be held for all times wherever I start the sigma plus rot. So if I slide it along, for example, starting here and starting here, it must be true on all of those occasions. But if I do that, then I know that the distance between a of t and d of t is less than the distance between this blue line and d of t, and so therefore, I can constrain both B max. That’s the maximum q occupancy I need to never overflow, and dmax, the maximum delay of any bit through the queue. So in summary, for no packet loss, I need that b is greater than or equal to sigma. And if the rate at which I’m serving is greater than this row, then the delay is less than or equal to B over R 1. So I’ve now bounded the delay based on things that I can control.<br>我在这里有一个累积到达过程，即绿蓝线，然后在这里有一个出发过程，即红线，我将限制t的a始终位于sigma rho线下方，sigma加上RT线。请记住，无论我在哪里开始sigma plus rot，都必须始终保持这个约束。因此，如果我将其滑动，例如，从这里开始，从这里开始，那么在所有这些情况下它都必须是真实的。但是如果我这样做，那么我知道t的a和t的d之间的距离小于这条蓝线和t的d之间的距离，因此，我可以约束两个B max。这是我永远不会溢出的最大q占用率，以及dmax，通过队列的任何位的最大延迟。总之，为了没有丢包，我需要b大于或等于sigma。如果我的服务速率大于此行，则延迟在R 1上小于或等于面向企业。所以我现在已经根据我能控制的事情来限制延迟。</p>
<p>发言人   12:02<br>B and R 1 still doesn’t tell me how I’m going to do this. It just tells me that if I can constrain A of t, then this will all hold. And so what I’m going to tell you next and describe is that if the flows are what we’re going to call leaky bucket constraint, and the routers use weighted for queueing, then end to ender leg guarantees are possible. So what is this leaky bucket constraint? Well, it turns out the leaky bucket is something that implements the sigma R regulator and therefore makes all of this work.<br>B和R 1仍然没有告诉我该怎么做。它只是告诉我，如果我能约束t的A，那么这一切都会成立。所以接下来我要告诉你并描述的是，如果流是我们所说的泄漏桶约束，并且路由器使用加权进行排队，那么端到端的保证是可能的。那么这个漏桶约束是什么？好吧，事实证明，漏桶是实现西格玛调节器的东西，因此使所有这些工作正常。</p>
<p>发言人   12:36<br>Let’s take a look at what that leaky bucket is. So the leaky bucket regulator looks like this.<br>让我们看看那个漏水的桶是什么。所以泄漏的铲斗调节器看起来像这样。</p>
<p>发言人   12:43<br>Packets are going to arrive. So here are my packets arriving here, and they’re going to go into the packet buffer. And the rule is that I can send or I can take packets out of the buffer only if there are enough tokens and the tokens are being are being made available here at a particular rate row. And the token bucket sizes of sigma. So the tokens here are just a scheduling mechanism. The tokens don’t go out onto the wire. This token bucket is just a way of holding and implementing the scheduling mechanism that constrains the traffic. So this is something we’re going to do at the source at A when it’s sending the packets under the strained, we’re going to make sure that they are sigma r constrained.<br>数据包即将到达。这是我的数据包到达这里，它们将进入数据包缓冲区。规则是，只有在有足够的令牌并且令牌在此处以特定速率可用时，我才能从缓冲区中发送或取出数据包。以及西格玛令牌桶的大小。所以这里的代币只是一种调度机制。这些代币不会放到电线上。这个令牌桶只是一种持有和实现限制流量的调度机制的方式。所以这是我们在源头上做的事情，当它在紧张的情况下发送数据包时，我们将确保它们受到sigma r的约束。</p>
<p>发言人   13:24<br>Using the leaky bucket regulator. It can send them onto the wire if and only if there are enough tokens in its bucket. So it’s going to accumulate at rate r with burst in a sigma. In other words, the maximum that it can have in that bucket is sigma. And then it will send a packet if there are sufficient tokens that allow to send a packet of that size. So if the tokens are in bits, then you haven’t have enough tokens to represent the packet that you’re trying to send. And as soon as you send them, then you use up the tokens and you got to wait for more to be put in.<br>使用泄漏的铲斗调节器。当且仅当其存储桶中有足够的令牌时，它才能将它们发送到电线上。因此，它将以r的速率累积，并在西格玛中突发。换句话说，它在那个桶中可以拥有的最大值是sigma。如果有足够的令牌允许发送该大小的数据包，它将发送一个数据包。因此，如果令牌以位为单位，那么您没有足够的令牌来代表您尝试发送的数据包。一旦你发送它们，你就会用光代币，然后你必须等待更多的代币被放入。</p>
<p>发言人   13:58<br>And you can probably see how this will make sure that we’re allowing for bursts of up to sigma. But over on the long term, rate is only a row. And so that will meet the constraint that we want. So putting it all together, then, what have we got?<br>你可能会看到这将如何确保我们允许高达西格玛的爆发。但从长远来看，利率只是一个连续的。这将满足我们想要的限制。所以把它们放在一起，我们得到了什么？</p>
<p>发言人   14:12<br>We have a sigma rho constrained traffic here, So this would be our sigma rho constrained traffic going in that’s coming out of our leaky button at A, each router is going to run wfq weighted for queueing in order to make sure that we get a service rate of R 1 real for that particular flow, a buffer size of at least the B that we need, and that will be at each one. So we’ll have r twos here and b? And along the path, we’re going to take the packets and make sure they’re going into the correct queue that is being serviced at that rate. So we call that packet classification to put it into the correct queue. And then eventually it will find its way. Then we can use our equation for end to end delay in order to calculate the entire delay along the path.<br>我们这里有一个sigma rho约束的流量，所以这将是我们的sigma rho约束的流量，它从我们的泄漏按钮中出来，每个路由器都将运行wfq加权排队，以确保我们针对该特定流获得R 1 real的服务速率，缓冲区大小至少为我们需要的B，并且将在每个缓冲区中。所以我们将在这里和b两次？沿着路径，我们将接收数据包并确保它们进入以该速率服务的正确队列。所以我们称之为数据包分类，将其放入正确的队列中。最终它会找到自己的路。然后我们可以使用端到端延迟的方程式来计算整个路径上的延迟。</p>
<p>发言人   15:12<br>So you may be wondering how these values of sigma and rho and the values of R 1 and B and R2 and B get told to the routers and the source along the way. So there’s a, there’s actually a protocol for doing this, for setting this up initially. And this is something that’s called RSVP or the resource reservation protocol. And there is a ITF RFC that will tell us all about what we’re supposed to do. And it’s number 2, 2, 0 5, you can find this in any textbook, you can go and look at the RFC, or if you look it up in Wikipedia, you’ll find a good description of this.<br>因此，您可能想知道如何将sigma和rho的值以及r1和B的值告知路由器和源。因此，实际上有一个协议用于执行此操作，用于最初设置此操作。这就是所谓的RSVP或资源预留协议。还有一个ITF RFC会告诉我们所有人应该做什么。它是数字2，2，0 5，你可以在任何教科书中找到这个，你可以去看看RFC，或者如果你在维基百科上查找它，你会找到一个很好的描述。</p>
<p>发言人   15:50<br>So this is how we populate these values in the first place, how it is that end to end, the control system is able to install values along the path. So let’s look at a worked example of this now. So imagine that in the network below, we want an application to be able to send at a rate of 10 Mb per second and have an end to end delay of less than 5 milliseconds when it sends thousand byte packets. Now let’s see how we would do that.<br>这就是我们首先填充这些值的方式，就是端到端的方式，控制系统能够沿着路径安装值。现在让我们来看一个可行的例子。想象一下，在下面的网络中，我们希望一个应用程序能够以每秒10 Mb的速率发送，并且在发送千字节数据包时具有小于5毫秒的端到端延迟。现在让我们看看如何做到这一点。</p>
<p>发言人   16:24<br>So first of all, let’s calculate the fixed portion because there’s nothing we can do about the fixed portion of the end to end delay that’s going to be made up by the packetization delay and the propagation delay.<br>首先，让我们计算固定部分，因为我们无法处理端到端延迟的固定部分，这部分将由数据包化延迟和传播延迟来弥补。</p>
<p>发言人   16:35<br>So let’s look at the packetization delay first, packetization delay and when is going to be? Well, it’s the sum of the packetization delay across all of the links. So on the first link I’ve got thousand byte packets that I’m sending, so they are 1000 times 8 b divided by the rate that they’re going to go over the first link, which is a 1 Gb per second. So that’s 10 to the power of 9. And plus, oops, plus I need the same thing for the thousand byte packets going over the 100 mbps, which is 10 to the 8, and then I’m going to have the same thing over here for this. So I’m just going to multiply this by 2 because the last link is the same. And then I’ve got the propagation delay, propagation delay along all of these links, which is going to the.<br>那么让我们先看看打包延迟，打包延迟以及什么时候？嗯，它是所有链路的打包延迟的总和。因此，在第一个链接上，我有千字节的数据包正在发送，因此它们是1000乘以8 b除以它们将通过第一个链接的速率，即每秒1 gb。所以这是10的9次幂。而且，哎呀，再加上我需要同样的东西来处理超过100 mbps的千字节数据包，也就是10的8，然后我将在这里有同样的东西来处理这件事。所以我只是将它乘以2，因为最后一个链接是一样的。然后我得到了传播延迟，传播延迟沿着所有这些链接，它将进入。</p>
<p>发言人   17:42<br>The length of the length, which is 10 km, divided by the rate. So I’ve got 120 km in total, 120 km. So that’s 10 times 10 to the 30 m divided by the propagation speed, which speed, which I’m just going to assume is two times 10 to the 8 m per second. And so if I add these two together I’ve already done that and that comes out as 0.696696 milliseconds.<br>长度，即10千米，除以速率。所以我总共跑了120公里，120公里。所以这是10乘以10的30米除以传播速度，我只是假设传播速度是两乘以10的8米每秒。因此，如果我将这两个相加，我已经完成了，结果为0.696696毫秒。</p>
<p>发言人   18:09<br>So I’ve got a fixed propagation delay of 0.696 milliseconds. And so therefore I need the sum of all the queueing delays along the path to be less than or equal to the difference between that and 5 milliseconds. So that needs to be less than 4.304 milliseconds.<br>所以我的固定传播延迟为0.696毫秒。因此，我需要沿着路径的所有排队延迟的总和小于或等于该值与5毫秒之间的差。因此需要小于4.304毫秒。</p>
<p>发言人   18:29<br>Okay, so we’re going to remember this number because I’m going to clear this, and then we’re going to figure out how to make that work. So let’s choose to split the delay, the queueing delay, equally amongst the two routers. I can actually do this in any way I want. It’s going to make the math easier if I if I split it equally, in other words, it’s going to be just over 2 milliseconds for each one. So let’s clear that. So I’m going to make it so that the lathe through here is less than or equal to 2.1. What is it, 1, 5, 2 milliseconds? And the same thing here. So I’ll just draw that, that’s the same value.<br>好的，我们要记住这个数字，因为我要清除它，然后我们要弄清楚如何使它起作用。所以让我们选择在两个路由器之间平均分配延迟，队列延迟。我实际上可以以任何我想要的方式做到这一点。如果我平均分配它，换句话说，每个分配只需要超过2毫秒，这将使数学更容易。所以让我们明确一下。所以我要做到让这里的车床通过小于或等于2.1。1、5、2毫秒是多少？同样的事情在这里。所以我只画那个，这是相同的值。</p>
<p>发言人   19:14<br>Now I know what the rate is of the flow. It’s 10 Mb per second. So I know the rate at which the queue is going to be serviced. That’s going to be mill 10 Mb per second.<br>现在我知道流量的速率了。它是每秒10兆。所以我知道队列将被服务的速率。这将是每秒10 Mb的磨坊。</p>
<p>发言人   19:24<br>Now I’m trying to figure out how big B should be, how big should the buffer be? So B, the size of the buffer, the buffer in each 1 b needs to be large enough that I never drop anything. And so it’s got to be greater than 10 Mb per second because that’s the rate at which it’s going to be served times the duration of a bit through it.<br>现在我正在试图弄清楚B应该有多大，缓冲区应该有多大？因此，缓冲区的大小，每个1 B中的缓冲区需要足够大，以确保我永远不会丢弃任何东西。因此，它必须大于每秒10 Mb，因为这是它将被服务的速率，乘以一位通过它的持续时间。</p>
<p>发言人   19:47<br>Well, we already know that’s 2.152 milliseconds, okay? And so this ends up as 2, what is it, 21520 b, which is 2006 and 90 B. So I’ve got roughly three packets worth of delay that I must have. So basically what this tells me is using weighted fair queueing, I will serve each of these queues at a rate of 10 Mb per second. I know I need to do that in order for the system to meet this 10 mbps requirement. And I will assign a buffer at each of those routers to be at least point 2690 B at each of those along the path. Then if I add up all of the delays, my overall end to end delay will be less than or equal to 5 milliseconds, which is what I was trying to achieve.<br>我们已经知道那是2.152毫秒，好吗？所以这最终是2，它是什么，21520 b，也就是2006和90 B。所以我大约有三个数据包的延迟值，这是我必须拥有的。所以基本上这告诉我的是使用加权公平队列，我将以每秒10 Mb的速率为每个队列提供服务。我知道我需要这样做才能使系统满足这10 mbps的要求。我将在每个路由器上分配一个缓冲区，至少在路径上的每个路由器上分配一个点2690 B。然后，如果我把所有的延迟加起来，我的整体端到端延迟将小于或等于5毫秒，这就是我试图实现的。</p>
<p>发言人   21:20<br>So in practice, it’s, as I’ve shown you, it’s technically possible to provide this end to end delay, but actually very few networks actually control the end to end delay. In other words, not really used very widely in practice, why is that? Well, it turns out it’s quite complicated. To make it work you, it requires coordination amongst all of the players, all of the, all of the network operators, the end to end the routers along the way. And in practice, this hasn’t really taken off. And in most networks, a combination of over provisioning and priorities of traffic. So giving high priority to those that need special treatment has proved to work well enough in most cases.<br>所以在实践中，正如我向你展示的那样，提供这种端到端延迟在技术上是可行的，但实际上很少有网络真正控制端到端延迟。换句话说，在实践中并不广泛使用，为什么呢？嗯，事实证明这相当复杂。为了让它工作，需要所有参与者、所有网络运营商以及一路上的端到端路由器之间的协调。而在实践中，这并没有真正起飞。在大多数网络中，存在过度配置和优先级流量的组合。因此，在大多数情况下，高度优先考虑需要特殊治疗的人已经证明是有效的。</p>
<p>发言人   22:02<br>I wanted to go through and tell you this because if you can understand how this whole weighted fair curing mechanism works and how we can provide end to end delay guarantees, you understand a lot about the queueing dynamics of a packet switch network. And also, it’s quite likely that some of these ideas will be used in some networks in the future. So they should prove useful to you. And so in summary, if we know the size of a queue and the rate at which it’s being served, then we can, we can bound the delay through it.<br>我想详细介绍一下，因为如果你能理解整个加权公平固化机制是如何工作的，以及我们如何提供端到端的延迟保证，那么你就会对分组交换网络的排队动态有很多了解。而且，这些想法很可能会在未来的某些网络中使用。所以它们应该对你有用。总之，如果我们知道队列的大小和它被服务的速率，那么我们就可以通过它来限制延迟。</p>
<p>发言人   22:32<br>We can pick the size of the queue, and using weighted fair queueing, we can pick the rate at which the queue is served. Therefore, we just need a way to prevent packets from being dropped along the way. For this, we use a leaky bucket regulator, and with that, we can therefore bound the end to end delay. That’s the end of the video.<br>我们可以选择队列的大小，并使用加权公平队列，我们可以选择队列服务的速率。因此，我们只需要一种方法来防止数据包在传输过程中被丢弃。为此，我们使用一个泄漏桶调节器，因此我们可以限制端到端的延迟。视频到此结束。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>计算机网络 040 Packet Switching Guaranteed Delay</div>
      <div>http://example.com/2025/10/19/cs144-040/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/19/cs144-041/" title="计算机网络 041 Packet Switching Guaranteed Delay Example">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">计算机网络 041 Packet Switching Guaranteed Delay Example</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/19/cs144-039/" title="计算机网络 039 Packet Switching Strict priporities and guaranteed flow rates">
                        <span class="hidden-mobile">计算机网络 039 Packet Switching Strict priporities and guaranteed flow rates</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
