

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="100:00:00,000 –&gt; 00:00:07,080Noise and interference can lead to significant bit errors at the physical layer. 200:00:07,080 –&gt; 00:00:12,839In this video, I’ll present forward error correction or">
<meta property="og:type" content="article">
<meta property="og:title" content="CS144 NetworkP1077 11bForwardErrorCorrection">
<meta property="og:url" content="http://example.com/2025/10/23/CS144-networkP1077-11bForwardErrorCorrection/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="100:00:00,000 –&gt; 00:00:07,080Noise and interference can lead to significant bit errors at the physical layer. 200:00:07,080 –&gt; 00:00:12,839In this video, I’ll present forward error correction or">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-23T14:13:16.922Z">
<meta property="article:modified_time" content="2025-10-23T14:13:54.941Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>CS144 NetworkP1077 11bForwardErrorCorrection - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CS144 NetworkP1077 11bForwardErrorCorrection"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-23 22:13" pubdate>
          2025年10月23日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          2.9k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          25 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">CS144 NetworkP1077 11bForwardErrorCorrection</h1>
            
            
              <div class="markdown-body">
                
                <p>1<br>00:00:00,000 –&gt; 00:00:07,080<br>Noise and interference can lead to significant bit errors at the physical layer.</p>
<p>2<br>00:00:07,080 –&gt; 00:00:12,839<br>In this video, I’ll present forward error correction or FEC, a technique that allows the network</p>
<p>3<br>00:00:12,839 –&gt; 00:00:16,160<br>to successfully receive frames that have bit errors in them.</p>
<p>4<br>00:00:16,160 –&gt; 00:00:21,440<br>It’s called forward error correction because the approach assumes that some errors will occur,</p>
<p>5<br>00:00:21,440 –&gt; 00:00:26,940<br>so it includes extra error correcting information by default, that is rather than reacting to</p>
<p>6<br>00:00:26,940 –&gt; 00:00:30,820<br>errors and sending some correcting data only as needed.</p>
<p>7<br>00:00:30,820 –&gt; 00:00:34,899<br>Forward error correction adds some redundant data to the message so the receiver can recover</p>
<p>8<br>00:00:34,899 –&gt; 00:00:38,020<br>from a reasonable number of errors without any additional transmission.</p>
<p>9<br>00:00:38,020 –&gt; 00:00:42,400<br>I’ll also walk through a technique called interleaving that can make messages even more</p>
<p>10<br>00:00:42,400 –&gt; 00:00:46,540<br>robust to long bursts of errors.</p>
<p>11<br>00:00:46,540 –&gt; 00:00:50,740<br>If you make some mathematical assumptions about noise, there’s a precise relationship between</p>
<p>12<br>00:00:50,740 –&gt; 00:00:54,620<br>the links, signal to noise ratio, and it’s bit error rate.</p>
<p>13<br>00:00:54,619 –&gt; 00:00:57,979<br>These assumptions tend to be pretty accurate in practice, so this means there’s a strong</p>
<p>14<br>00:00:57,979 –&gt; 00:01:00,780<br>theoretical basis for bit error rates.</p>
<p>15<br>00:01:00,780 –&gt; 00:01:05,259<br>The exact bit error rate for a given signal to noise ratio depends on the modulation used.</p>
<p>16<br>00:01:05,259 –&gt; 00:01:09,780<br>For example, at a given signal to noise ratio, phase shift keying has a lower bit error rate</p>
<p>17<br>00:01:09,780 –&gt; 00:01:13,859<br>than amplitude shift keying.</p>
<p>18<br>00:01:13,859 –&gt; 00:01:19,700<br>Increasing the signal to noise ratio, either increasing the signal or reducing the noise,</p>
<p>19<br>00:01:19,700 –&gt; 00:01:22,060<br>decreases the bit error rate.</p>
<p>20<br>00:01:22,060 –&gt; 00:01:28,500<br>But something very important is that the bit error rate never reaches zero.</p>
<p>21<br>00:01:28,500 –&gt; 00:01:32,620<br>This because noise isn’t uniform, it follows a Gaussian distribution.</p>
<p>22<br>00:01:32,620 –&gt; 00:01:35,020<br>That’s the mathematical assumption.</p>
<p>23<br>00:01:35,020 –&gt; 00:01:39,180<br>So the chances of having noise greater than any threshold is always non-zero.</p>
<p>24<br>00:01:39,180 –&gt; 00:01:43,340<br>No matter how strong you make your signal, you’ll always lose packets.</p>
<p>25<br>00:01:43,340 –&gt; 00:01:51,260<br>You might lose very few, but there’s no such thing as a link with no bit errors.</p>
<p>26<br>00:01:51,260 –&gt; 00:01:54,740<br>I won’t go into the details why, but it turns out if you work through the math, sending</p>
<p>27<br>00:01:54,740 –&gt; 00:01:58,060<br>packets as raw bits is very inefficient.</p>
<p>28<br>00:01:58,060 –&gt; 00:02:03,219<br>If the signal strength is high enough that bit error rates are rare, then a system is</p>
<p>29<br>00:02:03,219 –&gt; 00:02:06,500<br>operating far below the Shannon limit.</p>
<p>30<br>00:02:06,500 –&gt; 00:02:10,500<br>It’s important that every word you say is perfectly understood.</p>
<p>31<br>00:02:10,500 –&gt; 00:02:14,300<br>You have to speak very slowly and very loudly.</p>
<p>32<br>00:02:14,300 –&gt; 00:02:17,659<br>This means you’re wasting a lot of the capacity of the channel.</p>
<p>33<br>00:02:17,659 –&gt; 00:02:23,740<br>For example, suppose you want to transmit a 1,500 byte, so 12,000 bit packets, the packet</p>
<p>34<br>00:02:23,740 –&gt; 00:02:28,659<br>loss rate below 1 in 10,000, so 10 to the minus 4.</p>
<p>35<br>00:02:28,659 –&gt; 00:02:32,419<br>This means that every one of the 12,000 bits must be correct.</p>
<p>36<br>00:02:32,419 –&gt; 00:02:40,419<br>So 1 minus the bit error rate, raised to 12,000th power, must be greater than 0.999.</p>
<p>37<br>00:02:40,419 –&gt; 00:02:45,539<br>So the bit error rate must be approximately 10 to the minus 8th.</p>
<p>38<br>00:02:45,539 –&gt; 00:02:50,659<br>To get this bit error rate, the system needs to transmit at a high power.</p>
<p>39<br>00:02:50,659 –&gt; 00:02:54,780<br>If you calculate what the channel capacity is at this power, that is, what speed you could</p>
<p>40<br>00:02:54,780 –&gt; 00:03:01,099<br>send data if you use the channel perfectly, it’s 5 times higher than your speed when sending</p>
<p>41<br>00:03:01,099 –&gt; 00:03:06,899<br>12,000 bit packets with the packets with a loss rate below 0.01%.</p>
<p>42<br>00:03:06,899 –&gt; 00:03:11,659<br>So if you try to send packets this way, just cranking the power up to have very few bit errors,</p>
<p>43<br>00:03:11,659 –&gt; 00:03:13,739<br>you’re wasting 80% of your capacity.</p>
<p>44<br>00:03:13,980 –&gt; 00:03:19,340<br>The theory says you can send data 5 times faster.</p>
<p>45<br>00:03:19,340 –&gt; 00:03:24,300<br>Highly engineered wireless systems like LTE operate very close to their theoretical</p>
<p>46<br>00:03:24,300 –&gt; 00:03:25,620<br>maximums.</p>
<p>47<br>00:03:25,620 –&gt; 00:03:27,820<br>So how does the system do that?</p>
<p>48<br>00:03:27,820 –&gt; 00:03:31,700<br>How does it send data in order to not waste that 80%?</p>
<p>49<br>00:03:31,700 –&gt; 00:03:35,140<br>The rest of this video explained the basic technique called forward error correction,</p>
<p>50<br>00:03:35,140 –&gt; 00:03:39,780<br>and the mechanism it uses called coding.</p>
<p>51<br>00:03:39,780 –&gt; 00:03:42,379<br>The basic idea behind coding is very simple.</p>
<p>52<br>00:03:42,379 –&gt; 00:03:46,460<br>Rather than just send the raw bits and hope none of them are corrupted, send the data</p>
<p>53<br>00:03:46,460 –&gt; 00:03:49,219<br>plus a little bit of redundancy.</p>
<p>54<br>00:03:49,219 –&gt; 00:03:52,780<br>Mechanisms like CRC’s max and check sums can detect errors.</p>
<p>55<br>00:03:52,780 –&gt; 00:03:57,299<br>With coding, we can only detect but also correct errors.</p>
<p>56<br>00:03:57,299 –&gt; 00:04:02,419<br>The idea is that adding just a little bit of redundancy one could correct a few bit errors.</p>
<p>57<br>00:04:02,419 –&gt; 00:04:07,259<br>Sending packets that have only a few errors lets you send them either much faster.</p>
<p>58<br>00:04:07,259 –&gt; 00:04:12,139<br>And this greater speed more than makes up for the redundancy at it.</p>
<p>59<br>00:04:12,139 –&gt; 00:04:17,099<br>The amount of redundancy you add is described by something called the coding gain.</p>
<p>60<br>00:04:17,099 –&gt; 00:04:21,459<br>The gain is described as a fraction, which shows the ratio between the number of bits sent</p>
<p>61<br>00:04:21,459 –&gt; 00:04:26,219<br>by the link layer and the corresponding number of bits at the physical error.</p>
<p>62<br>00:04:26,219 –&gt; 00:04:31,419<br>For example, if a system doubles the length of a packet, so it sends one bit of redundant</p>
<p>63<br>00:04:31,419 –&gt; 00:04:36,459<br>data for every bit of the link layer data, so two bits for every bit, the coding gain</p>
<p>64<br>00:04:36,459 –&gt; 00:04:37,860<br>is one half.</p>
<p>65<br>00:04:38,699 –&gt; 00:04:44,580<br>If three link layer bits are sent as four bits at the physical error, this is a three four code.</p>
<p>66<br>00:04:44,580 –&gt; 00:04:49,740<br>So a gain of one means you’re just sending raw bits.</p>
<p>67<br>00:04:49,740 –&gt; 00:04:54,620<br>Adding some redundant data like this to proactively correct errors is called forward error correction</p>
<p>68<br>00:04:54,620 –&gt; 00:04:56,300<br>or FEC.</p>
<p>69<br>00:04:56,300 –&gt; 00:05:00,660<br>It’s called forward error correction because the sender doesn’t need any feedback from the receiver,</p>
<p>70<br>00:05:00,660 –&gt; 00:05:02,340<br>so it doesn’t need a back channel.</p>
<p>71<br>00:05:02,340 –&gt; 00:05:07,819<br>Instead, the sender uses a bit of the capacity of the forward channel to correct errors.</p>
<p>72<br>00:05:08,540 –&gt; 00:05:10,300<br>There are many coding algorithms.</p>
<p>73<br>00:05:10,300 –&gt; 00:05:12,939<br>It’s a rich field of study that’s over 70 years old.</p>
<p>74<br>00:05:12,939 –&gt; 00:05:14,259<br>Some of them are very simple.</p>
<p>75<br>00:05:14,259 –&gt; 00:05:15,500<br>Some of them are very complex.</p>
<p>76<br>00:05:15,500 –&gt; 00:05:19,860<br>I’m going to present one of them, read Solomon codes.</p>
<p>77<br>00:05:19,860 –&gt; 00:05:22,259<br>Read Solomon codes have three great qualities.</p>
<p>78<br>00:05:22,259 –&gt; 00:05:25,219<br>First, they’re very effective and they’re used a lot.</p>
<p>79<br>00:05:25,219 –&gt; 00:05:32,019<br>For example, CDs, DVDs, DSL, Y-Max and RAID 6 storage systems all use read Solomon codes.</p>
<p>80<br>00:05:32,019 –&gt; 00:05:35,620<br>Second, as that list shows, they’re very flexible in general.</p>
<p>81<br>00:05:35,660 –&gt; 00:05:41,540<br>They’re used in storage, CDs, DVDs and RAID, as well as communication systems, DSL and Y-Max.</p>
<p>82<br>00:05:41,540 –&gt; 00:05:44,259<br>Third, they’re mathematically very simple.</p>
<p>83<br>00:05:44,259 –&gt; 00:05:47,019<br>So they’re simple to explain and understand.</p>
<p>84<br>00:05:50,139 –&gt; 00:05:53,540<br>Read Solomon codes operate on a block of data.</p>
<p>85<br>00:05:53,540 –&gt; 00:06:03,019<br>So you take a block of say 223 bytes and add 30 bytes of redundancy to turn it into a block of 255 bytes.</p>
<p>86<br>00:06:03,859 –&gt; 00:06:11,060<br>The basic intuition behind read Solomon is that you take your block and split it into K chunks.</p>
<p>87<br>00:06:11,060 –&gt; 00:06:13,620<br>For example, a chunk might be a byte.</p>
<p>88<br>00:06:13,620 –&gt; 00:06:19,299<br>You take a 223 byte block and break into 223 chunks.</p>
<p>89<br>00:06:19,299 –&gt; 00:06:27,180<br>Then consider each of these K values as the coefficients of a polynomial whose degree is K minus 1.</p>
<p>90<br>00:06:27,180 –&gt; 00:06:32,939<br>So in this example, we consider the chunks as the coefficient of a 220 degree polynomial.</p>
<p>91<br>00:06:32,939 –&gt; 00:06:37,459<br>So say our first three chunks are 71, 69 and 84.</p>
<p>92<br>00:06:37,459 –&gt; 00:06:43,300<br>This means that the three smallest coefficients, the polynomial are 71, 69 and 84.</p>
<p>93<br>00:06:43,300 –&gt; 00:06:48,139<br>So 71 x squared plus 69 x plus 84.</p>
<p>94<br>00:06:48,139 –&gt; 00:06:57,699<br>Or the could be the largest tree, 71 x to the 220 second, 69 x to the 220 first plus 84 x to the 220th.</p>
<p>95<br>00:06:57,699 –&gt; 00:06:58,699<br>Doesn’t matter.</p>
<p>96<br>00:06:59,699 –&gt; 00:07:07,699<br>The Unisolving’s theorem says that any n degree polynomial is defined by n plus 1 different data points.</p>
<p>97<br>00:07:07,699 –&gt; 00:07:14,699<br>So following our example, if we have a 222 degree polynomial,</p>
<p>98<br>00:07:14,699 –&gt; 00:07:22,699<br>then if we have 223 data points from that polynomial, we can figure out its coefficients.</p>
<p>99<br>00:07:22,699 –&gt; 00:07:25,699<br>Each data point has to have a different x value.</p>
<p>100<br>00:07:26,699 –&gt; 00:07:31,699<br>So this means that if we send more than 223 data points, and some of those data points are corrupted,</p>
<p>101<br>00:07:31,699 –&gt; 00:07:36,699<br>as long as we receive 223 correct data points, and know which ones are correct,</p>
<p>102<br>00:07:36,699 –&gt; 00:07:39,699<br>then we can recover the polynomial’s coefficient.</p>
<p>103<br>00:07:39,699 –&gt; 00:07:43,699<br>And remember, the coefficients of the data we’re trying to send.</p>
<p>104<br>00:07:43,699 –&gt; 00:07:49,699<br>So what you can do is, rather than send the original data, the coefficients of the polynomial,</p>
<p>105<br>00:07:49,699 –&gt; 00:07:52,699<br>you can send points on the polynomial.</p>
<p>106<br>00:07:52,699 –&gt; 00:07:59,699<br>Suppose the polynomial is f, you send a message that contains f of 0, f of 1, f of 2, f of 3.</p>
<p>107<br>00:07:59,699 –&gt; 00:08:06,699<br>The recipient receives these data points, and then from them, computes the coefficients.</p>
<p>108<br>00:08:06,699 –&gt; 00:08:10,699<br>There’s one mathematical complication though.</p>
<p>109<br>00:08:10,699 –&gt; 00:08:18,699<br>If you have a polynomial with large positive coefficients, the value of each data point will quickly become much larger than can fit in a single chunk.</p>
<p>110<br>00:08:18,699 –&gt; 00:08:24,699<br>For example, if one of the terms of the total polynomials, 84 times x to the 220th,</p>
<p>111<br>00:08:24,699 –&gt; 00:08:33,700<br>then x equals 2 will be 1.4 times 10 to the 68th, and coding this in binary would take 226 bits.</p>
<p>112<br>00:08:33,700 –&gt; 00:08:37,700<br>So the points, instead, are computed on a finite field.</p>
<p>113<br>00:08:37,700 –&gt; 00:08:40,700<br>This means it has a limited number of bits.</p>
<p>114<br>00:08:40,700 –&gt; 00:08:46,700<br>For example, since each chunk is a byte, you compute the value over the 8-bit field with values 0 to 255.</p>
<p>115<br>00:08:46,700 –&gt; 00:08:49,700<br>When a computation overflows, it just wraps around.</p>
<p>116<br>00:08:49,700 –&gt; 00:08:58,700<br>So the value in this field is 84 times 2 to the 20th, modulo 256, which happens to be 0.</p>
<p>117<br>00:08:58,700 –&gt; 00:09:06,700<br>If we have enough correct data points, we can reconstitute the polynomial coefficients and decode the data.</p>
<p>118<br>00:09:06,700 –&gt; 00:09:09,700<br>But there might be bitters.</p>
<p>119<br>00:09:09,700 –&gt; 00:09:13,700<br>How do we know which data points are correct, and which are corrupted?</p>
<p>120<br>00:09:13,700 –&gt; 00:09:19,700<br>The prior slide assumed we know. How do we find out?</p>
<p>121<br>00:09:19,700 –&gt; 00:09:22,700<br>Read Solomon distinguishes two kinds of errors.</p>
<p>122<br>00:09:22,700 –&gt; 00:09:29,700<br>The first are called erasers. These denote errors that the receiver knows are errors. They are erased values.</p>
<p>123<br>00:09:29,700 –&gt; 00:09:33,700<br>For example, you didn’t receive the chunk.</p>
<p>124<br>00:09:33,700 –&gt; 00:09:38,700<br>For example, in a rate array, you have erasers when a hard drive fails and stops responding.</p>
<p>125<br>00:09:38,700 –&gt; 00:09:42,700<br>The second type are errors, which you don’t know are errors.</p>
<p>126<br>00:09:42,700 –&gt; 00:09:50,700<br>This is the more common case in communication systems. Some of the chunks have bit errors, and you don’t know which ones.</p>
<p>127<br>00:09:50,700 –&gt; 00:09:57,700<br>The number of erasers in errors read Solomon can recover from depends on the amount of redundancy.</p>
<p>128<br>00:09:57,700 –&gt; 00:10:04,700<br>Let’s say that the original number of chunks is k, and the encoding adds redundancy, so it sends n chunks.</p>
<p>129<br>00:10:04,700 –&gt; 00:10:08,700<br>It’s adding n minus k chunks of redundancy.</p>
<p>130<br>00:10:08,700 –&gt; 00:10:19,700<br>If the problem is erasers, then all the receiver needs is k chunks, so the receiver can recover from up to n minus k erasers.</p>
<p>131<br>00:10:19,700 –&gt; 00:10:27,700<br>It turns out the receiver can recover from n minus k divided by two errors.</p>
<p>132<br>00:10:27,700 –&gt; 00:10:33,700<br>The receiver can recover from fewer errors than erasers because it needs to figure out which chunks of errors.</p>
<p>133<br>00:10:33,700 –&gt; 00:10:37,700<br>So, why can’t I handle only half as many errors as erasers?</p>
<p>134<br>00:10:37,700 –&gt; 00:10:45,700<br>One way to think of this is that the receiver is trying to solve for two sets of unknowns, which receive chunks are bad, and the coefficients of the polynomial.</p>
<p>135<br>00:10:45,700 –&gt; 00:10:51,700<br>If there are erasers, this tells the receiver which chunks are bad, and so it doesn’t need to solve for those unknowns.</p>
<p>136<br>00:10:51,700 –&gt; 00:11:00,700<br>But if there are errors, the receiver needs to solve for an additional unknown, and so it needs correct redundant bytes to do so.</p>
<p>137<br>00:11:00,700 –&gt; 00:11:11,700<br>So, returning to our example of a 223 byte data block turned into a 220 degree polynomial sent as 256 bytes, so 32 bytes of redundancy.</p>
<p>138<br>00:11:11,700 –&gt; 00:11:21,700<br>If 16 or fewer of the encoded chunks of bad errors, our receiver can successfully decode the data and reconstitute the original 223 bytes.</p>
<p>139<br>00:11:21,700 –&gt; 00:11:33,700<br>This particular code is described as a 255 223 code, and encoded block is 255 code words, which are generated from 223 data words.</p>
<p>140<br>00:11:33,700 –&gt; 00:11:43,700<br>For a code to support C code words, each word must be at least the ceiling of log 2 of C bits long.</p>
<p>141<br>00:11:43,700 –&gt; 00:11:48,700<br>So, to support 255 code words, each word must be at least 8 bits long.</p>
<p>142<br>00:11:48,700 –&gt; 00:11:55,700<br>Otherwise, there isn’t enough information in each word to decode the polynomial.</p>
<p>143<br>00:11:55,700 –&gt; 00:12:03,700<br>It turns out what I’ve just described is an exactly how read Solomon is used, because decoding is extremely expensive.</p>
<p>144<br>00:12:03,700 –&gt; 00:12:12,700<br>Instead, slightly different mathematical formulations are used that are more efficient, but the basic principles are the same, and the idea of points along the polynomial is still used.</p>
<p>145<br>00:12:13,700 –&gt; 00:12:16,700<br>Let’s walk through an example.</p>
<p>146<br>00:12:16,700 –&gt; 00:12:21,700<br>In this example, we’re encoding six bytes of data, the word hello.</p>
<p>147<br>00:12:21,700 –&gt; 00:12:25,700<br>We’re going to encode it with a 75 code.</p>
<p>148<br>00:12:25,700 –&gt; 00:12:30,700<br>So, five data chunks are turned into seven coded chunks.</p>
<p>149<br>00:12:30,700 –&gt; 00:12:36,700<br>Because we have seven code words per block, each chunk must be at least three bits long.</p>
<p>150<br>00:12:37,700 –&gt; 00:12:45,700<br>So, for a 75 code, this means we take five three bit data words and encode them as seven three bit code words.</p>
<p>151<br>00:12:45,700 –&gt; 00:12:48,700<br>15 bits becomes 21 bits.</p>
<p>152<br>00:12:48,700 –&gt; 00:12:54,700<br>The sender sends this longer data, the receiver receives it, and decodes it to the original data.</p>
<p>153<br>00:12:57,700 –&gt; 00:13:01,700<br>If you look at this example closely, you’ll see there’s an interesting edge case.</p>
<p>154<br>00:13:01,700 –&gt; 00:13:04,700<br>The input is 48 bits long.</p>
<p>155<br>00:13:04,700 –&gt; 00:13:07,700<br>We need to break it up into 15 bit blocks.</p>
<p>156<br>00:13:07,700 –&gt; 00:13:10,700<br>We need to send an integer number of blocks.</p>
<p>157<br>00:13:10,700 –&gt; 00:13:16,700<br>So, we have to increase the size of the data to be 60 bits, or four blocks long.</p>
<p>158<br>00:13:16,700 –&gt; 00:13:19,700<br>The edge case is that our data doesn’t easily fit into four blocks.</p>
<p>159<br>00:13:19,700 –&gt; 00:13:23,700<br>The typical solution to this is just to pad the last block with zeros.</p>
<p>160<br>00:13:23,700 –&gt; 00:13:28,700<br>In this example, we pad the last block by 12-0 bits.</p>
<p>161<br>00:13:28,700 –&gt; 00:13:34,700<br>60 data bits are encoded as four 21 bit code words, or 84 bits.</p>
<p>162<br>00:13:34,700 –&gt; 00:13:39,700<br>The sender sends 84 bits to the receiver.</p>
<p>163<br>00:13:39,700 –&gt; 00:13:46,700<br>The receiver runs a read-song decoder to get the 60 data bits and recover the string, hello.</p>
<p>164<br>00:13:49,700 –&gt; 00:13:57,700<br>One way one often thinks about encoding schemes is how long a burst of consecutive errors the approach can recover from.</p>
<p>165<br>00:13:58,700 –&gt; 00:14:03,700<br>So, let’s suppose that there are bit errors in the transmitted data.</p>
<p>166<br>00:14:03,700 –&gt; 00:14:05,700<br>Let’s ask a first question.</p>
<p>167<br>00:14:05,700 –&gt; 00:14:10,700<br>What’s the shortest burst of errors that could cause the 75 code to fail?</p>
<p>168<br>00:14:10,700 –&gt; 00:14:14,700<br>Now, in read-solomon, errors are in terms of code words.</p>
<p>169<br>00:14:14,700 –&gt; 00:14:19,700<br>A single bit error in a code word makes the whole word an error.</p>
<p>170<br>00:14:19,700 –&gt; 00:14:26,700<br>So, with a 75 code, a receiver can recover from a single code word error per block.</p>
<p>171<br>00:14:27,700 –&gt; 00:14:31,700<br>So, let’s suppose there’s one bit error here.</p>
<p>172<br>00:14:35,700 –&gt; 00:14:41,700<br>The decoder can still decode the first block, and the data is received correctly.</p>
<p>173<br>00:14:41,700 –&gt; 00:14:46,700<br>Now, suppose there are two consecutive bit errors.</p>
<p>174<br>00:14:46,700 –&gt; 00:14:49,700<br>Can read-solomon recover from this?</p>
<p>175<br>00:14:49,700 –&gt; 00:14:51,700<br>It turns out it depends.</p>
<p>176<br>00:14:51,700 –&gt; 00:14:56,700<br>If both bit errors fall in the same code word,</p>
<p>177<br>00:14:59,700 –&gt; 00:15:04,700<br>then there’s only one code word an error,</p>
<p>178<br>00:15:04,700 –&gt; 00:15:07,700<br>and read-solomon can decode correctly.</p>
<p>179<br>00:15:07,700 –&gt; 00:15:11,700<br>If the two bit errors fall in a block boundary,</p>
<p>180<br>00:15:11,700 –&gt; 00:15:15,700<br>there’s one error in the last bit of one block,</p>
<p>181<br>00:15:15,700 –&gt; 00:15:20,700<br>and one error in the first bit of another block.</p>
<p>182<br>00:15:20,700 –&gt; 00:15:23,700<br>Read-solomon can recover.</p>
<p>183<br>00:15:25,700 –&gt; 00:15:36,700<br>But if the two bit errors fall in a JSON code word in the same block,</p>
<p>184<br>00:15:40,700 –&gt; 00:15:47,700<br>like this, then there are two code words an error,</p>
<p>185<br>00:15:47,700 –&gt; 00:15:50,700<br>and read-solomon can decode the block.</p>
<p>186<br>00:15:50,700 –&gt; 00:15:57,700<br>So, the shortest burst of consecutive bit errors can cause the 75 code to fail is two.</p>
<p>187<br>00:15:58,700 –&gt; 00:16:02,700<br>A second question is what’s the longest burst of consecutive bit errors</p>
<p>188<br>00:16:02,700 –&gt; 00:16:06,700<br>the thing encoding might be able to recover from?</p>
<p>189<br>00:16:06,700 –&gt; 00:16:08,700<br>Since it’s a 75 code,</p>
<p>190<br>00:16:08,700 –&gt; 00:16:11,700<br>it must one code word in a block can be corrupted.</p>
<p>191<br>00:16:11,700 –&gt; 00:16:15,700<br>It doesn’t matter if one bit or all the bits in a code word are corrupted.</p>
<p>192<br>00:16:15,700 –&gt; 00:16:18,700<br>In other case, the code word is corrupted.</p>
<p>193<br>00:16:18,700 –&gt; 00:16:21,700<br>So, a three bit burst of errors can corrupt only one,</p>
<p>194<br>00:16:21,700 –&gt; 00:16:26,700<br>only a single code word, which read-solomon can recover from.</p>
<p>195<br>00:16:32,700 –&gt; 00:16:37,700<br>If the string of errors spans two different blocks,</p>
<p>196<br>00:16:39,700 –&gt; 00:16:44,700<br>then it could corrupt one code word in each of the two different blocks.</p>
<p>197<br>00:16:45,700 –&gt; 00:16:51,700<br>Both blocks would be decoded correctly.</p>
<p>198<br>00:16:54,700 –&gt; 00:16:57,700<br>So, the longest burst of consecutive bit errors is six.</p>
<p>199<br>00:16:57,700 –&gt; 00:17:00,700<br>The first three corrupt a single code word in one block,</p>
<p>200<br>00:17:00,700 –&gt; 00:17:04,700<br>and the second three corrupt a single code word in the second block.</p>
<p>201<br>00:17:04,700 –&gt; 00:17:09,700<br>If there are seven bit errors, then the burst of errors must corrupt three blocks.</p>
<p>202<br>00:17:10,700 –&gt; 00:17:15,700<br>Two of which must be must corrupt three code words,</p>
<p>203<br>00:17:15,700 –&gt; 00:17:18,700<br>two of which must be in one block,</p>
<p>204<br>00:17:18,700 –&gt; 00:17:20,700<br>so read-solomon cannot recover.</p>
<p>205<br>00:17:20,700 –&gt; 00:17:25,700<br>The longest burst of consecutive bit errors that the seven five code can recover from is six.</p>
<p>206<br>00:17:27,700 –&gt; 00:17:29,700<br>These numbers are small.</p>
<p>207<br>00:17:29,700 –&gt; 00:17:34,700<br>In part because it’s examples using such a small code with very little redundancy and small code words.</p>
<p>208<br>00:17:34,700 –&gt; 00:17:39,700<br>Imagine instead that the system uses a two five five two two three code with eight bit words.</p>
<p>209<br>00:17:39,700 –&gt; 00:17:43,700<br>The shortest burst that can corrupt a block that is is 122 bits,</p>
<p>210<br>00:17:43,700 –&gt; 00:17:45,700<br>it corrupts 17 code words.</p>
<p>211<br>00:17:45,700 –&gt; 00:17:49,700<br>The longest burst that it could recover from is 256 bits,</p>
<p>212<br>00:17:49,700 –&gt; 00:17:54,700<br>16 code words in one block, 16 code words in a second block.</p>
<p>213<br>00:17:55,700 –&gt; 00:18:00,700<br>One technique that can make read-solomon even more resistant to burst errors is interleaving.</p>
<p>214<br>00:18:00,700 –&gt; 00:18:03,700<br>The basic idea of interleaving.</p>
<p>215<br>00:18:05,700 –&gt; 00:18:08,700<br>Is that rather than lay out the code words linearly,</p>
<p>216<br>00:18:08,700 –&gt; 00:18:13,700<br>spread the amounts the burst of errors crops a small number of code words in many blocks,</p>
<p>217<br>00:18:13,700 –&gt; 00:18:16,700<br>rather than many code words in a small number of blocks.</p>
<p>218<br>00:18:17,700 –&gt; 00:18:22,700<br>For example, imagine we’re using our seven five code with three bit words.</p>
<p>219<br>00:18:23,700 –&gt; 00:18:28,700<br>A coded block is 21 bits long, seven three bit words.</p>
<p>220<br>00:18:28,700 –&gt; 00:18:30,700<br>Now suppose we have 12 blocks.</p>
<p>221<br>00:18:31,700 –&gt; 00:18:36,700<br>So let’s call the blocks a through l with the individual bits of each block being a subscript.</p>
<p>222<br>00:18:36,700 –&gt; 00:18:39,700<br>So a zero is the first bit of the first block.</p>
<p>223<br>00:18:39,700 –&gt; 00:18:42,700<br>We’ll see 20 is the last bit of the third block.</p>
<p>224<br>00:18:42,700 –&gt; 00:18:45,700<br>And b4 is the fifth bit of the second block.</p>
<p>225<br>00:18:45,700 –&gt; 00:18:47,700<br>If we use the format shown here,</p>
<p>226<br>00:18:47,700 –&gt; 00:18:51,700<br>the longest burst error that this data can recover from is six bits long,</p>
<p>227<br>00:18:51,700 –&gt; 00:18:57,700<br>corrupting the last three bits of one code word in one block.</p>
<p>228<br>00:18:57,700 –&gt; 00:19:00,700<br>And the first three bits, one code word in the following block.</p>
<p>229<br>00:19:02,700 –&gt; 00:19:05,700<br>Now imagine if instead we organize the bits,</p>
<p>230<br>00:19:05,700 –&gt; 00:19:08,700<br>so the code words from different blocks are interleaved.</p>
<p>231<br>00:19:08,700 –&gt; 00:19:13,700<br>Now instead of a zero, a one, a two, a three,</p>
<p>232<br>00:19:13,700 –&gt; 00:19:18,700<br>the first four bits are a zero, a one, a two, e zero.</p>
<p>233<br>00:19:18,700 –&gt; 00:19:22,700<br>So the sent data starts with the first code word from block a,</p>
<p>234<br>00:19:22,700 –&gt; 00:19:29,700<br>followed by the first code word from block e, then c, et cetera.</p>
<p>235<br>00:19:29,700 –&gt; 00:19:33,700<br>After the first code word from l, so bits,</p>
<p>236<br>00:19:33,700 –&gt; 00:19:37,700<br>l zero, l one, l two, there’s the second code word from a,</p>
<p>237<br>00:19:37,700 –&gt; 00:19:39,700<br>so bits a three, a four, a five.</p>
<p>238<br>00:19:39,700 –&gt; 00:19:42,700<br>Let’s call this code word infill leaving.</p>
<p>239<br>00:19:42,700 –&gt; 00:19:48,700<br>In this case, what’s the shortest burst error that could cause decoding to fail?</p>
<p>240<br>00:19:48,700 –&gt; 00:19:50,700<br>Let’s walk through it.</p>
<p>241<br>00:19:51,700 –&gt; 00:19:55,700<br>For the decoding to fail, it’s from two different code words,</p>
<p>242<br>00:19:55,700 –&gt; 00:19:58,700<br>from the same block must be corrupted.</p>
<p>243<br>00:19:58,700 –&gt; 00:20:03,700<br>For example, one bit of the first code word of a,</p>
<p>244<br>00:20:03,700 –&gt; 00:20:07,700<br>at a two, must be corrupted,</p>
<p>245<br>00:20:13,700 –&gt; 00:20:17,700<br>as well as one bit of the second code word of a, so a three.</p>
<p>246<br>00:20:18,700 –&gt; 00:20:22,700<br>These two bits are 34 bits apart,</p>
<p>247<br>00:20:25,700 –&gt; 00:20:30,700<br>because there are 12 chunks that is, we’d have to corrupt a two,</p>
<p>248<br>00:20:30,700 –&gt; 00:20:36,700<br>b zero, e one, e two, c zero, c one, c two, all the way up to l three,</p>
<p>249<br>00:20:36,700 –&gt; 00:20:40,700<br>a three, so a two, l two, a three,</p>
<p>250<br>00:20:40,700 –&gt; 00:20:43,700<br>or 11 code words plus two bits, 35 bits.</p>
<p>251<br>00:20:44,700 –&gt; 00:20:48,700<br>The shortest burst error that could cause decoding to fail is 35 bits.</p>
<p>252<br>00:20:48,700 –&gt; 00:20:53,700<br>This is over 16 times longer than if we didn’t use interleaving.</p>
<p>253<br>00:20:53,700 –&gt; 00:20:58,700<br>And what’s the longest burst error this could recover from?</p>
<p>254<br>00:20:58,700 –&gt; 00:21:03,700<br>This would cover a single code word in every single block,</p>
<p>255<br>00:21:03,700 –&gt; 00:21:05,700<br>so 36 bits.</p>
<p>256<br>00:21:05,700 –&gt; 00:21:10,700<br>For example, a burst error that covers the first 36 bits of the interleaved encoded data</p>
<p>257<br>00:21:10,700 –&gt; 00:21:15,700<br>will be corrupt the first code word of a, first code word of b,</p>
<p>258<br>00:21:15,700 –&gt; 00:21:20,700<br>the first code word of c, etc, up to the first code word of l.</p>
<p>259<br>00:21:26,700 –&gt; 00:21:30,700<br>Let’s consider another option, bit interleaving.</p>
<p>260<br>00:21:30,700 –&gt; 00:21:36,700<br>In bit interleaving, we interleaved the bits from individual code words.</p>
<p>261<br>00:21:37,700 –&gt; 00:21:42,700<br>So the first bit is a zero, the second bit is b zero, the third bit is c zero.</p>
<p>262<br>00:21:42,700 –&gt; 00:21:46,700<br>After bit l zero comes bit a one.</p>
<p>263<br>00:21:46,700 –&gt; 00:21:52,700<br>The last 12 bits of the data are bits a 20 to l 20.</p>
<p>264<br>00:21:52,700 –&gt; 00:21:58,700<br>So we’ve turned 12 blocks of 21 bits into 21 encoded blocks of 12 bits.</p>
<p>265<br>00:21:58,700 –&gt; 00:22:01,700<br>What’s the shortest burst of errors and corrupt the data?</p>
<p>266<br>00:22:02,700 –&gt; 00:22:06,700<br>The burst has to cover two code words in one block.</p>
<p>267<br>00:22:06,700 –&gt; 00:22:11,700<br>Suppose there is a burst starting at bit a two.</p>
<p>268<br>00:22:11,700 –&gt; 00:22:16,700<br>If the burst is 13 bits long, you’ll reach a three.</p>
<p>269<br>00:22:16,700 –&gt; 00:22:21,700<br>A three is in a different code word.</p>
<p>270<br>00:22:21,700 –&gt; 00:22:24,700<br>So this will cause the decoding of a to fail.</p>
<p>271<br>00:22:24,700 –&gt; 00:22:30,700<br>So the shortest burst of errors that could prevent decoding is 13 bits.</p>
<p>272<br>00:22:32,700 –&gt; 00:22:37,700<br>What’s the longest burst of errors that this read Solomon code can recover from?</p>
<p>273<br>00:22:37,700 –&gt; 00:22:43,700<br>The answer is 36 bits covering a single code word from every block.</p>
<p>274<br>00:22:43,700 –&gt; 00:22:50,700<br>For example, a zero to l two, the first 36 bits.</p>
<p>275<br>00:22:50,700 –&gt; 00:23:00,700<br>What’s important to note here is that bit level interleaving can recover from the same longest burst of errors as code word level interleaving.</p>
<p>276<br>00:23:01,700 –&gt; 00:23:06,700<br>But the shortest burst that can corrupt the data using bit interleaving is shorter.</p>
<p>277<br>00:23:06,700 –&gt; 00:23:10,700<br>For code interleaving remember, it was 35 bits for bit interleaving.</p>
<p>278<br>00:23:10,700 –&gt; 00:23:12,700<br>It’s 13 bits.</p>
<p>279<br>00:23:12,700 –&gt; 00:23:15,700<br>So why is this?</p>
<p>280<br>00:23:15,700 –&gt; 00:23:22,700<br>It’s because of the important property of read Solomon that any number of bits corrupted in code word cause it to be invalid.</p>
<p>281<br>00:23:23,700 –&gt; 00:23:31,700<br>So if there’s a burst of errors, you want them to be spread across as many blocks as possible so that there are a few errors in any block.</p>
<p>282<br>00:23:31,700 –&gt; 00:23:36,700<br>But if an error corrupts a code word, you want it to concentrate on that code word.</p>
<p>283<br>00:23:36,700 –&gt; 00:23:41,700<br>As every bit bit being an error is no worse than a single bit being an error.</p>
<p>284<br>00:23:41,700 –&gt; 00:23:45,700<br>So you want to minimize the number of code words that are corrupted in any block.</p>
<p>285<br>00:23:45,700 –&gt; 00:23:51,700<br>You can do this by spreading errors across blocks and by concentrating errors within code words.</p>
<p>286<br>00:23:52,700 –&gt; 00:23:56,700<br>With code word interleaving, all the bits of a code word are adjacent.</p>
<p>287<br>00:23:56,700 –&gt; 00:24:00,700<br>So a burst error that corrupts one bit will also usually corrupt the other bits.</p>
<p>288<br>00:24:00,700 –&gt; 00:24:03,700<br>With bit interleaving, all the bits of a code word are spread out.</p>
<p>289<br>00:24:03,700 –&gt; 00:24:07,700<br>So it’s easily possible to corrupt only one bit of a code word.</p>
<p>290<br>00:24:07,700 –&gt; 00:24:08,700<br>You see this?</p>
<p>291<br>00:24:08,700 –&gt; 00:24:17,700<br>We’re corrupting both A2 and A3 and bit interleaving acquires also corrupting a single bit from the code words B2, B2, C2, D2, etc.</p>
<p>292<br>00:24:17,700 –&gt; 00:24:22,700<br>For code word interleaving in contrast, it requires corrupting the entire intervening code words.</p>
<p>293<br>00:24:22,700 –&gt; 00:24:28,700<br>So B0, B1, B2, C0, C1, C2, etc.</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CS144 NetworkP1077 11bForwardErrorCorrection</div>
      <div>http://example.com/2025/10/23/CS144-networkP1077-11bForwardErrorCorrection/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月23日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/23/CS144-networkP1087-12LowerLayersrecap/" title="CS144 NetworkP1087 12LowerLayersrecap">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CS144 NetworkP1087 12LowerLayersrecap</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/23/CS144-networkP1067-11aFragmentation/" title="CS144 NetworkP1067 11aFragmentation">
                        <span class="hidden-mobile">CS144 NetworkP1067 11aFragmentation</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
