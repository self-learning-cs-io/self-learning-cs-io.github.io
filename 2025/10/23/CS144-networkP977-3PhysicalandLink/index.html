

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="title: CS144-networkP977-3PhysicalandLink.md100:00:00,000 –&gt; 00:00:05,000In the next two videos, I’m going to be telling you about clocks and clock recovery. 200:00:05,000 –&gt; 00:00:11,000Whenev">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2025/10/23/CS144-networkP977-3PhysicalandLink/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="title: CS144-networkP977-3PhysicalandLink.md100:00:00,000 –&gt; 00:00:05,000In the next two videos, I’m going to be telling you about clocks and clock recovery. 200:00:05,000 –&gt; 00:00:11,000Whenev">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-23T00:14:55.297Z">
<meta property="article:modified_time" content="2025-10-23T00:16:16.773Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text=""></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-23 08:14" pubdate>
          2025年10月23日 早上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          2.4k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          20 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header"></h1>
            
            
              <div class="markdown-body">
                
                <hr>
<h2 id="title-CS144-networkP977-3PhysicalandLink-md"><a href="#title-CS144-networkP977-3PhysicalandLink-md" class="headerlink" title="title: CS144-networkP977-3PhysicalandLink.md"></a>title: CS144-networkP977-3PhysicalandLink.md</h2><p>1<br>00:00:00,000 –&gt; 00:00:05,000<br>In the next two videos, I’m going to be telling you about clocks and clock recovery.</p>
<p>2<br>00:00:05,000 –&gt; 00:00:11,000<br>Whenever we send data over a link, for example an Ethernet link, we normally assume a data rate,</p>
<p>3<br>00:00:11,000 –&gt; 00:00:14,000<br>like 10 megabits per second or a gigabit per second.</p>
<p>4<br>00:00:14,000 –&gt; 00:00:19,000<br>When we send a 10 megabits per second, we’re assuming that each bit lasts 100 nanoseconds,</p>
<p>5<br>00:00:19,000 –&gt; 00:00:26,000<br>or 10 million of them per second. And at a gigabit per second, we’re assuming each bit lasts a nanosecond.</p>
<p>6<br>00:00:26,000 –&gt; 00:00:31,000<br>So there must be some notion of a clock somewhere, the clock that was used by the transmitter</p>
<p>7<br>00:00:31,000 –&gt; 00:00:36,000<br>in order to send those bits in the first place. And the receiver needs to know that clock as well</p>
<p>8<br>00:00:36,000 –&gt; 00:00:39,000<br>in order to be able to correctly decode them.</p>
<p>9<br>00:00:39,000 –&gt; 00:00:45,000<br>The problem is that there is no universal reference for a clock, which is precisely the same in two places.</p>
<p>10<br>00:00:45,000 –&gt; 00:00:51,000<br>So the clock that’s used or the frequency that’s used by the transmitter is not precisely known to the receiver.</p>
<p>11<br>00:00:51,000 –&gt; 00:00:56,000<br>It has to figure it out so it can figure out where one bit ends and another bit begins.</p>
<p>12<br>00:00:56,000 –&gt; 00:01:01,000<br>So in this video, I’m going to be describing what the general problem is,</p>
<p>13<br>00:01:01,000 –&gt; 00:01:07,000<br>how we encode clock information with the data to make the life easier for the receiver,</p>
<p>14<br>00:01:07,000 –&gt; 00:01:13,000<br>and then how the receiver can extract the clock and use it to transfer it into its own clock domain,</p>
<p>15<br>00:01:13,000 –&gt; 00:01:20,000<br>its own frequency of clock, and then use it and manipulate it as it would like in at the receiver.</p>
<p>16<br>00:01:20,000 –&gt; 00:01:23,000<br>So the outline of what we’re going to be seeing is this.</p>
<p>17<br>00:01:23,000 –&gt; 00:01:26,000<br>I’m going to be describing how data is transmitted using a clock,</p>
<p>18<br>00:01:26,000 –&gt; 00:01:32,000<br>and the receiver needs to know when to sample the incoming bits in order to recover them correctly.</p>
<p>19<br>00:01:32,000 –&gt; 00:01:37,000<br>We’ll see this in the context of what’s called asynchronous communications for short messages,</p>
<p>20<br>00:01:37,000 –&gt; 00:01:44,000<br>but then the more common case is synchronous communication. That’s what’s used in Ethernet and systems like that,</p>
<p>21<br>00:01:44,000 –&gt; 00:01:51,000<br>where the data is encoded along with the clock, making it easier for the receiver to recover the clock at the far end,</p>
<p>22<br>00:01:51,000 –&gt; 00:01:53,000<br>and then move it into its own clock domain.</p>
<p>23<br>00:01:56,000 –&gt; 00:02:00,000<br>When we transmit data, we always send it using a clock.</p>
<p>24<br>00:02:00,000 –&gt; 00:02:03,000<br>That’s because we want it to have a particular frequency.</p>
<p>25<br>00:02:03,000 –&gt; 00:02:07,000<br>So for example, here I show a server, a sending data,</p>
<p>26<br>00:02:07,000 –&gt; 00:02:14,000<br>and I’ve sort of zoomed in on the final stage of processing just before the data goes out on the wire.</p>
<p>27<br>00:02:14,000 –&gt; 00:02:20,000<br>This is a flip flop, which is just merely timing the data according to the outgoing clock,</p>
<p>28<br>00:02:20,000 –&gt; 00:02:26,000<br>which is here 10 megahertz. In other words, there’s a 100 nanosecond period to this clock.</p>
<p>29<br>00:02:26,000 –&gt; 00:02:30,000<br>So this is a clock that we might use for sending it 10 megabits per second.</p>
<p>30<br>00:02:30,000 –&gt; 00:02:33,000<br>When we want to receive that data at the other end,</p>
<p>31<br>00:02:33,000 –&gt; 00:02:41,000<br>ideally there would be a second wire coming from here that could be used in order to clock the data in at the other end,</p>
<p>32<br>00:02:41,000 –&gt; 00:02:48,000<br>so that this would come in as the data, and then would go to the receiver at the other end.</p>
<p>33<br>00:02:48,000 –&gt; 00:02:52,000<br>This would take two wires. We’d have to send both the data and the clock,</p>
<p>34<br>00:02:52,000 –&gt; 00:02:58,000<br>and in most cases we can’t afford to do that. It would be much more efficient if we could just send one of them.</p>
<p>35<br>00:02:58,000 –&gt; 00:03:05,000<br>So on here we would have the, if we were to do this, we’d have the data that could be the sequence 0, 1, 0, 1, 1,</p>
<p>36<br>00:03:05,000 –&gt; 00:03:14,000<br>and then 0, 0. And then down here would just be the clock that we would use in order to be able to encode it at one end and decode it at the other.</p>
<p>37<br>00:03:14,000 –&gt; 00:03:19,000<br>We’re going to be looking at a number of different examples where the clock is not sent.</p>
<p>38<br>00:03:19,000 –&gt; 00:03:24,000<br>There’s no specific or separate clock line, and in fact this is how it’s done in practice.</p>
<p>39<br>00:03:24,000 –&gt; 00:03:31,000<br>There’s no separate clock that’s sent. Everything has to be determined from the signal itself.</p>
<p>40<br>00:03:31,000 –&gt; 00:03:36,000<br>To illustrate the problem, let me start with an example.</p>
<p>41<br>00:03:36,000 –&gt; 00:03:44,000<br>Imagine that we have a clock here, and this is the clock that is being used by the transmitter in order to clock the data out onto the wire.</p>
<p>42<br>00:03:44,000 –&gt; 00:03:49,000<br>Okay, so I’ve put the guidelines here just to help me draw that. So this is the TX clock.</p>
<p>43<br>00:03:49,000 –&gt; 00:03:52,000<br>Alright, that is TX, CLK.</p>
<p>44<br>00:03:52,000 –&gt; 00:04:01,000<br>The data that’s being sent, let’s say in this example, we’re going to, every time there’s a downward transition in the clock,</p>
<p>45<br>00:04:01,000 –&gt; 00:04:10,000<br>we’re going to change the data that’s put on the wire. So for example, let’s say that it started out idle, and then it went to a 1,</p>
<p>46<br>00:04:10,000 –&gt; 00:04:19,000<br>and then it went for a 1 here, and then it continued as a 1 in the data down to here, and then we wanted to send a 0,</p>
<p>47<br>00:04:19,000 –&gt; 00:04:30,000<br>and then a, and so on. So the data that’s being sent is 0, 1, 1, 0, 1, and then we’re sending another 1 again here.</p>
<p>48<br>00:04:30,000 –&gt; 00:04:39,000<br>And so, at the receiver, let’s look at the receiver’s clock, and let’s assume that the receiver’s clock is nominally running at the same frequency,</p>
<p>49<br>00:04:39,000 –&gt; 00:04:46,000<br>although we didn’t get exactly right, because we were generating it locally, and we were using a different oscillator, for example, in order to generate that.</p>
<p>50<br>00:04:46,000 –&gt; 00:04:51,000<br>And they were designed to be the same normally, but they’re very slightly different.</p>
<p>51<br>00:04:51,000 –&gt; 00:04:57,000<br>And so in this case, we’re going to assume that that receiver clock is operating just a tad slower.</p>
<p>52<br>00:04:57,000 –&gt; 00:05:06,000<br>So it may have its transition at the same place at the beginning, but because it’s running a little bit slower, its first transition is a little bit later than this one.</p>
<p>53<br>00:05:06,000 –&gt; 00:05:16,000<br>And so its next transition is a little bit later again, it’s going to get a little later, and then it’s going to get a little later, and then eventually, just because it’s running a little bit slower,</p>
<p>54<br>00:05:16,000 –&gt; 00:05:26,000<br>it’s going to start falling behind, and you can see that by the time we get all the way over to here, its upward transition is about the same time as the transmit clock’s downward transition.</p>
<p>55<br>00:05:26,000 –&gt; 00:05:34,000<br>So it’s about out by half a phase. Now I’ve exaggerated it here, in practice there’d be much closer than this, but I’m just exaggerating to show you what’s going on.</p>
<p>56<br>00:05:35,000 –&gt; 00:05:56,000<br>Okay, now the data on when we were sending it was being changed on the downward transition, and it kind of makes sense for the receiver to try and identify the middle of the bit and sample a bit in the middle, so here and here, and here if it can, because this is furthest away from the edges, and so the data is going to be at its most stable.</p>
<p>57<br>00:05:56,000 –&gt; 00:06:09,000<br>So we’re looking to look into sample that in the middle. So for example, if we started sampling here, right at the beginning from the receiver, we would pretty accurately detect that as a zero, so we would see that as a zero, and everything would be good.</p>
<p>58<br>00:06:09,000 –&gt; 00:06:18,000<br>Then we’re going to sample it again here, we’re a little later than we would have been than we would have liked, but we’re still going to reliably see that as a one, so things are good.</p>
<p>59<br>00:06:19,000 –&gt; 00:06:27,000<br>We’re going to sample it here, we’re getting a bit close to that edge, let’s give ourselves the benefit of the doubt and say that we just caught that one there.</p>
<p>60<br>00:06:27,000 –&gt; 00:06:37,000<br>By the time we come over here and sample again, we’re actually sampling right here, and we’re going to miss this zero completely, so when we sample here, we’re going to see a one again.</p>
<p>61<br>00:06:37,000 –&gt; 00:06:48,000<br>This was zero that happened in the middle, this zero that was sent here. We didn’t sample, though, we’re no up arrows during that bit period of the receiver, so we didn’t see it, we missed it completely.</p>
<p>62<br>00:06:48,000 –&gt; 00:07:01,000<br>So clearly our ability to detect this is going to depend on a couple of things. One is how different are these clocks? I really exaggerated the difference here, in practice they’re very, very similar within a fraction of a percent.</p>
<p>63<br>00:07:01,000 –&gt; 00:07:19,000<br>In fact, we usually use units of parts per million, ppm, parts per million. So for example, if we say that a clock is within plus or minus a hundred parts per million, we mean it’s within plus or minus that would be 0.01%.</p>
<p>64<br>00:07:19,000 –&gt; 00:07:31,000<br>That’s because that’s 10 to the minus 10 to the minus 4. So that would be a typical value. In fact, you can get clocks that are as much as close as 50 parts per million.</p>
<p>65<br>00:07:31,000 –&gt; 00:07:43,000<br>Still, if we go over enough bits, so if it’s 100 parts per million, we would have to go over about 10,000 bit times, and we would actually have shifted by a complete bit in either direction.</p>
<p>66<br>00:07:43,000 –&gt; 00:07:52,000<br>And we don’t know whether the receiver is running faster or slower than the transmitter, so we don’t know whether we’re going to accidentally double sample a bit, or we’re going to miss a bit completely.</p>
<p>67<br>00:07:52,000 –&gt; 00:08:06,000<br>Generally speaking though, they hold at a fairly constant frequency. In other words, if one is faster, it’s likely to stay faster for quite a while. They’re not drifting very quickly relative to each other, they may just have a fixed offset.</p>
<p>68<br>00:08:06,000 –&gt; 00:08:13,000<br>So here we see the problem where we’ve actually incorrectly decoded the data because we didn’t have the clock.</p>
<p>69<br>00:08:13,000 –&gt; 00:08:23,000<br>Now, in some cases, we can still communicate without having to explicitly understand what the clock is or be able to recover it.</p>
<p>70<br>00:08:25,000 –&gt; 00:08:35,000<br>In what’s called asynchronous communication. Although we don’t use this for networks like Ethernet, it’s used by things like infrared remote control for a TV.</p>
<p>71<br>00:08:35,000 –&gt; 00:08:45,000<br>Or for short communications. It’s also used on the serial bus that’s used to connect computers, although that’s not used very much anymore.</p>
<p>72<br>00:08:45,000 –&gt; 00:08:53,000<br>So for very short communications, so long as we know normally that the transmit and the receive clock are about the same, we can make this work.</p>
<p>73<br>00:08:53,000 –&gt; 00:08:58,000<br>So for example, imagine that we had a very short packet here consisting of just seven bits.</p>
<p>74<br>00:08:58,000 –&gt; 00:09:11,000<br>At the beginning, it has this big bit at the beginning, which looks like it has a bigger amplitude, just to tell us that this is the start of the packet, and there’s one at the end to tell us that it’s the end of the packet.</p>
<p>75<br>00:09:11,000 –&gt; 00:09:19,000<br>So the start bit, let’s stop it. Then we have the sequence 0, 1, 1, 0, 1, 0, 0. This is just the data inside the packet.</p>
<p>76<br>00:09:19,000 –&gt; 00:09:30,000<br>So the transmit clock, that’s what was used in order to encode this in the first place. That’s correctly detecting the middle of each of these bits.</p>
<p>77<br>00:09:30,000 –&gt; 00:09:36,000<br>0, 1, 1, right in the center of all those bits, because that’s what was used to transmit it in the first place.</p>
<p>78<br>00:09:36,000 –&gt; 00:09:41,000<br>And here might be the receive clock. The receive clock here is running a little slower than the transmit clock.</p>
<p>79<br>00:09:41,000 –&gt; 00:09:50,000<br>You can see that there’s a slight gap between here and here, and that gap is going to grow as we go on closer to the end of the bit.</p>
<p>80<br>00:09:50,000 –&gt; 00:10:02,000<br>So long as before we get to the end of the packet, the receiver, it can still correctly decode the bits, and here it’s correctly decode that 0.</p>
<p>81<br>00:10:02,000 –&gt; 00:10:09,000<br>Then we’re okay. So how did all of this work? Well, after the start bit, the receiver said,</p>
<p>82<br>00:10:09,000 –&gt; 00:10:21,000<br>I’m going to start sampling half a bit time later. So it sees that start bit, it sees that falling edge here, and then it times until it samples, and then it correctly samples the 0 here.</p>
<p>83<br>00:10:21,000 –&gt; 00:10:30,000<br>And then it waits for another clock period, and then it samples again, and it will correctly sample that one, and so on all the way to the end.</p>
<p>84<br>00:10:31,000 –&gt; 00:10:40,000<br>How you can see that if the packet was longer, because of this drift of the receive clock, it’s getting later and later and later, eventually it will miss a bit.</p>
<p>85<br>00:10:40,000 –&gt; 00:10:56,000<br>So so long as we can make sure that the packet is not too long, in other words, we control P, and if we know that the tolerance between these two clocks, the difference between them, then knowing those two numbers, we can make sure that we can reliably decode the packet.</p>
<p>86<br>00:10:56,000 –&gt; 00:11:14,000<br>So for short packets, this works fine. In practice though, this doesn’t work very well for long packets, because we’d like P to be thousands or hundreds of thousands of bits, and we would have to make the tolerance of the receive clock so tight that this would not be practical to do in a real system.</p>
<p>87<br>00:11:14,000 –&gt; 00:11:25,000<br>So asynchronous communication sometimes used for links with short packets, in for remote control or serial links, or for example, those connecting directly to a printer locally.</p>
<p>88<br>00:11:25,000 –&gt; 00:11:37,000<br>Okay, so we’ve seen how data is transmitted using a clock, and we’ve seen that the receiver needs to know when to sample the arriving data, and we’ve also seen an example of asynchronous communications.</p>
<p>89<br>00:11:37,000 –&gt; 00:11:44,000<br>Now we’re going to go under the real meet, which is the synchronous communications, which is what we use in practice.</p>
<p>90<br>00:11:44,000 –&gt; 00:11:50,000<br>Let me start with sort of a block diagram of how the system might look.</p>
<p>91<br>00:11:50,000 –&gt; 00:11:57,000<br>Don’t be intimidated. I’m going to go through each of these pieces in turn, and we’re going to understand what each of them is doing.</p>
<p>92<br>00:11:57,000 –&gt; 00:12:11,000<br>So the problem is different hosts, and here we have a server A that’s sending to the router on the right, different hosts are using locally generated clocks of normally the same frequency, but slightly different.</p>
<p>93<br>00:12:11,000 –&gt; 00:12:22,000<br>So we have 10 megahertz plus or minus 100 parts per million. Again, this example here is a 10 mega bit per second link, because I’m sending data using this 10 megahertz clock.</p>
<p>94<br>00:12:22,000 –&gt; 00:12:32,000<br>And I’m sending to the router, sending to my first router, of course this could be another host or an Ethernet switch, anything which is the other end of an Ethernet link.</p>
<p>95<br>00:12:32,000 –&gt; 00:12:44,000<br>When the data arrives, because I’m only sending one over one piece of wire, what the receiver is going to do is going to try and figure out the clock that was used by the sender.</p>
<p>96<br>00:12:44,000 –&gt; 00:12:55,000<br>And this is in what’s called a clock recovery unit or a clock recovery circuit. These are special circuits that take the incoming signal and determine the clock that was used by the sender.</p>
<p>97<br>00:12:55,000 –&gt; 00:13:02,000<br>It does this by examining the frequency and the phase of the arriving bits, so those bits that were on the wire.</p>
<p>98<br>00:13:02,000 –&gt; 00:13:15,000<br>So it’s going to look at the bits and say, aha, if I can actually detect when there’s a transition, then I can actually determine what the frequency was and actually where one bit starts and another bit and that bit ends.</p>
<p>99<br>00:13:15,000 –&gt; 00:13:18,000<br>So it’s able to recover this.</p>
<p>100<br>00:13:19,000 –&gt; 00:13:31,000<br>So when the bit pattern could be anything, if there’s a strong enough component in the spectrum from the sender’s clock of what its frequency was, then there’s a receiver will find it and use it to sample the bits.</p>
<p>101<br>00:13:31,000 –&gt; 00:13:44,000<br>There are many types of circuit that are used for clock recovery unit, but the most common one is called a phase lock loop or a PLL phase locked loop and delay lock loops called DLLs, that kind of a digital equivalent.</p>
<p>102<br>00:13:44,000 –&gt; 00:13:54,000<br>Or they could actually be a very precise filter. There’s something called a SOAR filter or a surface acoustic wave, which is also used as a clock recovery device.</p>
<p>103<br>00:13:54,000 –&gt; 00:14:04,000<br>In the next slide, I’m going to tell you about how we make life easier for this clock recovery unit by encoding the clock and the data together before we transmit it.</p>
<p>104<br>00:14:04,000 –&gt; 00:14:08,000<br>Let’s go on and see what the other pieces are here.</p>
<p>105<br>00:14:08,000 –&gt; 00:14:17,000<br>So there’s a flip flop that’s used at the receiver in order to clock that data in. And you can see that, let me just redraw that, here’s the flip flop.</p>
<p>106<br>00:14:17,000 –&gt; 00:14:29,000<br>And it’s being clocked using the senders clock. So in other words, we’ve figured out what this clock was in the clock recovery unit and we’re using that to clock here.</p>
<p>107<br>00:14:29,000 –&gt; 00:14:41,000<br>Even though we’ve used the senders clock in order to recover the data, eventually we need to process it using a clock that’s been generated locally using an oscillator that is running inside the router.</p>
<p>108<br>00:14:41,000 –&gt; 00:14:52,000<br>So it needs to be able to clock this in. And this is why we say that the clock that’s once we’ve moved it into the into the clock domain of the receiver, we call this the receive clock domain.</p>
<p>109<br>00:14:52,000 –&gt; 00:15:03,000<br>So up until this point here, this transition, this dotted line, we’re using the transmitters clock domain because we’ve recovered the senders clock. And so we’re operating using its clock.</p>
<p>110<br>00:15:03,000 –&gt; 00:15:15,000<br>But the clock of the transmitter is not much used to us at the receiver if we’re wanting to process the data in order to calculate check sums and retransmit the data according to our local clock.</p>
<p>111<br>00:15:15,000 –&gt; 00:15:23,000<br>So we have to somehow move from one domain to the other. We have to do this very carefully so that we don’t lose bits in between.</p>
<p>112<br>00:15:23,000 –&gt; 00:15:33,000<br>So once the data has been sampled by the flip flop, it’s placed into a small 5.0 and that’s the 5.0 shown here.</p>
<p>113<br>00:15:33,000 –&gt; 00:15:37,000<br>And this 5.0 is very critical to how the whole system works.</p>
<p>114<br>00:15:37,000 –&gt; 00:15:43,000<br>The 5.0 is another special circuit to help us take the bit from the senders clock domain into the receivers clock domain.</p>
<p>115<br>00:15:43,000 –&gt; 00:15:49,000<br>Why? Because we need to get the bit into the clock domain of the receiver so it can process the packet using its own clock.</p>
<p>116<br>00:15:49,000 –&gt; 00:15:57,000<br>To do this, the bit is written into the 5.0 so it’s written into the 5.0 here using the transmitters clock.</p>
<p>117<br>00:15:57,000 –&gt; 00:16:03,000<br>And then it’s read out of the 5.0 using the receivers clock.</p>
<p>118<br>00:16:03,000 –&gt; 00:16:09,000<br>So the 5.0 is different from the ones we used before where we assume that the clock is the same on both sides.</p>
<p>119<br>00:16:09,000 –&gt; 00:16:13,000<br>This 5.0 is very carefully designed to let us do this using two clocks.</p>
<p>120<br>00:16:13,000 –&gt; 00:16:21,000<br>Once the bit emerges on the other side, it is now in the clock domain of the receiver and we can safely process it using its clock.</p>
<p>121<br>00:16:21,000 –&gt; 00:16:29,000<br>This 5.0 is called an elasticity buffer.</p>
<p>122<br>00:16:29,000 –&gt; 00:16:43,000<br>And we call it an elasticity buffer because it’s taking up the slack between the two clocks and we’re going to see in a minute how this is going to go up and down according to the relative speeds of the two clocks.</p>
<p>123<br>00:16:43,000 –&gt; 00:16:51,000<br>And in a few minutes I’ll explain how we design the whole system so we never overflow or underflow this elasticity buffer.</p>
<p>124<br>00:16:51,000 –&gt; 00:17:00,000<br>But first, I’m going to describe how we encode the signal in the first place so that the clock can be recovered by this clock recovery unit.</p>
<p>125<br>00:17:00,000 –&gt; 00:17:11,000<br>If the clock was sent separately, as I described in an example earlier, as it would be on a circuit board of a computer or between different parts of a circuit on a chip, life would be pretty simple.</p>
<p>126<br>00:17:11,000 –&gt; 00:17:19,000<br>We could simply use the clock to feed into the flip flop and capture the bits in the same clock domain everywhere.</p>
<p>127<br>00:17:19,000 –&gt; 00:17:25,000<br>But if the clock is not sent separately, the data stream must have sufficient transitions in it.</p>
<p>128<br>00:17:25,000 –&gt; 00:17:34,000<br>We must make sure that there are enough transitions in it in order for the receiver to be able to determine the clock at the other end.</p>
<p>129<br>00:17:34,000 –&gt; 00:17:42,000<br>We might be looking at this and saying, what if I was to send a stream of all ones so that this actually was like this, it would have no transitions in it at all.</p>
<p>130<br>00:17:42,000 –&gt; 00:17:47,000<br>And so the receiver wouldn’t be able to determine what the clock is. So we need to prevent that from happening.</p>
<p>131<br>00:17:47,000 –&gt; 00:18:01,000<br>Likewise, if it was to send all zeros, there would be no transitions. Or if it was to send a signal that looked like this, that had that changed half as often as the clock, then we might be confused and believe that the clock frequency was half what in fact it was.</p>
<p>132<br>00:18:01,000 –&gt; 00:18:12,000<br>So we need to think about this carefully. And the method that is typically used is to encode the data and when we send it in order to make sure there are sufficient transitions.</p>
<p>133<br>00:18:12,000 –&gt; 00:18:20,000<br>So I’m going to start by describing what the original 10 megabit per second ethernet used. It used something called Manchester coding or Manchester encoding.</p>
<p>134<br>00:18:20,000 –&gt; 00:18:31,000<br>Manchester coding is a very, very simple mechanism. It’s used occasionally these days, not as much as it was and we’ll see why that is in a minute. But it’s perhaps the simplest one to understand.</p>
<p>135<br>00:18:31,000 –&gt; 00:18:40,000<br>Here at the top is the data that we want to send. So this is the 0-1-1-1, sorry, 0-1-1-0-1-1, which is the data that we want to send.</p>
<p>136<br>00:18:40,000 –&gt; 00:18:46,000<br>And the way that that’s going to be encoded before placing it onto the wire is as follows.</p>
<p>137<br>00:18:47,000 –&gt; 00:18:53,000<br>We’re going to look at the middle, we’re going to look at the bit and make sure that there is a transition during every bit time.</p>
<p>138<br>00:18:53,000 –&gt; 00:19:01,000<br>So this is this signal here is the one that’s going to go under the wire. Whenever we see a 0, we can have a downward transition.</p>
<p>139<br>00:19:01,000 –&gt; 00:19:11,000<br>Whenever we see a 1, we can have an upward transition. So here we can see 1 is encoded by an upward transition. 0 is encoded by a downward transition.</p>
<p>140<br>00:19:12,000 –&gt; 00:19:17,000<br>So this would be what would go on the line and then to make it a continuous signal, we do this.</p>
<p>141<br>00:19:17,000 –&gt; 00:19:24,000<br>Now notice I had to insert another transition here because I’ve got 1 followed by 1, so therefore I need to have a downward transition.</p>
<p>142<br>00:19:24,000 –&gt; 00:19:32,000<br>And here I’ve got 1 followed by a 0, so I need to have a downward transition here. So this would be the sequence that I would send on the wire.</p>
<p>143<br>00:19:33,000 –&gt; 00:19:39,000<br>Then the clock that I would use at the far end can be recovered by just looking for the transitions.</p>
<p>144<br>00:19:39,000 –&gt; 00:19:49,000<br>See I’ve got a transition here, I’ve got a transition here, so whenever I see a transition I can be sure that I can use that to have a nice strong and easy way to recover the clock.</p>
<p>145<br>00:19:49,000 –&gt; 00:19:57,000<br>I must make sure that I’m not confused, I mustn’t see this transition as representing another upbeat on the clock at the other end.</p>
<p>146<br>00:19:57,000 –&gt; 00:20:05,000<br>But I could do that by just having a finely tuned filter at the other end because I know that normally I’m looking for a 10 megabit per second clock.</p>
<p>147<br>00:20:05,000 –&gt; 00:20:10,000<br>And so I’m not going to confuse it with one that’s running at twice the speed.</p>
<p>148<br>00:20:10,000 –&gt; 00:20:18,000<br>So by having a nice healthy set of transitions in the middle of the signal I can be sure that it’s easy to recover it at the other end.</p>
<p>149<br>00:20:18,000 –&gt; 00:20:23,000<br>So the advantages of this Manchester encoding is it guarantees one transition per bit period.</p>
<p>150<br>00:20:23,000 –&gt; 00:20:30,000<br>It has a second benefit which is a little bit more subtle. It does something which is called ensuring the DC balance.</p>
<p>151<br>00:20:30,000 –&gt; 00:20:41,000<br>If I send those as voltage levels on the wire with that was zero and this was plus and this was minus, this was minus.</p>
<p>152<br>00:20:41,000 –&gt; 00:20:50,000<br>I’m actually sending just as many, just as much spending, just as much of the time above that line as I am below it.</p>
<p>153<br>00:20:50,000 –&gt; 00:20:55,000<br>And so I’m making sure that I get DC balance in the long term.</p>
<p>154<br>00:20:55,000 –&gt; 00:21:05,000<br>The benefit of this is that in order to be able to correctly differentiate a one and a zero at the other end, I just need to set my threshold to be in the middle or the average on the wire.</p>
<p>155<br>00:21:05,000 –&gt; 00:21:10,000<br>So that makes it for a very reliable and robust recovery of bits at the far end.</p>
<p>156<br>00:21:10,000 –&gt; 00:21:16,000<br>There’s a clear disadvantage of Manchester encoding and that I’m inserting more transitions than I actually need.</p>
<p>157<br>00:21:16,000 –&gt; 00:21:21,000<br>I’m doubling the bandwidth in the worst case.</p>
<p>158<br>00:21:21,000 –&gt; 00:21:33,000<br>I’m doubling the bandwidth because by having more transitions, if I was to send a sequence of all ones, I would actually have a sequence of these where I’ve got twice as many transitions as I really need.</p>
<p>159<br>00:21:33,000 –&gt; 00:21:42,000<br>So by doubling the bandwidth, I would have a dominant frequency component with the signal that has been increased.</p>
<p>160<br>00:21:42,000 –&gt; 00:21:46,000<br>So we’re running over a cable and trying to make it as fast as we can. This is a problem.</p>
<p>161<br>00:21:46,000 –&gt; 00:21:51,000<br>We’ve now wasted some of the pressure span with on the wire.</p>
<p>162<br>00:21:51,000 –&gt; 00:21:54,000<br>Let’s look at what this spectrum looks like.</p>
<p>163<br>00:21:54,000 –&gt; 00:21:57,000<br>This is the frequency spectrum for 10 megabits per second.</p>
<p>164<br>00:21:57,000 –&gt; 00:22:04,000<br>So in other words, if we take it into a spectrum analyzer, something that will tell us the signal strength as a function of the frequency.</p>
<p>165<br>00:22:04,000 –&gt; 00:22:09,000<br>And if we were to take the original bit sequence, we would see something like this.</p>
<p>166<br>00:22:09,000 –&gt; 00:22:24,000<br>We would see at different frequencies. So this frequency here is the five megahertz, which is the average when I’ve got a sequence of zeros and ones, but a random sequence of zeros and ones.</p>
<p>167<br>00:22:24,000 –&gt; 00:22:32,000<br>I would see some frequency component around here, but it’s not strong enough to find it and lock onto it and know that that was the frequency of the clock.</p>
<p>168<br>00:22:32,000 –&gt; 00:22:41,000<br>However, if I look at it with Manchester encoding, I see what suddenly emerges is this strong component at 10 megahertz.</p>
<p>169<br>00:22:41,000 –&gt; 00:22:47,000<br>Everything has been moved up in the frequency band because I’ve encoded it and inserted more transitions.</p>
<p>170<br>00:22:47,000 –&gt; 00:22:54,000<br>So the spectrum itself is starting at five megahertz roughly now. There’ll be a little bit down here for long sequences of zeros or ones.</p>
<p>171<br>00:22:54,000 –&gt; 00:22:59,000<br>But I’m seeing that most of that spectrum is now above five megahertz.</p>
<p>172<br>00:22:59,000 –&gt; 00:23:06,000<br>It makes it very easy for clock recovery because I just need to find this dominant component and then use it as my clock at the far end.</p>
<p>173<br>00:23:06,000 –&gt; 00:23:11,000<br>So Manchester encoding it makes it nice easy, nice and easy.</p>
<p>174<br>00:23:11,000 –&gt; 00:23:26,000<br>As a second example, if I wanted to use something that was a little bit more efficient than Manchester encoding, I can take successive numbers, successive blocks of bits and encode them in a way to make sure I’ve got some transitions, but maybe not twice as many as I had before.</p>
<p>175<br>00:23:26,000 –&gt; 00:23:34,000<br>This is in this example, I will describe something called 4B5B encoding. There are variants of this 8B10B, 15B, 16B.</p>
<p>176<br>00:23:34,000 –&gt; 00:23:43,000<br>4B means it’s 4B of original data that I wanted to send and I’m going to encode that into a 5-bit code.</p>
<p>177<br>00:23:43,000 –&gt; 00:23:49,000<br>So just as an example here, I took 0, 0, 0, 0 and I encoded as 1, 1, 1, 1, 1, 0.</p>
<p>178<br>00:23:49,000 –&gt; 00:23:56,000<br>So I’m guaranteed if I send this on the wire of 1, 1, 1, 1, 0.</p>
<p>179<br>00:23:56,000 –&gt; 00:24:00,000<br>So this would be the 1, 1, 1, 1, 0.</p>
<p>180<br>00:24:00,000 –&gt; 00:24:03,000<br>I’m guaranteed that there is a downward transition during that code.</p>
<p>181<br>00:24:03,000 –&gt; 00:24:09,000<br>This code has two transitions in it, or actually three, from 0 to 1, 1 to 0, and then 0 to 1 again.</p>
<p>182<br>00:24:09,000 –&gt; 00:24:11,000<br>This one has from 1 to 0, 0 to 1.</p>
<p>183<br>00:24:11,000 –&gt; 00:24:16,000<br>So I can be sure always that there are some transitions within that 5 bits.</p>
<p>184<br>00:24:16,000 –&gt; 00:24:23,000<br>If I know that at the far end, then there will be enough transitions. Then whatever the data originally included,</p>
<p>185<br>00:24:23,000 –&gt; 00:24:28,000<br>I can make sure that I’ve got enough transitions to be able to recover the clock at the far end.</p>
<p>186<br>00:24:28,000 –&gt; 00:24:34,000<br>Why can I be sure that there are transitions? Well, there are two to the four, or 16 data codes,</p>
<p>187<br>00:24:34,000 –&gt; 00:24:38,000<br>and there are two to the five, or 32 codes that I’m going to put onto the wire.</p>
<p>188<br>00:24:38,000 –&gt; 00:24:42,000<br>I’m just going to select those ones that have enough transitions.</p>
<p>189<br>00:24:42,000 –&gt; 00:24:48,000<br>So there are twice as many to choose from. I can always be sure to find a code that has a transition in it.</p>
<p>190<br>00:24:48,000 –&gt; 00:24:54,000<br>So I can be sure that the outgoing data that I put onto the wire has enough transitions in it.</p>
<p>191<br>00:24:54,000 –&gt; 00:25:02,000<br>Comes at an overhead. It’s more bandwidth efficient than Manchester encoding, but it has a 25% overhead.</p>
<p>192<br>00:25:02,000 –&gt; 00:25:06,000<br>But that’s certainly much better than having a double overhead.</p>
<p>193<br>00:25:06,000 –&gt; 00:25:13,000<br>I’m actually left with some extra codes, and some people will use these for some in-band control signals.</p>
<p>194<br>00:25:13,000 –&gt; 00:25:21,000<br>So I’m actually end up with 16 codes that I didn’t actually need, because I’ve taken from four bits to five bits.</p>
<p>195<br>00:25:21,000 –&gt; 00:25:26,000<br>Fewer transition definitely make the clock recovery harder than for Manchester encoding,</p>
<p>196<br>00:25:26,000 –&gt; 00:25:31,000<br>but this has been around long enough that people have developed clever circuits in order to be able to do this.</p>
<p>197<br>00:25:31,000 –&gt; 00:25:38,000<br>So the 4B5B and variants of this block coding is very commonly used today.</p>
<p>198<br>00:25:38,000 –&gt; 00:25:47,000<br>So in summary, I have a system that looks like this. We’ve seen the clock that’s being used here.</p>
<p>199<br>00:25:47,000 –&gt; 00:25:52,000<br>I’ve now got encoded data. So this would be the encoded data that I’m sending.</p>
<p>200<br>00:25:52,000 –&gt; 00:25:57,000<br>Could be 4B5B or Manchester encoded. It goes out over the link.</p>
<p>201<br>00:25:57,000 –&gt; 00:26:04,000<br>The clock recovery unit is going to determine what the clock was that was used at the sender by examining the transitions.</p>
<p>202<br>00:26:04,000 –&gt; 00:26:10,000<br>We’ll use that to clock the data in, and then it’s going to put it into this elasticity buffer right here.</p>
<p>203<br>00:26:10,000 –&gt; 00:26:17,000<br>In the next video, I’m going to be describing how this elasticity buffer works and how we can size it correctly.</p>
<p>204<br>00:26:17,000 –&gt; 00:26:23,000<br>But for now, we’ve seen how we send data and how we can recover it.</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div></div>
      <div>http://example.com/2025/10/23/CS144-networkP977-3PhysicalandLink/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月23日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/23/CS144-networkP987-4PhysicalandLinkPrinciples/" title="">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/23/CS144-networkP967-2PhysicalandLinkPrinciples/" title="">
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
