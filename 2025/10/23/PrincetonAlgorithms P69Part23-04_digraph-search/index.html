

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="100:00:00,000 –&gt; 00:00:08,000Okay, first we’re going to look at the search algorithm for 200:00:08,000 –&gt; 00:00:13,000digraphs. And this is the finding the paths or 300:00:13,000 –&gt; 00:00:19,">
<meta property="og:type" content="article">
<meta property="og:title" content="PrincetonAlgorithms P69Part23 04_digraph Search">
<meta property="og:url" content="http://example.com/2025/10/23/PrincetonAlgorithms%20P69Part23-04_digraph-search/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="100:00:00,000 –&gt; 00:00:08,000Okay, first we’re going to look at the search algorithm for 200:00:08,000 –&gt; 00:00:13,000digraphs. And this is the finding the paths or 300:00:13,000 –&gt; 00:00:19,">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-23T14:33:27.240Z">
<meta property="article:modified_time" content="2025-10-23T14:34:26.510Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>PrincetonAlgorithms P69Part23 04_digraph Search - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="PrincetonAlgorithms P69Part23 04_digraph Search"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-23 22:33" pubdate>
          2025年10月23日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          1.7k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          14 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">PrincetonAlgorithms P69Part23 04_digraph Search</h1>
            
            
              <div class="markdown-body">
                
                <p>1<br>00:00:00,000 –&gt; 00:00:08,000<br>Okay, first we’re going to look at the search algorithm for</p>
<p>2<br>00:00:08,000 –&gt; 00:00:13,000<br>digraphs. And this is the finding the paths or</p>
<p>3<br>00:00:13,000 –&gt; 00:00:19,000<br>what are all the vertices that we can get to from a given vertex along a directed path.</p>
<p>4<br>00:00:19,000 –&gt; 00:00:25,000<br>And again, this is a little more complex for a digraph that would seem</p>
<p>5<br>00:00:25,000 –&gt; 00:00:33,000<br>then for a graph. So in this case, that’s a set of vertices that you can get to from the given vertex</p>
<p>6<br>00:00:33,000 –&gt; 00:00:42,000<br>x. Yes, notice that this set is characterized by every edge crossing the boundary goes in.</p>
<p>7<br>00:00:42,000 –&gt; 00:00:48,000<br>If there were an edge that went out, that would give another member of the set.</p>
<p>8<br>00:00:49,000 –&gt; 00:00:57,000<br>Well, actually, it looks more complicated to a human, but to the computer, it looks exactly precisely the same.</p>
<p>9<br>00:00:57,000 –&gt; 00:01:06,000<br>In fact, the method that we looked at for undirected graphs is actually a digraph processing algorithm.</p>
<p>10<br>00:01:06,000 –&gt; 00:01:15,000<br>It treats every connection between two vertices as two directed edges, one in each direction.</p>
<p>11<br>00:01:15,000 –&gt; 00:01:23,000<br>So, DFS that we looked at last time is actually a digraph algorithm, and we use precisely the same code.</p>
<p>12<br>00:01:23,000 –&gt; 00:01:34,000<br>So the visitor vertex v, we mark the vertex is visited and recursively visit all unmarked vertices w that you can get to from v.</p>
<p>13<br>00:01:34,000 –&gt; 00:01:40,000<br>Let’s look at the demo just to reinforce that.</p>
<p>14<br>00:01:41,000 –&gt; 00:01:49,000<br>So here’s a sampled digraph with the edges over at the right. Let’s look at depth first search on that digraph.</p>
<p>15<br>00:01:49,000 –&gt; 00:01:55,000<br>So we’re going to look at the vertices that we can get to from vertex 0 in this digraph.</p>
<p>16<br>00:01:55,000 –&gt; 00:02:07,000<br>Again, we have two vertex indexed arrays, one called marked, which says whether we can get there from v, and the other called edge 2, which gives us the vertex that took us there.</p>
<p>17<br>00:02:08,000 –&gt; 00:02:15,000<br>With that, we can recover the paths from vertex 0 to each vertex, then can we reach from vertex 0.</p>
<p>18<br>00:02:15,000 –&gt; 00:02:25,000<br>So we start off by visiting vertex 0, and now check the edges that are adjacent to it with directed edges going out.</p>
<p>19<br>00:02:25,000 –&gt; 00:02:33,000<br>So there’s 5, and then there’s going to be 1, but 5 is unmarked, so we have to recursively visit 5.</p>
<p>20<br>00:02:33,000 –&gt; 00:02:37,000<br>So we mark 5, and we say we got there from 0.</p>
<p>21<br>00:02:37,000 –&gt; 00:02:44,000<br>So the path from to 5 is 0 to 5.</p>
<p>22<br>00:02:44,000 –&gt; 00:02:51,000<br>And so now we’re going to recursively visit all the unmarked vertices, 0.2 from 5.</p>
<p>23<br>00:02:51,000 –&gt; 00:03:00,000<br>In this case, it’s just 4. My 4 is unmarked, so we’re going to recursively visit 4 and say we got there from 5.</p>
<p>24<br>00:03:00,000 –&gt; 00:03:06,000<br>And now recursively, we have to check all the unmarked vertices pointing from 4.</p>
<p>25<br>00:03:06,000 –&gt; 00:03:11,000<br>There’s 3 and 2. First, we do 3, and that’s unmarked.</p>
<p>26<br>00:03:11,000 –&gt; 00:03:16,000<br>So we’ve got to visit 3 and say that we got there from 4.</p>
<p>27<br>00:03:16,000 –&gt; 00:03:21,000<br>And now to visit 3, we looked at all the vertices pointing from 3.</p>
<p>28<br>00:03:21,000 –&gt; 00:03:27,000<br>We can check 5. We’ve already been to 5. That’s marked, so we don’t have to do anything.</p>
<p>29<br>00:03:27,000 –&gt; 00:03:35,000<br>And then we check 2. 2 is unmarked, so we continue with the depth first search and visit 2.</p>
<p>30<br>00:03:35,000 –&gt; 00:03:39,000<br>So now to visit, we mark 2 and say we got there from 3.</p>
<p>31<br>00:03:39,000 –&gt; 00:03:43,000<br>And now we check the vertices we can get to from 2.</p>
<p>32<br>00:03:43,000 –&gt; 00:03:48,000<br>In this case, it’s 0, which we’ve already been to, and 3, which we’ve already been to.</p>
<p>33<br>00:03:48,000 –&gt; 00:03:58,000<br>So now we’re done with vertex 2, and we can return and continue the search from 3.</p>
<p>34<br>00:03:58,000 –&gt; 00:04:02,000<br>Well, actually, that was the last one from 3, so we’re done with 3 as well.</p>
<p>35<br>00:04:02,000 –&gt; 00:04:07,000<br>So now we’re at 4. We still haven’t checked the edge from 4 to 2.</p>
<p>36<br>00:04:07,000 –&gt; 00:04:12,000<br>So now we do that. And of course, we’ve been to 2, so we don’t have any further processing.</p>
<p>37<br>00:04:12,000 –&gt; 00:04:15,000<br>And we’re done with 4.</p>
<p>38<br>00:04:16,000 –&gt; 00:04:22,000<br>4 was the only edge we get to from 5, so we’re going to be done with 5 as well.</p>
<p>39<br>00:04:22,000 –&gt; 00:04:33,000<br>And then what about 0? Well, we have to check 1. 1’s not visited, so we visit 1 market, and we turn, and then we’re done with 0.</p>
<p>40<br>00:04:33,000 –&gt; 00:04:39,000<br>And that gives the set of all vertices that are reachable from 0.</p>
<p>41<br>00:04:39,000 –&gt; 00:04:53,000<br>And not only that, the edge 2 array gives the information that we need to reconstruct a path from any of those, from 0 to any of those vertices using precisely the same method that we used before.</p>
<p>42<br>00:04:53,000 –&gt; 00:05:02,000<br>We get to 4 from 5, we get to 5 from 0, so 0, 5, 4 is a path to 4, and we can do that for any vertex in that set.</p>
<p>43<br>00:05:02,000 –&gt; 00:05:11,000<br>Okay, so what about the code? The code is exactly the same as for undirected graphs.</p>
<p>44<br>00:05:11,000 –&gt; 00:05:18,000<br>That’s the code for undirected graphs that we looked at last time to get the code for diagrams. We just change the names.</p>
<p>45<br>00:05:18,000 –&gt; 00:05:21,000<br>It’s the same code, otherwise.</p>
<p>46<br>00:05:21,000 –&gt; 00:05:36,000<br>The recursive constructor builds the array of marked vertices, and also builds edge 2, just to avoid clutter, left that one off this slide, and then it makes the call on DFS.</p>
<p>47<br>00:05:36,000 –&gt; 00:05:45,000<br>Then the recursive DFS does the work. It marks the vertex, and for every adjacent vertex, if it’s not marked, it does the DFS.</p>
<p>48<br>00:05:45,000 –&gt; 00:05:53,000<br>And then the client can ask whether any given vertex is reachable from us after the constructor has done its work.</p>
<p>49<br>00:05:53,000 –&gt; 00:05:58,000<br>That’s depth-first search in directed graphs, actually, we already did it.</p>
<p>50<br>00:05:58,000 –&gt; 00:06:04,000<br>Now, here’s just a couple of applications where this kind of code is used.</p>
<p>51<br>00:06:04,000 –&gt; 00:06:21,000<br>One is so-called program control flow analysis. Actually, every program can be viewed as a diagram where vertices are basic blocks of instructions that are just executed one after another with no conditionals.</p>
<p>52<br>00:06:21,000 –&gt; 00:06:32,000<br>Then, edges represent a jump if there’s an if statement vertex left two edges going out of it or a loop, which involves a conditional.</p>
<p>53<br>00:06:32,000 –&gt; 00:06:43,000<br>So, analyzing the program, people write systems to analyze programs to look at their structure by studying the diagrams.</p>
<p>54<br>00:06:43,000 –&gt; 00:06:59,000<br>For example, one thing that happens often is there’s unreachable code. Another thing you might want to do is determine whether you can get to the exit or not by doing this die-graph processing.</p>
<p>55<br>00:07:00,000 –&gt; 00:07:14,000<br>So, that’s actually a widely used technique in development software system development to try to improve code by doing this kind of die-graph processing.</p>
<p>56<br>00:07:14,000 –&gt; 00:07:38,000<br>And, of course, these die-graphs can be huge. Another classic use of depth-first search in die-graphs is garbage collection that’s used in systems like Java, where data structures or die-graphs, we build objects, and then we create references to other objects.</p>
<p>57<br>00:07:38,000 –&gt; 00:08:00,000<br>And so, the data that any program is used is really set as a die-graph. So, there’s the idea of roots. So, your program has some live objects that it can access through whatever state it’s in.</p>
<p>58<br>00:08:00,000 –&gt; 00:08:20,000<br>But, language like Java, there’s automatic garbage collection, which means the programmer, when it’s done with an object, maybe it overrides one of these pointers or something, there’s going to be some blocks that are not directly accessible by the program.</p>
<p>59<br>00:08:21,000 –&gt; 00:08:31,000<br>And so, what’s interesting is the set of reachable objects that can be indirectly accessed by the program, starting and following a chain of pointers.</p>
<p>60<br>00:08:32,000 –&gt; 00:08:39,000<br>So, those are the ones that can’t be collected or reclaimed by the system for reusing the memory.</p>
<p>61<br>00:08:39,000 –&gt; 00:08:52,000<br>But, all the other ones, the gray ones, they can’t be reached by the program. There’s no reason to keep them live, may as well collect them and return them for reuse.</p>
<p>62<br>00:08:53,000 –&gt; 00:09:13,000<br>So, this is so-called Mark and Sweep algorithm that actually dates back to 1960, where they run DFS to mark all reachable objects and then go through and sweep through all possible objects, and if it’s object is unmarked, it’s garbage so added to the list of free memory.</p>
<p>63<br>00:09:14,000 –&gt; 00:09:30,000<br>And that’s a classic method that’s still widely used. It uses an extra bit per object because you have to have that for the Mark, but still it’s an effective and useful die-graph solution.</p>
<p>64<br>00:09:31,000 –&gt; 00:09:46,000<br>So, DFS with reachability that we just showed in pathfinding is similar, and there’s a couple of other simple die-graph problems that we’ll consider. These are so far examples.</p>
<p>65<br>00:09:47,000 –&gt; 00:09:55,000<br>But, it’s also interesting that DFS is the basis for solving die-graph problems that are not so simple or immediate to solve.</p>
<p>66<br>00:09:56,000 –&gt; 00:10:11,000<br>And this was pointed out 40 years ago by Bob Tarjan in the seminal paper that showed that deaf first search can allow us to solve problems that seem pretty complicated actually in linear time.</p>
<p>67<br>00:10:12,000 –&gt; 00:10:16,000<br>And we’re going to look at an example of that later on.</p>
<p>68<br>00:10:17,000 –&gt; 00:10:31,000<br>So, that’s deaf first search. What about rep first search? Well, in the same way that we saw for deaf first search, every undirected graph is actually a die-graph that has edges in both direction.</p>
<p>69<br>00:10:32,000 –&gt; 00:10:45,000<br>So, BFS is really a directed graph algorithm, and we can use exactly the same code to find shortest paths from a source to any given vertex.</p>
<p>70<br>00:10:46,000 –&gt; 00:10:59,000<br>So, we use a queue. We put the source on a queue and market is visited. And then as long as the queue is non-empty, we remove the least recently added vertex and add to the queue.</p>
<p>71<br>00:10:59,000 –&gt; 00:11:05,000<br>And then the market is visited all the unmarked vertices that you can get to from that vertex.</p>
<p>72<br>00:11:06,000 –&gt; 00:11:19,000<br>And the same proof shows that BFS can compute shortest paths, the ones with the fewest number of edges, from S to each other vertex in a die-graph in time proportional to in linear time.</p>
<p>73<br>00:11:20,000 –&gt; 00:11:28,000<br>So, you want the GPS in your car to use BFS when driving around lower Manhattan.</p>
<p>74<br>00:11:29,000 –&gt; 00:11:38,000<br>So, let’s look at a demo. Again, just to see the distinction between breadth first search in die-graphs and see how it works.</p>
<p>75<br>00:11:39,000 –&gt; 00:11:46,000<br>So, this is a smaller die-graph again with six vertices in eight edges.</p>
<p>76<br>00:11:47,000 –&gt; 00:11:52,000<br>We take a queue and we take our source vertex and put it on the queue to get started.</p>
<p>77<br>00:11:53,000 –&gt; 00:12:00,000<br>Then, a queue is non-empty, so we remove zero and we check all the vertices that are adjacent that we get to.</p>
<p>78<br>00:12:01,000 –&gt; 00:12:06,000<br>So, we’re going to, in zero is zero distance from zero.</p>
<p>79<br>00:12:08,000 –&gt; 00:12:18,000<br>So, first we’ll check two. And that one is not marked. Now, so we mark it and put it on the queue.</p>
<p>80<br>00:12:19,000 –&gt; 00:12:24,000<br>And then we’ll check one and that one’s not marked, so we mark it and put it on the queue.</p>
<p>81<br>00:12:25,000 –&gt; 00:12:27,000<br>Then, we’re done with zero.</p>
<p>82<br>00:12:28,000 –&gt; 00:12:33,000<br>Now, queues non-empty, so we pull the least recently added off. That’s two.</p>
<p>83<br>00:12:34,000 –&gt; 00:12:38,000<br>And now, we’re going to check the vertices you can get to from two.</p>
<p>84<br>00:12:39,000 –&gt; 00:12:43,000<br>Notice, both one and two are distance one from zero.</p>
<p>85<br>00:12:44,000 –&gt; 00:12:49,000<br>And now, since we’re going from two, everything that we encounter will be distance two from the source.</p>
<p>86<br>00:12:50,000 –&gt; 00:12:54,000<br>So, we find four. It’s distance two from the source and we get there from vertex two.</p>
<p>87<br>00:12:55,000 –&gt; 00:12:59,000<br>Unmarked. So, we fill in those data structures and put it on the queue.</p>
<p>88<br>00:13:01,000 –&gt; 00:13:06,000<br>And then, we’re done with two. So, we go back to the queue in ones on the queue.</p>
<p>89<br>00:13:07,000 –&gt; 00:13:09,000<br>So, we pull one off. It’s distance one from zero.</p>
<p>90<br>00:13:10,000 –&gt; 00:13:17,000<br>Remember, the proofs showed that everything on the queue is one of two distance, either k or k plus one.</p>
<p>91<br>00:13:18,000 –&gt; 00:13:21,000<br>In this case, we’ve got one at distance one and four at distance two.</p>
<p>92<br>00:13:22,000 –&gt; 00:13:28,000<br>So, now, we’re going to pull one off the queue and look at the edges. You can get two places you can get two from one.</p>
<p>93<br>00:13:29,000 –&gt; 00:13:34,000<br>Now, we check two, but that’s already marked. So, we ignore it. And then, we’re done with one.</p>
<p>94<br>00:13:35,000 –&gt; 00:13:44,000<br>And now, four is left on the queue. So, we pull it off and check Jason vertices. In this case three, it’s unmarked.</p>
<p>95<br>00:13:45,000 –&gt; 00:13:52,000<br>So, we put it on the queue. Then, we’re done with four. Then, from three, we check five. And that’s unmarked.</p>
<p>96<br>00:13:53,000 –&gt; 00:14:01,000<br>And it’s one more distance from the source. So, we put it on the queue. And then finally, oh, we check two, which are already visited.</p>
<p>97<br>00:14:02,000 –&gt; 00:14:06,000<br>So, we don’t have to do anything. And then, finally, we pull five off the queue.</p>
<p>98<br>00:14:07,000 –&gt; 00:14:11,000<br>We check where you get two from five and a zero, which is marked. So, we’re done.</p>
<p>99<br>00:14:12,000 –&gt; 00:14:23,000<br>And so, that’s breadth for search, which gives us this directed tree from the source, which gives the shortest path to all the vertices that you can get to from that source.</p>
<p>100<br>00:14:24,000 –&gt; 00:14:31,000<br>Now, you can use a version of this to solve a more general problem known as the multiple source shortest paths problem.</p>
<p>101<br>00:14:32,000 –&gt; 00:14:42,000<br>In this problem, you’re given a diagram and a set of source vertices. And you want to find the shortest path from any vertex in the set to each other vertex.</p>
<p>102<br>00:14:43,000 –&gt; 00:14:56,000<br>So, for example, in this case, if the set is one, seven, and ten, what’s the shortest path to four from one of those vertices? Well, it turns out in this case to be seven, six, to four.</p>
<p>103<br>00:14:57,000 –&gt; 00:15:10,000<br>Shortest path to five is seven, six, zero, five. Shortest path to twelve is ten to twelve. That’s a more general problem, but it’s actually easy to solve.</p>
<p>104<br>00:15:11,000 –&gt; 00:15:23,000<br>How do we implement this? We just use a different constructor. We just use BFS, but initialize by put all the source vertices on the queue to get started.</p>
<p>105<br>00:15:24,000 –&gt; 00:15:36,000<br>So, that is every vertex is put those on the queue and they’re zero from the desired source, and then any vertex you can get to from any one of those is going to be one and so forth.</p>
<p>106<br>00:15:37,000 –&gt; 00:15:48,000<br>So, the result still gives away the edge to array will still give away to get from any vertex, the shortest way to get from any vertex to each of the source vertices.</p>
<p>107<br>00:15:49,000 –&gt; 00:16:06,000<br>Here’s an application of breadth for search. Let’s say you want to crawl the whole web, while all the web that you can access from some starting web page, say like Princeton’s starting web page.</p>
<p>108<br>00:16:07,000 –&gt; 00:16:21,000<br>Again, the diegraph model, each vertex is a web page, each edge is a link on that web page to some other web page, and so all we want to do is get to all the other vertices on the web.</p>
<p>109<br>00:16:22,000 –&gt; 00:16:39,000<br>And so, solution is, well, we don’t actually build the diegraph. We just use an implicit diegraph because for every web page, we can find the links to other web pages on it, and we’ll just build those as we encounter them.</p>
<p>110<br>00:16:40,000 –&gt; 00:16:49,000<br>So, we’re going to start with a source, which is the root web page. We’re going to have a queue of the sites that we still need to explore.</p>
<p>111<br>00:16:50,000 –&gt; 00:17:07,000<br>What we’re going to do is also have a set of discovered websites. This corresponds to our marked array, but since we don’t know how many vertices there are on the web, all we’re going to do is keep track of the ones that we’ve been to.</p>
<p>112<br>00:17:08,000 –&gt; 00:17:20,000<br>So, we don’t use a vertex index to array. We don’t even bother with because we’ll just use the vertex names and do the look up as indicated we could do.</p>
<p>113<br>00:17:21,000 –&gt; 00:17:36,000<br>So, all we do is, in the use-bred first search, the same method is, if the queue’s non-empty, pick a website off the queue and just add to the queue all the websites to which it links.</p>
<p>114<br>00:17:36,000 –&gt; 00:17:51,000<br>But all those websites, you check whether they’re in the set of the ones that you’ve seen already. Now, you might run out of space for this set before you get to the whole web, but anyway, conceptually, this is a way that you could go.</p>
<p>115<br>00:17:51,000 –&gt; 00:17:58,000<br>One thing to think about is, why not use DFS for this?</p>
<p>116<br>00:17:59,000 –&gt; 00:18:23,000<br>Well, one reason is you’re going to go far away in your search for the web. Maybe that’s what you want. But the real problem in point of fact is there’s some web pages that would trap such as search by creating new web pages and make links to them the first time that you visit them.</p>
<p>117<br>00:18:23,000 –&gt; 00:18:34,000<br>So, they trap searches like that because DFS would always go to a new web page like that and it would keep creating new ones and you wouldn’t get very far.</p>
<p>118<br>00:18:34,000 –&gt; 00:18:45,000<br>With Bred for a search, you’re taking a wide search of the pages that are close and that’s often maybe what you want for such a search.</p>
<p>119<br>00:18:45,000 –&gt; 00:18:58,000<br>And just to show how simple the idea is, this is a complete code for a kind of a bare bones web crawler, but it’ll get to a lot of websites.</p>
<p>120<br>00:18:58,000 –&gt; 00:19:12,000<br>So, let’s look at, and we do this example because again, it really indicates the power of using appropriate abstractions to implement the algorithms that we’re interested in.</p>
<p>121<br>00:19:13,000 –&gt; 00:19:24,000<br>So, this one, we’re going to use a queue, queue of strings. So, that’s the websites that we have to still yet to go to.</p>
<p>122<br>00:19:24,000 –&gt; 00:19:31,000<br>And then a set of strings is going to be the ones that we’ve already been to. That’s equivalent to the marked array.</p>
<p>123<br>00:19:32,000 –&gt; 00:19:44,000<br>We’ll start with Princeton’s website, add it to the queue of places we have to go and also mark it. Discover.ad just means a market.</p>
<p>124<br>00:19:44,000 –&gt; 00:19:55,000<br>So, now, while the queue’s not empty, what we’re going to do is read the raw HTML from the next website in the queue.</p>
<p>125<br>00:19:55,000 –&gt; 00:20:09,000<br>So, this is code using our input library that gets that job done. And then this is a little fooling around with regular expressions.</p>
<p>126<br>00:20:09,000 –&gt; 00:20:19,000<br>We’ll talk about algorithms like this later on that essentially tries to find all URLs within the text of that website.</p>
<p>127<br>00:20:19,000 –&gt; 00:20:26,000<br>And for all of those URLs, and we’ll look at what goes behind this code later on in the course.</p>
<p>128<br>00:20:26,000 –&gt; 00:20:34,000<br>For all those URLs, it’s going to check if it’s marked, that’s discovered.contains.</p>
<p>129<br>00:20:34,000 –&gt; 00:20:40,000<br>And if it’s not marked, it’ll say it’ll mark it and put it on the queue.</p>
<p>130<br>00:20:40,000 –&gt; 00:20:48,000<br>A very simple program with a very powerful effect that illustrates breadth first search.</p>
<p>131<br>00:20:49,000 –&gt; 00:20:54,000<br>And then, we’ll look at the code.</p>
<p>132<br>00:20:54,000 –&gt; 00:20:59,000<br>And then, we’ll look at the code.</p>
<p>133<br>00:20:59,000 –&gt; 00:21:04,000<br>And then, we’ll look at the code.</p>
<p>134<br>00:21:04,000 –&gt; 00:21:09,000<br>And then, we’ll look at the code.</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>PrincetonAlgorithms P69Part23 04_digraph Search</div>
      <div>http://example.com/2025/10/23/PrincetonAlgorithms P69Part23-04_digraph-search/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月23日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/23/PrincetonAlgorithms%20P75Part24-06_kruskals-algorithm/" title="PrincetonAlgorithms P75Part24 06_kruskals Algorithm">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">PrincetonAlgorithms P75Part24 06_kruskals Algorithm</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/23/PrincetonAlgorithms%20P71Part23-06_strong-components/" title="PrincetonAlgorithms P71Part23 06_strong Components">
                        <span class="hidden-mobile">PrincetonAlgorithms P71Part23 06_strong Components</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
