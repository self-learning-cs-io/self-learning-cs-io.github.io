

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="100:00:00,000 –&gt; 00:00:14,320I am in condition of being our leader. 200:00:14,320 –&gt; 00:00:33,039So, like Jignesh said, on Monday, and maybe Andy said last week, I don’t know. 300:00:33,039 –&amp;gt">
<meta property="og:type" content="article">
<meta property="og:title" content="CMU15445 P12F202311 JoinAlgorithms">
<meta property="og:url" content="http://example.com/2025/10/24/CMU15445%20P12F202311-JoinAlgorithms/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="100:00:00,000 –&gt; 00:00:14,320I am in condition of being our leader. 200:00:14,320 –&gt; 00:00:33,039So, like Jignesh said, on Monday, and maybe Andy said last week, I don’t know. 300:00:33,039 –&amp;gt">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-24T12:00:44.466Z">
<meta property="article:modified_time" content="2025-10-24T12:06:28.540Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>CMU15445 P12F202311 JoinAlgorithms - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CMU15445 P12F202311 JoinAlgorithms"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-24 20:00" pubdate>
          2025年10月24日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          9.3k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          78 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">CMU15445 P12F202311 JoinAlgorithms</h1>
            
            
              <div class="markdown-body">
                
                <p>1<br>00:00:00,000 –&gt; 00:00:14,320<br>I am in condition of being our leader.</p>
<p>2<br>00:00:14,320 –&gt; 00:00:33,039<br>So, like Jignesh said, on Monday, and maybe Andy said last week, I don’t know.</p>
<p>3<br>00:00:33,039 –&gt; 00:00:34,039<br>They’re both traveling today.</p>
<p>4<br>00:00:34,039 –&gt; 00:00:35,039<br>I’m Matt.</p>
<p>5<br>00:00:35,039 –&gt; 00:00:36,039<br>I’m a PhD student.</p>
<p>6<br>00:00:36,039 –&gt; 00:00:37,879<br>I work with Andy.</p>
<p>7<br>00:00:37,879 –&gt; 00:00:42,640<br>The last time I gave a lecture for this class, I was a first year PhD student, and now I’m</p>
<p>8<br>00:00:42,640 –&gt; 00:00:45,200<br>hopefully a final year PhD student.</p>
<p>9<br>00:00:45,200 –&gt; 00:00:52,840<br>So hopefully this is a nice bookend on that process.</p>
<p>10<br>00:00:52,840 –&gt; 00:00:53,840<br>We’ll see.</p>
<p>11<br>00:00:53,840 –&gt; 00:00:57,320<br>So with that said, let’s talk about joins today.</p>
<p>12<br>00:00:57,320 –&gt; 00:01:01,760<br>A little bit of administrative to get out of the way first.</p>
<p>13<br>00:01:01,760 –&gt; 00:01:03,359<br>Homework 2 is due tonight.</p>
<p>14<br>00:01:03,359 –&gt; 00:01:08,760<br>Homework 3 is due on Sunday, and the midterm is next Wednesday.</p>
<p>15<br>00:01:08,760 –&gt; 00:01:13,840<br>This lecture is the last lecture for material you will be responsible for for the midterm.</p>
<p>16<br>00:01:13,840 –&gt; 00:01:17,880<br>There’s going to be a lecture next Monday, but it will not be covered on the midterm exam.</p>
<p>17<br>00:01:17,880 –&gt; 00:01:18,880<br>Makes sense?</p>
<p>18<br>00:01:18,880 –&gt; 00:01:24,040<br>If anything looks wrong here, it’s above my pay grade, so you’d have to take it up with</p>
<p>19<br>00:01:24,040 –&gt; 00:01:29,320<br>the core staff, but these are the dates and stuff that I was given.</p>
<p>20<br>00:01:29,320 –&gt; 00:01:35,120<br>So let’s talk about the context for why we need joins in the first place.</p>
<p>21<br>00:01:35,120 –&gt; 00:01:39,000<br>So we pray at the altar of Ted Cod and the relational model in this class.</p>
<p>22<br>00:01:39,000 –&gt; 00:01:45,480<br>So that means we’re going to reduce duplication of our information and separate our information</p>
<p>23<br>00:01:45,480 –&gt; 00:01:47,520<br>into relations, into different tables.</p>
<p>24<br>00:01:47,520 –&gt; 00:01:51,280<br>But when we want to query that information and combine and make useful queries out of it,</p>
<p>25<br>00:01:51,280 –&gt; 00:01:52,280<br>we have to join stuff.</p>
<p>26<br>00:01:52,280 –&gt; 00:01:56,040<br>So things like customers and order tables or students and classes tables, those sort</p>
<p>27<br>00:01:56,040 –&gt; 00:01:59,920<br>of classic examples you see in textbooks.</p>
<p>28<br>00:01:59,920 –&gt; 00:02:05,040<br>And if you were paying attention to the database world 10, 15 years ago, which I’m guessing</p>
<p>29<br>00:02:05,040 –&gt; 00:02:10,199<br>no one here was, the no-sequel systems were all saying joins are stupid.</p>
<p>30<br>00:02:10,199 –&gt; 00:02:14,520<br>We should just, you know, denormalize all of our data, save a bunch of time.</p>
<p>31<br>00:02:14,520 –&gt; 00:02:15,840<br>We don’t need to do joins.</p>
<p>32<br>00:02:15,840 –&gt; 00:02:19,920<br>And then it turned out a lot of people who adopted no-sequel systems ended up building</p>
<p>33<br>00:02:19,920 –&gt; 00:02:23,920<br>joins on the application side anyway, which caused a lot of redundancy and slow systems</p>
<p>34<br>00:02:23,920 –&gt; 00:02:25,480<br>and it didn’t really work out.</p>
<p>35<br>00:02:25,479 –&gt; 00:02:31,840<br>So from Andy’s perspective, from our perspective, the relational model won again.</p>
<p>36<br>00:02:31,840 –&gt; 00:02:37,799<br>And another reason joins are important is systems like analytical systems for OLAP systems.</p>
<p>37<br>00:02:37,799 –&gt; 00:02:39,039<br>Hopefully you’ve heard that term before.</p>
<p>38<br>00:02:39,039 –&gt; 00:02:45,000<br>They’re going to spend 20 to 50% of their time just working on joins.</p>
<p>39<br>00:02:45,000 –&gt; 00:02:48,519<br>Transactional systems that’s not true at all, but for analytical systems, this is where</p>
<p>40<br>00:02:48,519 –&gt; 00:02:49,599<br>they’re going to spend a lot of their time.</p>
<p>41<br>00:02:49,599 –&gt; 00:02:54,079<br>So using the right join algorithm, getting the right join order, this is all going to</p>
<p>42<br>00:02:54,080 –&gt; 00:02:57,719<br>be probably the high pull in the tent that’s going to determine your query runtime.</p>
<p>43<br>00:02:57,719 –&gt; 00:03:02,560<br>So we need to make sure we get joins right.</p>
<p>44<br>00:03:02,560 –&gt; 00:03:09,520<br>So in the lecture today, we’re just going to focus on a class of joins called binary</p>
<p>45<br>00:03:09,520 –&gt; 00:03:10,520<br>inner equidjoins.</p>
<p>46<br>00:03:10,520 –&gt; 00:03:14,080<br>Basically, binary, we’re going to join two relations.</p>
<p>47<br>00:03:14,080 –&gt; 00:03:18,439<br>Inner equidjoin, we’re going to compare two attributes from each, or an attribute from each</p>
<p>48<br>00:03:18,439 –&gt; 00:03:19,439<br>relation.</p>
<p>49<br>00:03:19,439 –&gt; 00:03:23,480<br>And if there’s an equality there, we’re going to emit sort of a concatenated tuple from</p>
<p>50<br>00:03:23,479 –&gt; 00:03:27,560<br>that, that’s satisfied that predicate.</p>
<p>51<br>00:03:27,560 –&gt; 00:03:31,599<br>These sort of joins can be modified to support, or these algorithms can be modified to support</p>
<p>52<br>00:03:31,599 –&gt; 00:03:34,239<br>other sorts of joins, depending on the sort of predicate you want to do.</p>
<p>53<br>00:03:34,239 –&gt; 00:03:36,560<br>So range scans, anti-joins.</p>
<p>54<br>00:03:36,560 –&gt; 00:03:40,280<br>I think the textbook generally just refers to this class of joins as like theta joins, where</p>
<p>55<br>00:03:40,280 –&gt; 00:03:43,319<br>maybe you’re not using an equality operator.</p>
<p>56<br>00:03:43,319 –&gt; 00:03:46,959<br>And like I mentioned, these are binary joins, where we’re only worrying about two relations.</p>
<p>57<br>00:03:46,959 –&gt; 00:03:51,639<br>Multi-way joins exist mostly in research literature.</p>
<p>58<br>00:03:51,639 –&gt; 00:03:56,639<br>It was the case that SQL Server added support for this sort of stuff in like 1998, and then</p>
<p>59<br>00:03:56,639 –&gt; 00:03:58,639<br>eventually they decided that was a terrible idea.</p>
<p>60<br>00:03:58,639 –&gt; 00:04:04,199<br>It made performance unpredictable, and they ripped it back out a couple of years later.</p>
<p>61<br>00:04:04,199 –&gt; 00:04:07,639<br>As far as we know, relational AI is the only system these days that’s really still playing</p>
<p>62<br>00:04:07,639 –&gt; 00:04:08,639<br>with multi-way joins.</p>
<p>63<br>00:04:08,639 –&gt; 00:04:12,039<br>But you will see it in the research literature.</p>
<p>64<br>00:04:12,039 –&gt; 00:04:14,039<br>At the bottom here, there’s a little bit of terminology.</p>
<p>65<br>00:04:14,039 –&gt; 00:04:17,680<br>We’re going to reuse throughout this lecture.</p>
<p>66<br>00:04:17,680 –&gt; 00:04:22,920<br>We’re going to talk about left tables and right tables and outer tables and inner tables.</p>
<p>67<br>00:04:22,920 –&gt; 00:04:26,000<br>Here we’re just making the statement that the smaller table we want to be the left table</p>
<p>68<br>00:04:26,000 –&gt; 00:04:28,759<br>or the outer table, which doesn’t really mean anything to you yet, but it’ll start to</p>
<p>69<br>00:04:28,759 –&gt; 00:04:33,720<br>make sense as we discuss the algorithms that are in play here.</p>
<p>70<br>00:04:33,720 –&gt; 00:04:37,639<br>So we’re back to looking at query plans that we’ve seen before.</p>
<p>71<br>00:04:37,639 –&gt; 00:04:42,240<br>This notion of, in the early lectures we talked about how we turn SQL into logical operators,</p>
<p>72<br>00:04:42,240 –&gt; 00:04:44,879<br>and eventually we’re going to turn them into physical operators.</p>
<p>73<br>00:04:44,879 –&gt; 00:04:51,879<br>So in this setup, data is going to start all the way down at the leaf nodes on our relations,</p>
<p>74<br>00:04:51,879 –&gt; 00:04:57,040<br>tables basically, and the data is going to flow all the way up through this relation.</p>
<p>75<br>00:04:57,040 –&gt; 00:05:01,519<br>And then there may be a filter on, like in this case, there’s a filter on S, and then</p>
<p>76<br>00:05:01,519 –&gt; 00:05:02,519<br>it’s going to reach that join operator.</p>
<p>77<br>00:05:02,519 –&gt; 00:05:07,639<br>And that join operator is going to do a comparison, and then it’s going to emit tuples based</p>
<p>78<br>00:05:07,639 –&gt; 00:05:12,800<br>on tuples that satisfy the join predicate.</p>
<p>79<br>00:05:12,800 –&gt; 00:05:15,199<br>And so next week, when we start talking about query execution, we’re going to talk about</p>
<p>80<br>00:05:15,199 –&gt; 00:05:16,720<br>like the granularity that we’re working at.</p>
<p>81<br>00:05:16,720 –&gt; 00:05:21,560<br>I’m saying tuples sort of vaguely, because it may be the case you operate one tuple at a</p>
<p>82<br>00:05:21,560 –&gt; 00:05:24,920<br>time, you may work on vectors of tuples, but that’s sort of going to be design decisions</p>
<p>83<br>00:05:24,920 –&gt; 00:05:26,879<br>we’ll talk about next week.</p>
<p>84<br>00:05:26,879 –&gt; 00:05:31,199<br>And then at the root of the node, you’re going to get the root of this tree you’re going</p>
<p>85<br>00:05:31,199 –&gt; 00:05:37,360<br>to get the actual results of the query plan.</p>
<p>86<br>00:05:37,360 –&gt; 00:05:42,759<br>So when we’re designing these join operators, we have a couple decisions to have to think</p>
<p>87<br>00:05:42,759 –&gt; 00:05:45,000<br>about.</p>
<p>88<br>00:05:45,000 –&gt; 00:05:52,240<br>What do we actually output from these operators to their parent nodes, and as well as like,</p>
<p>89<br>00:05:52,240 –&gt; 00:05:54,920<br>how do we reason about what the cost of these operations are going to be?</p>
<p>90<br>00:05:54,920 –&gt; 00:05:57,599<br>And these are typically implementation design decisions.</p>
<p>91<br>00:05:57,599 –&gt; 00:06:00,159<br>These are not sort of things you change on the fly in a system.</p>
<p>92<br>00:06:00,159 –&gt; 00:06:02,680<br>When you’re sitting down here designing, how do I want to build my database system and</p>
<p>93<br>00:06:02,680 –&gt; 00:06:06,759<br>how is data going to flow through these query plans?</p>
<p>94<br>00:06:06,759 –&gt; 00:06:09,039<br>You sort of have to reason about these sorts of things of like, what are the inputs and</p>
<p>95<br>00:06:09,040 –&gt; 00:06:13,120<br>outputs of these join operators going to be?</p>
<p>96<br>00:06:13,120 –&gt; 00:06:18,480<br>And so at a very high level, let’s just take for example, this join operation here where</p>
<p>97<br>00:06:18,480 –&gt; 00:06:26,960<br>we’re looking at ID in relations R and S. When it’s doing this comparison, I sort of alluded</p>
<p>98<br>00:06:26,960 –&gt; 00:06:30,720<br>to this earlier, the outputs can vary based on sort of the processing model, tuple at a</p>
<p>99<br>00:06:30,720 –&gt; 00:06:32,800<br>time, vectors.</p>
<p>100<br>00:06:32,800 –&gt; 00:06:34,520<br>It’s also going to depend on the storage model.</p>
<p>101<br>00:06:34,519 –&gt; 00:06:38,599<br>So I think earlier in the class, you guys talked about NSMs versus DSMs.</p>
<p>102<br>00:06:38,599 –&gt; 00:06:42,279<br>You can only remember what that is.</p>
<p>103<br>00:06:42,279 –&gt; 00:06:45,279<br>There’s another term for when we talk about NSMs and DSMs.</p>
<p>104<br>00:06:45,279 –&gt; 00:06:46,799<br>Yeah, exactly.</p>
<p>105<br>00:06:46,799 –&gt; 00:06:48,639<br>So, so, row stores versus column stores.</p>
<p>106<br>00:06:48,639 –&gt; 00:06:53,039<br>So depending on how that data is organized and how it’s flowing up from the base tables,</p>
<p>107<br>00:06:53,039 –&gt; 00:06:58,079<br>that’s also going to inform how you implement these join operators.</p>
<p>108<br>00:06:58,079 –&gt; 00:07:00,839<br>And then the last is sort of the data requirements in the query.</p>
<p>109<br>00:07:00,839 –&gt; 00:07:09,359<br>Depending on if you want the sort of what operators are existing above these joined is</p>
<p>110<br>00:07:09,359 –&gt; 00:07:13,039<br>also going to change sort of sort of what you want their inputs to actually be.</p>
<p>111<br>00:07:13,039 –&gt; 00:07:19,279<br>So let’s talk about that, the first design decision, which is what comes out of these</p>
<p>112<br>00:07:19,279 –&gt; 00:07:20,359<br>join operators.</p>
<p>113<br>00:07:20,359 –&gt; 00:07:26,039<br>So the first example, or the first design choice you could do is an option called early</p>
<p>114<br>00:07:26,039 –&gt; 00:07:27,039<br>materialization.</p>
<p>115<br>00:07:27,040 –&gt; 00:07:33,760<br>So the idea is you have tables R, table S. We’re going to do a join on ID for those.</p>
<p>116<br>00:07:33,760 –&gt; 00:07:35,960<br>And we’re going to materialize all of the values.</p>
<p>117<br>00:07:35,960 –&gt; 00:07:38,160<br>So we’re going to do the comparison.</p>
<p>118<br>00:07:38,160 –&gt; 00:07:41,360<br>And wherever those IDs match, we’re going to create our output tuples.</p>
<p>119<br>00:07:41,360 –&gt; 00:07:45,560<br>And we’re going to send them up through the operator tree.</p>
<p>120<br>00:07:45,560 –&gt; 00:07:49,439<br>So they’re going to continue to flow up to that projection, which is then going to project</p>
<p>121<br>00:07:49,439 –&gt; 00:07:52,280<br>the information that we actually want.</p>
<p>122<br>00:07:52,280 –&gt; 00:07:55,520<br>The nice thing about this is you never actually have to go back to the base tables to get your</p>
<p>123<br>00:07:55,519 –&gt; 00:07:56,519<br>data again.</p>
<p>124<br>00:07:56,519 –&gt; 00:08:01,479<br>So you do one trip to storage and you start sending your tuples through the query plan</p>
<p>125<br>00:08:01,479 –&gt; 00:08:05,519<br>and eventually to the root node to produce your result.</p>
<p>126<br>00:08:05,519 –&gt; 00:08:09,560<br>This could be like all things in database systems that are trade us to these sorts of design</p>
<p>127<br>00:08:09,560 –&gt; 00:08:10,759<br>decisions.</p>
<p>128<br>00:08:10,759 –&gt; 00:08:16,680<br>This could be a bad idea if your tuples are extremely wide with a ton of attributes,</p>
<p>129<br>00:08:16,680 –&gt; 00:08:22,019<br>because you’re effectively copying potentially more data than you actually need if one, the</p>
<p>130<br>00:08:22,019 –&gt; 00:08:26,299<br>joint activity is going to be pretty low or you’re eventually going to filter that stuff</p>
<p>131<br>00:08:26,299 –&gt; 00:08:32,419<br>out anyway depending on the projection that’s closer to the root of the plant tree.</p>
<p>132<br>00:08:32,419 –&gt; 00:08:38,539<br>If the table’s wide but only one tuple matches, it’s actually not a big deal.</p>
<p>133<br>00:08:38,539 –&gt; 00:08:41,860<br>Depending on how early you sort of do these sorts of these projections.</p>
<p>134<br>00:08:41,860 –&gt; 00:08:45,259<br>And this is also opportunities here for where you can actually push down these projections</p>
<p>135<br>00:08:45,259 –&gt; 00:08:49,139<br>to sort of reduce some of that waste.</p>
<p>136<br>00:08:49,139 –&gt; 00:08:53,740<br>So the key idea here for early materialization is these subsequent operations never really</p>
<p>137<br>00:08:53,740 –&gt; 00:08:55,899<br>have to go back to the base tables to get that information.</p>
<p>138<br>00:08:55,899 –&gt; 00:08:59,819<br>So you sort of have predictable IOs based on you only need to know the size of your</p>
<p>139<br>00:08:59,819 –&gt; 00:09:03,139<br>tables because you’re going to scan them once materialize your data and send them up</p>
<p>140<br>00:09:03,139 –&gt; 00:09:06,379<br>through the query plan.</p>
<p>141<br>00:09:06,379 –&gt; 00:09:11,460<br>The other option as opposed to early materialization is late materialization.</p>
<p>142<br>00:09:11,460 –&gt; 00:09:16,460<br>So in this scenario we have tables R and S again and we do the comparison except this</p>
<p>143<br>00:09:16,460 –&gt; 00:09:21,580<br>time we’re only going to output like record IDs or in something like a Postgres, like a</p>
<p>144<br>00:09:21,580 –&gt; 00:09:28,820<br>tuple ID, some sort of unique identifier for what tuple in the base table satisfies this</p>
<p>145<br>00:09:28,820 –&gt; 00:09:35,420<br>join but you’re not actually going to materialize all the values that you need now.</p>
<p>146<br>00:09:35,420 –&gt; 00:09:40,420<br>So as these continue to flow through at the end you see here we actually need this C</p>
<p>147<br>00:09:40,420 –&gt; 00:09:45,660<br>date field from the base table S. You have to go all the way back to storage to get that</p>
<p>148<br>00:09:45,659 –&gt; 00:09:46,659<br>down.</p>
<p>149<br>00:09:46,659 –&gt; 00:09:49,779<br>So you’ve got these tuple IDs, you know what satisfied your join, you know what you</p>
<p>150<br>00:09:49,779 –&gt; 00:09:52,860<br>eventually want to output at the root of this query plan but you have to go all the way</p>
<p>151<br>00:09:52,860 –&gt; 00:09:54,819<br>back to the base tables.</p>
<p>152<br>00:09:54,819 –&gt; 00:10:02,620<br>And this was pretty common and sort of popular with column stores maybe 15 years ago because</p>
<p>153<br>00:10:02,620 –&gt; 00:10:08,539<br>for them it made more sense to only look at the data they needed to just rip through the</p>
<p>154<br>00:10:08,539 –&gt; 00:10:12,539<br>column that you were doing your join evaluation on and eventually you just go back and you</p>
<p>155<br>00:10:12,539 –&gt; 00:10:17,379<br>materialize the data that you actually need at the very end.</p>
<p>156<br>00:10:17,379 –&gt; 00:10:23,019<br>In practice I won’t say this is less common but we’ve at least heard from one of the major</p>
<p>157<br>00:10:23,019 –&gt; 00:10:28,860<br>big column stores, one of the early ones, Vertica, that was sort of a commercialized version</p>
<p>158<br>00:10:28,860 –&gt; 00:10:31,539<br>of C store.</p>
<p>159<br>00:10:31,539 –&gt; 00:10:36,419<br>They basically initially did late materialization because they’re like this is a great idea</p>
<p>160<br>00:10:36,419 –&gt; 00:10:40,860<br>and then similar to like the multi-way join thing when the research community says something</p>
<p>161<br>00:10:40,860 –&gt; 00:10:43,940<br>might be a good idea in practice it becomes kind of hard to predict and reason about what</p>
<p>162<br>00:10:43,940 –&gt; 00:10:50,620<br>the total IO costs will be because here in this case you don’t actually know what your</p>
<p>163<br>00:10:50,620 –&gt; 00:10:52,899<br>total IO is going to be until you get to the output.</p>
<p>164<br>00:10:52,899 –&gt; 00:10:58,700<br>You like it’s hard to predict because you don’t know how many tuples will satisfy the join</p>
<p>165<br>00:10:58,700 –&gt; 00:11:03,500<br>predicates and any sort of other filters and so at the end you have to go back to IO which</p>
<p>166<br>00:11:03,500 –&gt; 00:11:07,659<br>is sort of hard to predict ahead of time and going back to IO is actually getting, despite</p>
<p>167<br>00:11:07,659 –&gt; 00:11:11,819<br>storage getting faster, is getting harder and harder in the era of sort of disaggregated</p>
<p>168<br>00:11:11,819 –&gt; 00:11:17,019<br>compute or pushing storage off to separate storage nodes and cloud environments so now you’re</p>
<p>169<br>00:11:17,019 –&gt; 00:11:21,419<br>often going across the network to get your data instead of just to a local disk.</p>
<p>170<br>00:11:21,419 –&gt; 00:11:27,139<br>So this notion of early materialization is probably more common these days.</p>
<p>171<br>00:11:27,139 –&gt; 00:11:30,939<br>So that’s early materialization versus late materialization when we’re looking at table</p>
<p>172<br>00:11:30,939 –&gt; 00:11:31,939<br>scans for joins yet.</p>
<p>173<br>00:11:31,940 –&gt; 00:11:49,500<br>So the question is where does C-date sort of get materialized to when you’re doing query</p>
<p>174<br>00:11:49,500 –&gt; 00:11:52,020<br>evaluation and then like is it thrown away at the end?</p>
<p>175<br>00:11:52,020 –&gt; 00:11:53,500<br>Is that sort of the question?</p>
<p>176<br>00:11:53,500 –&gt; 00:11:56,900<br>Yeah, it’s sort of, that’s a system design decision.</p>
<p>177<br>00:11:56,899 –&gt; 00:12:02,299<br>What this is are you’re going to, you know, like a knob you can typically set in database</p>
<p>178<br>00:12:02,299 –&gt; 00:12:06,899<br>systems is just like how much work memory does a single query get to use to sort of store</p>
<p>179<br>00:12:06,899 –&gt; 00:12:08,539<br>a scratch space and stuff like that.</p>
<p>180<br>00:12:08,539 –&gt; 00:12:11,620<br>They’re going to use typically their own scratch space for that sort of information and then</p>
<p>181<br>00:12:11,620 –&gt; 00:12:13,980<br>it’s probably just going to be lost.</p>
<p>182<br>00:12:13,980 –&gt; 00:12:18,419<br>Unless you explicitly wanted to sort of, there are things called views.</p>
<p>183<br>00:12:18,419 –&gt; 00:12:20,220<br>I don’t think Andy’s talked about those yet.</p>
<p>184<br>00:12:20,220 –&gt; 00:12:24,059<br>I don’t know if we cover views in this class but there’s this notion of views and materialized</p>
<p>185<br>00:12:24,059 –&gt; 00:12:28,979<br>views where if you know you’re repeatedly doing this sort of querying and you want to</p>
<p>186<br>00:12:28,979 –&gt; 00:12:34,019<br>sort of maintain that information, you can create those in the database system.</p>
<p>187<br>00:12:34,019 –&gt; 00:12:38,539<br>If we don’t talk about it in 445, we talk about it in 7201 for sure.</p>
<p>188<br>00:12:38,539 –&gt; 00:12:39,539<br>Yeah.</p>
<p>189<br>00:12:39,539 –&gt; 00:12:46,539<br>So, confused why the unpredictable IO is the downside?</p>
<p>190<br>00:12:46,539 –&gt; 00:12:50,539<br>Because isn’t the IO always going to be less than the predictable one?</p>
<p>191<br>00:12:50,539 –&gt; 00:12:53,539<br>The predictable one is just for everything.</p>
<p>192<br>00:12:53,539 –&gt; 00:12:55,539<br>Whereas this is 3 less than everything.</p>
<p>193<br>00:12:55,539 –&gt; 00:13:02,539<br>Right, so the question is, late materialization should always be less IO than early materialization</p>
<p>194<br>00:13:02,539 –&gt; 00:13:07,539<br>for at least for a column store.</p>
<p>195<br>00:13:08,539 –&gt; 00:13:11,539<br>There’s also the case of round trips hurt and latency hurts.</p>
<p>196<br>00:13:11,539 –&gt; 00:13:16,539<br>So in the case of early materialization, you just sort of get the benefits of prefetching,</p>
<p>197<br>00:13:16,539 –&gt; 00:13:21,539<br>you just rip through all the data, you send it across, you process all of it at once,</p>
<p>198<br>00:13:21,539 –&gt; 00:13:26,539<br>you keep it around in memory, you get typically more cache locality from that sort of stuff as opposed to</p>
<p>199<br>00:13:26,539 –&gt; 00:13:32,539<br>having to sort of make round trips back and forth to storage devices where your latency starts to become the</p>
<p>200<br>00:13:33,539 –&gt; 00:13:36,539<br>pain point rather than just sort of sequential IO.</p>
<p>201<br>00:13:36,539 –&gt; 00:13:39,539<br>In her leaving that sort of stuff gets a little trickier too, right?</p>
<p>202<br>00:13:39,539 –&gt; 00:13:44,539<br>And again, reasoning about contention in the system with early materialization,</p>
<p>203<br>00:13:44,539 –&gt; 00:13:48,539<br>your query is going to rip through your tables, materialize your information, and you’re done.</p>
<p>204<br>00:13:48,539 –&gt; 00:13:53,539<br>That query is probably not going to have to go back and hammer storage is hard for the base table information</p>
<p>205<br>00:13:53,539 –&gt; 00:13:57,539<br>as opposed to late materialization is going to keep kind of ping ponging back and forth between like,</p>
<p>206<br>00:13:57,539 –&gt; 00:14:04,539<br>I need this, go get that from the table, and it’s sort of these round trips get harder a reason about I think.</p>
<p>207<br>00:14:04,539 –&gt; 00:14:08,539<br>Cool? Oh, yeah.</p>
<p>208<br>00:14:08,539 –&gt; 00:14:15,539<br>So I have another talk about why early materialization might be more resource efficient,</p>
<p>209<br>00:14:15,539 –&gt; 00:14:19,539<br>it is because, or is it related to when you perform the join,</p>
<p>210<br>00:14:19,539 –&gt; 00:14:22,539<br>you’re fetching all the pages sequentially anyways,</p>
<p>211<br>00:14:22,539 –&gt; 00:14:25,539<br>and if you materialize it right after the join,</p>
<p>212<br>00:14:25,539 –&gt; 00:14:30,539<br>then you can take advantage of the buffer pool manager and it’s still fresh,</p>
<p>213<br>00:14:30,539 –&gt; 00:14:33,539<br>take advantage of more locality.</p>
<p>214<br>00:14:33,539 –&gt; 00:14:34,539<br>Right, so the feedback are…</p>
<p>215<br>00:14:34,539 –&gt; 00:14:40,539<br>Yeah, so a statement is early materialization may benefit from locality because if you’re ripping through all the data already,</p>
<p>216<br>00:14:40,539 –&gt; 00:14:42,539<br>and then if you need it further up the query plan,</p>
<p>217<br>00:14:42,539 –&gt; 00:14:47,539<br>like it’s already possibly still in the buffer pool or the OS page cache if someone uses that like Postgres,</p>
<p>218<br>00:14:47,539 –&gt; 00:14:48,539<br>it’s the only one left.</p>
<p>219<br>00:14:48,539 –&gt; 00:14:51,539<br>Yeah, you would benefit from caching there as well if that were the case.</p>
<p>220<br>00:14:51,539 –&gt; 00:14:59,539<br>So the other thing we talked about when we’re thinking about design decisions for these joins is,</p>
<p>221<br>00:14:59,539 –&gt; 00:15:01,539<br>how do we reason about cost for these sorts of things?</p>
<p>222<br>00:15:01,539 –&gt; 00:15:03,539<br>And I alluded this to this a little bit earlier.</p>
<p>223<br>00:15:03,539 –&gt; 00:15:07,539<br>We’re mostly going to be focused on the cost of the IO for these joins.</p>
<p>224<br>00:15:07,539 –&gt; 00:15:08,539<br>We don’t really compare…</p>
<p>225<br>00:15:08,539 –&gt; 00:15:10,539<br>We don’t worry about the compute as much.</p>
<p>226<br>00:15:10,539 –&gt; 00:15:15,539<br>So in this case, we keep going back to this notion of there’s a table R and there’s a table S</p>
<p>227<br>00:15:15,539 –&gt; 00:15:17,539<br>that we’re joining on in this query over here,</p>
<p>228<br>00:15:17,539 –&gt; 00:15:20,539<br>and I’m going to say that there’s big M pages in R with little M tuples,</p>
<p>229<br>00:15:20,539 –&gt; 00:15:25,539<br>and big M pages in S with little M tuples.</p>
<p>230<br>00:15:25,539 –&gt; 00:15:29,539<br>And we’re going to cost through this entire lecture.</p>
<p>231<br>00:15:29,539 –&gt; 00:15:35,539<br>We’re going to cost these algorithms in the notion of M and N pages and little M and N tuples.</p>
<p>232<br>00:15:35,539 –&gt; 00:15:38,539<br>And like I said, we’re going to ignore the compute cost.</p>
<p>233<br>00:15:38,539 –&gt; 00:15:41,539<br>That’s a controversial statement to some people because some people are like,</p>
<p>234<br>00:15:41,539 –&gt; 00:15:47,539<br>okay, well, some of these algorithms are O N times N and others are O N plus M from a compute standpoint.</p>
<p>235<br>00:15:47,539 –&gt; 00:15:52,539<br>But in reality, IO is still a high poll in the tent for most of what we’re doing in these database systems.</p>
<p>236<br>00:15:52,539 –&gt; 00:15:57,539<br>Unless you’re doing an in-memory database system, then you may make some different design decisions,</p>
<p>237<br>00:15:57,539 –&gt; 00:16:01,539<br>but we’re really trying to design or reduce IO here in these disk-based systems.</p>
<p>238<br>00:16:03,539 –&gt; 00:16:09,539<br>Just as a brief aside, there’s this very naive way to do a join,</p>
<p>239<br>00:16:09,539 –&gt; 00:16:12,539<br>which would be like a cross product or a Cartesian product.</p>
<p>240<br>00:16:12,539 –&gt; 00:16:18,539<br>So like in the SQL standard and some database systems, I think, offer something called a cross join,</p>
<p>241<br>00:16:18,539 –&gt; 00:16:22,539<br>where you can basically just create this Cartesian product of two different relations.</p>
<p>242<br>00:16:22,539 –&gt; 00:16:31,539<br>And you could, if you really wanted to, implement a join that way by just sort of then creating this gigantic Cartesian product of these two tables</p>
<p>243<br>00:16:31,539 –&gt; 00:16:33,539<br>and then filtering down to the ones that you actually want.</p>
<p>244<br>00:16:33,539 –&gt; 00:16:36,539<br>But in practice, that’s a terrible idea.</p>
<p>245<br>00:16:36,539 –&gt; 00:16:41,539<br>To be honest, I don’t know why anyone ever use a cross join, but it exists.</p>
<p>246<br>00:16:41,539 –&gt; 00:16:44,539<br>All you can really do is just create two for loops that run through the two tables,</p>
<p>247<br>00:16:44,539 –&gt; 00:16:46,539<br>and it’s going to be wildly inefficient.</p>
<p>248<br>00:16:46,539 –&gt; 00:16:52,539<br>Unless you were trying to create just like specifically doing something like testing that needed a Cartesian product of your data,</p>
<p>249<br>00:16:52,539 –&gt; 00:16:54,539<br>I don’t know why you would do that.</p>
<p>250<br>00:16:55,539 –&gt; 00:16:59,539<br>So here’s a brief overview of the algorithms we’re going to look at today.</p>
<p>251<br>00:16:59,539 –&gt; 00:17:02,539<br>There’s sort of three classes or groups of algorithms.</p>
<p>252<br>00:17:02,539 –&gt; 00:17:04,539<br>The first we’re going to look at is the nested loop join.</p>
<p>253<br>00:17:04,539 –&gt; 00:17:06,539<br>Then we’re going to take a look at the sort merge join,</p>
<p>254<br>00:17:06,539 –&gt; 00:17:10,539<br>which is slightly related to the external merge sort algorithm we looked at,</p>
<p>255<br>00:17:10,539 –&gt; 00:17:12,539<br>with Jignash on Monday.</p>
<p>256<br>00:17:12,539 –&gt; 00:17:18,539<br>Then we’re going to talk about what’s probably the most important one, which is the hash join,</p>
<p>257<br>00:17:18,539 –&gt; 00:17:20,539<br>and spend a decent amount of time there.</p>
<p>258<br>00:17:20,539 –&gt; 00:17:28,539<br>In practice, hash joins generally going to be the fastest for, particularly for analytical systems,</p>
<p>259<br>00:17:28,539 –&gt; 00:17:32,539<br>well, TP, like these transactional systems, are typically not doing gigantic joins,</p>
<p>260<br>00:17:32,539 –&gt; 00:17:35,539<br>so they’ll do something simpler like an index nested loop join.</p>
<p>261<br>00:17:36,539 –&gt; 00:17:40,539<br>And it may be the case that if you have like a sort by in your query,</p>
<p>262<br>00:17:40,539 –&gt; 00:17:42,539<br>you may want to do the sort merge join.</p>
<p>263<br>00:17:44,539 –&gt; 00:17:47,539<br>Right, I forgot to warn you guys about that.</p>
<p>264<br>00:17:47,539 –&gt; 00:17:52,539<br>Yeah, they’re testing an emergency alert system today at 220, so it must be 220.</p>
<p>265<br>00:17:59,539 –&gt; 00:18:01,539<br>Yeah, they are a little early.</p>
<p>266<br>00:18:02,539 –&gt; 00:18:04,539<br>Yeah, that is quite annoying.</p>
<p>267<br>00:18:12,539 –&gt; 00:18:14,539<br>Alright, we’ve got a couple more still beeping.</p>
<p>268<br>00:18:14,539 –&gt; 00:18:16,539<br>Couple more.</p>
<p>269<br>00:18:16,539 –&gt; 00:18:18,539<br>Oh, God, they’re still going.</p>
<p>270<br>00:18:32,539 –&gt; 00:18:34,539<br>Alright, we’re good.</p>
<p>271<br>00:18:34,539 –&gt; 00:18:37,539<br>I forgot to warn about that.</p>
<p>272<br>00:18:37,539 –&gt; 00:18:38,539<br>I knew that was coming.</p>
<p>273<br>00:18:41,539 –&gt; 00:18:43,539<br>There’s always one.</p>
<p>274<br>00:18:47,539 –&gt; 00:18:49,539<br>I mean, the big takeaways here is there…</p>
<p>275<br>00:18:50,539 –&gt; 00:18:54,539<br>There’s no one size fits all solution in database systems.</p>
<p>276<br>00:18:54,539 –&gt; 00:18:58,539<br>Depending on the task at hand, the query, your data distribution, your system design,</p>
<p>277<br>00:18:58,539 –&gt; 00:19:01,539<br>different joins are going to make sense at the right time,</p>
<p>278<br>00:19:01,539 –&gt; 00:19:05,539<br>because like if your query has a sort by, you might want to do the sort merge join.</p>
<p>279<br>00:19:06,539 –&gt; 00:19:09,539<br>But like I said, all TP likes to use nested loop join.</p>
<p>280<br>00:19:09,539 –&gt; 00:19:11,539<br>You can get pretty far, which is a lot of time.</p>
<p>281<br>00:19:11,539 –&gt; 00:19:13,539<br>But I think that’s a lot of time.</p>
<p>282<br>00:19:13,539 –&gt; 00:19:15,539<br>I think that’s a lot of time.</p>
<p>283<br>00:19:16,539 –&gt; 00:19:18,539<br>But like I said, all TP likes to use nested loop join.</p>
<p>284<br>00:19:18,539 –&gt; 00:19:21,539<br>You can get pretty far, which is a nested loop join for a transactional system.</p>
<p>285<br>00:19:21,539 –&gt; 00:19:26,539<br>My sequel didn’t get a hash join until 2019,</p>
<p>286<br>00:19:26,539 –&gt; 00:19:29,539<br>because they could just do nested loop joins.</p>
<p>287<br>00:19:32,539 –&gt; 00:19:34,539<br>I have a theory, actually, I’ll discuss later with the sort merge join.</p>
<p>288<br>00:19:34,539 –&gt; 00:19:38,539<br>Andy hasn’t confirmed this for me, but I think it’s true, so we’ll just take it as gospel.</p>
<p>289<br>00:19:40,539 –&gt; 00:19:43,539<br>So we’re going to start with the naive nested loop join.</p>
<p>290<br>00:19:44,539 –&gt; 00:19:48,539<br>This will actually give you a better idea when I was talking about, again,</p>
<p>291<br>00:19:50,539 –&gt; 00:19:53,539<br>the outer table and the inner table and sort of where that name comes from.</p>
<p>292<br>00:19:54,539 –&gt; 00:19:57,539<br>So if you were sort of naively trying to design a join algorithm where I said,</p>
<p>293<br>00:19:57,539 –&gt; 00:20:01,539<br>okay, for every tuple in R and every tuple in S,</p>
<p>294<br>00:20:01,539 –&gt; 00:20:05,539<br>I just want to see to their IDs match, the simplest thing you could do,</p>
<p>295<br>00:20:05,539 –&gt; 00:20:08,539<br>is just write a for loop for this outer relation,</p>
<p>296<br>00:20:08,539 –&gt; 00:20:12,539<br>and then compare it to every single relation in the loop.</p>
<p>297<br>00:20:13,539 –&gt; 00:20:16,539<br>So that’s also where the name of our outer and inner tables is going to come from.</p>
<p>298<br>00:20:16,539 –&gt; 00:20:19,539<br>You’ll sometimes see other referred to as the left and the right table,</p>
<p>299<br>00:20:19,539 –&gt; 00:20:22,539<br>the left table is usually the outer table, the right table is the inner table.</p>
<p>300<br>00:20:22,539 –&gt; 00:20:25,539<br>That comes from sort of the query plan view that we usually think about.</p>
<p>301<br>00:20:25,539 –&gt; 00:20:29,539<br>And when you talk about optimizers, I think in the future,</p>
<p>302<br>00:20:30,539 –&gt; 00:20:34,539<br>they reason more about left and right trees and use that terminology a lot more,</p>
<p>303<br>00:20:34,539 –&gt; 00:20:37,539<br>whereas like, I think that’s the reason why I’m talking about the inner table.</p>
<p>304<br>00:20:37,539 –&gt; 00:20:40,539<br>So I think that’s the reason why I’m talking about the inner table.</p>
<p>305<br>00:20:40,539 –&gt; 00:20:43,539<br>So I think that’s why I’m talking about left and right trees and use that terminology a lot more,</p>
<p>306<br>00:20:43,539 –&gt; 00:20:50,539<br>whereas like, I feel like people living in the actual operator world think about outer and inner tables.</p>
<p>307<br>00:20:50,539 –&gt; 00:20:55,539<br>So it should seem obvious that maybe not,</p>
<p>308<br>00:20:55,539 –&gt; 00:21:00,539<br>but this algorithm is bad because we’re doing a ton of work.</p>
<p>309<br>00:21:00,539 –&gt; 00:21:05,539<br>So we know we have to scan every page in M.</p>
<p>310<br>00:21:05,539 –&gt; 00:21:09,539<br>So our cost upfront is we know we’re no more eventually going to have to go through every page</p>
<p>311<br>00:21:09,539 –&gt; 00:21:14,539<br>in table R. But then for every tuple in R,</p>
<p>312<br>00:21:14,539 –&gt; 00:21:17,539<br>we’re going to have to look at every page in N.</p>
<p>313<br>00:21:17,539 –&gt; 00:21:20,539<br>So the cost here is astronomical,</p>
<p>314<br>00:21:20,539 –&gt; 00:21:25,539<br>unless these tables are very, very, very small.</p>
<p>315<br>00:21:25,539 –&gt; 00:21:29,539<br>So for example, let’s put some numbers to this.</p>
<p>316<br>00:21:29,539 –&gt; 00:21:32,539<br>Table R has a thousand pages with a hundred thousand tuples.</p>
<p>317<br>00:21:32,539 –&gt; 00:21:36,539<br>Table S has 500 pages with 40,000 tuples.</p>
<p>318<br>00:21:36,539 –&gt; 00:21:42,539<br>And that’s going to cost us 50 million IOs to do just a simple nested loop joint.</p>
<p>319<br>00:21:42,539 –&gt; 00:21:46,539<br>And there’s sort of a strawman presentation here.</p>
<p>320<br>00:21:46,539 –&gt; 00:21:49,539<br>Okay, if you do a millisecond per IO, that’s going to take 1.3 hours.</p>
<p>321<br>00:21:49,539 –&gt; 00:21:51,539<br>That’s ignoring caching entirely.</p>
<p>322<br>00:21:51,539 –&gt; 00:21:53,539<br>There’s no notion of an OS page cache here.</p>
<p>323<br>00:21:53,539 –&gt; 00:21:55,539<br>There’s no notion of a CPU cache here.</p>
<p>324<br>00:21:55,539 –&gt; 00:21:59,539<br>This is just if you had to go to disk for every single page to do this operation,</p>
<p>325<br>00:21:59,539 –&gt; 00:22:02,539<br>that’s how long it’s going to take you.</p>
<p>326<br>00:22:02,539 –&gt; 00:22:05,539<br>And then if you switch the order of the tables,</p>
<p>327<br>00:22:05,539 –&gt; 00:22:10,539<br>you get about 20% savings in your IOs and your execution time.</p>
<p>328<br>00:22:10,539 –&gt; 00:22:14,539<br>So that’s sort of a brief tease into why optimization is going to be important in the future,</p>
<p>329<br>00:22:14,539 –&gt; 00:22:17,539<br>because even just something as simple as getting the joint order right on these</p>
<p>330<br>00:22:17,539 –&gt; 00:22:26,539<br>can have a big difference in the query execution time when we go to actually run these.</p>
<p>331<br>00:22:26,539 –&gt; 00:22:30,539<br>Oh, yeah, the last thing, these numbers are actually quite small.</p>
<p>332<br>00:22:30,539 –&gt; 00:22:33,539<br>If you had 4 kill light pages, this is only about 6 megabytes of data,</p>
<p>333<br>00:22:33,539 –&gt; 00:22:35,539<br>which again, this would fit in L3.</p>
<p>334<br>00:22:35,539 –&gt; 00:22:37,539<br>So these are very small tables.</p>
<p>335<br>00:22:37,539 –&gt; 00:22:38,539<br>This would fit in your L3 cache.</p>
<p>336<br>00:22:38,539 –&gt; 00:22:40,539<br>You would actually be able to rip through this very quickly with a nested loop joint.</p>
<p>337<br>00:22:40,539 –&gt; 00:22:45,539<br>So this is sort of an example of maybe you could get away with an index nested loop joint</p>
<p>338<br>00:22:45,539 –&gt; 00:22:47,539<br>if you know your tables are very, very, very small.</p>
<p>339<br>00:22:47,539 –&gt; 00:22:49,539<br>Like you don’t need to do anything fancy.</p>
<p>340<br>00:22:49,539 –&gt; 00:22:54,539<br>If you know they’re going to fit in cache, because tables that small do exist in practice.</p>
<p>341<br>00:22:54,539 –&gt; 00:22:57,539<br>So if you are doing a very simple joint,</p>
<p>342<br>00:22:57,539 –&gt; 00:23:00,539<br>it may be the case you would want to do a nested loop joint,</p>
<p>343<br>00:23:00,539 –&gt; 00:23:06,539<br>but in general we consider this bad in the common case.</p>
<p>344<br>00:23:06,539 –&gt; 00:23:08,539<br>So how can we do better?</p>
<p>345<br>00:23:08,539 –&gt; 00:23:11,539<br>We’ll use the notion of locality here.</p>
<p>346<br>00:23:11,539 –&gt; 00:23:15,539<br>I mean, that’s pretty common in our designing computer software systems.</p>
<p>347<br>00:23:15,539 –&gt; 00:23:20,539<br>So instead of just iterating for every single individual tuple in R</p>
<p>348<br>00:23:20,539 –&gt; 00:23:22,539<br>and ripping through all of S,</p>
<p>349<br>00:23:22,539 –&gt; 00:23:26,539<br>we’re only going to do it for each page in R.</p>
<p>350<br>00:23:26,539 –&gt; 00:23:30,539<br>So that’s going to reduce the cost fairly significantly.</p>
<p>351<br>00:23:30,539 –&gt; 00:23:35,539<br>So instead of, we’re still going to have to pay this upfront cost.</p>
<p>352<br>00:23:35,539 –&gt; 00:23:37,539<br>You know you’re going to have to go through all of R.</p>
<p>353<br>00:23:37,539 –&gt; 00:23:39,539<br>There’s no getting around that.</p>
<p>354<br>00:23:39,539 –&gt; 00:23:41,539<br>But instead of little M times N,</p>
<p>355<br>00:23:41,539 –&gt; 00:23:45,539<br>so basically every tuple looking at every page in S,</p>
<p>356<br>00:23:45,539 –&gt; 00:23:47,539<br>we’re only going to do it for every page.</p>
<p>357<br>00:23:47,539 –&gt; 00:23:50,539<br>And that’s going to save us a bunch of IOs.</p>
<p>358<br>00:23:50,539 –&gt; 00:23:55,539<br>And when the optimizer is choosing the joint order here,</p>
<p>359<br>00:23:55,539 –&gt; 00:23:59,539<br>ideally we want the smaller table to be the outer table.</p>
<p>360<br>00:23:59,539 –&gt; 00:24:02,539<br>And when it’s reasoning about this sort of stuff,</p>
<p>361<br>00:24:02,539 –&gt; 00:24:05,539<br>we’re determining that based on the number of pages not the number of tuples.</p>
<p>362<br>00:24:05,539 –&gt; 00:24:08,539<br>The number of tuples doesn’t necessarily relate to the number of disk IOs</p>
<p>363<br>00:24:08,539 –&gt; 00:24:14,539<br>we’re more worried about the number of pages that’s going to have to fetch from disk.</p>
<p>364<br>00:24:14,539 –&gt; 00:24:17,539<br>So imagine in the case of,</p>
<p>365<br>00:24:17,539 –&gt; 00:24:22,539<br>okay, you have your buffer pool, you have B buffers available total.</p>
<p>366<br>00:24:22,539 –&gt; 00:24:25,539<br>We’re going to use B minus 2 buffers for the outer table.</p>
<p>367<br>00:24:25,539 –&gt; 00:24:29,539<br>That’s because we’re going to use one buffer for the output of the joint.</p>
<p>368<br>00:24:29,539 –&gt; 00:24:37,539<br>We’re going to use one buffer to sort of stream the other inner table.</p>
<p>369<br>00:24:37,539 –&gt; 00:24:40,539<br>Does that make sense when I say like we’re going to, like basically,</p>
<p>370<br>00:24:40,539 –&gt; 00:24:43,539<br>we’re going to try to use as many buffers in the buffer pool for the outer table.</p>
<p>371<br>00:24:43,539 –&gt; 00:24:48,539<br>And then we’re just going to keep two set aside for this, for the output from the joint.</p>
<p>372<br>00:24:48,539 –&gt; 00:24:55,539<br>And the others just going to be going to be completely churning and ripping through S.</p>
<p>373<br>00:24:55,539 –&gt; 00:25:00,539<br>And if we do that,</p>
<p>374<br>00:25:00,539 –&gt; 00:25:03,539<br>yeah, okay, so we’ll get to the IO cost here.</p>
<p>375<br>00:25:03,539 –&gt; 00:25:05,539<br>So again, we’ve got M.</p>
<p>376<br>00:25:05,539 –&gt; 00:25:07,539<br>So this is the case where the tables don’t fit in memory.</p>
<p>377<br>00:25:07,539 –&gt; 00:25:09,539<br>We have to rely on our buffer pool.</p>
<p>378<br>00:25:09,539 –&gt; 00:25:14,539<br>And you can only hold M divided by B minus 2 in memory at a time.</p>
<p>379<br>00:25:14,539 –&gt; 00:25:16,539<br>You multiply that by N.</p>
<p>380<br>00:25:16,539 –&gt; 00:25:22,539<br>And our cost here, if it fits in memory, is only 1500 IOs.</p>
<p>381<br>00:25:22,539 –&gt; 00:25:24,539<br>In that case, it’s only 0.15 seconds.</p>
<p>382<br>00:25:24,539 –&gt; 00:25:28,539<br>I think we were over an hour under, like sort of the strawman argument before.</p>
<p>383<br>00:25:28,539 –&gt; 00:25:32,539<br>So it’s a dramatic drop in IOs.</p>
<p>384<br>00:25:32,539 –&gt; 00:25:37,539<br>My clicker is not behaving, I think.</p>
<p>385<br>00:25:37,539 –&gt; 00:25:40,539<br>There we go.</p>
<p>386<br>00:25:40,539 –&gt; 00:25:42,539<br>And then if it doesn’t fit in memory,</p>
<p>387<br>00:25:42,539 –&gt; 00:25:48,539<br>and we rely on a buffer pool that has 102 buffer pages, which I guess he did that to make the math easier,</p>
<p>388<br>00:25:48,539 –&gt; 00:25:53,539<br>because two are going to be reserved for the inner table and the output.</p>
<p>389<br>00:25:53,539 –&gt; 00:25:58,539<br>You get 6000 IOs, and then if the optimizer were to switch the joint order,</p>
<p>390<br>00:25:58,539 –&gt; 00:26:05,539<br>you get 5,500 IOs.</p>
<p>391<br>00:26:05,539 –&gt; 00:26:08,539<br>Okay.</p>
<p>392<br>00:26:08,539 –&gt; 00:26:12,539<br>Still.</p>
<p>393<br>00:26:12,539 –&gt; 00:26:18,539<br>So the nested loop joint is kind of just, oh yeah.</p>
<p>394<br>00:26:18,539 –&gt; 00:26:25,539<br>So why do we want to bring the pages from the outer table,</p>
<p>395<br>00:26:25,539 –&gt; 00:26:32,539<br>because we’re leaving one of the inner one a lot more.</p>
<p>396<br>00:26:32,539 –&gt; 00:26:38,539<br>You would end up swapping back and forth, I think, if you had the inner table as the one that you wanted to try to fit into memory.</p>
<p>397<br>00:26:38,539 –&gt; 00:26:45,539<br>So for looping over the outer table, let’s say we take this first block of the outer table,</p>
<p>398<br>00:26:45,539 –&gt; 00:26:49,539<br>and then bring the rest of the inner pages into the buffer pool.</p>
<p>399<br>00:26:49,539 –&gt; 00:26:55,539<br>Are we going to get rid of that first block of the inner table as soon as we’re done with it?</p>
<p>400<br>00:26:55,539 –&gt; 00:27:01,539<br>Yeah, but we can sort of coordinate that our own by just sort of like pinning it, I guess, or,</p>
<p>401<br>00:27:01,539 –&gt; 00:27:06,539<br>because the inner table is always just going to be streaming through over and over and over again.</p>
<p>402<br>00:27:06,539 –&gt; 00:27:13,539<br>So we want that to be in the buffer pool if you’re going to stream over it, if you’re continually getting stuff in it.</p>
<p>403<br>00:27:13,539 –&gt; 00:27:17,539<br>Can I actually put the size of the buffer really giant?</p>
<p>404<br>00:27:17,539 –&gt; 00:27:20,539<br>Well, it doesn’t matter if it’s going to be big.</p>
<p>405<br>00:27:20,539 –&gt; 00:27:23,539<br>Well, if it’s going to be big and you keep the stuff in the outer,</p>
<p>406<br>00:27:23,539 –&gt; 00:27:25,539<br>it’s inside of your buffer pool, right?</p>
<p>407<br>00:27:25,539 –&gt; 00:27:27,539<br>Then your second loop will be giant.</p>
<p>408<br>00:27:27,539 –&gt; 00:27:31,539<br>So you’re going to have to replace that every time, so we can’t fit all the intonate.</p>
<p>409<br>00:27:31,539 –&gt; 00:27:34,539<br>Yeah, you’re going to thrat.</p>
<p>410<br>00:27:34,539 –&gt; 00:27:36,539<br>Yeah.</p>
<p>411<br>00:27:36,539 –&gt; 00:27:37,539<br>Thanks.</p>
<p>412<br>00:27:37,539 –&gt; 00:27:40,539<br>Whereas in the outer loop, there’s the last chance of crashing the direction, because for each outer loop,</p>
<p>413<br>00:27:40,539 –&gt; 00:27:43,539<br>you’re going through as many inner loops.</p>
<p>414<br>00:27:43,539 –&gt; 00:27:44,539<br>Right.</p>
<p>415<br>00:27:44,539 –&gt; 00:27:46,539<br>Makes sense?</p>
<p>416<br>00:27:46,539 –&gt; 00:27:49,539<br>Cool.</p>
<p>417<br>00:27:49,539 –&gt; 00:27:52,539<br>Awesome.</p>
<p>418<br>00:27:52,539 –&gt; 00:27:57,539<br>So yeah, like I was saying, these nested loop joins are basically just sort of a brute force.</p>
<p>419<br>00:27:57,539 –&gt; 00:28:00,539<br>Like you’re going to sequentially scan through the inner and the outer tables,</p>
<p>420<br>00:28:00,539 –&gt; 00:28:03,539<br>and the inner tables case over and over and over again.</p>
<p>421<br>00:28:03,539 –&gt; 00:28:10,539<br>And that’s sort of what we’re, we don’t have a choice if we don’t know anything really about the data.</p>
<p>422<br>00:28:10,539 –&gt; 00:28:14,539<br>If there’s no order here under the relational model.</p>
<p>423<br>00:28:14,539 –&gt; 00:28:18,539<br>But if there’s an index, we can use that to help us out here.</p>
<p>424<br>00:28:18,539 –&gt; 00:28:25,539<br>So hopefully, if we’re lucky, and this is where particularly true for allTP systems,</p>
<p>425<br>00:28:25,539 –&gt; 00:28:29,539<br>if we get an index, we can choose an index, and we can do an index join instead.</p>
<p>426<br>00:28:29,539 –&gt; 00:28:36,539<br>So what does that actually look like if we’re going to use an index to do a join?</p>
<p>427<br>00:28:36,539 –&gt; 00:28:38,539<br>The clicker is going to be grief again.</p>
<p>428<br>00:28:38,539 –&gt; 00:28:45,539<br>So in this case, for each tuple, R and R, that’s get used to that being the outer loop.</p>
<p>429<br>00:28:45,539 –&gt; 00:28:48,539<br>Basically, there’s no getting around looking at each one of these.</p>
<p>430<br>00:28:48,539 –&gt; 00:28:54,539<br>But instead of having to iterate one at a time and then looping through and doing a sequential scan on the inner table,</p>
<p>431<br>00:28:54,539 –&gt; 00:29:00,539<br>we can just do an index probe, assuming we have an index on SID, which would be great.</p>
<p>432<br>00:29:00,539 –&gt; 00:29:04,539<br>Hopefully, that’s the primary key on that table or something like that.</p>
<p>433<br>00:29:04,539 –&gt; 00:29:09,539<br>And if there’s a match in the index, then we can omit that tuple.</p>
<p>434<br>00:29:09,539 –&gt; 00:29:15,539<br>So we basically remove looping over and over again around the inner table.</p>
<p>435<br>00:29:15,539 –&gt; 00:29:20,539<br>We just have to do index probes for the tuples.</p>
<p>436<br>00:29:20,539 –&gt; 00:29:28,539<br>So in this case, we sort of hand wave away and say that the cost of an index probe is some arbitrary constant C.</p>
<p>437<br>00:29:28,539 –&gt; 00:29:33,539<br>That’s because we don’t actually know what it would be based on sort of what type of index it is.</p>
<p>438<br>00:29:33,539 –&gt; 00:29:37,539<br>If it’s a hash index, we’re looking at something that’s more constant time as opposed to like a B plus tree.</p>
<p>439<br>00:29:37,539 –&gt; 00:29:39,539<br>So you look at something logarithmic.</p>
<p>440<br>00:29:39,539 –&gt; 00:29:45,539<br>This also, you know, I said, hopefully this is maybe, well, this can’t be a unique index because I see duplicate values there in ID.</p>
<p>441<br>00:29:45,539 –&gt; 00:29:47,539<br>So that’s not your primary key.</p>
<p>442<br>00:29:47,539 –&gt; 00:29:49,539<br>There could be duplicates in this index.</p>
<p>443<br>00:29:49,539 –&gt; 00:29:56,539<br>So it may not be exactly some beautiful data structures specific.</p>
<p>444<br>00:29:56,539 –&gt; 00:30:02,539<br>You know, this is exactly how long this operation will take because we don’t know the data distribution inside of this index.</p>
<p>445<br>00:30:02,539 –&gt; 00:30:05,539<br>But we sort of hand wave that away as being some constant C.</p>
<p>446<br>00:30:05,539 –&gt; 00:30:08,539<br>So the cost gets reduced to big M.</p>
<p>447<br>00:30:08,539 –&gt; 00:30:10,539<br>You still got to look at everything in R.</p>
<p>448<br>00:30:10,539 –&gt; 00:30:15,539<br>And then the number of tuples in R times this index operation, this index look up.</p>
<p>449<br>00:30:15,539 –&gt; 00:30:17,539<br>Just look at the identity check.</p>
<p>450<br>00:30:17,539 –&gt; 00:30:21,539<br>This only works if you’re joining based off of two primary keys, right?</p>
<p>451<br>00:30:21,539 –&gt; 00:30:26,539<br>So your question is this only works if you’re joining on primary keys.</p>
<p>452<br>00:30:26,539 –&gt; 00:30:29,539<br>Oh, like whatever key would I be stored in the index?</p>
<p>453<br>00:30:29,539 –&gt; 00:30:32,539<br>It would have to be some sort of key in an index.</p>
<p>454<br>00:30:32,539 –&gt; 00:30:33,539<br>Yeah, exactly.</p>
<p>455<br>00:30:33,539 –&gt; 00:30:34,539<br>It doesn’t have to be a primary key.</p>
<p>456<br>00:30:34,539 –&gt; 00:30:36,539<br>You can have secondary indexes.</p>
<p>457<br>00:30:36,539 –&gt; 00:30:40,539<br>But it would just have to be something that has an index on it already.</p>
<p>458<br>00:30:40,539 –&gt; 00:30:45,539<br>It doesn’t matter whether it’s unique or what the constraint is there.</p>
<p>459<br>00:30:45,539 –&gt; 00:30:48,539<br>But if there’s an index, the optimizer will try to choose this.</p>
<p>460<br>00:30:48,539 –&gt; 00:30:53,539<br>And this is really, I mentioned all TPP systems,</p>
<p>461<br>00:30:53,539 –&gt; 00:30:56,539<br>mostly try to just do index nested loop joins if they can.</p>
<p>462<br>00:30:56,539 –&gt; 00:30:58,539<br>Like most transactional systems.</p>
<p>463<br>00:30:58,539 –&gt; 00:31:02,539<br>Like if you see your queries doing sequential scans,</p>
<p>464<br>00:31:02,539 –&gt; 00:31:09,539<br>that’s a hint that that’s something you just want to build an index on and your transactions will run significantly faster.</p>
<p>465<br>00:31:09,539 –&gt; 00:31:16,539<br>So the case of hash join is the BMS just on the fly building an index on the inner table.</p>
<p>466<br>00:31:16,539 –&gt; 00:31:17,539<br>Right.</p>
<p>467<br>00:31:17,539 –&gt; 00:31:18,539<br>So I mean, that’s a great question.</p>
<p>468<br>00:31:18,539 –&gt; 00:31:20,539<br>The question was like, is in a hash join,</p>
<p>469<br>00:31:20,539 –&gt; 00:31:22,539<br>is it just sort of building a hash index on the fly?</p>
<p>470<br>00:31:22,539 –&gt; 00:31:25,539<br>Yeah, this is sort of foreshadowing how a hash join works as well.</p>
<p>471<br>00:31:25,539 –&gt; 00:31:28,539<br>Because it’s basically an index join,</p>
<p>472<br>00:31:28,539 –&gt; 00:31:32,539<br>but it’s going to build a hash index on the fly.</p>
<p>473<br>00:31:32,539 –&gt; 00:31:36,539<br>And I think SQL Server also, like,</p>
<p>474<br>00:31:36,539 –&gt; 00:31:40,539<br>if it does an index, or excuse me, if it does,</p>
<p>475<br>00:31:40,539 –&gt; 00:31:44,539<br>it can build sort of indexes on the fly as well if it benefits from this sort of situation</p>
<p>476<br>00:31:44,539 –&gt; 00:31:46,539<br>where I think it’s called a spooled index.</p>
<p>477<br>00:31:46,539 –&gt; 00:31:50,539<br>Where it can sort of, yeah, sort of as you alluded to,</p>
<p>478<br>00:31:50,539 –&gt; 00:31:53,539<br>a hash join is going to build the data structure and then probably throw it away.</p>
<p>479<br>00:31:53,539 –&gt; 00:31:59,539<br>They can be smart and sort of keep that stuff around if they think it’s going to be useful for future queries.</p>
<p>480<br>00:31:59,539 –&gt; 00:32:03,539<br>But yes, this is sort of foreshadowing what’s going to happen in a hash join.</p>
<p>481<br>00:32:03,539 –&gt; 00:32:07,539<br>So, some takeaways from nested loop join.</p>
<p>482<br>00:32:07,539 –&gt; 00:32:10,539<br>Pick the smaller table to be your outer table,</p>
<p>483<br>00:32:10,539 –&gt; 00:32:12,539<br>try to get as much of it into memory as possible.</p>
<p>484<br>00:32:12,539 –&gt; 00:32:15,539<br>And when you have to, you have to loop over the inner table,</p>
<p>485<br>00:32:15,539 –&gt; 00:32:19,539<br>and ideally, you have an index on the attributes that you’re using for the join key</p>
<p>486<br>00:32:19,539 –&gt; 00:32:23,539<br>because that’s going to save you a whole bunch of time.</p>
<p>487<br>00:32:23,539 –&gt; 00:32:28,539<br>And so, and then we looked at sort of the naive, just two for loops.</p>
<p>488<br>00:32:28,539 –&gt; 00:32:30,539<br>That’s where the inner and outer table name comes from.</p>
<p>489<br>00:32:30,539 –&gt; 00:32:37,539<br>Block nested loop join looks, it takes benefits from locality and then an index nested loop join.</p>
<p>490<br>00:32:37,539 –&gt; 00:32:40,539<br>Do you have a new index in this key?</p>
<p>491<br>00:32:40,539 –&gt; 00:32:41,539<br>Sure.</p>
<p>492<br>00:32:41,539 –&gt; 00:32:44,539<br>So, if we already have a B plus 3 index,</p>
<p>493<br>00:32:44,539 –&gt; 00:32:47,539<br>do we actually create another hash in this,</p>
<p>494<br>00:32:47,539 –&gt; 00:32:51,539<br>if the one you do the index has a choice?</p>
<p>495<br>00:32:51,539 –&gt; 00:32:54,539<br>So, the question is, if we already have a B plus 3 index,</p>
<p>496<br>00:32:54,539 –&gt; 00:32:58,539<br>do we create a hash index if we want to do the index as a loop j?</p>
<p>497<br>00:32:58,539 –&gt; 00:33:05,539<br>So, the C is a constant time look up.</p>
<p>498<br>00:33:05,539 –&gt; 00:33:16,539<br>I think Andy’s just using the heavy lifting here, just saying,</p>
<p>499<br>00:33:16,539 –&gt; 00:33:17,539<br>there’s some constant.</p>
<p>500<br>00:33:17,539 –&gt; 00:33:22,539<br>If it’s a B plus 3, it’s going to be actually, like you said, logarithmic.</p>
<p>501<br>00:33:22,539 –&gt; 00:33:25,539<br>So, I don’t want to confuse the issue when I said, like,</p>
<p>502<br>00:33:25,539 –&gt; 00:33:30,539<br>if we’re doing a hash join, we don’t build an index for an index nested loop join.</p>
<p>503<br>00:33:30,539 –&gt; 00:33:32,539<br>We’re relying on an index that already exists.</p>
<p>504<br>00:33:32,539 –&gt; 00:33:35,539<br>If there’s a B plus 3 there already, that’s what we’re going to use.</p>
<p>505<br>00:33:35,539 –&gt; 00:33:41,539<br>The hope is the optimizer wouldn’t then build a hash index on top of it, probably.</p>
<p>506<br>00:33:41,539 –&gt; 00:33:44,539<br>I’m trying to think if there’s any scenario where you would want to do a hash join,</p>
<p>507<br>00:33:44,539 –&gt; 00:33:47,539<br>would a B plus 3 index is there, and I can’t think of one.</p>
<p>508<br>00:33:47,539 –&gt; 00:33:51,539<br>Because a B plus 3 also gives you the nice ordering as well,</p>
<p>509<br>00:33:51,539 –&gt; 00:33:54,539<br>which you may or may not need in the query results.</p>
<p>510<br>00:33:54,539 –&gt; 00:34:03,539<br>Like I said, we’ve got our takeaways here from the index nested loop join,</p>
<p>511<br>00:34:03,539 –&gt; 00:34:06,539<br>and then the different algorithms we have within those.</p>
<p>512<br>00:34:06,539 –&gt; 00:34:10,539<br>They’re not always a terrible idea for, again, for transactional systems.</p>
<p>513<br>00:34:10,539 –&gt; 00:34:18,539<br>It makes sense, and also if the tables are really, really small, just do an nested loop join.</p>
<p>514<br>00:34:18,539 –&gt; 00:34:21,539<br>So, let’s talk about the sort merge join.</p>
<p>515<br>00:34:21,539 –&gt; 00:34:26,539<br>The sort merge join, the basic idea, there’s two phases here.</p>
<p>516<br>00:34:26,539 –&gt; 00:34:31,539<br>In the first, you’re going to sort both tables using an algorithm like the external merge sort</p>
<p>517<br>00:34:31,539 –&gt; 00:34:33,539<br>that Jignesh talked about on Monday.</p>
<p>518<br>00:34:33,539 –&gt; 00:34:37,539<br>But all we really care about today is these two tables, they’re going to be sorted.</p>
<p>519<br>00:34:37,539 –&gt; 00:34:39,539<br>Use your favorite sorting algorithm.</p>
<p>520<br>00:34:39,539 –&gt; 00:34:42,539<br>We’re not reasoning too much about today how you make that happen.</p>
<p>521<br>00:34:42,539 –&gt; 00:34:44,539<br>That’s what Monday was for.</p>
<p>522<br>00:34:44,539 –&gt; 00:34:49,539<br>And then in the second phase, you’ve got these two sorted tables,</p>
<p>523<br>00:34:49,539 –&gt; 00:34:55,539<br>and you’re just going to create cursors in each one, and you’re just going to go in order and try to look for matches.</p>
<p>524<br>00:34:55,539 –&gt; 00:35:00,539<br>And nice thing that this ordering gives you is you don’t have to start all the way at the beginning for the inner table.</p>
<p>525<br>00:35:00,539 –&gt; 00:35:04,539<br>Every single time you’re going, as you’re working down the outer table.</p>
<p>526<br>00:35:04,539 –&gt; 00:35:11,539<br>So, the ordering here gives you some hopefully guarantees you don’t need to backtrack as far.</p>
<p>527<br>00:35:11,539 –&gt; 00:35:15,539<br>There are degenerate cases where you actually have to backtrack all the way back to the beginning every single time,</p>
<p>528<br>00:35:15,539 –&gt; 00:35:21,539<br>and this sort of falls apart and turns into a nested loop join, or a nested loop join.</p>
<p>529<br>00:35:21,539 –&gt; 00:35:24,539<br>But we can talk about that in a minute.</p>
<p>530<br>00:35:24,539 –&gt; 00:35:32,539<br>So, I hate seeing code on a projector or pseudo code, but we’re just going to step through this really briefly.</p>
<p>531<br>00:35:32,539 –&gt; 00:35:36,539<br>So, step one, like I said, we’re going to sort the two tables, R and S.</p>
<p>532<br>00:35:36,539 –&gt; 00:35:40,539<br>We’re going to create cursors, and we’ll step through an example here in a moment.</p>
<p>533<br>00:35:40,539 –&gt; 00:35:43,539<br>So, don’t worry about grocking all of this right now.</p>
<p>534<br>00:35:43,539 –&gt; 00:35:55,539<br>You get cursors at the top of each sorted relation, and you’re just going to advance those cursors based on comparing the quality keys for greater or less than.</p>
<p>535<br>00:35:55,539 –&gt; 00:35:58,539<br>And then if you have a match as you’re sort of iterating through, you emit that.</p>
<p>536<br>00:35:58,539 –&gt; 00:36:02,539<br>And then there are scenarios where you’re going to need to backtrack, and we’ll give an example of that in a minute.</p>
<p>537<br>00:36:02,539 –&gt; 00:36:10,539<br>So, again, this is more for your reference when you’re studying or need to understand how a startward join works.</p>
<p>538<br>00:36:10,539 –&gt; 00:36:16,539<br>But let’s go through an example, because I think it’s more helpful.</p>
<p>539<br>00:36:16,539 –&gt; 00:36:25,539<br>So, once again, we have tables, R and S. Step one, sort them.</p>
<p>540<br>00:36:25,539 –&gt; 00:36:29,539<br>Beautiful.</p>
<p>541<br>00:36:29,539 –&gt; 00:36:34,539<br>This clicker has given me so much grief today.</p>
<p>542<br>00:36:34,539 –&gt; 00:36:39,539<br>Initialized cursors to the beginning of our sorted relations, and we’re just going to do a comparison.</p>
<p>543<br>00:36:39,539 –&gt; 00:36:42,539<br>And we’re going to say, does SID match RID?</p>
<p>544<br>00:36:42,539 –&gt; 00:36:45,539<br>It does emit that tuple.</p>
<p>545<br>00:36:45,539 –&gt; 00:36:51,539<br>Go to the next tuple in S. So, we’re still sort of working with this outer table, inner table notion.</p>
<p>546<br>00:36:51,539 –&gt; 00:36:55,539<br>You’ll see how this ordering helps us reduce how far we have to backtrack.</p>
<p>547<br>00:36:55,539 –&gt; 00:36:59,539<br>We don’t have to start all the way at the beginning when you move to the next tuple in R.</p>
<p>548<br>00:36:59,539 –&gt; 00:37:01,539<br>We’ll do another comparison.</p>
<p>549<br>00:37:01,539 –&gt; 00:37:05,539<br>That’s also a match. We’ll emit that tuple.</p>
<p>550<br>00:37:05,539 –&gt; 00:37:07,539<br>Beautiful.</p>
<p>551<br>00:37:07,539 –&gt; 00:37:09,539<br>And we’ll advance the cursor to the next one.</p>
<p>552<br>00:37:09,539 –&gt; 00:37:14,539<br>And so, now we see that SID is now greater than RID.</p>
<p>553<br>00:37:14,539 –&gt; 00:37:16,539<br>So, we need to advance the cursor in the outer table.</p>
<p>554<br>00:37:16,539 –&gt; 00:37:20,539<br>And we do another comparison. And we see that there’s a match. And we emit that tuple.</p>
<p>555<br>00:37:20,539 –&gt; 00:37:22,539<br>Advance the cursor again.</p>
<p>556<br>00:37:22,539 –&gt; 00:37:26,539<br>Once again, the SID is now greater than RID.</p>
<p>557<br>00:37:26,539 –&gt; 00:37:31,539<br>So, we’re going to advance the cursor in table R.</p>
<p>558<br>00:37:31,539 –&gt; 00:37:35,539<br>And this is a scenario where we have to backtrack.</p>
<p>559<br>00:37:35,539 –&gt; 00:37:37,539<br>We’ve advanced the cursor in R.</p>
<p>560<br>00:37:37,539 –&gt; 00:37:40,539<br>We’re still less than the inner table’s value.</p>
<p>561<br>00:37:40,539 –&gt; 00:37:44,539<br>So, we have to back the cursor up in the inner table.</p>
<p>562<br>00:37:44,539 –&gt; 00:37:47,539<br>But, unlike a nested loop join, we don’t have to go all the way to the beginning.</p>
<p>563<br>00:37:47,539 –&gt; 00:37:50,539<br>We’re relying on this ordering to not have to go as far.</p>
<p>564<br>00:37:50,539 –&gt; 00:37:53,539<br>Go back to 200. Do a comparison. It’s a match.</p>
<p>565<br>00:37:53,539 –&gt; 00:37:55,539<br>We emit that tuple.</p>
<p>566<br>00:37:55,539 –&gt; 00:37:57,539<br>Advance the inner cursor again.</p>
<p>567<br>00:37:57,539 –&gt; 00:37:59,539<br>We’re now less than 400.</p>
<p>568<br>00:37:59,539 –&gt; 00:38:01,539<br>So, advance the outer cursor.</p>
<p>569<br>00:38:01,539 –&gt; 00:38:04,539<br>We don’t have to backtrack on the inner table on this one.</p>
<p>570<br>00:38:04,539 –&gt; 00:38:07,539<br>We’re still less than at the outer cursor.</p>
<p>571<br>00:38:07,539 –&gt; 00:38:10,539<br>RID is less than SID. So, we’re going to advance the cursor again.</p>
<p>572<br>00:38:10,539 –&gt; 00:38:14,539<br>Do the comparison. Output that tuple.</p>
<p>573<br>00:38:14,539 –&gt; 00:38:16,539<br>We’re going to advance the inner cursor.</p>
<p>574<br>00:38:16,539 –&gt; 00:38:19,539<br>Advance the inner cursor.</p>
<p>575<br>00:38:19,539 –&gt; 00:38:22,539<br>We do another comparison.</p>
<p>576<br>00:38:22,539 –&gt; 00:38:24,539<br>RID is less than SID.</p>
<p>577<br>00:38:24,539 –&gt; 00:38:26,539<br>Advance the outer cursor.</p>
<p>578<br>00:38:26,539 –&gt; 00:38:29,539<br>We get a match. We output that one.</p>
<p>579<br>00:38:29,539 –&gt; 00:38:32,539<br>And we’re at the end of SID.</p>
<p>580<br>00:38:32,539 –&gt; 00:38:36,539<br>This example for some reason.</p>
<p>581<br>00:38:36,539 –&gt; 00:38:40,539<br>There we go.</p>
<p>582<br>00:38:40,539 –&gt; 00:38:42,539<br>Yes.</p>
<p>583<br>00:38:42,539 –&gt; 00:38:47,539<br>We’re backtracking to the very first occurrence.</p>
<p>584<br>00:38:47,539 –&gt; 00:38:50,539<br>For example, there’s only one 200 here,</p>
<p>585<br>00:38:50,539 –&gt; 00:38:53,539<br>but there were multiple 200 in the table.</p>
<p>586<br>00:38:53,539 –&gt; 00:38:55,539<br>All the way to the first 200?</p>
<p>587<br>00:38:55,539 –&gt; 00:38:58,539<br>So, the question is, if there were multiple 200s in the inner table,</p>
<p>588<br>00:38:58,539 –&gt; 00:39:01,539<br>would you backtrack to the first 200? Yes.</p>
<p>589<br>00:39:01,539 –&gt; 00:39:06,539<br>Because you have to compare now this sort of second 200 at the outer relation to the inner relation.</p>
<p>590<br>00:39:06,539 –&gt; 00:39:08,539<br>Makes sense?</p>
<p>591<br>00:39:08,539 –&gt; 00:39:11,539<br>If you want to backtrack to the first 200 or something,</p>
<p>592<br>00:39:11,539 –&gt; 00:39:14,539<br>it’s like the previous embedding.</p>
<p>593<br>00:39:14,539 –&gt; 00:39:23,539<br>Yes. So, the question is, you backtrack to the occurrence of the sort of the outer cursor’s value, I guess.</p>
<p>594<br>00:39:23,539 –&gt; 00:39:25,539<br>Yeah. That’s basically how far you would have to backtrack.</p>
<p>595<br>00:39:25,539 –&gt; 00:39:27,539<br>Anything that could possibly still satisfy the equality predicate,</p>
<p>596<br>00:39:27,539 –&gt; 00:39:30,539<br>you have to make sure you backtrack far enough to check that.</p>
<p>597<br>00:39:30,539 –&gt; 00:39:34,539<br>So, the question is, how are you going to store that?</p>
<p>598<br>00:39:34,539 –&gt; 00:39:37,539<br>You could basically memoize that, right?</p>
<p>599<br>00:39:37,539 –&gt; 00:39:40,539<br>Like, you could basically just keep track of, okay,</p>
<p>600<br>00:39:40,539 –&gt; 00:39:42,539<br>when I met a new cursor value here,</p>
<p>601<br>00:39:42,539 –&gt; 00:39:45,539<br>where was the first place I had a match in the inner table?</p>
<p>602<br>00:39:45,539 –&gt; 00:39:47,539<br>So, that the next time you have to advance this one,</p>
<p>603<br>00:39:47,539 –&gt; 00:39:49,539<br>you just jump right back to that one.</p>
<p>604<br>00:39:49,539 –&gt; 00:39:50,539<br>You could…</p>
<p>605<br>00:39:50,539 –&gt; 00:39:52,539<br>You’re like, throw the table, it’s all the same.</p>
<p>606<br>00:39:52,539 –&gt; 00:39:53,539<br>You could store that.</p>
<p>607<br>00:39:53,539 –&gt; 00:39:56,539<br>I could probably hold a record of that.</p>
<p>608<br>00:39:57,539 –&gt; 00:40:01,539<br>I could probably hold a record ID in a variable, right?</p>
<p>609<br>00:40:01,539 –&gt; 00:40:04,539<br>Just a 32-bit integer or something like that,</p>
<p>610<br>00:40:04,539 –&gt; 00:40:09,539<br>to hold the record ID in this table that just knows how far I have to backtrack to for this current cursor.</p>
<p>611<br>00:40:09,539 –&gt; 00:40:14,539<br>How are you going to store one for our IDs current index?</p>
<p>612<br>00:40:14,539 –&gt; 00:40:16,539<br>That’s the one you need to store.</p>
<p>613<br>00:40:16,539 –&gt; 00:40:22,539<br>You need to store the index or the tuple ID or the record ID on the inner table</p>
<p>614<br>00:40:22,539 –&gt; 00:40:25,539<br>for how far you need to backtrack to for the current outer key.</p>
<p>615<br>00:40:25,539 –&gt; 00:40:26,539<br>Is that make sense?</p>
<p>616<br>00:40:26,539 –&gt; 00:40:27,539<br>Cool.</p>
<p>617<br>00:40:28,539 –&gt; 00:40:30,539<br>Did that check out for everyone else too?</p>
<p>618<br>00:40:30,539 –&gt; 00:40:32,539<br>I’m not making that up.</p>
<p>619<br>00:40:32,539 –&gt; 00:40:33,539<br>Okay.</p>
<p>620<br>00:40:36,539 –&gt; 00:40:38,539<br>You guys are going to have to call me on this.</p>
<p>621<br>00:40:38,539 –&gt; 00:40:39,539<br>I’ve never given this lecture.</p>
<p>622<br>00:40:39,539 –&gt; 00:40:41,539<br>So, if it sounds like that’s not right,</p>
<p>623<br>00:40:41,539 –&gt; 00:40:43,539<br>tell me if something doesn’t pass the smell test.</p>
<p>624<br>00:40:46,539 –&gt; 00:40:47,539<br>20 minutes later?</p>
<p>625<br>00:40:47,539 –&gt; 00:40:48,539<br>Yeah.</p>
<p>626<br>00:40:48,539 –&gt; 00:40:51,539<br>So, you only backtracked within the outer joins,</p>
<p>627<br>00:40:51,539 –&gt; 00:40:53,539<br>the ID is very simple, right?</p>
<p>628<br>00:40:54,539 –&gt; 00:40:57,539<br>So, the question is, you only backtrack in…</p>
<p>629<br>00:40:57,539 –&gt; 00:41:02,539<br>The case where the outer ID is hurt people when you move through an x cursor?</p>
<p>630<br>00:41:02,539 –&gt; 00:41:04,539<br>Only when it’s equal.</p>
<p>631<br>00:41:04,539 –&gt; 00:41:08,539<br>I guess the number could be used by leading the backdrop and we hit 300 and R</p>
<p>632<br>00:41:08,539 –&gt; 00:41:11,539<br>and we’re still at 400 in the chat.</p>
<p>633<br>00:41:11,539 –&gt; 00:41:13,539<br>So, in this one?</p>
<p>634<br>00:41:13,539 –&gt; 00:41:14,539<br>Yeah.</p>
<p>635<br>00:41:14,539 –&gt; 00:41:17,539<br>So, we…</p>
<p>636<br>00:41:18,539 –&gt; 00:41:20,539<br>We can go back here to the stream,</p>
<p>637<br>00:41:20,539 –&gt; 00:41:22,539<br>we don’t think we’d backtrack.</p>
<p>638<br>00:41:22,539 –&gt; 00:41:23,539<br>So, like, we have to know that…</p>
<p>639<br>00:41:23,539 –&gt; 00:41:24,539<br>So, yeah, we can go back to the stream.</p>
<p>640<br>00:41:24,539 –&gt; 00:41:29,539<br>Yeah, like, nothing satisfied the join predicate for 300.</p>
<p>641<br>00:41:29,539 –&gt; 00:41:33,539<br>So, we probably wouldn’t have it cached that anything was there that we need to jump back to,</p>
<p>642<br>00:41:33,539 –&gt; 00:41:37,539<br>that there was no index for that in the inner table.</p>
<p>643<br>00:41:37,539 –&gt; 00:41:39,539<br>Yeah, it’s just an optimization.</p>
<p>644<br>00:41:39,539 –&gt; 00:41:41,539<br>You wanted to go back to the pseudocoder?</p>
<p>645<br>00:41:41,539 –&gt; 00:41:44,539<br>Yeah, just one second.</p>
<p>646<br>00:41:44,539 –&gt; 00:41:47,539<br>One second.</p>
<p>647<br>00:41:47,539 –&gt; 00:41:50,539<br>Oh, okay.</p>
<p>648<br>00:41:55,539 –&gt; 00:41:59,539<br>So, it’s in the scenario where you have to increment the outer table’s cursor.</p>
<p>649<br>00:41:59,539 –&gt; 00:42:03,539<br>You need to know, potentially, how far you need to backtrack on the inner table,</p>
<p>650<br>00:42:03,539 –&gt; 00:42:08,539<br>because you may have advanced past two pulls that would still satisfy the join predicate.</p>
<p>651<br>00:42:09,539 –&gt; 00:42:12,539<br>Yeah.</p>
<p>652<br>00:42:14,539 –&gt; 00:42:16,539<br>Cool.</p>
<p>653<br>00:42:16,539 –&gt; 00:42:18,539<br>So, how do we cost this thing?</p>
<p>654<br>00:42:18,539 –&gt; 00:42:22,539<br>The sort cost for RNS comes from the lecture on Monday.</p>
<p>655<br>00:42:22,539 –&gt; 00:42:26,539<br>And so, I’m not going to discuss that math, because math is scary.</p>
<p>656<br>00:42:26,539 –&gt; 00:42:31,539<br>And the merge cost is you just have to look at every single page in both relations.</p>
<p>657<br>00:42:31,539 –&gt; 00:42:33,539<br>So, it’s just m plus n.</p>
<p>658<br>00:42:33,539 –&gt; 00:42:39,539<br>And so, in this case, the high-pollin intent is going to be typically the sorting process.</p>
<p>659<br>00:42:39,539 –&gt; 00:42:45,539<br>And we’ll get some clicking going again.</p>
<p>660<br>00:42:45,539 –&gt; 00:42:48,539<br>And so, again, here’s our hard numbers.</p>
<p>661<br>00:42:48,539 –&gt; 00:42:53,539<br>I think those table sizes have more or less stayed the same.</p>
<p>662<br>00:42:53,539 –&gt; 00:42:57,539<br>If they haven’t, that makes this difficult.</p>
<p>663<br>00:42:57,539 –&gt; 00:43:02,539<br>We’ve got the sort cost that’s going to be 4,000 IOs for R,</p>
<p>664<br>00:43:02,539 –&gt; 00:43:07,539<br>for S is 2,000 IOs, and then the merge cost is only 1,500, add those up to 1,500.</p>
<p>665<br>00:43:07,539 –&gt; 00:43:12,539<br>And again, this sort of straw-man IO cost of 1 millisecond per access to the disk</p>
<p>666<br>00:43:12,539 –&gt; 00:43:19,539<br>is going to take less than a second to perform the sort merge join.</p>
<p>667<br>00:43:19,539 –&gt; 00:43:25,539<br>So, I mentioned this before.</p>
<p>668<br>00:43:25,539 –&gt; 00:43:31,539<br>There’s a degenerate case here for the sort merge join, where what if every attribute</p>
<p>669<br>00:43:31,539 –&gt; 00:43:33,539<br>has the exact same values?</p>
<p>670<br>00:43:33,539 –&gt; 00:43:36,539<br>You’re going to pay the cost to sort it all.</p>
<p>671<br>00:43:36,539 –&gt; 00:43:39,539<br>And then you’re still going to have to, like, you’re going to have to backtrack also</p>
<p>672<br>00:43:39,539 –&gt; 00:43:43,539<br>in every single iteration on the inner table.</p>
<p>673<br>00:43:43,539 –&gt; 00:43:49,539<br>And this will just sort of devolve to a nested loop join, plus you paid to sort it first.</p>
<p>674<br>00:43:49,539 –&gt; 00:43:56,539<br>So, in practice, if someone makes a, oh, this shouldn’t happen.</p>
<p>675<br>00:43:56,539 –&gt; 00:43:59,539<br>If someone makes an attribute, call them on a big table.</p>
<p>676<br>00:43:59,539 –&gt; 00:44:04,539<br>That’s all got one value, and they want to join on that.</p>
<p>677<br>00:44:04,539 –&gt; 00:44:06,539<br>And they did a bad job.</p>
<p>678<br>00:44:06,539 –&gt; 00:44:09,539<br>And then there are also other things in database systems we can do to sort of help us out here.</p>
<p>679<br>00:44:09,539 –&gt; 00:44:10,539<br>There’s things called zone maps.</p>
<p>680<br>00:44:10,539 –&gt; 00:44:15,539<br>There’s other things we can know about the distribution and the cardinality of an individual column</p>
<p>681<br>00:44:15,539 –&gt; 00:44:19,539<br>that would maybe help us know, hey, don’t sort this column.</p>
<p>682<br>00:44:19,539 –&gt; 00:44:24,539<br>It’s a column that’s just a billion ones, or something like that.</p>
<p>683<br>00:44:24,539 –&gt; 00:44:34,539<br>Database systems sort of usually, we usually have things to stop people from doing something too crazy like that.</p>
<p>684<br>00:44:34,539 –&gt; 00:44:36,539<br>So, when is it useful?</p>
<p>685<br>00:44:36,539 –&gt; 00:44:41,539<br>It would be great if one or both of the tables is already sorted on the join key.</p>
<p>686<br>00:44:41,539 –&gt; 00:44:43,539<br>That would be beautiful.</p>
<p>687<br>00:44:43,539 –&gt; 00:44:48,539<br>Or it may be the case that you want your output ordered for the eventual output.</p>
<p>688<br>00:44:48,539 –&gt; 00:44:52,539<br>So, in case of an order by clause or something like that, the database system may say,</p>
<p>689<br>00:44:52,539 –&gt; 00:44:54,539<br>well, I’m going to have to sort this anyway.</p>
<p>690<br>00:44:54,539 –&gt; 00:44:59,539<br>I might as well just go for a sort merge join.</p>
<p>691<br>00:44:59,539 –&gt; 00:45:01,539<br>And it doesn’t necessarily have to be sorted first.</p>
<p>692<br>00:45:01,539 –&gt; 00:45:05,539<br>It could have been an operation below like an index probe that’s like a B plus tree that provides ordering.</p>
<p>693<br>00:45:05,539 –&gt; 00:45:07,539<br>It could be producing the inputs.</p>
<p>694<br>00:45:07,539 –&gt; 00:45:09,539<br>These may not be base tables underneath.</p>
<p>695<br>00:45:09,539 –&gt; 00:45:11,539<br>They may be index probes or something like that.</p>
<p>696<br>00:45:11,539 –&gt; 00:45:13,539<br>That could be producing ordered data into the operator.</p>
<p>697<br>00:45:13,539 –&gt; 00:45:17,539<br>And then the optimizer will know, I could use a sort merge join here because my inputs are already going to be sorted.</p>
<p>698<br>00:45:17,539 –&gt; 00:45:19,539<br>So, I don’t have to pay the sort cost.</p>
<p>699<br>00:45:19,539 –&gt; 00:45:20,539<br>Did you have a question?</p>
<p>700<br>00:45:20,539 –&gt; 00:45:22,539<br>I would exactly do the question.</p>
<p>701<br>00:45:22,539 –&gt; 00:45:26,539<br>Why would you prefer sort of doing a load of something that has been asked to be sorted?</p>
<p>702<br>00:45:26,539 –&gt; 00:45:29,539<br>Like, being in an index probe.</p>
<p>703<br>00:45:29,539 –&gt; 00:45:30,539<br>Right.</p>
<p>704<br>00:45:30,539 –&gt; 00:45:31,539<br>Yeah.</p>
<p>705<br>00:45:31,539 –&gt; 00:45:34,539<br>Yeah, so sometimes if the optimizer knows stuff coming in is already ordered.</p>
<p>706<br>00:45:34,539 –&gt; 00:45:38,539<br>And this was sort of what I alluded to earlier that Andy hasn’t actually confirmed for me.</p>
<p>707<br>00:45:38,539 –&gt; 00:45:41,539<br>Like, my sequel, I mentioned, got the hash join in 2019.</p>
<p>708<br>00:45:41,539 –&gt; 00:45:44,539<br>That sounds like it got a disease.</p>
<p>709<br>00:45:44,539 –&gt; 00:45:48,539<br>They added hash join support to my sequel as late as 2019.</p>
<p>710<br>00:45:48,539 –&gt; 00:45:54,539<br>My sequel storage engine is in ODB and it always clusters its data on a primary key.</p>
<p>711<br>00:45:54,539 –&gt; 00:46:03,539<br>So, if tables are commonly being joined on primary key, well one you probably have an index anyway.</p>
<p>712<br>00:46:03,539 –&gt; 00:46:05,539<br>But again, in ODB is also sorted already.</p>
<p>713<br>00:46:05,539 –&gt; 00:46:07,539<br>It’s already basically clustered.</p>
<p>714<br>00:46:07,539 –&gt; 00:46:12,539<br>So, they may have decided in, for a long time in my sequel, we can just always rely on index or sort merge joins.</p>
<p>715<br>00:46:12,539 –&gt; 00:46:14,539<br>And we don’t really need a hash join.</p>
<p>716<br>00:46:14,539 –&gt; 00:46:17,539<br>But eventually they came along and added it.</p>
<p>717<br>00:46:17,539 –&gt; 00:46:21,539<br>Which gets me to the hash join.</p>
<p>718<br>00:46:21,539 –&gt; 00:46:23,539<br>The big one.</p>
<p>719<br>00:46:23,539 –&gt; 00:46:33,539<br>So, the basic properties we’re going to rely on here is, okay, if two tuples or if tuples in RNS are going to satisfy the join predicate,</p>
<p>720<br>00:46:33,539 –&gt; 00:46:42,539<br>the hope is they’re going to have some, if we’ve picked a reasonable hash function, if you hash those values,</p>
<p>721<br>00:46:42,539 –&gt; 00:46:44,539<br>we’re also going to hash to the same value.</p>
<p>722<br>00:46:44,539 –&gt; 00:46:51,539<br>So, we can rely on a hash table here to make our lookups more efficient.</p>
<p>723<br>00:46:51,539 –&gt; 00:46:54,539<br>And I’ll show you how that happens.</p>
<p>724<br>00:46:54,539 –&gt; 00:46:59,539<br>And in some cases, we’re basically on the flag and available to hash table on the outer table.</p>
<p>725<br>00:46:59,539 –&gt; 00:47:02,539<br>And then we’re going to do lookups on the inner table using that same hash function.</p>
<p>726<br>00:47:02,539 –&gt; 00:47:07,539<br>And whenever there’s a match, we emit a tuple.</p>
<p>727<br>00:47:07,539 –&gt; 00:47:10,539<br>And there’s an illusion here to partitioning and stuff like that.</p>
<p>728<br>00:47:10,539 –&gt; 00:47:11,539<br>We’ll get to that.</p>
<p>729<br>00:47:11,539 –&gt; 00:47:17,539<br>We’re basically talking about what happens if a bucket start overflowing or your hash table doesn’t fit in memory.</p>
<p>730<br>00:47:17,539 –&gt; 00:47:20,539<br>But the basic idea is, you’re going to build a hash index, like you said before.</p>
<p>731<br>00:47:20,539 –&gt; 00:47:23,539<br>You’re going to build a hash index on one of the tables.</p>
<p>732<br>00:47:23,539 –&gt; 00:47:26,539<br>And then on the other table, you’re just going to scan along, apply the hash function.</p>
<p>733<br>00:47:26,539 –&gt; 00:47:28,539<br>And if you get a match, you’re going to emit that tuple.</p>
<p>734<br>00:47:28,539 –&gt; 00:47:30,539<br>So, there’s two phases here.</p>
<p>735<br>00:47:30,539 –&gt; 00:47:34,539<br>We’ve got the build phase, which I described sort of briefly a moment ago.</p>
<p>736<br>00:47:34,539 –&gt; 00:47:37,539<br>And then on the outer table, you’re going to apply some hash function.</p>
<p>737<br>00:47:37,539 –&gt; 00:47:40,539<br>You’re going to build a hash table.</p>
<p>738<br>00:47:40,539 –&gt; 00:47:43,539<br>Choose whatever hash table you want.</p>
<p>739<br>00:47:43,539 –&gt; 00:47:46,539<br>But I think you guys have discussed hashing already.</p>
<p>740<br>00:47:46,539 –&gt; 00:47:50,539<br>In this case, you generally want to use linear probing.</p>
<p>741<br>00:47:50,539 –&gt; 00:47:53,539<br>And then in the probe phase, you’re going to go along the inner relation.</p>
<p>742<br>00:47:53,539 –&gt; 00:47:57,539<br>You’re going to hash each tuple on the join key.</p>
<p>743<br>00:47:57,539 –&gt; 00:48:01,539<br>And anywhere you get a match in the hash table, you’re going to emit that tuple into the query plan.</p>
<p>744<br>00:48:01,539 –&gt; 00:48:04,539<br>So, what does this look like?</p>
<p>745<br>00:48:04,539 –&gt; 00:48:07,539<br>Step one, build hash table.</p>
<p>746<br>00:48:07,539 –&gt; 00:48:14,539<br>And then for each tuple in S, I think I’ve said this a few times now, but I like to see it with the graphics.</p>
<p>747<br>00:48:14,539 –&gt; 00:48:16,539<br>Okay, so we’re going to build the hash table.</p>
<p>748<br>00:48:16,539 –&gt; 00:48:20,539<br>Scan all the way through R using hash function one.</p>
<p>749<br>00:48:20,539 –&gt; 00:48:27,539<br>And then we’re going to apply the same hash function to the second table, or the second relation.</p>
<p>750<br>00:48:27,539 –&gt; 00:48:32,539<br>And then anywhere there’s a match, we emit that tuple.</p>
<p>751<br>00:48:32,539 –&gt; 00:48:37,539<br>So, what is in this hash table?</p>
<p>752<br>00:48:37,539 –&gt; 00:48:39,539<br>One, you need the key.</p>
<p>753<br>00:48:39,539 –&gt; 00:48:42,539<br>You have to keep that around from the join key.</p>
<p>754<br>00:48:42,539 –&gt; 00:48:47,539<br>You can’t just build the hash table and then just keep like just a record ID sitting there with it.</p>
<p>755<br>00:48:47,539 –&gt; 00:48:50,539<br>You have to keep the original key because it made the case that there’s a collision on this hash function.</p>
<p>756<br>00:48:50,539 –&gt; 00:48:54,539<br>And you still have to do a comparison of was this a real match?</p>
<p>757<br>00:48:54,539 –&gt; 00:49:05,539<br>Just because I hashed to the same value in the hash table, you still have to do the key comparison just to make sure it wasn’t sort of like a asperiace collision or any sort of like misplaced tuple in the hash table.</p>
<p>758<br>00:49:05,539 –&gt; 00:49:09,539<br>It had to like move for linear probing.</p>
<p>759<br>00:49:09,539 –&gt; 00:49:12,539<br>And then this gets to sort of the discussion earlier.</p>
<p>760<br>00:49:12,539 –&gt; 00:49:14,539<br>We had with earlier versus late materialization.</p>
<p>761<br>00:49:14,539 –&gt; 00:49:16,539<br>Do you put the value in the hash table with it?</p>
<p>762<br>00:49:16,539 –&gt; 00:49:17,539<br>Maybe.</p>
<p>763<br>00:49:17,539 –&gt; 00:49:20,539<br>Some people put just a record ID again.</p>
<p>764<br>00:49:20,539 –&gt; 00:49:23,539<br>It depends like all things in these systems designs.</p>
<p>765<br>00:49:23,539 –&gt; 00:49:29,539<br>It just depends on what works best for the system that you’re designing, whether you want to materialize this and keep it in the hash table.</p>
<p>766<br>00:49:29,539 –&gt; 00:49:34,539<br>And that’s sort of going to become the canonical materialization of the data that you need to go back to later.</p>
<p>767<br>00:49:34,539 –&gt; 00:49:41,539<br>Or if you just want something that is like an entry or an offset into something you may have materialized already.</p>
<p>768<br>00:49:41,539 –&gt; 00:49:47,539<br>A different memory buffer.</p>
<p>769<br>00:49:47,539 –&gt; 00:49:56,539<br>So we have a brief discussion now of probed filter of what’s called a probe filter that relies on a data structure called a bloom filter.</p>
<p>770<br>00:49:56,539 –&gt; 00:50:00,539<br>There’s a much longer example in fall 2022.</p>
<p>771<br>00:50:00,539 –&gt; 00:50:07,539<br>So if you really want to see how a bloom filter works like going to sort of the bit logic and stuff like that.</p>
<p>772<br>00:50:07,539 –&gt; 00:50:11,539<br>We’ve pruned it for time, but they’re pretty interesting data structures.</p>
<p>773<br>00:50:11,539 –&gt; 00:50:22,539<br>The basic idea with this probe filter is before you do the hash table look up, you look in this data structure that checks to see if the key is going to be present in the hash table.</p>
<p>774<br>00:50:22,539 –&gt; 00:50:24,539<br>Because it’s typically a much smaller data structure.</p>
<p>775<br>00:50:24,539 –&gt; 00:50:29,539<br>These bloom filters can typically fit in a CPU cache.</p>
<p>776<br>00:50:29,539 –&gt; 00:50:36,539<br>It’s just going to be much more efficient typically to use a bloom filter to look up first than it is going to be in a hash table.</p>
<p>777<br>00:50:36,539 –&gt; 00:50:42,539<br>Now, you may be wondering like, okay, well, why wouldn’t you just use a bloom filter instead of a hash table?</p>
<p>778<br>00:50:42,539 –&gt; 00:50:47,539<br>It’s because these are probabilistic data structures so they can have…</p>
<p>779<br>00:50:47,539 –&gt; 00:50:51,539<br>They can never have a false negative. They’re never going to say, oh, that is not in the set.</p>
<p>780<br>00:50:51,539 –&gt; 00:50:56,539<br>But it’s possible they could do a false positive and say, yes, this look up that you’re doing is in the set.</p>
<p>781<br>00:50:56,539 –&gt; 00:51:02,539<br>And then you have to go to the hash table and actually that’s your ground truth of whether it’s actually going to satisfy the join predicate.</p>
<p>782<br>00:51:02,539 –&gt; 00:51:06,539<br>But in practice, these bloom filters can save a lot of hash table lookups.</p>
<p>783<br>00:51:06,539 –&gt; 00:51:08,539<br>So what does that actually look like?</p>
<p>784<br>00:51:08,539 –&gt; 00:51:14,539<br>We’re joining A and B for some reason because why it’s not R and S.</p>
<p>785<br>00:51:14,539 –&gt; 00:51:16,539<br>But we’re joining A and B.</p>
<p>786<br>00:51:16,539 –&gt; 00:51:25,539<br>And while we’re building our hash table on A, we’re also going to build a bloom filter.</p>
<p>787<br>00:51:25,539 –&gt; 00:51:38,539<br>Because we have to scan the data anyway. And then when it comes to the probe phase, we’re going to first look up in the bloom filter if the tuple and if the key attribute in B satisfies the bloom filter.</p>
<p>788<br>00:51:38,539 –&gt; 00:51:45,539<br>If it doesn’t, you move on to the next one. And then if it does, only then do you go to the hash table.</p>
<p>789<br>00:51:45,539 –&gt; 00:51:54,539<br>The reason this is helpful as well, again, in a disk-based system, these hash tables may not sit in memory. They may have to spill the disk, which we’re going to talk about very shortly.</p>
<p>790<br>00:51:54,539 –&gt; 00:52:07,539<br>But this will also sort of motivate why something like a bloom filter is helpful to sort of prune out hash table lookups ahead of time.</p>
<p>791<br>00:52:07,539 –&gt; 00:52:09,539<br>Clicker. There we go.</p>
<p>792<br>00:52:09,539 –&gt; 00:52:18,539<br>So as I alluded to, what happens if you don’t have enough memory for your entire hash table?</p>
<p>793<br>00:52:18,539 –&gt; 00:52:25,539<br>Hash tables are sorry, go ahead.</p>
<p>794<br>00:52:25,539 –&gt; 00:52:42,539<br>Generally, yeah, you’re still going to probably want to do the bloom filter lookup first because it’s probably going to have a better chance of staying warm in your CPU cache.</p>
<p>795<br>00:52:42,539 –&gt; 00:52:51,539<br>Depending on your hash table implementation, they’re not as cache friendly. We’re going to have to jump around through pointers, especially for linear probing and such.</p>
<p>796<br>00:52:51,539 –&gt; 00:53:07,539<br>Usually, we would probably just do the bloom filter lookup first. But I think even in memory systems, often rely on bloom filters before they do a hash lookup.</p>
<p>797<br>00:53:07,539 –&gt; 00:53:22,539<br>So, one bloom filter for the entire table. So it’s a data structure in this case that they’re going to, so the question is, would you have a bloom filter for the entire table? That was the question.</p>
<p>798<br>00:53:22,539 –&gt; 00:53:32,539<br>If you’re doing it the way it’s described in sort of the previous slide, where it’s built on the fly, you’re just building this bloom filter on the join attribute.</p>
<p>799<br>00:53:32,539 –&gt; 00:53:47,539<br>However, that predicate is. In practice, systems keep these bloom filters around. Again, it’s supplemental data structures. They build them as they go, maybe similar to, I think I mentioned zone maps before.</p>
<p>800<br>00:53:47,539 –&gt; 00:53:56,539<br>But there’s an optimization that database systems may build these on the fly to help with other query execution, sort of like an index as well.</p>
<p>801<br>00:53:56,539 –&gt; 00:54:08,539<br>But for this example here, where we’re just talking about how you could use a bloom filter as a filter in a hash join, you just build it dynamically just on the join attribute and then you discard it.</p>
<p>802<br>00:54:08,539 –&gt; 00:54:19,539<br>And then I’ll come back to you.</p>
<p>803<br>00:54:19,539 –&gt; 00:54:31,539<br>So the question is, we talked about index join before, and if we use a hash index for that is that different than this. Conceptually, not really, it just depends on when is the hash table being built.</p>
<p>804<br>00:54:31,539 –&gt; 00:54:48,539<br>So what I’m describing here is sort of an ephemeral hash table. This is used for query execution and then is generally discarded. Whereas if you’re using a hash join, you’re relying on a permanent data structure or permanent persistent data structure that it can reuse over and over again across multiple query.</p>
<p>805<br>00:54:48,539 –&gt; 00:55:14,539<br>So I have a follow up on the bloom filter. So if I remember correctly, is he’s built a bloom filter on all of the rows on the attribute value of all of the rows in the relation than the probability for a false positive is slightly higher than say you have two or three bloom filters built on a subset of the roles of the attribute value.</p>
<p>806<br>00:55:14,539 –&gt; 00:55:32,539<br>So your statement and question is that from your recollection, if you instead of building a very large bloom filter of a very wide one that incorporates all like sort of the the tuples attributes, it’s better to sort of layer bloom filters based on different individual attributes or a subset of the attributes.</p>
<p>807<br>00:55:32,539 –&gt; 00:56:01,539<br>In practice, yeah, bloom filters are often multilayered with how they do these sorts of things. I mentioned that there’s we talk about bloom filters longer, I think in last year’s version of this lecture, there’s also a link to like a bloom filter calculator that can basically say for how many keys, how wide is the attribute, how big does my bloom filter need to be in order to give me some sort of bound on false positives or and you can sort of play with the numbers or you could, yeah, you could Google bloom filter calculator.</p>
<p>808<br>00:56:01,539 –&gt; 00:56:08,539<br>But yeah, because they’re probabilistic data structures, there’s tradeoffs here with you’re going to trade off space versus false positives.</p>
<p>809<br>00:56:11,539 –&gt; 00:56:14,539<br>Cool, yeah, bloom filters are cool.</p>
<p>810<br>00:56:16,539 –&gt; 00:56:26,539<br>There was also, as just as inside, there was a research project here with one of Andy’s students about six or seven years ago called surf succinct range filters and they’re very similar concept.</p>
<p>811<br>00:56:26,539 –&gt; 00:56:33,539<br>They’re basically a probabilistic data structure. Bloom filters only allow you to test on is something in the set or not in the set.</p>
<p>812<br>00:56:33,539 –&gt; 00:56:42,539<br>This basically was like a bloom filter, but for range queries and it’s actually been pretty widely adopted in quite a few systems since that paper was published a few years ago.</p>
<p>813<br>00:56:42,539 –&gt; 00:56:47,539<br>So if you’re interested in bloom filters, go read the surf paper.</p>
<p>814<br>00:56:47,539 –&gt; 00:56:56,539<br>So as I mentioned, what happens if your hash table doesn’t fit in memory? So, okay, I thought there was a question.</p>
<p>815<br>00:56:56,539 –&gt; 00:57:01,539<br>And that’s where something called the partition hash join comes in.</p>
<p>816<br>00:57:01,539 –&gt; 00:57:10,539<br>We’re going to basically partition the table first and then we’re going to basically probe within each partition.</p>
<p>817<br>00:57:10,539 –&gt; 00:57:23,539<br>So we’re sort of like up or yeah, I don’t know how to describe this just using the word partition again, but we’re basically going to segment these relations into small chunks that allow us to keep this sort of information that we need in memory.</p>
<p>818<br>00:57:23,539 –&gt; 00:57:31,539<br>You’ll hear it for a do sometimes the grace hash join. It was a project out of the University of Tokyo, I think, yeah, in the 80s.</p>
<p>819<br>00:57:31,539 –&gt; 00:57:43,539<br>This was something called a database machine, which I guess is a link. I don’t know where that links to, but it’s sort of this idea of you had these very special purpose computers that were designed just for database processing.</p>
<p>820<br>00:57:43,539 –&gt; 00:57:54,539<br>They would design hardware specifically just to compute things like joins and ultimately what killed it in the 80s was Moore’s law.</p>
<p>821<br>00:57:54,539 –&gt; 00:58:09,539<br>You would spend a year, two years, three years designing the specialized system that could process your database queries. And by then Intel had put out the next generation of X86, particularly when you get to the 90s as well.</p>
<p>822<br>00:58:09,539 –&gt; 00:58:20,539<br>And it crushed you in performance. At that point, we were still getting so much faster every year or two. So that sort of killed the database machine idea then.</p>
<p>823<br>00:58:20,539 –&gt; 00:58:32,539<br>This is an example of one that Andy knows of again from the 80s. This was from Britain Lee, I think. And yeah, I don’t know. Andy finds that I’m using a dude just sitting in a tie using a database.</p>
<p>824<br>00:58:32,539 –&gt; 00:58:49,539<br>But this idea came around again. Like a lot of things in database systems and computer software systems and just this field in general. This idea came around again and you had these companies like like Teradata and Atiza, probably the most well-known database machine was Oracle’s exit data.</p>
<p>825<br>00:58:49,539 –&gt; 00:59:01,539<br>And you could buy these million dollar racks full of very specialized hardware and sort of made them database machines as they were putting specific hardware in there for query processing, things like FPGA’s specialized CPUs.</p>
<p>826<br>00:59:01,539 –&gt; 00:59:16,539<br>What kind of what kind of what took the steam out of this wave, I think, was the cloud era. So we went from because there was a brief window where this seemed like a great idea, right? We’re death of Moore’s law.</p>
<p>827<br>00:59:16,539 –&gt; 00:59:27,539<br>We’re getting reduced gains in CPU year over year and people like specialized hardware. Yes, this is the solution. But then people got less interested in specialized hardware and running on pram.</p>
<p>828<br>00:59:27,539 –&gt; 00:59:42,539<br>They wanted to run on commodity hardware in the cloud. There’s still highly specialized systems like yellow brick exists. We did a we had a seminar series talked from them about a year ago on the YouTube channel, which is really interesting about how they built sort of a specialized database system.</p>
<p>829<br>00:59:42,539 –&gt; 00:59:53,539<br>And now they’ve deployed it in a cloud setting that’s bordering on like a unicronal design where they basically boot the operating system and then they never make another system call again in the database system owns everything.</p>
<p>830<br>00:59:53,539 –&gt; 01:00:05,539<br>It’s a pretty cool system. So if that’s interesting, there’s a seminar talk on that on the database groups YouTube channel back to the partition hash join.</p>
<p>831<br>01:00:07,539 –&gt; 01:00:10,539<br>This slide is exactly the same.</p>
<p>832<br>01:00:10,539 –&gt; 01:00:24,539<br>So the basic idea is we’re going to hash this into hash the outer table R into into a sequence of buckets. We’re going to use the same hash function on the interrelation s to create buckets of its own.</p>
<p>833<br>01:00:24,539 –&gt; 01:00:32,539<br>And what you can do is you can now spill these buckets to disk because we’re using the same hash function here.</p>
<p>834<br>01:00:32,539 –&gt; 01:00:38,539<br>Keys that hash into sort of this first bucket from from table R.</p>
<p>835<br>01:00:38,539 –&gt; 01:00:45,539<br>We only have to compare sort of bucket at a time. We don’t have to worry about keeping this all in memory.</p>
<p>836<br>01:00:45,539 –&gt; 01:01:03,539<br>As we do the comparison. So you can just go down through these buckets, do the comparisons and then you emit those tuples. You don’t have to worry about keeping all this at the entire hash table in memory.</p>
<p>837<br>01:01:03,539 –&gt; 01:01:13,539<br>And in this case, you would want to use a different hash function when you’re comparing the two or you could just sort of directly compare the you could almost do like a nested loop joint inside of these buckets depending on how big they are.</p>
<p>838<br>01:01:13,539 –&gt; 01:01:19,539<br>You don’t actually need to worry about hashing again. But if you were hashing, you would want to use probably a different hash function.</p>
<p>839<br>01:01:19,539 –&gt; 01:01:32,539<br>So there’s a few edge cases here. What if a partition doesn’t fit in memory? Well, then you have to recursively partition it. You have to choose a different hash function for that specific bucket.</p>
<p>840<br>01:01:32,539 –&gt; 01:01:48,539<br>So you can create more buckets and hash those. And there’s also this option where like if the single join key has so many matching records sort of the degenerate case I said before with the sort merge join.</p>
<p>841<br>01:01:48,539 –&gt; 01:01:53,539<br>The hash join is not going to really help you here because everything’s going to hash into the same bucket and then you’re going to have to do secondary hashing on all that.</p>
<p>842<br>01:01:53,539 –&gt; 01:02:03,539<br>So you’re going to probably hashing to the same bucket. So this would be a this would be a there’s sort of degenerate cases here that you have to reason about with a hash join.</p>
<p>843<br>01:02:03,539 –&gt; 01:02:07,539<br>So what does recursive partitioning look like in this case.</p>
<p>844<br>01:02:07,539 –&gt; 01:02:17,539<br>We have this first hash hash function on R and we have a bunch of tuples that are hashing into this bucket and that’s causing a problem for us because this bucket’s now full.</p>
<p>845<br>01:02:17,539 –&gt; 01:02:30,539<br>And actually have to. There we go throw a second hash function at at this bucket one and then you end up with bucket like one prime one double prime one triple prime.</p>
<p>846<br>01:02:30,539 –&gt; 01:02:43,539<br>And then you’re going to go hash table S and the important thing to note here you have to make sure even if even if this bucket one weren’t going to spill for the inner table.</p>
<p>847<br>01:02:43,539 –&gt; 01:02:48,539<br>You have to do the double hashing now because we have to make sure that.</p>
<p>848<br>01:02:48,539 –&gt; 01:03:06,539<br>To pulls that hash into this bucket with the second hash function after spilling we make sure we check those from the inner relation if you if you only hash once or if you didn’t do that you wouldn’t necessarily be able to to to look at all the data you needed to you don’t want to accidentally skip anything.</p>
<p>849<br>01:03:06,539 –&gt; 01:03:13,539<br>So what is the cost of the hash join in the great case and you don’t need recursive partitioning.</p>
<p>850<br>01:03:13,539 –&gt; 01:03:22,539<br>It’s just three times looking at every page so we had the partition phase we’re going to read and write both tables.</p>
<p>851<br>01:03:22,539 –&gt; 01:03:35,539<br>And plus NIOs and you’re going to have to do that twice for the for the reading the right and in the probe phase you’re just going to go through each table one more time.</p>
<p>852<br>01:03:35,539 –&gt; 01:03:41,539<br>Interesting. That was just interesting that we actually reason about rights on this.</p>
<p>853<br>01:03:41,539 –&gt; 01:03:46,539<br>Join out for them when we generally have not really thought about rights.</p>
<p>854<br>01:03:46,539 –&gt; 01:03:50,539<br>Or outputs. So again we’ll put the same numbers on it.</p>
<p>855<br>01:03:50,539 –&gt; 01:03:55,539<br>What does the cost analysis look like 4,500 IOs in this case 0.45 seconds.</p>
<p>856<br>01:03:55,539 –&gt; 01:03:59,539<br>I just wander too far I think.</p>
<p>857<br>01:03:59,539 –&gt; 01:04:01,539<br>Wait did I get a real number?</p>
<p>858<br>01:04:01,539 –&gt; 01:04:08,539<br>Okay. So if the keys are skewed we have this pro oh yeah.</p>
<p>859<br>01:04:08,539 –&gt; 01:04:17,539<br>So if you do have to do the recursive ashi how do you present about the time the cost.</p>
<p>860<br>01:04:17,539 –&gt; 01:04:24,539<br>So the question is if you have to do the recursive partitioning how do you reason about the cost.</p>
<p>861<br>01:04:24,539 –&gt; 01:04:38,539<br>My answer to that is this is the only thing you should be responsible for on the midterm and I will make sure that’s true with Andy because as far as I know it’s not in any other slides and we don’t actually put any sort of cost on the recursive partitioning.</p>
<p>862<br>01:04:38,539 –&gt; 01:04:48,539<br>It’s hard to say in practice because when you’re talking about recursive partitioning it’s dependent on your data distribution at that point.</p>
<p>863<br>01:04:48,539 –&gt; 01:04:54,539<br>So the degenerate case is everything hashes into one and it sort of devolves.</p>
<p>864<br>01:04:54,539 –&gt; 01:05:03,539<br>You could probably yeah without noting a data distribution I don’t think you could actually put a reasonable sort of approximation on it.</p>
<p>865<br>01:05:03,539 –&gt; 01:05:07,539<br>Maybe someone in the YouTube comments will tell me I’m wrong.</p>
<p>866<br>01:05:07,539 –&gt; 01:05:27,539<br>So the question is what order do you do this in and because in the second hash you may have spilling as well right.</p>
<p>867<br>01:05:27,539 –&gt; 01:05:43,539<br>So in practice yeah I don’t know what a real system would do here in practice you’ve very very rarely would ever go beyond two rounds it just doesn’t seem to really happen.</p>
<p>868<br>01:05:43,539 –&gt; 01:06:03,539<br>But it’s a good question and it’s a good thing to think about is like sort of these degenerate cases when you’re actually implementing these sorts of things but in practice you sort of Andy can gleeve this out.</p>
<p>869<br>01:06:03,539 –&gt; 01:06:14,539<br>So his statement is the whole reason we’re here with a partitioned hash table in the first place is the outer relations hash table didn’t fit in memory so we’re going to have to spill that and while we’re building our inner hash table as well that’s going to have to spill as well.</p>
<p>870<br>01:06:14,539 –&gt; 01:06:29,539<br>So like as you’re streaming it you’re reading or streaming it sorry you’re reading one one page at a time that you’re writing one page at a time like that’s how I think about is that is that correct.</p>
<p>871<br>01:06:29,539 –&gt; 01:06:45,539<br>Yeah in the absence of us having any sort of constant here of talking about like the buffer pool size and introducing some constant B and reasoning about that I think the notion of just sort of streaming a page at a time from each table is probably the right way to think about these algorithms.</p>
<p>872<br>01:06:45,539 –&gt; 01:06:59,539<br>Because this is sort of in the absence of it is a little bizarre that sometimes we talk about what this would do with a buffer pool and what it wouldn’t but when we’re generally just thinking about these algorithms we were just thinking there’s no buffer pool.</p>
<p>873<br>01:06:59,539 –&gt; 01:07:05,539<br>And just what it what would be the the I.O. cost.</p>
<p>874<br>01:07:05,539 –&gt; 01:07:10,539<br>So there’s an optimization we can do in the case of sort of very skewed keys that time right.</p>
<p>875<br>01:07:10,539 –&gt; 01:07:12,539<br>Yeah.</p>
<p>876<br>01:07:12,539 –&gt; 01:07:14,539<br>We have 11 minutes is that right.</p>
<p>877<br>01:07:14,539 –&gt; 01:07:17,539<br>Okay.</p>
<p>878<br>01:07:17,539 –&gt; 01:07:29,539<br>If your keys are very skewed and you notice a lot of things going into the same buckets you can you can have this notion of a hot partition where you basically just say okay these keys are are hashing over and over again to this same partition.</p>
<p>879<br>01:07:29,539 –&gt; 01:07:50,539<br>And you can sort of it’s sort of like similar to the notion of a pinning in a buffer pool you can basically say these partitions should stay in memory and you’re going to do sort of comparisons immediately you’re not going to worry about these sort of separate phases of a build an appropriate phase like you can basically as you’re doing the building.</p>
<p>880<br>01:07:50,539 –&gt; 01:08:06,539<br>You can you can compute that you could do the some of these comparisons on the fly in practice it’s not really done it’s pretty difficult to do and and but you will see some notion of a hybrid hash join sometimes in literature.</p>
<p>881<br>01:08:06,539 –&gt; 01:08:19,539<br>So that’s why we’re just sort of presenting it is something that could exist here in the notion in the case of highly skewed data this is sort of an alternative I guess to like spilling those first those first buckets and creating like ever growing.</p>
<p>882<br>01:08:19,539 –&gt; 01:08:26,539<br>Buckets like you could do an optimization here and just keep those ones in memory and start doing our comparisons as on the fly.</p>
<p>883<br>01:08:26,539 –&gt; 01:08:48,539<br>So we’re going to wrap up I think on hash joins in this case the inner table can be any size and ideally we would love for the outer table to fit into memory that would be best case scenario so this is another example of like this is something the optimizer needs to try to get right.</p>
<p>884<br>01:08:48,539 –&gt; 01:08:55,539<br>Table sizes and actually usually that hard to to reason about like that that it can actually get right.</p>
<p>885<br>01:08:55,539 –&gt; 01:09:17,539<br>And then if we know if we know the size of that outer table we could do something like a static hash table and we don’t have to worry about resizing this thing if it gets to a certain size like we can just basically pre allocate the buffers that we need for this hash table we know based on this table size that I’m going to need this big of a hash table and not constantly have to to rehash otherwise we have to use like dynamic hash tables.</p>
<p>886<br>01:09:17,539 –&gt; 01:09:24,539<br>Or allow for things to like spill into like basement pages of this hash table.</p>
<p>887<br>01:09:24,539 –&gt; 01:09:53,539<br>So as question is if the query comes in.</p>
<p>888<br>01:09:53,539 –&gt; 01:10:02,539<br>So query comes in and I need space my buffer pool to run these sort of hash joins like is that memory sort of reserved for you or how does that work.</p>
<p>889<br>01:10:02,539 –&gt; 01:10:13,539<br>Generally it’s a knob you can tune in these database systems like how much space do you set aside for for working memory in the buffer pool for things like hash tables and stuff like that.</p>
<p>890<br>01:10:13,539 –&gt; 01:10:29,539<br>So the system may allocate it on the side as like a separate buffer pool or something like that just for hash joins because they may be able to say okay based on concurrency in the system we can reason about how much contention there would be for that data structure but it’s sort of a system design implementation decision.</p>
<p>891<br>01:10:29,539 –&gt; 01:10:33,539<br>But always a good thing to be thinking about.</p>
<p>892<br>01:10:33,539 –&gt; 01:10:44,539<br>So how come we call the outer table which we call the one that is the hash table the other table for index and the hash table.</p>
<p>893<br>01:10:44,539 –&gt; 01:10:59,539<br>So the question is why do we call the outer table the table that has the hash table built for a hash join versus when I was talking about an index that’s the loose joint the inner join is the one that would maybe have the hash table on it.</p>
<p>894<br>01:10:59,539 –&gt; 01:11:18,539<br>So the I don’t want to get too fixated on that inner table on an on an index join being a hash table or hash index potentially like in practice it’s probably going to be a B plus tree so I don’t want to like confuse those those two ideas for you guys.</p>
<p>895<br>01:11:18,539 –&gt; 01:11:35,539<br>So for a nested loop join you would still</p>
<p>896<br>01:11:35,539 –&gt; 01:12:02,539<br>have to use the hash join to other table smaller so the hash table smaller is more like a different memory whereas with with index join the inner table is larger so you would want to use an index to speed up per outer table of time.</p>
<p>897<br>01:12:02,539 –&gt; 01:12:25,539<br>So for example if you use a B plus tree index on the outer table in the index join and your inner loop has more iterations then your total lookup time would be higher than compared to you use each key in the outer loop and you probe it into an index in the inner table.</p>
<p>898<br>01:12:25,539 –&gt; 01:12:35,539<br>So I would think it was probably in the index every time but you’re probing a smaller number of times.</p>
<p>899<br>01:12:35,539 –&gt; 01:12:41,539<br>I think it’s better to stream below the table with index.</p>
<p>900<br>01:12:41,539 –&gt; 01:13:00,539<br>Yeah and so in hash joins we typically also just refer to like again it’s like an implementation thing like they they loved overload the terminology of like you have your build you’ve your build side and you have your probe side of your tables like they don’t necessarily always reason about outer and inner tables were like your outer tables your build side your inter tables your probe side.</p>
<p>901<br>01:13:00,539 –&gt; 01:13:19,539<br>So it’s the terminology gets a little weird especially like you said when you’re dealing with an index join in nested index nested loop join where like the inner tables the one that’s relying on the index or has the index already but that’s yeah that’s just the way the terminology has wound up yeah.</p>
<p>902<br>01:13:19,539 –&gt; 01:13:29,539<br>So generally hashing is probably going to be the better choice like unless you specifically need ordering.</p>
<p>903<br>01:13:29,539 –&gt; 01:13:40,539<br>The hash hash joins are usually the way to do it there’s a lot of modern analytical systems that just sort of default to a hash join they don’t even bother reasoning about anything else.</p>
<p>904<br>01:13:40,539 –&gt; 01:14:01,539<br>The note here says good demoses use either both so like a more traditional like transactional or just general purpose all around system like a postgres they’re going to support all these sorts of joins whereas like highly specialized systems high very fast transactional systems will focus on index joins and oh lap systems will typically use hash joins.</p>
<p>905<br>01:14:01,539 –&gt; 01:14:14,539<br>So next class you guys get to start talking about how to actually execute these queries that’s going to be on Monday and then like the initial slide said you guys have a midterm on Wednesday so good luck with that.</p>
<p>906<br>01:14:31,539 –&gt; 01:14:45,539<br>Now listen I’m the poppy with the motherfucking 28 gram dependent on if it’s the pop you ain’t hit them all yet still got your sugar I smack you with the bottom of the clip to tell you look up show me what it’s a set for blow your face back.</p>
<p>907<br>01:14:45,539 –&gt; 01:14:58,539<br>I got a block on tap the feds can’t trace that style is like tap the proof you can’t lace that the Dominic and oh you got call me Dominican black Skelly black and other black sweat Timberlands my whole black 38 and send you to the perigates.</p>
<p>908<br>01:14:58,539 –&gt; 01:15:08,539<br>You get the lava trying to skate and that’s your first statement. I ain’t lying for that cake. I can’t see you wait my granddad’s happy weight the Rand to every state when he acting how I’m living tell him I’m living great.</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CMU15445 P12F202311 JoinAlgorithms</div>
      <div>http://example.com/2025/10/24/CMU15445 P12F202311-JoinAlgorithms/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月24日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/24/CMU15445%20P13F202312-QueryExecutionPart1/" title="CMU15445 P13F202312 QueryExecutionPart1">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CMU15445 P13F202312 QueryExecutionPart1</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/24/CMU15445%20P11F202310-SortingAggregationAlgorithms/" title="CMU15445 P11F202310 SortingAggregationAlgorithms">
                        <span class="hidden-mobile">CMU15445 P11F202310 SortingAggregationAlgorithms</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
