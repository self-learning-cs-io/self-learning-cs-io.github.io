

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="100:00:00,000 –&gt; 00:00:29,500Alright, so we are going to talk about 200:00:29,500 –&gt; 00:00:49,480a 300:00:49,500 –&gt; 00:00:58,500policing 400:00:58,500 –&gt; 00:01:03,980slide is on the websit">
<meta property="og:type" content="article">
<meta property="og:title" content="CMU15445 P15F202314 QueryPlanningOptimization">
<meta property="og:url" content="http://example.com/2025/10/24/CMU15445%20P15F202314-QueryPlanningOptimization/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="100:00:00,000 –&gt; 00:00:29,500Alright, so we are going to talk about 200:00:29,500 –&gt; 00:00:49,480a 300:00:49,500 –&gt; 00:00:58,500policing 400:00:58,500 –&gt; 00:01:03,980slide is on the websit">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-24T12:00:44.467Z">
<meta property="article:modified_time" content="2025-10-24T12:06:28.540Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>CMU15445 P15F202314 QueryPlanningOptimization - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CMU15445 P15F202314 QueryPlanningOptimization"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-24 20:00" pubdate>
          2025年10月24日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          8.8k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          74 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">CMU15445 P15F202314 QueryPlanningOptimization</h1>
            
            
              <div class="markdown-body">
                
                <p>1<br>00:00:00,000 –&gt; 00:00:29,500<br>Alright, so we are going to talk about</p>
<p>2<br>00:00:29,500 –&gt; 00:00:49,480<br>a</p>
<p>3<br>00:00:49,500 –&gt; 00:00:58,500<br>policing</p>
<p>4<br>00:00:58,500 –&gt; 00:01:03,980<br>slide is on the website. Yes. And if it’s not, let me know. I think it just went up this</p>
<p>5<br>00:01:03,980 –&gt; 00:01:12,700<br>morning along with the notes and the video. So the lecture from Monday should be up over</p>
<p>6<br>00:01:12,700 –&gt; 00:01:20,939<br>there. I mean, not seeing it. Sorry. I’ll put this up right after the talk. Yep. It’s a</p>
<p>7<br>00:01:20,939 –&gt; 00:01:26,659<br>whole new set of slides from what was there last time. So just pay attention and then</p>
<p>8<br>00:01:26,659 –&gt; 00:01:35,979<br>I’ll get you through all of that. Other questions? Okay. All right. So let’s get started.</p>
<p>9<br>00:01:35,979 –&gt; 00:01:45,579<br>And we are going to go and take a look at query optimization. There we go. All right. So,</p>
<p>10<br>00:01:45,579 –&gt; 00:01:55,659<br>okay. Move. All right. We’re going to look at this query over here, which is a very simple</p>
<p>11<br>00:01:55,659 –&gt; 00:02:02,619<br>select query. And we’re going to go and walk through the motions for optimizing this</p>
<p>12<br>00:02:02,619 –&gt; 00:02:08,419<br>query. Okay. So this looks pretty simple. To set up the machinery for query optimization,</p>
<p>13<br>00:02:08,419 –&gt; 00:02:12,699<br>we’re first going to need access to this thing called the catalog, which I know we’ve talked</p>
<p>14<br>00:02:12,699 –&gt; 00:02:18,219<br>about briefly, but we’ll understand it far more deeply today. And this is going to have,</p>
<p>15<br>00:02:18,219 –&gt; 00:02:22,740<br>think of it as metadata for all the data that you have, right? It’s a mini database, if</p>
<p>16<br>00:02:22,740 –&gt; 00:02:27,580<br>you wish. And it has information. For example, I’ve got two tables in the system. One is</p>
<p>17<br>00:02:27,580 –&gt; 00:02:32,620<br>the employee table and then there’s the department table. And along with that information,</p>
<p>18<br>00:02:32,620 –&gt; 00:02:39,780<br>such as there are 10,000 records in the amp table and 500 records on the department table</p>
<p>19<br>00:02:39,780 –&gt; 00:02:44,140<br>and they spread across 50 pages. So basically 10 records per page in each of the tables.</p>
<p>20<br>00:02:44,140 –&gt; 00:02:49,780<br>So those are stats that get stored in the catalog with everything else. I’ve also shown</p>
<p>21<br>00:02:49,780 –&gt; 00:02:54,300<br>little triangles. The dark triangles means I’ve got a clustered index built on that attribute.</p>
<p>22<br>00:02:54,300 –&gt; 00:03:00,420<br>So there’s a clustered index on SSN in the amp table and unclustered indices on the amp name</p>
<p>23<br>00:03:00,420 –&gt; 00:03:08,939<br>and the department ID fields. Okay. So that’s a setup. Now we are going to go and start to optimize</p>
<p>24<br>00:03:08,939 –&gt; 00:03:18,300<br>this query. And the first query plan that we start with is a literal implementation of the way</p>
<p>25<br>00:03:18,300 –&gt; 00:03:23,460<br>in which you would go and evaluate this query following SQL semantics, which says, take everything</p>
<p>26<br>00:03:23,460 –&gt; 00:03:30,939<br>from the from clause to a Cartesian product that gives you the ampent department and then go ahead</p>
<p>27<br>00:03:30,939 –&gt; 00:03:38,780<br>and take a look at that information in and apply the selection, which is applying the joint</p>
<p>28<br>00:03:38,780 –&gt; 00:03:43,980<br>condition followed by the selection on the department name and the projection on the employee.</p>
<p>29<br>00:03:44,379 –&gt; 00:03:49,500<br>So an optimizer is going to consider a variety of different plans, including a plan like this.</p>
<p>30<br>00:03:49,500 –&gt; 00:03:54,780<br>Now this is a Cartesian product. So most optimizers won’t. So this is just for getting us going today.</p>
<p>31<br>00:03:54,780 –&gt; 00:04:00,379<br>But what we have to do is to figure out what is the cost of this plan. And you’re going to figure</p>
<p>32<br>00:04:00,379 –&gt; 00:04:05,339<br>this out without actually running the plan because as we’ll see very soon is a number of plans that</p>
<p>33<br>00:04:05,339 –&gt; 00:04:10,699<br>you can produce for the query is a very large number. It is an NP hard problem. So we can’t run the</p>
<p>34<br>00:04:10,699 –&gt; 00:04:15,019<br>query to figure out whether we should run the query, right? That’s oxymoronic. So we have to look</p>
<p>35<br>00:04:15,019 –&gt; 00:04:20,539<br>at the query and then figure out how much does it cost. And then look at other ways of getting that</p>
<p>36<br>00:04:20,539 –&gt; 00:04:25,659<br>same answer that SQL semantics and then figure out if there’s a better way to do it than this.</p>
<p>37<br>00:04:26,539 –&gt; 00:04:31,419<br>What’s the cost of this plan? So you’re going to start working like an optimizer. So we’ve enumerated</p>
<p>38<br>00:04:31,419 –&gt; 00:04:35,819<br>our first plan. Heating an optimizer does is enumerate plans. We’ve done the first plan.</p>
<p>39<br>00:04:36,300 –&gt; 00:04:42,939<br>It’s a logical plan as we will see. This is just a view of what that query execution would look like.</p>
<p>40<br>00:04:42,939 –&gt; 00:04:48,860<br>And then we start to say how much does it cost? We’ll reach to our catalogs along with cost models</p>
<p>41<br>00:04:48,860 –&gt; 00:04:55,579<br>that we have written in code and start making assumptions. So we’ll say this operation of a</p>
<p>42<br>00:04:55,579 –&gt; 00:04:59,740<br>Cartesian product I have to read the two inputs, which is 50 pages and</p>
<p>43<br>00:04:59,740 –&gt; 00:05:07,660<br>50 pages. And I have to write a whole bunch of pages. And the number of writes in those pages,</p>
<p>44<br>00:05:08,220 –&gt; 00:05:14,220<br>I think I have a typo here that should be 1,000 pages, which we are reading both of those in.</p>
<p>45<br>00:05:14,699 –&gt; 00:05:19,740<br>And then, oh, actually, I know what’s happening there. That’s basically looking at each of the page,</p>
<p>46<br>00:05:19,740 –&gt; 00:05:25,740<br>the 50 pages times 1,000. That’s the cost of the Cartesian product. 50 times a thousand, right? It’s</p>
<p>47<br>00:05:26,220 –&gt; 00:05:31,900<br>imagine doing a nested loops to do this Cartesian product. So that’s the second number is the cost</p>
<p>48<br>00:05:31,900 –&gt; 00:05:37,660<br>to do the Cartesian product. But now I’m going to produce an output. So I have to figure out what that</p>
<p>49<br>00:05:37,660 –&gt; 00:05:43,420<br>output size is. I’m going to assume my stats are correct that there are 10,000 records in one</p>
<p>50<br>00:05:43,420 –&gt; 00:05:49,420<br>and 500 records in the other. And so what’s going to be the size of that output in terms of number</p>
<p>51<br>00:05:49,420 –&gt; 00:05:56,699<br>of records in a Cartesian product? It’s a Cartesian product. So every record will pair with every</p>
<p>52<br>00:05:56,699 –&gt; 00:06:03,500<br>other record, right? So it will be 10,000 times 500. That’s how many record pairs I’ll produce.</p>
<p>53<br>00:06:03,500 –&gt; 00:06:10,620<br>It’s a Cartesian product, right? What is the space for each of those records? In the original tables,</p>
<p>54<br>00:06:10,620 –&gt; 00:06:16,620<br>we could fit 10 records per page. Now each record that we produce as output is twice as big,</p>
<p>55<br>00:06:16,620 –&gt; 00:06:23,340<br>right? Twice as wide. So we’ll fit five on a page, right? So we will have 10,000 records multiplied</p>
<p>56<br>00:06:23,340 –&gt; 00:06:29,819<br>by 500 records, which is five million, divide by five. It tells me that this output is a million pages</p>
<p>57<br>00:06:29,819 –&gt; 00:06:36,379<br>long. Does that make sense? It’s just the pure product of the cardinalities that are input. That’s</p>
<p>58<br>00:06:36,379 –&gt; 00:06:41,500<br>how Cartesian’s product for. As you can see, we are starting to cost these. And these are all guesses,</p>
<p>59<br>00:06:41,500 –&gt; 00:06:46,139<br>but they are pretty good guesses based on the stats we have. The stats could be wrong, maybe a count</p>
<p>60<br>00:06:46,139 –&gt; 00:06:50,139<br>for the number of pages or number of records is not perfect. And we’ll get to that in a bit,</p>
<p>61<br>00:06:50,139 –&gt; 00:06:54,620<br>but assuming what we know, we’re going to take those costs that we know, plus some of these other</p>
<p>62<br>00:06:54,620 –&gt; 00:07:01,819<br>things and try to guess what the cost of this model is of this operation is. Everyone with me so far?</p>
<p>63<br>00:07:05,500 –&gt; 00:07:09,500<br>Five couples per page. How did I get five couples per page? Because the Cartesian product is going</p>
<p>64<br>00:07:09,500 –&gt; 00:07:13,899<br>to have an M record and a department record side by side, right? So I’m just projecting all of those</p>
<p>65<br>00:07:14,459 –&gt; 00:07:21,019<br>out. So the output record would be twice as wide, twice as many bytes per record as the input.</p>
<p>66<br>00:07:21,019 –&gt; 00:07:23,819<br>Because I’m just combining all the attributes from both of those together.</p>
<p>67<br>00:07:26,620 –&gt; 00:07:31,259<br>All of those, yeah, we’re just taking all of those and passing it along, keeping all of those across.</p>
<p>68<br>00:07:33,739 –&gt; 00:07:34,379<br>Okay, yep.</p>
<p>69<br>00:07:35,339 –&gt; 00:07:39,100<br>Ask again, sorry.</p>
<p>70<br>00:07:42,459 –&gt; 00:07:47,100<br>Why is the first entry 50 nested groups joined? So I will read 50 pages. That’s my</p>
<p>71<br>00:07:47,980 –&gt; 00:07:52,379<br>outer block in the nested loops and I’m going to screen over the other stuff. So it’s just that cost.</p>
<p>72<br>00:07:52,379 –&gt; 00:07:55,819<br>Now, of course, I could have implemented Cartesian product in a slightly different way. I could</p>
<p>73<br>00:07:55,819 –&gt; 00:08:00,300<br>have get a different number for the first two, but that comes from the assumption of how that algorithm</p>
<p>74<br>00:08:00,300 –&gt; 00:08:04,860<br>is implemented. Okay, and we’ll get to details of that as we switch around algorithms, but that’s a great</p>
<p>75<br>00:08:04,860 –&gt; 00:08:09,180<br>question. How am I getting all these costs? I’m guessing based on algorithmic properties,</p>
<p>76<br>00:08:09,900 –&gt; 00:08:14,139<br>input stats, and I’m trying to get to a rough number that is not too far out. That’s all we care</p>
<p>77<br>00:08:14,139 –&gt; 00:08:19,740<br>about. It doesn’t need to be precise to the last bit over here. Okay, other questions?</p>
<p>78<br>00:08:22,060 –&gt; 00:08:28,060<br>All right, now we say what is the next stuff which says a selection on MPID with department ID</p>
<p>79<br>00:08:28,060 –&gt; 00:08:33,820<br>costs. Okay, now here we’re going to assume that we know that there’s a foreign key relationship</p>
<p>80<br>00:08:33,820 –&gt; 00:08:40,059<br>between the two components and so I’m going to say it’s this operation is going to read in the</p>
<p>81<br>00:08:40,059 –&gt; 00:08:45,259<br>million pages that were written by the previous. So that’s the first million and then it’s going to</p>
<p>82<br>00:08:45,259 –&gt; 00:08:55,340<br>write its output. How big is its output? Its output is estimated to be 2000 writes. Why? Because I’ve</p>
<p>83<br>00:08:55,340 –&gt; 00:09:01,259<br>got the Cartesian product. If the primary key foreign key relationship holds, that means for every</p>
<p>84<br>00:09:01,259 –&gt; 00:09:07,500<br>record in the MP table, there is one department ID because that’s the key relationship. This means</p>
<p>85<br>00:09:07,500 –&gt; 00:09:13,019<br>after I apply this selection, my output will be the same number of records as there are in the</p>
<p>86<br>00:09:13,019 –&gt; 00:09:18,700<br>MP table, which is 10,000 records. Five of these now bigger records that we are working with fit on</p>
<p>87<br>00:09:18,700 –&gt; 00:09:27,020<br>a page. So the output size that I will have is 2000 pages. That’s how much I write. Okay,</p>
<p>88<br>00:09:27,020 –&gt; 00:09:32,460<br>everyone let me so far. So again, I’m making, I’m looking at the schema, I’m guessing, but I’m</p>
<p>89<br>00:09:32,460 –&gt; 00:09:37,580<br>making good educated guesses. That’s what an optimizer has to do. And as you see, it’s getting harder</p>
<p>90<br>00:09:37,580 –&gt; 00:09:42,460<br>as we get up the tree. The first one was easy. There was no guesswork. Now the second one’s building</p>
<p>91<br>00:09:42,460 –&gt; 00:09:48,460<br>on stuff that the first operator outputted and if you make a mistake there in a estimation, the errors</p>
<p>92<br>00:09:48,460 –&gt; 00:09:54,220<br>will carry through. Okay, but we have to find a way to cost it and that’s what we are doing.</p>
<p>93<br>00:09:55,019 –&gt; 00:10:01,740<br>Next stage, we are going to apply the selection on department name is equal to toy. Now again,</p>
<p>94<br>00:10:01,740 –&gt; 00:10:08,620<br>we’ll start guessing, educated guessing. We’ll say department ID is a key in the department table.</p>
<p>95<br>00:10:09,580 –&gt; 00:10:17,019<br>And there are 500 records. So on average, what is the probability that a department ID field has a</p>
<p>96<br>00:10:17,019 –&gt; 00:10:22,299<br>name toy is going to be one over 500. You’re just going to assume there’s uniform distribution</p>
<p>97<br>00:10:22,299 –&gt; 00:10:27,179<br>of employees across all the departments, which may not be true. Maybe every employee works in the</p>
<p>98<br>00:10:27,179 –&gt; 00:10:32,139<br>toy department, for example, or no one works in the toy department, but we are just averaging</p>
<p>99<br>00:10:32,139 –&gt; 00:10:37,980<br>things out. We just assume a uniform distribution of the data across these two tables with respect to</p>
<p>100<br>00:10:37,980 –&gt; 00:10:45,259<br>that key relationship. Okay, so now we will end up with a table in which that operation we are going</p>
<p>101<br>00:10:45,259 –&gt; 00:10:54,139<br>to have to read as you might guess, 2000 pages. Come on, there we go. And we’re going to write</p>
<p>102<br>00:10:54,139 –&gt; 00:11:00,299<br>four. That four is simply dividing by 500 the number of records we had, which was 10,000,</p>
<p>103<br>00:11:00,299 –&gt; 00:11:05,419<br>dividing a game by five, because that’s how many records fit on the page. And that’s the</p>
<p>104<br>00:11:06,539 –&gt; 00:11:12,220<br>size of that output page, four pages for that output for that operation.</p>
<p>105<br>00:11:12,540 –&gt; 00:11:17,820<br>Last, we are going to project out the employee name, just that one column is all that the query</p>
<p>106<br>00:11:17,820 –&gt; 00:11:25,259<br>wanted. And we’ll read for that again, that one page, the four reads, and then go write that up.</p>
<p>107<br>00:11:25,980 –&gt; 00:11:33,740<br>So we’ve got a correct plan. We’ve taken a logical view of that query, written that down here,</p>
<p>108<br>00:11:33,740 –&gt; 00:11:38,540<br>come up with a cost for it in the first thing that we said is a way in which we could go run</p>
<p>109<br>00:11:38,620 –&gt; 00:11:44,539<br>this query. And that’s two million IOs. You add all of those numbers up, trust me, it comes out to</p>
<p>110<br>00:11:44,539 –&gt; 00:11:50,779<br>about two million IOs. Okay, can we do better? That’s the job of the optimizer. Can I do better?</p>
<p>111<br>00:11:50,779 –&gt; 00:11:56,219<br>And now we start enumerating, right? We start saying, what are other ways I can run this query?</p>
<p>112<br>00:11:56,699 –&gt; 00:12:02,699<br>And here’s another way that you could run this query. So again, this is a logical query plan</p>
<p>113<br>00:12:02,700 –&gt; 00:12:09,259<br>that says, do a join first, don’t do a Cartesian product, that’s dumb. Do a join between these two</p>
<p>114<br>00:12:09,259 –&gt; 00:12:15,980<br>tables, then do the rest of it as we did before. Okay, now the question is, what join do we use?</p>
<p>115<br>00:12:16,620 –&gt; 00:12:22,060<br>So we’re now getting a little bit more detailed into this plan space. And we’ll say, let’s do a page</p>
<p>116<br>00:12:22,060 –&gt; 00:12:28,379<br>nested loops. If we do a page nested loops, plug in the formulas you had from the last few lectures,</p>
<p>117<br>00:12:28,379 –&gt; 00:12:33,100<br>some that you looked at when we looked at query operations. And that’s going to be that 50 plus</p>
<p>118<br>00:12:33,100 –&gt; 00:12:37,580<br>5,000. And now we are going to do 2,000 as the right. The first two terms come from simply</p>
<p>119<br>00:12:37,580 –&gt; 00:12:42,779<br>plugging in the cost of doing block nested loops into the formulas we have from before. And that’s</p>
<p>120<br>00:12:42,779 –&gt; 00:12:47,340<br>why those formulas are important. The 2000 is exactly the same as what we had before, right? And</p>
<p>121<br>00:12:47,340 –&gt; 00:12:53,179<br>that upper part of the tree. So all we did is took this portion here, these two bottom operators</p>
<p>122<br>00:12:53,179 –&gt; 00:12:57,899<br>and combined them to do a join because that’s what you would do, right? That’s much more efficient.</p>
<p>123<br>00:12:57,899 –&gt; 00:13:03,740<br>And we add the rest of it up, nothing changes there. And you end up with 54,000 IOs.</p>
<p>124<br>00:13:04,379 –&gt; 00:13:09,980<br>Very different from 2 million IOs that we had before. Can we do better? And that’s good you</p>
<p>125<br>00:13:09,980 –&gt; 00:13:13,419<br>don’t have the slides. So I want you to think right now. I’ll put the slides up immediately after that.</p>
<p>126<br>00:13:14,620 –&gt; 00:13:18,379<br>Okay, as I said, I read it the whole talk. So let’s see, can we do better?</p>
<p>127<br>00:13:18,779 –&gt; 00:13:20,779<br>Yep.</p>
<p>128<br>00:13:26,779 –&gt; 00:13:31,340<br>Yeah, so it’s basically can we, why are we carrying all these department columns all across,</p>
<p>129<br>00:13:31,340 –&gt; 00:13:35,980<br>just look at the department name and department ID and bring that along? Definitely. We will</p>
<p>130<br>00:13:35,980 –&gt; 00:13:40,220<br>definitely do that. It’s basically doing projection push down as we’ve seen a little bit.</p>
<p>131<br>00:13:40,220 –&gt; 00:13:43,500<br>Another idea? Did you have another idea? Okay.</p>
<p>132<br>00:13:43,899 –&gt; 00:13:51,179<br>Those are indices on the tables. So I already mentioned that. Dark ones are the clustered indices.</p>
<p>133<br>00:13:51,820 –&gt; 00:13:57,980<br>Yep. Exactly. We could change the algorithm. Why do you do you look at all these join algorithms?</p>
<p>134<br>00:13:57,980 –&gt; 00:14:01,419<br>Because we know some are better block-dested loops is probably not as good.</p>
<p>135<br>00:14:02,059 –&gt; 00:14:07,500<br>Right? So let’s do that. We’ll switch the join algorithm to a sort merge. Let’s just say I picked</p>
<p>136<br>00:14:07,500 –&gt; 00:14:12,620<br>that and then we’ll say how much would it cost? But with sort merge, I’ll also need to know how much</p>
<p>137<br>00:14:12,620 –&gt; 00:14:18,060<br>of a buffer pool space am I going to get? Right? Because my cost is going to depend. Do I do a two-pass</p>
<p>138<br>00:14:18,060 –&gt; 00:14:22,299<br>algorithm? Do I do a four-pass algorithm? That’s going to depend upon how much space do I have.</p>
<p>139<br>00:14:22,299 –&gt; 00:14:26,700<br>That’s why we needed all these numbers. So now we’re adding a little bit more detail. I’m creating a</p>
<p>140<br>00:14:26,700 –&gt; 00:14:32,139<br>plan. But for this plan to work, if I’m doing a sort merge, I’m saying I need 50 pages of buffer</p>
<p>141<br>00:14:32,139 –&gt; 00:14:39,419<br>pool to do my sort merge. Plug the formulas in as before from the class. That comes to 3,150 and then</p>
<p>142<br>00:14:39,419 –&gt; 00:14:47,659<br>2000 writes same thing carries over. Yep. Oh, very good. I didn’t put the slash. That’s great.</p>
<p>143<br>00:14:47,659 –&gt; 00:14:51,500<br>That’s exactly what we are going to do next. And you’re thinking now. You’re thinking I can optimize</p>
<p>144<br>00:14:51,500 –&gt; 00:14:55,819<br>her. How can I do this well? We spent all this time with query execution saying all of these</p>
<p>145<br>00:14:55,819 –&gt; 00:15:00,139<br>things matter. But now we are saying how do we make the plan to make all of that stuff work?</p>
<p>146<br>00:15:00,139 –&gt; 00:15:06,139<br>And that’s exactly right. So if we just chase this down by simply switching the algorithm to</p>
<p>147<br>00:15:06,139 –&gt; 00:15:11,899<br>sort merge join, we come down to a dramatically smaller number about 7,000 IOs. And exactly as</p>
<p>148<br>00:15:11,899 –&gt; 00:15:16,460<br>was suggested, this is with materialization. Why we reading and writing at every point? Could we</p>
<p>149<br>00:15:16,460 –&gt; 00:15:21,100<br>just pipeline as we talked about? Right? Pipeline says just produce the output and send it across.</p>
<p>150<br>00:15:21,100 –&gt; 00:15:24,699<br>When you talked about the vectorization model, we’ll say that vectorization might be doing a</p>
<p>151<br>00:15:24,699 –&gt; 00:15:29,659<br>vector at a time. But regardless, we are not landing all the data, storing it to a temp file at the</p>
<p>152<br>00:15:29,659 –&gt; 00:15:34,700<br>end of each operator and reading it back in the next one. So we are doing something far simpler.</p>
<p>153<br>00:15:34,700 –&gt; 00:15:40,940<br>So that’s exactly what we’ll do. And if you do that with pipelining, you cross out all the back</p>
<p>154<br>00:15:40,940 –&gt; 00:15:45,660<br>and forth read writes that are happening. Assume you can fit everything in memory, which means in this</p>
<p>155<br>00:15:45,660 –&gt; 00:15:49,820<br>case, the plan is simple. You just need a 50 buffers for the sort merge. But imagine you had one</p>
<p>156<br>00:15:49,820 –&gt; 00:15:53,740<br>join feeding into another join and stuff like that. You need to count all the memory spaces that you</p>
<p>157<br>00:15:53,740 –&gt; 00:15:58,860<br>need to make that work. If you have that, you can pipeline that through. And now we have 3000 IOs.</p>
<p>158<br>00:15:58,860 –&gt; 00:16:04,060<br>So we came down from 2 million to 3000. So you see why optimizer guys, people who know how to</p>
<p>159<br>00:16:04,700 –&gt; 00:16:08,700<br>optimize the folks who know how to write good optimizers, they’re often the highest paid people in</p>
<p>160<br>00:16:08,700 –&gt; 00:16:12,460<br>the database companies. And it’s not just this. Obviously, we’ll do a lot more. You’ll see it’ll get</p>
<p>161<br>00:16:12,460 –&gt; 00:16:18,140<br>a lot more complex. But the big difference that it makes, hopefully, that’s coming through.</p>
<p>162<br>00:16:18,140 –&gt; 00:16:19,660<br>Can we do better? Yep.</p>
<p>163<br>00:16:19,660 –&gt; 00:16:22,860<br>I was trying to think about the work space course.</p>
<p>164<br>00:16:22,860 –&gt; 00:16:24,300<br>Yeah.</p>
<p>165<br>00:16:24,300 –&gt; 00:16:25,340<br>Yeah.</p>
<p>166<br>00:16:25,340 –&gt; 00:16:26,300<br>Yeah.</p>
<p>167<br>00:16:26,300 –&gt; 00:16:33,660<br>That’s great. So the question is, should we be thinking about the worst case course as opposed to</p>
<p>168<br>00:16:33,659 –&gt; 00:16:39,259<br>the best case courses you make in memory? That’s exact. That’s true. Here, for example, I’m saying at</p>
<p>169<br>00:16:39,259 –&gt; 00:16:45,179<br>the query optimization time, planning time, I’m hoping to get 50 buffer pages. But what if I start to</p>
<p>170<br>00:16:45,179 –&gt; 00:16:49,179<br>run the query and I don’t have that, and I only get five? So the question is, what do I do? Should I</p>
<p>171<br>00:16:49,179 –&gt; 00:16:54,379<br>plan for that? Absolutely. And the most standard way to do that is to make a plan, start running. And</p>
<p>172<br>00:16:54,379 –&gt; 00:16:58,620<br>then say, whoops, at runtime, what I thought was going to happen is not there. Can I adapt the</p>
<p>173<br>00:16:58,620 –&gt; 00:17:03,580<br>plan on the fly? So you can do adaptive query processing, adaptive query optimization,</p>
<p>174<br>00:17:03,580 –&gt; 00:17:08,059<br>wilding query processing, and interleave both of those. Take the advanced graduate database class</p>
<p>175<br>00:17:08,059 –&gt; 00:17:12,859<br>and we talk about stuff like that. So right now, we are assuming optimization happens, then processing,</p>
<p>176<br>00:17:12,859 –&gt; 00:17:16,940<br>but you can interleave those, especially as you start to realize whoops, something that happened.</p>
<p>177<br>00:17:16,940 –&gt; 00:17:21,819<br>You can do other kinds of things too. So for example, you can say, hey, when I do that, I’m expecting</p>
<p>178<br>00:17:21,819 –&gt; 00:17:27,740<br>that input to be 2000 pages in that second operator. At runtime, you can say, oh my gosh, instead of</p>
<p>179<br>00:17:27,740 –&gt; 00:17:33,259<br>2000, it seems like I’ve already seen 20,000 pages and it’s still going. I’m way off. You can say,</p>
<p>180<br>00:17:33,259 –&gt; 00:17:38,140<br>I’m sure the rest of the plan is also bad. I need to go re-optimize that or do something different.</p>
<p>181<br>00:17:38,140 –&gt; 00:17:42,700<br>So you can keep track of all these calculations we are doing as stats. When we create the plan to say,</p>
<p>182<br>00:17:42,700 –&gt; 00:17:47,180<br>this is what I expected to be. And if it’s not, then maybe I should do something about it.</p>
<p>183<br>00:17:47,180 –&gt; 00:17:50,380<br>There are other ways in which you could do something about it, including saying, I’ll kill the query,</p>
<p>184<br>00:17:50,380 –&gt; 00:17:54,940<br>I’ve just started. I’m way off. Go back to the optimize and ask it to dig a little bit deeper.</p>
<p>185<br>00:17:54,940 –&gt; 00:18:00,059<br>It’s not as commonly done. More common method is to go and start to adapt what you’ve already</p>
<p>186<br>00:18:00,059 –&gt; 00:18:05,580<br>done and then start to change the rest of what you haven’t executed yet. Again, those advanced topics,</p>
<p>187<br>00:18:05,580 –&gt; 00:18:10,620<br>but I like how you guys are thinking. So we can do a little bit along the lines of what was suggested,</p>
<p>188<br>00:18:10,620 –&gt; 00:18:15,820<br>which is we can look at the plan that we have at hand, which costed about 3000 IOs and say,</p>
<p>189<br>00:18:15,820 –&gt; 00:18:22,940<br>let’s go a little bit deeper into this and let’s go flip around the join and the selection. So this</p>
<p>190<br>00:18:22,940 –&gt; 00:18:29,740<br>is called a selection push down. And so I’m, all I need is the records that are in the toy</p>
<p>191<br>00:18:29,740 –&gt; 00:18:35,259<br>department. I didn’t need to build a do the sort more joint with all the records from the department,</p>
<p>192<br>00:18:35,259 –&gt; 00:18:41,019<br>from all the departments. And now if I have an index, as was just mentioned, maybe I can use that.</p>
<p>193<br>00:18:41,019 –&gt; 00:18:46,140<br>So I’m counting it as three reads. Maybe it’s a two level index, one read to actually get the record.</p>
<p>194<br>00:18:46,140 –&gt; 00:18:50,380<br>There’s only one, right? Because the department IDs are unique. I’m going to make that assumption</p>
<p>195<br>00:18:50,380 –&gt; 00:18:55,340<br>here that there are no two departments called toy, right? So I’m making that assumption. And then I’ll</p>
<p>196<br>00:18:55,340 –&gt; 00:19:00,380<br>do a nested index loop join because I’ve got an index on the other columns. And now I have a much</p>
<p>197<br>00:19:00,380 –&gt; 00:19:04,780<br>simple plan. I plug in straightforward formulas. I can do this with 37 IOs.</p>
<p>198<br>00:19:07,020 –&gt; 00:19:12,140<br>So we flip things around. We change the shape of the tree as we saw in the last one. We push that</p>
<p>199<br>00:19:12,140 –&gt; 00:19:19,100<br>selection down. Now in the grand scheme of life, as do you have questions? Yep.</p>
<p>200<br>00:19:23,580 –&gt; 00:19:28,220<br>Yeah, I’ll come to that. We have a ton of material to come. I’m going to try to get query</p>
<p>201<br>00:19:28,220 –&gt; 00:19:33,580<br>optimization in our 10 minutes. So wait for it. If I don’t, I’m definitely answering that question.</p>
<p>202<br>00:19:33,580 –&gt; 00:19:39,259<br>It’s coming. Okay. So other questions about what we just covered is that foundation clear because</p>
<p>203<br>00:19:39,259 –&gt; 00:19:46,859<br>otherwise you’ll be lost for the rest of the lecture. Okay. All right. So let’s keep going.</p>
<p>204<br>00:19:47,579 –&gt; 00:19:52,619<br>Let’s say we decide this is the plan we want to execute. We’ve enumerated these plans. We enumerated</p>
<p>205<br>00:19:52,619 –&gt; 00:19:58,059<br>a bunch of plans, costed them and said this the best we can do. There are many more plans by the way</p>
<p>206<br>00:19:58,059 –&gt; 00:20:03,740<br>that we could enumerate, but we’ve just done this. And now we are ready to send it to the scheduler.</p>
<p>207<br>00:20:03,740 –&gt; 00:20:09,180<br>Like the question that was asked, I can’t send this. This is a logical view of what the query should</p>
<p>208<br>00:20:09,180 –&gt; 00:20:14,700<br>query should look like. I have to do other things with it. All this red stuff are annotations I add,</p>
<p>209<br>00:20:14,700 –&gt; 00:20:22,299<br>which will say things like, oh, the first selection, I’m looking at the department table and the</p>
<p>210<br>00:20:22,299 –&gt; 00:20:27,099<br>access path. Remember, that’s the technical term is to use that unclustered or the nonclustered</p>
<p>211<br>00:20:27,099 –&gt; 00:20:32,779<br>B tree and access path for the M phase of file scan. I’m going to pipeline stuff. I’m going to use</p>
<p>212<br>00:20:32,779 –&gt; 00:20:39,259<br>the nested index loop and all that stuff. So the details about what we want that runtime system to do</p>
<p>213<br>00:20:39,259 –&gt; 00:20:45,259<br>is all going to have to be put into a data structure that captures the tree along with all the red</p>
<p>214<br>00:20:45,259 –&gt; 00:20:50,619<br>stuff. And then that gets sent to the query scheduler, which we talked about two lectures ago.</p>
<p>215<br>00:20:50,619 –&gt; 00:20:56,139<br>When now it goes and starts to run the tree bottom up and or top down depending on whichever way</p>
<p>216<br>00:20:56,140 –&gt; 00:21:01,180<br>we’ve set up the rest of the query execution machinery and start to do that. And now the most</p>
<p>217<br>00:21:01,180 –&gt; 00:21:07,340<br>stats that get added including, I expect this to be 2000 pages as an input and stuff like that.</p>
<p>218<br>00:21:07,340 –&gt; 00:21:12,220<br>I’m not shown that here, but typically these annotated trees, they’re called physical plans</p>
<p>219<br>00:21:13,259 –&gt; 00:21:16,700<br>as compared to the logical plan which we saw before, which didn’t have these details.</p>
<p>220<br>00:21:16,700 –&gt; 00:21:21,100<br>The physical plan is something you can run. It tells you which algorithm to use precisely.</p>
<p>221<br>00:21:21,099 –&gt; 00:21:25,899<br>And if you have stats and notations and you have choices to go and do dynamic re optimization,</p>
<p>222<br>00:21:25,899 –&gt; 00:21:30,459<br>but we won’t talk about dynamic re optimization today. Let’s just get you to see how regular</p>
<p>223<br>00:21:30,459 –&gt; 00:21:34,539<br>optimization happens. And as I said, take the advanced database class if you’re interested in that talk.</p>
<p>224<br>00:21:36,539 –&gt; 00:21:42,059<br>All right, so logical plan, we enumerated, costed that. Once we found something, we’ll convert that</p>
<p>225<br>00:21:42,059 –&gt; 00:21:48,779<br>to a physical plan. That’s what you send to the scheduler. Okay. All right.</p>
<p>226<br>00:21:49,019 –&gt; 00:21:59,420<br>So the NP hard question that was asked, the space of plans you have to search that you can search</p>
<p>227<br>00:21:59,420 –&gt; 00:22:04,619<br>is exponential in the number of joins and it’s been shown to be an NP hard problem. If I’ve got</p>
<p>228<br>00:22:04,619 –&gt; 00:22:09,899<br>10 joins, I’m going to be looking at 10 factorial, some large number like that. And practically,</p>
<p>229<br>00:22:09,899 –&gt; 00:22:15,339<br>if I give you a 10 join query or an invite, you might sometimes see 100 join queries. This is not</p>
<p>230<br>00:22:15,339 –&gt; 00:22:20,220<br>unheard of. You will never be able to run the optimization, right? You may take years to just find</p>
<p>231<br>00:22:20,220 –&gt; 00:22:25,339<br>the optimal plan. And so the question is, what do you do? So you’re not going to look at the entire</p>
<p>232<br>00:22:25,339 –&gt; 00:22:31,259<br>space of all the plans. You’re going to, if the entire space is this yellow cloud, you’re going to</p>
<p>233<br>00:22:31,259 –&gt; 00:22:38,220<br>design your optimizer to only look at a small portion of it. So it’s practical. And then the whole</p>
<p>234<br>00:22:38,220 –&gt; 00:22:43,899<br>art is about how do you define that space to be the space in which you will find the good stuff.</p>
<p>235<br>00:22:44,700 –&gt; 00:22:49,980<br>So the goal of an optimizer is not to find the optimal plan over all possible plans because that’s</p>
<p>236<br>00:22:49,980 –&gt; 00:22:54,380<br>too much. It’ll take longer to optimize by many orders of magnitude than running something,</p>
<p>237<br>00:22:54,380 –&gt; 00:22:59,580<br>but it is to not make very bad decisions. Don’t run the condition product. Don’t run really bad stuff.</p>
<p>238<br>00:22:59,580 –&gt; 00:23:04,860<br>So it’s to find in whatever time budget you have, often you have a limited time budget to do the</p>
<p>239<br>00:23:04,860 –&gt; 00:23:10,220<br>optimization. Because you can say, I have a query, I’m going to take an hour to optimize it. Oh,</p>
<p>240<br>00:23:10,220 –&gt; 00:23:14,299<br>and it actually just takes a minute to run. You can’t also say, I’m just going to take a minute to</p>
<p>241<br>00:23:14,299 –&gt; 00:23:18,460<br>optimize. Oh, and the best plan I came up with takes a day to run. So you’re going to have to find</p>
<p>242<br>00:23:18,460 –&gt; 00:23:23,500<br>that balance. You’re going to have to find that balance. And there’s a lot of art that goes into that.</p>
<p>243<br>00:23:23,500 –&gt; 00:23:28,700<br>But regardless, you’re going to need smart ways to say which space to I hunt in. When I’m hunting on</p>
<p>244<br>00:23:28,700 –&gt; 00:23:33,259<br>enumerating all these plans, how do I, how can I do this in a smart way? So that’s what we’ll talk</p>
<p>245<br>00:23:33,259 –&gt; 00:23:37,180<br>about. And there’s just not one way. We’ll talk about one way today. And that’s why optimization is</p>
<p>246<br>00:23:37,180 –&gt; 00:23:42,700<br>an evergreen field as workloads change and things get more and more complex in data platforms. How to</p>
<p>247<br>00:23:42,700 –&gt; 00:23:47,820<br>do this stuff keeps changing all the time. So if you are an optimizer person, you have a job for life.</p>
<p>248<br>00:23:47,820 –&gt; 00:23:52,700<br>And probably the highest paid database employee in the company is likely to be optimizer person.</p>
<p>249<br>00:23:54,779 –&gt; 00:23:58,620<br>But you’ve got to know the math and you’ve got to get comfortable with algebra and stuff like that,</p>
<p>250<br>00:23:58,620 –&gt; 00:24:03,500<br>which we’ll start enumerating these plans as because that’s what all the papers are. And they</p>
<p>251<br>00:24:03,500 –&gt; 00:24:09,500<br>write those in terms of those transformation. So this is just reiterating that we have a logical</p>
<p>252<br>00:24:09,500 –&gt; 00:24:13,980<br>way of representing the query, which is to say, here’s how I’m going to run that. And then you can</p>
<p>253<br>00:24:13,980 –&gt; 00:24:18,539<br>manipulate that, like push the selection down stuff like that. And then there’s a physical space in</p>
<p>254<br>00:24:18,539 –&gt; 00:24:23,259<br>which you’re going to define very specific things. What joint do I run? What selection do I run? Do I use</p>
<p>255<br>00:24:23,259 –&gt; 00:24:28,299<br>an index? And so that’s a physical stuff. Okay. So as you’ll see, there are different styles of</p>
<p>256<br>00:24:28,299 –&gt; 00:24:34,139<br>optimization and one style will start doing both together. But the main style which we’ll start with</p>
<p>257<br>00:24:34,139 –&gt; 00:24:38,539<br>is going to just work in logical space, find the best logical way to do it and then convert that into</p>
<p>258<br>00:24:38,539 –&gt; 00:24:43,899<br>the physical plan. Okay. It’s kind of simpler and it’s how the whole optimization game started in the</p>
<p>259<br>00:24:43,899 –&gt; 00:24:53,659<br>fear. So let’s just dig into it. So we are in that optimization module, we have to enumerate as we</p>
<p>260<br>00:24:53,660 –&gt; 00:25:00,060<br>enumerated a few plans for that very simple query. But what we also have to do is to do this</p>
<p>261<br>00:25:00,060 –&gt; 00:25:05,740<br>search and apply some cost to it. Now this enumeration can be done by applying rules and I’ll show you</p>
<p>262<br>00:25:05,740 –&gt; 00:25:10,860<br>some rules soon. And just like saying, just apply the rules. If I’ve got a joint with B, I know</p>
<p>263<br>00:25:10,860 –&gt; 00:25:15,500<br>that’s the same as B joint with A. Joint’s can compute that way. Just keep applying the rules because</p>
<p>264<br>00:25:15,500 –&gt; 00:25:21,980<br>every time you apply a rule that is safe, you get a new plan. See if that is cheaper. Right? And</p>
<p>265<br>00:25:21,980 –&gt; 00:25:27,420<br>the other one is I’m going to do something more intelligent and search for that type of combination</p>
<p>266<br>00:25:27,420 –&gt; 00:25:32,860<br>but in a cost driven way. So in practical optimizers, they use a little bit of both. They’re not</p>
<p>267<br>00:25:34,299 –&gt; 00:25:39,740<br>orthogonal to each other. They can actually be combined with each other. Okay. So let’s start to make</p>
<p>268<br>00:25:39,740 –&gt; 00:25:44,700<br>it a little bit more practical as to what are rules based way of enumeration and cost-based ways.</p>
<p>269<br>00:25:44,700 –&gt; 00:25:49,019<br>So we’ll start with the rules based stuff. And you already saw three of those, the three most</p>
<p>270<br>00:25:49,019 –&gt; 00:25:54,700<br>popular one in the example that you just saw. The first one is a predicate pushdown. And in this</p>
<p>271<br>00:25:54,700 –&gt; 00:25:59,339<br>rule based method, you are simply going to apply the rule. You don’t need to know anything about</p>
<p>272<br>00:25:59,339 –&gt; 00:26:03,099<br>the data. You’re just going to apply the rule. For the cost-based stuff, you’re going to have to</p>
<p>273<br>00:26:03,099 –&gt; 00:26:06,940<br>know about the data. You have to say, what does it cost and should I cost one way or the other?</p>
<p>274<br>00:26:06,940 –&gt; 00:26:11,819<br>So rule based are just blind. Just by the structure of the tree, don’t have to know how many records are</p>
<p>275<br>00:26:11,819 –&gt; 00:26:17,579<br>where you could just apply that. Okay. The application may result in a worst plan or a better plan.</p>
<p>276<br>00:26:17,579 –&gt; 00:26:21,899<br>That’s not the consideration. It’s just like how can I enumerate? Right. And then eventually,</p>
<p>277<br>00:26:21,899 –&gt; 00:26:26,139<br>you may end up costing something. But just applying the rule based way to enumerate doesn’t require you</p>
<p>278<br>00:26:26,139 –&gt; 00:26:30,299<br>to know anything about the data. Here’s a simple one. If I didn’t tell you anything about how many</p>
<p>279<br>00:26:30,299 –&gt; 00:26:36,619<br>records are in the two tables, M, and Department, and you see a selection, you can say, you know what?</p>
<p>280<br>00:26:36,619 –&gt; 00:26:41,179<br>Regardless, I think selections are usually more selective than joints. It’s probably a good idea,</p>
<p>281<br>00:26:41,179 –&gt; 00:26:46,699<br>more often than not to push the selection down. And just a rule of thumb, I don’t care about how many</p>
<p>282<br>00:26:46,700 –&gt; 00:26:50,539<br>records there are. In general, this is going to be good. You can say, I could build an optimizer</p>
<p>283<br>00:26:50,539 –&gt; 00:26:54,940<br>that does just apply some of these rules. And from what I understand, the bus stop optimizes</p>
<p>284<br>00:26:54,940 –&gt; 00:26:58,779<br>basically rules based. And it’s going to do simple rules like that. And it’s simple to build.</p>
<p>285<br>00:26:58,779 –&gt; 00:27:03,740<br>We’ll get you a whole bunch of benefit form optimization, but doesn’t require you to build a far</p>
<p>286<br>00:27:03,740 –&gt; 00:27:10,220<br>more complex optimizer. It’s often where you would stop. Okay. So really simple. Hopefully,</p>
<p>287<br>00:27:10,220 –&gt; 00:27:14,860<br>you can see why in general, this is a good idea. Okay. So now, if you want to be the highest</p>
<p>288<br>00:27:14,859 –&gt; 00:27:19,339<br>database employee, you have to start getting familiar with terms like this. See what I put</p>
<p>289<br>00:27:19,339 –&gt; 00:27:25,259<br>down over there? That is a relational algebraic expression, which I know we’ve covered before,</p>
<p>290<br>00:27:25,899 –&gt; 00:27:29,740<br>but that’s the free representation of the algebraic representation. Right? So let’s just walk</p>
<p>291<br>00:27:29,740 –&gt; 00:27:37,579<br>through that and see what that looks like. Whoops. Come back, please. Okay. And so as you can see,</p>
<p>292<br>00:27:39,099 –&gt; 00:27:44,379<br>I’ll write both of them down. The first one over here is basically saying, look at the</p>
<p>293<br>00:27:45,740 –&gt; 00:27:51,019<br>the first part over here, which is that join is essentially that department join with the employee</p>
<p>294<br>00:27:51,019 –&gt; 00:27:56,939<br>in that inner bracket. Then that flows into the selection, which is up over there, and then flows</p>
<p>295<br>00:27:56,939 –&gt; 00:28:02,299<br>into the projection. So the bracketing stuff basically gives you that representation in this</p>
<p>296<br>00:28:02,299 –&gt; 00:28:07,019<br>mathematical form for what that tree looks like. And the papers when they talk about transformation,</p>
<p>297<br>00:28:07,019 –&gt; 00:28:11,419<br>are just going to say this transforms into that. That’s a predicate push down. As you can see,</p>
<p>298<br>00:28:11,420 –&gt; 00:28:17,180<br>this is the rewrite of the predicate push down, where this selection moved inner before that joint</p>
<p>299<br>00:28:17,180 –&gt; 00:28:22,220<br>happened. So just regular math expressions, same thing, but you’ve got to get that in your head</p>
<p>300<br>00:28:22,220 –&gt; 00:28:27,019<br>if you want to play around with optimizers. Okay. And understand what they do. Not rocket science,</p>
<p>301<br>00:28:27,019 –&gt; 00:28:31,500<br>but you just have to get comfortable with relational algebra. Okay. Questions?</p>
<p>302<br>00:28:33,980 –&gt; 00:28:40,220<br>Okay. So the other simple one also we saw, Cartesian products are nearly always going to be a bad idea.</p>
<p>303<br>00:28:40,940 –&gt; 00:28:45,180<br>They’re often the one case where it’s not a bad idea is if M and department would have one record,</p>
<p>304<br>00:28:45,740 –&gt; 00:28:49,660<br>you’re not going to do much better, might as well do a Cartesian product, right? And the case is</p>
<p>305<br>00:28:49,660 –&gt; 00:28:54,299<br>like that, very rare, but nearly always it’s going to be a bad idea. So this is just saying,</p>
<p>306<br>00:28:54,299 –&gt; 00:28:59,500<br>hey, replace that with a join. And again, you can write that in relational algebra where you were</p>
<p>307<br>00:28:59,500 –&gt; 00:29:04,940<br>doing in that inner bracketed term, the Cartesian product, and then you were applying the selection.</p>
<p>308<br>00:29:04,940 –&gt; 00:29:08,940<br>You’re saying, oh, I can just replace it with a natural join, which here is represented by the</p>
<p>309<br>00:29:08,940 –&gt; 00:29:14,539<br>dumbbell operation saying it’s on the DID. And the DID column is common in both. You could even omit that,</p>
<p>310<br>00:29:14,539 –&gt; 00:29:19,420<br>and that just becomes the same syntax as we’ve seen in SQL as a natural join syntax. But now just</p>
<p>311<br>00:29:19,420 –&gt; 00:29:25,500<br>written algebraically. Okay. Everyone getting comfortable with algebraic manipulation of</p>
<p>312<br>00:29:25,500 –&gt; 00:29:37,340<br>freeze and logical plans? Questions? Yep. Yeah, great question. So again, these things are</p>
<p>313<br>00:29:37,339 –&gt; 00:29:42,059<br>may not work. A predicate push down may not work, for example, if every department was a toy. So</p>
<p>314<br>00:29:42,059 –&gt; 00:29:49,339<br>it’s the same cost. Or if it turns out that the join was most selective, that the join between</p>
<p>315<br>00:29:49,339 –&gt; 00:29:55,019<br>department and employee ended up having zero records because all the employees had nulls,</p>
<p>316<br>00:29:55,019 –&gt; 00:29:59,419<br>or there no one was assigned to any department, then this selection would have been more</p>
<p>317<br>00:29:59,419 –&gt; 00:30:04,619<br>more effective as throwing records away. And there’s nothing else to do. So sometimes a join can be,</p>
<p>318<br>00:30:05,419 –&gt; 00:30:09,979<br>can reduce data from flowing up more than a selection. So again, these are rules of thumbs,</p>
<p>319<br>00:30:09,979 –&gt; 00:30:16,059<br>but based on what actual data sits in the tables, you might actually get one versus. So it’s not guaranteed</p>
<p>320<br>00:30:16,059 –&gt; 00:30:20,539<br>that this is always better. Both of these that you’ve looked at are nearly always going to be the</p>
<p>321<br>00:30:20,539 –&gt; 00:30:28,299<br>better way to do it. Okay, but not always, not always. Here’s a third one that also we have seen,</p>
<p>322<br>00:30:28,299 –&gt; 00:30:33,339<br>which is a projection push down. I guess we didn’t see this one. And I don’t know why this is</p>
<p>323<br>00:30:33,419 –&gt; 00:30:39,579<br>blanking out on me. All right, there we go. And this projection push down is effectively saying,</p>
<p>324<br>00:30:39,899 –&gt; 00:30:45,259<br>I am carrying all the employee information all the way through this pipeline, all I needed from</p>
<p>325<br>00:30:45,259 –&gt; 00:30:49,899<br>the employee table was the name and the department ID, right? I need the department ID for the join.</p>
<p>326<br>00:30:51,179 –&gt; 00:30:57,019<br>Right, because that’s the join key. Why do I carry the rest of the columns of this employee table,</p>
<p>327<br>00:30:57,019 –&gt; 00:31:01,179<br>push that projection down. And as you can see, you’re going to have less data flow across,</p>
<p>328<br>00:31:01,180 –&gt; 00:31:08,620<br>all the costs will go down. Okay. And so a lot of these rule based stuff will be things like this.</p>
<p>329<br>00:31:08,620 –&gt; 00:31:13,500<br>And I’m not going to read through all of this. I will assume now you can take a look at this. And</p>
<p>330<br>00:31:13,500 –&gt; 00:31:18,460<br>this is not even all the rules. They’re going to be like hundreds of rules like that. But let’s take a</p>
<p>331<br>00:31:18,460 –&gt; 00:31:23,980<br>look at one or two, which are going to be super important. So let’s take a look at this one over here</p>
<p>332<br>00:31:23,980 –&gt; 00:31:31,100<br>that basically is the joint commutativity. If I have our natural joint with S, I can flip those</p>
<p>333<br>00:31:31,099 –&gt; 00:31:36,859<br>around. I get the same result, right? Logically, I get the same result. It’s the same set of records</p>
<p>334<br>00:31:36,859 –&gt; 00:31:40,699<br>that I get. So I can flip that around. Where would I flip that around? Because maybe that’s better.</p>
<p>335<br>00:31:40,699 –&gt; 00:31:48,779<br>As you remember in nested loops and sort merge and other algorithms, there’s asymmetry in what is</p>
<p>336<br>00:31:48,779 –&gt; 00:31:53,980<br>the inner versus outer and you can get that. Or it may be that I have an index and I can leverage the</p>
<p>337<br>00:31:53,980 –&gt; 00:31:59,579<br>index on the on the one that is the inner relation and I want to flip that around. Okay, but it’s a rule.</p>
<p>338<br>00:31:59,579 –&gt; 00:32:04,619<br>I can flip it. These rules are apply this transformation. The query semantics remains the same. It is</p>
<p>339<br>00:32:04,619 –&gt; 00:32:09,980<br>safe. Then figure out whether it’s a good idea or not. Okay, in a pure rule based up, you’ll apply it</p>
<p>340<br>00:32:09,980 –&gt; 00:32:14,539<br>and assume it’s a good idea. You’ll have something saying, if I see I will always do selection push</p>
<p>341<br>00:32:14,539 –&gt; 00:32:20,059<br>down and projection push down and remove Cartesian products. And that’s my optimizer. And that’s fine.</p>
<p>342<br>00:32:20,059 –&gt; 00:32:25,980<br>You’ll get a pretty decent optimizer with very little effort. Okay, let’s look at the second one,</p>
<p>343<br>00:32:25,980 –&gt; 00:32:31,259<br>which is the next one over here, which is called joint commutativity, which is saying our joint</p>
<p>344<br>00:32:31,259 –&gt; 00:32:38,460<br>with s, joint with t. If I join s and t first, that’s the bracket on the left side. I’ve got one plan,</p>
<p>345<br>00:32:38,460 –&gt; 00:32:43,259<br>but I could also switch that around and join r and s first and then join with t. Why would I do</p>
<p>346<br>00:32:43,259 –&gt; 00:32:48,620<br>that? Second one? Because maybe our joint with s produces very small records, maybe zero, maybe just</p>
<p>347<br>00:32:48,620 –&gt; 00:32:54,299<br>one. And maybe s joint with t might produce a billion records. I would rather do the smaller stuff first</p>
<p>348<br>00:32:54,299 –&gt; 00:32:58,379<br>because then I have less work to do. I’m not carrying all of this stuff across. Right?</p>
<p>349<br>00:32:59,980 –&gt; 00:33:05,500<br>Okay, and this by the way, there are very nice symmetries for the joint properties with matrix</p>
<p>350<br>00:33:05,500 –&gt; 00:33:11,579<br>multiplication because optimization, if you’re a numeric optimization person, you see they also do</p>
<p>351<br>00:33:11,579 –&gt; 00:33:15,419<br>similar types of things, but joints have, but we have a richer set of algebra and richer set of</p>
<p>352<br>00:33:15,419 –&gt; 00:33:22,059<br>manipulation with relational algebra. Okay, so it’s a more, it’s a both fun, my biased view of an</p>
<p>353<br>00:33:22,059 –&gt; 00:33:27,419<br>optimization problem. Okay, now let you look at this stuff. I don’t want to memorize all of this</p>
<p>354<br>00:33:27,419 –&gt; 00:33:30,940<br>stuff, but I do need you to know the three things that we talked about and the two things that are</p>
<p>355<br>00:33:30,940 –&gt; 00:33:35,899<br>joints, their fair game, for example, if you’re trying to worry about it from that perspective. Okay?</p>
<p>356<br>00:33:36,779 –&gt; 00:33:41,259<br>I do need you to know what a rule based method does. Doesn’t have to look at the data. I can just</p>
<p>357<br>00:33:41,259 –&gt; 00:33:48,539<br>apply. It’s a good way to build quick things in an optimizer. Okay? Now, as we’ve talked about,</p>
<p>358<br>00:33:48,539 –&gt; 00:33:52,220<br>that’s not going to be enough, but before I go into the cost-based optimization,</p>
<p>359<br>00:33:52,220 –&gt; 00:33:55,980<br>let’s just tie everything together that we’ve discussed so far, give you a minute to breathe</p>
<p>360<br>00:33:55,980 –&gt; 00:34:01,339<br>before we go jump into even more hairy optimization techniques. What’s the grand scheme?</p>
<p>361<br>00:34:02,139 –&gt; 00:34:07,659<br>Application sends a query. That comes to a parser. That parser checks, you have a table in the</p>
<p>362<br>00:34:07,659 –&gt; 00:34:12,779<br>from clause. Is that table actually exist in the catalogs or did you miss type it? Stuff like that.</p>
<p>363<br>00:34:13,740 –&gt; 00:34:18,860<br>It’s going to basically do all of that. Take that abstract syntax tree of the parser. The binder will</p>
<p>364<br>00:34:18,860 –&gt; 00:34:24,460<br>go and check the catalogs to figure out. Is it meaningful? You are referring to column A in table R,</p>
<p>365<br>00:34:24,940 –&gt; 00:34:28,700<br>but that doesn’t exist. So all of that type of checking happens over there for it to say,</p>
<p>366<br>00:34:28,700 –&gt; 00:34:34,380<br>okay, this query looks legitimate. I’m ready to let it go. And then it goes to the optimizer, where</p>
<p>367<br>00:34:35,260 –&gt; 00:34:40,780<br>it’s going to send across a logical plan. And that logical plan, the optimizer is going to go over</p>
<p>368<br>00:34:40,780 –&gt; 00:34:46,620<br>the logical plan, enumerate different ways of rewriting that logical plan and figure out which is</p>
<p>369<br>00:34:46,620 –&gt; 00:34:52,540<br>the best one. So the optimizer internally can use a heuristic based, rules-based method as you</p>
<p>370<br>00:34:52,540 –&gt; 00:34:56,780<br>just talked about or cost-based stuff, which we’re going to talk about next or a combination of both of</p>
<p>371<br>00:34:56,780 –&gt; 00:35:03,019<br>those. Okay, so its job is to do that enumeration that search space that I mentioned and find the best</p>
<p>372<br>00:35:03,019 –&gt; 00:35:09,260<br>way to do it with whatever time budget it has. And whatever stats it has at its disposal, at its</p>
<p>373<br>00:35:09,260 –&gt; 00:35:16,700<br>disposal from the catalog. Okay, and then it will go and pull up more information about what algorithm,</p>
<p>374<br>00:35:16,700 –&gt; 00:35:21,900<br>however implemented this algorithm, you know, what’s my hash-joints implementation’s cost, right? Those</p>
<p>375<br>00:35:21,900 –&gt; 00:35:27,420<br>are equations that will depend on the implementation. Plug all of that in to get the costs that we have.</p>
<p>376<br>00:35:27,420 –&gt; 00:35:31,420<br>And then eventually get a physical plan like the one that I showed you, the annotated</p>
<p>377<br>00:35:31,420 –&gt; 00:35:36,940<br>relational algebraic rate, aka the physical plan. Now that can be sent to the scheduler where it can</p>
<p>378<br>00:35:36,940 –&gt; 00:35:43,900<br>run stuff. Okay, so that’s the scheme. We’re going to go deeper into the optimizer. As we said,</p>
<p>379<br>00:35:43,900 –&gt; 00:35:49,420<br>it can use a combination of these two methods. We just covered what the rule-based stuff looks like,</p>
<p>380<br>00:35:49,420 –&gt; 00:35:54,460<br>right? Just enumerate rules and apply things based on best judgment perhaps. And now we are going</p>
<p>381<br>00:35:54,460 –&gt; 00:35:59,179<br>to go into a cost-based search. Okay, this is the fun stuff. Yep.</p>
<p>382<br>00:36:05,740 –&gt; 00:36:11,980<br>And that’s a good point. Commitativity as a rule-based stuff, you would generally not apply,</p>
<p>383<br>00:36:11,980 –&gt; 00:36:15,579<br>you would apply it in the cost-based scenario, right? So again, the rules might be there,</p>
<p>384<br>00:36:15,579 –&gt; 00:36:18,940<br>how you use it, when you use it will depend on that. So that’s a great point. The</p>
<p>385<br>00:36:18,940 –&gt; 00:36:23,019<br>commitative associativity is at the heart of this cost-based search I’m going to talk about.</p>
<p>386<br>00:36:23,019 –&gt; 00:36:26,780<br>So one reasonable way might be if I’m trying to build an optimizer in a hurry,</p>
<p>387<br>00:36:26,780 –&gt; 00:36:31,019<br>I might say do selection push down, remove Cartesian products, projection push downs. I think</p>
<p>388<br>00:36:31,019 –&gt; 00:36:34,780<br>everyone needs it. And now for the joint stuff, do what we are going to talk about in the cost-based</p>
<p>389<br>00:36:34,780 –&gt; 00:36:39,340<br>stuff. So you saw how over there, for some part of it, it is rules-based, the other part is cost-based,</p>
<p>390<br>00:36:39,340 –&gt; 00:36:45,500<br>and I can get a decent optimizer working. Okay? Good question. Other questions?</p>
<p>391<br>00:36:45,500 –&gt; 00:36:50,460<br>Good question. Good question. Good question. Good question. Good question. Good question. Good question.</p>
<p>392<br>00:36:50,460 –&gt; 00:36:57,420<br>Ask again. How do you use Cartesian products? Will the Cartesian, we just talked about that.</p>
<p>393<br>00:36:57,420 –&gt; 00:37:00,300<br>There might be, so the question is, will the Cartesian product be better in some cases?</p>
<p>394<br>00:37:00,860 –&gt; 00:37:06,460<br>Yeah, and we just talked about that, right? If both sides had one record and it’s just going to</p>
<p>395<br>00:37:06,460 –&gt; 00:37:09,980<br>join with each other, you know, that’s the same as doing a nested loops, you don’t have to set up all</p>
<p>396<br>00:37:09,980 –&gt; 00:37:14,539<br>the machinery, might just do a Cartesian product. So there are some cases where Cartesian product is</p>
<p>397<br>00:37:14,539 –&gt; 00:37:19,019<br>better, usually not, but there are definitely rare corner cases where Cartesian product is better.</p>
<p>398<br>00:37:20,219 –&gt; 00:37:28,860<br>Yep. Okay. Great. Other questions? I think I should just not touch this. Something’s very</p>
<p>399<br>00:37:28,860 –&gt; 00:37:33,820<br>flaky today. Okay. Great. Just give me one second. Does this mean the recordings not done? I</p>
<p>400<br>00:37:33,820 –&gt; 00:37:37,340<br>hate if I have to go record this measure all over again.</p>
<p>401<br>00:37:45,019 –&gt; 00:37:53,739<br>Okay. Great. Everything looks to be in order. All right. So now we are going to go into the</p>
<p>402<br>00:37:53,739 –&gt; 00:38:02,139<br>cost-based optimizer and then start digging deeper into time. All right. So we’ll start with a very</p>
<p>403<br>00:38:02,139 –&gt; 00:38:09,179<br>specific style of query optimization, which is based on something called the system R optimizer.</p>
<p>404<br>00:38:09,179 –&gt; 00:38:16,219<br>It was one of the first database systems that was built in the whole field. And back in the day</p>
<p>405<br>00:38:16,219 –&gt; 00:38:20,379<br>when God had come up with a relational model IBM first rejected it, but then they started to</p>
<p>406<br>00:38:20,379 –&gt; 00:38:24,779<br>really dig into it. System R is the system that they built. I know we talked about that in the first</p>
<p>407<br>00:38:24,779 –&gt; 00:38:32,219<br>class. And its optimization stuff is the bedrock for what most systems do even to this day.</p>
<p>408<br>00:38:32,779 –&gt; 00:38:37,899<br>And as we’ll see, it’s got a very specific point of view. It is cost-based, right? So it’ll do all</p>
<p>409<br>00:38:37,900 –&gt; 00:38:45,019<br>of this join a sociativity and commutativity enumeration, but will cost it. And then as we will also see,</p>
<p>410<br>00:38:45,019 –&gt; 00:38:49,260<br>it’s a style called bottom up. And I’ll contrast that with another style I’ll introduce later,</p>
<p>411<br>00:38:49,260 –&gt; 00:38:54,139<br>which is called top down. Okay. So technically it’s a cost-based bottom up optimizer. If you want to</p>
<p>412<br>00:38:54,139 –&gt; 00:38:59,980<br>sound smart, when you talk to optimizer people. Okay. And now it’s going to do the following. It’s</p>
<p>413<br>00:38:59,980 –&gt; 00:39:04,460<br>going to start by saying, what are all the tables I have? For each table I’m going to find out,</p>
<p>414<br>00:39:04,460 –&gt; 00:39:08,940<br>how do I access it to access through a file scan through an index scan? What is the cost? So figure</p>
<p>415<br>00:39:08,940 –&gt; 00:39:14,139<br>out what is called the single relational access path first. And then keep combining them while the</p>
<p>416<br>00:39:14,139 –&gt; 00:39:18,699<br>joins and using the associativity and commutativity properties. Okay. And then there are nested</p>
<p>417<br>00:39:18,699 –&gt; 00:39:23,900<br>sub queries, which I’ll talk about in a little bit. So ignore all of that for now. So and it’ll try to</p>
<p>418<br>00:39:23,900 –&gt; 00:39:28,059<br>choose the best plan. It’s a cost-based stuff based on everything it has seen so far. So it’ll try to</p>
<p>419<br>00:39:28,059 –&gt; 00:39:32,539<br>prune things away so it can keep what it needs as it keeps building up. So it’s a dynamic programming</p>
<p>420<br>00:39:32,539 –&gt; 00:39:40,699<br>style method. And those of you who are into dynamic program will recognize that a choice of algorithmic</p>
<p>421<br>00:39:40,699 –&gt; 00:39:47,259<br>style. So the first is we’ll pick the best single relational access path. So if I’ve got a table</p>
<p>422<br>00:39:47,259 –&gt; 00:39:53,099<br>like we had the department table and it had one way I can scan it as a file scan. It had a bunch</p>
<p>423<br>00:39:53,099 –&gt; 00:39:56,619<br>of indices. I could scan it through each of the indices. I’ll just say what does it cost doing each</p>
<p>424<br>00:39:56,619 –&gt; 00:40:01,820<br>of those? And then I’ll keep around the cheapest and system R will keep around not just the cheapest,</p>
<p>425<br>00:40:01,820 –&gt; 00:40:07,019<br>but also something in which I get things in sorted order. But ignore that for now. So I’ll basically try</p>
<p>426<br>00:40:07,019 –&gt; 00:40:13,100<br>to find the best way to access each table or maybe a couple best ways. And then I’ll say now if I</p>
<p>427<br>00:40:13,100 –&gt; 00:40:17,900<br>access this through a file scan and this through an index and next stage I want to do a joint,</p>
<p>428<br>00:40:17,900 –&gt; 00:40:22,220<br>what would that look like? So it’s going to start building up in that way. And it’ll use simple</p>
<p>429<br>00:40:22,220 –&gt; 00:40:27,019<br>heuristics as we talked about for the cost model and we can see that in a little bit more detail.</p>
<p>430<br>00:40:27,980 –&gt; 00:40:33,019<br>A little bit more setup and then we’ll start looking at some animations is we’ll take the query block</p>
<p>431<br>00:40:33,019 –&gt; 00:40:38,300<br>and break it up into these logical operators. So all of that is saying we’re going to manipulate</p>
<p>432<br>00:40:38,300 –&gt; 00:40:45,259<br>in the logical space. And for once we get down to a logical operator like a join, then we will say,</p>
<p>433<br>00:40:45,259 –&gt; 00:40:50,300<br>oh, I’ve got five implementations of join algorithms. Now I’m starting to make a physical decision</p>
<p>434<br>00:40:50,300 –&gt; 00:40:54,780<br>for that operator saying what would nested loops cost me here? What would block nested loops cost</p>
<p>435<br>00:40:54,780 –&gt; 00:40:59,180<br>me here? What would hash join, sort merge and so on would cost me there? Different flavors of</p>
<p>436<br>00:40:59,180 –&gt; 00:41:05,100<br>hash join, for example. And so we will start making those physical decisions too as we intertwine</p>
<p>437<br>00:41:05,100 –&gt; 00:41:12,940<br>between between these costs. System R, did you have a question? Okay. Just trying to stop the people</p>
<p>438<br>00:41:12,940 –&gt; 00:41:18,540<br>from the back to look at this getting you, like you were raising your hand. All right, just stretching.</p>
<p>439<br>00:41:19,340 –&gt; 00:41:26,539<br>It looks only at these plans called left deep trees. These left deep trees will have a shape that</p>
<p>440<br>00:41:26,539 –&gt; 00:41:34,779<br>looks like this where all the joins sit along like a long line. And you can think of all of these as</p>
<p>441<br>00:41:34,779 –&gt; 00:41:39,259<br>the inner relations. And so for example, you can imagine if you had built hash tables on all of that,</p>
<p>442<br>00:41:39,259 –&gt; 00:41:44,619<br>you just take this record probe, probe, probe, and you’re done. So if you have enough memory to build</p>
<p>443<br>00:41:44,619 –&gt; 00:41:51,420<br>all the hash tables, this goes blazingly fast. And so it concentrates on that class of plans.</p>
<p>444<br>00:41:51,420 –&gt; 00:41:56,699<br>It will not do what is called a bushy plan. A bushy plan is characterized by having a node</p>
<p>445<br>00:41:57,579 –&gt; 00:42:03,019<br>in the logical plan like that in which both the inputs are also joints. So at some point it branches</p>
<p>446<br>00:42:03,019 –&gt; 00:42:06,859<br>off and the branches, both branches are a joint. That’s the definition of a bushy plan.</p>
<p>447<br>00:42:07,900 –&gt; 00:42:13,179<br>Okay. So even if one of the nodes in your plan has that, then it’s a bushy plan. So it doesn’t look</p>
<p>448<br>00:42:13,179 –&gt; 00:42:20,139<br>at that. But that is that later on turned out like there are many times where bushy plan is the</p>
<p>449<br>00:42:20,139 –&gt; 00:42:24,940<br>better way to optimize. So it’s going to miss out on that. Where if you go back to that diagram I</p>
<p>450<br>00:42:24,940 –&gt; 00:42:28,940<br>had with the cloud, it’s going to miss out on a whole bunch of plans that are outside that space. So</p>
<p>451<br>00:42:28,940 –&gt; 00:42:35,099<br>it’s chosen to say I’m going to look, it’s taken a specific point of view and said I’m going to look</p>
<p>452<br>00:42:35,099 –&gt; 00:42:41,019<br>at the face of these lefty plans. It actually looks at something a little bit general called linear</p>
<p>453<br>00:42:41,019 –&gt; 00:42:46,219<br>plans, but ignore that. I’m not going to look at stuff here which is bushy plans and also doesn’t</p>
<p>454<br>00:42:46,219 –&gt; 00:42:50,699<br>look at Cartesian plans which are in this space. It deliberately says I will not spend time looking</p>
<p>455<br>00:42:50,699 –&gt; 00:42:58,219<br>there. Okay. It’s a very specific example of how it makes its perspective. How it chooses where it’s</p>
<p>456<br>00:42:58,219 –&gt; 00:43:05,579<br>going to look for a plans. All right. So and this was done by Pat Sylencher, really famous,</p>
<p>457<br>00:43:06,219 –&gt; 00:43:11,659<br>any member and was quite the breakthrough in query optimization when this paper came out in 79.</p>
<p>458<br>00:43:13,340 –&gt; 00:43:19,259<br>So how does it work? We’ll take a slightly more complex query. I stole that from Andy’s slide</p>
<p>459<br>00:43:19,259 –&gt; 00:43:26,059<br>last year. He had some amazing animations which was awesome. And we are going to choose as we said</p>
<p>460<br>00:43:26,059 –&gt; 00:43:31,579<br>first step the best single relational access plan. So we’ll say here are three relations. In this case</p>
<p>461<br>00:43:31,579 –&gt; 00:43:38,219<br>it’s doing a join between artists where they appear the album and then only selecting album names</p>
<p>462<br>00:43:38,219 –&gt; 00:43:43,420<br>which are which is like Andy’s OG remix. And so I’m going to enumerate different ways of accessing</p>
<p>463<br>00:43:43,420 –&gt; 00:43:49,659<br>each of those sequential scans index lookups stuff like that based on what the schema tells me</p>
<p>464<br>00:43:49,659 –&gt; 00:43:58,460<br>choose the best plan and then start to dig into the join order stuff. Okay. So I’ve now finished</p>
<p>465<br>00:43:59,420 –&gt; 00:44:04,059<br>I know how to access each table by itself. I’m going to now say what are different ways to join</p>
<p>466<br>00:44:04,059 –&gt; 00:44:10,059<br>and I’ll start enumerating that. I could do artists, peers and albums or I could do appears albums.</p>
<p>467<br>00:44:10,059 –&gt; 00:44:13,340<br>I can enumerate all of that and as you can see this is going to be exponential in the number of</p>
<p>468<br>00:44:13,340 –&gt; 00:44:18,460<br>joins right. That’s where the complexity comes from. I’m going to choose to do some things. I made</p>
<p>469<br>00:44:18,460 –&gt; 00:44:23,340<br>a site. I don’t want to look at condition products. So those are choices that I will make as I go about</p>
<p>470<br>00:44:24,300 –&gt; 00:44:31,420<br>writing this optimizer. So in this as we then start to say I’m going to look at these specific</p>
<p>471<br>00:44:31,420 –&gt; 00:44:35,740<br>types of join ordering and now start doing the costing. So let’s go and dig into that. So here’s</p>
<p>472<br>00:44:35,740 –&gt; 00:44:39,500<br>what’s going to happen. Yep question. Question about the creation. Yes. Yes.</p>
<p>473<br>00:44:39,500 –&gt; 00:44:45,660<br>After doing one relationship to a relationship. Yes. And the slide will basically do that. Yep.</p>
<p>474<br>00:44:45,660 –&gt; 00:44:50,059<br>They’re just saying these are the possible. This is the universe of stuff that I have to look at.</p>
<p>475<br>00:44:50,059 –&gt; 00:44:55,659<br>But I look at even that in a very systematic way. So here’s how we will look at. So I will say I</p>
<p>476<br>00:44:55,659 –&gt; 00:44:59,659<br>eventually need to end up with a logical plan that is equivalent to what is shown on the top.</p>
<p>477<br>00:45:00,299 –&gt; 00:45:03,739<br>Right. That’s not a physical plan on the top. I need to join all these three tables with each</p>
<p>478<br>00:45:03,739 –&gt; 00:45:09,420<br>other. Right. That’s basically what this tells us. To start with I’ve got tables. Artist albums and</p>
<p>479<br>00:45:11,019 –&gt; 00:45:16,539<br>appears I have to start assembling this thing together. Okay. So now pay attention. So now here the real</p>
<p>480<br>00:45:16,539 –&gt; 00:45:22,940<br>dynamic programming magic comes in. First, I will start my enumeration. By the way, before this,</p>
<p>481<br>00:45:22,940 –&gt; 00:45:27,179<br>I’ve already decided, appears should be done with a file scan. Maybe this with an index stuff</p>
<p>482<br>00:45:27,179 –&gt; 00:45:32,219<br>like that. Like that decision I made in the first step. Single relational access path optimization.</p>
<p>483<br>00:45:32,779 –&gt; 00:45:38,699<br>Okay. Then I’m going to say, oh, what are the different ways I could do that? And not everything is</p>
<p>484<br>00:45:38,699 –&gt; 00:45:44,059<br>listed here, right, to keep this like compact. I can choose what it wants to do. But it’s going to do</p>
<p>485<br>00:45:44,059 –&gt; 00:45:49,420<br>things like, oh, I’m going to join a one and a three first and third. And I could use a hash</p>
<p>486<br>00:45:49,420 –&gt; 00:45:55,019<br>join or a sort more join and can just start enumerating all of these different combinations.</p>
<p>487<br>00:45:55,019 –&gt; 00:45:59,019<br>As you can see what’s at play over here is I’m playing around with the associativity and</p>
<p>488<br>00:45:59,019 –&gt; 00:46:03,579<br>commutativity. If you think of the top line as being the relational algebra, I’m saying which one</p>
<p>489<br>00:46:03,579 –&gt; 00:46:11,659<br>do I put brackets around first? Okay. And then I’m going to say, all right, if I do that, the first two</p>
<p>490<br>00:46:11,659 –&gt; 00:46:16,379<br>are basically doing a join between artists and appears first. The second two are basically doing</p>
<p>491<br>00:46:16,379 –&gt; 00:46:19,819<br>album and appears first and so on. And a lot more combinations I haven’t shown here.</p>
<p>492<br>00:46:21,259 –&gt; 00:46:27,420<br>Okay. But for each one of that like this year, this was, both of these will give me that part</p>
<p>493<br>00:46:27,420 –&gt; 00:46:32,299<br>of the join is done, right? And here if I’d more than two join algorithms, that list would grow.</p>
<p>494<br>00:46:32,299 –&gt; 00:46:39,420<br>So you can see there’s a lot of space to explore here, right? And now I will start to do putting</p>
<p>495<br>00:46:39,420 –&gt; 00:46:44,940<br>all of that together and say, I can look at this from a cost-based perspective. And just for</p>
<p>496<br>00:46:44,940 –&gt; 00:46:49,820<br>each of these individual ones, I’ll just look at this part. If I want to get to here, I’ve got these</p>
<p>497<br>00:46:49,820 –&gt; 00:46:55,420<br>two choices. Which one is cheaper? There’s no reason to carry the more expensive one forward because</p>
<p>498<br>00:46:55,420 –&gt; 00:46:59,659<br>dynamic programming, it’s going to build on itself. There’s no point in carrying the more expensive</p>
<p>499<br>00:46:59,659 –&gt; 00:47:04,780<br>part forward. So start pruning now, right? So you can see how it is starting to prune. So if you just</p>
<p>500<br>00:47:04,780 –&gt; 00:47:10,060<br>keep that around, isn’t that beautiful? Right? So now it’s got this little compact dynamic programming</p>
<p>501<br>00:47:10,060 –&gt; 00:47:14,700<br>table. It says, those two are better done with hash join. This one better with a sort more join.</p>
<p>502<br>00:47:14,700 –&gt; 00:47:20,300<br>And now as you can see, I’ll just recourse through it and get the rest of it done. Okay? So just to</p>
<p>503<br>00:47:20,300 –&gt; 00:47:27,420<br>complete the picture, I will then say, let’s chase, chase this back down. This says, I do a 3, a 2,</p>
<p>504<br>00:47:27,420 –&gt; 00:47:33,100<br>which I did before. Now I’ll add in a 1. That’s the permutation that I picked there. Again, I could</p>
<p>505<br>00:47:33,099 –&gt; 00:47:38,059<br>do through two algorithms. If those are the only two I have, I can find the cost. At this point,</p>
<p>506<br>00:47:38,059 –&gt; 00:47:43,579<br>I’ve reached the equivalent logical space I needed to be at the top. That logical stuff is just a</p>
<p>507<br>00:47:43,579 –&gt; 00:47:50,219<br>logical stuff. And I will go and start pruning. Look at everything that makes sense at that second</p>
<p>508<br>00:47:50,219 –&gt; 00:47:56,139<br>step. And now I’ve got full plans. I’ve got three full plans that I’ve survived. Then I just go find</p>
<p>509<br>00:47:56,139 –&gt; 00:48:04,139<br>the best one. And I’m done. Okay? Did that make sense? And this is a straight up dynamic programming</p>
<p>510<br>00:48:04,139 –&gt; 00:48:09,339<br>technique cast in this way. And that’s where this paper was so beautiful. Before that, it was like,</p>
<p>511<br>00:48:09,339 –&gt; 00:48:15,179<br>how are you going to optimize these queries? But it was a really beautiful algorithm. Okay? If you</p>
<p>512<br>00:48:15,179 –&gt; 00:48:22,460<br>love algorithms, this probably like gets you excited. All right. So now we’ve got that. And the one</p>
<p>513<br>00:48:22,460 –&gt; 00:48:28,539<br>part we didn’t do as you might have noticed is that there’s an order by clause in that query.</p>
<p>514<br>00:48:29,500 –&gt; 00:48:36,460<br>Okay? What we did here was to just get the logical way. We said that’s the logical target.</p>
<p>515<br>00:48:36,460 –&gt; 00:48:42,460<br>That’s the goal. We start from just atomic parts. We reach there. But we didn’t do the order by.</p>
<p>516<br>00:48:42,460 –&gt; 00:48:47,179<br>And so what system are we do? It didn’t have a systematic way of dealing with the physical property</p>
<p>517<br>00:48:47,179 –&gt; 00:48:51,820<br>of ordering as it was building stuff. As you’ll see, the top down thing that came later,</p>
<p>518<br>00:48:51,820 –&gt; 00:48:57,980<br>inbuilt that into the optimization process. And so it would then go through that and then go and</p>
<p>519<br>00:48:57,980 –&gt; 00:49:02,780<br>decide, I have to do an order by which it would defer to the very end. And so he’s the best plan.</p>
<p>520<br>00:49:02,780 –&gt; 00:49:07,340<br>How do I put the order by and try to adjust it, but not really look for an optimal plan with the</p>
<p>521<br>00:49:07,340 –&gt; 00:49:12,220<br>order by in the first place or, you know, in the worst case, it would put a start at the end of it.</p>
<p>522<br>00:49:12,220 –&gt; 00:49:17,900<br>So it was not that property of ordering was left out. And that was improved by good scruffy as</p>
<p>523<br>00:49:17,900 –&gt; 00:49:23,660<br>you look at the top down stuff in a second. Okay. And I seem to have misplaced my phone. Okay, good.</p>
<p>524<br>00:49:23,660 –&gt; 00:49:30,940<br>We have a bit of time. All right. So that is the bottom up approach. As you can see, the name is</p>
<p>525<br>00:49:30,940 –&gt; 00:49:36,940<br>because I’m building the tree pieces at a time going bottom up till I produce the final back. Right?</p>
<p>526<br>00:49:38,300 –&gt; 00:49:45,019<br>In contrast to that is the top down approach. And the top the bottom up approach by the way is what</p>
<p>527<br>00:49:45,019 –&gt; 00:49:49,659<br>all the old systems use that was a breakthrough and query optimization. So all the database systems</p>
<p>528<br>00:49:49,659 –&gt; 00:49:55,659<br>listed here use that it’s also relatively simple to implement. Not simple as a rule-based stuff.</p>
<p>529<br>00:49:55,659 –&gt; 00:50:00,699<br>Definitely be more complicated. But it takes a little bit lot more machinery to do the top down stuff.</p>
<p>530<br>00:50:01,420 –&gt; 00:50:02,619<br>What’s the top down stuff? Yep.</p>
<p>531<br>00:50:02,619 –&gt; 00:50:10,219<br>What’s the bottom? It’s the bottom. It’s the bottom.</p>
<p>532<br>00:50:10,219 –&gt; 00:50:19,179<br>Yeah. I would not say that is intrinsically a property of that. It’s you could engineer a bottom</p>
<p>533<br>00:50:19,179 –&gt; 00:50:23,339<br>up stuff in which you try to consider that upfront and they change the enumeration stuff. But that’s</p>
<p>534<br>00:50:23,339 –&gt; 00:50:28,380<br>kind of what was done there. So but I don’t know if anyone really does that that very systematically.</p>
<p>535<br>00:50:28,380 –&gt; 00:50:33,260<br>There is I’m digressing but in the system are paper there was this notion of interesting orders</p>
<p>536<br>00:50:33,260 –&gt; 00:50:39,260<br>and they would keep track of sorting till for some of these things like if I get plan A versus plan B</p>
<p>537<br>00:50:39,260 –&gt; 00:50:44,780<br>at a medium at the second level. If this one is sorted by something that needs to be joined later,</p>
<p>538<br>00:50:44,780 –&gt; 00:50:49,099<br>I could benefit from that. So did it keep some sorting information but only for the purpose of</p>
<p>539<br>00:50:49,099 –&gt; 00:50:54,539<br>join but not for explicit property that gets used for other stuff? I know it’s a technical detail but</p>
<p>540<br>00:50:54,619 –&gt; 00:50:59,579<br>can you change that? It doesn’t seem like it would it would be impossible to do that. It’s</p>
<p>541<br>00:50:59,579 –&gt; 00:51:03,900<br>but not easy either. You’d have to make some some changes. It’s not incompatible.</p>
<p>542<br>00:51:05,739 –&gt; 00:51:13,019<br>So top down was invented by Gutskrafe when he was an assistant professor with this</p>
<p>543<br>00:51:13,019 –&gt; 00:51:17,340<br>student build mechanic as part of the volcano project which we’ve seen the iterator model came</p>
<p>544<br>00:51:17,340 –&gt; 00:51:22,539<br>from their exchange stuff came from there. So obviously huge work huge contribution that he’s</p>
<p>545<br>00:51:22,539 –&gt; 00:51:30,139<br>made to the field. The realization was that really there are two types of rules you apply.</p>
<p>546<br>00:51:30,139 –&gt; 00:51:35,340<br>The logical rules like saying selection push down then there are physical rules that are related</p>
<p>547<br>00:51:35,340 –&gt; 00:51:40,460<br>to applying the algorithms or thinking about sought properties and you could write all of those</p>
<p>548<br>00:51:40,460 –&gt; 00:51:44,300<br>as transformation rules some are the logical space manipulation some in the physical space</p>
<p>549<br>00:51:44,300 –&gt; 00:51:49,900<br>manipulation and then what you do in the top down approach is you start with a plan some plan</p>
<p>550<br>00:51:49,900 –&gt; 00:51:54,300<br>that is correct and then start to say what adjustments can I make where applying the rules and they</p>
<p>551<br>00:51:54,300 –&gt; 00:51:58,780<br>could be a mix off I could apply at one point a logical rule and change a join order or I could</p>
<p>552<br>00:51:58,780 –&gt; 00:52:03,180<br>apply a physical rule and change the algorithm and I can play around with all of that stuff. So it’s</p>
<p>553<br>00:52:03,180 –&gt; 00:52:07,260<br>like don’t need to do logical planning first then physical in the bottom of fashion start with</p>
<p>554<br>00:52:07,260 –&gt; 00:52:11,660<br>something that makes sense and you can control things a lot better. So you know there’s still a</p>
<p>555<br>00:52:11,660 –&gt; 00:52:16,619<br>debate in the community but top down is probably a better way to do because you get a lot more control</p>
<p>556<br>00:52:16,619 –&gt; 00:52:21,019<br>over that so it’s space and you can be more specific because you can interlead physical and logical</p>
<p>557<br>00:52:21,019 –&gt; 00:52:27,819<br>plan manipulation. So how does that work? In the top down optimization you’re going to do as I</p>
<p>558<br>00:52:27,819 –&gt; 00:52:33,339<br>said you’ll apply two different types of rules logical to logical or logical to physical that</p>
<p>559<br>00:52:33,980 –&gt; 00:52:39,019<br>join AB versus join B is just basically I’m commuting the join logical to physical is saying if</p>
<p>560<br>00:52:39,019 –&gt; 00:52:44,699<br>I’ve got a join oh I could try a hash join and see if it is cheaper right so it can do those and</p>
<p>561<br>00:52:44,699 –&gt; 00:52:50,859<br>so it’s basically in some sense now it’s rules based but it’s going to cost each of those but the</p>
<p>562<br>00:52:50,859 –&gt; 00:52:56,139<br>rules are of two types logical logical to logical transformation or logical to physical transformation.</p>
<p>563<br>00:52:58,139 –&gt; 00:53:02,779<br>Does that make sense? Let me show you an example and maybe it’ll make more sense. So we’ll start with</p>
<p>564<br>00:53:02,779 –&gt; 00:53:07,579<br>the same query we had before and at this time we’ll say we have topped out right so we’re going to</p>
<p>565<br>00:53:07,579 –&gt; 00:53:12,939<br>start and say I have this plan I’m going to do an equi join between all those and an order by</p>
<p>566<br>00:53:13,500 –&gt; 00:53:18,380<br>that’s what I have and let’s start by seeing what else we can do with it. So it’s going to start by</p>
<p>567<br>00:53:18,380 –&gt; 00:53:24,700<br>exploring from there and apply a logical to physical plan rule and say hey you know what first two</p>
<p>568<br>00:53:24,700 –&gt; 00:53:30,940<br>let’s go join that using a sort mode join okay I’m because that plan above is still logical I don’t</p>
<p>569<br>00:53:30,940 –&gt; 00:53:35,820<br>have the physical plan but has all the properties I need with it saying three relations need to be</p>
<p>570<br>00:53:35,820 –&gt; 00:53:42,220<br>joined that’s what the top thing says and output needs to come ordered by artist ID. So the three</p>
<p>571<br>00:53:42,219 –&gt; 00:53:47,739<br>relations needs to join as a logical property it needs to be sorted by artist ID is a physical property</p>
<p>572<br>00:53:47,739 –&gt; 00:53:53,500<br>of the output right so these nodes these there’s now this notion of logical properties and physical</p>
<p>573<br>00:53:53,500 –&gt; 00:53:59,179<br>properties okay now I say I’m going to change the physical property by applying a sort mode join</p>
<p>574<br>00:53:59,179 –&gt; 00:54:04,859<br>to the tree at hand okay and that’s what it is so now it’s starting with something and then making</p>
<p>575<br>00:54:04,859 –&gt; 00:54:10,219<br>it more real and exploring in the opposite direction does that make sense like we didn’t start with</p>
<p>576<br>00:54:10,219 –&gt; 00:54:13,980<br>single relation access plan and build this dynamic program you say we’ll start with something</p>
<p>577<br>00:54:13,980 –&gt; 00:54:19,579<br>that makes sense and let’s let refine it right so you can uh and that refining will be like how much</p>
<p>578<br>00:54:19,579 –&gt; 00:54:23,899<br>portion of the search space I want to search so here it will do that sort mode join and say okay</p>
<p>579<br>00:54:23,899 –&gt; 00:54:28,059<br>now how do I do the sort mode join because I have these three stuff look at every point in time</p>
<p>580<br>00:54:28,059 –&gt; 00:54:32,379<br>is keeping a complete plan at hand right so let’s say to do the sort mode join I can take that and</p>
<p>581<br>00:54:32,379 –&gt; 00:54:38,619<br>I can take that that’s a correct plan right so it has a correct plan right now for what how it</p>
<p>582<br>00:54:38,619 –&gt; 00:54:43,980<br>could go produce that okay and then you’ll say okay what else can I do can I make this node better</p>
<p>583<br>00:54:45,179 –&gt; 00:54:50,779<br>right can I make it can I give more detailed story it’s logical can I make it more physical yep</p>
<p>584<br>00:54:50,779 –&gt; 00:54:55,900<br>I can put a hash join I can look at other stuff I needed to I could prune stuff out if I didn’t need to</p>
<p>585<br>00:54:55,900 –&gt; 00:54:59,900<br>I’ll complete that hash join and say oh yeah yeah I need to go take these two because this one’s</p>
<p>586<br>00:54:59,900 –&gt; 00:55:04,859<br>taken right that’s my tree I’m just refining it I’m making it real now I’ve got a real plan</p>
<p>587<br>00:55:04,860 –&gt; 00:55:11,019<br>for this tree for this one that I can apply other transformations to this and say okay at this</p>
<p>588<br>00:55:11,019 –&gt; 00:55:15,099<br>point I could have done something else I could have done a sort mode join and that would have</p>
<p>589<br>00:55:15,099 –&gt; 00:55:21,420<br>looked like that okay and now have two different things that are complete I could go and say</p>
<p>590<br>00:55:22,780 –&gt; 00:55:27,820<br>let’s go and keep doing this stuff keep exploring at some point you might say you know this</p>
<p>591<br>00:55:27,820 –&gt; 00:55:32,220<br>thing is more expensive and I can go prune that out so it’s just a totally different style you’re</p>
<p>592<br>00:55:32,219 –&gt; 00:55:37,099<br>going to start from the top and you can do other things but you can start to play around with all</p>
<p>593<br>00:55:37,099 –&gt; 00:55:41,899<br>kinds of interesting things that might say you know if I expect this to be small then don’t apply</p>
<p>594<br>00:55:41,899 –&gt; 00:55:47,259<br>don’t only look for hash joins don’t look for salt merge you can be more local in terms of making</p>
<p>595<br>00:55:47,259 –&gt; 00:55:52,859<br>the choices about how you apply these plans furthermore it’s a very elegant system that everything</p>
<p>596<br>00:55:52,859 –&gt; 00:55:57,019<br>is a rule that you’re applying as a transformation but your physical and logical stuff it kind of</p>
<p>597<br>00:55:57,019 –&gt; 00:56:03,659<br>works in the same framework okay it’s not like I do the logical optimization first and the physical</p>
<p>598<br>00:56:03,659 –&gt; 00:56:08,780<br>it’s like not a two-step you can interview and blend all of that stuff and start to make other</p>
<p>599<br>00:56:08,780 –&gt; 00:56:14,059<br>decisions with it and it just continues I could have gone and said oh I need to stick a quick</p>
<p>600<br>00:56:14,059 –&gt; 00:56:19,340<br>sort because I need an order buy over there but because the other in this case maybe the plan</p>
<p>601<br>00:56:19,340 –&gt; 00:56:23,579<br>was coming out salt merge by joins so it was naturally getting ordered by artist ID but if it</p>
<p>602<br>00:56:23,579 –&gt; 00:56:27,819<br>doesn’t then I could put an explicit sort method and then oh that is too expensive and I</p>
<p>603<br>00:56:27,819 –&gt; 00:56:32,380<br>so on I can prove stuff same thing you’re gonna cost up when things get physical and proven stuff out</p>
<p>604<br>00:56:32,380 –&gt; 00:56:38,219<br>but you’re just starting with a with something that works and then refining it okay and the nice part</p>
<p>605<br>00:56:38,219 –&gt; 00:56:42,860<br>about the top down is you can also very easily at you know you’ll very quickly have a correct plan</p>
<p>606<br>00:56:42,860 –&gt; 00:56:47,900<br>and you can say oh this used to cost three million very quickly I went to two million very quickly</p>
<p>607<br>00:56:47,900 –&gt; 00:56:54,700<br>I went to a thousand and now and that took me like 10 milliseconds to do now the last 100 milliseconds</p>
<p>608<br>00:56:54,700 –&gt; 00:56:59,579<br>I’ve only improved the plan by 10% stop I can go with what I want you get choices like that a far</p>
<p>609<br>00:56:59,579 –&gt; 00:57:06,619<br>more easily in the top down approach okay because you kind of see everything in front of you you start</p>
<p>610<br>00:57:06,619 –&gt; 00:57:11,740<br>with something complete and keep making it more complete right so that helps you do have to do</p>
<p>611<br>00:57:12,860 –&gt; 00:57:17,019<br>exponential 10-way dynamic programming type of a style it’ll take you a long time to get to something</p>
<p>612<br>00:57:17,019 –&gt; 00:57:22,860<br>complete right so you can start to get something out there really quick all right you have a bunch of</p>
<p>613<br>00:57:22,860 –&gt; 00:57:30,219<br>stuff to cover on the other details that matter so hopefully that was the core of the optimization</p>
<p>614<br>00:57:31,099 –&gt; 00:57:36,780<br>and that code works if I told you the query is a single block query a select project select from</p>
<p>615<br>00:57:36,780 –&gt; 00:57:41,820<br>where and that’s it but as you already know you have CTEs and you have nested sub queries that you</p>
<p>616<br>00:57:41,820 –&gt; 00:57:48,860<br>can write in life is a lot more complicated it is very common for a database system to be</p>
<p>617<br>00:57:48,860 –&gt; 00:57:53,260<br>presented with queries that might be deeply nested might at 10 20 levels of nesting as sub blocks</p>
<p>618<br>00:57:53,900 –&gt; 00:57:59,340<br>okay and you can nest in all kinds of places in SQL so what do you do with these nested queries</p>
<p>619<br>00:57:59,980 –&gt; 00:58:06,539<br>so the goal is we know how to do single block optimization right if I can take that query and I can</p>
<p>620<br>00:58:06,539 –&gt; 00:58:10,620<br>read write a nested query into a single block everything you told you before you can apply to it and</p>
<p>621<br>00:58:10,619 –&gt; 00:58:17,579<br>that works beautifully okay if you can’t do that then what you could do is to run each block at a</p>
<p>622<br>00:58:17,579 –&gt; 00:58:23,019<br>time and then build up run the innermost block then the next one and so on so you have a way to do</p>
<p>623<br>00:58:23,019 –&gt; 00:58:29,500<br>it but can we do better and the the way we can do better is by basically rewriting the queries</p>
<p>624<br>00:58:29,500 –&gt; 00:58:34,380<br>whenever possible to make it a single block query because now you’ll be able to optimize it globally</p>
<p>625<br>00:58:35,019 –&gt; 00:58:39,579<br>okay so it’s so optimizing each block which doesn’t have any information and running it</p>
<p>626<br>00:58:39,579 –&gt; 00:58:44,139<br>try to flatten it out and get a bigger block because now you give the optimizer a global view</p>
<p>627<br>00:58:44,139 –&gt; 00:58:51,019<br>of what to optimize does that make sense so here for example is a query in which we are looking at</p>
<p>628<br>00:58:51,019 –&gt; 00:58:55,579<br>sailors there’s a nested block here that’s looking at the reservation sailors have made you can see</p>
<p>629<br>00:58:55,579 –&gt; 00:59:00,699<br>the web cross there’s a join and it’s looking for all reservations made by sailors on a certain day</p>
<p>630<br>00:59:01,259 –&gt; 00:59:08,940<br>now that is the same as rewriting that query into a single block as that now the SQL programmer could</p>
<p>631<br>00:59:08,940 –&gt; 00:59:13,340<br>have written this one which you might argue but often queries are generated queries are ready</p>
<p>632<br>00:59:13,340 –&gt; 00:59:17,900<br>written by humans they’re generated by tools and tools love to generate nested queries because that’s</p>
<p>633<br>00:59:17,900 –&gt; 00:59:23,019<br>the abstraction on which they are built okay regardless for us as a database engine we have to be ready</p>
<p>634<br>00:59:23,019 –&gt; 00:59:28,220<br>with deeply nested queries and there’ll be techniques like this to go flatten stuff out often they</p>
<p>635<br>00:59:28,220 –&gt; 00:59:31,820<br>are done through a rules based components you can see there’s a little bit of that this rules are</p>
<p>636<br>00:59:31,820 –&gt; 00:59:37,740<br>everywhere you can often this rewriting and flattening is done through a rules infrastructure okay find</p>
<p>637<br>00:59:37,739 –&gt; 00:59:43,899<br>this pattern this pattern is safe if you rewrite it in this way okay and it’s not always possible</p>
<p>638<br>00:59:43,899 –&gt; 00:59:49,579<br>to flatten and we won’t go into the details here but take the advanced graduate class and we’ll do</p>
<p>639<br>00:59:49,579 –&gt; 00:59:55,739<br>that if it’s you if for queries that are harder there’s always a way out and that always a way out</p>
<p>640<br>00:59:55,739 –&gt; 01:00:00,539<br>is to just run each block at a time and get your answer but sometimes you can also do these things</p>
<p>641<br>01:00:00,539 –&gt; 01:00:05,819<br>called decomposing queries so I’ll give you an example here which is again a bunch of some</p>
<p>642<br>01:00:05,820 –&gt; 01:00:11,019<br>happening with sailors and their reservations and boats but in over here is a predicate that says</p>
<p>643<br>01:00:11,019 –&gt; 01:00:15,260<br>select only those sailors whether rating is equal to the maximum rating of all sailors so it’s</p>
<p>644<br>01:00:15,260 –&gt; 01:00:22,140<br>trying to find the highest rated sailors okay but that inner query that select max s2 rating</p>
<p>645<br>01:00:22,140 –&gt; 01:00:28,620<br>that’s effectively a constant for the rest of the block for the outer block so you could decompose</p>
<p>646<br>01:00:28,620 –&gt; 01:00:34,780<br>this query and say hey this nested block I could run that once and whatever value I get just plug</p>
<p>647<br>01:00:34,780 –&gt; 01:00:41,500<br>that value in here right and you can flatten it you can decompose it in that way and some systems</p>
<p>648<br>01:00:41,500 –&gt; 01:00:48,220<br>will actually run that get the answer stick it into this then run that so it’ll optimize that</p>
<p>649<br>01:00:48,940 –&gt; 01:00:53,260<br>first query the max rating it’s simple here but you can imagine sometimes it’s a more complex query</p>
<p>650<br>01:00:54,060 –&gt; 01:00:58,860<br>and then go flatten out the difference between this query and the other one was in this query it is</p>
<p>651<br>01:00:58,860 –&gt; 01:01:08,220<br>a co related query where this inner query that you have has it refers to if you look at this table</p>
<p>652<br>01:01:08,220 –&gt; 01:01:14,700<br>over here sailors the sailors ID field is showing up in that inner query block these are called co related</p>
<p>653<br>01:01:14,700 –&gt; 01:01:22,940<br>queries okay so co related queries tend to be flattenable a fair amount and this was not a</p>
<p>654<br>01:01:22,940 –&gt; 01:01:27,099<br>correlated query that inner block has nothing to do with no join key or any such thing with the</p>
<p>655<br>01:01:27,099 –&gt; 01:01:31,819<br>outer stuff they are very amenable to doing this decomposition you can just pull it out it feels</p>
<p>656<br>01:01:31,819 –&gt; 01:01:37,099<br>like a constant and it is a constant for the rest of the query right so you’ll do techniques like this</p>
<p>657<br>01:01:37,099 –&gt; 01:01:43,659<br>before you go and start throwing things to the query optimizer other things that you will do before</p>
<p>658<br>01:01:43,659 –&gt; 01:01:48,380<br>you present stuff to the query optimizer and sometimes this expression reading is also what the</p>
<p>659<br>01:01:48,380 –&gt; 01:01:53,739<br>query optimizer does so it gets confusing as to where the boundary between the parser is and the</p>
<p>660<br>01:01:53,739 –&gt; 01:01:58,619<br>optimizer is and the execution engineers right those boundaries are artificial and in fact there’s</p>
<p>661<br>01:01:58,619 –&gt; 01:02:03,019<br>a nice paper that talks about this artificial boundary causes a lot of trouble and again particularly</p>
<p>662<br>01:02:03,019 –&gt; 01:02:09,099<br>advanced database class we’ll cover that type of material expressions are everywhere and sometimes</p>
<p>663<br>01:02:09,099 –&gt; 01:02:13,659<br>you will get queries that look like this so before you even go and optimize the query and stuff</p>
<p>664<br>01:02:13,659 –&gt; 01:02:18,219<br>like that and this may be piece of a query right maybe in a block of a query somewhere where someone</p>
<p>665<br>01:02:18,219 –&gt; 01:02:22,219<br>writes where one is equal to zero and you might say why would a user write that they probably wouldn’t</p>
<p>666<br>01:02:22,219 –&gt; 01:02:26,619<br>write that but the tool would definitely generate stuff like this all the time right and sometimes</p>
<p>667<br>01:02:26,619 –&gt; 01:02:30,219<br>users do make mistakes and they’ll write stuff like that so you might you might see all kinds of</p>
<p>668<br>01:02:30,219 –&gt; 01:02:34,619<br>crazy stuff if you’ve been long around and well with the database that’s been around for a while</p>
<p>669<br>01:02:34,619 –&gt; 01:02:38,779<br>and you could rewrite this stuff to say you know this is really the same as where is equal to false I can</p>
<p>670<br>01:02:39,579 –&gt; 01:02:45,179<br>take that expression and just convert it into a simpler truth function because that makes everything</p>
<p>671<br>01:02:45,179 –&gt; 01:02:50,939<br>easier okay in this case it’s going to return nothing right and same thing you’ll see functions like</p>
<p>672<br>01:02:50,940 –&gt; 01:02:55,900<br>now is equal to now is null that can also be made into that and some systems when you have</p>
<p>673<br>01:02:55,900 –&gt; 01:03:00,460<br>functions like now and random won’t do that false and actually go evaluate the query and come up with</p>
<p>674<br>01:03:00,460 –&gt; 01:03:05,500<br>the answer because these sometimes don’t know what’s the property of random or null you know and</p>
<p>675<br>01:03:05,500 –&gt; 01:03:10,220<br>many database systems also allow users to register external functions so you can’t make assumptions</p>
<p>676<br>01:03:10,220 –&gt; 01:03:14,860<br>so databases will take different approaches to doing that the main point is if you have expressions</p>
<p>677<br>01:03:14,860 –&gt; 01:03:19,420<br>you can go and rewrite that before you send everything to the optimizer because you can just</p>
<p>678<br>01:03:19,420 –&gt; 01:03:23,900<br>simplify that these are just in the math stuff you can do systematic stuff you can do that are safe</p>
<p>679<br>01:03:23,900 –&gt; 01:03:31,740<br>to do that here’s a between a predicate where it’s a or so between one and 100 or between 50 and 100</p>
<p>680<br>01:03:31,740 –&gt; 01:03:37,260<br>it’s the same as rewriting that to do that so simplify the query using safe methods to these</p>
<p>681<br>01:03:37,260 –&gt; 01:03:42,940<br>different rewrites flattening out the methods before you get stuff to the optimizer okay that’s</p>
<p>682<br>01:03:42,940 –&gt; 01:03:46,700<br>usually a good way to do it questions</p>
<p>683<br>01:03:49,420 –&gt; 01:03:55,980<br>okay all right now there’s a question of how do we calculate the cost of these plans right we</p>
<p>684<br>01:03:55,980 –&gt; 01:03:59,420<br>talked about oh we’ll produce these plans whether it’s bottom up or top down at some point you have</p>
<p>685<br>01:03:59,420 –&gt; 01:04:04,619<br>to say what does this cost do a prune prune this plan or do I keep keep it around and so that’s where</p>
<p>686<br>01:04:04,619 –&gt; 01:04:09,900<br>the assumptions of these cost models come in and essentially it’s like hey what’s the size of the</p>
<p>687<br>01:04:09,900 –&gt; 01:04:14,220<br>output of the joint I need to know that to figure out what of output of that selection because I</p>
<p>688<br>01:04:14,220 –&gt; 01:04:18,059<br>need to know that to figure out what’s that joint going to cost should I be using a sort merge versus</p>
<p>689<br>01:04:18,539 –&gt; 01:04:22,940<br>nested loop should I be commuting that joint I need to know these numbers before I can make any of</p>
<p>690<br>01:04:22,940 –&gt; 01:04:30,299<br>those choices so need a cost model and the cost estimations done in a variety of different ways and</p>
<p>691<br>01:04:30,299 –&gt; 01:04:36,460<br>it will be a combination of using some internal cost model that allows us to compare one plan versus</p>
<p>692<br>01:04:36,460 –&gt; 01:04:40,779<br>the other right you already saw this in action with the example that we started in the class so</p>
<p>693<br>01:04:40,779 –&gt; 01:04:45,420<br>let’s just dig into that they’re usually going to be two components to the cost model what is going to</p>
<p>694<br>01:04:45,420 –&gt; 01:04:50,860<br>be say I mean what are my units that I’m pricing out so the units might be how many CPU cycles and</p>
<p>695<br>01:04:50,860 –&gt; 01:04:55,420<br>I’m going to consume how many IOs we are going to consume in the example we talked about that I</p>
<p>696<br>01:04:55,420 –&gt; 01:05:00,300<br>showed earlier it was just IO cost but sometimes the CPU cost can be significant and that might change</p>
<p>697<br>01:05:00,300 –&gt; 01:05:05,500<br>so you really want to have a proper cost models and when you have CPU and IO cost you might also</p>
<p>698<br>01:05:05,500 –&gt; 01:05:10,539<br>need to basically then say you know how many cycles of CPU can I trade off for an IO cost so you</p>
<p>699<br>01:05:10,539 –&gt; 01:05:15,340<br>going to need some constants and often those are guesses that are input into the optimizer these</p>
<p>700<br>01:05:15,340 –&gt; 01:05:21,259<br>cost models are really hard to get right but we need something that is reasonable okay then there</p>
<p>701<br>01:05:21,259 –&gt; 01:05:26,219<br>are these logical costs that will depend upon the size of the output size of the operators and the</p>
<p>702<br>01:05:26,219 –&gt; 01:05:30,940<br>algorithms that we have chosen so ultimately we have to combine all of that stuff to come up with</p>
<p>703<br>01:05:30,940 –&gt; 01:05:36,940<br>something that looks real with all the complexity that happens in database system into CPUs IO</p>
<p>704<br>01:05:36,940 –&gt; 01:05:41,579<br>activity network activity and stuff like that but you still need to say which one is better because</p>
<p>705<br>01:05:41,579 –&gt; 01:05:46,780<br>you have all kinds of trade-offs that are getting made so most systems will use a combination of</p>
<p>706<br>01:05:47,340 –&gt; 01:05:53,019<br>CPU and IO cost they will at least do those two and then they will have to pick some default</p>
<p>707<br>01:05:53,019 –&gt; 01:05:57,659<br>stuff like saying in post-test it will be processing the tuple in memory is 400 times faster than</p>
<p>708<br>01:05:57,659 –&gt; 01:06:01,980<br>reading a tuple from disk because you have to come up with a common unit across all of these</p>
<p>709<br>01:06:01,980 –&gt; 01:06:07,260<br>different factors so these are going to be additional assumptions that we make to get something real</p>
<p>710<br>01:06:07,260 –&gt; 01:06:14,699<br>so we can compare two plans and say which one is cheaper okay and so you’ll see if you look at the</p>
<p>711<br>01:06:14,699 –&gt; 01:06:19,500<br>manual of Postgres which is very nice because it’s open they’ll have stuff like this look we don’t</p>
<p>712<br>01:06:19,500 –&gt; 01:06:23,179<br>know what we are doing but this is the best we can do and pretty much every database system is going</p>
<p>713<br>01:06:23,179 –&gt; 01:06:29,019<br>to have that is a famous thing at SQL server where the cost model for those constants like 400</p>
<p>714<br>01:06:29,019 –&gt; 01:06:35,340<br>was based upon a desktop on which some benchmarks were run that are sitting below one of the original</p>
<p>715<br>01:06:35,340 –&gt; 01:06:41,340<br>creators of SQL server for the longest time the constants were chosen based on on this machine</p>
<p>716<br>01:06:41,340 –&gt; 01:06:47,579<br>how many IO how many cycles can I run how many CPU operations can I do in one IO but crazy things</p>
<p>717<br>01:06:47,579 –&gt; 01:06:52,460<br>like that happen okay and of course they fixed it systems like DB2 and other advanced systems when</p>
<p>718<br>01:06:52,460 –&gt; 01:06:56,619<br>you install the system they will run a few micro benchmarks to come up with those constants and</p>
<p>719<br>01:06:56,619 –&gt; 01:07:01,179<br>use that because that changes from machine to machine but those things are important to get things</p>
<p>720<br>01:07:01,179 –&gt; 01:07:06,859<br>right we also had statistics such as number of records and stuff like that in the tables that we looked</p>
<p>721<br>01:07:06,859 –&gt; 01:07:12,699<br>at who creates that database systems have special commands like analyze and they will go and scan</p>
<p>722<br>01:07:12,699 –&gt; 01:07:18,059<br>the entire table to go produce that stats which goes into the catalog okay and you can run that</p>
<p>723<br>01:07:18,059 –&gt; 01:07:23,500<br>periodically you can run it as a cron job so it’s not uncommon to say I’m going to run it every week</p>
<p>724<br>01:07:23,500 –&gt; 01:07:27,739<br>and as we start about transactions these things that scan all of that for doing things like analyze</p>
<p>725<br>01:07:27,739 –&gt; 01:07:33,420<br>will be run at the lowest isolation level right so it’s okay if they see slightly in the corrupt data</p>
<p>726<br>01:07:33,420 –&gt; 01:07:37,500<br>we just want to get decent guesses for how many records are there we do or to be offered orders of</p>
<p>727<br>01:07:37,500 –&gt; 01:07:46,460<br>magnitude okay then we also have to do interesting things like saying okay I see a predicate this is</p>
<p>728<br>01:07:46,460 –&gt; 01:07:51,900<br>called the selection cardinality I have to estimate the cardinality of a select operator so I’ve got</p>
<p>729<br>01:07:51,900 –&gt; 01:07:57,579<br>a predicate here that says age is equal to nine how do I know how many records will pass that</p>
<p>730<br>01:07:57,579 –&gt; 01:08:03,420<br>predicate because I need that for the rest of the planning right and so you start making assumptions so</p>
<p>731<br>01:08:04,780 –&gt; 01:08:10,780<br>this is not real but imagine you were able to store there are 16 different 15 different values</p>
<p>732<br>01:08:10,780 –&gt; 01:08:16,060<br>age values in this database and you store exact counts for each of those now you can say age is</p>
<p>733<br>01:08:16,060 –&gt; 01:08:23,980<br>equal to nine I can look at the value the number of occurrences that I have for nine which is there</p>
<p>734<br>01:08:23,980 –&gt; 01:08:29,820<br>so four they’re total of 45 different values so I can see the selectivity of this operation</p>
<p>735<br>01:08:29,820 –&gt; 01:08:39,100<br>is four by 45 now I can use that to guess what the output sizes yep you would do this for anything</p>
<p>736<br>01:08:39,100 –&gt; 01:08:44,460<br>on which you can have a predicate which could be non index attribute too and as you’ll see very</p>
<p>737<br>01:08:44,460 –&gt; 01:08:50,460<br>next slide that was obviously too expensive because you know the space to store that detailed value</p>
<p>738<br>01:08:50,460 –&gt; 01:08:54,619<br>could be the same space as you need to store the original column so you might be doubling the size</p>
<p>739<br>01:08:54,619 –&gt; 01:08:59,659<br>of your database which is a bad idea you want these statistics to be compact and as accurate as</p>
<p>740<br>01:08:59,659 –&gt; 01:09:04,779<br>possible and cheap to compute it’s like three things touching against each other and you won’t get</p>
<p>741<br>01:09:04,779 –&gt; 01:09:09,100<br>all of that but that’s the whole design space we’re also going to make assumptions that the data is</p>
<p>742<br>01:09:09,100 –&gt; 01:09:14,300<br>uniformly distributed right like we did when we said toys across employees is uniformly distributed</p>
<p>743<br>01:09:14,380 –&gt; 01:09:18,860<br>will assume independence and we’ll talk about that next that two predicates are independent we can</p>
<p>744<br>01:09:18,860 –&gt; 01:09:23,100<br>just combine them that may not hold true in practice but they advance methods to work with that</p>
<p>745<br>01:09:23,739 –&gt; 01:09:27,980<br>then we’ll do inclusion principle like we did we said oh every department employee will have a</p>
<p>746<br>01:09:29,020 –&gt; 01:09:33,900<br>every employee has a department I did they’re not all nuts so a foreign key is point to something</p>
<p>747<br>01:09:33,900 –&gt; 01:09:39,260<br>real so these are all assumptions that we make as we start to make estimates about these cardinality</p>
<p>748<br>01:09:39,260 –&gt; 01:09:44,380<br>so the question that was asked related to that is sometimes these can be way off so for example if I’ve</p>
<p>749<br>01:09:44,380 –&gt; 01:09:51,500<br>got two predicates where it says make is Honda and model is a card and I say by these statistics by</p>
<p>750<br>01:09:51,500 –&gt; 01:09:58,699<br>individual stats on the make column I estimate that one in 10 cards is a Honda and one in 100 cards</p>
<p>751<br>01:09:59,340 –&gt; 01:10:05,420<br>100 models is an accord a semi estimation says that the joint cardinality for both of these columns</p>
<p>752<br>01:10:05,420 –&gt; 01:10:11,020<br>is the product of those two but I would be way off why because only Honda makes a card so I assume</p>
<p>753<br>01:10:11,020 –&gt; 01:10:16,619<br>uniform distribution and that is way off so these can be wrong and that touches on this point of how</p>
<p>754<br>01:10:16,619 –&gt; 01:10:21,340<br>you sometimes have to go and dynamically re-optimize these queries and that’s a hot topic of research</p>
<p>755<br>01:10:21,340 –&gt; 01:10:30,460<br>even to this day okay there are the things you can do uh histograms are going to represent this</p>
<p>756<br>01:10:30,460 –&gt; 01:10:36,619<br>details information that we had but with a lot less space so two classes of histograms the first</p>
<p>757<br>01:10:36,619 –&gt; 01:10:43,260<br>one will say I will go and take uh this information and break it up into buckets so I divided into five</p>
<p>758<br>01:10:43,260 –&gt; 01:10:49,020<br>buckets three values in each bucket now for each bucket I will store the total count so now I</p>
<p>759<br>01:10:49,020 –&gt; 01:10:54,220<br>one third the number of values that I’m storing right I can make it one tenth one hundred one million</p>
<p>760<br>01:10:54,220 –&gt; 01:10:58,939<br>whatever I want to and these are called equi with histogram because I picked a width and kept that</p>
<p>761<br>01:10:58,939 –&gt; 01:11:05,099<br>uniform and I just did across that space and counted in that there’s a flip side of it called equi</p>
<p>762<br>01:11:05,099 –&gt; 01:11:09,819<br>depth histogram that’s going to allow the bucket size to be different but it’s going to say I’m</p>
<p>763<br>01:11:09,819 –&gt; 01:11:14,859<br>trying to get roughly equal values in each of these buckets and uh they’re different properties</p>
<p>764<br>01:11:14,859 –&gt; 01:11:19,500<br>between the equi width and equi depth the all kinds of other names you hear if you get into this</p>
<p>765<br>01:11:19,500 –&gt; 01:11:24,939<br>space like re-optimal histograms and stuff pros and cons for each one of those both topics we cover in</p>
<p>766<br>01:11:24,939 –&gt; 01:11:29,979<br>the advanced database class here you need to know that we do histograms because you want a more compact</p>
<p>767<br>01:11:29,979 –&gt; 01:11:36,379<br>representation they’re more accurate than just guessing uniform distribution okay so they’re very</p>
<p>768<br>01:11:36,379 –&gt; 01:11:42,379<br>important and you want to have these histograms the more advanced versions of histograms based on</p>
<p>769<br>01:11:42,379 –&gt; 01:11:46,299<br>these things called sketches you’re not going to go into the details of it again that gets covered in</p>
<p>770<br>01:11:46,299 –&gt; 01:11:52,859<br>the advanced database class they are more sophisticated of building things uh of building these types of</p>
<p>771<br>01:11:52,859 –&gt; 01:11:58,539<br>approximate stats the key one over here is hyper log log which is used all over it’s a very fast</p>
<p>772<br>01:11:58,539 –&gt; 01:12:05,500<br>way to get uh uh to get an estimate for the number of distinct values in a set in a single pass</p>
<p>773<br>01:12:05,500 –&gt; 01:12:11,500<br>and that gets used for all over the place including in data platform outside database systems uh so</p>
<p>774<br>01:12:11,500 –&gt; 01:12:16,219<br>if you’re interviewing for a database job do look up hyper log log because you should you should be</p>
<p>775<br>01:12:16,219 –&gt; 01:12:20,859<br>aware of that method it’s a fast way to do approximate counting obviously has importance for the</p>
<p>776<br>01:12:20,859 –&gt; 01:12:25,739<br>types of stuff we do in optimization but in all of the places still the other thing you could do a</p>
<p>777<br>01:12:25,739 –&gt; 01:12:33,019<br>sample so I can uh take randomly sample one hundredth of the records in the table and then say take</p>
<p>778<br>01:12:33,019 –&gt; 01:12:38,299<br>the predicate I have which is ages greater than 50 here what does it look like on my sample I’ve just</p>
<p>779<br>01:12:38,299 –&gt; 01:12:43,259<br>brought a small amount of data from this not the entire table and whatever I get I’ll say okay</p>
<p>780<br>01:12:43,259 –&gt; 01:12:47,579<br>that’s going to apply to the rest of it so it’s of completely guessing uniform distribution this</p>
<p>781<br>01:12:47,579 –&gt; 01:12:53,019<br>is a more educated guess with a little extra cost right so uh that’s the trade off you’re making a</p>
<p>782<br>01:12:53,019 –&gt; 01:13:00,300<br>little extra cost for uh more accurate information so I know I’m running out of time I’ve got three</p>
<p>783<br>01:13:00,300 –&gt; 01:13:06,300<br>slides so this is the conclusion slide let’s tie everything together and hopefully you’ve appreciated</p>
<p>784<br>01:13:06,300 –&gt; 01:13:13,340<br>what query optimization does and it’s going to look at the SQL query convert that into a logical plan</p>
<p>785<br>01:13:13,340 –&gt; 01:13:17,579<br>eventually end up with the physical plan and as you saw sometimes that logical to physical is not</p>
<p>786<br>01:13:17,579 –&gt; 01:13:22,699<br>like a one step linear process but you could be intertwining those till you end up with a physical plan</p>
<p>787<br>01:13:22,699 –&gt; 01:13:27,180<br>that you can give to a schedule of which is all the details that you need before you do all of that</p>
<p>788<br>01:13:27,180 –&gt; 01:13:31,980<br>stuff using the top down or bottom up approach for query optimization you’ll flatten the query out</p>
<p>789<br>01:13:31,980 –&gt; 01:13:36,140<br>do all the expressions rewrites all that other stuff to make the query correct and has compact as</p>
<p>790<br>01:13:36,140 –&gt; 01:13:41,500<br>possible for sending it to the optimizer was a very hard work to do the enumeration as we said it can</p>
<p>791<br>01:13:41,500 –&gt; 01:13:46,699<br>be talked on a bottom up and for all of this to work you may have the best enumeration algorithm</p>
<p>792<br>01:13:46,699 –&gt; 01:13:52,300<br>but if your cost function is off you’ll get bad plans so you need the cost uh functions to also work</p>
<p>793<br>01:13:53,020 –&gt; 01:13:58,300<br>so that’s all the stuff I need you to know for the exams just give me two minutes for those of you</p>
<p>794<br>01:13:58,300 –&gt; 01:14:02,619<br>who are really curious about query optimization I just want to tell you you want to dig deeper into</p>
<p>795<br>01:14:02,619 –&gt; 01:14:08,460<br>this space so not gonna grill you for the exams on this but many of you are probably curious</p>
<p>796<br>01:14:09,260 –&gt; 01:14:13,180<br>there are four essential there you probably need to read like 5200 papers if you’re going to build a</p>
<p>797<br>01:14:13,180 –&gt; 01:14:18,140<br>query optimizer it is less rocket sciencey than it seems and I’ll talk about that in the next</p>
<p>798<br>01:14:18,140 –&gt; 01:14:24,619<br>slide but it’s very very hard on as I said optimizers are often the highest paid engineers in any data</p>
<p>799<br>01:14:24,619 –&gt; 01:14:30,539<br>company the first one is the way where you would start it’s written by Suridhich Chaudhary a giant</p>
<p>800<br>01:14:30,539 –&gt; 01:14:36,220<br>in the field of optimization at Microsoft it just gives you very it in like a small number of pages</p>
<p>801<br>01:14:36,220 –&gt; 01:14:42,380<br>like 8 or 10 pages he synthesized that whole field as it stood back in 98 and said here’s that</p>
<p>802<br>01:14:42,380 –&gt; 01:14:46,380<br>whole mess and here’s how you should think about enumeration costing and stuff like that beautiful</p>
<p>803<br>01:14:46,380 –&gt; 01:14:50,860<br>paper very easy to read if you understood everything today I strongly recommend you to go and read</p>
<p>804<br>01:14:50,860 –&gt; 01:14:54,780<br>that paper it’ll take you to that next level again we won’t grill you in the exam but it’s great</p>
<p>805<br>01:14:55,659 –&gt; 01:14:59,659<br>then there’s the paper by Gertz Krafay which is that top-down stuff very technical detail takes a</p>
<p>806<br>01:14:59,659 –&gt; 01:15:04,619<br>little bit of getting used to then the next paper is a system art that started this whole field of</p>
<p>807<br>01:15:04,619 –&gt; 01:15:10,140<br>optimization the last one is this which is a beautiful paper it’s a beautiful title two of</p>
<p>808<br>01:15:10,140 –&gt; 01:15:15,180<br>nests and trees which basically says sometimes we have these outer joints right you’ve seen that</p>
<p>809<br>01:15:15,180 –&gt; 01:15:19,420<br>everything we’ve talked about today was about inner joints but these outer joints cause a massive</p>
<p>810<br>01:15:19,420 –&gt; 01:15:24,859<br>nightmare for query optimization this paper showed that if you’ve got a bunch of outer joints and</p>
<p>811<br>01:15:24,859 –&gt; 01:15:30,939<br>inner joints mixed up in your query there are in many cases clean ways to get a block of outer</p>
<p>812<br>01:15:30,939 –&gt; 01:15:35,099<br>joint read written and a block of inner joints read so you can optimize just the inner joints through</p>
<p>813<br>01:15:35,099 –&gt; 01:15:39,739<br>all the techniques we’ve talked about beautiful beautiful paper it just seemed impossible that you</p>
<p>814<br>01:15:39,739 –&gt; 01:15:43,899<br>could make this algebra that clean but if you’re into that type of match stuff in algorithms</p>
<p>815<br>01:15:43,899 –&gt; 01:15:49,099<br>I strongly recommend that and then the last slide is uh next time we’ll talk about transactions</p>
<p>816<br>01:15:49,099 –&gt; 01:15:55,099<br>which is the next hardest part and let’s see if I flip one of the slides that I needed to just give</p>
<p>817<br>01:15:55,100 –&gt; 01:16:05,900<br>me a minute as I try to pull that up there we go and this is the very last slide which is if you are</p>
<p>818<br>01:16:05,900 –&gt; 01:16:13,660<br>going to go and do try to build an optimizer three rules these are my rules you’ll have to read a</p>
<p>819<br>01:16:13,660 –&gt; 01:16:20,300<br>lot of papers with lots of algebra get used to that it’ll be a lot of fun early on you’re going to</p>
<p>820<br>01:16:20,300 –&gt; 01:16:24,860<br>have to throw a lot more work roads at it because optimizers get better over time by hardening</p>
<p>821<br>01:16:25,260 –&gt; 01:16:30,460<br>and that’s how db2 oracle SQL servers optimizers are amongst the best because they’ve seen so much</p>
<p>822<br>01:16:30,460 –&gt; 01:16:36,060<br>workload over the last 30 40 years the last one is you will not no matter how smart you are you will not</p>
<p>823<br>01:16:36,060 –&gt; 01:16:40,380<br>get it right in the first place it’s not that oh I picked the right enumeration strategy and stuff</p>
<p>824<br>01:16:40,380 –&gt; 01:16:46,140<br>like that it’s nitty-gritty details like hey what was the data structure that I used to keep track of</p>
<p>825<br>01:16:46,140 –&gt; 01:16:51,820<br>all the tables and all the predicates and keep track of which one gets evaluated where and you’ll</p>
<p>826<br>01:16:52,219 –&gt; 01:16:57,340<br>soon have a spaghetti of objects in your c++ code that are all over the place you’ll try to do a</p>
<p>827<br>01:16:57,340 –&gt; 01:17:01,579<br>logical to physical transformation and find the data structures are all wrong you’ll probably patch it</p>
<p>828<br>01:17:01,579 –&gt; 01:17:06,460<br>and very soon you’ll have code that is unmentainable not because the optimizer stuff is that hard it</p>
<p>829<br>01:17:06,460 –&gt; 01:17:11,420<br>is hard which because you made it even harder because the data structures are all spaghetti I’ve seen</p>
<p>830<br>01:17:11,420 –&gt; 01:17:16,059<br>three optimizers one that was written by someone else doing my thesis work who are sitting right next</p>
<p>831<br>01:17:16,059 –&gt; 01:17:20,859<br>to me and he had a really interesting thing that is I told him why is your code so hard to read and he</p>
<p>832<br>01:17:20,859 –&gt; 01:17:25,500<br>said it was hard to write so it may be hard to read right it is hard to write and if you don’t go</p>
<p>833<br>01:17:25,500 –&gt; 01:17:29,179<br>back and throw it away it’ll be hard to read and when you’re writing it you’re just building on it</p>
<p>834<br>01:17:30,619 –&gt; 01:17:36,460<br>and I have looked at the DB2 optimizer I worked on that in an intern it was very very difficult to read</p>
<p>835<br>01:17:36,460 –&gt; 01:17:40,779<br>and then in the quick step system we tried to build ask me and optimize as it could build but in the</p>
<p>836<br>01:17:40,779 –&gt; 01:17:46,219<br>end we still ended up with the data mess it’s because we did not do rule number three which is</p>
<p>837<br>01:17:46,220 –&gt; 01:17:50,300<br>planned to throw it away and read right from scratch and don’t try to patch it so with that</p>
<p>838<br>01:17:50,300 –&gt; 01:17:53,659<br>I’ll stop and then we’ll pick up on transactions in the next class thank you</p>
<p>839<br>01:18:16,780 –&gt; 01:18:20,699<br>you ain’t hit them all yeah still got your shirt up I smack you with the bottom of the</p>
<p>840<br>01:18:20,699 –&gt; 01:18:25,579<br>clip to tell you look up show me what it’s safe set for I blow your face back I got a block on</p>
<p>841<br>01:18:25,579 –&gt; 01:18:30,860<br>taps the fence can’t trace that style is like Tampa proof you can’t lace that at the Dominican</p>
<p>842<br>01:18:30,860 –&gt; 01:18:36,060<br>oh you could call me Dominican black Skelly black leather black sweat dimmelins my old black</p>
<p>843<br>01:18:36,060 –&gt; 01:18:40,380<br>dirty eight send you to the perigates you get a zombie trying to skate and that’s your first</p>
<p>844<br>01:18:41,020 –&gt; 01:18:45,420<br>I ain’t lying for that take your family see you wait my grand’s is happy wait the ran through every</p>
<p>845<br>01:18:45,420 –&gt; 01:18:48,380<br>state when they acting how I’m living tell them I’m living great</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CMU15445 P15F202314 QueryPlanningOptimization</div>
      <div>http://example.com/2025/10/24/CMU15445 P15F202314-QueryPlanningOptimization/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月24日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/24/CMU15445%20P16F202315-ConcurrencyControlTheory/" title="CMU15445 P16F202315 ConcurrencyControlTheory">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CMU15445 P16F202315 ConcurrencyControlTheory</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/24/CMU15445%20P14F202313-QueryExecutionPart2/" title="CMU15445 P14F202313 QueryExecutionPart2">
                        <span class="hidden-mobile">CMU15445 P14F202313 QueryExecutionPart2</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
