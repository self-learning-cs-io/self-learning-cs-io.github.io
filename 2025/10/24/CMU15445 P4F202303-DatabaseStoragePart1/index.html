

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="100:00:00,000 –&gt; 00:00:22,460Music 200:00:22,460 –&gt; 00:00:29,460Alright, DJ TPL. 300:00:29,460 –&gt; 00:00:32,700Thank you. 400:00:32,700 –&gt; 00:00:34,859I heard a wild rumor. 500:00:34,859 –&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="CMU15445 P4F202303 DatabaseStoragePart1">
<meta property="og:url" content="http://example.com/2025/10/24/CMU15445%20P4F202303-DatabaseStoragePart1/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="100:00:00,000 –&gt; 00:00:22,460Music 200:00:22,460 –&gt; 00:00:29,460Alright, DJ TPL. 300:00:29,460 –&gt; 00:00:32,700Thank you. 400:00:32,700 –&gt; 00:00:34,859I heard a wild rumor. 500:00:34,859 –&amp;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-24T12:00:44.478Z">
<meta property="article:modified_time" content="2025-10-24T12:06:28.543Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>CMU15445 P4F202303 DatabaseStoragePart1 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CMU15445 P4F202303 DatabaseStoragePart1"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-24 20:00" pubdate>
          2025年10月24日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          14k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          117 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">CMU15445 P4F202303 DatabaseStoragePart1</h1>
            
            
              <div class="markdown-body">
                
                <p>1<br>00:00:00,000 –&gt; 00:00:22,460<br>Music</p>
<p>2<br>00:00:22,460 –&gt; 00:00:29,460<br>Alright, DJ TPL.</p>
<p>3<br>00:00:29,460 –&gt; 00:00:32,700<br>Thank you.</p>
<p>4<br>00:00:32,700 –&gt; 00:00:34,859<br>I heard a wild rumor.</p>
<p>5<br>00:00:34,859 –&gt; 00:00:37,859<br>I heard he used to date Larry Allison’s girlfriend.</p>
<p>6<br>00:00:37,859 –&gt; 00:00:41,659<br>Oh, you heard that?</p>
<p>7<br>00:00:41,659 –&gt; 00:00:44,659<br>What are you?</p>
<p>8<br>00:00:44,659 –&gt; 00:00:45,659<br>What happened?</p>
<p>9<br>00:00:45,659 –&gt; 00:00:46,659<br>He stole it from you?</p>
<p>10<br>00:00:46,659 –&gt; 00:00:47,659<br>Man, you guys.</p>
<p>11<br>00:00:47,659 –&gt; 00:00:48,659<br>Alright.</p>
<p>12<br>00:00:48,659 –&gt; 00:00:56,979<br>Alright, we’ll come back to that later.</p>
<p>13<br>00:00:56,979 –&gt; 00:00:58,579<br>Larry Allison is the founder oracle.</p>
<p>14<br>00:00:58,579 –&gt; 00:01:01,459<br>He is the fifth richest person in the world.</p>
<p>15<br>00:01:01,459 –&gt; 00:01:03,459<br>He owns a Hawaiian island.</p>
<p>16<br>00:01:03,459 –&gt; 00:01:05,379<br>All paid for by databases.</p>
<p>17<br>00:01:05,379 –&gt; 00:01:07,459<br>That’s why this class exists.</p>
<p>18<br>00:01:07,459 –&gt; 00:01:08,459<br>Alright.</p>
<p>19<br>00:01:08,459 –&gt; 00:01:10,739<br>So I’m administrative stuff.</p>
<p>20<br>00:01:10,739 –&gt; 00:01:15,739<br>So the homework one, we do this coming Sunday on a 10th.</p>
<p>21<br>00:01:15,739 –&gt; 00:01:17,340<br>Project Zero is also doing the 10th.</p>
<p>22<br>00:01:17,340 –&gt; 00:01:20,340<br>Who here is not started Project Zero?</p>
<p>23<br>00:01:20,340 –&gt; 00:01:22,140<br>One, why not?</p>
<p>24<br>00:01:22,140 –&gt; 00:01:24,140<br>Two.</p>
<p>25<br>00:01:24,140 –&gt; 00:01:26,740<br>Do you know C++?</p>
<p>26<br>00:01:26,740 –&gt; 00:01:27,740<br>That’s a no.</p>
<p>27<br>00:01:27,740 –&gt; 00:01:29,939<br>Do you know C++?</p>
<p>28<br>00:01:29,939 –&gt; 00:01:36,140<br>You should really start because if you know 0 C++, it will be a struggle.</p>
<p>29<br>00:01:36,140 –&gt; 00:01:38,540<br>And again, we’re not trying to do this to torture you.</p>
<p>30<br>00:01:38,540 –&gt; 00:01:41,700<br>It’s really meant to be like, this is what the rest of the course is going to be like</p>
<p>31<br>00:01:41,700 –&gt; 00:01:43,100<br>in terms of the projects.</p>
<p>32<br>00:01:43,100 –&gt; 00:01:47,140<br>If you don’t know how to write C++ and don’t have to debug it, you’re going to have problems.</p>
<p>33<br>00:01:47,140 –&gt; 00:01:51,460<br>Print F or standard C out is not a debug method.</p>
<p>34<br>00:01:51,460 –&gt; 00:01:52,460<br>Okay?</p>
<p>35<br>00:01:52,460 –&gt; 00:01:54,659<br>You know, you want to use a debugger.</p>
<p>36<br>00:01:54,659 –&gt; 00:01:56,460<br>And then Project One will be released.</p>
<p>37<br>00:01:56,460 –&gt; 00:02:00,540<br>If we suppose to go out today, probably will come out Friday.</p>
<p>38<br>00:02:00,540 –&gt; 00:02:03,980<br>And that will be on the buffer pool, which we’ll start teaching in a week and a half.</p>
<p>39<br>00:02:03,980 –&gt; 00:02:04,980<br>Okay?</p>
<p>40<br>00:02:04,980 –&gt; 00:02:07,980<br>Any questions about homework one or Project Zero?</p>
<p>41<br>00:02:07,980 –&gt; 00:02:08,979<br>Okay.</p>
<p>42<br>00:02:08,979 –&gt; 00:02:12,500<br>Alright, jump into the material.</p>
<p>43<br>00:02:12,500 –&gt; 00:02:18,379<br>So last class, we spent time talking about SQL and the modern things you can do with</p>
<p>44<br>00:02:18,379 –&gt; 00:02:22,900<br>the CTEs, lateral joins, nested queries, wind of functions, so forth.</p>
<p>45<br>00:02:22,900 –&gt; 00:02:26,500<br>Prior to that, we talked about the relational model and relational algebra.</p>
<p>46<br>00:02:26,500 –&gt; 00:02:31,979<br>And so at this point, that’s the logical view of what the database system is going to look</p>
<p>47<br>00:02:31,979 –&gt; 00:02:32,979<br>like that.</p>
<p>48<br>00:02:32,979 –&gt; 00:02:35,939<br>We’re going to sort of mentally construct throughout the rest of the semester.</p>
<p>49<br>00:02:35,939 –&gt; 00:02:39,060<br>So we’re not going to go back to these discuss these things, but we’ll see how we need to</p>
<p>50<br>00:02:39,060 –&gt; 00:02:40,979<br>know what SQL looks like what relational model is.</p>
<p>51<br>00:02:40,979 –&gt; 00:02:45,060<br>In order to build the various parts of the system, we’ll be discussing going forward.</p>
<p>52<br>00:02:45,060 –&gt; 00:02:49,339<br>So as I said at the end of last class, this point forward and the semester going forward,</p>
<p>53<br>00:02:49,339 –&gt; 00:02:54,659<br>up and around Thanksgiving is going to be how to build a sort of a classic or canonical</p>
<p>54<br>00:02:54,659 –&gt; 00:02:58,939<br>database, relational database management system.</p>
<p>55<br>00:02:58,939 –&gt; 00:03:04,939<br>So the outline for going forward, we’ve already discussed what relational databases are.</p>
<p>56<br>00:03:04,939 –&gt; 00:03:09,859<br>But the first four topics here is storage, execution, concurrency, go to recovery.</p>
<p>57<br>00:03:09,860 –&gt; 00:03:18,300<br>These are the aspects you would need to have to build a full-featured, safe, reliable database</p>
<p>58<br>00:03:18,300 –&gt; 00:03:19,780<br>management system.</p>
<p>59<br>00:03:19,780 –&gt; 00:03:24,700<br>And we’ll assume it’s going to run on a single node, because it makes our life easier.</p>
<p>60<br>00:03:24,700 –&gt; 00:03:26,580<br>Don’t go to distribute until you have to.</p>
<p>61<br>00:03:26,580 –&gt; 00:03:31,100<br>And then once we understand what a single node database system looks like, we’ll then discuss</p>
<p>62<br>00:03:31,100 –&gt; 00:03:33,860<br>how to expand this and do distributed databases.</p>
<p>63<br>00:03:33,860 –&gt; 00:03:37,420<br>And at the end of the semester, we’ll talk a little bit also to about how what other additional</p>
<p>64<br>00:03:37,420 –&gt; 00:03:39,820<br>features and optimizations we can apply.</p>
<p>65<br>00:03:39,819 –&gt; 00:03:44,819<br>Which then will be a segue into the advanced class if you want to take that in the spring.</p>
<p>66<br>00:03:44,819 –&gt; 00:03:48,859<br>So the way to think about a database management system and the way the course is laid out</p>
<p>67<br>00:03:48,859 –&gt; 00:03:51,340<br>is a bunch of layers.</p>
<p>68<br>00:03:51,340 –&gt; 00:03:54,019<br>And the different layers are going to provide different functionality to capabilities</p>
<p>69<br>00:03:54,019 –&gt; 00:03:56,060<br>for the database system.</p>
<p>70<br>00:03:56,060 –&gt; 00:04:00,419<br>And they’re going to expose an API to whatever the layer is above it.</p>
<p>71<br>00:04:00,419 –&gt; 00:04:04,740<br>And the topics we’ve discussed again, basically how to construct those layers, put them all</p>
<p>72<br>00:04:04,740 –&gt; 00:04:07,939<br>together, and have a full-featured database management system.</p>
<p>73<br>00:04:07,939 –&gt; 00:04:12,699<br>So the way to think about it is that the most simple view point would be the application</p>
<p>74<br>00:04:12,699 –&gt; 00:04:15,939<br>comes along and they’re going to issue a SQL query.</p>
<p>75<br>00:04:15,939 –&gt; 00:04:18,300<br>And that’s going to first show up and get parsed.</p>
<p>76<br>00:04:18,300 –&gt; 00:04:20,300<br>The string of text of the SQL query is parsed.</p>
<p>77<br>00:04:20,300 –&gt; 00:04:23,259<br>We’re going to run through the query optimizer.</p>
<p>78<br>00:04:23,259 –&gt; 00:04:25,860<br>Below that, then we’ll start executing whatever the query plan is.</p>
<p>79<br>00:04:25,860 –&gt; 00:04:31,980<br>The B access methods to actually talk to the tables or indexes or whatever trying to access.</p>
<p>80<br>00:04:31,980 –&gt; 00:04:35,699<br>There’ll be a buffable manager to manage the memory for our database system.</p>
<p>81<br>00:04:35,699 –&gt; 00:04:39,500<br>And then at the lowest level, it’ll be a disk manager that’ll be responsible for reading</p>
<p>82<br>00:04:39,500 –&gt; 00:04:42,379<br>writing data to disk.</p>
<p>83<br>00:04:42,379 –&gt; 00:04:47,300<br>And so today’s class, we’re going to start getting the semester, return to the bottom,</p>
<p>84<br>00:04:47,300 –&gt; 00:04:49,139<br>and then work our way up.</p>
<p>85<br>00:04:49,139 –&gt; 00:04:52,379<br>When we get to something like a current general recovery, that’s going to permeate throughout</p>
<p>86<br>00:04:52,379 –&gt; 00:04:53,379<br>the entire system.</p>
<p>87<br>00:04:53,379 –&gt; 00:04:55,699<br>So we’re going to have to come back and revisit all these things.</p>
<p>88<br>00:04:55,699 –&gt; 00:04:59,939<br>Like, when we’re running transactions, we need to know what’s on disk.</p>
<p>89<br>00:04:59,939 –&gt; 00:05:05,379<br>We need to know what we’re accessing, how we’re accessing it, what queries we’re executing.</p>
<p>90<br>00:05:05,379 –&gt; 00:05:09,180<br>So the storage execution will get us through the entire stack.</p>
<p>91<br>00:05:09,180 –&gt; 00:05:11,939<br>And then we’ll come back and touch it all over again.</p>
<p>92<br>00:05:11,939 –&gt; 00:05:12,939<br>That sounds weird.</p>
<p>93<br>00:05:12,939 –&gt; 00:05:17,180<br>We’ll look at it all over again when we talk about concurrent general recovery.</p>
<p>94<br>00:05:17,180 –&gt; 00:05:18,939<br>And it’s saying we’re going to distribute a database.</p>
<p>95<br>00:05:18,939 –&gt; 00:05:23,980<br>We have to know about all these things in order to build a full reliable, safe, distributed</p>
<p>96<br>00:05:23,980 –&gt; 00:05:24,980<br>database system.</p>
<p>97<br>00:05:24,980 –&gt; 00:05:25,980<br>Okay?</p>
<p>98<br>00:05:25,980 –&gt; 00:05:28,939<br>All right.</p>
<p>99<br>00:05:28,939 –&gt; 00:05:34,180<br>So for the system, we’re going to discuss the methods we’re going to discuss this semester.</p>
<p>100<br>00:05:34,180 –&gt; 00:05:37,780<br>We’re going to assume that the architecture of what we’re trying to build, again, think</p>
<p>101<br>00:05:37,780 –&gt; 00:05:40,620<br>it conceptually, we’re going to construct in our minds a daily, daily system.</p>
<p>102<br>00:05:40,620 –&gt; 00:05:42,500<br>And bus hub is one implementation of this.</p>
<p>103<br>00:05:42,500 –&gt; 00:05:46,060<br>We’re going to assume we’re building what is called a disk-based database system, or a</p>
<p>104<br>00:05:46,060 –&gt; 00:05:48,699<br>disk-oriented architecture.</p>
<p>105<br>00:05:48,699 –&gt; 00:05:52,740<br>And this is where the database minimum system itself is going to assume that the primary</p>
<p>106<br>00:05:52,740 –&gt; 00:05:56,899<br>storage location of the database is going to be on some non-volatile disk.</p>
<p>107<br>00:05:56,899 –&gt; 00:06:00,340<br>It could be an SSD, a spending disk hard drive.</p>
<p>108<br>00:06:00,340 –&gt; 00:06:02,220<br>If you’re running in the cloud, it could be S3.</p>
<p>109<br>00:06:02,220 –&gt; 00:06:06,100<br>But we’re assuming that it’s going to be disk-based.</p>
<p>110<br>00:06:06,100 –&gt; 00:06:09,860<br>And all the things we’re going to build in our database-minute system are really designed</p>
<p>111<br>00:06:09,860 –&gt; 00:06:17,980<br>to now coordinate or orchestrate the movement of data back and forth from disk into memory.</p>
<p>112<br>00:06:17,980 –&gt; 00:06:19,980<br>This should not be news for anyone.</p>
<p>113<br>00:06:19,980 –&gt; 00:06:24,620<br>This is the classic, bond-normen architecture where the data is at rest on disk.</p>
<p>114<br>00:06:24,620 –&gt; 00:06:26,940<br>We can’t operate it unless we bring it into memory.</p>
<p>115<br>00:06:26,940 –&gt; 00:06:29,620<br>And then the CPU can do whatever it needs to.</p>
<p>116<br>00:06:29,620 –&gt; 00:06:33,220<br>And this is the overall theme of what we’re trying to build.</p>
<p>117<br>00:06:33,220 –&gt; 00:06:35,220<br>And this is obviously going to be super hard.</p>
<p>118<br>00:06:35,220 –&gt; 00:06:38,939<br>And if you’re an application developer, you don’t want to be doing this yourself in your</p>
<p>119<br>00:06:38,939 –&gt; 00:06:40,620<br>application code.</p>
<p>120<br>00:06:40,620 –&gt; 00:06:44,379<br>You want a database system that knows how to do this reliably and safely and correctly</p>
<p>121<br>00:06:44,379 –&gt; 00:06:49,459<br>and efficiently to do it for you.</p>
<p>122<br>00:06:49,459 –&gt; 00:06:54,660<br>So the way to think about what storage looks like from our perspective as a database system</p>
<p>123<br>00:06:54,660 –&gt; 00:06:56,259<br>is in terms of this hierarchy.</p>
<p>124<br>00:06:56,259 –&gt; 00:06:59,819<br>You might have seen this in other classes or other textbooks.</p>
<p>125<br>00:06:59,819 –&gt; 00:07:06,019<br>And the way to think about this is that going from the bottom to the top, the storage devices</p>
<p>126<br>00:07:06,019 –&gt; 00:07:10,699<br>are going to get faster, but smaller and more expensive.</p>
<p>127<br>00:07:10,699 –&gt; 00:07:14,339<br>So at the bottom layer here, you have something like network storage.</p>
<p>128<br>00:07:14,339 –&gt; 00:07:16,819<br>This would be like EBS or S3.</p>
<p>129<br>00:07:16,819 –&gt; 00:07:19,300<br>I think in the textbook, there’s a layer below this.</p>
<p>130<br>00:07:19,300 –&gt; 00:07:24,339<br>I think we have tape drives, but nobody runs data systems all those anymore.</p>
<p>131<br>00:07:24,339 –&gt; 00:07:28,339<br>But as you go up after network storage and you have a locally attached spinning disk</p>
<p>132<br>00:07:28,339 –&gt; 00:07:31,060<br>hard drive, and then you have maybe like an SSD.</p>
<p>133<br>00:07:31,060 –&gt; 00:07:35,699<br>And then after that, you have DRAM and CPU cashes and then now CPU registers.</p>
<p>134<br>00:07:35,699 –&gt; 00:07:37,539<br>CPU registers are super fast.</p>
<p>135<br>00:07:37,539 –&gt; 00:07:42,779<br>It’s the fastest kind of storage you can have, but we’re talking you have maybe 32 registers</p>
<p>136<br>00:07:42,779 –&gt; 00:07:43,779<br>on your CPU.</p>
<p>137<br>00:07:43,779 –&gt; 00:07:46,219<br>And each one’s going to be 64 bits.</p>
<p>138<br>00:07:46,219 –&gt; 00:07:50,299<br>You can’t store a lot of space in there, store a lot of things in there.</p>
<p>139<br>00:07:50,299 –&gt; 00:07:53,019<br>But they’re going to be super fast.</p>
<p>140<br>00:07:53,019 –&gt; 00:07:57,539<br>So from our perspective in this semester, the only thing we really care about is this division</p>
<p>141<br>00:07:57,539 –&gt; 00:07:59,139<br>line here.</p>
<p>142<br>00:07:59,139 –&gt; 00:08:01,299<br>And that’s between volatile and non-volatile storage.</p>
<p>143<br>00:08:01,299 –&gt; 00:08:03,500<br>Obviously, what does volatile mean?</p>
<p>144<br>00:08:03,500 –&gt; 00:08:06,620<br>We have volatile storage.</p>
<p>145<br>00:08:06,620 –&gt; 00:08:07,620<br>What’s that?</p>
<p>146<br>00:08:07,620 –&gt; 00:08:11,419<br>Yeah, it says data’s going when you, when you’ve power is going on.</p>
<p>147<br>00:08:11,419 –&gt; 00:08:15,620<br>You pull the plug on your DRAM or your CPU registers, like everything gets wiped out.</p>
<p>148<br>00:08:15,620 –&gt; 00:08:18,259<br>When you boot the system back up, nothing’s still there.</p>
<p>149<br>00:08:18,259 –&gt; 00:08:23,379<br>And volatile basically means that you write data to the device and assuming that you make</p>
<p>150<br>00:08:23,379 –&gt; 00:08:28,339<br>the right calls to tell it to get flushed or you get back an announcement, we’ll cover</p>
<p>151<br>00:08:28,339 –&gt; 00:08:29,339<br>that later.</p>
<p>152<br>00:08:29,339 –&gt; 00:08:32,580<br>Then we assume that data is going to be persistent.</p>
<p>153<br>00:08:32,580 –&gt; 00:08:37,100<br>And that no matter if we restart the system, pull the power, take the machine out, put it</p>
<p>154<br>00:08:37,100 –&gt; 00:08:40,659<br>into another location, whatever, when we come back that our data will be there.</p>
<p>155<br>00:08:40,659 –&gt; 00:08:43,620<br>Of course, database systems, we don’t trust the hardware.</p>
<p>156<br>00:08:43,620 –&gt; 00:08:44,620<br>We don’t trust the OS too.</p>
<p>157<br>00:08:44,620 –&gt; 00:08:45,620<br>We’ll get that in a second.</p>
<p>158<br>00:08:45,620 –&gt; 00:08:46,620<br>We don’t trust any of the ***.</p>
<p>159<br>00:08:46,620 –&gt; 00:08:50,259<br>We’re going to do much extra stuff to make sure that if we write stuff, maybe we write</p>
<p>160<br>00:08:50,259 –&gt; 00:08:52,700<br>to multiple locations or we write a backup for it, right?</p>
<p>161<br>00:08:52,700 –&gt; 00:08:56,820<br>The bunch of things we’ll do to make sure that we, we truly get non-volatile storage.</p>
<p>162<br>00:08:56,820 –&gt; 00:09:02,539<br>But from the design of the architecture itself, we’ll assume that it’s, you know, it’s</p>
<p>163<br>00:09:02,539 –&gt; 00:09:05,379<br>volatile versus non-volatile.</p>
<p>164<br>00:09:05,379 –&gt; 00:09:09,139<br>Another key difference we’re going to see between volatile and non-volatile is how we can</p>
<p>165<br>00:09:09,139 –&gt; 00:09:10,899<br>access the data.</p>
<p>166<br>00:09:10,899 –&gt; 00:09:14,980<br>So non-volatile storage will be considered to be bite addressable.</p>
<p>167<br>00:09:14,980 –&gt; 00:09:15,980<br>Because that means.</p>
<p>168<br>00:09:15,980 –&gt; 00:09:19,980<br>It’s creating each individual bite.</p>
<p>169<br>00:09:19,980 –&gt; 00:09:22,820<br>It says you can query each individual bite, correct.</p>
<p>170<br>00:09:22,820 –&gt; 00:09:23,820<br>Yeah.</p>
<p>171<br>00:09:23,820 –&gt; 00:09:26,019<br>So let’s say I have a 1 megabyte file.</p>
<p>172<br>00:09:26,019 –&gt; 00:09:32,899<br>If I want the, I want to get 64 bits at some random offset, I can do that in memory.</p>
<p>173<br>00:09:32,899 –&gt; 00:09:33,899<br>There’s cache lines.</p>
<p>174<br>00:09:33,899 –&gt; 00:09:36,820<br>It’s not exactly true, but for now we can ignore that.</p>
<p>175<br>00:09:36,820 –&gt; 00:09:41,700<br>In a non-volatile storage, like thinking of it as SSD, you can’t go get exactly 64 bits</p>
<p>176<br>00:09:41,700 –&gt; 00:09:43,379<br>in a 1 megabyte file.</p>
<p>177<br>00:09:43,379 –&gt; 00:09:47,539<br>So that way we get the block that that, that 64 bits is in, bring that in a memory and</p>
<p>178<br>00:09:47,539 –&gt; 00:09:49,139<br>then do whatever you need on it.</p>
<p>179<br>00:09:49,139 –&gt; 00:09:50,139<br>Right?</p>
<p>180<br>00:09:50,139 –&gt; 00:09:54,980<br>So you can only address blocks, not individual, individual bites.</p>
<p>181<br>00:09:54,980 –&gt; 00:10:00,059<br>And so the reason why this matters is that there’ll be certain algorithms will choose in</p>
<p>182<br>00:10:00,059 –&gt; 00:10:05,100<br>the design of our system where we know we’re fetching blocks instead of single bites or</p>
<p>183<br>00:10:05,100 –&gt; 00:10:06,220<br>bite offsets.</p>
<p>184<br>00:10:06,220 –&gt; 00:10:10,580<br>And therefore we’ll choose maybe an algorithm that is better for block-adjustable data.</p>
<p>185<br>00:10:10,580 –&gt; 00:10:16,240<br>Actually this we’re also going to choose potentially algorithms that are, that are maximized</p>
<p>186<br>00:10:16,240 –&gt; 00:10:18,139<br>amount of sequential access of our data.</p>
<p>187<br>00:10:18,139 –&gt; 00:10:21,980<br>So what do I mean by this?</p>
<p>188<br>00:10:21,980 –&gt; 00:10:25,220<br>Yes.</p>
<p>189<br>00:10:25,220 –&gt; 00:10:27,980<br>Accessing adjacent blocks by cheaper.</p>
<p>190<br>00:10:27,980 –&gt; 00:10:29,220<br>So we want to do some questions.</p>
<p>191<br>00:10:29,220 –&gt; 00:10:30,220<br>Right.</p>
<p>192<br>00:10:30,220 –&gt; 00:10:32,060<br>So he said accessing adjacent blocks are cheaper.</p>
<p>193<br>00:10:32,060 –&gt; 00:10:33,820<br>So we want to do that as much as possible.</p>
<p>194<br>00:10:33,820 –&gt; 00:10:38,420<br>So again, say I want to get, I want to get 10 megabytes.</p>
<p>195<br>00:10:38,419 –&gt; 00:10:42,179<br>And I have, and they’re broken onto one megabyte blocks.</p>
<p>196<br>00:10:42,179 –&gt; 00:10:45,339<br>If those one megabyte blocks are scattered in different locations, then I got to, it’s</p>
<p>197<br>00:10:45,339 –&gt; 00:10:46,339<br>called random access.</p>
<p>198<br>00:10:46,339 –&gt; 00:10:49,019<br>Go jump to those different locations to get that data.</p>
<p>199<br>00:10:49,019 –&gt; 00:10:53,500<br>Or alternatively if it’s all aligned together and contiguous, then in theory I can do one</p>
<p>200<br>00:10:53,500 –&gt; 00:10:57,979<br>fetch command, not saying what the device is, but it’s one fetch command to go get those</p>
<p>201<br>00:10:57,979 –&gt; 00:11:00,179<br>10 meg, one megabyte blocks.</p>
<p>202<br>00:11:00,179 –&gt; 00:11:02,339<br>And that’s going to be way more efficient.</p>
<p>203<br>00:11:02,339 –&gt; 00:11:03,339<br>Right?</p>
<p>204<br>00:11:03,339 –&gt; 00:11:07,779<br>If you just take it like on a website or you’re downloading some of the internet, if I can go</p>
<p>205<br>00:11:07,779 –&gt; 00:11:10,539<br>open up a single connection and get all the data I need rather than opening up different</p>
<p>206<br>00:11:10,539 –&gt; 00:11:13,779<br>connections, the one fetch is going to be faster.</p>
<p>207<br>00:11:13,779 –&gt; 00:11:16,819<br>At the hardware level, think of like a spinning disk hard drive.</p>
<p>208<br>00:11:16,819 –&gt; 00:11:18,379<br>And laptops don’t come with these anymore.</p>
<p>209<br>00:11:18,379 –&gt; 00:11:20,339<br>They still exist in the enterprise world.</p>
<p>210<br>00:11:20,339 –&gt; 00:11:25,059<br>But there’s a physical arm that’s spinning around in a platter like a vinyl record, right?</p>
<p>211<br>00:11:25,059 –&gt; 00:11:26,419<br>Like that old people have.</p>
<p>212<br>00:11:26,419 –&gt; 00:11:29,939<br>And so if you have to plot, move the arm, they get data.</p>
<p>213<br>00:11:29,939 –&gt; 00:11:32,059<br>Moving that arm is, it’s a physical thing.</p>
<p>214<br>00:11:32,059 –&gt; 00:11:33,059<br>It’s expensive.</p>
<p>215<br>00:11:33,059 –&gt; 00:11:36,220<br>It’s actually moving something through, through helium.</p>
<p>216<br>00:11:36,540 –&gt; 00:11:39,620<br>You’re moving something, moving the arm on the platter.</p>
<p>217<br>00:11:39,620 –&gt; 00:11:44,300<br>So if I have to, if I can just move the arm once and then read a bunch of data without</p>
<p>218<br>00:11:44,300 –&gt; 00:11:46,100<br>moving it again, that’s the quantum access.</p>
<p>219<br>00:11:46,100 –&gt; 00:11:47,100<br>That’s going to be faster.</p>
<p>220<br>00:11:47,100 –&gt; 00:11:49,820<br>If I had to pick the arm up and move it over and over again, then that’s going to be much</p>
<p>221<br>00:11:49,820 –&gt; 00:11:50,820<br>slower.</p>
<p>222<br>00:11:50,820 –&gt; 00:11:55,779<br>And again, we’ll see this when we, this come up also with the execution algorithms that</p>
<p>223<br>00:11:55,779 –&gt; 00:12:00,340<br>will be certain algorithms that will choose that will maximize quantum access.</p>
<p>224<br>00:12:00,340 –&gt; 00:12:02,220<br>And we’ll choose those over something that’s more random access.</p>
<p>225<br>00:12:02,220 –&gt; 00:12:06,180<br>And this is different than maybe how you think about algorithms in interclasses because</p>
<p>226<br>00:12:06,739 –&gt; 00:12:10,539<br>in that world, they assume everything’s always going to be, the memory access is always the</p>
<p>227<br>00:12:10,539 –&gt; 00:12:12,219<br>same.</p>
<p>228<br>00:12:12,219 –&gt; 00:12:13,579<br>In our world, we’re dealing with real hardware.</p>
<p>229<br>00:12:13,579 –&gt; 00:12:14,939<br>So we can’t make that assumption.</p>
<p>230<br>00:12:17,419 –&gt; 00:12:22,620<br>So let me tell you what, so the way we think about this is that I’ll use the term memory</p>
<p>231<br>00:12:22,620 –&gt; 00:12:23,620<br>in this class.</p>
<p>232<br>00:12:23,620 –&gt; 00:12:26,859<br>And I’ll just mean here, I’ll just mean DRAM.</p>
<p>233<br>00:12:26,859 –&gt; 00:12:30,019<br>And when I say disk, I’m going to mean anything below that, right?</p>
<p>234<br>00:12:30,019 –&gt; 00:12:34,219<br>So an SSD, it’s spending this hard drive or a network cloud storage.</p>
<p>235<br>00:12:35,220 –&gt; 00:12:40,259<br>The ones up here, the CPU registers, we won’t discuss these in this class.</p>
<p>236<br>00:12:40,259 –&gt; 00:12:43,940<br>In the advanced class, we’ll talk about different algorithms of the methods to kind of maximize</p>
<p>237<br>00:12:43,940 –&gt; 00:12:49,500<br>the amount of processing being due of data in CPU registers or like L3, L2 caches.</p>
<p>238<br>00:12:49,500 –&gt; 00:12:51,060<br>And in that world, you can make a huge difference.</p>
<p>239<br>00:12:53,060 –&gt; 00:12:56,779<br>It’s also a word noting that are some sort of merging hardware devices or hardware that’s</p>
<p>240<br>00:12:56,779 –&gt; 00:12:59,820<br>available today that spans different layers.</p>
<p>241<br>00:13:00,820 –&gt; 00:13:05,060<br>So you can get sort of fast network storage or disaggregated storage or disaggregated</p>
<p>242<br>00:13:05,060 –&gt; 00:13:11,420<br>memory where this looks like it potentially could be bite addressable, but you’re going</p>
<p>243<br>00:13:11,420 –&gt; 00:13:15,300<br>over a physical network, so it’s a little bit slower.</p>
<p>244<br>00:13:15,300 –&gt; 00:13:18,460<br>So it sort of straddles in between here.</p>
<p>245<br>00:13:18,460 –&gt; 00:13:22,860<br>And then there was something called persistent memory that people have been dreaming about</p>
<p>246<br>00:13:22,860 –&gt; 00:13:28,020<br>for a long time that would have sort of the best benefit of, or have they bite address</p>
<p>247<br>00:13:28,019 –&gt; 00:13:32,419<br>ability of DRAM, but also the persistence of NSSD.</p>
<p>248<br>00:13:32,419 –&gt; 00:13:38,059<br>And we’d actually sit in the dim slot so you could write to it as if it was a memory,</p>
<p>249<br>00:13:38,059 –&gt; 00:13:40,379<br>but if you pull the plug, everything gets retained.</p>
<p>250<br>00:13:40,379 –&gt; 00:13:47,819<br>And this is something when I first started CMU 10 years ago, we were spending a lot of</p>
<p>251<br>00:13:47,819 –&gt; 00:13:48,819<br>time researching this.</p>
<p>252<br>00:13:48,819 –&gt; 00:13:53,340<br>This is something we was very interested in because if we had this persistent memory, basically</p>
<p>253<br>00:13:53,340 –&gt; 00:13:57,940<br>all the stuff that I’m going to talk about in two weeks, actually Project 1 in this class</p>
<p>254<br>00:13:57,940 –&gt; 00:13:59,940<br>basically goes away, right?</p>
<p>255<br>00:13:59,940 –&gt; 00:14:02,620<br>Because I don’t need to worry about moving things in and out of disk.</p>
<p>256<br>00:14:02,620 –&gt; 00:14:04,420<br>Everything, my memory’s persistent.</p>
<p>257<br>00:14:04,420 –&gt; 00:14:09,740<br>There may be no, if anybody actually should have made this persistent, non-volta memory.</p>
<p>258<br>00:14:09,740 –&gt; 00:14:10,740<br>Yes.</p>
<p>259<br>00:14:10,740 –&gt; 00:14:13,899<br>I guess you could try to look at an SSD or hardware and something attached to like Intel,</p>
<p>260<br>00:14:13,899 –&gt; 00:14:14,899<br>off-camera, something?</p>
<p>261<br>00:14:14,899 –&gt; 00:14:15,899<br>Boom, there you go.</p>
<p>262<br>00:14:15,899 –&gt; 00:14:17,900<br>You look at the SSD and you look at the SSD.</p>
<p>263<br>00:14:17,900 –&gt; 00:14:21,740<br>Yes, so he said you could try this with an SSD, yes, people do that, but that’s not</p>
<p>264<br>00:14:21,740 –&gt; 00:14:23,259<br>true persistent memory.</p>
<p>265<br>00:14:23,259 –&gt; 00:14:24,940<br>Or then you said Intel Optane.</p>
<p>266<br>00:14:24,940 –&gt; 00:14:26,460<br>Intel Optane actually was an SSD.</p>
<p>267<br>00:14:26,460 –&gt; 00:14:27,860<br>It was actually phase change memory.</p>
<p>268<br>00:14:27,860 –&gt; 00:14:32,220<br>It was actually was a physical device that could do, it was persistent memory, right?</p>
<p>269<br>00:14:32,220 –&gt; 00:14:35,539<br>HP had memory, there was IBM, rumor had something, right?</p>
<p>270<br>00:14:35,539 –&gt; 00:14:38,659<br>Intel is the only one that actually made this.</p>
<p>271<br>00:14:38,659 –&gt; 00:14:40,620<br>Who here has heard of Intel Optane?</p>
<p>272<br>00:14:40,620 –&gt; 00:14:41,860<br>Well he obviously yes.</p>
<p>273<br>00:14:41,860 –&gt; 00:14:43,659<br>Very, very few.</p>
<p>274<br>00:14:43,659 –&gt; 00:14:45,779<br>It’s already dead.</p>
<p>275<br>00:14:45,779 –&gt; 00:14:48,659<br>So Intel killed it last year.</p>
<p>276<br>00:14:48,659 –&gt; 00:14:52,899<br>Hopefully Intel hired a new CEO and they cut a bunch of divisions and unfortunately they</p>
<p>277<br>00:14:52,899 –&gt; 00:14:53,899<br>cut this.</p>
<p>278<br>00:14:53,899 –&gt; 00:14:58,419<br>And this sucks because to me this would have been a game changer but Intel couldn’t make</p>
<p>279<br>00:14:58,419 –&gt; 00:14:59,419<br>any money off of it.</p>
<p>280<br>00:14:59,419 –&gt; 00:15:03,860<br>And what sucks also too is now no one’s going to try this for another decade because if</p>
<p>281<br>00:15:03,860 –&gt; 00:15:07,899<br>Intel could make money off of it, who will?</p>
<p>282<br>00:15:07,899 –&gt; 00:15:10,740<br>But there was a various project at different database companies.</p>
<p>283<br>00:15:10,740 –&gt; 00:15:15,220<br>They were trying to build database systems just around persistent memory.</p>
<p>284<br>00:15:15,220 –&gt; 00:15:17,740<br>Because again a bunch of the stuff we’re going to have to do with moving data back and forth</p>
<p>285<br>00:15:17,740 –&gt; 00:15:21,300<br>between disk and memory goes away with this.</p>
<p>286<br>00:15:21,300 –&gt; 00:15:23,379<br>So that’s a shame.</p>
<p>287<br>00:15:23,379 –&gt; 00:15:25,180<br>Okay.</p>
<p>288<br>00:15:25,180 –&gt; 00:15:28,899<br>So the reason why we have to be cognizant of what the storage is going to look like is because</p>
<p>289<br>00:15:28,899 –&gt; 00:15:33,300<br>the performance characteristics as I said, between these different devices are going to be</p>
<p>290<br>00:15:33,300 –&gt; 00:15:35,620<br>dramatically different.</p>
<p>291<br>00:15:35,620 –&gt; 00:15:40,899<br>And we’re going to try to maximize the amount of work we can do for data when it’s in memory.</p>
<p>292<br>00:15:40,899 –&gt; 00:15:44,660<br>When we bring something off a disk into memory, we want to do as much work as we can on</p>
<p>293<br>00:15:45,139 –&gt; 00:15:49,100<br>that data before we throw it away and bring something else into memory.</p>
<p>294<br>00:15:49,100 –&gt; 00:15:52,379<br>In an ideal world, our database would fit entirely in memory.</p>
<p>295<br>00:15:52,379 –&gt; 00:15:56,779<br>Even then you start the right out the disk but in some cases that’s not always possible.</p>
<p>296<br>00:15:56,779 –&gt; 00:16:03,579<br>So the way to take it is at the CPU level, a cache miss is going to basically one nanosecond.</p>
<p>297<br>00:16:03,579 –&gt; 00:16:09,399<br>It’s getting out of DRAMs, 100 nanoseconds, and SSD is about 16 microseconds or 16,000</p>
<p>298<br>00:16:09,399 –&gt; 00:16:10,399<br>nanoseconds.</p>
<p>299<br>00:16:10,399 –&gt; 00:16:11,399<br>That’s actually pretty good.</p>
<p>300<br>00:16:11,399 –&gt; 00:16:14,059<br>Spitting this hard drive, two million nanoseconds.</p>
<p>301<br>00:16:14,059 –&gt; 00:16:18,459<br>And then EBS can fluctuate, sometimes you get 50 milliseconds, sometimes you get 500 milliseconds,</p>
<p>302<br>00:16:18,459 –&gt; 00:16:20,379<br>depends on how hot the data is.</p>
<p>303<br>00:16:20,379 –&gt; 00:16:23,859<br>And then tape archives, again, this is glacial.</p>
<p>304<br>00:16:23,859 –&gt; 00:16:26,099<br>You don’t want to build any system off of this.</p>
<p>305<br>00:16:26,099 –&gt; 00:16:29,899<br>So this data comes from, this particular data here comes out.</p>
<p>306<br>00:16:29,899 –&gt; 00:16:31,619<br>There’s a Berkeley website and a link there.</p>
<p>307<br>00:16:31,619 –&gt; 00:16:35,099<br>You sort of show you the trends of the hardware performance, the speeds of these devices</p>
<p>308<br>00:16:35,099 –&gt; 00:16:36,299<br>over time.</p>
<p>309<br>00:16:36,299 –&gt; 00:16:40,699<br>This table has been attributed to Jeff Dean from the early 2000s.</p>
<p>310<br>00:16:40,700 –&gt; 00:16:44,620<br>I think it might predate him before that.</p>
<p>311<br>00:16:44,620 –&gt; 00:16:48,140<br>So as humans, it’s hard for us to reason about nanoseconds, right?</p>
<p>312<br>00:16:48,140 –&gt; 00:16:49,660<br>Like one nanosecond, what does that actually mean?</p>
<p>313<br>00:16:49,660 –&gt; 00:16:53,259<br>Or two million nanoseconds, is that a long time?</p>
<p>314<br>00:16:53,259 –&gt; 00:16:58,379<br>And so there’s a simple trick you can do to realize how bad this actually is or how much</p>
<p>315<br>00:16:58,379 –&gt; 00:17:04,380<br>slower things actually get if you just change one nanosecond to one second.</p>
<p>316<br>00:17:04,380 –&gt; 00:17:09,220<br>So this is a trick that, or this is something that Jim Gray used to do in the 90s.</p>
<p>317<br>00:17:09,220 –&gt; 00:17:14,299<br>If you just change one nanosecond to one second, now you see how massively slower these</p>
<p>318<br>00:17:14,299 –&gt; 00:17:15,299<br>other devices are.</p>
<p>319<br>00:17:15,299 –&gt; 00:17:19,420<br>You see why you want to keep everything in memory as much as possible.</p>
<p>320<br>00:17:19,420 –&gt; 00:17:25,420<br>And so if I have to read a page from a book and say, doing an L1 cache miss would be</p>
<p>321<br>00:17:25,420 –&gt; 00:17:28,180<br>me walking at this table and looking in the book.</p>
<p>322<br>00:17:28,180 –&gt; 00:17:31,700<br>Or if I had to read from an SSD or DRAM, maybe it’s walking over to the library and then</p>
<p>323<br>00:17:31,700 –&gt; 00:17:33,700<br>finding the book.</p>
<p>324<br>00:17:33,700 –&gt; 00:17:35,900<br>But if I had to read from a tape archive, it’s 31 years.</p>
<p>325<br>00:17:35,900 –&gt; 00:17:40,100<br>And that’s equivalent to flying to Pluto, the planet, and then reading one book.</p>
<p>326<br>00:17:40,100 –&gt; 00:17:43,100<br>So we want to avoid all of this as much as possible.</p>
<p>327<br>00:17:43,100 –&gt; 00:17:45,540<br>Okay?</p>
<p>328<br>00:17:45,540 –&gt; 00:17:48,580<br>So this Quential versus Randomly, we’ve recurred this, we discussed this already.</p>
<p>329<br>00:17:48,580 –&gt; 00:17:52,259<br>But again, this is going to be a reoccurring theme throughout the entire semester where,</p>
<p>330<br>00:17:52,259 –&gt; 00:17:56,820<br>again, the database system is going to prefer Squential access over random access for both</p>
<p>331<br>00:17:56,820 –&gt; 00:17:57,820<br>reads and writes.</p>
<p>332<br>00:17:57,820 –&gt; 00:18:00,900<br>When spending this hard drive, again, it makes a huge difference.</p>
<p>333<br>00:18:00,900 –&gt; 00:18:05,019<br>But even on SSD, because of the way they actually work underneath the covers with the ASICs</p>
<p>334<br>00:18:05,019 –&gt; 00:18:10,460<br>and then doing compaction and so forth, you’re better off doing batch reads and writes sequentially</p>
<p>335<br>00:18:10,460 –&gt; 00:18:13,259<br>as much as possible.</p>
<p>336<br>00:18:13,259 –&gt; 00:18:14,259<br>Right?</p>
<p>337<br>00:18:14,259 –&gt; 00:18:15,259<br>Right.</p>
<p>338<br>00:18:15,259 –&gt; 00:18:19,579<br>So the other system design goals we’re going to have and how we choose how we want to build</p>
<p>339<br>00:18:19,579 –&gt; 00:18:26,379<br>our system is that we want to give the illusion that we are operating with the database entirely</p>
<p>340<br>00:18:26,379 –&gt; 00:18:27,379<br>in memory.</p>
<p>341<br>00:18:27,379 –&gt; 00:18:31,940<br>Again, for most databases aren’t that big, most databases are less than 10 gigabytes.</p>
<p>342<br>00:18:31,940 –&gt; 00:18:32,940<br>Right?</p>
<p>343<br>00:18:33,900 –&gt; 00:18:38,779<br>But if a really massive database is like in the terabytes or gigabytes and terabytes and petabytes,</p>
<p>344<br>00:18:38,779 –&gt; 00:18:43,420<br>ideally you want to give the appearance that everything’s already in memory even though it</p>
<p>345<br>00:18:43,420 –&gt; 00:18:44,940<br>actually isn’t.</p>
<p>346<br>00:18:44,940 –&gt; 00:18:48,460<br>And there’s tricks we can do to hide the distals and so forth.</p>
<p>347<br>00:18:48,460 –&gt; 00:18:54,360<br>And then as since reading, writing disk is so expensive, we want to do a bunch of other</p>
<p>348<br>00:18:54,360 –&gt; 00:18:59,660<br>tricks in our design of our system to avoid prolonged stalls or having a system appear</p>
<p>349<br>00:18:59,660 –&gt; 00:19:01,779<br>unresponsive.</p>
<p>350<br>00:19:01,779 –&gt; 00:19:04,759<br>Because one that will frustrate the application or frustrate the user because they think</p>
<p>351<br>00:19:04,759 –&gt; 00:19:08,620<br>the system is stuck, but you’re really fetching things from disk.</p>
<p>352<br>00:19:08,620 –&gt; 00:19:12,300<br>But this also is going to cause other problems because if we’re holding a lock on something</p>
<p>353<br>00:19:12,300 –&gt; 00:19:15,779<br>and we stall because we have to get something from disk or write something from disk, that’s</p>
<p>354<br>00:19:15,779 –&gt; 00:19:19,620<br>going to slow down everybody else behind us and have a convoy effect.</p>
<p>355<br>00:19:19,620 –&gt; 00:19:21,420<br>So there’s a bunch of things.</p>
<p>356<br>00:19:21,420 –&gt; 00:19:24,259<br>For this reason we want to avoid this as much as possible.</p>
<p>357<br>00:19:24,259 –&gt; 00:19:28,500<br>And again, because random access is slower than a sweatshirt access, we want to maximize</p>
<p>358<br>00:19:28,500 –&gt; 00:19:31,859<br>much access.</p>
<p>359<br>00:19:31,859 –&gt; 00:19:35,500<br>So what does this all sound like?</p>
<p>360<br>00:19:35,500 –&gt; 00:19:39,740<br>Having the appearance that we have more memory than we actually do.</p>
<p>361<br>00:19:39,740 –&gt; 00:19:40,740<br>Virtual memory.</p>
<p>362<br>00:19:40,740 –&gt; 00:19:42,259<br>All right, so we’ll get this in a second.</p>
<p>363<br>00:19:42,259 –&gt; 00:19:45,099<br>I’ll explain why we don’t want to do virtual memory than the OS.</p>
<p>364<br>00:19:45,099 –&gt; 00:19:50,099<br>And why as a database system developer, engineer building the actual system, we always want</p>
<p>365<br>00:19:50,099 –&gt; 00:19:55,299<br>to do as much as we can ourselves and not rely on the OS to do anything.</p>
<p>366<br>00:19:55,299 –&gt; 00:19:56,299<br>So this is our diagram.</p>
<p>367<br>00:19:56,299 –&gt; 00:19:58,299<br>This is what we’re building.</p>
<p>368<br>00:19:58,299 –&gt; 00:20:02,259<br>So we have some database file or files plural.</p>
<p>369<br>00:20:02,259 –&gt; 00:20:03,259<br>It doesn’t matter.</p>
<p>370<br>00:20:03,259 –&gt; 00:20:05,099<br>We can discuss the differences.</p>
<p>371<br>00:20:05,099 –&gt; 00:20:09,500<br>We have some database file that’s on disk and we’re going to break it up into pages.</p>
<p>372<br>00:20:09,500 –&gt; 00:20:12,460<br>Now, describe what a page is in the second.</p>
<p>373<br>00:20:12,460 –&gt; 00:20:15,099<br>And there’ll be some directory that’s going to say, here’s what pages I have, here’s</p>
<p>374<br>00:20:15,099 –&gt; 00:20:17,980<br>where to find them at this offset and so forth.</p>
<p>375<br>00:20:17,980 –&gt; 00:20:23,740<br>And then there’ll be some buffer pool where of memory, the data system is allocated, basically</p>
<p>376<br>00:20:23,740 –&gt; 00:20:26,700<br>called malloc against the OS, got some memory.</p>
<p>377<br>00:20:26,700 –&gt; 00:20:31,779<br>And then we’re going to use that as the staging area where we bring pages in from disk.</p>
<p>378<br>00:20:31,779 –&gt; 00:20:35,779<br>So now if the execution engine, the thing that’s going to run our query, it comes along.</p>
<p>379<br>00:20:35,779 –&gt; 00:20:38,580<br>And it wants to get page number two.</p>
<p>380<br>00:20:38,580 –&gt; 00:20:42,940<br>We can ignore how it knows it wants page number two for now.</p>
<p>381<br>00:20:42,940 –&gt; 00:20:45,380<br>But it assumes that’s what it wants, it wants page number two.</p>
<p>382<br>00:20:45,380 –&gt; 00:20:47,980<br>So the very first thing we got to do is bring in the page directory because that’s going</p>
<p>383<br>00:20:47,980 –&gt; 00:20:52,259<br>to tell us where on disk the pages are.</p>
<p>384<br>00:20:52,259 –&gt; 00:20:58,019<br>And then it’ll make a call to the OS or whatever the device that’s storing the database file</p>
<p>385<br>00:20:58,019 –&gt; 00:21:00,500<br>and it’ll bring that page into memory.</p>
<p>386<br>00:21:00,500 –&gt; 00:21:06,059<br>And then now the buffer pool will give back the execution engine a pointer in memory,</p>
<p>387<br>00:21:06,059 –&gt; 00:21:11,700<br>a 64 bit pointer in memory, where this page exists.</p>
<p>388<br>00:21:11,700 –&gt; 00:21:14,660<br>And now it’s up to the execution engine or the access method, the operators to then</p>
<p>389<br>00:21:14,660 –&gt; 00:21:16,940<br>interpret what’s inside that page.</p>
<p>390<br>00:21:16,940 –&gt; 00:21:20,220<br>Because all that’s opaque to the rest of the system.</p>
<p>391<br>00:21:20,220 –&gt; 00:21:24,220<br>It’s not entirely true, but at this point they don’t really know.</p>
<p>392<br>00:21:24,220 –&gt; 00:21:27,980<br>And then let’s say once you do about the updates, it makes changes to whatever’s in page number</p>
<p>393<br>00:21:27,980 –&gt; 00:21:28,980<br>two.</p>
<p>394<br>00:21:28,980 –&gt; 00:21:32,220<br>I’m not saying whether it’s a two-blum, nothing, but it doesn’t matter.</p>
<p>395<br>00:21:32,220 –&gt; 00:21:35,980<br>And then now the data system is responsible for writing this back out to disk to make sure</p>
<p>396<br>00:21:35,980 –&gt; 00:21:39,220<br>that any changes are persistent.</p>
<p>397<br>00:21:39,220 –&gt; 00:21:43,259<br>So this is effectively where we’re going for the next three or four lectures.</p>
<p>398<br>00:21:43,259 –&gt; 00:21:45,579<br>This is the architecture we’re going to be building.</p>
<p>399<br>00:21:45,579 –&gt; 00:21:50,859<br>So we’ll discuss what pages look like in the next three lectures, three, four, and five.</p>
<p>400<br>00:21:50,859 –&gt; 00:21:57,460<br>We’ll discuss how to write things out the disk in six and how to manage memory in six.</p>
<p>401<br>00:21:57,460 –&gt; 00:22:01,819<br>And then we’ll discuss how to execute the queries up here in 12 and 13.</p>
<p>402<br>00:22:01,819 –&gt; 00:22:03,819<br>Okay?</p>
<p>403<br>00:22:03,819 –&gt; 00:22:08,179<br>So our focus really today is what are these things on disk?</p>
<p>404<br>00:22:08,179 –&gt; 00:22:09,899<br>Okay?</p>
<p>405<br>00:22:09,899 –&gt; 00:22:13,259<br>So I said before, what does this sound like?</p>
<p>406<br>00:22:13,259 –&gt; 00:22:14,419<br>Everyone said virtual memory.</p>
<p>407<br>00:22:14,820 –&gt; 00:22:19,140<br>And you say, okay, well, why do any of this, why take the next three lectures, talking about</p>
<p>408<br>00:22:19,140 –&gt; 00:22:23,860<br>what’s it, what’s, you need this lecture, why take the next two lectures after that,</p>
<p>409<br>00:22:23,860 –&gt; 00:22:28,259<br>talk about how to manage memory back on fourth from disk, when the OS can do that for us.</p>
<p>410<br>00:22:28,259 –&gt; 00:22:33,740<br>If anybody knows what’s the sys call you would use to use virtual memory in this way.</p>
<p>411<br>00:22:33,740 –&gt; 00:22:35,500<br>And that, beautiful, excellent.</p>
<p>412<br>00:22:35,500 –&gt; 00:22:37,019<br>Sensor memory map file.</p>
<p>413<br>00:22:37,019 –&gt; 00:22:38,820<br>So this is in the positive standard.</p>
<p>414<br>00:22:38,820 –&gt; 00:22:40,500<br>Windows has their own version of it.</p>
<p>415<br>00:22:40,500 –&gt; 00:22:45,339<br>But this allows you to take the contents of a file that’s on disk and you map it into</p>
<p>416<br>00:22:45,339 –&gt; 00:22:50,140<br>virtual memory in your process, in the address base of your process.</p>
<p>417<br>00:22:50,140 –&gt; 00:22:56,460<br>And then now that process can jump to any offset in that address base in memory.</p>
<p>418<br>00:22:56,460 –&gt; 00:23:00,460<br>And the OS is responsible for deciding, oh, is the thing you need in memory or not, if</p>
<p>419<br>00:23:00,460 –&gt; 00:23:04,700<br>not, then it goes and fetches the page you need and brings it in memory.</p>
<p>420<br>00:23:04,700 –&gt; 00:23:05,700<br>Right?</p>
<p>421<br>00:23:05,700 –&gt; 00:23:08,460<br>So the database doesn’t, it’s not doing any of the reason rights.</p>
<p>422<br>00:23:08,460 –&gt; 00:23:13,220<br>It just, an MAP opens the file and the OS does all the management of the data, moving the</p>
<p>423<br>00:23:13,220 –&gt; 00:23:14,660<br>data back and forth for us.</p>
<p>424<br>00:23:14,660 –&gt; 00:23:16,420<br>All right, so it looks like that.</p>
<p>425<br>00:23:16,420 –&gt; 00:23:19,779<br>So we have an R and disk file, we have a bunch of pages, right?</p>
<p>426<br>00:23:19,779 –&gt; 00:23:21,740<br>We call MAP to open it up.</p>
<p>427<br>00:23:21,740 –&gt; 00:23:25,019<br>And then we’ll have a concept of virtual memory and physical memory.</p>
<p>428<br>00:23:25,019 –&gt; 00:23:28,380<br>So virtual memory would be what I see in my process address base.</p>
<p>429<br>00:23:28,380 –&gt; 00:23:33,779<br>And again, at some starting location, I’ll get the, I’ll get the MAP file.</p>
<p>430<br>00:23:33,779 –&gt; 00:23:36,100<br>And then these virtual memory has to be backed by physical pages.</p>
<p>431<br>00:23:36,099 –&gt; 00:23:41,059<br>So as I touch a page, the OS has to go then put it into some space in physical memory</p>
<p>432<br>00:23:41,059 –&gt; 00:23:44,259<br>and then update the wiring for the virtual memory table.</p>
<p>433<br>00:23:44,259 –&gt; 00:23:45,259<br>All right?</p>
<p>434<br>00:23:45,259 –&gt; 00:23:48,339<br>So let’s say that my process wants to touch page one.</p>
<p>435<br>00:23:48,339 –&gt; 00:23:52,379<br>So we would have a page fault because the OS would recognize I don’t have page one in</p>
<p>436<br>00:23:52,379 –&gt; 00:23:53,379<br>physical memory.</p>
<p>437<br>00:23:53,379 –&gt; 00:23:57,379<br>It would go out the disk, fetch it for me, put it in, update virtual memory to now point</p>
<p>438<br>00:23:57,379 –&gt; 00:23:58,379<br>to it.</p>
<p>439<br>00:23:58,379 –&gt; 00:24:01,899<br>And then my process can touch it or do whatever once with it.</p>
<p>440<br>00:24:01,899 –&gt; 00:24:03,379<br>Same thing now if I want page three.</p>
<p>441<br>00:24:03,379 –&gt; 00:24:04,379<br>It’s not in there.</p>
<p>442<br>00:24:04,379 –&gt; 00:24:05,379<br>I get a page fault.</p>
<p>443<br>00:24:05,380 –&gt; 00:24:09,820<br>The OS blocks my process when I do the, when I access it, it goes fetch the page</p>
<p>444<br>00:24:09,820 –&gt; 00:24:15,460<br>and need from disk, updates the wiring and then my process can start running again.</p>
<p>445<br>00:24:15,460 –&gt; 00:24:17,900<br>My thread can start running again.</p>
<p>446<br>00:24:17,900 –&gt; 00:24:21,300<br>What happens when I, if I want to touch page two?</p>
<p>447<br>00:24:21,300 –&gt; 00:24:22,300<br>What’s that?</p>
<p>448<br>00:24:22,300 –&gt; 00:24:25,620<br>It’s you get rid of it, right?</p>
<p>449<br>00:24:25,620 –&gt; 00:24:28,940<br>But what happens while I’m getting rid of it?</p>
<p>450<br>00:24:28,940 –&gt; 00:24:30,340<br>My process stalls, right?</p>
<p>451<br>00:24:30,340 –&gt; 00:24:34,460<br>I go to, the OS is going to block me while it says, okay, well, I don’t have any more</p>
<p>452<br>00:24:34,460 –&gt; 00:24:35,460<br>physical memory.</p>
<p>453<br>00:24:35,460 –&gt; 00:24:38,539<br>Let me go out and figure out what do these, you know, page one or three, which one should</p>
<p>454<br>00:24:38,539 –&gt; 00:24:39,539<br>I throw away?</p>
<p>455<br>00:24:39,539 –&gt; 00:24:40,539<br>Right?</p>
<p>456<br>00:24:40,539 –&gt; 00:24:46,220<br>But the OS is going to have its own internal statistics about how these pages are being</p>
<p>457<br>00:24:46,220 –&gt; 00:24:51,740<br>accessed and it, it’s going to make a decision about what page do it.</p>
<p>458<br>00:24:51,740 –&gt; 00:24:54,539<br>But it doesn’t know anything about what we’re doing inside the database system because it</p>
<p>459<br>00:24:54,539 –&gt; 00:24:55,539<br>just sees reason rights.</p>
<p>460<br>00:24:55,539 –&gt; 00:24:57,539<br>It doesn’t, like, like, like, as a course screen.</p>
<p>461<br>00:24:57,539 –&gt; 00:24:58,539<br>It doesn’t know what queries are.</p>
<p>462<br>00:24:58,539 –&gt; 00:25:00,539<br>Doesn’t know what’s in these data pages.</p>
<p>463<br>00:25:00,539 –&gt; 00:25:02,340<br>What’s in these files?</p>
<p>464<br>00:25:03,019 –&gt; 00:25:07,139<br>So the OS is going to try to make a decision on how to swap things out.</p>
<p>465<br>00:25:07,139 –&gt; 00:25:08,459<br>And that’s just, you know, for eviction.</p>
<p>466<br>00:25:08,459 –&gt; 00:25:12,179<br>There’s a whole bunch of other problems that we’re going to face if we rely on the OS</p>
<p>467<br>00:25:12,179 –&gt; 00:25:15,419<br>to do this for us.</p>
<p>468<br>00:25:15,419 –&gt; 00:25:20,259<br>So in my first example here, I showed one thread, right, or one process with accessing it.</p>
<p>469<br>00:25:20,259 –&gt; 00:25:23,419<br>But again, we’re going to try to build a database, a modern database system that can take</p>
<p>470<br>00:25:23,419 –&gt; 00:25:27,139<br>advantage of multiple cores or multiple CPUs.</p>
<p>471<br>00:25:27,139 –&gt; 00:25:29,699<br>And so we need to have multiple threads access them.</p>
<p>472<br>00:25:29,700 –&gt; 00:25:34,900<br>And now what if one of them, you know, one of them, touch something, writes it, and then</p>
<p>473<br>00:25:34,900 –&gt; 00:25:38,580<br>another guy tries to read it, but it gets stalled because it gets evicted, right?</p>
<p>474<br>00:25:38,580 –&gt; 00:25:40,340<br>The ordering can get kind of screwy.</p>
<p>475<br>00:25:40,340 –&gt; 00:25:43,960<br>And again, the opportunism doesn’t know anything that’s going on, what’s running inside the</p>
<p>476<br>00:25:43,960 –&gt; 00:25:46,340<br>system at the same time.</p>
<p>477<br>00:25:46,340 –&gt; 00:25:47,340<br>So everything’s read-only.</p>
<p>478<br>00:25:47,340 –&gt; 00:25:48,340<br>It’s okay, right?</p>
<p>479<br>00:25:48,340 –&gt; 00:25:50,340<br>Because we’re not dirtying any pages.</p>
<p>480<br>00:25:50,340 –&gt; 00:25:51,860<br>The OS can swap things out.</p>
<p>481<br>00:25:51,860 –&gt; 00:25:53,660<br>It’ll be good enough.</p>
<p>482<br>00:25:53,660 –&gt; 00:25:58,000<br>And there are some cases, there are some data systems that do use MAP, just for sort of</p>
<p>483<br>00:25:58,000 –&gt; 00:26:01,039<br>read-only parts of the system.</p>
<p>484<br>00:26:01,039 –&gt; 00:26:04,640<br>But if you now need to have multiple writers, which again, in a real system, we’re going</p>
<p>485<br>00:26:04,640 –&gt; 00:26:09,359<br>to want this, then there’s a bunch of other problems.</p>
<p>486<br>00:26:09,359 –&gt; 00:26:11,000<br>So the first one is transaction safety.</p>
<p>487<br>00:26:11,000 –&gt; 00:26:12,720<br>This is the one I sort of mentioned.</p>
<p>488<br>00:26:12,720 –&gt; 00:26:18,920<br>Like if I have a transaction that updates multiple pages, I need to make sure that these pages</p>
<p>489<br>00:26:18,920 –&gt; 00:26:21,000<br>are actually written out in the right order.</p>
<p>490<br>00:26:21,000 –&gt; 00:26:24,680<br>And the OS doesn’t know that because this solves these dirty pages, it doesn’t know anything</p>
<p>491<br>00:26:24,680 –&gt; 00:26:29,960<br>about does this page need to be written before this other page.</p>
<p>492<br>00:26:29,960 –&gt; 00:26:33,840<br>You can do some things like you can lock the page using Mlock, but that only prevents</p>
<p>493<br>00:26:33,840 –&gt; 00:26:35,240<br>the OS from swapping it out.</p>
<p>494<br>00:26:35,240 –&gt; 00:26:37,120<br>It doesn’t prevent it from writing out.</p>
<p>495<br>00:26:37,120 –&gt; 00:26:39,480<br>So now it may write out a dirty page that it shouldn’t have.</p>
<p>496<br>00:26:39,480 –&gt; 00:26:43,920<br>I crash and come back, and now I have changes that shouldn’t have been written at disk.</p>
<p>497<br>00:26:43,920 –&gt; 00:26:50,360<br>And I have to go figure out how to reverse that or deal with the bad data and inconsistent</p>
<p>498<br>00:26:50,360 –&gt; 00:26:52,360<br>data.</p>
<p>499<br>00:26:52,439 –&gt; 00:26:55,039<br>We’ve already talked about doing stalls.</p>
<p>500<br>00:26:55,039 –&gt; 00:26:57,919<br>Again, if you try to access something that’s not in memory, you get a major page fault.</p>
<p>501<br>00:26:57,919 –&gt; 00:27:00,199<br>It blocks your thread, it de-schedules you.</p>
<p>502<br>00:27:00,199 –&gt; 00:27:03,639<br>The disk schedule goes, gets your page, brings it in, and when it’s available, then you</p>
<p>503<br>00:27:03,639 –&gt; 00:27:04,639<br>get re-scheduled.</p>
<p>504<br>00:27:04,639 –&gt; 00:27:06,159<br>Your thread gets re-scheduled again.</p>
<p>505<br>00:27:06,159 –&gt; 00:27:10,039<br>But now your thread is blocked and doing nothing.</p>
<p>506<br>00:27:10,039 –&gt; 00:27:14,240<br>And maybe there are other queries you could possibly run while you’re waiting for that</p>
<p>507<br>00:27:14,240 –&gt; 00:27:16,639<br>thing to get fetched from disk.</p>
<p>508<br>00:27:16,639 –&gt; 00:27:19,919<br>So then you say, OK, well, maybe I’ll make a dispatcher or a scheduler.</p>
<p>509<br>00:27:19,920 –&gt; 00:27:21,920<br>So there’s only one thread that goes and gets things.</p>
<p>510<br>00:27:21,920 –&gt; 00:27:24,960<br>If there’s a page fault, he gets blocked, then I can run out of the threads.</p>
<p>511<br>00:27:24,960 –&gt; 00:27:32,360<br>But now you’re building more infrastructure around the limitations of MAP.</p>
<p>512<br>00:27:32,360 –&gt; 00:27:36,680<br>Next problem you have is how do you handle errors?</p>
<p>513<br>00:27:36,680 –&gt; 00:27:43,240<br>If I, in MAP, if I try to access a page that, for whatever reason, it’s corrupted or</p>
<p>514<br>00:27:43,240 –&gt; 00:27:48,360<br>not available, there’s some harm to problem, you don’t get an exception as you would if</p>
<p>515<br>00:27:48,359 –&gt; 00:27:52,679<br>you write it in user space code, you get a sig bus interrupt.</p>
<p>516<br>00:27:52,679 –&gt; 00:27:56,039<br>Now you need a signal handler all throughout the rest of your system because you may be</p>
<p>517<br>00:27:56,039 –&gt; 00:28:01,359<br>doing something that is in a critical section that you don’t want to get interrupted or</p>
<p>518<br>00:28:01,359 –&gt; 00:28:02,359<br>break.</p>
<p>519<br>00:28:02,359 –&gt; 00:28:05,199<br>So therefore you have to have an interrupt handler to make sure you can go back to the thing</p>
<p>520<br>00:28:05,199 –&gt; 00:28:10,240<br>you were doing before to handle this interrupt.</p>
<p>521<br>00:28:10,240 –&gt; 00:28:15,359<br>Because this is the only sort of, this is how the operating system tells you things are</p>
<p>522<br>00:28:15,359 –&gt; 00:28:16,639<br>going back.</p>
<p>523<br>00:28:16,640 –&gt; 00:28:20,640<br>You can’t get back an error code, you get back an interrupt.</p>
<p>524<br>00:28:20,640 –&gt; 00:28:24,720<br>It’s a lot of engineering to handle this.</p>
<p>525<br>00:28:24,720 –&gt; 00:28:26,200<br>You don’t want to do this.</p>
<p>526<br>00:28:26,200 –&gt; 00:28:29,720<br>And then there’s obviously going to be performance issues.</p>
<p>527<br>00:28:29,720 –&gt; 00:28:33,240<br>And this is because the operating system is going to have its own internal data structures</p>
<p>528<br>00:28:33,240 –&gt; 00:28:37,440<br>about what’s in memory and not memory, what’s getting scheduled and not getting scheduled.</p>
<p>529<br>00:28:37,440 –&gt; 00:28:41,320<br>And it has to protect those critical sections inside its own data structures with new</p>
<p>530<br>00:28:41,319 –&gt; 00:28:44,000<br>text or whatever.</p>
<p>531<br>00:28:44,000 –&gt; 00:28:46,799<br>And now that’s going to be a contention point.</p>
<p>532<br>00:28:46,799 –&gt; 00:28:50,379<br>Whereas in a database system, we know what queries are trying to do because, again,</p>
<p>533<br>00:28:50,379 –&gt; 00:28:53,359<br>it’s eagles declarative, we know what the queries want to do because we have the physical</p>
<p>534<br>00:28:53,359 –&gt; 00:28:57,240<br>plan, we know what the data is trying to access, and therefore we can, we’re in a better</p>
<p>535<br>00:28:57,240 –&gt; 00:28:59,879<br>decision to decide how to schedule things.</p>
<p>536<br>00:28:59,879 –&gt; 00:29:00,879<br>Yes?</p>
<p>537<br>00:29:00,879 –&gt; 00:29:06,439<br>The database system is going to work with the data systems.</p>
<p>538<br>00:29:06,439 –&gt; 00:29:09,599<br>His question is the database systems have the privilege to work with harder directly.</p>
<p>539<br>00:29:09,599 –&gt; 00:29:16,839<br>There are methods called kernel bypass where you can, for NDE, there’s ways to make calls</p>
<p>540<br>00:29:16,839 –&gt; 00:29:20,000<br>to hardware without having to rely on the OS.</p>
<p>541<br>00:29:20,000 –&gt; 00:29:24,419<br>The problem with those things are you basically have to implement a bunch of the OS back</p>
<p>542<br>00:29:24,419 –&gt; 00:29:26,559<br>and up inside the database system.</p>
<p>543<br>00:29:26,559 –&gt; 00:29:30,119<br>So there’s something called, this is a tangent.</p>
<p>544<br>00:29:30,119 –&gt; 00:29:34,599<br>Like, if you don’t want to have to use the OS’s TCP stack for networking, there’s something</p>
<p>545<br>00:29:34,599 –&gt; 00:29:42,119<br>called the DVDK from Intel, the data plane, the data kit, or development kit.</p>
<p>546<br>00:29:42,119 –&gt; 00:29:46,000<br>Basically, it’s a way to hook directly into hardware and you get raw packets out.</p>
<p>547<br>00:29:46,000 –&gt; 00:29:47,000<br>But again, it’s raw packets.</p>
<p>548<br>00:29:47,000 –&gt; 00:29:51,799<br>If it’s a TCP connection, now you got to keep track of the TCP headers and a lot of f***ing</p>
<p>549<br>00:29:51,799 –&gt; 00:29:54,240<br>right.</p>
<p>550<br>00:29:54,240 –&gt; 00:29:55,240<br>Very few database systems do this.</p>
<p>551<br>00:29:55,240 –&gt; 00:29:56,759<br>I only know two.</p>
<p>552<br>00:29:56,759 –&gt; 00:29:58,839<br>One was, one’s yellow brick.</p>
<p>553<br>00:29:58,839 –&gt; 00:30:00,799<br>We’ll discuss them throughout the semester.</p>
<p>554<br>00:30:00,799 –&gt; 00:30:01,799<br>They went to amazing stuff.</p>
<p>555<br>00:30:01,799 –&gt; 00:30:04,399<br>They basically rewrite their own.</p>
<p>556<br>00:30:04,399 –&gt; 00:30:08,359<br>They basically only use the OS to turn the thing on and they never call Malik again.</p>
<p>557<br>00:30:08,359 –&gt; 00:30:10,519<br>They allocate all the memory, everything beginning.</p>
<p>558<br>00:30:10,519 –&gt; 00:30:12,519<br>They wrote their own PCIe drivers.</p>
<p>559<br>00:30:12,519 –&gt; 00:30:14,559<br>They do much amazing engineering.</p>
<p>560<br>00:30:14,559 –&gt; 00:30:15,559<br>Few people do that.</p>
<p>561<br>00:30:15,559 –&gt; 00:30:20,200<br>They know it was a ScaliaDB, but the DVDK was so difficult to handle that.</p>
<p>562<br>00:30:20,200 –&gt; 00:30:21,200<br>It was huge pains.</p>
<p>563<br>00:30:21,200 –&gt; 00:30:22,200<br>They don’t do it.</p>
<p>564<br>00:30:22,200 –&gt; 00:30:30,720<br>So the answer to the question is, for some things, you have to go through the OS.</p>
<p>565<br>00:30:30,720 –&gt; 00:30:34,279<br>In the 80s, they got really crazy.</p>
<p>566<br>00:30:34,279 –&gt; 00:30:37,440<br>Instead of using a file system, they wrote their own storage layer on top of like raw</p>
<p>567<br>00:30:37,440 –&gt; 00:30:38,440<br>block devices.</p>
<p>568<br>00:30:38,440 –&gt; 00:30:40,680<br>People try this over the years.</p>
<p>569<br>00:30:40,680 –&gt; 00:30:45,480<br>From an engineering perspective, it’s oftentimes you do have to rely on the OS, but you</p>
<p>570<br>00:30:45,480 –&gt; 00:30:49,920<br>want to minimize your contact with it because the OS is going to be your enemy.</p>
<p>571<br>00:30:49,920 –&gt; 00:30:51,920<br>Other questions?</p>
<p>572<br>00:30:51,920 –&gt; 00:30:52,920<br>All right.</p>
<p>573<br>00:30:52,920 –&gt; 00:30:56,240<br>I don’t spend too much time on MAP.</p>
<p>574<br>00:30:56,640 –&gt; 00:30:57,960<br>Suffice it, it’s a bad idea.</p>
<p>575<br>00:30:57,960 –&gt; 00:30:59,880<br>Don’t do it.</p>
<p>576<br>00:30:59,880 –&gt; 00:31:06,039<br>If I die, you can put on my tombstone, never use MAP for your database.</p>
<p>577<br>00:31:06,039 –&gt; 00:31:10,079<br>The reason why I was going to bring this up is because we invite a lot of these different</p>
<p>578<br>00:31:10,079 –&gt; 00:31:12,920<br>database companies and startups to come and give talks at CMU.</p>
<p>579<br>00:31:12,920 –&gt; 00:31:16,519<br>And surprisingly over the last couple of years, a lot of them mentioned they’re using MAP.</p>
<p>580<br>00:31:16,519 –&gt; 00:31:17,519<br>And we ask them why.</p>
<p>581<br>00:31:17,519 –&gt; 00:31:19,960<br>And they say, oh, because it’s quick and easy to use.</p>
<p>582<br>00:31:19,960 –&gt; 00:31:22,559<br>And then when we go talk to them a few years later, like, oh yeah, that was a huge mistake.</p>
<p>583<br>00:31:22,559 –&gt; 00:31:23,440<br>We should not have done MAP.</p>
<p>584<br>00:31:23,440 –&gt; 00:31:26,000<br>We should have done what lecture six is going to teach you.</p>
<p>585<br>00:31:26,000 –&gt; 00:31:27,000<br>Right?</p>
<p>586<br>00:31:27,000 –&gt; 00:31:29,000<br>So here’s a listing of some systems that I know using MAP.</p>
<p>587<br>00:31:29,000 –&gt; 00:31:30,400<br>There’s a couple others I’m sure I’m missing.</p>
<p>588<br>00:31:30,400 –&gt; 00:31:32,799<br>There’s a bunch of hobby projects.</p>
<p>589<br>00:31:32,799 –&gt; 00:31:34,400<br>So the ones at the top, these are full usage.</p>
<p>590<br>00:31:34,400 –&gt; 00:31:39,200<br>These are systems that were they entirely use MAP for all data back and forth from disk</p>
<p>591<br>00:31:39,200 –&gt; 00:31:41,480<br>and memory.</p>
<p>592<br>00:31:41,480 –&gt; 00:31:44,279<br>The most famous one of these is polyelastic.</p>
<p>593<br>00:31:44,279 –&gt; 00:31:51,680<br>Moan ADB was a commsroid out of CWI, the same place that build.db.</p>
<p>594<br>00:31:51,680 –&gt; 00:31:55,320<br>The LMDB does poly the exact opposite of me where I’m saying never use MAP.</p>
<p>595<br>00:31:55,320 –&gt; 00:31:57,400<br>He’s like always, always use MAP.</p>
<p>596<br>00:31:57,400 –&gt; 00:32:00,160<br>And he’s been banned on a bunch of different databases mailing lists because he would email</p>
<p>597<br>00:32:00,160 –&gt; 00:32:02,960<br>them and say, like, you guys should be using, you should be using LMDB.</p>
<p>598<br>00:32:02,960 –&gt; 00:32:04,720<br>You should be using MAP, right?</p>
<p>599<br>00:32:04,720 –&gt; 00:32:06,960<br>He’s wrong.</p>
<p>600<br>00:32:06,960 –&gt; 00:32:09,799<br>He’s s*** is weird.</p>
<p>601<br>00:32:09,799 –&gt; 00:32:12,759<br>But here’s the ones at the bottom that weren’t partially using it.</p>
<p>602<br>00:32:12,759 –&gt; 00:32:14,799<br>Actually, I would put manga as full usage.</p>
<p>603<br>00:32:14,799 –&gt; 00:32:16,200<br>They should really be at the top.</p>
<p>604<br>00:32:16,200 –&gt; 00:32:19,640<br>But the ones at the bottom here, they all got rid of it, right?</p>
<p>605<br>00:32:19,640 –&gt; 00:32:21,560<br>Because of all the issues that I mentioned before.</p>
<p>606<br>00:32:21,559 –&gt; 00:32:25,359<br>You can get something up and running pretty quickly to use MAP because you don’t have to</p>
<p>607<br>00:32:25,359 –&gt; 00:32:27,000<br>build your own buffer pool manager.</p>
<p>608<br>00:32:27,000 –&gt; 00:32:30,359<br>But because you’re lying on the OS to move data back and forth, it’s going to make horrible</p>
<p>609<br>00:32:30,359 –&gt; 00:32:32,599<br>decisions, right?</p>
<p>610<br>00:32:32,599 –&gt; 00:32:36,119<br>I don’t want to pick on Mongo, but Mongo is the best example of this.</p>
<p>611<br>00:32:36,119 –&gt; 00:32:39,960<br>Mongo started off with an MAP based storage engine, storage manager.</p>
<p>612<br>00:32:39,960 –&gt; 00:32:42,480<br>They were the hot database in the 2010s.</p>
<p>613<br>00:32:42,480 –&gt; 00:32:44,919<br>They raised a ton of investor money.</p>
<p>614<br>00:32:44,919 –&gt; 00:32:46,960<br>They had really good engineers.</p>
<p>615<br>00:32:46,960 –&gt; 00:32:48,480<br>They were based on a ton of MAP.</p>
<p>616<br>00:32:48,480 –&gt; 00:32:51,880<br>But MAP was the right choice.</p>
<p>617<br>00:32:51,880 –&gt; 00:32:53,920<br>They could have made that work.</p>
<p>618<br>00:32:53,920 –&gt; 00:32:54,920<br>But what did they do?</p>
<p>619<br>00:32:54,920 –&gt; 00:32:56,680<br>They threw it all away and they bought wire tiger.</p>
<p>620<br>00:32:56,680 –&gt; 00:33:00,480<br>It was a storage manager that doesn’t use MAP.</p>
<p>621<br>00:33:00,480 –&gt; 00:33:05,680<br>So again, just to reiterate, we don’t want to use the OS to manage memory because the</p>
<p>622<br>00:33:05,680 –&gt; 00:33:08,759<br>data system is always going to be a better position to do this.</p>
<p>623<br>00:33:08,759 –&gt; 00:33:11,400<br>It’s not just for managing memory, it’s basically for everything.</p>
<p>624<br>00:33:11,400 –&gt; 00:33:12,680<br>We don’t need the OS for scheduling.</p>
<p>625<br>00:33:12,680 –&gt; 00:33:16,160<br>We don’t need the OS for caching rights.</p>
<p>626<br>00:33:16,160 –&gt; 00:33:21,759<br>We don’t need the OS for the network stuff you need to.</p>
<p>627<br>00:33:21,759 –&gt; 00:33:23,759<br>But there’s a trick for that.</p>
<p>628<br>00:33:23,759 –&gt; 00:33:27,480<br>But OS is always going to be a problem.</p>
<p>629<br>00:33:27,480 –&gt; 00:33:30,640<br>Again, for MAP, I’ll send this link on Piazza.</p>
<p>630<br>00:33:30,640 –&gt; 00:33:32,560<br>We wrote a paper about this and why you don’t want to use this.</p>
<p>631<br>00:33:32,560 –&gt; 00:33:38,519<br>Then there’s a 10 minute YouTube video cartoon about all the problems.</p>
<p>632<br>00:33:38,519 –&gt; 00:33:45,920<br>The OS is going to be a problem for us and we have to design our system to deal with it.</p>
<p>633<br>00:33:45,920 –&gt; 00:33:50,279<br>So for database storage, there’s two problems we have to deal with.</p>
<p>634<br>00:33:50,279 –&gt; 00:33:54,240<br>How are we going to represent the database on these files on disk?</p>
<p>635<br>00:33:54,240 –&gt; 00:33:59,519<br>And then once we have those, how do we move data back and forth from disk into memory?</p>
<p>636<br>00:33:59,519 –&gt; 00:34:04,640<br>So today’s lecture is going to be on the first problem here and then we’ll cover the</p>
<p>637<br>00:34:04,640 –&gt; 00:34:11,400<br>second problem in the upcoming lectures.</p>
<p>638<br>00:34:11,400 –&gt; 00:34:17,280<br>So there’s going to be three layers of what data is going to look like on these disk pages.</p>
<p>639<br>00:34:17,280 –&gt; 00:34:22,920<br>So the first question is, what do these files actually look like?</p>
<p>640<br>00:34:22,920 –&gt; 00:34:24,960<br>And then within a file, there’s going to be pages.</p>
<p>641<br>00:34:24,960 –&gt; 00:34:27,480<br>We’re going to have to break it up into different chunks.</p>
<p>642<br>00:34:27,480 –&gt; 00:34:30,400<br>And then we’ll discuss what these pages look like.</p>
<p>643<br>00:34:30,400 –&gt; 00:34:35,240<br>And then within that page, we’re going to have tuples, the data itself, the tables.</p>
<p>644<br>00:34:35,240 –&gt; 00:34:37,039<br>We can ignore indexes for now.</p>
<p>645<br>00:34:37,039 –&gt; 00:34:40,039<br>And you have to decide what do those actually tuples look like.</p>
<p>646<br>00:34:40,039 –&gt; 00:34:44,199<br>So we’re going to start at the top and then go deeper, deeper inside of these files to</p>
<p>647<br>00:34:44,199 –&gt; 00:34:49,000<br>understand what they actually contain.</p>
<p>648<br>00:34:49,000 –&gt; 00:34:52,239<br>So as I said before, the database system is going to maintain a database as one more</p>
<p>649<br>00:34:52,239 –&gt; 00:34:56,639<br>files on disk, SQLite, DuckDB, those are all single file databases.</p>
<p>650<br>00:34:56,639 –&gt; 00:34:58,840<br>All the enterprise databases are postgres my SQL.</p>
<p>651<br>00:34:58,840 –&gt; 00:35:05,000<br>Every other system, more full feature system, is going to be running, maintaining multiple</p>
<p>652<br>00:35:05,000 –&gt; 00:35:08,119<br>files for your tables and databases.</p>
<p>653<br>00:35:08,119 –&gt; 00:35:14,480<br>And so the format that these files are going to be based on is typically going to be</p>
<p>654<br>00:35:14,480 –&gt; 00:35:18,719<br>a proprietary or custom to whatever the database system actually is.</p>
<p>655<br>00:35:18,719 –&gt; 00:35:19,719<br>Right?</p>
<p>656<br>00:35:19,719 –&gt; 00:35:24,880<br>Meaning you can’t take the postgres database files and open them up in my SQL or open them</p>
<p>657<br>00:35:24,880 –&gt; 00:35:25,880<br>up in SQLite.</p>
<p>658<br>00:35:25,880 –&gt; 00:35:30,920<br>Now, DuckDB, because they want to be portable and compatible with SQLite, they have connectors</p>
<p>659<br>00:35:30,920 –&gt; 00:35:34,000<br>to read SQLite files and other things.</p>
<p>660<br>00:35:34,000 –&gt; 00:35:38,360<br>But in general, all the major database systems are going to have their own proprietary format.</p>
<p>661<br>00:35:38,360 –&gt; 00:35:40,519<br>And the OS doesn’t know anything about what’s inside of these files.</p>
<p>662<br>00:35:40,519 –&gt; 00:35:42,039<br>There’s a no what’s inside of a page.</p>
<p>663<br>00:35:42,039 –&gt; 00:35:44,440<br>There’s a no where indexes are, where it’s the tables are, it just knows nothing, just</p>
<p>664<br>00:35:44,440 –&gt; 00:35:46,559<br>sees much of files.</p>
<p>665<br>00:35:46,559 –&gt; 00:35:52,159<br>So next class, we’ll talk about portal file formats, things like parquet, avro, org, arrow, these</p>
<p>666<br>00:35:52,159 –&gt; 00:35:58,199<br>are going to be open source specifications for what a database file could look like.</p>
<p>667<br>00:35:58,199 –&gt; 00:36:01,320<br>And then there’s a bunch of different systems that know how to read them and access them and</p>
<p>668<br>00:36:01,320 –&gt; 00:36:02,320<br>write them.</p>
<p>669<br>00:36:02,320 –&gt; 00:36:04,320<br>So we’ll we’ll we’ll we’ll write those later.</p>
<p>670<br>00:36:04,320 –&gt; 00:36:10,800<br>And as I said before, in the 1980s, there was a sort of a lot of the earlier database systems</p>
<p>671<br>00:36:10,800 –&gt; 00:36:15,760<br>decided that they not only were they going to have customized file formats, they were also</p>
<p>672<br>00:36:15,760 –&gt; 00:36:17,400<br>going to have customized file systems.</p>
<p>673<br>00:36:17,400 –&gt; 00:36:22,960<br>And they were going to use the EXT3 didn’t exist, you know, B3FS didn’t exist back then.</p>
<p>674<br>00:36:22,960 –&gt; 00:36:26,440<br>But they whatever the equipment was in the 80s, they didn’t even rely on what the OS said</p>
<p>675<br>00:36:26,440 –&gt; 00:36:28,039<br>what the file system was.</p>
<p>676<br>00:36:28,039 –&gt; 00:36:30,039<br>They wanted to do everything themselves.</p>
<p>677<br>00:36:30,039 –&gt; 00:36:32,920<br>And that’s a lot of engineering work and nobody does that today.</p>
<p>678<br>00:36:32,920 –&gt; 00:36:36,119<br>And it’s usually a marginal benefit.</p>
<p>679<br>00:36:36,119 –&gt; 00:36:39,360<br>The only systems that still do this would be like what I’ll call enterprise systems.</p>
<p>680<br>00:36:39,360 –&gt; 00:36:44,000<br>So this would be Oracle, the DB2s, the Teradata’s, these are like million dollar database systems</p>
<p>681<br>00:36:44,000 –&gt; 00:36:47,679<br>that are trying to get as much, you know, much performances you can.</p>
<p>682<br>00:36:47,679 –&gt; 00:36:57,960<br>These systems will support this in addition to running off the generic OS file systems.</p>
<p>683<br>00:36:57,960 –&gt; 00:37:02,480<br>So then the part of the database system is going to be responsible for maintaining and</p>
<p>684<br>00:37:02,480 –&gt; 00:37:07,039<br>coordinating these different files that we’ll call generically as the storage manager.</p>
<p>685<br>00:37:07,039 –&gt; 00:37:12,119<br>Sometimes it’s called the storage engine, right, it’s the same idea.</p>
<p>686<br>00:37:12,119 –&gt; 00:37:17,760<br>And it’s going to be the part of the system that communicates with either the hardware,</p>
<p>687<br>00:37:17,760 –&gt; 00:37:22,119<br>or communicates with the hardware, or whatever the storage device is either through the OS</p>
<p>688<br>00:37:22,119 –&gt; 00:37:31,679<br>or using direct access to retrieve data and bring it into the database systems memory.</p>
<p>689<br>00:37:31,679 –&gt; 00:37:32,920<br>And so we’ll discuss this next class.</p>
<p>690<br>00:37:32,920 –&gt; 00:37:36,279<br>I keep saying this, but there’s so many things to discuss.</p>
<p>691<br>00:37:36,279 –&gt; 00:37:40,799<br>A bunch of these systems will maintain their own, sort of, disk scheduler, disk batcher</p>
<p>692<br>00:37:40,799 –&gt; 00:37:43,839<br>that decides when, what pages to read and what order.</p>
<p>693<br>00:37:43,839 –&gt; 00:37:47,279<br>Because otherwise, if you just go do more effort, it’s going to say, oh, the OS is going</p>
<p>694<br>00:37:47,279 –&gt; 00:37:48,880<br>to figure out how to order things.</p>
<p>695<br>00:37:48,880 –&gt; 00:37:52,800<br>Right again, the data system is in a better position to know what it actually needs and</p>
<p>696<br>00:37:52,800 –&gt; 00:37:53,840<br>in what order.</p>
<p>697<br>00:37:53,840 –&gt; 00:37:59,880<br>So various systems can have their own thread decide how to schedule their own disk reads.</p>
<p>698<br>00:37:59,880 –&gt; 00:38:03,200<br>And you want to do this because you want to minimize the amount of thrashing of bringing</p>
<p>699<br>00:38:03,200 –&gt; 00:38:05,559<br>things in a memory how to throw it out right away.</p>
<p>700<br>00:38:05,559 –&gt; 00:38:09,519<br>So if you know two queries need the same page, maybe you bring that in first, but more</p>
<p>701<br>00:38:09,519 –&gt; 00:38:10,880<br>some other pages.</p>
<p>702<br>00:38:10,880 –&gt; 00:38:16,079<br>And then you throw away the first page once you know those two queries are done with them.</p>
<p>703<br>00:38:16,079 –&gt; 00:38:20,079<br>So the database follows are going to be broken up into what are called pages.</p>
<p>704<br>00:38:20,079 –&gt; 00:38:24,000<br>And the data system is going to be your response, sort of, keeping track of what data has been</p>
<p>705<br>00:38:24,000 –&gt; 00:38:28,000<br>read and written to these various pages.</p>
<p>706<br>00:38:28,000 –&gt; 00:38:30,119<br>And then keeps track of how much space is available in each of them.</p>
<p>707<br>00:38:30,119 –&gt; 00:38:35,480<br>Because again, if I need to start a new toople, I need to find a page that has space for</p>
<p>708<br>00:38:35,480 –&gt; 00:38:36,480<br>me.</p>
<p>709<br>00:38:36,480 –&gt; 00:38:39,400<br>So I’ll keep track of some directory that says this page has this amount of space and go</p>
<p>710<br>00:38:39,400 –&gt; 00:38:41,840<br>put it in there.</p>
<p>711<br>00:38:41,840 –&gt; 00:38:46,720<br>Now the data system itself, the storage manager layer that part we’re talking about here,</p>
<p>712<br>00:38:46,720 –&gt; 00:38:52,360<br>it’s not going to maintain multiple copies of these pages for redundancy replication purposes.</p>
<p>713<br>00:38:52,360 –&gt; 00:38:56,800<br>We assume that’s going to happen either both above and below this part of the system in</p>
<p>714<br>00:38:56,800 –&gt; 00:38:57,880<br>the stack.</p>
<p>715<br>00:38:57,880 –&gt; 00:39:03,280<br>So above would be like something that knows if a query shows up and wants to do a write,</p>
<p>716<br>00:39:03,280 –&gt; 00:39:07,000<br>send it to another physical box or another node and have both of those machines do the</p>
<p>717<br>00:39:07,000 –&gt; 00:39:08,000<br>right.</p>
<p>718<br>00:39:08,000 –&gt; 00:39:10,960<br>And then below it would be like if you’re running rate or some kind of storage appliance that</p>
<p>719<br>00:39:10,960 –&gt; 00:39:15,679<br>knows how to replicate pages, then down below it’ll do that as well.</p>
<p>720<br>00:39:15,679 –&gt; 00:39:18,720<br>Typically database systems will not maintain multiple copies themselves because it’s a</p>
<p>721<br>00:39:18,720 –&gt; 00:39:25,280<br>bunch of extra work that ideally you don’t want to have to do.</p>
<p>722<br>00:39:25,280 –&gt; 00:39:26,800<br>All right, so what is a page?</p>
<p>723<br>00:39:26,800 –&gt; 00:39:32,519<br>So in our view, from a data perspective, a page is going to be a fixed size block of data</p>
<p>724<br>00:39:32,519 –&gt; 00:39:36,280<br>and it can contain data from any part of the database itself.</p>
<p>725<br>00:39:37,120 –&gt; 00:39:41,760<br>For this lecture, we assume it’s just two pulls or records, but it can create indexes, log</p>
<p>726<br>00:39:41,760 –&gt; 00:39:46,200<br>information, additional metadata of the catalog, statistics, right.</p>
<p>727<br>00:39:46,200 –&gt; 00:39:52,360<br>It doesn’t matter, but it’s still going to be broken up into these fixed size blocks.</p>
<p>728<br>00:39:52,360 –&gt; 00:39:57,120<br>Most systems are not going to mix page types, meaning you don’t take a one megabyte page</p>
<p>729<br>00:39:57,120 –&gt; 00:40:02,760<br>and put in data from this table and this table and index and stuff like that, right.</p>
<p>730<br>00:40:02,760 –&gt; 00:40:07,720<br>For simplicity, you’re going to assume that one page belongs to some object in the database,</p>
<p>731<br>00:40:07,720 –&gt; 00:40:13,880<br>a table or index and so forth, and it would only contain data for that particular object.</p>
<p>732<br>00:40:13,880 –&gt; 00:40:18,080<br>Some systems are going to require every page to be self-contained, meaning all the information,</p>
<p>733<br>00:40:18,080 –&gt; 00:40:22,520<br>all the metadata you need to have to understand what’s inside that page has to be included</p>
<p>734<br>00:40:22,520 –&gt; 00:40:24,480<br>in the page itself.</p>
<p>735<br>00:40:24,480 –&gt; 00:40:27,240<br>So Oracle’s probably the most famous one that does this, right.</p>
<p>736<br>00:40:27,240 –&gt; 00:40:31,360<br>So within a page, you have to keep track of like, it belongs to this table and has these</p>
<p>737<br>00:40:31,360 –&gt; 00:40:34,559<br>columns, these types and so forth.</p>
<p>738<br>00:40:34,559 –&gt; 00:40:39,840<br>The reason why they want to do this is because if there’s some corruption in the database</p>
<p>739<br>00:40:39,840 –&gt; 00:40:45,120<br>files, you don’t want to have some page that contains the metadata about the table,</p>
<p>740<br>00:40:45,120 –&gt; 00:40:50,320<br>get blown away and then now you can’t understand what’s in any other page, right.</p>
<p>741<br>00:40:50,320 –&gt; 00:40:53,440<br>Again, replication can solve this problem.</p>
<p>742<br>00:40:53,440 –&gt; 00:40:58,240<br>Harbor has certainly got a lot more reliable in modern times than it did before.</p>
<p>743<br>00:40:58,239 –&gt; 00:41:01,679<br>Like hard drives, super flaky before.</p>
<p>744<br>00:41:01,679 –&gt; 00:41:04,679<br>They’re still not ideal, but they’re much better than they used to be.</p>
<p>745<br>00:41:04,679 –&gt; 00:41:10,159<br>So this maybe this, having every page be self-contained is less of an issue today, but</p>
<p>746<br>00:41:10,159 –&gt; 00:41:15,199<br>there’s a design choice that Oracle made very early on.</p>
<p>747<br>00:41:15,199 –&gt; 00:41:19,719<br>Now every page in our database file is going to be given a unique identifier, like a page</p>
<p>748<br>00:41:19,719 –&gt; 00:41:24,159<br>ID, like some number, 64 bit integer, 30 bit integer.</p>
<p>749<br>00:41:24,159 –&gt; 00:41:28,119<br>And then there’ll be some method or some mechanism that the dataset is going to use that</p>
<p>750<br>00:41:28,119 –&gt; 00:41:33,279<br>allow it to map a page ID to some physical location on our storage device.</p>
<p>751<br>00:41:33,279 –&gt; 00:41:37,799<br>And again, that could be like a file name inside of a directory at some offset.</p>
<p>752<br>00:41:37,799 –&gt; 00:41:41,839<br>If we’re running on like a cloud storage, it could be an S3 bucket at some offset and so</p>
<p>753<br>00:41:41,839 –&gt; 00:41:42,839<br>forth, right.</p>
<p>754<br>00:41:42,839 –&gt; 00:41:44,599<br>From our purpose, it doesn’t matter.</p>
<p>755<br>00:41:44,599 –&gt; 00:41:48,799<br>We just have a way to say, if we’re looking at page 123, there’s some method to say, here’s</p>
<p>756<br>00:41:48,799 –&gt; 00:41:53,079<br>where to go find it.</p>
<p>757<br>00:41:53,079 –&gt; 00:41:57,039<br>And now, what’s sort of confusing in the constant databases is that there’s three different</p>
<p>758<br>00:41:57,039 –&gt; 00:42:00,440<br>notions of what a page actually is.</p>
<p>759<br>00:42:00,440 –&gt; 00:42:03,440<br>And so at the lowest level, you have what is called a hardware page.</p>
<p>760<br>00:42:03,440 –&gt; 00:42:07,199<br>And this is typically four kilobytes.</p>
<p>761<br>00:42:07,199 –&gt; 00:42:17,360<br>And this is going to be the largest size or the smallest size of a page or a block of data</p>
<p>762<br>00:42:17,360 –&gt; 00:42:21,880<br>that the hardware can guarantee that it can do atomic rights.</p>
<p>763<br>00:42:21,880 –&gt; 00:42:22,880<br>So what do I mean by that?</p>
<p>764<br>00:42:22,880 –&gt; 00:42:23,880<br>It’s atomic rights.</p>
<p>765<br>00:42:23,880 –&gt; 00:42:27,880<br>Is this all or nothing?</p>
<p>766<br>00:42:27,880 –&gt; 00:42:28,880<br>Right.</p>
<p>767<br>00:42:28,880 –&gt; 00:42:33,920<br>So it means that if I tell the hardware, I want to write four kilobytes and I get back</p>
<p>768<br>00:42:33,920 –&gt; 00:42:38,920<br>an acknowledgement that yes, I wrote four kilobytes, then I can assume that it made it.</p>
<p>769<br>00:42:38,920 –&gt; 00:42:44,320<br>If I need to write eight kilobytes, and I send that as two four kilobyte blocks down to</p>
<p>770<br>00:42:44,320 –&gt; 00:42:49,960<br>the OS, or started to the hardware, I may write the first four kilobytes and then crash</p>
<p>771<br>00:42:49,960 –&gt; 00:42:54,679<br>and then come back and then the second four kilobytes did make it.</p>
<p>772<br>00:42:54,679 –&gt; 00:42:58,159<br>There’s no guarantee, the hardware can’t guarantee that it can do that all automatically, like</p>
<p>773<br>00:42:58,159 –&gt; 00:42:59,679<br>all or nothing.</p>
<p>774<br>00:42:59,679 –&gt; 00:43:03,320<br>And so because of this, we’re going to do much other extra stuff inside our database system</p>
<p>775<br>00:43:03,320 –&gt; 00:43:05,920<br>to deal with that.</p>
<p>776<br>00:43:05,920 –&gt; 00:43:07,720<br>We’ll get to that later.</p>
<p>777<br>00:43:07,720 –&gt; 00:43:12,000<br>And then above the hardware, now the operating system is going to have its own notion of a</p>
<p>778<br>00:43:12,000 –&gt; 00:43:13,000<br>page.</p>
<p>779<br>00:43:13,000 –&gt; 00:43:16,880<br>And in Linux, by default, this is four kilobytes.</p>
<p>780<br>00:43:16,880 –&gt; 00:43:20,599<br>And again, this is like mapping something that’s on the hardware to something that’s in</p>
<p>781<br>00:43:20,599 –&gt; 00:43:22,440<br>virtual memory.</p>
<p>782<br>00:43:22,440 –&gt; 00:43:29,079<br>Now in X64, they also support two different modes or sort of huge pages as they’re called.</p>
<p>783<br>00:43:29,079 –&gt; 00:43:31,880<br>So you can get page sizes actually two megabytes and one gigabyte.</p>
<p>784<br>00:43:31,880 –&gt; 00:43:36,320<br>And again, the hardware can’t guarantee that it can write out four kilobytes automatically.</p>
<p>785<br>00:43:36,320 –&gt; 00:43:41,079<br>This is just to reduce the amount of bookkeeping that the OS does for the pages that it brings</p>
<p>786<br>00:43:41,079 –&gt; 00:43:43,440<br>into memory.</p>
<p>787<br>00:43:43,440 –&gt; 00:43:47,280<br>And then within that now, above that, the database system is going to have its own notion of a</p>
<p>788<br>00:43:47,280 –&gt; 00:43:50,880<br>page as well.</p>
<p>789<br>00:43:50,880 –&gt; 00:43:54,920<br>And typically, this is going to be anywhere in the range of 512 bytes.</p>
<p>790<br>00:43:54,920 –&gt; 00:43:57,159<br>This is what SQLite does.</p>
<p>791<br>00:43:57,159 –&gt; 00:44:02,920<br>Up to I think 32 kilobytes, some systems let you go up to 64 kilobytes.</p>
<p>792<br>00:44:02,920 –&gt; 00:44:09,119<br>And so the page size is going to be the way we’ll represent where to find, sorry, the page</p>
<p>793<br>00:44:09,119 –&gt; 00:44:17,319<br>ID is a way to represent at what offset in some file for a given page size, can we find</p>
<p>794<br>00:44:17,319 –&gt; 00:44:20,000<br>the data that we’re looking for?</p>
<p>795<br>00:44:20,000 –&gt; 00:44:24,079<br>So again, most systems are the defaults going to be four kilobytes.</p>
<p>796<br>00:44:24,079 –&gt; 00:44:28,079<br>In SQL server and Postgres, the page size is going to be eight kilobytes.</p>
<p>797<br>00:44:28,079 –&gt; 00:44:31,519<br>And then in my SQL, they go up to 16 kilobytes.</p>
<p>798<br>00:44:31,519 –&gt; 00:44:36,039<br>For something like a DB2 and an enterprise system, actually for DB2 on a per table basis,</p>
<p>799<br>00:44:36,039 –&gt; 00:44:38,039<br>you can change the page size.</p>
<p>800<br>00:44:38,039 –&gt; 00:44:43,639<br>And then take a guess, would anybody take a guess why one page size, a larger page size</p>
<p>801<br>00:44:43,639 –&gt; 00:44:48,960<br>might be a better idea?</p>
<p>802<br>00:44:48,960 –&gt; 00:44:49,960<br>What did I say in the beginning?</p>
<p>803<br>00:44:49,960 –&gt; 00:44:51,159<br>What do we want to try to maximize?</p>
<p>804<br>00:44:51,159 –&gt; 00:44:52,960<br>So, sequential access, correct.</p>
<p>805<br>00:44:52,960 –&gt; 00:44:53,960<br>Yes.</p>
<p>806<br>00:44:53,960 –&gt; 00:45:02,800<br>So, if I’m organizing on disk 16 kilobytes blocks and I need to read 16 kilobytes of data,</p>
<p>807<br>00:45:02,800 –&gt; 00:45:09,960<br>then it’s one sort of call to our dispassion in the data system that makes one call on</p>
<p>808<br>00:45:09,960 –&gt; 00:45:14,640<br>the OS to go grab continuous 16 kilobytes.</p>
<p>809<br>00:45:14,640 –&gt; 00:45:19,920<br>If I’m using four kilobyte pages, then I got to make separate lookups that go get the</p>
<p>810<br>00:45:19,920 –&gt; 00:45:23,480<br>data in potentially random locations.</p>
<p>811<br>00:45:23,480 –&gt; 00:45:28,000<br>And there’s, there’s, there’s, cyscalls you can make to the OS are, to the device itself</p>
<p>812<br>00:45:28,000 –&gt; 00:45:32,080<br>that when you allocate data that you want things to be ideally contiguously aligned, you</p>
<p>813<br>00:45:32,079 –&gt; 00:45:37,880<br>can like pre-allocate and extend to say allocate me a 10 megabyte block of data and then</p>
<p>814<br>00:45:37,880 –&gt; 00:45:42,759<br>then the data can divide that 10 megabyte block into, you know, 8 kilobytes chunks or</p>
<p>815<br>00:45:42,759 –&gt; 00:45:44,759<br>whatever the block size it wants.</p>
<p>816<br>00:45:44,759 –&gt; 00:45:45,759<br>Yes.</p>
<p>817<br>00:45:45,759 –&gt; 00:45:46,759<br>Right.</p>
<p>818<br>00:45:46,759 –&gt; 00:45:53,599<br>So, then he says, and he’s correct, doesn’t this mean that large pay sizes make rights</p>
<p>819<br>00:45:53,599 –&gt; 00:45:54,599<br>more expensive?</p>
<p>820<br>00:45:54,599 –&gt; 00:45:58,239<br>Because now, if I only have to write one kilobytes, but I’m storing as a 16 kilobytes page,</p>
<p>821<br>00:45:58,239 –&gt; 00:46:00,119<br>I got to write it all 16 kilobytes.</p>
<p>822<br>00:46:00,119 –&gt; 00:46:01,119<br>Absolutely.</p>
<p>823<br>00:46:01,119 –&gt; 00:46:02,119<br>So, this is a good point.</p>
<p>824<br>00:46:02,119 –&gt; 00:46:04,920<br>This is something I would say throughout the entire semester.</p>
<p>825<br>00:46:04,920 –&gt; 00:46:08,239<br>It’s, I mean, not just for data basis, computer science in general.</p>
<p>826<br>00:46:08,239 –&gt; 00:46:09,239<br>There’s no free lunch.</p>
<p>827<br>00:46:09,239 –&gt; 00:46:13,719<br>There’s, we pros and cons to each of these and then different situations, one approach</p>
<p>828<br>00:46:13,719 –&gt; 00:46:15,199<br>might be better than another.</p>
<p>829<br>00:46:15,199 –&gt; 00:46:18,759<br>If my workload is entirely read only, if I never write anything, then yeah, I want large</p>
<p>830<br>00:46:18,759 –&gt; 00:46:21,599<br>page sizes, assuming I’m doing large, smithral scans.</p>
<p>831<br>00:46:21,599 –&gt; 00:46:23,880<br>If I’m doing much of rights, then maybe I want something smaller.</p>
<p>832<br>00:46:23,880 –&gt; 00:46:25,799<br>But what the right amount is?</p>
<p>833<br>00:46:25,799 –&gt; 00:46:26,799<br>Depends.</p>
<p>834<br>00:46:26,799 –&gt; 00:46:27,799<br>Yes.</p>
<p>835<br>00:46:27,800 –&gt; 00:46:51,760<br>So, his statement is, if I do 16 kilobytes reads, and I’m still using four kilobytes of</p>
<p>836<br>00:46:51,760 –&gt; 00:46:57,760<br>data, assuming that 16 kilobytes is contiguous, then can’t I go make a, uh,</p>
<p>837<br>00:46:57,760 –&gt; 00:47:01,520<br>you know, go make a single call to get 16 kilobytes that are contiguous.</p>
<p>838<br>00:47:01,520 –&gt; 00:47:04,760<br>And then if I had the right individual, within the individual four kilobytes, I could still</p>
<p>839<br>00:47:04,760 –&gt; 00:47:05,760<br>write those out.</p>
<p>840<br>00:47:05,760 –&gt; 00:47:06,760<br>Absolutely.</p>
<p>841<br>00:47:06,760 –&gt; 00:47:07,760<br>Yes.</p>
<p>842<br>00:47:07,760 –&gt; 00:47:08,760<br>And this is what I was saying before.</p>
<p>843<br>00:47:08,760 –&gt; 00:47:12,760<br>We will then choose algorithms or methods that try to write the data out, so that it is</p>
<p>844<br>00:47:12,760 –&gt; 00:47:15,760<br>contiguous so that we can do those fetches.</p>
<p>845<br>00:47:15,760 –&gt; 00:47:16,760<br>Right?</p>
<p>846<br>00:47:16,760 –&gt; 00:47:20,040<br>And again, this is something that data system could do for us, because we know what the query</p>
<p>847<br>00:47:20,040 –&gt; 00:47:22,080<br>is, we know what data you’re going to potentially read.</p>
<p>848<br>00:47:22,080 –&gt; 00:47:26,560<br>And so we can read ahead for you and try to fetch things that are, uh, before you actually</p>
<p>849<br>00:47:26,560 –&gt; 00:47:27,560<br>need them.</p>
<p>850<br>00:47:27,559 –&gt; 00:47:31,400<br>Now the OS can do that with prefetching as well, but it can only prefetch things that are</p>
<p>851<br>00:47:31,400 –&gt; 00:47:35,360<br>contiguous, uh, in both directions, I think, in Linux, yes.</p>
<p>852<br>00:47:35,360 –&gt; 00:47:38,920<br>But it can’t do, in fact, the prefetched things that aren’t contiguous, it can’t do that</p>
<p>853<br>00:47:38,920 –&gt; 00:47:39,920<br>for me.</p>
<p>854<br>00:47:39,920 –&gt; 00:47:43,079<br>All right, so is this clear?</p>
<p>855<br>00:47:43,079 –&gt; 00:47:47,000<br>So again, there’ll be some page ID, and we’ll see this in a second how this is being used.</p>
<p>856<br>00:47:47,000 –&gt; 00:47:50,759<br>That’s going to allow us to say, from page, uh, page one to three, here’s where to go find</p>
<p>857<br>00:47:50,759 –&gt; 00:47:51,759<br>it.</p>
<p>858<br>00:47:51,759 –&gt; 00:47:52,759<br>All right.</p>
<p>859<br>00:47:52,760 –&gt; 00:48:00,160<br>So now we’re going to talk about how do we actually keep track of that mapping of page</p>
<p>860<br>00:48:00,160 –&gt; 00:48:03,600<br>IDs to locations.</p>
<p>861<br>00:48:03,600 –&gt; 00:48:06,840<br>And there’s a, this would be one of the big differences of how the data systems are going</p>
<p>862<br>00:48:06,840 –&gt; 00:48:09,400<br>to organize the, and their pages.</p>
<p>863<br>00:48:09,400 –&gt; 00:48:12,880<br>Um, and again, there’s not, I’m not saying one way is better than another.</p>
<p>864<br>00:48:12,880 –&gt; 00:48:17,840<br>I’ll describe the heat file approaches than those common one, uh, but certainly a bunch</p>
<p>865<br>00:48:17,840 –&gt; 00:48:21,360<br>of other systems are doing different things, uh, and they’re, and they’re trade outs for</p>
<p>866<br>00:48:21,360 –&gt; 00:48:23,440<br>all these ones.</p>
<p>867<br>00:48:23,440 –&gt; 00:48:27,400<br>So at this point, where we’re in our discussion, we don’t need to know anything about what’s</p>
<p>868<br>00:48:27,400 –&gt; 00:48:28,400<br>inside of our pages.</p>
<p>869<br>00:48:28,400 –&gt; 00:48:31,079<br>Like again, we don’t care whether there’s indexes or tuples.</p>
<p>870<br>00:48:31,079 –&gt; 00:48:34,800<br>We just need to know for a given page, where, how do I go find it and how to keep track</p>
<p>871<br>00:48:34,800 –&gt; 00:48:37,680<br>of what pages I actually have.</p>
<p>872<br>00:48:37,680 –&gt; 00:48:43,720<br>So tree files is basically store, um, you can store the, uh, like sort of, in the leaf</p>
<p>873<br>00:48:43,720 –&gt; 00:48:47,599<br>nodes, you can store the actual pages themselves or you can, you can have a hash table.</p>
<p>874<br>00:48:47,599 –&gt; 00:48:51,079<br>I, I say M, uh, or some sort of files.</p>
<p>875<br>00:48:51,079 –&gt; 00:48:54,920<br>This is something from like the 70s, my SQL usage, it’s by default.</p>
<p>876<br>00:48:54,920 –&gt; 00:48:58,599<br>It’s not that common anymore, but again, it’s another way to sort of keep track of things.</p>
<p>877<br>00:48:58,599 –&gt; 00:49:01,319<br>And then hashing file is, again, use the hash table to look up.</p>
<p>878<br>00:49:01,319 –&gt; 00:49:03,400<br>Heat file is going to be the most common one.</p>
<p>879<br>00:49:03,400 –&gt; 00:49:06,319<br>Um, but these other methods exist.</p>
<p>880<br>00:49:06,319 –&gt; 00:49:08,880<br>And then for the log, structure stuff, we’ll see that next class.</p>
<p>881<br>00:49:08,880 –&gt; 00:49:13,119<br>Uh, how this is?</p>
<p>882<br>00:49:13,119 –&gt; 00:49:14,920<br>The directory is really keeping track.</p>
<p>883<br>00:49:14,920 –&gt; 00:49:17,960<br>You still want to use potentially heat file to keep track of what, what things are.</p>
<p>884<br>00:49:17,960 –&gt; 00:49:20,320<br>Can, because we don’t care about what’s it, we don’t care at this point with inside the</p>
<p>885<br>00:49:20,320 –&gt; 00:49:21,320<br>pages.</p>
<p>886<br>00:49:21,320 –&gt; 00:49:23,320<br>All right.</p>
<p>887<br>00:49:23,320 –&gt; 00:49:27,960<br>So heat file is just going to be an un, uh, a collection of unorder pages, uh, where our</p>
<p>888<br>00:49:27,960 –&gt; 00:49:29,240<br>tuples will be stored in random order.</p>
<p>889<br>00:49:29,240 –&gt; 00:49:32,559<br>And again, the relational model allows us to do that because the relational model doesn’t</p>
<p>890<br>00:49:32,559 –&gt; 00:49:37,960<br>find, or doesn’t says that the data doesn’t have to be specified in exact order.</p>
<p>891<br>00:49:37,960 –&gt; 00:49:42,440<br>Some systems might pre-sort them, uh, to make things faster for other, other effects.</p>
<p>892<br>00:49:42,440 –&gt; 00:49:46,519<br>But the relational model doesn’t require you to do that.</p>
<p>893<br>00:49:46,519 –&gt; 00:49:51,440<br>And so the only API we need in our storage manager to support a heat file is basically</p>
<p>894<br>00:49:51,440 –&gt; 00:49:58,240<br>to create pages, get a page, write to a page, uh, delete a page, and then an iterator API</p>
<p>895<br>00:49:58,240 –&gt; 00:50:03,159<br>allows the two, to squench the read pages to get the list of all the page IDs that we</p>
<p>896<br>00:50:03,159 –&gt; 00:50:05,639<br>have and read over them.</p>
<p>897<br>00:50:05,639 –&gt; 00:50:09,639<br>So managing this heat file is really easy to do.</p>
<p>898<br>00:50:09,639 –&gt; 00:50:14,960<br>If your database is a single file, like inductee, B, or like in, in, in SQLite, right?</p>
<p>899<br>00:50:14,960 –&gt; 00:50:19,799<br>Because all you need to do to find a given page is just know what the page number is.</p>
<p>900<br>00:50:19,799 –&gt; 00:50:23,159<br>You know what the size of the page is because they all have to be the same size.</p>
<p>901<br>00:50:23,159 –&gt; 00:50:27,759<br>And now you just do a simple arithmetic like take whatever the ID I’m looking for, multiply</p>
<p>902<br>00:50:27,759 –&gt; 00:50:32,079<br>it by the, the size of the page, and then I can jump to whatever that offset is in the</p>
<p>903<br>00:50:32,079 –&gt; 00:50:33,079<br>file.</p>
<p>904<br>00:50:33,079 –&gt; 00:50:36,759<br>I don’t know exactly what I’m looking for.</p>
<p>905<br>00:50:36,760 –&gt; 00:50:41,080<br>If you go look in the SQLite documentation, they, they talk about how, uh, in, in the</p>
<p>906<br>00:50:41,080 –&gt; 00:50:44,880<br>header of their, of their, the data file, all sort of the, the metadata that they keep</p>
<p>907<br>00:50:44,880 –&gt; 00:50:48,880<br>track of basically do, do this trick here.</p>
<p>908<br>00:50:48,880 –&gt; 00:50:52,120<br>Where things get tricky is if you have multiple files, which again, most systems do,</p>
<p>909<br>00:50:52,120 –&gt; 00:50:54,480<br>Postgres does, my SQL does, Oracle does.</p>
<p>910<br>00:50:54,480 –&gt; 00:50:58,880<br>And then now we need a way to say, all right, for given page number two, what file and</p>
<p>911<br>00:50:58,880 –&gt; 00:51:04,000<br>at what offset, you know, what directory or what file and what offset has, has the page, uh,</p>
<p>912<br>00:51:04,000 –&gt; 00:51:07,400<br>that I need.</p>
<p>913<br>00:51:07,400 –&gt; 00:51:08,400<br>Right?</p>
<p>914<br>00:51:08,400 –&gt; 00:51:10,519<br>And this is what a heat file page directory can get for us.</p>
<p>915<br>00:51:10,519 –&gt; 00:51:14,559<br>You can think of it’s like a hash table where you just keep track of, it’s mapping from</p>
<p>916<br>00:51:14,559 –&gt; 00:51:19,199<br>the page ID to, to the pages in the data file.</p>
<p>917<br>00:51:19,199 –&gt; 00:51:23,440<br>And this typical would be, uh, sort of special file, you got the header of, of the, of the,</p>
<p>918<br>00:51:23,440 –&gt; 00:51:27,760<br>the single database file, or at some special location inside of, uh, the database system and</p>
<p>919<br>00:51:27,760 –&gt; 00:51:29,039<br>a directory.</p>
<p>920<br>00:51:29,039 –&gt; 00:51:31,880<br>And you can sort of think is, it’s a database when the, the database is, it’s the database</p>
<p>921<br>00:51:31,880 –&gt; 00:51:34,119<br>that keeps track of what’s in your database.</p>
<p>922<br>00:51:34,119 –&gt; 00:51:35,119<br>Right?</p>
<p>923<br>00:51:35,119 –&gt; 00:51:37,840<br>The catalog is part of that as too, but this is like keeping track of where the physical</p>
<p>924<br>00:51:37,840 –&gt; 00:51:39,960<br>location things are.</p>
<p>925<br>00:51:39,960 –&gt; 00:51:45,440<br>And so this has to be kept in sync with the actual files on disk because I don’t want to</p>
<p>926<br>00:51:45,440 –&gt; 00:51:48,480<br>create a bunch of pages, not update my page directory.</p>
<p>927<br>00:51:48,480 –&gt; 00:51:52,880<br>I crash and come back and now my page directory doesn’t know about these other pages and I, I</p>
<p>928<br>00:51:52,880 –&gt; 00:51:54,480<br>can’t get to them.</p>
<p>929<br>00:51:54,480 –&gt; 00:51:55,480<br>Right?</p>
<p>930<br>00:51:55,480 –&gt; 00:51:57,680<br>So there’s, there’s a bunch of extra tricks we have to do to make sure that these things are</p>
<p>931<br>00:51:57,680 –&gt; 00:51:59,519<br>maintained or kept in sync.</p>
<p>932<br>00:52:00,320 –&gt; 00:52:03,759<br>Okay, so just thinking like I have a bunch of pages, they’re on some, they’re on some</p>
<p>933<br>00:52:03,759 –&gt; 00:52:06,159<br>location, a bunch of files, doesn’t matter where.</p>
<p>934<br>00:52:06,159 –&gt; 00:52:09,719<br>And then it’s just a mapping to tell you where to go find it.</p>
<p>935<br>00:52:09,719 –&gt; 00:52:13,480<br>Additional metadata can keep track of like for every single page, you can keep track of</p>
<p>936<br>00:52:13,480 –&gt; 00:52:14,759<br>an essential location.</p>
<p>937<br>00:52:14,759 –&gt; 00:52:18,360<br>The number of free slots that they actually have or free space they have.</p>
<p>938<br>00:52:18,360 –&gt; 00:52:22,320<br>So now, again, if I want to insert a tuple and I got to find a page to put it in, I don’t</p>
<p>939<br>00:52:22,320 –&gt; 00:52:24,960<br>want to have to scan them all and figure out who’s got free space.</p>
<p>940<br>00:52:24,960 –&gt; 00:52:27,000<br>My page directory would tell me that.</p>
<p>941<br>00:52:27,000 –&gt; 00:52:28,000<br>Right?</p>
<p>942<br>00:52:29,000 –&gt; 00:52:32,480<br>And then if I run out of pages, I know how to allocate them and then update my page directory</p>
<p>943<br>00:52:32,480 –&gt; 00:52:33,400<br>to point this as well.</p>
<p>944<br>00:52:36,000 –&gt; 00:52:39,039<br>Again, just think, think of a hash table that I’ve gotten written to this, it keeps track</p>
<p>945<br>00:52:39,039 –&gt; 00:52:40,039<br>of the pages that I have.</p>
<p>946<br>00:52:40,039 –&gt; 00:52:43,719<br>But then I can also again iterate or scan through and say here’s page one, here’s page</p>
<p>947<br>00:52:43,719 –&gt; 00:52:44,719<br>two, here’s page three.</p>
<p>948<br>00:52:44,719 –&gt; 00:52:48,360<br>Because we’re going to need this if we have an access method like a Spontural Scan operator.</p>
<p>949<br>00:52:48,360 –&gt; 00:52:49,360<br>Right?</p>
<p>950<br>00:52:49,360 –&gt; 00:52:52,039<br>If we don’t have an index, we need to be able to iterate over there, every single tuple</p>
<p>951<br>00:52:52,039 –&gt; 00:52:53,039<br>in the table.</p>
<p>952<br>00:52:53,039 –&gt; 00:52:56,039<br>So the page directory needs to be to expose us that API.</p>
<p>953<br>00:52:56,039 –&gt; 00:52:57,039<br>Yes.</p>
<p>954<br>00:52:57,039 –&gt; 00:52:58,400<br>So the page and then case of a crash.</p>
<p>955<br>00:52:58,400 –&gt; 00:53:03,599<br>So that means because the directory is part of the word time memory, do I also have to</p>
<p>956<br>00:53:03,599 –&gt; 00:53:05,360<br>write it through the storage from there?</p>
<p>957<br>00:53:05,360 –&gt; 00:53:06,360<br>Yes.</p>
<p>958<br>00:53:06,360 –&gt; 00:53:09,440<br>So this question is, because the directory has to be brought in a memory in order to</p>
<p>959<br>00:53:09,440 –&gt; 00:53:12,279<br>read it, it’s a non-volta memory.</p>
<p>960<br>00:53:12,279 –&gt; 00:53:15,159<br>So now if I crash, I don’t want to lose it.</p>
<p>961<br>00:53:15,159 –&gt; 00:53:17,400<br>Does that mean any changes that make to it have to be written at disk?</p>
<p>962<br>00:53:17,400 –&gt; 00:53:18,719<br>Yes.</p>
<p>963<br>00:53:18,719 –&gt; 00:53:25,360<br>But it’s not as bad as like, you’re not updating this thing all the time.</p>
<p>964<br>00:53:25,360 –&gt; 00:53:30,920<br>So if you run out of space in your data as far as the allocate more pages, you’re not</p>
<p>965<br>00:53:30,920 –&gt; 00:53:32,720<br>going to allocate this one page.</p>
<p>966<br>00:53:32,720 –&gt; 00:53:33,720<br>Right?</p>
<p>967<br>00:53:33,720 –&gt; 00:53:35,360<br>Because then you can potentially do that for every single query.</p>
<p>968<br>00:53:35,360 –&gt; 00:53:39,320<br>You’re going to allocate like a gigabyte of data, update your page directory, that gets</p>
<p>969<br>00:53:39,320 –&gt; 00:53:40,519<br>written at disk once.</p>
<p>970<br>00:53:40,519 –&gt; 00:53:43,039<br>You make sure that’s persisted and it’s safe.</p>
<p>971<br>00:53:43,039 –&gt; 00:53:44,039<br>Then you perceive it running the query.</p>
<p>972<br>00:53:44,039 –&gt; 00:53:47,800<br>So that means any update to the directory has to be written at the top.</p>
<p>973<br>00:53:47,800 –&gt; 00:53:48,800<br>Yes.</p>
<p>974<br>00:53:48,800 –&gt; 00:53:50,800<br>So statement says, any update to the page directory has to be written at disk?</p>
<p>975<br>00:53:50,800 –&gt; 00:53:51,800<br>Absolutely, yes.</p>
<p>976<br>00:53:51,800 –&gt; 00:53:54,280<br>Because otherwise you don’t know what you have.</p>
<p>977<br>00:53:54,280 –&gt; 00:53:55,280<br>Yes.</p>
<p>978<br>00:53:55,280 –&gt; 00:54:05,480<br>Is this stored in a special database file or is it stored along with other pages?</p>
<p>979<br>00:54:05,480 –&gt; 00:54:07,800<br>What do you mean by it’s special?</p>
<p>980<br>00:54:07,800 –&gt; 00:54:09,120<br>Just like a separate file?</p>
<p>981<br>00:54:09,120 –&gt; 00:54:10,120<br>Yes.</p>
<p>982<br>00:54:10,120 –&gt; 00:54:12,440<br>So some says it’s a separate file.</p>
<p>983<br>00:54:12,440 –&gt; 00:54:16,600<br>SQLite was stored in the header of the file.</p>
<p>984<br>00:54:16,600 –&gt; 00:54:18,600<br>Particularly stored separately.</p>
<p>985<br>00:54:18,600 –&gt; 00:54:19,600<br>Yes.</p>
<p>986<br>00:54:20,119 –&gt; 00:54:21,119<br>Yes.</p>
<p>987<br>00:54:21,119 –&gt; 00:54:33,039<br>So this question is, when I say a data system can use multiple files, what I mean within</p>
<p>988<br>00:54:33,039 –&gt; 00:54:36,799<br>one table does it contain multiple files or within the database does contain multiple</p>
<p>989<br>00:54:36,799 –&gt; 00:54:37,799<br>files?</p>
<p>990<br>00:54:37,799 –&gt; 00:54:38,799<br>Yes.</p>
<p>991<br>00:54:38,799 –&gt; 00:54:39,799<br>Anyone?</p>
<p>992<br>00:54:39,799 –&gt; 00:54:40,799<br>Does it?</p>
<p>993<br>00:54:40,799 –&gt; 00:54:45,759<br>So does the user one file for all the tables say, SQLite?</p>
<p>994<br>00:54:45,759 –&gt; 00:54:48,519<br>But I mean, we can pop up and press grass and just look in the data record.</p>
<p>995<br>00:54:48,519 –&gt; 00:54:52,239<br>There’s a bunch of files in there that have numbers in them and there are various data</p>
<p>996<br>00:54:52,239 –&gt; 00:54:53,239<br>files.</p>
<p>997<br>00:54:53,239 –&gt; 00:54:54,239<br>And sometimes they’ll be for indexes.</p>
<p>998<br>00:54:54,239 –&gt; 00:54:55,599<br>Sometimes they’ll be for tables.</p>
<p>999<br>00:54:55,599 –&gt; 00:54:56,599<br>Right?</p>
<p>1000<br>00:54:56,599 –&gt; 00:54:59,039<br>And the various systems do different things.</p>
<p>1001<br>00:54:59,039 –&gt; 00:55:03,559<br>And again, not to keep repeating myself, this is the beauty of SQL.</p>
<p>1002<br>00:55:03,559 –&gt; 00:55:04,559<br>I don’t know.</p>
<p>1003<br>00:55:04,559 –&gt; 00:55:05,559<br>Don’t care.</p>
<p>1004<br>00:55:05,559 –&gt; 00:55:08,199<br>In my SQL queries, whether I have one file or a thousand files, right?</p>
<p>1005<br>00:55:08,199 –&gt; 00:55:10,679<br>The data systems can decide how to do that.</p>
<p>1006<br>00:55:10,679 –&gt; 00:55:13,159<br>It just knows how to run your query for you.</p>
<p>1007<br>00:55:13,159 –&gt; 00:55:14,840<br>So again, different data systems do different things.</p>
<p>1008<br>00:55:14,840 –&gt; 00:55:20,280<br>Do you know that you want to use multiple files for one table?</p>
<p>1009<br>00:55:20,280 –&gt; 00:55:24,200<br>This question is, how do you know whether you want to use multiple files for one table?</p>
<p>1010<br>00:55:24,200 –&gt; 00:55:26,200<br>Again, it depends.</p>
<p>1011<br>00:55:26,200 –&gt; 00:55:35,320<br>So if we won’t talk about large columns yet, but like, see, you have a table that has a</p>
<p>1012<br>00:55:35,320 –&gt; 00:55:37,760<br>blob field or a text field.</p>
<p>1013<br>00:55:37,760 –&gt; 00:55:40,000<br>And that’s like 10 megabytes.</p>
<p>1014<br>00:55:40,000 –&gt; 00:55:43,920<br>You’d want to store that in separate pages, but maybe you want to store that compressed</p>
<p>1015<br>00:55:43,920 –&gt; 00:55:45,639<br>because there’s a bunch of text data.</p>
<p>1016<br>00:55:45,639 –&gt; 00:55:49,000<br>So you have the regular columns of the integers and floats, whatever.</p>
<p>1017<br>00:55:49,000 –&gt; 00:55:50,000<br>That’s sort of one file.</p>
<p>1018<br>00:55:50,000 –&gt; 00:55:53,360<br>And then your large stuff is sort of another file, right?</p>
<p>1019<br>00:55:53,360 –&gt; 00:55:55,519<br>So that’s one approach, but you can imagine also too.</p>
<p>1020<br>00:55:55,519 –&gt; 00:55:59,519<br>Maybe you just have some space in a single file with the top parts of the fixed stuff,</p>
<p>1021<br>00:55:59,519 –&gt; 00:56:01,240<br>the bottom of the barrel length.</p>
<p>1022<br>00:56:01,240 –&gt; 00:56:02,240<br>It depends.</p>
<p>1023<br>00:56:02,240 –&gt; 00:56:11,039<br>I think my SQL, up to the 5.6, used to store, I think it was one file for all tables.</p>
<p>1024<br>00:56:11,039 –&gt; 00:56:16,400<br>All databases, and they mentioned, no, it was one file per database, and they split</p>
<p>1025<br>00:56:16,400 –&gt; 00:56:19,400<br>up to be one file in a per table.</p>
<p>1026<br>00:56:19,400 –&gt; 00:56:22,239<br>And separate files are indexes.</p>
<p>1027<br>00:56:22,239 –&gt; 00:56:23,239<br>Okay.</p>
<p>1028<br>00:56:23,239 –&gt; 00:56:30,320<br>All right, so now we know sort of roughly what the files look like or how the files are laid</p>
<p>1029<br>00:56:30,320 –&gt; 00:56:32,519<br>out and how we keep track of where they exist.</p>
<p>1030<br>00:56:32,519 –&gt; 00:56:37,800<br>So let’s not talk about what’s actually inside the pages themselves.</p>
<p>1031<br>00:56:37,800 –&gt; 00:56:43,400<br>Every page is going to have a header that’s going to tell you something about what the</p>
<p>1032<br>00:56:43,400 –&gt; 00:56:45,280<br>data actually is.</p>
<p>1033<br>00:56:45,280 –&gt; 00:56:50,360<br>So a common thing would be like the page size or like a check sum, right?</p>
<p>1034<br>00:56:50,360 –&gt; 00:56:54,800<br>So if you crash and come back or you start the system, actually anytime you fetch something</p>
<p>1035<br>00:56:54,800 –&gt; 00:57:00,640<br>from disk, you computer fast check to sum to make sure that the data isn’t corrupted.</p>
<p>1036<br>00:57:00,640 –&gt; 00:57:04,280<br>Maybe keep track of the version of the database system that actually created the page.</p>
<p>1037<br>00:57:04,280 –&gt; 00:57:07,680<br>That way if like you put it into a version that breaks compatibility, you can have</p>
<p>1038<br>00:57:07,679 –&gt; 00:57:10,839<br>some code that knows how to still read the old data.</p>
<p>1039<br>00:57:10,839 –&gt; 00:57:14,559<br>We won’t talk about transactions until after the midterm, but like you can keep track of</p>
<p>1040<br>00:57:14,559 –&gt; 00:57:18,879<br>like what thread or what transaction wrote to what data in this and whether it’s actually</p>
<p>1041<br>00:57:18,879 –&gt; 00:57:22,000<br>visible to whatever, whatever query you’re running.</p>
<p>1042<br>00:57:22,000 –&gt; 00:57:27,440<br>If the data is compressed or encoded in a certain way, which we’ll discuss next week,</p>
<p>1043<br>00:57:27,440 –&gt; 00:57:30,839<br>there’ll be metadata about what, how, what the question scheme actually is.</p>
<p>1044<br>00:57:30,839 –&gt; 00:57:35,559<br>There’ll be information about what the, the schema is or what the table schema is as we</p>
<p>1045<br>00:57:35,559 –&gt; 00:57:37,199<br>talk about Oracle does.</p>
<p>1046<br>00:57:37,199 –&gt; 00:57:41,320<br>Sometimes there’s additional statistics about what’s in the data itself.</p>
<p>1047<br>00:57:41,320 –&gt; 00:57:45,199<br>So like for a given column, what’s the min value and the max value?</p>
<p>1048<br>00:57:45,199 –&gt; 00:57:48,559<br>Because maybe I just need to read that instead of actually reading the data to figure out</p>
<p>1049<br>00:57:48,559 –&gt; 00:57:50,840<br>whether there’s something I need.</p>
<p>1050<br>00:57:50,840 –&gt; 00:57:51,840<br>Right?</p>
<p>1051<br>00:57:51,840 –&gt; 00:57:56,360<br>And again, as we are discussed, Oracle is famously self-contained, but not all systems</p>
<p>1052<br>00:57:56,360 –&gt; 00:58:00,199<br>do that.</p>
<p>1053<br>00:58:00,199 –&gt; 00:58:05,320<br>So now within the page itself, we need to decide how we actually want to organize the</p>
<p>1054<br>00:58:05,320 –&gt; 00:58:06,320<br>tuple data.</p>
<p>1055<br>00:58:06,320 –&gt; 00:58:07,320<br>Right?</p>
<p>1056<br>00:58:07,320 –&gt; 00:58:10,800<br>So at this point in this lecture, we’re going to assume that we’re only storing tuples</p>
<p>1057<br>00:58:10,800 –&gt; 00:58:11,800<br>in our pages.</p>
<p>1058<br>00:58:11,800 –&gt; 00:58:13,640<br>We’ll discuss indexes later.</p>
<p>1059<br>00:58:13,640 –&gt; 00:58:17,840<br>And then we’re going to assume that we’re storing tuples in a row oriented manner.</p>
<p>1060<br>00:58:17,840 –&gt; 00:58:21,960<br>Meaning like if I have five attributes, I will have a, I will have a tuple and I’ll have</p>
<p>1061<br>00:58:21,960 –&gt; 00:58:25,519<br>those five attributes continuously before I see the next tuple.</p>
<p>1062<br>00:58:25,519 –&gt; 00:58:28,760<br>Next, or next week we’ll see about column stores where you store this slightly different.</p>
<p>1063<br>00:58:28,760 –&gt; 00:58:33,800<br>But for our purposes here, we assume it’s, that’s row oriented and we’ll break this</p>
<p>1064<br>00:58:33,800 –&gt; 00:58:34,800<br>next week.</p>
<p>1065<br>00:58:35,519 –&gt; 00:58:39,120<br>All right, so there’s 300 approaches of what could actually be in our pages.</p>
<p>1066<br>00:58:39,120 –&gt; 00:58:42,960<br>So the tuple oriented storage where we’re only storing tuples and the exact values that</p>
<p>1067<br>00:58:42,960 –&gt; 00:58:46,960<br>those tuples have, there’ll be a log structured approach where we just store deltiles of what</p>
<p>1068<br>00:58:46,960 –&gt; 00:58:52,320<br>changed since the last time, since the last time these tuples updated.</p>
<p>1069<br>00:58:52,320 –&gt; 00:58:54,760<br>And that should be indexed organized.</p>
<p>1070<br>00:58:54,760 –&gt; 00:59:00,600<br>Indexed organized storage would be, it could be like a tree structure where in the leaf</p>
<p>1071<br>00:59:00,600 –&gt; 00:59:03,120<br>nodes, I’m actually storing the data itself.</p>
<p>1072<br>00:59:03,119 –&gt; 00:59:07,440<br>So today’s lecture, we’re only going to talk about the first one, tuple and storage.</p>
<p>1073<br>00:59:07,440 –&gt; 00:59:10,039<br>And then next week we’ll talk about the two other approaches.</p>
<p>1074<br>00:59:10,039 –&gt; 00:59:11,039<br>Okay?</p>
<p>1075<br>00:59:11,039 –&gt; 00:59:15,440<br>All right, so let’s think about how do we actually want to store tuples in our pages?</p>
<p>1076<br>00:59:15,440 –&gt; 00:59:16,440<br>Right?</p>
<p>1077<br>00:59:16,440 –&gt; 00:59:20,159<br>So let’s say we have a really simple approach where in our page header, we just keep track</p>
<p>1078<br>00:59:20,159 –&gt; 00:59:23,719<br>of the number of tuples that we have.</p>
<p>1079<br>00:59:23,719 –&gt; 00:59:28,679<br>And anytime we want to insert a new tuple, we just append to the end.</p>
<p>1080<br>00:59:28,679 –&gt; 00:59:29,679<br>Right?</p>
<p>1081<br>00:59:29,679 –&gt; 00:59:31,480<br>So we can assume our data’s fixed length.</p>
<p>1082<br>00:59:31,480 –&gt; 00:59:36,360<br>So if I want to insert a new tuple, I just go look at the header, see the number of tuples,</p>
<p>1083<br>00:59:36,360 –&gt; 00:59:38,719<br>multiply that by the size of the tuple.</p>
<p>1084<br>00:59:38,719 –&gt; 00:59:43,719<br>And that tells me where offset I want to write the page.</p>
<p>1085<br>00:59:43,719 –&gt; 00:59:45,719<br>Which one?</p>
<p>1086<br>00:59:45,719 –&gt; 00:59:47,240<br>Oh, lantern fly.</p>
<p>1087<br>00:59:47,240 –&gt; 00:59:50,240<br>Just kill it.</p>
<p>1088<br>00:59:50,240 –&gt; 00:59:58,240<br>Is anybody wanting to keep that alive?</p>
<p>1089<br>00:59:58,239 –&gt; 01:00:02,079<br>For those in YouTube, we have a lantern fly infestation.</p>
<p>1090<br>01:00:02,079 –&gt; 01:00:04,079<br>All right.</p>
<p>1091<br>01:00:04,079 –&gt; 01:00:05,079<br>Right?</p>
<p>1092<br>01:00:05,079 –&gt; 01:00:09,439<br>So is this a good idea or bad idea?</p>
<p>1093<br>01:00:09,439 –&gt; 01:00:11,239<br>I said straw man, so obviously a bad idea.</p>
<p>1094<br>01:00:11,239 –&gt; 01:00:12,239<br>Or why is it a bad idea?</p>
<p>1095<br>01:00:12,239 –&gt; 01:00:17,719<br>If you have to delete a tuple, then it just stores everything out of order.</p>
<p>1096<br>01:00:17,719 –&gt; 01:00:18,719<br>Right?</p>
<p>1097<br>01:00:18,719 –&gt; 01:00:23,519<br>So if I delete a tuple, I delete tuple 2, if there was everything at order.</p>
<p>1098<br>01:00:23,519 –&gt; 01:00:24,519<br>Right?</p>
<p>1099<br>01:00:25,239 –&gt; 01:00:28,679<br>What I want to be able to do is insert a new tuple.</p>
<p>1100<br>01:00:28,679 –&gt; 01:00:31,960<br>And I don’t want to put it at the end, I want to use this spot here.</p>
<p>1101<br>01:00:31,960 –&gt; 01:00:33,800<br>So number of tuples is enough.</p>
<p>1102<br>01:00:33,800 –&gt; 01:00:39,000<br>It made a keep track of where things are located, second side, where to put them in.</p>
<p>1103<br>01:00:39,000 –&gt; 01:00:42,400<br>But it’s going beyond what I’m showing here.</p>
<p>1104<br>01:00:42,400 –&gt; 01:00:44,239<br>What’s another obvious problem?</p>
<p>1105<br>01:00:44,239 –&gt; 01:00:46,639<br>One of the tuples is like the new store on the page.</p>
<p>1106<br>01:00:46,639 –&gt; 01:00:49,519<br>He said one of the tuples is too big to store in the page.</p>
<p>1107<br>01:00:49,519 –&gt; 01:00:52,599<br>Yes, but also what if they’re not fixed length?</p>
<p>1108<br>01:00:52,599 –&gt; 01:00:55,639<br>Which most data is, is not fixed length.</p>
<p>1109<br>01:00:55,639 –&gt; 01:00:58,519<br>Email addresses aren’t the same size.</p>
<p>1110<br>01:00:58,519 –&gt; 01:01:00,759<br>Android IDs aren’t always the same size.</p>
<p>1111<br>01:01:00,759 –&gt; 01:01:02,719<br>Now I can just sort of just a chart type, but what does that do?</p>
<p>1112<br>01:01:02,719 –&gt; 01:01:05,039<br>That preallocates the space I need.</p>
<p>1113<br>01:01:05,039 –&gt; 01:01:10,719<br>And if the largest email address is one kilobyte, then I have to store one kilobyte</p>
<p>1114<br>01:01:10,719 –&gt; 01:01:14,880<br>for every single email address, even though it’s not going to be using that space.</p>
<p>1115<br>01:01:14,880 –&gt; 01:01:19,319<br>Then his comment is, well, what if the table can’t fit in this page?</p>
<p>1116<br>01:01:19,319 –&gt; 01:01:21,199<br>How do I spam multiple pages?</p>
<p>1117<br>01:01:21,199 –&gt; 01:01:26,000<br>We’ll discuss that next week, but also this also would not work.</p>
<p>1118<br>01:01:26,000 –&gt; 01:01:27,639<br>So clearly, this is not enough for us.</p>
<p>1119<br>01:01:27,639 –&gt; 01:01:34,159<br>We need additional embedded to keep track of how we’re going to store this.</p>
<p>1120<br>01:01:34,159 –&gt; 01:01:42,000<br>Another problem too is, again, if four couldn’t go here, I couldn’t fill the gap when I deleted</p>
<p>1121<br>01:01:42,000 –&gt; 01:01:43,000<br>two.</p>
<p>1122<br>01:01:43,000 –&gt; 01:01:46,039<br>If four needs to go here, then I’m wasting space.</p>
<p>1123<br>01:01:46,039 –&gt; 01:01:50,879<br>But if I want to maybe move three up, but now I have to tell the rest of the system that</p>
<p>1124<br>01:01:50,880 –&gt; 01:01:57,320<br>I moved three, because I haven’t told you how I’m pointing to three, how I find three,</p>
<p>1125<br>01:01:57,320 –&gt; 01:02:00,760<br>but assuming it’s going to be like some offset within this page.</p>
<p>1126<br>01:02:00,760 –&gt; 01:02:05,079<br>But now if I’m moving three, then I have to go update every possible index that is maybe</p>
<p>1127<br>01:02:05,079 –&gt; 01:02:06,079<br>pointing to it.</p>
<p>1128<br>01:02:06,079 –&gt; 01:02:10,119<br>And that’s going to be super expensive.</p>
<p>1129<br>01:02:10,119 –&gt; 01:02:15,079<br>So the most common approach to handle this problem is called it’s Slotted Pages.</p>
<p>1130<br>01:02:15,079 –&gt; 01:02:19,200<br>And what I’ll describe here isn’t going to be exactly how every system does this, but</p>
<p>1131<br>01:02:19,199 –&gt; 01:02:21,119<br>at a high level, this is what everyone is doing.</p>
<p>1132<br>01:02:21,119 –&gt; 01:02:26,319<br>If you’re a row-oriented database system that’s using tuple-oriented pages, so not log</p>
<p>1133<br>01:02:26,319 –&gt; 01:02:30,079<br>structured, then they’re doing something that looks like this.</p>
<p>1134<br>01:02:30,079 –&gt; 01:02:34,359<br>So we’re going to have a header, and keep track of all the metadata we talked about</p>
<p>1135<br>01:02:34,359 –&gt; 01:02:35,359<br>for.</p>
<p>1136<br>01:02:35,359 –&gt; 01:02:42,039<br>Then after the header, we’ll have the Slot array, where the, at every position in that</p>
<p>1137<br>01:02:42,039 –&gt; 01:02:48,199<br>Slot array is going to point to some tuple in our page.</p>
<p>1138<br>01:02:48,199 –&gt; 01:02:52,079<br>And the tuples will be starting at the bottom, at the end of the page.</p>
<p>1139<br>01:02:52,079 –&gt; 01:02:55,759<br>So at the bottom, we’ll have all the fixed length and bar length tuple data.</p>
<p>1140<br>01:02:55,759 –&gt; 01:02:58,719<br>For now, assume that everything is put together.</p>
<p>1141<br>01:02:58,719 –&gt; 01:03:03,679<br>So meaning like, if you have a really large value, it isn’t stored in separate page.</p>
<p>1142<br>01:03:03,679 –&gt; 01:03:07,679<br>The entire tuple has to be stored inside this page.</p>
<p>1143<br>01:03:07,679 –&gt; 01:03:12,319<br>And so the Slot array is just going to be storing fixed length offsets to where to find</p>
<p>1144<br>01:03:12,319 –&gt; 01:03:15,439<br>the starting location of individual tuples.</p>
<p>1145<br>01:03:15,440 –&gt; 01:03:21,599<br>And maybe you could also store the size and the tuple in the header if you wanted to.</p>
<p>1146<br>01:03:21,599 –&gt; 01:03:29,440<br>So now what’s going to happen is, as we need to update the table and add new pages, sorry,</p>
<p>1147<br>01:03:29,440 –&gt; 01:03:33,480<br>add new tuples inside the page, the Slot array is going to grow from the beginning to the</p>
<p>1148<br>01:03:33,480 –&gt; 01:03:34,800<br>end.</p>
<p>1149<br>01:03:34,800 –&gt; 01:03:39,679<br>And then all our tuple data is going to grow from the end to the beginning.</p>
<p>1150<br>01:03:39,679 –&gt; 01:03:44,519<br>And at any single time, I add a new entry into my Slot array, sorry, new tuple.</p>
<p>1151<br>01:03:44,519 –&gt; 01:03:51,159<br>I update the Slot array to tell me where to go find it.</p>
<p>1152<br>01:03:51,159 –&gt; 01:03:56,639<br>So now if I go back to the problem I had before where I say I deleted tuple 3, well, this</p>
<p>1153<br>01:03:56,639 –&gt; 01:04:00,559<br>is fine because I didn’t move any other tuples.</p>
<p>1154<br>01:04:00,559 –&gt; 01:04:03,639<br>The Slot array for four still points to it.</p>
<p>1155<br>01:04:03,639 –&gt; 01:04:07,679<br>So I don’t have to tell any other part of the system that I moved for.</p>
<p>1156<br>01:04:07,679 –&gt; 01:04:13,280<br>But even if I now want to reclaim this space that I’ve been or three used to be and I’ve</p>
<p>1157<br>01:04:13,280 –&gt; 01:04:20,240<br>deleted, if I want to slide three or four over to take to compact it, all they need to</p>
<p>1158<br>01:04:20,240 –&gt; 01:04:27,640<br>do now is just update the Slot array to point to the new offset, which is easy to do.</p>
<p>1159<br>01:04:27,640 –&gt; 01:04:28,640<br>I don’t have to.</p>
<p>1160<br>01:04:28,640 –&gt; 01:04:30,240<br>Again, relational model says I don’t have to do this.</p>
<p>1161<br>01:04:30,240 –&gt; 01:04:31,240<br>Some systems do.</p>
<p>1162<br>01:04:31,240 –&gt; 01:04:32,240<br>Some systems don’t.</p>
<p>1163<br>01:04:32,240 –&gt; 01:04:34,240<br>We’ll see this in a second.</p>
<p>1164<br>01:04:34,240 –&gt; 01:04:37,480<br>And this is all fine.</p>
<p>1165<br>01:04:37,480 –&gt; 01:04:40,240<br>So this is what SQLite does.</p>
<p>1166<br>01:04:40,239 –&gt; 01:04:41,239<br>This is what Postgres does.</p>
<p>1167<br>01:04:41,239 –&gt; 01:04:42,239<br>This is what my SQL does.</p>
<p>1168<br>01:04:42,239 –&gt; 01:04:44,239<br>SQL server does this.</p>
<p>1169<br>01:04:44,239 –&gt; 01:04:46,000<br>This Slot page is the most common approach.</p>
<p>1170<br>01:04:46,000 –&gt; 01:04:50,239<br>This is what everyone does.</p>
<p>1171<br>01:04:50,239 –&gt; 01:04:51,239<br>Yes.</p>
<p>1172<br>01:04:51,239 –&gt; 01:04:55,239<br>Do you think you use the Slot number starting?</p>
<p>1173<br>01:04:55,239 –&gt; 01:04:56,239<br>Like if you are doing something wrong.</p>
<p>1174<br>01:04:56,239 –&gt; 01:05:00,559<br>So this question is, can I reuse Slot position three if I start a new tuple?</p>
<p>1175<br>01:05:00,559 –&gt; 01:05:01,559<br>Yes.</p>
<p>1176<br>01:05:01,559 –&gt; 01:05:03,559<br>But I don’t have to put that in front of four.</p>
<p>1177<br>01:05:03,559 –&gt; 01:05:04,559<br>I can put it anywhere.</p>
<p>1178<br>01:05:04,559 –&gt; 01:05:05,559<br>Other questions?</p>
<p>1179<br>01:05:06,559 –&gt; 01:05:07,559<br>Yes.</p>
<p>1180<br>01:05:07,559 –&gt; 01:05:12,559<br>What does this call be like wasting a small amount of memory?</p>
<p>1181<br>01:05:12,559 –&gt; 01:05:15,559<br>It’s like the people are like that.</p>
<p>1182<br>01:05:15,559 –&gt; 01:05:16,559<br>Yeah.</p>
<p>1183<br>01:05:16,559 –&gt; 01:05:23,559<br>So her statement is her question is, wouldn’t this be wasting space if the tuples are variable</p>
<p>1184<br>01:05:23,559 –&gt; 01:05:24,559<br>length?</p>
<p>1185<br>01:05:24,559 –&gt; 01:05:25,559<br>Yeah.</p>
<p>1186<br>01:05:25,559 –&gt; 01:05:32,559<br>So again, my tuples are growing from the tuple data is going from the end to the beginning.</p>
<p>1187<br>01:05:32,559 –&gt; 01:05:34,559<br>Slot array is going from the beginning to the end.</p>
<p>1188<br>01:05:34,559 –&gt; 01:05:39,559<br>At some point I’m going to run out of space and there might be a little space in the middle</p>
<p>1189<br>01:05:39,559 –&gt; 01:05:40,559<br>that I can’t use for anything.</p>
<p>1190<br>01:05:40,559 –&gt; 01:05:41,559<br>Is that wasted?</p>
<p>1191<br>01:05:41,559 –&gt; 01:05:42,559<br>Yes.</p>
<p>1192<br>01:05:42,559 –&gt; 01:05:49,559<br>But the advantage we get of not having to update other things any time we shuffle the order</p>
<p>1193<br>01:05:49,559 –&gt; 01:05:58,559<br>of the Slot array is worth that cost.</p>
<p>1194<br>01:05:58,559 –&gt; 01:05:59,559<br>Okay.</p>
<p>1195<br>01:06:00,559 –&gt; 01:06:09,559<br>So now assuming we’re sort of thinking of Slot array pages, now we need to wait to identify tuples.</p>
<p>1196<br>01:06:09,559 –&gt; 01:06:13,559<br>And this, or this one we’re going to use, this was the notion of a record ID.</p>
<p>1197<br>01:06:13,559 –&gt; 01:06:16,559<br>Different data systems might call this the row ID or the row number.</p>
<p>1198<br>01:06:16,559 –&gt; 01:06:26,559<br>But the high level, the way to think about it is a way to uniquely identify some logical tuple based on its physical location inside of a file</p>
<p>1199<br>01:06:26,559 –&gt; 01:06:27,559<br>page.</p>
<p>1200<br>01:06:27,559 –&gt; 01:06:36,559<br>And it’s typically going to be a combination of like a file number, an ID number, the page number, and then the slot number that corresponds where they exist in that Slot array.</p>
<p>1201<br>01:06:36,559 –&gt; 01:06:43,559<br>So that when you want to do a lookup, say, I need this tuple, if you have the record ID, you would then look in the page directory and</p>
<p>1202<br>01:06:43,559 –&gt; 01:06:45,559<br>figure out what page has it.</p>
<p>1203<br>01:06:45,559 –&gt; 01:06:53,559<br>To go grab that page, then use the slot number inside the Slot array to figure out where the, you know, what offset inside that page has the data you’re looking for.</p>
<p>1204<br>01:06:54,559 –&gt; 01:06:56,559<br>So most data, this is not stored this record ID.</p>
<p>1205<br>01:06:56,559 –&gt; 01:06:58,559<br>This is something that synthesize materialize.</p>
<p>1206<br>01:06:58,559 –&gt; 01:07:08,559<br>Again, based on the page directory, you know, of, of, of, or how you keep track of how to find things, meaning like within the tuple data itself, I’m not storing this record ID.</p>
<p>1207<br>01:07:08,559 –&gt; 01:07:13,559<br>SQLite does store this as a separate column that you, not supposed to see, but you can get to it.</p>
<p>1208<br>01:07:13,559 –&gt; 01:07:22,559<br>And the way they do the reason why they do this is because this is how they’re going to, they’re going to use this as the primary key to allow them to identify individual tuples.</p>
<p>1209<br>01:07:23,559 –&gt; 01:07:28,559<br>So if I get, we haven’t talked about secondary indexes, but I have an index that’s not the primary key index.</p>
<p>1210<br>01:07:28,559 –&gt; 01:07:37,559<br>My, my value when I, when I do, when I do my lookup on a key is going to be that row ID, which I then use on the primary key row ID index, the find the data I need.</p>
<p>1211<br>01:07:37,559 –&gt; 01:07:40,559<br>Different systems do different things.</p>
<p>1212<br>01:07:40,559 –&gt; 01:07:44,559<br>So the size of this is going to vary based on implementation.</p>
<p>1213<br>01:07:44,559 –&gt; 01:07:46,559<br>So postgres is going to be six, six bytes.</p>
<p>1214<br>01:07:46,559 –&gt; 01:07:49,559<br>SQLite is going to be eight bytes or 64 bits.</p>
<p>1215<br>01:07:49,559 –&gt; 01:07:55,559<br>SQL Server has an eight byte one and then Oracle has a 10 byte record ID.</p>
<p>1216<br>01:07:55,559 –&gt; 01:07:58,559<br>Again, you can see this directly in the database system.</p>
<p>1217<br>01:07:58,559 –&gt; 01:08:01,559<br>So we can do a quick demo just to show you all this.</p>
<p>1218<br>01:08:04,559 –&gt; 01:08:07,559<br>So you’re not supposed to use this in your application, right?</p>
<p>1219<br>01:08:07,559 –&gt; 01:08:14,559<br>So even though this would uniquely identify a, a tuple, again, it’s, it’s the physical location of it.</p>
<p>1220<br>01:08:14,559 –&gt; 01:08:33,559<br>And it could change, meaning like if I insert a tuple and I get a record ID, if I, if my application then references it, the problem could be like I could run compaction or garbage collection or in postgres is called the vacuum, where I could reorganize that page where maybe now the slot number changes or the page number changes.</p>
<p>1221<br>01:08:33,559 –&gt; 01:08:35,559<br>And now the thing I’m looking for isn’t there anymore.</p>
<p>1222<br>01:08:35,560 –&gt; 01:08:47,560<br>So again, this is the physical aspect of the database system that we’re not supposed to really use in our application, but it’s exposed to us because if we need to administer and maintain these systems, we need to know where the data actually is.</p>
<p>1223<br>01:08:50,560 –&gt; 01:08:53,560<br>So let me log in, okay, sorry.</p>
<p>1224<br>01:08:53,560 –&gt; 01:09:03,560<br>I’m going to need to reconnect, sorry.</p>
<p>1225<br>01:09:03,560 –&gt; 01:09:06,560<br>All right, so we do postgres first.</p>
<p>1226<br>01:09:06,560 –&gt; 01:09:13,560<br>So we’re going to create a really simple table R that just has three tuples.</p>
<p>1227<br>01:09:14,560 –&gt; 01:09:18,560<br>Right, 101, 101, 102.</p>
<p>1228<br>01:09:18,560 –&gt; 01:09:21,560<br>So postgres has something called the CTID.</p>
<p>1229<br>01:09:21,560 –&gt; 01:09:29,560<br>And this is going to be a tuple now that’s going to give you the page number and then the slot number.</p>
<p>1230<br>01:09:29,560 –&gt; 01:09:34,560<br>So these tuples here are page zero, slot one, slot two, slot three.</p>
<p>1231<br>01:09:34,560 –&gt; 01:09:35,560<br>Right.</p>
<p>1232<br>01:09:35,560 –&gt; 01:09:42,560<br>So now if I, say I actually, the second tuple, I delete 101.</p>
<p>1233<br>01:09:43,560 –&gt; 01:09:53,560<br>Now when I do my scan, again, now you can see that postgres decided to delete the tuple, but it didn’t move things around.</p>
<p>1234<br>01:09:53,560 –&gt; 01:09:59,560<br>Right, I let the data where it actually, you know, where it actually lives.</p>
<p>1235<br>01:09:59,560 –&gt; 01:10:02,560<br>But now I can run garbage, the garbage collection.</p>
<p>1236<br>01:10:02,560 –&gt; 01:10:05,560<br>Actually, let me, let me start a tuple back.</p>
<p>1237<br>01:10:06,560 –&gt; 01:10:09,560<br>So I’m certain one of three.</p>
<p>1238<br>01:10:09,560 –&gt; 01:10:14,560<br>Now you can see again, it didn’t take that, that, that O2 slot from the first tuple I deleted.</p>
<p>1239<br>01:10:14,560 –&gt; 01:10:17,560<br>And just a pen it to the end put it in slot four.</p>
<p>1240<br>01:10:17,560 –&gt; 01:10:20,560<br>Right.</p>
<p>1241<br>01:10:20,560 –&gt; 01:10:28,560<br>So then I get, I can now run the, again, postgres, it’s called the vacuum.</p>
<p>1242<br>01:10:28,560 –&gt; 01:10:30,560<br>So the command is vacuum.</p>
<p>1243<br>01:10:30,560 –&gt; 01:10:31,560<br>Again, this is a postgres idiom.</p>
<p>1244<br>01:10:31,560 –&gt; 01:10:39,560<br>So vacuum four is going to have postgres basically compact every single page and write out a new, new, new pages, new files.</p>
<p>1245<br>01:10:39,560 –&gt; 01:10:42,560<br>So I have a bunch of pages that are, that are empty.</p>
<p>1246<br>01:10:42,560 –&gt; 01:10:46,560<br>It’ll, it’ll release them when it, when it creates a new version.</p>
<p>1247<br>01:10:46,560 –&gt; 01:10:49,560<br>So now when I do that same query before, right.</p>
<p>1248<br>01:10:49,560 –&gt; 01:10:51,560<br>Now you see decided to compact it, right.</p>
<p>1249<br>01:10:51,560 –&gt; 01:10:57,560<br>But one, but, oh, one, oh two, oh three, right.</p>
<p>1250<br>01:10:57,560 –&gt; 01:10:58,560<br>Makes sense?</p>
<p>1251<br>01:10:58,560 –&gt; 01:10:59,560<br>Yes.</p>
<p>1252<br>01:10:59,560 –&gt; 01:11:06,560<br>So is this, um, this is like, you refer to the, you know, page number and offset slot, slot number.</p>
<p>1253<br>01:11:06,560 –&gt; 01:11:11,560<br>So is it, is a slot number, like in the, like going backward or in the slot array?</p>
<p>1254<br>01:11:11,560 –&gt; 01:11:12,560<br>It’s in the slot array.</p>
<p>1255<br>01:11:12,560 –&gt; 01:11:13,560<br>Oh.</p>
<p>1256<br>01:11:13,560 –&gt; 01:11:16,560<br>Because then you use the slot array to say what offset it within the page, right.</p>
<p>1257<br>01:11:16,560 –&gt; 01:11:17,560<br>I find what I need.</p>
<p>1258<br>01:11:17,560 –&gt; 01:11:18,560<br>Yes.</p>
<p>1259<br>01:11:18,560 –&gt; 01:11:23,560<br>The slot array can be one index, because there’s something at zero, like metadata.</p>
<p>1260<br>01:11:23,560 –&gt; 01:11:28,560<br>So the question is, the, the slot array starts at zero index, even the page turns at zero index.</p>
<p>1261<br>01:11:28,560 –&gt; 01:11:34,560<br>Sorry, slot array starts at one index, page turns at zero index, is there something in, uh, in one.</p>
<p>1262<br>01:11:34,560 –&gt; 01:11:35,560<br>Let’s find out.</p>
<p>1263<br>01:11:35,560 –&gt; 01:11:40,560<br>So you’re not supposed to do this, but you can do, you can actually query this, right.</p>
<p>1264<br>01:11:40,560 –&gt; 01:11:46,560<br>C tidy equals, and oh, oh.</p>
<p>1265<br>01:11:46,560 –&gt; 01:11:48,560<br>That doesn’t have anything there.</p>
<p>1266<br>01:11:48,560 –&gt; 01:11:49,560<br>But I can get the other one.</p>
<p>1267<br>01:11:49,560 –&gt; 01:11:52,560<br>So I, I don’t know why they do that.</p>
<p>1268<br>01:11:52,560 –&gt; 01:11:53,560<br>Yes.</p>
<p>1269<br>01:11:53,560 –&gt; 01:11:58,560<br>So when you say the ID, it’s by, uh, on the, uh, what is that?</p>
<p>1270<br>01:11:58,560 –&gt; 01:12:01,560<br>You know, it’s basically, uh, the limit on the limit on the, uh, the limit.</p>
<p>1271<br>01:12:01,560 –&gt; 01:12:07,560<br>Same, same it is, um, when we say a slot, uh, the, the C tidy is going to be six bytes.</p>
<p>1272<br>01:12:07,560 –&gt; 01:12:11,560<br>So it’s probably a four byte page number, and then a two byte offset.</p>
<p>1273<br>01:12:11,560 –&gt; 01:12:14,560<br>Doesn’t that limit the number of slots we can have in a page?</p>
<p>1274<br>01:12:14,560 –&gt; 01:12:15,560<br>Yes.</p>
<p>1275<br>01:12:15,560 –&gt; 01:12:17,560<br>But postgres is by default is eight kilobyte page sizes.</p>
<p>1276<br>01:12:17,560 –&gt; 01:12:21,560<br>So you can’t have a billion two-poles in a single page.</p>
<p>1277<br>01:12:21,560 –&gt; 01:12:24,560<br>All right. So let’s, let’s look at all the systems.</p>
<p>1278<br>01:12:24,560 –&gt; 01:12:27,560<br>So again, SQLite is, it’s different.</p>
<p>1279<br>01:12:27,560 –&gt; 01:12:30,560<br>So SQLite, uh, you have this row ID.</p>
<p>1280<br>01:12:30,560 –&gt; 01:12:33,560<br>Again, and it’s actually storing this, right.</p>
<p>1281<br>01:12:33,560 –&gt; 01:12:35,560<br>It’s a 64 bit integer, and it actually stores this.</p>
<p>1282<br>01:12:35,560 –&gt; 01:12:38,560<br>So like, uh, it uses this as the primary key.</p>
<p>1283<br>01:12:38,560 –&gt; 01:12:39,560<br>Yes.</p>
<p>1284<br>01:12:39,560 –&gt; 01:12:44,560<br>So the size of the two will sort somewhere, typically in the header of the two-poles.</p>
<p>1285<br>01:12:44,560 –&gt; 01:12:47,560<br>Yes.</p>
<p>1286<br>01:12:48,560 –&gt; 01:12:52,560<br>All right. So this, so if we delete from, uh,</p>
<p>1287<br>01:12:52,560 –&gt; 01:12:55,560<br>what will delete a two-pole?</p>
<p>1288<br>01:12:55,560 –&gt; 01:12:57,560<br>Around the same query, right?</p>
<p>1289<br>01:12:57,560 –&gt; 01:13:00,560<br>It does, it doesn’t reuse the row ID.</p>
<p>1290<br>01:13:00,560 –&gt; 01:13:03,560<br>Because it’s actually a physical thing of the primary key.</p>
<p>1291<br>01:13:03,560 –&gt; 01:13:10,560<br>All right. So let’s do now, SQL server.</p>
<p>1292<br>01:13:10,560 –&gt; 01:13:13,560<br>So SQL server has this different syntax.</p>
<p>1293<br>01:13:13,560 –&gt; 01:13:16,560<br>It has this double, as hard to see.</p>
<p>1294<br>01:13:16,560 –&gt; 01:13:19,560<br>If I highlight it, can you see it?</p>
<p>1295<br>01:13:19,560 –&gt; 01:13:21,560<br>No.</p>
<p>1296<br>01:13:21,560 –&gt; 01:13:23,560<br>There’s two percent, there’s percent signs there.</p>
<p>1297<br>01:13:23,560 –&gt; 01:13:27,560<br>Trust me.</p>
<p>1298<br>01:13:27,560 –&gt; 01:13:34,560<br>Sorry, let’s go back.</p>
<p>1299<br>01:13:34,560 –&gt; 01:13:36,560<br>All right, there you go.</p>
<p>1300<br>01:13:36,560 –&gt; 01:13:39,560<br>There’s percent signs. Sorry.</p>
<p>1301<br>01:13:39,560 –&gt; 01:13:43,560<br>So when you run this, you get back some, some hex data like this, right?</p>
<p>1302<br>01:13:43,560 –&gt; 01:13:45,560<br>What does this mean?</p>
<p>1303<br>01:13:45,560 –&gt; 01:13:48,560<br>So there is a undocumented command.</p>
<p>1304<br>01:13:48,560 –&gt; 01:13:52,560<br>Actually, this is all, like, this is all you’re not supposed to do this, but you can’t.</p>
<p>1305<br>01:13:52,560 –&gt; 01:13:54,560<br>Like it’s, it’s not documented.</p>
<p>1306<br>01:13:54,560 –&gt; 01:13:56,560<br>I mean, Microsoft doesn’t officially support this.</p>
<p>1307<br>01:13:56,560 –&gt; 01:14:00,560<br>But there is a command called whatever, this function here,</p>
<p>1308<br>01:14:00,560 –&gt; 01:14:02,560<br>and you pass in the physical location,</p>
<p>1309<br>01:14:02,560 –&gt; 01:14:06,560<br>and then you’ll get back now the formatted file number,</p>
<p>1310<br>01:14:06,560 –&gt; 01:14:10,560<br>the page number, and then the slot number, right?</p>
<p>1311<br>01:14:10,560 –&gt; 01:14:12,560<br>And you can actually, it’s interesting in,</p>
<p>1312<br>01:14:12,560 –&gt; 01:14:15,560<br>I learned this today, you can actually get back what the,</p>
<p>1313<br>01:14:15,560 –&gt; 01:14:17,560<br>that function is actually doing.</p>
<p>1314<br>01:14:17,560 –&gt; 01:14:21,560<br>So you can get it to spit back the, what it actually does.</p>
<p>1315<br>01:14:21,560 –&gt; 01:14:23,560<br>And you see here, whether they’re taking that physical location,</p>
<p>1316<br>01:14:23,560 –&gt; 01:14:26,560<br>and how they’re jumping to different bytes to get the,</p>
<p>1317<br>01:14:26,560 –&gt; 01:14:30,560<br>the page ID, file number, and the slot number, right?</p>
<p>1318<br>01:14:30,560 –&gt; 01:14:32,560<br>So let’s do the same thing we did before.</p>
<p>1319<br>01:14:32,560 –&gt; 01:14:35,560<br>Let’s delete 101.</p>
<p>1320<br>01:14:35,560 –&gt; 01:14:40,560<br>Then we’ll run the same query to get the page number offsets, right?</p>
<p>1321<br>01:14:40,560 –&gt; 01:14:44,560<br>So in this case here, it didn’t move anything, right?</p>
<p>1322<br>01:14:44,560 –&gt; 01:14:47,560<br>So now if we insert our tool back,</p>
<p>1323<br>01:14:47,560 –&gt; 01:14:52,560<br>or insert a new tool, run that same query.</p>
<p>1324<br>01:14:52,560 –&gt; 01:14:55,560<br>Now look what it did.</p>
<p>1325<br>01:14:55,560 –&gt; 01:15:00,560<br>So my tool for, with ID 102, that was that slot 2,</p>
<p>1326<br>01:15:00,560 –&gt; 01:15:05,560<br>but when I inserted the new tool, it moved that second tool 102</p>
<p>1327<br>01:15:05,560 –&gt; 01:15:09,560<br>into slot 2, and then put the, the new tool into slot 3.</p>
<p>1328<br>01:15:09,560 –&gt; 01:15:11,560<br>Postgres didn’t do that, right?</p>
<p>1329<br>01:15:11,560 –&gt; 01:15:14,560<br>Postgres just kept depending on the end.</p>
<p>1330<br>01:15:14,560 –&gt; 01:15:17,560<br>Is this wrong?</p>
<p>1331<br>01:15:17,560 –&gt; 01:15:20,560<br>Who knows?</p>
<p>1332<br>01:15:20,560 –&gt; 01:15:21,560<br>Is it better?</p>
<p>1333<br>01:15:21,560 –&gt; 01:15:22,560<br>Who knows?</p>
<p>1334<br>01:15:22,560 –&gt; 01:15:23,560<br>Right?</p>
<p>1335<br>01:15:23,560 –&gt; 01:15:27,560<br>And the reason why you can do this is because when you fetch a page</p>
<p>1336<br>01:15:27,560 –&gt; 01:15:30,560<br>and bring it to memory, and you start, you know,</p>
<p>1337<br>01:15:30,560 –&gt; 01:15:34,560<br>inserting a tuple into it, you’re holding the latch or the lock on that page,</p>
<p>1338<br>01:15:34,560 –&gt; 01:15:37,560<br>the, the data is going to decide whether once you do compaction</p>
<p>1339<br>01:15:37,560 –&gt; 01:15:40,560<br>or whatever the optimization wants to do, because it knows that no of the thread</p>
<p>1340<br>01:15:40,560 –&gt; 01:15:42,560<br>can write to that page at the same time.</p>
<p>1341<br>01:15:42,560 –&gt; 01:15:46,560<br>So we can decide whether or not we want to, you know,</p>
<p>1342<br>01:15:46,560 –&gt; 01:15:50,560<br>compact it or not as we do it. Postgres doesn’t do it, SQL Server does.</p>
<p>1343<br>01:15:50,560 –&gt; 01:15:55,560<br>All right, this is the good everyone’s favorite Oracle.</p>
<p>1344<br>01:15:55,560 –&gt; 01:16:00,560<br>I need to create the table first, I think.</p>
<p>1345<br>01:16:00,560 –&gt; 01:16:05,560<br>I don’t think it’s going to let me do that.</p>
<p>1346<br>01:16:05,560 –&gt; 01:16:13,560<br>No, it did. All right, so, so in Oracle, they have a row ID, right?</p>
<p>1347<br>01:16:13,560 –&gt; 01:16:18,560<br>But you get, again, some binary data here, right?</p>
<p>1348<br>01:16:18,560 –&gt; 01:16:22,560<br>Again, this is stack of a flow, this is not me,</p>
<p>1349<br>01:16:22,560 –&gt; 01:16:26,560<br>but there’s much of function you can do around this, right?</p>
<p>1350<br>01:16:26,560 –&gt; 01:16:29,560<br>And then you see now they’re storing an logic ID, a file number,</p>
<p>1351<br>01:16:29,560 –&gt; 01:16:34,560<br>a block number, or the page number, and then the row slot, right?</p>
<p>1352<br>01:16:34,560 –&gt; 01:16:37,560<br>So again, this is something, taking something that’s defined in the textbook,</p>
<p>1353<br>01:16:37,560 –&gt; 01:16:41,560<br>describing it like a logical level, or describing it as a theoretical level,</p>
<p>1354<br>01:16:41,560 –&gt; 01:16:44,560<br>here’s how to organize your database system, and then you can see different</p>
<p>1355<br>01:16:44,560 –&gt; 01:16:48,560<br>invitations of it. Through SQL, you can then see how they are storing slots,</p>
<p>1356<br>01:16:48,560 –&gt; 01:16:53,560<br>sort of things in a lot of pages. All right?</p>
<p>1357<br>01:16:53,560 –&gt; 01:17:02,560<br>All right, so in the sake of time, I think I’m going to skip.</p>
<p>1358<br>01:17:02,560 –&gt; 01:17:12,560<br>I mean, this will segue into next class, but the two-bow itself is just going to be a sequence of bytes, right?</p>
<p>1359<br>01:17:12,560 –&gt; 01:17:15,560<br>There’s some header, and then a byte sequence.</p>
<p>1360<br>01:17:15,560 –&gt; 01:17:19,560<br>And then it’s up for the database system to know how to interpret those bytes based on the type,</p>
<p>1361<br>01:17:19,560 –&gt; 01:17:23,560<br>and, you know, based on the values that nature looking at.</p>
<p>1362<br>01:17:23,560 –&gt; 01:17:26,560<br>So again, we’ll cover this next class, but the way to think about this is like,</p>
<p>1363<br>01:17:26,560 –&gt; 01:17:29,560<br>there’ll be some header that contains information about whether this two-bow’s,</p>
<p>1364<br>01:17:29,560 –&gt; 01:17:32,560<br>this or not, we can store it, you know, whether or not we want to store,</p>
<p>1365<br>01:17:32,560 –&gt; 01:17:38,560<br>keep track of what columns have nulls, and then the execution engine will know how to get</p>
<p>1366<br>01:17:38,560 –&gt; 01:17:41,560<br>jumped to different offsets within the tuple based on the schema.</p>
<p>1367<br>01:17:41,560 –&gt; 01:17:48,560<br>So again, we’ll cover this in next class, but just to finish up,</p>
<p>1368<br>01:17:48,560 –&gt; 01:17:51,560<br>the, again, what are we discussed today?</p>
<p>1369<br>01:17:51,560 –&gt; 01:17:53,560<br>There’s a database system. It’s going to be stored, it’s going to be maintained database,</p>
<p>1370<br>01:17:53,560 –&gt; 01:17:58,560<br>a database is going to be tracked in, across different files, and it can broken up into pages,</p>
<p>1371<br>01:17:58,560 –&gt; 01:18:01,560<br>and then we have different ways of keep track of those pages, keep track of what’s</p>
<p>1372<br>01:18:01,560 –&gt; 01:18:04,560<br>and how to store things in those pages, and then next class we’ll talk about what</p>
<p>1373<br>01:18:04,560 –&gt; 01:18:06,560<br>how to store action to tuples, okay?</p>
<p>1374<br>01:18:06,560 –&gt; 01:18:10,560<br>So again, let’s go to the next class, have a good weekend, see ya, get in.</p>
<p>1375<br>01:18:28,560 –&gt; 01:18:33,560<br>I’m the poppy with the motherfucking ho-ho 28-a-gram, depending on if it’s the pop,</p>
<p>1376<br>01:18:33,560 –&gt; 01:18:37,560<br>you ain’t hit them all yet, still got your shirt up, I smack you with the bottom of the clip</p>
<p>1377<br>01:18:37,560 –&gt; 01:18:41,560<br>and tell you, look up, show me what it’s safe set for, I blow your face back,</p>
<p>1378<br>01:18:41,560 –&gt; 01:18:45,560<br>I got a block on tap, the fets can’t trace that, style is like temp, but proof,</p>
<p>1379<br>01:18:45,560 –&gt; 01:18:49,560<br>you can’t lace that, at the Dominicin, oh you the, call me Dominicin, black Skelly,</p>
<p>1380<br>01:18:49,560 –&gt; 01:18:54,560<br>black, nothing, black, sweat, dimmelins, my whole black, 38, send you to the purdigate,</p>
<p>1381<br>01:18:54,560 –&gt; 01:18:57,560<br>you get the zombie trying to skate, and that’s your first mistake,</p>
<p>1382<br>01:18:57,560 –&gt; 01:19:00,560<br>I ain’t lying for that cake, your family, see ya, wait, my grand’s is happy, wait,</p>
<p>1383<br>01:19:00,560 –&gt; 01:19:03,560<br>they ran through every state, were they acting how I’m living,</p>
<p>1384<br>01:19:03,560 –&gt; 01:19:05,560<br>I tell them I’m living great.</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CMU15445 P4F202303 DatabaseStoragePart1</div>
      <div>http://example.com/2025/10/24/CMU15445 P4F202303-DatabaseStoragePart1/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月24日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/24/CMU15445%20P5F202304-DatabaseStoragePart2/" title="CMU15445 P5F202304 DatabaseStoragePart2">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CMU15445 P5F202304 DatabaseStoragePart2</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/24/CMU15445%20P2F202301-RelationalModelAlgebra/" title="CMU15445 P2F202301 RelationalModelAlgebra">
                        <span class="hidden-mobile">CMU15445 P2F202301 RelationalModelAlgebra</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
