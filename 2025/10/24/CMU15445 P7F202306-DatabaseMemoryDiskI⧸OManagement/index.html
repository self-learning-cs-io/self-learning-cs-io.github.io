

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="100:00:00,000 –&gt; 00:00:09,220besonders system commit such a 200:00:09,220 –&gt; 00:00:30,660How was the concert on Saturday? 300:00:30,660 –&gt; 00:00:33,620Even though it might be a red line of bu">
<meta property="og:type" content="article">
<meta property="og:title" content="CMU15445 P7F202306 DatabaseMemoryDiskI⧸OManagement">
<meta property="og:url" content="http://example.com/2025/10/24/CMU15445%20P7F202306-DatabaseMemoryDiskI%E2%A7%B8OManagement/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="100:00:00,000 –&gt; 00:00:09,220besonders system commit such a 200:00:09,220 –&gt; 00:00:30,660How was the concert on Saturday? 300:00:30,660 –&gt; 00:00:33,620Even though it might be a red line of bu">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-24T12:00:44.480Z">
<meta property="article:modified_time" content="2025-10-24T12:06:28.543Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>CMU15445 P7F202306 DatabaseMemoryDiskI⧸OManagement - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CMU15445 P7F202306 DatabaseMemoryDiskI⧸OManagement"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-24 20:00" pubdate>
          2025年10月24日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          110 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">CMU15445 P7F202306 DatabaseMemoryDiskI⧸OManagement</h1>
            
            
              <div class="markdown-body">
                
                <p>1<br>00:00:00,000 –&gt; 00:00:09,220<br>besonders system commit such a</p>
<p>2<br>00:00:09,220 –&gt; 00:00:30,660<br>How was the concert on Saturday?</p>
<p>3<br>00:00:30,660 –&gt; 00:00:33,620<br>Even though it might be a red line of bunch of speakers.</p>
<p>4<br>00:00:33,620 –&gt; 00:00:34,859<br>What do you mean to red line speakers?</p>
<p>5<br>00:00:34,859 –&gt; 00:00:40,539<br>I mean, if the speaker can work at 100%, we were working at 200%.</p>
<p>6<br>00:00:40,539 –&gt; 00:00:41,979<br>Did you break them?</p>
<p>7<br>00:00:41,979 –&gt; 00:00:43,140<br>Next time maybe.</p>
<p>8<br>00:00:43,140 –&gt; 00:00:43,859<br>OK, nice.</p>
<p>9<br>00:00:43,859 –&gt; 00:00:44,420<br>All right.</p>
<p>10<br>00:00:44,420 –&gt; 00:00:45,619<br>How many of you showed up?</p>
<p>11<br>00:00:45,619 –&gt; 00:00:46,299<br>200?</p>
<p>12<br>00:00:46,299 –&gt; 00:00:46,619<br>200.</p>
<p>13<br>00:00:46,619 –&gt; 00:00:47,579<br>That’s impressive.</p>
<p>14<br>00:00:47,579 –&gt; 00:00:47,859<br>OK.</p>
<p>15<br>00:00:47,859 –&gt; 00:00:49,219<br>And your next show is when?</p>
<p>16<br>00:00:49,219 –&gt; 00:00:51,259<br>October, after the fall break.</p>
<p>17<br>00:00:51,259 –&gt; 00:00:52,299<br>That’s off campus, though.</p>
<p>18<br>00:00:52,299 –&gt; 00:00:52,820<br>OK.</p>
<p>19<br>00:00:52,820 –&gt; 00:00:53,980<br>We’ll post that on PSA.</p>
<p>20<br>00:00:53,980 –&gt; 00:00:54,460<br>All right, guys.</p>
<p>21<br>00:00:54,460 –&gt; 00:00:55,620<br>Lots of cover.</p>
<p>22<br>00:00:55,620 –&gt; 00:00:58,659<br>Some quick administrative things to cover quickly.</p>
<p>23<br>00:00:58,659 –&gt; 00:01:01,620<br>So the homework, too, has been out.</p>
<p>24<br>00:01:01,620 –&gt; 00:01:04,099<br>We bumped the due date to be October 4th,</p>
<p>25<br>00:01:04,099 –&gt; 00:01:09,219<br>because we didn’t want to have it lined up on the same date that Project 1 is due.</p>
<p>26<br>00:01:09,219 –&gt; 00:01:12,500<br>So the material problem, all it’s due, is the sketching with Labor Day,</p>
<p>27<br>00:01:12,500 –&gt; 00:01:13,099<br>everything.</p>
<p>28<br>00:01:13,099 –&gt; 00:01:15,140<br>So the material of that homework discusses things.</p>
<p>29<br>00:01:15,140 –&gt; 00:01:15,939<br>We’ll discuss next week.</p>
<p>30<br>00:01:15,939 –&gt; 00:01:17,659<br>So we postponed that a day.</p>
<p>31<br>00:01:17,659 –&gt; 00:01:18,899<br>And then Project 1 still on track.</p>
<p>32<br>00:01:18,899 –&gt; 00:01:20,619<br>We do October 2nd.</p>
<p>33<br>00:01:20,619 –&gt; 00:01:21,979<br>And again, that’s on a Sunday.</p>
<p>34<br>00:01:21,979 –&gt; 00:01:27,419<br>We’re having the Q&amp;A session today, Monday, 6.30 PM.</p>
<p>35<br>00:01:27,419 –&gt; 00:01:29,179<br>And that’ll be on Zoom.</p>
<p>36<br>00:01:29,179 –&gt; 00:01:31,299<br>And there’s a post on that in Piazza.</p>
<p>37<br>00:01:31,299 –&gt; 00:01:33,299<br>And then, as for all the projects again,</p>
<p>38<br>00:01:33,299 –&gt; 00:01:37,819<br>there won’t be any office hours on Sundays when the project is due.</p>
<p>39<br>00:01:37,819 –&gt; 00:01:40,259<br>But there’ll be a special office hour session</p>
<p>40<br>00:01:40,259 –&gt; 00:01:47,219<br>on the Saturday before it’s due on campus with like 4.0 TAs between 3 and 5 PM.</p>
<p>41<br>00:01:47,219 –&gt; 00:01:49,340<br>This meant to be a forcing function for you guys actually,</p>
<p>42<br>00:01:49,340 –&gt; 00:01:52,979<br>like, start working on the project instead of showing up the dates due to office hours.</p>
<p>43<br>00:01:52,979 –&gt; 00:01:55,340<br>And you know, it doesn’t compile, right?</p>
<p>44<br>00:01:55,340 –&gt; 00:02:00,060<br>We want you to start sooner rather than later, OK?</p>
<p>45<br>00:02:00,060 –&gt; 00:02:01,620<br>So many’s already gotten, I think there’s a couple of people already got</p>
<p>46<br>00:02:01,620 –&gt; 00:02:03,540<br>100% on Project 1.</p>
<p>47<br>00:02:03,540 –&gt; 00:02:07,980<br>Even though today’s lecture discusses Project 1, so impressive.</p>
<p>48<br>00:02:07,980 –&gt; 00:02:08,980<br>Yes.</p>
<p>49<br>00:02:08,980 –&gt; 00:02:10,300<br>How long do you expect it to be in Project 1?</p>
<p>50<br>00:02:10,300 –&gt; 00:02:11,539<br>Sorry, how much you expected what?</p>
<p>51<br>00:02:11,539 –&gt; 00:02:15,700<br>How much time do you expect the complete entire project?</p>
<p>52<br>00:02:15,700 –&gt; 00:02:20,060<br>It’s question is how much time should we expect to complete the entire project?</p>
<p>53<br>00:02:20,060 –&gt; 00:02:21,580<br>And it depends on your background.</p>
<p>54<br>00:02:21,580 –&gt; 00:02:23,500<br>Like, some people have ripped through C++, no problems.</p>
<p>55<br>00:02:23,500 –&gt; 00:02:26,580<br>Other people struggle, right?</p>
<p>56<br>00:02:26,580 –&gt; 00:02:30,219<br>Project 1 is, I mean, it’s more work than Project 0.</p>
<p>57<br>00:02:30,219 –&gt; 00:02:31,699<br>It’s less work than Project 1.</p>
<p>58<br>00:02:31,699 –&gt; 00:02:33,099<br>It’s reasonable.</p>
<p>59<br>00:02:33,099 –&gt; 00:02:35,099<br>It’s not bad.</p>
<p>60<br>00:02:35,099 –&gt; 00:02:36,060<br>Any other questions?</p>
<p>61<br>00:02:36,060 –&gt; 00:02:38,259<br>I’ll give you a little more.</p>
<p>62<br>00:02:38,259 –&gt; 00:02:42,259<br>All right, so a bunch of other things that are extra-crickly are things that you can do</p>
<p>63<br>00:02:42,259 –&gt; 00:02:43,460<br>in the class.</p>
<p>64<br>00:02:43,460 –&gt; 00:02:48,659<br>Today, we’re having another seminar talk from CME alum, Dana Van Aken.</p>
<p>65<br>00:02:48,659 –&gt; 00:02:50,060<br>Just talk about auto-tune.</p>
<p>66<br>00:02:50,060 –&gt; 00:02:51,699<br>Can I start up that I’m involved in?</p>
<p>67<br>00:02:51,699 –&gt; 00:02:55,379<br>The next week we’ll have one of the co-founders of Process ML.</p>
<p>68<br>00:02:55,379 –&gt; 00:03:03,659<br>This is a hosted version of Postgres where they put UDFs or you can make like PyTorch calls</p>
<p>69<br>00:03:03,659 –&gt; 00:03:05,659<br>directly in SQL.</p>
<p>70<br>00:03:05,659 –&gt; 00:03:09,900<br>They also been working on a Postgres proxy called PGCAT that’s written in Rust, Engage,</p>
<p>71<br>00:03:09,900 –&gt; 00:03:10,900<br>and Property.</p>
<p>72<br>00:03:10,900 –&gt; 00:03:15,620<br>And then the week after that, it should be not the 18th, October 2nd, that we’ll have</p>
<p>73<br>00:03:15,620 –&gt; 00:03:20,300<br>the CTO and co-founder of Weve8, one of these vector databases, come and talk with us</p>
<p>74<br>00:03:20,300 –&gt; 00:03:21,300<br>on Zoom.</p>
<p>75<br>00:03:21,300 –&gt; 00:03:22,300<br>Okay.</p>
<p>76<br>00:03:22,300 –&gt; 00:03:23,300<br>Yes?</p>
<p>77<br>00:03:23,380 –&gt; 00:03:26,580<br>Are there any internship opportunities for any of these companies?</p>
<p>78<br>00:03:26,580 –&gt; 00:03:29,380<br>This question is, are there any opportunities for any of these companies?</p>
<p>79<br>00:03:29,380 –&gt; 00:03:32,860<br>Absolutely, yes.</p>
<p>80<br>00:03:32,860 –&gt; 00:03:37,540<br>We can, we may figure out what best way to free contact them, but yes.</p>
<p>81<br>00:03:37,540 –&gt; 00:03:41,740<br>All the companies are hiring, right?</p>
<p>82<br>00:03:41,740 –&gt; 00:03:44,700<br>So there was two big data that’s used in the last week since the last half class.</p>
<p>83<br>00:03:44,700 –&gt; 00:03:51,860<br>They already know what the note they were.</p>
<p>84<br>00:03:51,860 –&gt; 00:03:54,940<br>Postgres released version 16.</p>
<p>85<br>00:03:54,940 –&gt; 00:03:58,380<br>This is not a big game changer in terms of like they don’t have like, you know, amazing</p>
<p>86<br>00:03:58,380 –&gt; 00:03:59,380<br>new features.</p>
<p>87<br>00:03:59,380 –&gt; 00:04:01,220<br>It’s a lot of refinement and improvements.</p>
<p>88<br>00:04:01,220 –&gt; 00:04:03,220<br>They’re nice to have.</p>
<p>89<br>00:04:03,220 –&gt; 00:04:08,620<br>You know, it’s, it’s, it says, a game changer improvement be like in my opinion is when</p>
<p>90<br>00:04:08,620 –&gt; 00:04:14,460<br>they added just in time compilation for ware clauses, which we’ll cover in a few weeks.</p>
<p>91<br>00:04:14,460 –&gt; 00:04:16,580<br>De-duplication for Btrees is kind of nice.</p>
<p>92<br>00:04:16,579 –&gt; 00:04:22,180<br>It’s a bunch of I.O. stuff that’s still not in ready for production, which we’ll talk</p>
<p>93<br>00:04:22,180 –&gt; 00:04:25,180<br>about a little bit about today, but like, it’s a nice to have.</p>
<p>94<br>00:04:25,180 –&gt; 00:04:27,659<br>Postgres has been putting out releases once a year and it’s been kind of nice.</p>
<p>95<br>00:04:27,659 –&gt; 00:04:34,259<br>And then Databricks announced they raised a series I for $500 million with a, like, a $43</p>
<p>96<br>00:04:34,259 –&gt; 00:04:35,259<br>billion valuation.</p>
<p>97<br>00:04:35,259 –&gt; 00:04:37,419<br>That’s a lot of money.</p>
<p>98<br>00:04:37,419 –&gt; 00:04:40,659<br>Goes, goes that saying.</p>
<p>99<br>00:04:40,659 –&gt; 00:04:45,299<br>Yeah, I don’t, I don’t, snow like didn’t raise this amount, this amount before they went</p>
<p>100<br>00:04:45,299 –&gt; 00:04:46,299<br>IPO.</p>
<p>101<br>00:04:47,020 –&gt; 00:04:49,020<br>Anyway, they’re hiring.</p>
<p>102<br>00:04:49,020 –&gt; 00:04:52,780<br>All right, so, all right.</p>
<p>103<br>00:04:52,780 –&gt; 00:04:59,500<br>So last class was, we finished up the discussion on the storage aspect of database systems and</p>
<p>104<br>00:04:59,500 –&gt; 00:05:05,819<br>it was really focusing on how the database system is going to represent data in, in disk.</p>
<p>105<br>00:05:05,819 –&gt; 00:05:09,580<br>We talked about the two point in the storage, log structure storage, the index or any storage,</p>
<p>106<br>00:05:09,580 –&gt; 00:05:10,580<br>right.</p>
<p>107<br>00:05:10,580 –&gt; 00:05:13,860<br>Now we know what these files look like on disk, how they’re broken up into pages.</p>
<p>108<br>00:05:13,860 –&gt; 00:05:19,460<br>And so today’s class and going forward is really about how do we get those pages from</p>
<p>109<br>00:05:19,460 –&gt; 00:05:24,379<br>disk, bring those into memory, and then do something with them.</p>
<p>110<br>00:05:24,379 –&gt; 00:05:27,980<br>And of course, the whole goal of what we’re trying to build in this conceptual system</p>
<p>111<br>00:05:27,980 –&gt; 00:05:32,300<br>we’re talking about is having a database system that gives the illusion that we have more</p>
<p>112<br>00:05:32,300 –&gt; 00:05:34,620<br>memory than we actually have, right.</p>
<p>113<br>00:05:34,620 –&gt; 00:05:36,699<br>The database is larger than what fits a memory.</p>
<p>114<br>00:05:36,699 –&gt; 00:05:39,620<br>We want to make it look like we could fit everything in memory.</p>
<p>115<br>00:05:39,620 –&gt; 00:05:43,819<br>So today’s really about how do we go get the things we need from disk, those pages,</p>
<p>116<br>00:05:43,819 –&gt; 00:05:48,099<br>bring them into memory and then make decisions on how to remove them in order to save space</p>
<p>117<br>00:05:48,099 –&gt; 00:05:51,259<br>when we want to bring new things in.</p>
<p>118<br>00:05:51,259 –&gt; 00:05:53,300<br>All right.</p>
<p>119<br>00:05:53,300 –&gt; 00:05:58,139<br>So there’s two key aspects where we have to consider in any decisions we’re making on</p>
<p>120<br>00:05:58,139 –&gt; 00:06:01,019<br>how we move data back and forth in disk.</p>
<p>121<br>00:06:01,019 –&gt; 00:06:05,579<br>The first is, wherever you want to write our pages on disk, can we sort of lay them out</p>
<p>122<br>00:06:05,579 –&gt; 00:06:09,019<br>in such a way that we can maximize the amount of sequential IO we’re doing instead of</p>
<p>123<br>00:06:09,019 –&gt; 00:06:11,980<br>doing random IO.</p>
<p>124<br>00:06:11,980 –&gt; 00:06:16,420<br>And the idea here is that we want to keep pages that are going to be used together, possibly</p>
<p>125<br>00:06:16,420 –&gt; 00:06:22,460<br>close to each other physically on disk, so that when a query is running or some task is</p>
<p>126<br>00:06:22,460 –&gt; 00:06:25,540<br>running inside our database system, we have to go fetch a bunch of pages.</p>
<p>127<br>00:06:25,540 –&gt; 00:06:28,540<br>We want this page to be sequential when we bring those into memory.</p>
<p>128<br>00:06:28,540 –&gt; 00:06:33,780<br>So the next thing that we consider is, when we have to go read things into memory, and</p>
<p>129<br>00:06:33,780 –&gt; 00:06:38,259<br>this is typically done on demand, meaning we’ll see prefetching in a second, but you’re</p>
<p>130<br>00:06:38,259 –&gt; 00:06:41,819<br>not just the system that isn’t going to go randomly reading things because it wants to.</p>
<p>131<br>00:06:41,819 –&gt; 00:06:42,819<br>All right.</p>
<p>132<br>00:06:42,819 –&gt; 00:06:46,060<br>If you insert about your data and then you never go read it, it’s not going to go read</p>
<p>133<br>00:06:46,060 –&gt; 00:06:49,339<br>back into memory just for the hell of it, right?</p>
<p>134<br>00:06:49,339 –&gt; 00:06:50,899<br>And so it’s going to be on demand.</p>
<p>135<br>00:06:50,899 –&gt; 00:06:55,060<br>We have to go get things from disk, bringing it into memory.</p>
<p>136<br>00:06:55,060 –&gt; 00:06:59,740<br>And then the question is going to be, when do we want to evict that from memory?</p>
<p>137<br>00:06:59,740 –&gt; 00:07:00,740<br>Right.</p>
<p>138<br>00:07:00,740 –&gt; 00:07:01,980<br>What was the last time it was access?</p>
<p>139<br>00:07:01,980 –&gt; 00:07:02,980<br>How was access?</p>
<p>140<br>00:07:02,980 –&gt; 00:07:04,779<br>Was it updated since we brought it into memory?</p>
<p>141<br>00:07:04,779 –&gt; 00:07:06,420<br>And therefore we need to write it out.</p>
<p>142<br>00:07:06,420 –&gt; 00:07:12,100<br>We’re not going to talk about how to make sure that we can save our changes in case of</p>
<p>143<br>00:07:12,100 –&gt; 00:07:13,780<br>a crash or a failure.</p>
<p>144<br>00:07:13,780 –&gt; 00:07:19,379<br>We’ll talk a little bit about that at the end, but that will be a major focus on the</p>
<p>145<br>00:07:19,379 –&gt; 00:07:21,860<br>major focus of a lecture after the midterm.</p>
<p>146<br>00:07:21,860 –&gt; 00:07:25,660<br>This is really about, OK, I got to decide what data to evict.</p>
<p>147<br>00:07:25,660 –&gt; 00:07:29,180<br>How do I make that decision?</p>
<p>148<br>00:07:29,180 –&gt; 00:07:31,980<br>And so this is that same diagram I showed before.</p>
<p>149<br>00:07:31,980 –&gt; 00:07:36,379<br>Well we have the database file on disk and it’s broken up to a bunch of pages.</p>
<p>150<br>00:07:36,379 –&gt; 00:07:40,460<br>And then now what we’re talking about today is this piece here called the buffer pool.</p>
<p>151<br>00:07:40,460 –&gt; 00:07:45,939<br>I’ll call it the buffer pool manager, some places or some of systems called the buffer pool</p>
<p>152<br>00:07:45,939 –&gt; 00:07:50,060<br>cache, cache manager.</p>
<p>153<br>00:07:50,060 –&gt; 00:07:53,220<br>The all basically mean the same thing, but it’s the memory that the database system is going</p>
<p>154<br>00:07:53,220 –&gt; 00:07:57,259<br>to allocate from the operating system and control on its own.</p>
<p>155<br>00:07:57,259 –&gt; 00:08:02,139<br>So when you have your execution engine, it starts doing something like it saves running</p>
<p>156<br>00:08:02,139 –&gt; 00:08:03,139<br>a query.</p>
<p>157<br>00:08:03,139 –&gt; 00:08:05,579<br>It doesn’t have to, but it could.</p>
<p>158<br>00:08:05,579 –&gt; 00:08:08,659<br>At some point it says I need to get page number two.</p>
<p>159<br>00:08:08,659 –&gt; 00:08:12,019<br>So again we go get the page directory from disk, bring that into memory if it’s not already</p>
<p>160<br>00:08:12,019 –&gt; 00:08:13,019<br>there.</p>
<p>161<br>00:08:13,019 –&gt; 00:08:15,219<br>Look on our page directory and that’s going to tell us our page number two.</p>
<p>162<br>00:08:15,219 –&gt; 00:08:18,620<br>Here’s the file and the offset where to find that particular page.</p>
<p>163<br>00:08:18,620 –&gt; 00:08:24,379<br>We go fetch that memory, put into one of our free space in our buffer pool, and then give</p>
<p>164<br>00:08:24,379 –&gt; 00:08:31,459<br>back the execution engine a pointer to that page sitting in the buffer pool.</p>
<p>165<br>00:08:31,459 –&gt; 00:08:36,860<br>So now let’s say again we run some kind of a fiction policy, a replacement policy and</p>
<p>166<br>00:08:36,860 –&gt; 00:08:41,019<br>we decide to remove page two for whatever reason because we need a more space.</p>
<p>167<br>00:08:41,019 –&gt; 00:08:43,500<br>We ran about your other data, it doesn’t matter.</p>
<p>168<br>00:08:43,500 –&gt; 00:08:47,860<br>But now when the execution engine comes back and says I give me page two again, it’s not</p>
<p>169<br>00:08:47,860 –&gt; 00:08:51,980<br>memory, you got to go go to disk and get it, but this time it actually might land in a</p>
<p>170<br>00:08:51,980 –&gt; 00:08:56,220<br>different location in our buffer pool.</p>
<p>171<br>00:08:56,220 –&gt; 00:08:59,580<br>And again our system, the execution engine, all the other parts of the system above the</p>
<p>172<br>00:08:59,580 –&gt; 00:09:07,060<br>buffer pool, they should obviously not be not care that it’s now in a different location.</p>
<p>173<br>00:09:07,060 –&gt; 00:09:08,940<br>This is different than men map, right?</p>
<p>174<br>00:09:08,940 –&gt; 00:09:12,580<br>If you end map a file, the memory map file, when you bring that into your address space,</p>
<p>175<br>00:09:12,580 –&gt; 00:09:17,379<br>anytime you jump to that sort of map file address space, you’re always going to get the same</p>
<p>176<br>00:09:17,379 –&gt; 00:09:21,379<br>page or the odd or oddity service guarantee that for you.</p>
<p>177<br>00:09:21,379 –&gt; 00:09:25,439<br>It may not be in memory when you’re accessing and you get installed while it gets fetches</p>
<p>178<br>00:09:25,439 –&gt; 00:09:28,340<br>in, but it’s always going to be in the same address space.</p>
<p>179<br>00:09:28,340 –&gt; 00:09:29,740<br>In our system we’re not going to do that.</p>
<p>180<br>00:09:29,740 –&gt; 00:09:33,580<br>The same page can be in different locations every time it’s brought in and out of memory.</p>
<p>181<br>00:09:33,580 –&gt; 00:09:34,580<br>Right?</p>
<p>182<br>00:09:34,580 –&gt; 00:09:38,139<br>Because we need that freedom because who knows what’s going to be in memory the next time</p>
<p>183<br>00:09:38,139 –&gt; 00:09:39,620<br>we go fetch a page.</p>
<p>184<br>00:09:39,620 –&gt; 00:09:43,580<br>And so again, this is much different than when then calling malloc.</p>
<p>185<br>00:09:43,580 –&gt; 00:09:47,700<br>When you call malloc, the OS is taking care of us all for you.</p>
<p>186<br>00:09:47,700 –&gt; 00:09:50,860<br>The database system is managing all this memory.</p>
<p>187<br>00:09:50,860 –&gt; 00:09:53,980<br>Because as we see, as we go along, it’s always going to be in a better position to make</p>
<p>188<br>00:09:53,980 –&gt; 00:09:56,580<br>the best decision how to optimize this.</p>
<p>189<br>00:09:56,580 –&gt; 00:09:57,580<br>Right?</p>
<p>190<br>00:09:57,580 –&gt; 00:10:00,860<br>So for today’s agenda, we’re going to talk about a high level of up-to-people manager is.</p>
<p>191<br>00:10:00,860 –&gt; 00:10:04,100<br>They’re talking about some optimizations we can add to it.</p>
<p>192<br>00:10:04,100 –&gt; 00:10:05,860<br>The order is actually switched.</p>
<p>193<br>00:10:05,860 –&gt; 00:10:09,220<br>Then we’ll talk about buffer-pull-for-place-and-polices, then disk-Ios-casualing, and then</p>
<p>194<br>00:10:09,220 –&gt; 00:10:15,420<br>we’ll briefly mention that there’s other memory pools in our database system that may not</p>
<p>195<br>00:10:15,420 –&gt; 00:10:17,420<br>be always backed by a buffer-for-manager.</p>
<p>196<br>00:10:17,420 –&gt; 00:10:18,420<br>Right?</p>
<p>197<br>00:10:18,419 –&gt; 00:10:21,860<br>We’re going to be looking at an ephemeral cache for certain things.</p>
<p>198<br>00:10:21,860 –&gt; 00:10:23,659<br>So again, I’m going to call it a buffer-for-manager.</p>
<p>199<br>00:10:23,659 –&gt; 00:10:25,500<br>The textbook calls a buffer manager.</p>
<p>200<br>00:10:25,500 –&gt; 00:10:28,740<br>I think Oracle might call it the buffer cache.</p>
<p>201<br>00:10:28,740 –&gt; 00:10:32,459<br>We’re all talking about the same thing.</p>
<p>202<br>00:10:32,459 –&gt; 00:10:34,299<br>So the high level looks like this.</p>
<p>203<br>00:10:34,299 –&gt; 00:10:39,740<br>Again, it’s just a region of memory that we’ve allocated from the OS, and we’re going to</p>
<p>204<br>00:10:39,740 –&gt; 00:10:44,980<br>logically chunk it up into fixed-size pages, again, based on the page size of the database</p>
<p>205<br>00:10:44,980 –&gt; 00:10:45,980<br>system.</p>
<p>206<br>00:10:45,980 –&gt; 00:10:46,980<br>Right?</p>
<p>207<br>00:10:46,980 –&gt; 00:10:49,220<br>We said, Postgres is 8 kilobytes.</p>
<p>208<br>00:10:49,220 –&gt; 00:10:50,220<br>My SQL is 16 kilobytes.</p>
<p>209<br>00:10:50,220 –&gt; 00:10:51,460<br>It’s going to have compression size.</p>
<p>210<br>00:10:51,460 –&gt; 00:10:52,460<br>Right?</p>
<p>211<br>00:10:52,460 –&gt; 00:10:53,460<br>It doesn’t matter.</p>
<p>212<br>00:10:53,460 –&gt; 00:10:56,420<br>We’re breaking it up based on those page sizes.</p>
<p>213<br>00:10:56,420 –&gt; 00:11:03,860<br>And then an entry or a location in our buffer-poled memory that we could use to install a page,</p>
<p>214<br>00:11:03,860 –&gt; 00:11:06,659<br>we’re going to call that a frame.</p>
<p>215<br>00:11:06,659 –&gt; 00:11:08,060<br>So I think the system boots up.</p>
<p>216<br>00:11:08,060 –&gt; 00:11:09,060<br>It calls malloc.</p>
<p>217<br>00:11:09,060 –&gt; 00:11:10,580<br>It gets a bunch of memory.</p>
<p>218<br>00:11:10,580 –&gt; 00:11:13,539<br>And then it says, say, break it up and divide it up into frames.</p>
<p>219<br>00:11:13,539 –&gt; 00:11:19,059<br>And then as the database system or other parts of the execution or whatever, start requesting</p>
<p>220<br>00:11:19,059 –&gt; 00:11:25,339<br>pages, we’re going to make an exact copy of the pages from disk into memory and put it</p>
<p>221<br>00:11:25,339 –&gt; 00:11:26,339<br>into one of these frames.</p>
<p>222<br>00:11:26,339 –&gt; 00:11:29,419<br>And the reason why we get to call it frames is because we’re running out of terms.</p>
<p>223<br>00:11:29,419 –&gt; 00:11:30,419<br>Right?</p>
<p>224<br>00:11:30,419 –&gt; 00:11:31,419<br>Can’t call it a page.</p>
<p>225<br>00:11:31,419 –&gt; 00:11:32,419<br>Can’t call it a block because we already used that.</p>
<p>226<br>00:11:32,419 –&gt; 00:11:35,179<br>Can’t call it a slot because we have a slot array.</p>
<p>227<br>00:11:35,179 –&gt; 00:11:37,819<br>So for whatever reason, we’re going to call it a frame.</p>
<p>228<br>00:11:37,819 –&gt; 00:11:38,819<br>All right.</p>
<p>229<br>00:11:38,819 –&gt; 00:11:41,059<br>So again, so somebody needs page one.</p>
<p>230<br>00:11:41,059 –&gt; 00:11:46,579<br>And we go find a free frame in our buffer pool and we just copy that page on disk into memory.</p>
<p>231<br>00:11:46,579 –&gt; 00:11:47,579<br>Same thing here.</p>
<p>232<br>00:11:47,579 –&gt; 00:11:50,779<br>I need page three, find a free slot, and I copy it into memory here.</p>
<p>233<br>00:11:50,779 –&gt; 00:11:57,059<br>But again, here we can see that page one and page three are not continuous on disk because</p>
<p>234<br>00:11:57,059 –&gt; 00:11:58,659<br>there’s page two in between them.</p>
<p>235<br>00:11:58,659 –&gt; 00:12:01,819<br>But when we put in our buffer pool and bring it into memory, we’re again, we’re free to</p>
<p>236<br>00:12:01,819 –&gt; 00:12:04,500<br>put it in any location that we want.</p>
<p>237<br>00:12:04,500 –&gt; 00:12:07,939<br>It doesn’t matter.</p>
<p>238<br>00:12:07,940 –&gt; 00:12:16,580<br>So now, if we modify one of these pages, we’re not going to, we’re not required to flush</p>
<p>239<br>00:12:16,580 –&gt; 00:12:18,180<br>the data back to disk right away.</p>
<p>240<br>00:12:18,180 –&gt; 00:12:22,540<br>And again, we will cover durability and the recovery after the midterm.</p>
<p>241<br>00:12:22,540 –&gt; 00:12:26,580<br>But this is a key difference then between a right through cache or a right back cache.</p>
<p>242<br>00:12:26,580 –&gt; 00:12:27,580<br>Right?</p>
<p>243<br>00:12:27,580 –&gt; 00:12:31,820<br>With a right through cache in the OS, when you write something to the cache, it then gets</p>
<p>244<br>00:12:31,820 –&gt; 00:12:34,020<br>immediately written out the disk as well.</p>
<p>245<br>00:12:34,019 –&gt; 00:12:38,139<br>And a right back cache will write it in memory, but we’re not required to write it back</p>
<p>246<br>00:12:38,139 –&gt; 00:12:39,139<br>right away.</p>
<p>247<br>00:12:39,139 –&gt; 00:12:40,139<br>We’ll do it at some later point.</p>
<p>248<br>00:12:40,139 –&gt; 00:12:44,059<br>There’ll be a background thread or an eviction policy that’ll do this.</p>
<p>249<br>00:12:44,059 –&gt; 00:12:48,699<br>And so we won’t talk about this today, but there’ll be a separate log file right ahead</p>
<p>250<br>00:12:48,699 –&gt; 00:12:52,460<br>log that’ll keep track of what changes we made.</p>
<p>251<br>00:12:52,460 –&gt; 00:12:57,299<br>And we’ll make sure that thing gets flushed to disk before our dirty pages do.</p>
<p>252<br>00:12:57,299 –&gt; 00:12:58,299<br>We don’t have to know that for now.</p>
<p>253<br>00:12:58,299 –&gt; 00:13:02,579<br>I’m just be mindful that even though we may update pages, we’re not required to write</p>
<p>254<br>00:13:02,580 –&gt; 00:13:06,660<br>them back right away in memory.</p>
<p>255<br>00:13:06,660 –&gt; 00:13:10,540<br>I said that the internal data structure we’re going to use to keep track of what is actually</p>
<p>256<br>00:13:10,540 –&gt; 00:13:13,180<br>in our frames is going to be called the page table.</p>
<p>257<br>00:13:13,180 –&gt; 00:13:15,300<br>Again, the OS has its own page table.</p>
<p>258<br>00:13:15,300 –&gt; 00:13:16,780<br>This is the database system’s page table.</p>
<p>259<br>00:13:16,780 –&gt; 00:13:17,780<br>It’s better.</p>
<p>260<br>00:13:17,780 –&gt; 00:13:23,940<br>And so it’s typically going to be a fixed size hash table that is just keeping track of,</p>
<p>261<br>00:13:23,940 –&gt; 00:13:28,259<br>here’s all my frames, right, identified by some frame ID.</p>
<p>262<br>00:13:28,259 –&gt; 00:13:35,100<br>And then here’s the page information that’s currently residing in that page.</p>
<p>263<br>00:13:35,100 –&gt; 00:13:39,340<br>I could just be a pointer to where that page is actually located.</p>
<p>264<br>00:13:39,340 –&gt; 00:13:42,500<br>And we’re going to have to protect this page table with a latch.</p>
<p>265<br>00:13:42,500 –&gt; 00:13:47,460<br>But I’ll describe in a second, think of it as a mutex, that allows us to have multiple</p>
<p>266<br>00:13:47,460 –&gt; 00:13:53,259<br>threads or multiple workers accessing the page table at the same time.</p>
<p>267<br>00:13:53,259 –&gt; 00:13:54,860<br>I don’t want to use term threads.</p>
<p>268<br>00:13:54,860 –&gt; 00:13:59,100<br>I would better use terms workers because I can postgres and older systems.</p>
<p>269<br>00:13:59,100 –&gt; 00:14:00,940<br>They’re not multi-ferred.</p>
<p>270<br>00:14:00,940 –&gt; 00:14:02,220<br>They’re multi-process.</p>
<p>271<br>00:14:02,220 –&gt; 00:14:04,220<br>And so the idea is still the same.</p>
<p>272<br>00:14:04,220 –&gt; 00:14:07,539<br>We want to make sure that if there’s multiple workers touching things and updating things,</p>
<p>273<br>00:14:07,539 –&gt; 00:14:13,500<br>they don’t have, when we’re in the critical sections, we don’t break things.</p>
<p>274<br>00:14:13,500 –&gt; 00:14:18,180<br>So in addition to keeping track of like, here’s the pointer to the page in our buffer pool</p>
<p>275<br>00:14:18,180 –&gt; 00:14:22,120<br>and in the frame, we’re also going to have additional metadata about how the pages are</p>
<p>276<br>00:14:22,120 –&gt; 00:14:25,519<br>being used throughout the system.</p>
<p>277<br>00:14:25,519 –&gt; 00:14:29,480<br>So the first thing we would have, obviously, is a dirty flag that tells us whether a query</p>
<p>278<br>00:14:29,480 –&gt; 00:14:32,120<br>has updated a page since we last brought it into memory.</p>
<p>279<br>00:14:32,120 –&gt; 00:14:39,740<br>We’ll also have a pin or reference counter that keeps track of the number of workers that</p>
<p>280<br>00:14:39,740 –&gt; 00:14:44,360<br>require this page to remain in memory, and therefore it can’t be evicted when we run our</p>
<p>281<br>00:14:44,360 –&gt; 00:14:46,440<br>addiction policy.</p>
<p>282<br>00:14:46,440 –&gt; 00:14:51,840<br>So for each page, say page three here, say there’s some query that is accessing it at this</p>
<p>283<br>00:14:51,840 –&gt; 00:14:53,000<br>given time.</p>
<p>284<br>00:14:53,000 –&gt; 00:14:54,840<br>So in our page table, we have a little counter.</p>
<p>285<br>00:14:54,840 –&gt; 00:15:00,040<br>It says there’s at least one worker that’s accessing it.</p>
<p>286<br>00:15:00,040 –&gt; 00:15:06,560<br>And then now say if another query comes along and is looking for another page that’s not</p>
<p>287<br>00:15:06,560 –&gt; 00:15:11,600<br>in our page table, we’ll put a latch on it, protect it, go fetch the data we need.</p>
<p>288<br>00:15:11,600 –&gt; 00:15:13,360<br>So in this case, we need page two.</p>
<p>289<br>00:15:13,360 –&gt; 00:15:18,360<br>We update a free frame in our buffer pool, update the page table to now point to this buffer</p>
<p>290<br>00:15:18,360 –&gt; 00:15:21,560<br>pool, update any metadata we need to know about it.</p>
<p>291<br>00:15:21,559 –&gt; 00:15:26,439<br>Like who accessed it when they last accessed it and so forth.</p>
<p>292<br>00:15:26,439 –&gt; 00:15:31,239<br>And then once this query is done doing whatever its update needs to the page table, we can</p>
<p>293<br>00:15:31,239 –&gt; 00:15:35,679<br>release the latch for turn that worker back to whatever it’s doing.</p>
<p>294<br>00:15:35,679 –&gt; 00:15:39,399<br>And then now any other worker that comes along looking for page two will find it in this</p>
<p>295<br>00:15:39,399 –&gt; 00:15:44,319<br>page table.</p>
<p>296<br>00:15:44,319 –&gt; 00:15:48,639<br>Pretty simple, right?</p>
<p>297<br>00:15:48,639 –&gt; 00:15:54,639<br>So I use this term latch and purposely did not say lock.</p>
<p>298<br>00:15:54,639 –&gt; 00:15:57,480<br>Everything I guess, why?</p>
<p>299<br>00:15:57,480 –&gt; 00:15:58,480<br>Yes.</p>
<p>300<br>00:15:58,480 –&gt; 00:16:06,279<br>So he says the standard locks that we have, locks and latches we have are different, different</p>
<p>301<br>00:16:06,279 –&gt; 00:16:07,279<br>from who or what.</p>
<p>302<br>00:16:07,279 –&gt; 00:16:27,079<br>So he says that there’s that latches have some database magic that’s better for our purposes</p>
<p>303<br>00:16:27,079 –&gt; 00:16:30,000<br>versus locks.</p>
<p>304<br>00:16:30,000 –&gt; 00:16:31,000<br>Not quite.</p>
<p>305<br>00:16:31,000 –&gt; 00:16:32,000<br>Yes.</p>
<p>306<br>00:16:32,000 –&gt; 00:16:33,000<br>Yes.</p>
<p>307<br>00:16:33,000 –&gt; 00:16:34,720<br>Locks are for user space.</p>
<p>308<br>00:16:34,720 –&gt; 00:16:35,720<br>Yes.</p>
<p>309<br>00:16:35,720 –&gt; 00:16:37,720<br>He says locks are for user space.</p>
<p>310<br>00:16:37,720 –&gt; 00:16:41,500<br>In the, I mean the database system is running in user space, but it’s for, let’s say logical</p>
<p>311<br>00:16:41,500 –&gt; 00:16:42,519<br>things in the database.</p>
<p>312<br>00:16:42,519 –&gt; 00:16:43,519<br>Correct.</p>
<p>313<br>00:16:43,519 –&gt; 00:16:44,519<br>Yes.</p>
<p>314<br>00:16:44,519 –&gt; 00:16:47,879<br>So this trips people up when they come from like a more OS background.</p>
<p>315<br>00:16:47,879 –&gt; 00:16:51,679<br>So in the database world, we have this decision between locks and latches.</p>
<p>316<br>00:16:51,679 –&gt; 00:16:56,559<br>So a lock is to protect these higher level concepts or objects in our database.</p>
<p>317<br>00:16:56,559 –&gt; 00:16:59,960<br>A tuple, a table, a database, right?</p>
<p>318<br>00:16:59,960 –&gt; 00:17:02,120<br>I take locks on these things.</p>
<p>319<br>00:17:02,120 –&gt; 00:17:04,460<br>And what will happen is we haven’t discussed what transactions are just, yeah, but think</p>
<p>320<br>00:17:04,460 –&gt; 00:17:05,960<br>of like I want to do multiple updates.</p>
<p>321<br>00:17:05,960 –&gt; 00:17:08,720<br>It’s like multiple round trips of SQL queries.</p>
<p>322<br>00:17:08,720 –&gt; 00:17:14,640<br>And so if I take a lock on something, I want to hold it for the length of that transaction.</p>
<p>323<br>00:17:14,640 –&gt; 00:17:19,519<br>And because he’s saying user space, but it’s like the application is the one that’s creating</p>
<p>324<br>00:17:19,519 –&gt; 00:17:24,000<br>these locks or the database is creating these locks of the application, we assume that they’re</p>
<p>325<br>00:17:24,000 –&gt; 00:17:28,680<br>stupid and therefore we need to make sure that they don’t have dead locks or other problems.</p>
<p>326<br>00:17:28,680 –&gt; 00:17:32,680<br>So we have to have these digital protection mechanisms to make sure that the JavaScript</p>
<p>327<br>00:17:32,680 –&gt; 00:17:36,560<br>program or doesn’t do something they shouldn’t be doing.</p>
<p>328<br>00:17:36,560 –&gt; 00:17:40,519<br>Latches are the low level internal primitives we’re going to use to protect the critical</p>
<p>329<br>00:17:40,519 –&gt; 00:17:43,560<br>sections of our database system.</p>
<p>330<br>00:17:43,560 –&gt; 00:17:45,680<br>And these are what the database system developers are using.</p>
<p>331<br>00:17:45,680 –&gt; 00:17:48,680<br>You had to use in Project Zero, right?</p>
<p>332<br>00:17:48,680 –&gt; 00:17:50,440<br>You had to take a mutex, right?</p>
<p>333<br>00:17:50,440 –&gt; 00:17:55,640<br>So a latch is basically like a low level mutex, right?</p>
<p>334<br>00:17:55,640 –&gt; 00:18:01,240<br>And because the latches are being used by the database system developers, meaning us,</p>
<p>335<br>00:18:01,240 –&gt; 00:18:06,200<br>right, it’s not going to have the the the the deadlock detection and other protection mechanisms</p>
<p>336<br>00:18:06,200 –&gt; 00:18:09,640<br>we need because if we’re the ones building a database system, we need to be smart enough</p>
<p>337<br>00:18:09,640 –&gt; 00:18:12,400<br>to make sure we don’t have deadlocks.</p>
<p>338<br>00:18:12,400 –&gt; 00:18:16,080<br>And so latches are really meant to be like quick in and out critical section, do something</p>
<p>339<br>00:18:16,080 –&gt; 00:18:17,080<br>and release it.</p>
<p>340<br>00:18:17,080 –&gt; 00:18:20,400<br>And we need to do through through program or discipline, we need where are the ones</p>
<p>341<br>00:18:20,400 –&gt; 00:18:24,400<br>that have to make sure that we don’t have deadlocks.</p>
<p>342<br>00:18:24,400 –&gt; 00:18:29,200<br>Now this is confusing because this is also in C++, the standard library, there’s also</p>
<p>343<br>00:18:29,200 –&gt; 00:18:30,280<br>they use the term latches.</p>
<p>344<br>00:18:30,280 –&gt; 00:18:32,240<br>But that’s just a countdown barrier.</p>
<p>345<br>00:18:32,240 –&gt; 00:18:34,920<br>We don’t want that, we don’t need that, we’re going to roll around latches.</p>
<p>346<br>00:18:34,920 –&gt; 00:18:38,480<br>We’ll see this more next week when we talk about index and currency troll and for B plus</p>
<p>347<br>00:18:38,480 –&gt; 00:18:39,480<br>trees.</p>
<p>348<br>00:18:39,480 –&gt; 00:18:44,800<br>But for now, just assume you can treat it as the mutex.</p>
<p>349<br>00:18:44,800 –&gt; 00:18:49,680<br>We don’t want to use the OS mutex, as that has other problems, we’ll cover that later.</p>
<p>350<br>00:18:49,680 –&gt; 00:18:53,759<br>All right, again, another point distinction, I’ve already said this, between the page directory</p>
<p>351<br>00:18:53,759 –&gt; 00:19:01,200<br>and the page table, the page directory is just a disk resident mapping between page IDs</p>
<p>352<br>00:19:01,200 –&gt; 00:19:05,599<br>and their locations on the physical disk on the actual files themselves.</p>
<p>353<br>00:19:05,599 –&gt; 00:19:11,000<br>But the page table is going to be the sephemeral memory mapping that we use to identify, for</p>
<p>354<br>00:19:11,000 –&gt; 00:19:14,720<br>a given page ID, here’s the frame where it’s actually located.</p>
<p>355<br>00:19:14,720 –&gt; 00:19:18,079<br>And if it’s not in our page table, we know we have to look in the page directory to go</p>
<p>356<br>00:19:18,079 –&gt; 00:19:21,839<br>find where it is on disk and go bring it in.</p>
<p>357<br>00:19:21,839 –&gt; 00:19:23,720<br>All right.</p>
<p>358<br>00:19:23,720 –&gt; 00:19:27,240<br>So most of the time, the query is going to be hitting up the page table, but it’s only</p>
<p>359<br>00:19:27,240 –&gt; 00:19:31,279<br>when the page table says something’s not there, then there needs to be some mechanism through</p>
<p>360<br>00:19:31,279 –&gt; 00:19:34,559<br>like the disk module or something that says, all right, let me look at the page directory,</p>
<p>361<br>00:19:34,559 –&gt; 00:19:38,839<br>let me go get the fetch the page from disk and then put it into the page table.</p>
<p>362<br>00:19:38,839 –&gt; 00:19:39,839<br>Okay?</p>
<p>363<br>00:19:39,839 –&gt; 00:19:43,680<br>So what I’ve shown you so far is a basic page table, right?</p>
<p>364<br>00:19:43,680 –&gt; 00:19:46,440<br>It’s a hash table, it’s a maximum metadata.</p>
<p>365<br>00:19:46,440 –&gt; 00:19:50,400<br>If the page is there, if you could forgive a page ID, you get back a pointer to it.</p>
<p>366<br>00:19:50,400 –&gt; 00:19:54,720<br>If it’s not there, the sum mechanism to go get it from disk, then put install it into</p>
<p>367<br>00:19:54,720 –&gt; 00:20:00,120<br>a free frame, then the page table has the entry, right?</p>
<p>368<br>00:20:00,120 –&gt; 00:20:05,680<br>But this is going to be a big bottleneck unless we’re clever and smart about exploiting</p>
<p>369<br>00:20:05,680 –&gt; 00:20:12,240<br>the information we know about what is going on inside of our database system.</p>
<p>370<br>00:20:12,240 –&gt; 00:20:17,040<br>To approximate decisions, how we want to allocate things and decide who gets what page,</p>
<p>371<br>00:20:17,039 –&gt; 00:20:21,119<br>what time, what location, and how we decided to make things.</p>
<p>372<br>00:20:21,119 –&gt; 00:20:25,079<br>Because we don’t exploit the information we know about what our queries want to do, what</p>
<p>373<br>00:20:25,079 –&gt; 00:20:29,839<br>our data looks like, what our access patterns are, then we’re no better than the OS, right?</p>
<p>374<br>00:20:29,839 –&gt; 00:20:32,720<br>The OS doesn’t see anything going on inside our database system.</p>
<p>375<br>00:20:32,720 –&gt; 00:20:38,879<br>So if we just blindly take requests and go take them out, whatever, we’re no better than</p>
<p>376<br>00:20:38,879 –&gt; 00:20:42,159<br>the OS, right?</p>
<p>377<br>00:20:42,160 –&gt; 00:20:48,480<br>So some of these techniques we’ll talk about, these optimizations, again, it’s going</p>
<p>378<br>00:20:48,480 –&gt; 00:20:51,759<br>to motivate why we need to write our own buffer pool manager, why we don’t want to do</p>
<p>379<br>00:20:51,759 –&gt; 00:20:53,320<br>the OS.</p>
<p>380<br>00:20:53,320 –&gt; 00:20:58,279<br>And it’ll be a combination of policies that will affect all queries and running at the</p>
<p>381<br>00:20:58,279 –&gt; 00:21:00,960<br>same time.</p>
<p>382<br>00:21:00,960 –&gt; 00:21:06,240<br>Or it could be things that are going to just help a single query by itself, maybe not necessarily</p>
<p>383<br>00:21:06,240 –&gt; 00:21:10,759<br>worrying about other queries that are running at the same time, but we can isolate the</p>
<p>384<br>00:21:10,759 –&gt; 00:21:17,359<br>decisions we make for that query so they don’t try not to affect others.</p>
<p>385<br>00:21:17,359 –&gt; 00:21:21,480<br>And I’m not going to say one of these approaches can be better than another, but you will see</p>
<p>386<br>00:21:21,480 –&gt; 00:21:26,519<br>that as we go along, all the major data systems are going to use some combination of all of</p>
<p>387<br>00:21:26,519 –&gt; 00:21:30,720<br>them, or some of them are most of them.</p>
<p>388<br>00:21:30,720 –&gt; 00:21:36,519<br>So I can’t say which one is most important when it implement first, but we’ll see how</p>
<p>389<br>00:21:36,519 –&gt; 00:21:39,680<br>it’s going to go along.</p>
<p>390<br>00:21:39,680 –&gt; 00:21:42,480<br>So the things I talked about is using multiple buffer pools.</p>
<p>391<br>00:21:42,480 –&gt; 00:21:44,960<br>Actually, that’s probably the first one I’m going to take back what I said.</p>
<p>392<br>00:21:44,960 –&gt; 00:21:46,960<br>Multiple, multiple pools is obviously going to do first.</p>
<p>393<br>00:21:46,960 –&gt; 00:21:48,519<br>We’ll see what that looks like.</p>
<p>394<br>00:21:48,519 –&gt; 00:21:54,160<br>Prefetchings are about complicated, scan sharing, and then buffer pool bypass.</p>
<p>395<br>00:21:54,160 –&gt; 00:22:00,039<br>So my toy exam I showed you beginning, we said there was one page table, one set of frames,</p>
<p>396<br>00:22:00,039 –&gt; 00:22:03,000<br>and that was it for the entire system.</p>
<p>397<br>00:22:03,000 –&gt; 00:22:07,279<br>But then again, because there’s multiple workers running at the same time, we have to use</p>
<p>398<br>00:22:07,279 –&gt; 00:22:09,799<br>these latches to protect the data structure.</p>
<p>399<br>00:22:09,799 –&gt; 00:22:14,639<br>And for a large number CPU course, a large number of workers running at the same time, those</p>
<p>400<br>00:22:14,639 –&gt; 00:22:18,079<br>latches are going to become a bottleneck.</p>
<p>401<br>00:22:18,079 –&gt; 00:22:22,920<br>We can, because it’s fixed, assuming the page table is fixed size, we don’t have to have</p>
<p>402<br>00:22:22,920 –&gt; 00:22:24,319<br>a latch for the entire page table.</p>
<p>403<br>00:22:24,319 –&gt; 00:22:29,720<br>We’re going to have latch for individual pages or locations in the hash table.</p>
<p>404<br>00:22:29,720 –&gt; 00:22:34,759<br>But even then, if everybody’s trying to go get the same small number of pages, then those</p>
<p>405<br>00:22:34,759 –&gt; 00:22:38,720<br>latches are going to be a bottleneck.</p>
<p>406<br>00:22:38,720 –&gt; 00:22:46,400<br>So an easy way to alleviate this contention point is just to have multiple buffer pools.</p>
<p>407<br>00:22:46,400 –&gt; 00:22:48,279<br>So I still allocate the same amount of memory.</p>
<p>408<br>00:22:48,279 –&gt; 00:22:52,160<br>So I have to tell the data system when I boot up, I want 10 gigs of memory for my buffer</p>
<p>409<br>00:22:52,160 –&gt; 00:22:53,160<br>pool.</p>
<p>410<br>00:22:53,160 –&gt; 00:22:59,759<br>But I’m going to take those 10 gigs and I can divide it into equal size chunks, and then</p>
<p>411<br>00:22:59,759 –&gt; 00:23:04,640<br>now have a separate page table for each of them.</p>
<p>412<br>00:23:04,640 –&gt; 00:23:13,080<br>It also ensures that for certain access patterns on certain objects in the database, I can</p>
<p>413<br>00:23:13,080 –&gt; 00:23:17,080<br>have different policies that can affect one buffer pool versus another based on how I</p>
<p>414<br>00:23:17,080 –&gt; 00:23:19,800<br>know that object is going to be used.</p>
<p>415<br>00:23:19,800 –&gt; 00:23:25,240<br>So for example, in DB2, DB2 probably has the most sophisticated buffer pool management</p>
<p>416<br>00:23:25,240 –&gt; 00:23:32,280<br>configurations, where you can actually define a table space, I think like a name space,</p>
<p>417<br>00:23:32,279 –&gt; 00:23:36,099<br>that is backed by a given buffer pool, you can set what the page size should be for that</p>
<p>418<br>00:23:36,099 –&gt; 00:23:40,000<br>buffer pool, and then you can tell which tables we manage or indexes we manage by that</p>
<p>419<br>00:23:40,000 –&gt; 00:23:41,680<br>buffer pool.</p>
<p>420<br>00:23:41,680 –&gt; 00:23:47,440<br>So let’s say you have like one table that is primarily used for random access, you can</p>
<p>421<br>00:23:47,440 –&gt; 00:23:52,839<br>have some policies, the fiction policies based on that’s optimal for random access.</p>
<p>422<br>00:23:52,839 –&gt; 00:23:55,680<br>Then you have another buffer pool that’s for these other tables, you reduce the</p>
<p>423<br>00:23:55,680 –&gt; 00:23:58,440<br>sequential scans, you have a different buffer policies for that sequential scan, maybe</p>
<p>424<br>00:23:58,440 –&gt; 00:24:01,960<br>you use larger pages to page sizes.</p>
<p>425<br>00:24:01,960 –&gt; 00:24:05,200<br>As far as I know DB2 is the only one that lets you do this, I haven’t seen, it’s post-cursing</p>
<p>426<br>00:24:05,200 –&gt; 00:24:08,200<br>my SQL statement can’t do this.</p>
<p>427<br>00:24:08,200 –&gt; 00:24:12,759<br>I don’t know about the other enterprise ones, but the DB2 one is very sophisticated.</p>
<p>428<br>00:24:12,759 –&gt; 00:24:18,480<br>Again, this allows you to customize the buffer pool management for exactly how that object</p>
<p>429<br>00:24:18,480 –&gt; 00:24:20,600<br>is going to be used.</p>
<p>430<br>00:24:20,600 –&gt; 00:24:27,440<br>Now the question is how do you find and runtime what buffer pool management should use.</p>
<p>431<br>00:24:28,279 –&gt; 00:24:31,799<br>So let’s say I have two buffer pools.</p>
<p>432<br>00:24:31,799 –&gt; 00:24:36,920<br>The first thing I could do is, as I said in the DB2 case, I can assign a buffer pool to</p>
<p>433<br>00:24:36,920 –&gt; 00:24:40,519<br>back a given object based on this identifier.</p>
<p>434<br>00:24:40,519 –&gt; 00:24:45,400<br>Table 1, 2, 3, table whatever, that’s buffer pool 1, and all other tables are buffer pool</p>
<p>435<br>00:24:45,400 –&gt; 00:24:46,400<br>2.</p>
<p>436<br>00:24:46,400 –&gt; 00:24:51,759<br>So not runtime when I have an op of request, it’s obviously not SQL, but somehow I got</p>
<p>437<br>00:24:51,759 –&gt; 00:24:56,440<br>a through an index lookup, I figured out that I want to look at record 1, 2, 3, and we</p>
<p>438<br>00:24:56,440 –&gt; 00:25:01,080<br>saw before how we can break the record ID into its individual components, usually like</p>
<p>439<br>00:25:01,080 –&gt; 00:25:07,160<br>a page ID or slot number, but in case the SQL server, it also had a file number or an object</p>
<p>440<br>00:25:07,160 –&gt; 00:25:08,160<br>ID.</p>
<p>441<br>00:25:08,160 –&gt; 00:25:15,680<br>So if we can use this from the record ID, then do a lookup and say, okay, object 456, that’s</p>
<p>442<br>00:25:15,680 –&gt; 00:25:19,759<br>managed by buffer pool 1, and then send the request to that buffer pool.</p>
<p>443<br>00:25:19,759 –&gt; 00:25:23,000<br>And all the requests for other objects may end to another buffer pool.</p>
<p>444<br>00:25:23,000 –&gt; 00:25:29,319<br>And I’ve isolated them so that there’s less last contention between the two of them.</p>
<p>445<br>00:25:29,319 –&gt; 00:25:34,519<br>The simplest approach then is to do what my SQL does is you just take the record ID, hash</p>
<p>446<br>00:25:34,519 –&gt; 00:25:38,960<br>it, modify the number of buffer pool managers you have, and that tells you which one you</p>
<p>447<br>00:25:38,960 –&gt; 00:25:39,960<br>go to.</p>
<p>448<br>00:25:39,960 –&gt; 00:25:40,960<br>Right?</p>
<p>449<br>00:25:40,960 –&gt; 00:25:41,960<br>Pretty simple.</p>
<p>450<br>00:25:41,960 –&gt; 00:25:42,960<br>Yes.</p>
<p>451<br>00:25:42,960 –&gt; 00:25:47,160<br>Do you have to statically allocate how much memory is being able to get in your buffer pool?</p>
<p>452<br>00:25:47,160 –&gt; 00:25:51,039<br>Yes, so he said that the question is, do you have to statically allocate how much memory</p>
<p>453<br>00:25:51,039 –&gt; 00:25:53,759<br>each buffer pool has?</p>
<p>454<br>00:25:53,759 –&gt; 00:25:54,759<br>Yes.</p>
<p>455<br>00:25:54,759 –&gt; 00:25:59,960<br>And so in PostGuest MI SQL, in most systems, you cannot change the size of the buffer pool,</p>
<p>456<br>00:25:59,960 –&gt; 00:26:02,119<br>but actually having a restarting entire system.</p>
<p>457<br>00:26:02,119 –&gt; 00:26:06,359<br>Actually, in the middle of that, all of the open source systems have that limitation.</p>
<p>458<br>00:26:06,359 –&gt; 00:26:11,319<br>The commercial systems can be kind of clever and like, I think in Oracle, you can increase</p>
<p>459<br>00:26:11,319 –&gt; 00:26:16,559<br>the buffer pool size and allocate the memory and then slowly increment and migrate pages</p>
<p>460<br>00:26:16,559 –&gt; 00:26:18,799<br>over from the page to the next.</p>
<p>461<br>00:26:18,799 –&gt; 00:26:19,799<br>Right?</p>
<p>462<br>00:26:19,799 –&gt; 00:26:22,799<br>So, what is the most tricky thing when most systems are statically allocated?</p>
<p>463<br>00:26:22,799 –&gt; 00:26:28,200<br>So, one that potentially weights a lot of memory is your partitioning by database or</p>
<p>464<br>00:26:28,200 –&gt; 00:26:30,159<br>table, because I imagine different.</p>
<p>465<br>00:26:30,159 –&gt; 00:26:31,159<br>Yes.</p>
<p>466<br>00:26:31,159 –&gt; 00:26:35,680<br>So, this question is, could this mean that you are potentially wasting memory if you partition</p>
<p>467<br>00:26:35,680 –&gt; 00:26:37,720<br>and say by table?</p>
<p>468<br>00:26:37,720 –&gt; 00:26:43,079<br>So for example, if I say, I make a new buffer pool, I put, I say it has 10 gigs and I say,</p>
<p>469<br>00:26:43,079 –&gt; 00:26:46,599<br>you’re going to manage this table, but I don’t put any data in that table.</p>
<p>470<br>00:26:46,599 –&gt; 00:26:47,919<br>Is that wasting space?</p>
<p>471<br>00:26:47,919 –&gt; 00:26:48,919<br>Yes.</p>
<p>472<br>00:26:49,400 –&gt; 00:26:52,480<br>But like, the Davis system did exactly what you wanted to do.</p>
<p>473<br>00:26:52,480 –&gt; 00:26:53,480<br>The human was stupid.</p>
<p>474<br>00:26:53,480 –&gt; 00:26:54,480<br>Right?</p>
<p>475<br>00:26:54,480 –&gt; 00:26:59,259<br>There’s, I mean, there’s not, yeah, because the problem is, it doesn’t know, you think,</p>
<p>476<br>00:26:59,259 –&gt; 00:27:02,320<br>okay, well, only allocated one to man as needed.</p>
<p>477<br>00:27:02,320 –&gt; 00:27:09,080<br>But like, the amount of engineering effort to sort of accommodate stupid people is probably</p>
<p>478<br>00:27:09,080 –&gt; 00:27:10,840<br>not worth it in that case.</p>
<p>479<br>00:27:10,840 –&gt; 00:27:14,560<br>If you’re using DB2 in theories, you should know, like if you’re calling create buffer pool</p>
<p>480<br>00:27:14,560 –&gt; 00:27:17,360<br>to command to do it, you kind of should be known what you’re doing.</p>
<p>481<br>00:27:17,360 –&gt; 00:27:18,360<br>Right?</p>
<p>482<br>00:27:18,359 –&gt; 00:27:27,439<br>So again, in my opinion, I think that what I said, this is actually the first optimization</p>
<p>483<br>00:27:27,439 –&gt; 00:27:32,000<br>should do to scale your buffer manager, because it’s not that much, much work.</p>
<p>484<br>00:27:32,000 –&gt; 00:27:34,319<br>The hashing ones probably the easiest one to do as well.</p>
<p>485<br>00:27:34,319 –&gt; 00:27:35,319<br>Right?</p>
<p>486<br>00:27:35,319 –&gt; 00:27:39,639<br>Because there’s no central data structure to say, okay, for this object, you go to this</p>
<p>487<br>00:27:39,639 –&gt; 00:27:44,519<br>one, or you just hash it and you’re done.</p>
<p>488<br>00:27:44,519 –&gt; 00:27:46,799<br>The next optimization we can do is prefetching.</p>
<p>489<br>00:27:47,639 –&gt; 00:27:53,279<br>Again, the OS to do prefetching, we’ll see, for like simple cases, like when you’re doing</p>
<p>490<br>00:27:53,279 –&gt; 00:27:56,759<br>sequential scans, we’ll see one case where it can’t do it.</p>
<p>491<br>00:27:56,759 –&gt; 00:28:04,039<br>So the basic idea is that if you run a query and it has to start accessing data in your</p>
<p>492<br>00:28:04,039 –&gt; 00:28:10,200<br>table, it’s going to open up a cursor that just starts scanning through the pages one by</p>
<p>493<br>00:28:10,200 –&gt; 00:28:11,200<br>one.</p>
<p>494<br>00:28:11,200 –&gt; 00:28:12,200<br>Right?</p>
<p>495<br>00:28:12,200 –&gt; 00:28:15,919<br>And so assuming this in our example here, our buffer pool starts off as empty.</p>
<p>496<br>00:28:15,920 –&gt; 00:28:21,160<br>So at the very first page that it sees, page zero, it’s not in the buffer pool.</p>
<p>497<br>00:28:21,160 –&gt; 00:28:23,680<br>So we just go again, we just go copy and put that in.</p>
<p>498<br>00:28:23,680 –&gt; 00:28:26,560<br>Then we scan along, we need page one, page one’s not there.</p>
<p>499<br>00:28:26,560 –&gt; 00:28:29,039<br>So it goes ahead and copy that.</p>
<p>500<br>00:28:29,039 –&gt; 00:28:33,080<br>But now the data system could be smart and say, okay, well, you’ve read page zero, you’ve</p>
<p>501<br>00:28:33,080 –&gt; 00:28:38,680<br>read page one, it’s very likely you’re going to read page two, three, and so forth.</p>
<p>502<br>00:28:38,680 –&gt; 00:28:45,200<br>So let me go ahead and prefetch those guys while the data system is processing page one,</p>
<p>503<br>00:28:45,200 –&gt; 00:28:46,200<br>all right?</p>
<p>504<br>00:28:46,200 –&gt; 00:28:49,680<br>Go get page two, page three, put it in.</p>
<p>505<br>00:28:49,680 –&gt; 00:28:55,360<br>So by the time you’re finished processing page one, and you come to page two, lo and behold,</p>
<p>506<br>00:28:55,360 –&gt; 00:28:59,440<br>the page you’re looking, the next page you need is already there.</p>
<p>507<br>00:28:59,440 –&gt; 00:29:02,840<br>All right, and just do this all the way down the line.</p>
<p>508<br>00:29:02,840 –&gt; 00:29:05,880<br>All right, we haven’t talked about how we execute queries just yet, but the typically</p>
<p>509<br>00:29:05,880 –&gt; 00:29:11,240<br>the way it works is that you request a page, it’s going to have a bunch of tuples in it.</p>
<p>510<br>00:29:11,240 –&gt; 00:29:15,799<br>Do some kind of computation inside the data that’s in those tuples, and then when you’re</p>
<p>511<br>00:29:15,799 –&gt; 00:29:18,799<br>done, go get the next page, right?</p>
<p>512<br>00:29:18,799 –&gt; 00:29:22,720<br>As you’re doing your scan along the leaf nodes in the query plan tree.</p>
<p>513<br>00:29:22,720 –&gt; 00:29:27,160<br>And so it’s not like we’re just blindly ripping through the pages and say, you know, get,</p>
<p>514<br>00:29:27,160 –&gt; 00:29:32,279<br>get, get, get, get, get, it’s get some think time, do some compute, then go get the next</p>
<p>515<br>00:29:32,279 –&gt; 00:29:33,279<br>page.</p>
<p>516<br>00:29:33,279 –&gt; 00:29:35,960<br>And so that think time is where the data system can say, I have some time to go ahead and</p>
<p>517<br>00:29:35,960 –&gt; 00:29:38,039<br>prefetch the things that you’re needing.</p>
<p>518<br>00:29:38,039 –&gt; 00:29:39,279<br>Right?</p>
<p>519<br>00:29:40,240 –&gt; 00:29:44,879<br>And I don’t have the diagram here, but this is why we have that, that, that pinning mechanism</p>
<p>520<br>00:29:44,879 –&gt; 00:29:45,879<br>before, right?</p>
<p>521<br>00:29:45,879 –&gt; 00:29:50,079<br>I don’t obviously don’t want to fetch in page one, then the data system says in, in</p>
<p>522<br>00:29:50,079 –&gt; 00:29:54,079<br>a background thread, okay, let me go prefetch page three and two, and it goes and swaps</p>
<p>523<br>00:29:54,079 –&gt; 00:29:56,359<br>out page one while you’re still accessing it, right?</p>
<p>524<br>00:29:56,359 –&gt; 00:30:00,119<br>The pin will, the pinning mechanism will, will prevent that.</p>
<p>525<br>00:30:00,119 –&gt; 00:30:01,119<br>Yes?</p>
<p>526<br>00:30:01,119 –&gt; 00:30:07,319<br>Is it, is it possible that different bubbles for, for the standpoint?</p>
<p>527<br>00:30:07,319 –&gt; 00:30:09,319<br>Question, ah, it’s good point, thank you.</p>
<p>528<br>00:30:09,319 –&gt; 00:30:13,439<br>This question is, is it possible for different buffer pool, buffer pool is to hold the same</p>
<p>529<br>00:30:13,439 –&gt; 00:30:14,439<br>page?</p>
<p>530<br>00:30:14,439 –&gt; 00:30:15,439<br>No.</p>
<p>531<br>00:30:15,439 –&gt; 00:30:16,519<br>It’s always being one more corresponded.</p>
<p>532<br>00:30:16,519 –&gt; 00:30:18,240<br>Every page can only exist in one buffer pool.</p>
<p>533<br>00:30:18,240 –&gt; 00:30:22,599<br>Because still that, what would happen if you allowed that, right?</p>
<p>534<br>00:30:22,599 –&gt; 00:30:29,359<br>Well, you could have the page, you will point to the same, point to the same page, different</p>
<p>535<br>00:30:29,359 –&gt; 00:30:32,599<br>page, you will point to the same page, but then depending where the metadata is, like</p>
<p>536<br>00:30:32,599 –&gt; 00:30:38,079<br>the reference counter, the pin marker and things like that, like if that’s separate, separate</p>
<p>537<br>00:30:38,079 –&gt; 00:30:42,480<br>pages, then one buffer pool may say, okay, no one’s accessing it, then let me go swap it</p>
<p>538<br>00:30:42,480 –&gt; 00:30:46,719<br>out, but the other page table has a pin, and you would miss that.</p>
<p>539<br>00:30:46,719 –&gt; 00:30:50,480<br>So yeah, for that reason, it’s a one-way correspondent.</p>
<p>540<br>00:30:50,480 –&gt; 00:30:53,879<br>That’s good point, thank you.</p>
<p>541<br>00:30:53,879 –&gt; 00:30:54,879<br>Yes?</p>
<p>542<br>00:30:54,879 –&gt; 00:30:58,919<br>What’s the relationship between the pin, counter and the latch?</p>
<p>543<br>00:30:58,920 –&gt; 00:31:01,279<br>The question is, what’s the relationship between a pin counter and a latch?</p>
<p>544<br>00:31:01,279 –&gt; 00:31:12,920<br>A pin counter just says that there’s some, some, so the pin counter says there’s some worker</p>
<p>545<br>00:31:12,920 –&gt; 00:31:17,279<br>that’s accessing this page, but I’m not in the page table right now when I’m doing it,</p>
<p>546<br>00:31:17,279 –&gt; 00:31:18,279<br>right?</p>
<p>547<br>00:31:18,279 –&gt; 00:31:22,560<br>I get the pointer to the page, I’m going back to my original diagram.</p>
<p>548<br>00:31:22,560 –&gt; 00:31:26,480<br>Right, go back here.</p>
<p>549<br>00:31:26,480 –&gt; 00:31:32,240<br>So it’s on the page table, but like this guy says, give me page two, I take a latch in</p>
<p>550<br>00:31:32,240 –&gt; 00:31:37,160<br>the page table to go get the pointer to that, to that, to that page.</p>
<p>551<br>00:31:37,160 –&gt; 00:31:43,120<br>And then before I get the pointer back to my execution, and I pin it, because now I’m</p>
<p>552<br>00:31:43,120 –&gt; 00:31:46,279<br>outside the page table, because the pin is protected, the latch is protecting the data</p>
<p>553<br>00:31:46,279 –&gt; 00:31:50,400<br>structure, but I’m out of the data structure, but I have a reference to the page, so I have</p>
<p>554<br>00:31:50,400 –&gt; 00:31:53,480<br>the pin just to say someone is actually reading this page.</p>
<p>555<br>00:31:53,480 –&gt; 00:31:57,960<br>And then when I’m done with it, I can then, you know, decrement that reference counter,</p>
<p>556<br>00:31:57,960 –&gt; 00:32:03,200<br>which potentially unlocked or released the pin, and then now the buffer manager can</p>
<p>557<br>00:32:03,200 –&gt; 00:32:07,880<br>side, okay, I know for this page two, nobody has a pin, there’s nobody referencing it,</p>
<p>558<br>00:32:07,880 –&gt; 00:32:10,400<br>so I’m free to evict it.</p>
<p>559<br>00:32:10,400 –&gt; 00:32:13,799<br>So again, the latch protects the data structure, the pin protects the page.</p>
<p>560<br>00:32:13,799 –&gt; 00:32:14,799<br>Yes.</p>
<p>561<br>00:32:14,799 –&gt; 00:32:19,480<br>So the page table is not like inside the buffer pool, like sort of separately, and it can</p>
<p>562<br>00:32:19,480 –&gt; 00:32:20,879<br>actually relate it.</p>
<p>563<br>00:32:20,879 –&gt; 00:32:26,279<br>All right, question is the, the, the, the, the, the, the, the, the, the, the, the, the,</p>
<p>564<br>00:32:26,279 –&gt; 00:32:27,279<br>it is the buffer pool.</p>
<p>565<br>00:32:27,279 –&gt; 00:32:29,279<br>I guess like, it’s not in this.</p>
<p>566<br>00:32:29,279 –&gt; 00:32:35,159<br>Yeah, this is like a hologram, but like, it’s in this box, how about that?</p>
<p>567<br>00:32:35,159 –&gt; 00:32:36,159<br>Right?</p>
<p>568<br>00:32:36,159 –&gt; 00:32:40,319<br>Like, these are the, like, these are the frames, there’s some other page table data structure</p>
<p>569<br>00:32:40,319 –&gt; 00:32:41,319<br>here, yes.</p>
<p>570<br>00:32:42,319 –&gt; 00:32:43,319<br>Yes.</p>
<p>571<br>00:32:43,319 –&gt; 00:32:58,599<br>So this question is, does the buffer manager have access to the query plan?</p>
<p>572<br>00:32:58,599 –&gt; 00:32:59,839<br>No, right?</p>
<p>573<br>00:32:59,839 –&gt; 00:33:04,079<br>The, because we have these layers, but you can send it hints.</p>
<p>574<br>00:33:04,079 –&gt; 00:33:07,079<br>Boss tub doesn’t support those hints, but you can send it hints like, I’m accessing this</p>
<p>575<br>00:33:07,079 –&gt; 00:33:12,480<br>page, and here’s likely the next page is I’m going to access as well.</p>
<p>576<br>00:33:12,480 –&gt; 00:33:13,480<br>Yes.</p>
<p>577<br>00:33:13,480 –&gt; 00:33:14,480<br>Then you said something about static.</p>
<p>578<br>00:33:14,480 –&gt; 00:33:19,159<br>You’re not, there’s, there’s, well, where the buffer pool manager did, where the</p>
<p>579<br>00:33:19,159 –&gt; 00:33:22,119<br>topic we know, which thing does it still get?</p>
<p>580<br>00:33:22,119 –&gt; 00:33:23,119<br>What do you might statically know?</p>
<p>581<br>00:33:23,119 –&gt; 00:33:31,119<br>Like, if I do, if I send a, a comment, yes, yes, what the buffer pool manager did</p>
<p>582<br>00:33:31,119 –&gt; 00:33:34,519<br>you know, what the purpose of the bulk in that?</p>
<p>583<br>00:33:34,519 –&gt; 00:33:35,519<br>Okay.</p>
<p>584<br>00:33:35,519 –&gt; 00:33:41,599<br>So the question is, if I have a select query, who is, who is figuring out what the pre-fetch?</p>
<p>585<br>00:33:41,599 –&gt; 00:33:42,599<br>Maybe that’s what you’re really asking.</p>
<p>586<br>00:33:42,599 –&gt; 00:33:43,599<br>Right?</p>
<p>587<br>00:33:43,599 –&gt; 00:33:45,599<br>This has to come up with the execution engine.</p>
<p>588<br>00:33:45,599 –&gt; 00:33:46,599<br>Right?</p>
<p>589<br>00:33:46,599 –&gt; 00:33:53,439<br>The buffer manager doesn’t know about, it’s just, you know, it’s sort of division responsibilities.</p>
<p>590<br>00:33:53,439 –&gt; 00:33:58,119<br>Like, the profile manager shouldn’t have to infer, like, for this query plan on this</p>
<p>591<br>00:33:58,119 –&gt; 00:33:59,839<br>table, what page I’m going to read.</p>
<p>592<br>00:33:59,839 –&gt; 00:34:02,079<br>That all comes down below because you think about it too.</p>
<p>593<br>00:34:02,079 –&gt; 00:34:04,879<br>That’s where the execution has to ask, I know what page it needs to read anyway because</p>
<p>594<br>00:34:04,879 –&gt; 00:34:06,399<br>that’s a read them.</p>
<p>595<br>00:34:06,399 –&gt; 00:34:10,079<br>So all that logic is, is, is in that part of the system, which we’ll cover in two weeks.</p>
<p>596<br>00:34:10,079 –&gt; 00:34:13,599<br>So like, I said, I think it’s an end, and then should we have the call, the call, the</p>
<p>597<br>00:34:13,599 –&gt; 00:34:14,599<br>technical security.</p>
<p>598<br>00:34:14,599 –&gt; 00:34:15,599<br>Yeah.</p>
<p>599<br>00:34:15,599 –&gt; 00:34:19,799<br>So the, the execution engine should say, I’m fetching page one now, but by the way, I’m</p>
<p>600<br>00:34:19,799 –&gt; 00:34:21,279<br>also going to fetch page two and three.</p>
<p>601<br>00:34:21,279 –&gt; 00:34:22,279<br>Right?</p>
<p>602<br>00:34:22,279 –&gt; 00:34:27,079<br>Because think about it, like, you could have a, you could have like, in your select call,</p>
<p>603<br>00:34:27,079 –&gt; 00:34:30,719<br>in the query here, you have a limit 10, right?</p>
<p>604<br>00:34:30,719 –&gt; 00:34:32,159<br>With no wear clause.</p>
<p>605<br>00:34:32,159 –&gt; 00:34:37,440<br>So in the first page, I got five tuples and the second page, or the page here, I got</p>
<p>606<br>00:34:37,440 –&gt; 00:34:40,639<br>five tuples and page one, I got two tuples.</p>
<p>607<br>00:34:40,639 –&gt; 00:34:43,639<br>Therefore, I know I’m going to have to read more pages so you can send that hit, you know,</p>
<p>608<br>00:34:43,639 –&gt; 00:34:45,440<br>ahead of time or something like that.</p>
<p>609<br>00:34:45,440 –&gt; 00:34:46,440<br>Right?</p>
<p>610<br>00:34:46,440 –&gt; 00:34:50,319<br>And then that’s the beauty of having a declarative language like SQL, where you know what</p>
<p>611<br>00:34:50,319 –&gt; 00:34:52,519<br>you’re going to do ahead of time.</p>
<p>612<br>00:34:52,519 –&gt; 00:34:53,519<br>Right?</p>
<p>613<br>00:34:53,519 –&gt; 00:34:55,119<br>At least at a, at a high level.</p>
<p>614<br>00:34:55,119 –&gt; 00:34:59,920<br>So with enough, you have enough information where you could make these kind of decisions.</p>
<p>615<br>00:34:59,920 –&gt; 00:35:00,920<br>Yes?</p>
<p>616<br>00:35:00,920 –&gt; 00:35:08,279<br>So you never prefetch pages in the database that you know is the use for simulation, like,</p>
<p>617<br>00:35:08,279 –&gt; 00:35:09,679<br>I’m sure.</p>
<p>618<br>00:35:09,679 –&gt; 00:35:15,880<br>So, this question is, do you never prefetch pages unless you’re absolutely certain you’re</p>
<p>619<br>00:35:15,880 –&gt; 00:35:16,880<br>going to need them?</p>
<p>620<br>00:35:16,880 –&gt; 00:35:18,759<br>Maybe that’s what you’re asking?</p>
<p>621<br>00:35:18,759 –&gt; 00:35:22,920<br>Actually, I don’t, I don’t know how aggressive they are.</p>
<p>622<br>00:35:22,920 –&gt; 00:35:27,480<br>Yeah.</p>
<p>623<br>00:35:27,480 –&gt; 00:35:32,119<br>The commercial systems do this much better and they’re obviously closed source.</p>
<p>624<br>00:35:32,119 –&gt; 00:35:36,119<br>So, virtual scan is pretty easy.</p>
<p>625<br>00:35:36,119 –&gt; 00:35:43,680<br>For index scans, next slide, this one can be kind of tricky as well because you may not</p>
<p>626<br>00:35:43,680 –&gt; 00:35:49,960<br>be able to prefetch without falling along the pages as much.</p>
<p>627<br>00:35:49,960 –&gt; 00:35:51,920<br>You may not be able to jump ahead.</p>
<p>628<br>00:35:51,920 –&gt; 00:35:54,920<br>So I think in index scans, the pre-venson is a bit more conservative.</p>
<p>629<br>00:35:54,920 –&gt; 00:36:00,280<br>Squatual scan, you could just, you know, you can jump a lot farther.</p>
<p>630<br>00:36:00,280 –&gt; 00:36:03,519<br>And we haven’t been talking to like, there’s all a bunch of other factors too.</p>
<p>631<br>00:36:03,519 –&gt; 00:36:10,360<br>As always, in the case in databases, like, there’s like multi-versionings or who knows whether</p>
<p>632<br>00:36:10,360 –&gt; 00:36:14,360<br>like, you know, yes, the next page I’m going to read has 10 tuples, but like, only three</p>
<p>633<br>00:36:14,360 –&gt; 00:36:15,559<br>may be visible.</p>
<p>634<br>00:36:15,559 –&gt; 00:36:16,960<br>It’s complicated.</p>
<p>635<br>00:36:17,960 –&gt; 00:36:18,960<br>All right.</p>
<p>636<br>00:36:18,960 –&gt; 00:36:23,079<br>So, going back here, the threshold scan, the OS can kind of do this, right?</p>
<p>637<br>00:36:23,079 –&gt; 00:36:27,920<br>Assuming your pages are contiguous, the OS read ahead can kind of figure this out.</p>
<p>638<br>00:36:27,920 –&gt; 00:36:35,360<br>What it can’t do is infer the logical data structure that the pages physically represent and</p>
<p>639<br>00:36:35,360 –&gt; 00:36:36,760<br>prefetch according to that.</p>
<p>640<br>00:36:36,760 –&gt; 00:36:40,800<br>Because again, it doesn’t know what a B plus 3 is, doesn’t know what a hash table is,</p>
<p>641<br>00:36:40,800 –&gt; 00:36:42,760<br>at least at the page level.</p>
<p>642<br>00:36:42,760 –&gt; 00:36:47,240<br>So we do because we’re the ones actually running it.</p>
<p>643<br>00:36:47,240 –&gt; 00:36:53,400<br>So let’s say I have a query like the select start from A where the value between 150 and</p>
<p>644<br>00:36:53,400 –&gt; 00:36:58,400<br>I can do this by reading, by doing an index scan.</p>
<p>645<br>00:36:58,400 –&gt; 00:37:01,240<br>We haven’t talked about B plus 3’s yet, but again, it’s a tree data structure that shouldn’t</p>
<p>646<br>00:37:01,240 –&gt; 00:37:06,360<br>be farmed at anyone in this class and then assume that along the leaf nodes, the values</p>
<p>647<br>00:37:06,360 –&gt; 00:37:10,040<br>are sorted based on the key, right?</p>
<p>648<br>00:37:10,039 –&gt; 00:37:15,279<br>So to do this, run this particular query, I have to start with the root node, that’s page</p>
<p>649<br>00:37:15,279 –&gt; 00:37:19,360<br>0, I go get that, put that in my data, put that in my buffer pool.</p>
<p>650<br>00:37:19,360 –&gt; 00:37:24,840<br>Then I traverse down to this side of the tree, I get page 1, put that in my buffer pool,</p>
<p>651<br>00:37:24,840 –&gt; 00:37:29,199<br>but then now I’m going to jump down to this leaf node here and because I have this, this</p>
<p>652<br>00:37:29,199 –&gt; 00:37:35,279<br>wear clause that is going to be reading so many, so many records, I know I need to at least</p>
<p>653<br>00:37:35,279 –&gt; 00:37:39,199<br>go to over to the page 5, right?</p>
<p>654<br>00:37:39,199 –&gt; 00:37:46,399<br>So I’ll go get page 3, but I also can potentially pre-fetch page 5.</p>
<p>655<br>00:37:46,399 –&gt; 00:37:51,879<br>But again, the operating system can’t do this, can’t know this because page 3 and page 5</p>
<p>656<br>00:37:51,879 –&gt; 00:37:52,960<br>are not contiguous.</p>
<p>657<br>00:37:52,960 –&gt; 00:37:58,759<br>The data system knows because it knows that if I at least get the index page 3, I have</p>
<p>658<br>00:37:58,759 –&gt; 00:38:04,639<br>a sibling pointer, a page ID, so I know what the next page I’m going to read over along</p>
<p>659<br>00:38:04,639 –&gt; 00:38:08,759<br>the leaf nodes as I scan across, so therefore I can go ahead and pre-fetch that.</p>
<p>660<br>00:38:09,560 –&gt; 00:38:12,960<br>Even though it’s not in sequential order of the other pages.</p>
<p>661<br>00:38:12,960 –&gt; 00:38:18,600<br>Again, there’s just another example why we want to do this in the side of the system,</p>
<p>662<br>00:38:18,600 –&gt; 00:38:20,840<br>not the OS.</p>
<p>663<br>00:38:20,840 –&gt; 00:38:27,200<br>All right, the next optimization we can do is called scan sharing.</p>
<p>664<br>00:38:27,200 –&gt; 00:38:30,520<br>Sometimes call it synchronized scans in like some of the order systems.</p>
<p>665<br>00:38:30,520 –&gt; 00:38:33,960<br>The basic idea here is a bunch of queries show up.</p>
<p>666<br>00:38:33,960 –&gt; 00:38:36,480<br>They want access to the same table.</p>
<p>667<br>00:38:36,480 –&gt; 00:38:40,240<br>When I’m getting started, I start scanning through the pages.</p>
<p>668<br>00:38:40,240 –&gt; 00:38:46,519<br>We can recognize that they need the same data, so we just pick you back off of them.</p>
<p>669<br>00:38:46,519 –&gt; 00:38:51,760<br>Our cursor attaches there, cursor, and we read the same pages at the same time.</p>
<p>670<br>00:38:51,760 –&gt; 00:38:55,760<br>So we remove the redundant IO.</p>
<p>671<br>00:38:55,760 –&gt; 00:38:59,719<br>This is different than result caching, which we want to talk about the semester of result</p>
<p>672<br>00:38:59,719 –&gt; 00:39:06,440<br>caching basically, query shows up, I compute some answer, I save that result in a cache,</p>
<p>673<br>00:39:06,440 –&gt; 00:39:10,559<br>query shows up again, potentially slightly different, which is harder to do,</p>
<p>674<br>00:39:10,559 –&gt; 00:39:15,400<br>but the same query shows up again, I don’t have to rerun the query, I just send the result back.</p>
<p>675<br>00:39:15,400 –&gt; 00:39:18,800<br>The scan sharing is really at the low physical levels of the access method,</p>
<p>676<br>00:39:18,800 –&gt; 00:39:22,360<br>how we’re actually scanning the pages, we can recognize that they two queries</p>
<p>677<br>00:39:22,360 –&gt; 00:39:30,320<br>need to read the same thing, and therefore we can reuse any pages as we go along and fetch them.</p>
<p>678<br>00:39:30,320 –&gt; 00:39:34,440<br>So we don’t have conflicting cursors trying to read the same pages at the same time.</p>
<p>679<br>00:39:36,440 –&gt; 00:39:39,320<br>So this is repeating what I just said.</p>
<p>680<br>00:39:39,320 –&gt; 00:39:48,599<br>For the DB2 SQL Server, Teradata, and Postgres, they actually support the full scan sharing</p>
<p>681<br>00:39:48,599 –&gt; 00:39:54,599<br>for queries that aren’t exactly the same, but at least they’re reading the same tables.</p>
<p>682<br>00:39:54,599 –&gt; 00:40:00,320<br>In Oracle, the only support cursor sharing for queries that show up that look exactly the same.</p>
<p>683<br>00:40:00,320 –&gt; 00:40:04,360<br>I mean, literally exactly the same, because they’re basically hashing the string</p>
<p>684<br>00:40:04,360 –&gt; 00:40:06,599<br>to see whether there’s a match.</p>
<p>685<br>00:40:06,599 –&gt; 00:40:11,079<br>If you go look at the documentation, if you have queries like Select Star from employees,</p>
<p>686<br>00:40:11,079 –&gt; 00:40:15,480<br>Select Star from employees of the capital E, or an extra space before the front calls,</p>
<p>687<br>00:40:15,480 –&gt; 00:40:19,160<br>these won’t match because when you hash the strings, they’re not the same.</p>
<p>688<br>00:40:19,160 –&gt; 00:40:22,120<br>So it has to literally be the exact same query running the exact same time,</p>
<p>689<br>00:40:22,120 –&gt; 00:40:25,559<br>and then they can share it.</p>
<p>690<br>00:40:25,559 –&gt; 00:40:26,800<br>So conceptually looks like this.</p>
<p>691<br>00:40:26,800 –&gt; 00:40:34,320<br>So say I have query one, once there’s a summation on the value column from table A,</p>
<p>692<br>00:40:34,320 –&gt; 00:40:39,280<br>so it attaches a cursor to the pages, starts reading them, fetching them into the buffer pool.</p>
<p>693<br>00:40:39,280 –&gt; 00:40:40,280<br>Right?</p>
<p>694<br>00:40:40,280 –&gt; 00:40:42,280<br>First thing gets page 0, that’s not there.</p>
<p>695<br>00:40:42,280 –&gt; 00:40:45,519<br>So it puts that in memory, goes down to page 2, and so forth.</p>
<p>696<br>00:40:45,519 –&gt; 00:40:46,519<br>Right?</p>
<p>697<br>00:40:46,519 –&gt; 00:40:51,160<br>So now we get to page 3, and we haven’t talked about the eviction policy, but page 0 is the</p>
<p>698<br>00:40:51,160 –&gt; 00:40:52,559<br>last one that was used.</p>
<p>699<br>00:40:52,559 –&gt; 00:40:56,600<br>So we go ahead and evict page 0 and put in page 3.</p>
<p>700<br>00:40:56,600 –&gt; 00:41:01,800<br>But now Q2 shows up, once the computer and average instead of summation, on the same table</p>
<p>701<br>00:41:01,800 –&gt; 00:41:03,000<br>though.</p>
<p>702<br>00:41:03,000 –&gt; 00:41:07,719<br>So the naive thing to do is to have it start at the beginning, just like the first cursor,</p>
<p>703<br>00:41:07,719 –&gt; 00:41:10,599<br>and just scan down and read the pages at the same time.</p>
<p>704<br>00:41:10,599 –&gt; 00:41:11,760<br>Right?</p>
<p>705<br>00:41:11,760 –&gt; 00:41:17,440<br>But obviously this is stupid because in this scenario here, we just, the Q2 needs to read</p>
<p>706<br>00:41:17,440 –&gt; 00:41:21,639<br>page 0, but Q1 just got that evict from the buffer pool.</p>
<p>707<br>00:41:21,639 –&gt; 00:41:22,639<br>Right?</p>
<p>708<br>00:41:22,639 –&gt; 00:41:26,960<br>So the very first thing we would do here is evict, if you want to Q2, we had our evict page</p>
<p>709<br>00:41:26,960 –&gt; 00:41:28,960<br>2 to put page 0 in.</p>
<p>710<br>00:41:28,960 –&gt; 00:41:31,800<br>But again, we just got rid of page 0.</p>
<p>711<br>00:41:31,800 –&gt; 00:41:34,720<br>So the better thing to do is you attach Q2 to Q1.</p>
<p>712<br>00:41:34,720 –&gt; 00:41:42,680<br>Again, at the lowest level as you scan the table and let Q2 ride along Q1, see all the pages</p>
<p>713<br>00:41:42,680 –&gt; 00:41:45,280<br>that it sees and processes them accordingly.</p>
<p>714<br>00:41:45,280 –&gt; 00:41:49,880<br>And then Q1 goes away, but then Q2 recognizes, oh, there’s a bunch of pages at the top of</p>
<p>715<br>00:41:49,880 –&gt; 00:41:51,480<br>the table that I missed.</p>
<p>716<br>00:41:51,480 –&gt; 00:41:57,280<br>Let me go back and get all those, and then compete my query.</p>
<p>717<br>00:41:57,280 –&gt; 00:41:58,120<br>Right?</p>
<p>718<br>00:41:59,119 –&gt; 00:42:02,119<br>What’s the potential problem with this?</p>
<p>719<br>00:42:02,119 –&gt; 00:42:03,119<br>Yes.</p>
<p>720<br>00:42:03,119 –&gt; 00:42:07,119<br>So it’s hard to implement.</p>
<p>721<br>00:42:07,119 –&gt; 00:42:10,119<br>Not that hard.</p>
<p>722<br>00:42:10,119 –&gt; 00:42:22,119<br>If the aggregate function depends on the ordering of the data, which again, relational model,</p>
<p>723<br>00:42:22,119 –&gt; 00:42:25,119<br>it doesn’t, we know functions, yes.</p>
<p>724<br>00:42:26,119 –&gt; 00:42:29,119<br>You’re close to it, but basically it saved you had a limit clause.</p>
<p>725<br>00:42:29,119 –&gt; 00:42:30,119<br>Right?</p>
<p>726<br>00:42:30,119 –&gt; 00:42:31,119<br>Right?</p>
<p>727<br>00:42:31,119 –&gt; 00:42:35,119<br>I want to get the first 100 tuples and compete the average on that.</p>
<p>728<br>00:42:35,119 –&gt; 00:42:37,119<br>Again, relational model is unordered.</p>
<p>729<br>00:42:37,119 –&gt; 00:42:42,119<br>So technically it’s correct if Q2 starts at page 0 versus page 3.</p>
<p>730<br>00:42:42,119 –&gt; 00:42:45,119<br>And again, it gets 100 tuples and it competes the average.</p>
<p>731<br>00:42:45,119 –&gt; 00:42:47,119<br>Both answers are technically correct.</p>
<p>732<br>00:42:47,119 –&gt; 00:42:50,119<br>From the application perspective, this looks fucked up because now you’ve got queries that</p>
<p>733<br>00:42:50,119 –&gt; 00:42:54,119<br>stay in query at two different times show up with different results.</p>
<p>734<br>00:42:54,119 –&gt; 00:42:57,119<br>So I was being glib and I said, oh, yeah, it’s not that hard to implement.</p>
<p>735<br>00:42:57,119 –&gt; 00:42:58,119<br>You can attach the cursor.</p>
<p>736<br>00:42:58,119 –&gt; 00:43:03,119<br>Again, if there’s no, if there’s no ordering constraints, it’s easy.</p>
<p>737<br>00:43:03,119 –&gt; 00:43:11,119<br>But if you need to make sure that your queries produce the same results over and over again, then this can be a bit tricky.</p>
<p>738<br>00:43:11,119 –&gt; 00:43:14,119<br>Now, this is part of the reason, again, I’m not trying to bash Oracle.</p>
<p>739<br>00:43:14,119 –&gt; 00:43:18,119<br>Like the easiest thing to do is if it’s the exact same query, then I’ll do a cursor sharing.</p>
<p>740<br>00:43:18,119 –&gt; 00:43:23,119<br>The tricky thing is to figure out, again, to understand the semantics of what the query is actually wants to do,</p>
<p>741<br>00:43:23,119 –&gt; 00:43:28,119<br>and then identify when is it safe to attach the one cursor to another,</p>
<p>742<br>00:43:28,119 –&gt; 00:43:37,119<br>and then how to maybe go back and get more results as needed.</p>
<p>743<br>00:43:37,119 –&gt; 00:43:47,119<br>So this is a, going sort of extreme scan sharing is this idea called continuous scan sharing.</p>
<p>744<br>00:43:47,119 –&gt; 00:43:51,119<br>I’ll say up front, too, that no real system does this.</p>
<p>745<br>00:43:51,119 –&gt; 00:43:54,119<br>I just like it because it’s a different way to think about how to build a system.</p>
<p>746<br>00:43:54,119 –&gt; 00:44:01,119<br>So again, going back to his point, he said it’d be hard to implement the scan sharing, potentially, yes.</p>
<p>747<br>00:44:01,119 –&gt; 00:44:10,119<br>But what if he just did the dumbest thing and just had everything’s due scan sharing because the cursor is just running all the time?</p>
<p>748<br>00:44:10,119 –&gt; 00:44:17,119<br>So it literally reads one page after another, brings that into your buffer pool, and then when you’re done,</p>
<p>749<br>00:44:17,119 –&gt; 00:44:20,119<br>it just loops back around and does it all over again.</p>
<p>750<br>00:44:20,119 –&gt; 00:44:32,119<br>So now, like when a query shows up, you just kind of pop along whenever it’s going and then get what you need, and then you go away and you’re done.</p>
<p>751<br>00:44:32,119 –&gt; 00:44:35,119<br>Good idea or bad idea?</p>
<p>752<br>00:44:35,119 –&gt; 00:44:36,119<br>What’s that?</p>
<p>753<br>00:44:36,119 –&gt; 00:44:38,119<br>Or bad? Why?</p>
<p>754<br>00:44:38,119 –&gt; 00:44:42,119<br>You’re probably doing a lot of extra reads that you may not need.</p>
<p>755<br>00:44:42,119 –&gt; 00:44:44,119<br>I guess it depends on if…</p>
<p>756<br>00:44:44,119 –&gt; 00:44:50,119<br>So assuming every query is doing a full table scan or almost a full table scan.</p>
<p>757<br>00:44:50,119 –&gt; 00:44:54,119<br>Where do we have some tables sitting around and we’re just staying through it?</p>
<p>758<br>00:44:54,119 –&gt; 00:44:55,119<br>What if you have a table?</p>
<p>759<br>00:44:55,119 –&gt; 00:45:00,119<br>So you could maybe say the cursor doesn’t get fired until the query shows up and touches the table.</p>
<p>760<br>00:45:00,119 –&gt; 00:45:02,119<br>You’re back.</p>
<p>761<br>00:45:02,119 –&gt; 00:45:06,119<br>You can both of our pretty things into memory and then you can read them right after.</p>
<p>762<br>00:45:06,119 –&gt; 00:45:09,119<br>Yeah, but…</p>
<p>763<br>00:45:10,119 –&gt; 00:45:16,119<br>Well, say you have to do that anyway for the full table scan because the table doesn’t fit in memory anyway.</p>
<p>764<br>00:45:16,119 –&gt; 00:45:22,119<br>So, yes.</p>
<p>765<br>00:45:22,119 –&gt; 00:45:24,119<br>Is it hard to skip around?</p>
<p>766<br>00:45:24,119 –&gt; 00:45:26,119<br>It’s hard to skip around.</p>
<p>767<br>00:45:26,119 –&gt; 00:45:28,119<br>Well, in some ways, it’s also too.</p>
<p>768<br>00:45:28,119 –&gt; 00:45:31,119<br>It makes your runtime kind of deterministic, right?</p>
<p>769<br>00:45:31,119 –&gt; 00:45:35,119<br>Because you know it’s going to be at least n, where it ends in a number of pages.</p>
<p>770<br>00:45:36,119 –&gt; 00:45:37,119<br>That’s just for scans.</p>
<p>771<br>00:45:37,119 –&gt; 00:45:39,119<br>It joins our whole number of beats we haven’t talked about yet.</p>
<p>772<br>00:45:39,119 –&gt; 00:45:44,119<br>So, if it’s on prem, you’ve already paid for the hardware ignoring energy costs.</p>
<p>773<br>00:45:44,119 –&gt; 00:45:46,119<br>This is kind of okay.</p>
<p>774<br>00:45:46,119 –&gt; 00:45:48,119<br>But if it’s running in the cloud, would you actually pay in per eye-op?</p>
<p>775<br>00:45:48,119 –&gt; 00:45:50,119<br>Then this is actually terrible, right?</p>
<p>776<br>00:45:50,119 –&gt; 00:45:53,119<br>Because you end up reading more data than you eventually actually need.</p>
<p>777<br>00:45:53,119 –&gt; 00:46:00,119<br>So I was saying there’s only one prototype I know that did this out of ECH Zurich, Corker Skendo.</p>
<p>778<br>00:46:01,119 –&gt; 00:46:07,119<br>And they built it specifically for a sort of telecom business where they needed deterministic runtimes or queries.</p>
<p>779<br>00:46:07,119 –&gt; 00:46:09,119<br>But this was a few years ago.</p>
<p>780<br>00:46:09,119 –&gt; 00:46:12,119<br>And it was another prototype I had the same kind of thing.</p>
<p>781<br>00:46:12,119 –&gt; 00:46:13,119<br>So it’s an interesting idea.</p>
<p>782<br>00:46:13,119 –&gt; 00:46:16,119<br>It’s a different way to think about a system that’s unorthodox.</p>
<p>783<br>00:46:16,119 –&gt; 00:46:19,119<br>I just like to present it as a different way to think about things.</p>
<p>784<br>00:46:19,119 –&gt; 00:46:20,119<br>There’s wide-loved databases.</p>
<p>785<br>00:46:20,119 –&gt; 00:46:23,119<br>There’s so many different ways to solve the same problem over and over again.</p>
<p>786<br>00:46:23,119 –&gt; 00:46:27,119<br>And we can debate what’s good and what’s bad.</p>
<p>787<br>00:46:27,119 –&gt; 00:46:30,119<br>So last optimization I talk about is called buffer pool bypass.</p>
<p>788<br>00:46:30,119 –&gt; 00:46:37,119<br>And the idea here is that if we have a query that’s running a Squancho scan,</p>
<p>789<br>00:46:37,119 –&gt; 00:46:40,119<br>we have to bring things off a disk in the memory.</p>
<p>790<br>00:46:40,119 –&gt; 00:46:47,119<br>But maybe we don’t want to put it into our buffer pool because one needs to pay for the maintenance cost of the buffer pool.</p>
<p>791<br>00:46:47,119 –&gt; 00:46:51,119<br>In the patient, we’ll think of latch, update things, and VIX stuff and so forth.</p>
<p>792<br>00:46:51,119 –&gt; 00:46:54,119<br>And then also, too, if we’re doing a Squancho scan,</p>
<p>793<br>00:46:54,119 –&gt; 00:46:57,119<br>the data we just read may not actually be useful,</p>
<p>794<br>00:46:57,119 –&gt; 00:47:00,119<br>well, it’s not going to be useful for our query because we’re getting Squancho scan,</p>
<p>795<br>00:47:00,119 –&gt; 00:47:05,119<br>we’re only going to meet the table once, usually.</p>
<p>796<br>00:47:05,119 –&gt; 00:47:11,119<br>And so rather than having all these different workers running the same time,</p>
<p>797<br>00:47:11,119 –&gt; 00:47:14,119<br>doing Squancho scans and polluting the page table,</p>
<p>798<br>00:47:14,119 –&gt; 00:47:20,119<br>what if we just give every worker its own little piece of memory,</p>
<p>799<br>00:47:20,119 –&gt; 00:47:25,119<br>like a working memory, and then any page we read,</p>
<p>800<br>00:47:25,119 –&gt; 00:47:27,119<br>we put it into that, that worker’s memory.</p>
<p>801<br>00:47:27,119 –&gt; 00:47:29,119<br>Yes, you could have two duplicates.</p>
<p>802<br>00:47:29,119 –&gt; 00:47:32,119<br>It only works if it’s read only, you can’t do rights.</p>
<p>803<br>00:47:32,119 –&gt; 00:47:34,119<br>And then that way it’s just like a circular buffer,</p>
<p>804<br>00:47:34,119 –&gt; 00:47:37,119<br>we just keep filling up and wrap around.</p>
<p>805<br>00:47:37,119 –&gt; 00:47:39,119<br>So a bunch of systems support this,</p>
<p>806<br>00:47:39,119 –&gt; 00:47:41,119<br>Oracle SQL Server Postgres and Informix.</p>
<p>807<br>00:47:41,119 –&gt; 00:47:46,119<br>I think this originated in Formix, and they call it light scans, light meaning because again,</p>
<p>808<br>00:47:46,119 –&gt; 00:47:49,119<br>you don’t touch the heavyweight page table in the buffer pool.</p>
<p>809<br>00:47:49,119 –&gt; 00:47:55,119<br>And the idea here is that I can potentially not pollute my page table because the data I need,</p>
<p>810<br>00:47:55,119 –&gt; 00:47:59,119<br>sorry, but the data I need is sort of local to me.</p>
<p>811<br>00:47:59,119 –&gt; 00:48:04,119<br>Of course, the downside of this is that you lose the sharing capability of two workers</p>
<p>812<br>00:48:04,119 –&gt; 00:48:08,119<br>need the same pages at the same time, or one soon after another,</p>
<p>813<br>00:48:08,119 –&gt; 00:48:12,119<br>then you lose that reuse possibility.</p>
<p>814<br>00:48:12,119 –&gt; 00:48:18,119<br>Again, it’s another optimization that we can do because we control exactly what the queries are actually,</p>
<p>815<br>00:48:18,119 –&gt; 00:48:21,119<br>what they’re actually executing in touch.</p>
<p>816<br>00:48:21,119 –&gt; 00:48:25,119<br>All right.</p>
<p>817<br>00:48:25,119 –&gt; 00:48:29,119<br>So we sort of dance around this idea of a dicting data,</p>
<p>818<br>00:48:29,119 –&gt; 00:48:31,119<br>our dicting page is more profitable.</p>
<p>819<br>00:48:31,119 –&gt; 00:48:34,119<br>So now we got to talk about how we’re actually going to do it.</p>
<p>820<br>00:48:34,119 –&gt; 00:48:37,119<br>You need to know this because it’s project one.</p>
<p>821<br>00:48:37,119 –&gt; 00:48:43,119<br>So when the execution just says, okay, I’m bringing a page into memory,</p>
<p>822<br>00:48:43,119 –&gt; 00:48:46,119<br>I’m going to put it into a frame.</p>
<p>823<br>00:48:46,119 –&gt; 00:48:50,119<br>But if there’s no free frames, it has to decide what to evict.</p>
<p>824<br>00:48:50,119 –&gt; 00:48:52,119<br>It’s a cache.</p>
<p>825<br>00:48:52,119 –&gt; 00:48:55,119<br>It should not be ground-break.</p>
<p>826<br>00:48:55,119 –&gt; 00:49:02,119<br>So there’s a bunch of different metrics and objectives we have to consider in our</p>
<p>827<br>00:49:02,119 –&gt; 00:49:07,119<br>eviction policy that’s going to depend on various factors of our implementation of our database system.</p>
<p>828<br>00:49:07,119 –&gt; 00:49:10,119<br>Obviously, one, our eviction policy to be correct.</p>
<p>829<br>00:49:10,119 –&gt; 00:49:13,119<br>We don’t want an evict to page, then immediately that page is the most,</p>
<p>830<br>00:49:13,119 –&gt; 00:49:17,119<br>you know, the most used thing and therefore we keep reading and writing it from disk open over again.</p>
<p>831<br>00:49:17,119 –&gt; 00:49:19,119<br>Could that be bad?</p>
<p>832<br>00:49:19,119 –&gt; 00:49:22,119<br>We want to, our eviction policy to be fast.</p>
<p>833<br>00:49:22,119 –&gt; 00:49:25,119<br>We don’t want to, you know, if it’s a, if it’s a,</p>
<p>834<br>00:49:25,119 –&gt; 00:49:28,119<br>we’re using an NP-complete algorithm or exponential algorithm.</p>
<p>835<br>00:49:28,119 –&gt; 00:49:31,119<br>We don’t want to take three seconds to decide what page we have to evict because</p>
<p>836<br>00:49:31,119 –&gt; 00:49:35,119<br>monitors go read from disk because that would, that would have been a lot faster in the first place.</p>
<p>837<br>00:49:35,119 –&gt; 00:49:40,119<br>And related to this, we also don’t want to have a big cost of maintaining the metadata we need</p>
<p>838<br>00:49:40,119 –&gt; 00:49:47,119<br>to keep track of how pages are being accessed so that we can make a decision what to evict.</p>
<p>839<br>00:49:47,119 –&gt; 00:49:50,119<br>So again, this is the oldest problem in computer science.</p>
<p>840<br>00:49:50,119 –&gt; 00:49:54,119<br>I have the other oldest problem in computer science is naming something or naming a system.</p>
<p>841<br>00:49:54,119 –&gt; 00:49:57,119<br>We can talk about how bus type got named but,</p>
<p>842<br>00:49:57,119 –&gt; 00:49:59,119<br>everyone has a caching paper.</p>
<p>843<br>00:49:59,119 –&gt; 00:50:03,119<br>I think I have two.</p>
<p>844<br>00:50:03,119 –&gt; 00:50:08,119<br>So the most obvious easy thing to do is do LRU, at least recently used.</p>
<p>845<br>00:50:08,119 –&gt; 00:50:12,119<br>The basic idea here is just maintaining the timestamp or keep track of a link,</p>
<p>846<br>00:50:12,119 –&gt; 00:50:17,119<br>a link list of when a, when pages were last touched.</p>
<p>847<br>00:50:17,119 –&gt; 00:50:22,119<br>And then when it comes, comes time to evict the page, we just go to the tail end of the link list and pop,</p>
<p>848<br>00:50:22,119 –&gt; 00:50:26,119<br>pop whatever is there and that’s, you know, that one has been accessing a while.</p>
<p>849<br>00:50:26,119 –&gt; 00:50:28,119<br>We go ahead and evict it.</p>
<p>850<br>00:50:28,119 –&gt; 00:50:32,119<br>Right? So say I should have a hero, q1, wants to touch page one.</p>
<p>851<br>00:50:32,119 –&gt; 00:50:37,119<br>Page one is already in our link list so we just move it to the front, right, to the head.</p>
<p>852<br>00:50:37,119 –&gt; 00:50:41,119<br>And then now say another query wants to come and touch, you know, access page five,</p>
<p>853<br>00:50:41,119 –&gt; 00:50:42,119<br>but page five is not in memory.</p>
<p>854<br>00:50:42,119 –&gt; 00:50:50,119<br>So we go ahead and page two because it’s at the end, right?</p>
<p>855<br>00:50:50,119 –&gt; 00:50:54,119<br>This should not be news to anyone.</p>
<p>856<br>00:50:54,119 –&gt; 00:51:00,119<br>So another way to do it, achieve the same thing without tracking the actual timestamps in this link list.</p>
<p>857<br>00:51:00,119 –&gt; 00:51:03,119<br>So use an approximation algorithm called clock.</p>
<p>858<br>00:51:03,119 –&gt; 00:51:06,119<br>Who here has heard a clock before?</p>
<p>859<br>00:51:06,119 –&gt; 00:51:09,119<br>Less than five. Okay.</p>
<p>860<br>00:51:09,119 –&gt; 00:51:12,119<br>And so clock is that used in a bunch of other systems as well.</p>
<p>861<br>00:51:12,119 –&gt; 00:51:16,119<br>I think Linux uses this for its page cache or page table.</p>
<p>862<br>00:51:16,119 –&gt; 00:51:20,119<br>They use a multi-hand clock, which we don’t even know about that.</p>
<p>863<br>00:51:20,119 –&gt; 00:51:27,119<br>But the basic idea here is that instead of keeping track of like the exact ordering of pages in LRU,</p>
<p>864<br>00:51:27,119 –&gt; 00:51:34,119<br>instead we just give a user symbol reference bit for every page that we use to keep track of</p>
<p>865<br>00:51:34,119 –&gt; 00:51:40,119<br>whenever we set the one, whenever it’s access, whenever it’s written to a red.</p>
<p>866<br>00:51:40,119 –&gt; 00:51:45,119<br>And the idea here is that we’ll have this this clock and sweep around and look at all our pages.</p>
<p>867<br>00:51:45,119 –&gt; 00:51:51,119<br>And if the bit set to one set it to zero, if it is set to zero, then we go ahead and evict it.</p>
<p>868<br>00:51:51,119 –&gt; 00:51:56,119<br>Right. So say we have four pages, we just give a reference bit, reference bit, we set the zero.</p>
<p>869<br>00:51:56,119 –&gt; 00:52:02,119<br>Right. And then say page one gets access by a query, we go ahead and set the reference bit to one.</p>
<p>870<br>00:52:02,119 –&gt; 00:52:06,119<br>And then now let’s say another query once a page that’s not in a buffer pool.</p>
<p>871<br>00:52:06,119 –&gt; 00:52:09,119<br>So we got a side which of these four we want to evict.</p>
<p>872<br>00:52:09,119 –&gt; 00:52:13,119<br>So we go ahead and the clock starts at some starting point.</p>
<p>873<br>00:52:13,119 –&gt; 00:52:16,119<br>It looks at the reference bit, if it’s set to one, we set it to zero.</p>
<p>874<br>00:52:16,119 –&gt; 00:52:18,119<br>And then move on to the next one.</p>
<p>875<br>00:52:18,119 –&gt; 00:52:20,119<br>And here page two, the reference bit is set to zero.</p>
<p>876<br>00:52:20,119 –&gt; 00:52:26,119<br>So therefore we know the last time the clock swept around and looked for pages to evict, it wasn’t touched.</p>
<p>877<br>00:52:26,119 –&gt; 00:52:29,119<br>So therefore this is safe to evict.</p>
<p>878<br>00:52:30,119 –&gt; 00:52:32,119<br>We go ahead and replace it with another one.</p>
<p>879<br>00:52:32,119 –&gt; 00:52:35,119<br>And then say the other page three and four, they’ve been accessed.</p>
<p>880<br>00:52:35,119 –&gt; 00:52:38,119<br>Clock sees around, sets their bit to zero.</p>
<p>881<br>00:52:38,119 –&gt; 00:52:40,119<br>And then so forth, come to here.</p>
<p>882<br>00:52:40,119 –&gt; 00:52:42,119<br>And then now we’re back to page one.</p>
<p>883<br>00:52:42,119 –&gt; 00:52:44,119<br>It wasn’t accessed since the last time we saw it.</p>
<p>884<br>00:52:44,119 –&gt; 00:52:48,119<br>So we go ahead and evict this one.</p>
<p>885<br>00:52:48,119 –&gt; 00:52:52,119<br>This is a good idea or a bad idea?</p>
<p>886<br>00:52:52,119 –&gt; 00:52:53,119<br>Yes.</p>
<p>887<br>00:52:53,119 –&gt; 00:52:59,119<br>It seems good in that it allows us to have a lot of storage between one bit per.</p>
<p>888<br>00:52:59,119 –&gt; 00:53:02,119<br>But the downside seems like it’s going to evict you,</p>
<p>889<br>00:53:02,119 –&gt; 00:53:07,119<br>and if you don’t use the room, we might have fewer hits.</p>
<p>890<br>00:53:07,119 –&gt; 00:53:08,119<br>So you got the first part right.</p>
<p>891<br>00:53:08,119 –&gt; 00:53:12,119<br>The first part is said this is nice because the medited overhead is low,</p>
<p>892<br>00:53:12,119 –&gt; 00:53:14,119<br>because it’s just a bit per page.</p>
<p>893<br>00:53:14,119 –&gt; 00:53:16,119<br>You store that as a continuous bit vector.</p>
<p>894<br>00:53:16,119 –&gt; 00:53:18,119<br>That’s easy to do.</p>
<p>895<br>00:53:18,119 –&gt; 00:53:21,119<br>But then the second you said like you might evict things that you shouldn’t, you shouldn’t actually need to beck.</p>
<p>896<br>00:53:21,119 –&gt; 00:53:23,119<br>The clock only runs.</p>
<p>897<br>00:53:23,119 –&gt; 00:53:26,119<br>You only start the sweep whenever you need to evict.</p>
<p>898<br>00:53:26,119 –&gt; 00:53:28,119<br>So it’s not just running the background all the time.</p>
<p>899<br>00:53:28,119 –&gt; 00:53:29,119<br>Yeah.</p>
<p>900<br>00:53:29,119 –&gt; 00:53:32,119<br>You don’t want to do that.</p>
<p>901<br>00:53:32,119 –&gt; 00:53:34,119<br>Yes.</p>
<p>902<br>00:53:34,119 –&gt; 00:53:39,119<br>You’re not taking into account the frequency of the pages that I’ve been asking.</p>
<p>903<br>00:53:39,119 –&gt; 00:53:40,119<br>Yes.</p>
<p>904<br>00:53:40,119 –&gt; 00:53:45,119<br>So he said, and he’s correct, that in case of clock, and actually LRU,</p>
<p>905<br>00:53:45,119 –&gt; 00:53:46,119<br>it would have this problem.</p>
<p>906<br>00:53:46,119 –&gt; 00:53:52,119<br>We’re not keeping track of the frequency in pages in which pages are accessed.</p>
<p>907<br>00:53:52,119 –&gt; 00:53:55,119<br>And so this makes them susceptible to two problems.</p>
<p>908<br>00:53:55,119 –&gt; 00:53:57,119<br>So the first one is what he said down here.</p>
<p>909<br>00:53:57,119 –&gt; 00:54:00,119<br>Like in both clock and LRU, we’re only tracking when they’re accessed,</p>
<p>910<br>00:54:00,119 –&gt; 00:54:03,119<br>now not how often they were accessed.</p>
<p>911<br>00:54:03,119 –&gt; 00:54:09,119<br>And in both cases also too, they’re susceptible to a problem called sequential flooding.</p>
<p>912<br>00:54:09,119 –&gt; 00:54:14,119<br>And this is the problem where if a running sequential scans,</p>
<p>913<br>00:54:14,119 –&gt; 00:54:17,119<br>we got to go fetch pages from disk, put into our buffer pool.</p>
<p>914<br>00:54:17,119 –&gt; 00:54:20,119<br>But if we’re tracking the last time they were used,</p>
<p>915<br>00:54:20,119 –&gt; 00:54:25,119<br>the last page I just got got from my sequential scan is the most one that’s recently used.</p>
<p>916<br>00:54:25,119 –&gt; 00:54:28,119<br>But for that sequential scan, it’s actually the most useful one,</p>
<p>917<br>00:54:28,119 –&gt; 00:54:31,119<br>at least useful one, because just the page that is read,</p>
<p>918<br>00:54:31,119 –&gt; 00:54:34,119<br>I’m not going to go back and read it again.</p>
<p>919<br>00:54:34,119 –&gt; 00:54:35,119<br>Right?</p>
<p>920<br>00:54:35,119 –&gt; 00:54:37,119<br>And in some cases for at least all that workloads,</p>
<p>921<br>00:54:37,119 –&gt; 00:54:40,119<br>it’s kind of like you went the most recently used one.</p>
<p>922<br>00:54:40,119 –&gt; 00:54:45,119<br>It’s a gross approximation, but it’s another way to think about it.</p>
<p>923<br>00:54:45,119 –&gt; 00:54:46,119<br>Right?</p>
<p>924<br>00:54:46,119 –&gt; 00:54:50,119<br>Again, so like this, I have a query once it was select star from a table,</p>
<p>925<br>00:54:50,119 –&gt; 00:54:52,119<br>but we’re only going to get one ID or one record.</p>
<p>926<br>00:54:52,119 –&gt; 00:54:54,119<br>And say that’s in page 0.</p>
<p>927<br>00:54:54,119 –&gt; 00:54:58,119<br>So we go put page 0 in our buffer pool.</p>
<p>928<br>00:54:58,119 –&gt; 00:55:01,119<br>Then we have our O-Lat query that’s going to scan the entire table</p>
<p>929<br>00:55:01,119 –&gt; 00:55:04,119<br>and go fetch all the pages that entire table.</p>
<p>930<br>00:55:04,119 –&gt; 00:55:07,119<br>But when it gets to page 3, we’re not in space.</p>
<p>931<br>00:55:07,119 –&gt; 00:55:14,119<br>So for these pages here, the least recently used page is page 0.</p>
<p>932<br>00:55:14,119 –&gt; 00:55:18,119<br>So I’m going to go ahead and evict that and put in page 3.</p>
<p>933<br>00:55:18,119 –&gt; 00:55:22,119<br>But for another query comes along, it does the same thing the first guy did</p>
<p>934<br>00:55:22,119 –&gt; 00:55:25,119<br>and goes gets page 1 or once, once record 1 in page 1.</p>
<p>935<br>00:55:25,119 –&gt; 00:55:30,119<br>That’s actually the page I wanted, I need, but I just evicted it.</p>
<p>936<br>00:55:30,119 –&gt; 00:55:34,119<br>So this is the worst thing you could do.</p>
<p>937<br>00:55:34,119 –&gt; 00:55:36,119<br>Right?</p>
<p>938<br>00:55:37,119 –&gt; 00:55:40,119<br>So the sequential flooding is a problem because again,</p>
<p>939<br>00:55:40,119 –&gt; 00:55:44,119<br>if we do merge these point queries and then all of a sudden a switch query shows up,</p>
<p>940<br>00:55:44,119 –&gt; 00:55:52,119<br>it’s going to blow away any useful information we’ve collected in our LU or clock metadata.</p>
<p>941<br>00:55:52,119 –&gt; 00:55:56,119<br>So the solution to this is called LUK.</p>
<p>942<br>00:55:56,119 –&gt; 00:56:01,119<br>The idea here is you just keep track of the last K times a page was accessed.</p>
<p>943<br>00:56:01,119 –&gt; 00:56:05,119<br>And then when it comes time to decide what to evict,</p>
<p>944<br>00:56:05,119 –&gt; 00:56:12,119<br>you compute the interval between the last time, the K times it was accessed.</p>
<p>945<br>00:56:12,119 –&gt; 00:56:17,119<br>And whatever one has the largest interval, meaning the time fund it was sort of accessed,</p>
<p>946<br>00:56:17,119 –&gt; 00:56:25,119<br>K minus 1, or K minus 2 times 4, if that interval is the largest, then you know that it’s likely to not be used in the future.</p>
<p>947<br>00:56:25,119 –&gt; 00:56:29,119<br>And therefore you can go ahead and remove it.</p>
<p>948<br>00:56:30,119 –&gt; 00:56:35,119<br>You think LU is basically LRUK, where K equals 1.</p>
<p>949<br>00:56:35,119 –&gt; 00:56:39,119<br>And with 2 or 3 or whatever, merge systems used to, if you’re going to use this,</p>
<p>950<br>00:56:39,119 –&gt; 00:56:41,119<br>they just keep track of the last two times.</p>
<p>951<br>00:56:41,119 –&gt; 00:56:43,119<br>And I’d say what’s the time between the two of those?</p>
<p>952<br>00:56:43,119 –&gt; 00:56:46,119<br>And I take the one that is the largest.</p>
<p>953<br>00:56:46,119 –&gt; 00:56:55,119<br>And so of course this is susceptible to another problem where I fetch a page in,</p>
<p>954<br>00:56:55,119 –&gt; 00:57:02,119<br>and I haven’t access it twice yet, so the interval is essentially affinity.</p>
<p>955<br>00:57:02,119 –&gt; 00:57:04,119<br>And then it goes ahead and gets immediately evicted.</p>
<p>956<br>00:57:04,119 –&gt; 00:57:07,119<br>But say that actually is the hot page, and I want to keep that in memory.</p>
<p>957<br>00:57:07,119 –&gt; 00:57:11,119<br>But because I keep evicting it, I lose that, I don’t have any history of it.</p>
<p>958<br>00:57:11,119 –&gt; 00:57:16,119<br>So the way to solve this is that you maintain a in-mary hash table,</p>
<p>959<br>00:57:16,119 –&gt; 00:57:21,119<br>that keeps track of, here’s the last couple pages that I’ve evicted on disk,</p>
<p>960<br>00:57:21,119 –&gt; 00:57:24,119<br>and here’s the last, here’s when they were accessed, the time stamp.</p>
<p>961<br>00:57:24,119 –&gt; 00:57:27,119<br>So that when I fetch a page back in, after it was just removed,</p>
<p>962<br>00:57:27,119 –&gt; 00:57:32,119<br>I at least now have a history for it, and not assume that it’s infinity.</p>
<p>963<br>00:57:32,119 –&gt; 00:57:38,119<br>And that means that over time, you’ll be able to get information you need to compute the correct interval for pages</p>
<p>964<br>00:57:38,119 –&gt; 00:57:41,119<br>when they first, you know, when the first time they brought in a memory.</p>
<p>965<br>00:57:41,119 –&gt; 00:57:44,119<br>And again, it’s self-correcting, because again, if I bring something to memory</p>
<p>966<br>00:57:44,119 –&gt; 00:57:49,119<br>but they never go fetch it again, it’ll get removed from my informal cache.</p>
<p>967<br>00:57:49,119 –&gt; 00:57:56,119<br>And whenever I need it again, I won’t have the history, and I’ll know I should have evicted.</p>
<p>968<br>00:57:56,119 –&gt; 00:57:58,119<br>It’s a simple solution, there’s simple problems.</p>
<p>969<br>00:57:58,119 –&gt; 00:58:01,119<br>Surprisingly, this was not in the minutes of the 90s.</p>
<p>970<br>00:58:01,119 –&gt; 00:58:06,119<br>And as far as I can tell, only Postgres and SQL Server actually do this.</p>
<p>971<br>00:58:06,119 –&gt; 00:58:10,119<br>And again, this is why I like open source things, because there’s actually the mailing list</p>
<p>972<br>00:58:10,119 –&gt; 00:58:13,119<br>post for the Postgres people, and then in 2002, they say,</p>
<p>973<br>00:58:13,119 –&gt; 00:58:16,119<br>hey, this LRUK seems like a good idea, we should do it.</p>
<p>974<br>00:58:16,119 –&gt; 00:58:19,119<br>And they implement it.</p>
<p>975<br>00:58:19,119 –&gt; 00:58:24,119<br>So my SQL doesn’t do exactly LRUK as I define, but they use a sort of Proximate1.</p>
<p>976<br>00:58:24,119 –&gt; 00:58:34,119<br>And the way they do this is that they sort of logically divide up the link list for the LRU page list.</p>
<p>977<br>00:58:34,119 –&gt; 00:58:37,119<br>And they have two different sections, or regions.</p>
<p>978<br>00:58:37,119 –&gt; 00:58:40,119<br>They have like the young region, the old region.</p>
<p>979<br>00:58:41,119 –&gt; 00:58:45,119<br>And for each of these two different regions, you’ll have a different head pointer,</p>
<p>980<br>00:58:45,119 –&gt; 00:58:48,119<br>where you would insert new entries.</p>
<p>981<br>00:58:48,119 –&gt; 00:58:52,119<br>So let’s say that I have a query I want to touch page 1, it’s not in memory,</p>
<p>982<br>00:58:52,119 –&gt; 00:58:55,119<br>so I have to put it into my buffer pool.</p>
<p>983<br>00:58:55,119 –&gt; 00:59:00,119<br>And when I want to add it to my link list here, because page 1 is not already in the link list,</p>
<p>984<br>00:59:00,119 –&gt; 00:59:05,119<br>I’m going to add it to the old region, and I’ll insert it where the head pointer is.</p>
<p>985<br>00:59:06,119 –&gt; 00:59:10,119<br>So I’ll pick page 8 and put page 1 there.</p>
<p>986<br>00:59:10,119 –&gt; 00:59:18,119<br>Now, if page 1 is never accessed again, it’ll slowly make its way to the end of the link list,</p>
<p>987<br>00:59:18,119 –&gt; 00:59:21,119<br>and then get evicted.</p>
<p>988<br>00:59:21,119 –&gt; 00:59:24,119<br>But if say Q2 comes along and it touches page 1 again,</p>
<p>989<br>00:59:24,119 –&gt; 00:59:29,119<br>we would identify that it already exists in my link list,</p>
<p>990<br>00:59:29,119 –&gt; 00:59:34,119<br>and it’s in the old region, so therefore I’ll put it at the head of the young list.</p>
<p>991<br>00:59:35,119 –&gt; 00:59:37,119<br>And then slide everyone out.</p>
<p>992<br>00:59:37,119 –&gt; 00:59:41,119<br>So again, it’s approximately L-A-U-K, because I’m not really keeping track of the intervals</p>
<p>993<br>00:59:41,119 –&gt; 00:59:47,119<br>between when it was accessed before, but just knowing that within this boundary of the young versus old,</p>
<p>994<br>00:59:47,119 –&gt; 00:59:52,119<br>then I know it’s like, it was most likely accessed more recently.</p>
<p>995<br>00:59:52,119 –&gt; 00:59:55,119<br>Whereas over here, you haven’t seen it before.</p>
<p>996<br>00:59:55,119 –&gt; 00:59:59,119<br>You haven’t seen it before, it was added to the list.</p>
<p>997<br>01:00:05,119 –&gt; 01:00:10,119<br>So I would say also, going back to the L-A-U-K,</p>
<p>998<br>01:00:10,119 –&gt; 01:00:15,119<br>there’s a bunch of other optimizations you can do that SQL server does,</p>
<p>999<br>01:00:15,119 –&gt; 01:00:21,119<br>but I don’t think Postgres does, where you can keep track of how,</p>
<p>1000<br>01:00:21,119 –&gt; 01:00:25,119<br>of who is accessing or referencing a page.</p>
<p>1001<br>01:00:25,119 –&gt; 01:00:31,119<br>And then that can determine whether you would say an access counts for a distinct reference,</p>
<p>1002<br>01:00:31,119 –&gt; 01:00:33,119<br>and therefore should update the interval.</p>
<p>1003<br>01:00:33,119 –&gt; 01:00:40,119<br>An example would be if I have within the same transaction two separate queries access the same page,</p>
<p>1004<br>01:00:40,119 –&gt; 01:00:46,119<br>well that’s in the same transaction, so therefore should they be considered distinct or not.</p>
<p>1005<br>01:00:46,119 –&gt; 01:00:50,119<br>If there are two separate transactions, then it’s very likely this page is hot,</p>
<p>1006<br>01:00:50,119 –&gt; 01:00:52,119<br>because a bunch of transactions are accessing it.</p>
<p>1007<br>01:00:52,119 –&gt; 01:00:59,119<br>I think of like if you log into Amazon and you go update your account information</p>
<p>1008<br>01:00:59,119 –&gt; 01:01:03,119<br>and say for whatever reason that transaction updates your record twice,</p>
<p>1009<br>01:01:03,119 –&gt; 01:01:07,119<br>well that’s done in the same transaction, is that considered two accesses or one,</p>
<p>1010<br>01:01:07,119 –&gt; 01:01:10,119<br>and then SQL server they’ll consider that one,</p>
<p>1011<br>01:01:10,119 –&gt; 01:01:14,119<br>and then in Postgres they consider that two.</p>
<p>1012<br>01:01:14,119 –&gt; 01:01:24,119<br>Again, you knew a bunch of fancy things because you know how the data system is accessing pages.</p>
<p>1013<br>01:01:24,119 –&gt; 01:01:32,119<br>There’s a bunch of policies you can do for deciding, you know, sort of related this,</p>
<p>1014<br>01:01:32,119 –&gt; 01:01:37,119<br>like for a given query what page should I evict.</p>
<p>1015<br>01:01:37,119 –&gt; 01:01:45,119<br>Like if this is sort of related to the private cache, like in some systems you can say,</p>
<p>1016<br>01:01:45,119 –&gt; 01:01:51,119<br>all right, here’s a some subset of the pages that I’m accessing.</p>
<p>1017<br>01:01:51,119 –&gt; 01:01:56,119<br>They’re being backed by the buffer pool, right, but I’m keeping track of which ones I’m accessing.</p>
<p>1018<br>01:01:56,119 –&gt; 01:02:00,119<br>So then I can give a hint to the buffer manager to say, if you don’t have any more space,</p>
<p>1019<br>01:02:00,119 –&gt; 01:02:04,119<br>here’s the pages where I know I’m accessing therefore, and I don’t need them again,</p>
<p>1020<br>01:02:04,119 –&gt; 01:02:06,119<br>therefore you can go ahead and evict them.</p>
<p>1021<br>01:02:06,119 –&gt; 01:02:14,119<br>Now whether or not the data system decides, you should evict them or not, depends on the implementation.</p>
<p>1022<br>01:02:14,119 –&gt; 01:02:22,119<br>You can also maintain priority hints about what the type of page or what the object that a page represents.</p>
<p>1023<br>01:02:22,119 –&gt; 01:02:28,119<br>And then this provided to the data system to say, you know, the buffer manager whether something should be evict or not.</p>
<p>1024<br>01:02:28,119 –&gt; 01:02:33,119<br>So the classic example would be if I have an index of a bunch of pages,</p>
<p>1025<br>01:02:33,119 –&gt; 01:02:41,119<br>and a very clear is that it always means certain new records that are just increasing the size of the data I’m starting,</p>
<p>1026<br>01:02:41,119 –&gt; 01:02:48,119<br>the value that the index is based on, then I know I’m going to be always hitting the right side of the tree,</p>
<p>1027<br>01:02:48,119 –&gt; 01:02:54,119<br>and therefore maybe I want to keep those pages in memory, and I don’t care if page 2 over here gets evicted</p>
<p>1028<br>01:02:54,119 –&gt; 01:02:59,119<br>because I’m mostly going to be updating things on page 6.</p>
<p>1029<br>01:02:59,119 –&gt; 01:03:04,119<br>Otherwise if I do much select queries, I have to use the index,</p>
<p>1030<br>01:03:04,119 –&gt; 01:03:09,119<br>and I know the very first thing they’re always going to access is the root page index,</p>
<p>1031<br>01:03:09,119 –&gt; 01:03:13,119<br>so therefore that should be given a high priority than the other ones.</p>
<p>1032<br>01:03:13,119 –&gt; 01:03:18,119<br>Now these seem kind of like band-aids over like LRUK or other mechanisms,</p>
<p>1033<br>01:03:18,119 –&gt; 01:03:20,119<br>and they kind of are, right?</p>
<p>1034<br>01:03:20,119 –&gt; 01:03:24,119<br>And so it’s like, think of it as like a light pin to tell the system,</p>
<p>1035<br>01:03:24,119 –&gt; 01:03:30,119<br>hey you really probably shouldn’t evict this, but if you have to, yes you can, but please don’t.</p>
<p>1036<br>01:03:31,119 –&gt; 01:03:38,119<br>But again, there’s additional things beyond the LRU tracking that the systems are doing.</p>
<p>1037<br>01:03:38,119 –&gt; 01:03:42,119<br>The big challenge though when it comes to evicting pages is whether they’re dirty or not.</p>
<p>1038<br>01:03:42,119 –&gt; 01:03:50,119<br>So the easiest thing to do is if all my pages are clean to evict them from the bufferable is to do nothing,</p>
<p>1039<br>01:03:50,119 –&gt; 01:03:55,119<br>you just drop the page reference in the page table, you need to overwrite whatever’s there before, right?</p>
<p>1040<br>01:03:55,119 –&gt; 01:03:58,119<br>Because you don’t need to flush it back to disk.</p>
<p>1041<br>01:03:59,119 –&gt; 01:04:05,119<br>If though, if all the pages are dirty or the one you want to evict is dirty, then you got to write that to disk,</p>
<p>1042<br>01:04:05,119 –&gt; 01:04:11,119<br>make sure it’s durable and safe, which covered later in the semester, before you can go ahead and say,</p>
<p>1043<br>01:04:11,119 –&gt; 01:04:16,119<br>okay this frame is now free, you can go ahead and reuse it.</p>
<p>1044<br>01:04:16,119 –&gt; 01:04:21,119<br>It’s actually more complicated than that because you actually have to write and show the log record as flushed at disk first,</p>
<p>1045<br>01:04:21,119 –&gt; 01:04:25,119<br>before you can flush the dirty page that the log reference talks about.</p>
<p>1046<br>01:04:25,119 –&gt; 01:04:27,119<br>Okay, we will cover that later.</p>
<p>1047<br>01:04:27,119 –&gt; 01:04:31,119<br>So the reason why this is tricky to do is because it may be the case given all the things we just talked about,</p>
<p>1048<br>01:04:31,119 –&gt; 01:04:35,119<br>these priority hints, these different policies, the LRU case stuff,</p>
<p>1049<br>01:04:35,119 –&gt; 01:04:40,119<br>it may be the case that the page you want to evict is dirty,</p>
<p>1050<br>01:04:40,119 –&gt; 01:04:48,119<br>and so that is going to require a disk flush, but maybe the second page you could evict is clean.</p>
<p>1051<br>01:04:48,119 –&gt; 01:04:51,119<br>So should you violate the LRU case in that case?</p>
<p>1052<br>01:04:51,119 –&gt; 01:04:55,119<br>Again, just trying to get things out as fast as possible.</p>
<p>1053<br>01:04:55,119 –&gt; 01:05:01,119<br>Different systems do different things, and this is why the enterprise systems are much better than the open source systems,</p>
<p>1054<br>01:05:01,119 –&gt; 01:05:05,119<br>because they have all this metadata, they have all this sophisticated algorithms to make these decisions.</p>
<p>1055<br>01:05:05,119 –&gt; 01:05:08,119<br>Because it actually depends on the speed of the hardware.</p>
<p>1056<br>01:05:08,119 –&gt; 01:05:13,119<br>If your disk is super fast, then yeah, I’ll write it out the disk, I’ll write out a dirty page out right away,</p>
<p>1057<br>01:05:13,119 –&gt; 01:05:16,119<br>because that’s going to be fairly inexpensive operation.</p>
<p>1058<br>01:05:16,119 –&gt; 01:05:20,119<br>If my disk is really slow, or I’ve got to write it with a network to some slow device,</p>
<p>1059<br>01:05:20,119 –&gt; 01:05:30,119<br>then maybe I want to minimize the amount of disk rights I have to do when I have to evict something the exact moment I need a space.</p>
<p>1060<br>01:05:30,119 –&gt; 01:05:33,119<br>So there’s no easy answer to this.</p>
<p>1061<br>01:05:33,119 –&gt; 01:05:39,119<br>If all your pages are dirty and need a vick one, you have to write it.</p>
<p>1062<br>01:05:39,119 –&gt; 01:05:43,119<br>But what’s one way to avoid this problem?</p>
<p>1063<br>01:05:43,119 –&gt; 01:05:47,119<br>To not have the right deal on the critical path when you want access to page.</p>
<p>1064<br>01:05:52,119 –&gt; 01:05:55,119<br>Backarm writing, right?</p>
<p>1065<br>01:05:55,119 –&gt; 01:06:05,119<br>You could have a separate thread in the background, just walk through a page table, figure out what’s dirty, make sure the log is on disk.</p>
<p>1066<br>01:06:05,119 –&gt; 01:06:09,119<br>Again, we’ll cover that later, but soon you have to court a log first.</p>
<p>1067<br>01:06:09,119 –&gt; 01:06:14,119<br>Find pages that are dirty, and go ahead and write them out.</p>
<p>1068<br>01:06:14,119 –&gt; 01:06:17,119<br>Then you just flip the bit to say this page is now clean.</p>
<p>1069<br>01:06:17,119 –&gt; 01:06:24,119<br>So that when the eviction algorithm runs, and it says, okay, I have to evict something, now has a bunch of options of pages that are clean that could write out.</p>
<p>1070<br>01:06:24,119 –&gt; 01:06:29,119<br>Or sorry, just drop, you don’t have to write anything.</p>
<p>1071<br>01:06:29,119 –&gt; 01:06:34,119<br>But now there’s this trade-off routine, like should I have my system be aggressively writing out dirty pages,</p>
<p>1072<br>01:06:34,119 –&gt; 01:06:39,119<br>maybe interfering with queries and transactions that are trying to run things with a happy application?</p>
<p>1073<br>01:06:39,119 –&gt; 01:06:42,119<br>Or should I delay that?</p>
<p>1074<br>01:06:42,119 –&gt; 01:06:48,119<br>But then now the problem is that some point I need to get free space at all my pages are dirty.</p>
<p>1075<br>01:06:48,119 –&gt; 01:06:54,119<br>It’s a super hard problem, and there’s no easy answer.</p>
<p>1076<br>01:06:54,119 –&gt; 01:07:00,119<br>But all the systems are going to have some mechanism to do this background writing.</p>
<p>1077<br>01:07:00,119 –&gt; 01:07:04,119<br>Then checkpoints are a whole another beast. Checkpoints you flush everything out.</p>
<p>1078<br>01:07:04,119 –&gt; 01:07:14,119<br>But that happens every minute, every minute, every second.</p>
<p>1079<br>01:07:14,119 –&gt; 01:07:18,119<br>Okay?</p>
<p>1080<br>01:07:18,119 –&gt; 01:07:23,119<br>So now we start talking a little bit about what we do these disk writes and disk reads.</p>
<p>1081<br>01:07:23,119 –&gt; 01:07:27,119<br>We have to talk about how we actually going to do that.</p>
<p>1082<br>01:07:27,119 –&gt; 01:07:34,119<br>And for this one, when we make reading write calls to the file system,</p>
<p>1083<br>01:07:34,119 –&gt; 01:07:38,119<br>assuming we’re running on the file, not raw partitions,</p>
<p>1084<br>01:07:38,119 –&gt; 01:07:44,119<br>there’s a bunch of layers below us in our daily system, like the OS and the file system and the hardware,</p>
<p>1085<br>01:07:44,119 –&gt; 01:07:53,119<br>that’s going to be clever and try to obviously maximize the amount of bandwidth that can achieve by reordering and batching our IO requests.</p>
<p>1086<br>01:07:53,119 –&gt; 01:07:58,119<br>Part of the reason why these modern disk drives or SSDs and the MED drives are so fast,</p>
<p>1087<br>01:07:58,119 –&gt; 01:08:02,119<br>because they have these long cues and do parallel requests.</p>
<p>1088<br>01:08:02,119 –&gt; 01:08:06,119<br>So if you just started to do one read at a time, that’s going to be super slow, but you can batch things up,</p>
<p>1089<br>01:08:06,119 –&gt; 01:08:10,119<br>and make sure that you’re reading a bunch of contiguous data, things will be really fast.</p>
<p>1090<br>01:08:10,119 –&gt; 01:08:19,119<br>But the challenge is though, these different layers of the system below the daily system don’t know what the requests actually correspond to.</p>
<p>1091<br>01:08:19,119 –&gt; 01:08:22,119<br>They just see reads and writes and pages at some location or some address.</p>
<p>1092<br>01:08:22,119 –&gt; 01:08:27,119<br>They don’t know, oh, this is from the background writer, or this is for an index, or this is for the query,</p>
<p>1093<br>01:08:27,119 –&gt; 01:08:30,119<br>then they need to run right now.</p>
<p>1094<br>01:08:30,119 –&gt; 01:08:37,119<br>So you can play some games with in Linux setting the IO priority, but that’s basically a sledgehammer.</p>
<p>1095<br>01:08:37,119 –&gt; 01:08:43,119<br>The only thing you can really do is change the IO priority on a per process level.</p>
<p>1096<br>01:08:43,119 –&gt; 01:08:48,119<br>You can’t do it on a per single request, which is what we really want.</p>
<p>1097<br>01:08:48,119 –&gt; 01:08:54,119<br>So if you read the documentation on a bunch of data systems, they tell you to all get off the default Linux scheduler,</p>
<p>1098<br>01:08:54,119 –&gt; 01:09:00,119<br>which is the fair scheduler, and either use deadline or the simple 5.0Q and no op,</p>
<p>1099<br>01:09:00,119 –&gt; 01:09:10,119<br>because they don’t want the operating system to do a bunch of stuff that the data system can’t control.</p>
<p>1100<br>01:09:10,119 –&gt; 01:09:18,119<br>So this is why in most data systems, they’re going to have their own little shim layer right above the OS</p>
<p>1101<br>01:09:18,119 –&gt; 01:09:26,119<br>that can be responsible for keeping track of what requests are outstanding for reads and writes from the Bupfable Manager,</p>
<p>1102<br>01:09:26,119 –&gt; 01:09:31,119<br>and decide how to put things together to optimize performance.</p>
<p>1103<br>01:09:31,119 –&gt; 01:09:38,119<br>And basically, you think of determining the priorities for the different IO requests based on multitude of different factors,</p>
<p>1104<br>01:09:38,119 –&gt; 01:09:43,119<br>because again, we know what the queries are trying to do, we know what pages are in a Bupfable,</p>
<p>1105<br>01:09:43,119 –&gt; 01:09:48,119<br>we know what’s dirty and not dirty, we know what are the outstanding requests.</p>
<p>1106<br>01:09:48,119 –&gt; 01:09:52,119<br>And so to try to keep track of things like what’s Swential IO versus Random IO,</p>
<p>1107<br>01:09:52,119 –&gt; 01:09:56,119<br>is the request based on the critical path of like a query needs this right now,</p>
<p>1108<br>01:09:56,119 –&gt; 01:10:03,119<br>or is this like a background job, the background writer, and therefore, you know, could have a lower priority.</p>
<p>1109<br>01:10:03,119 –&gt; 01:10:10,119<br>Is the data accessing for a table and index log records, again, the logs you want to flush as fast as possible,</p>
<p>1110<br>01:10:10,119 –&gt; 01:10:17,119<br>is it for a femoral data? Like if it’s a Swential scan for a table, that’s going to have a lower priority,</p>
<p>1111<br>01:10:17,119 –&gt; 01:10:21,119<br>and then maybe you ran them access for index, because as you traverse your B-plustry,</p>
<p>1112<br>01:10:21,119 –&gt; 01:10:26,119<br>you’re holding latches as you go down, and therefore, that’s going to prevent other threads from running at the same time.</p>
<p>1113<br>01:10:26,119 –&gt; 01:10:29,119<br>But if you’re query, your scan query is a little bit slower,</p>
<p>1114<br>01:10:29,119 –&gt; 01:10:33,119<br>you’re technically potentially not interfering with other queries running at the same time.</p>
<p>1115<br>01:10:33,119 –&gt; 01:10:38,119<br>Well, that’s not true, because you can take locks during when you run queries and transactions.</p>
<p>1116<br>01:10:38,119 –&gt; 01:10:43,119<br>So there’s no easy answer for when one should be faster than another.</p>
<p>1117<br>01:10:43,119 –&gt; 01:10:46,119<br>You can’t just because it’s indexed, because it’s a table.</p>
<p>1118<br>01:10:46,119 –&gt; 01:10:49,119<br>Again, the OS doesn’t know that it’s an indexed page versus a table page.</p>
<p>1119<br>01:10:49,119 –&gt; 01:10:54,119<br>There’s also sometimes in some systems, you can have SLA service level agreements,</p>
<p>1120<br>01:10:54,119 –&gt; 01:10:59,119<br>or service level objectives. My queries have to run within the certain deadline as a certain latency.</p>
<p>1121<br>01:10:59,119 –&gt; 01:11:02,119<br>And the typically way you do this is you have different user accounts,</p>
<p>1122<br>01:11:02,119 –&gt; 01:11:05,119<br>and give one user count higher priority than another user count.</p>
<p>1123<br>01:11:05,119 –&gt; 01:11:10,119<br>The front-end application has a higher priority than nightly reporting jobs,</p>
<p>1124<br>01:11:10,119 –&gt; 01:11:13,119<br>and you do that based on user roles.</p>
<p>1125<br>01:11:16,119 –&gt; 01:11:20,119<br>So the way we can get better performance,</p>
<p>1126<br>01:11:20,119 –&gt; 01:11:25,119<br>and try to avoid some of this interference from the OS,</p>
<p>1127<br>01:11:25,119 –&gt; 01:11:28,119<br>is to use what’s called direct IO.</p>
<p>1128<br>01:11:28,119 –&gt; 01:11:31,119<br>So all your disk operations, for the most part,</p>
<p>1129<br>01:11:31,119 –&gt; 01:11:38,119<br>are going to have to go through the OS API, unless you’re doing direct kernel bypass to the hardware device,</p>
<p>1130<br>01:11:38,119 –&gt; 01:11:41,119<br>but most systems don’t do that.</p>
<p>1131<br>01:11:41,119 –&gt; 01:11:45,119<br>And the idea here is that we don’t want the OS to maintain its own cache,</p>
<p>1132<br>01:11:45,119 –&gt; 01:11:50,119<br>because we don’t want the OS to buffer our reads and writes,</p>
<p>1133<br>01:11:50,119 –&gt; 01:11:53,119<br>we want to do that all entirely ourselves.</p>
<p>1134<br>01:11:53,119 –&gt; 01:11:57,119<br>Because again, we want to have full control of the hardware.</p>
<p>1135<br>01:11:57,119 –&gt; 01:12:02,119<br>So the idea is like this. If I do a read against the file system,</p>
<p>1136<br>01:12:02,119 –&gt; 01:12:08,119<br>well, the OS is going to say, let me go maintain my own little buffer pool in the OS,</p>
<p>1137<br>01:12:08,119 –&gt; 01:12:11,119<br>across all the processes running.</p>
<p>1138<br>01:12:11,119 –&gt; 01:12:13,119<br>It’s a global for the OS.</p>
<p>1139<br>01:12:13,119 –&gt; 01:12:17,119<br>And then I will store the data I need, you’re asking for, my page cache.</p>
<p>1140<br>01:12:17,119 –&gt; 01:12:21,119<br>And the next time I do a read, I’ll get it from my page cache.</p>
<p>1141<br>01:12:21,119 –&gt; 01:12:24,119<br>So instead, we want to bypass this and go around it,</p>
<p>1142<br>01:12:24,119 –&gt; 01:12:30,119<br>and store it directly to the hardware, and not have the OS buffer anything.</p>
<p>1143<br>01:12:30,119 –&gt; 01:12:35,119<br>So most systems use direct IO. Most systems will use direct IO by default.</p>
<p>1144<br>01:12:35,119 –&gt; 01:12:38,119<br>There’s only one system that does not.</p>
<p>1145<br>01:12:38,119 –&gt; 01:12:41,119<br>I’m going to take a guess what it is.</p>
<p>1146<br>01:12:41,119 –&gt; 01:12:44,119<br>Say a single store. No.</p>
<p>1147<br>01:12:44,119 –&gt; 01:12:47,119<br>Nice to go. No. It’s Postgres.</p>
<p>1148<br>01:12:47,119 –&gt; 01:12:50,119<br>Postgres, because there’s a relic from the 80s,</p>
<p>1149<br>01:12:50,119 –&gt; 01:12:53,119<br>they rely heavily on the OS page cache.</p>
<p>1150<br>01:12:53,119 –&gt; 01:12:57,119<br>And so when you allocate a buffer pool in Postgres,</p>
<p>1151<br>01:12:57,119 –&gt; 01:13:00,119<br>you set it to like 30% of the amount of memory that’s on the box.</p>
<p>1152<br>01:13:00,119 –&gt; 01:13:04,119<br>My SQL and every other database system tell you it’s 80% of the memory that’s available on the box.</p>
<p>1153<br>01:13:04,119 –&gt; 01:13:08,119<br>Because in Postgres, they want some of the memory to be for the page cache in the OS,</p>
<p>1154<br>01:13:08,119 –&gt; 01:13:10,119<br>some of the memory for the database system.</p>
<p>1155<br>01:13:11,119 –&gt; 01:13:12,119<br>So what’s the problem with this?</p>
<p>1156<br>01:13:12,119 –&gt; 01:13:14,119<br>Well, now I’ve got redundant copies of my pages.</p>
<p>1157<br>01:13:14,119 –&gt; 01:13:18,119<br>The OS is going to have a copy of my page, and my data system is going to have a copy of my page.</p>
<p>1158<br>01:13:18,119 –&gt; 01:13:20,119<br>Same things for reads and writes.</p>
<p>1159<br>01:13:20,119 –&gt; 01:13:27,119<br>And then the data system is going to have its own policy of how to decide what pages do a bit.</p>
<p>1160<br>01:13:27,119 –&gt; 01:13:30,119<br>But then just because I evicted from my buffer pool in my database system,</p>
<p>1161<br>01:13:30,119 –&gt; 01:13:33,119<br>the OS can decide to evict it any way it wants to.</p>
<p>1162<br>01:13:33,119 –&gt; 01:13:37,119<br>Again, it doesn’t know what the pages actually represent.</p>
<p>1163<br>01:13:37,119 –&gt; 01:13:42,119<br>And then you also lose control when things actually get flushed out the disk unless you’re careful.</p>
<p>1164<br>01:13:44,119 –&gt; 01:13:49,119<br>So let’s see how far you guys can get with these answers here, even if you haven’t taken the OS class.</p>
<p>1165<br>01:13:49,119 –&gt; 01:13:51,119<br>So if you call F-Rite, what happens?</p>
<p>1166<br>01:13:53,119 –&gt; 01:13:55,119<br>I open a file, right?</p>
<p>1167<br>01:13:55,119 –&gt; 01:13:57,119<br>Say, say, say, I open my database file.</p>
<p>1168<br>01:13:57,119 –&gt; 01:14:02,119<br>I have my buffer pool manager bring a page in, another query updates it.</p>
<p>1169<br>01:14:02,119 –&gt; 01:14:03,119<br>The page is dirty.</p>
<p>1170<br>01:14:03,119 –&gt; 01:14:05,119<br>I call F-Rite to write that page out the disk.</p>
<p>1171<br>01:14:05,119 –&gt; 01:14:06,119<br>What happens?</p>
<p>1172<br>01:14:08,119 –&gt; 01:14:10,119<br>The assume we were not using direct I-O.</p>
<p>1173<br>01:14:12,119 –&gt; 01:14:14,119<br>The page lands in the OS page cache.</p>
<p>1174<br>01:14:14,119 –&gt; 01:14:18,119<br>Because the operating system is trying to be clever and trying to make things fast for you, right?</p>
<p>1175<br>01:14:19,119 –&gt; 01:14:21,119<br>So is it on disk yet?</p>
<p>1176<br>01:14:21,119 –&gt; 01:14:25,119<br>When F-Rite returns, is my data safe?</p>
<p>1177<br>01:14:25,119 –&gt; 01:14:26,119<br>No.</p>
<p>1178<br>01:14:26,119 –&gt; 01:14:28,119<br>Because it’s in the OS page cache.</p>
<p>1179<br>01:14:28,119 –&gt; 01:14:30,119<br>When is it going to be flushed out the disk?</p>
<p>1180<br>01:14:32,119 –&gt; 01:14:33,119<br>When the OS decides to do it.</p>
<p>1181<br>01:14:34,119 –&gt; 01:14:35,119<br>Right?</p>
<p>1182<br>01:14:36,119 –&gt; 01:14:37,119<br>But, f*** that.</p>
<p>1183<br>01:14:37,119 –&gt; 01:14:38,119<br>We want to make sure our things are on disk.</p>
<p>1184<br>01:14:38,119 –&gt; 01:14:39,119<br>So what do we call F-Sync?</p>
<p>1185<br>01:14:41,119 –&gt; 01:14:42,119<br>What does F-Sync do?</p>
<p>1186<br>01:14:44,119 –&gt; 01:14:45,119<br>Flush?</p>
<p>1187<br>01:14:45,119 –&gt; 01:14:46,119<br>Flush what?</p>
<p>1188<br>01:14:47,119 –&gt; 01:14:48,119<br>Dirty pages out the disk.</p>
<p>1189<br>01:14:48,119 –&gt; 01:14:50,119<br>You can kind of do ranges, right?</p>
<p>1190<br>01:14:50,119 –&gt; 01:14:51,119<br>It doesn’t always work.</p>
<p>1191<br>01:14:52,119 –&gt; 01:14:59,119<br>And then the call to F-Sync will block until the harbor complex says your data is persisted.</p>
<p>1192<br>01:15:00,119 –&gt; 01:15:01,119<br>Now the harbor complex is playing games too.</p>
<p>1193<br>01:15:01,119 –&gt; 01:15:03,119<br>Sometimes the harbor has little battery down there.</p>
<p>1194<br>01:15:03,119 –&gt; 01:15:06,119<br>So you’ll get your rights that still setting volatile memory.</p>
<p>1195<br>01:15:06,119 –&gt; 01:15:10,119<br>But if it is a power, and you can send a response to it, I got your right.</p>
<p>1196<br>01:15:10,119 –&gt; 01:15:12,119<br>But then there’s a power loss.</p>
<p>1197<br>01:15:12,119 –&gt; 01:15:15,119<br>There’s just enough battery juice to make sure it gets written to disk.</p>
<p>1198<br>01:15:15,119 –&gt; 01:15:16,119<br>Right?</p>
<p>1199<br>01:15:16,119 –&gt; 01:15:20,119<br>So it’s not always me on the name flash at that point.</p>
<p>1200<br>01:15:20,119 –&gt; 01:15:22,119<br>But typically that’s good enough.</p>
<p>1201<br>01:15:23,119 –&gt; 01:15:25,119<br>But what happens if F-Sync calls a failure?</p>
<p>1202<br>01:15:25,119 –&gt; 01:15:27,119<br>What F-Sync says I can’t do it for you.</p>
<p>1203<br>01:15:28,119 –&gt; 01:15:30,119<br>What does that mean?</p>
<p>1204<br>01:15:33,119 –&gt; 01:15:38,119<br>Say the OS doesn’t crash, F-Sync just returns an error.</p>
<p>1205<br>01:15:41,119 –&gt; 01:15:45,119<br>In Linux, it’s going to mark the dirty pages of clean.</p>
<p>1206<br>01:15:45,119 –&gt; 01:15:46,119<br>It’s not a kernel pack.</p>
<p>1207<br>01:15:46,119 –&gt; 01:15:50,119<br>It says, these pages are clean, even though F-Sync failed.</p>
<p>1208<br>01:15:50,119 –&gt; 01:15:52,119<br>And then you need to call F-Sync again.</p>
<p>1209<br>01:15:52,119 –&gt; 01:15:55,119<br>It’s going to stick on those pages that you want to write that down.</p>
<p>1210<br>01:15:55,119 –&gt; 01:15:58,119<br>It’s going to stick on those pages that you want to write to disk for your F-Rite.</p>
<p>1211<br>01:15:58,119 –&gt; 01:16:00,119<br>It’s going to come back and say, yep, I got them.</p>
<p>1212<br>01:16:00,119 –&gt; 01:16:01,119<br>They’re clean.</p>
<p>1213<br>01:16:01,119 –&gt; 01:16:02,119<br>It’s on disk.</p>
<p>1214<br>01:16:02,119 –&gt; 01:16:04,119<br>But it’s aligned to you.</p>
<p>1215<br>01:16:04,119 –&gt; 01:16:05,119<br>Right?</p>
<p>1216<br>01:16:05,119 –&gt; 01:16:07,119<br>Why is it aligned to you?</p>
<p>1217<br>01:16:10,119 –&gt; 01:16:14,119<br>Because the kernel developer is worried about someone pulling out a USB stick.</p>
<p>1218<br>01:16:14,119 –&gt; 01:16:15,119<br>Right?</p>
<p>1219<br>01:16:15,119 –&gt; 01:16:22,119<br>And then the F-Sync failing and having a bunch of pages marked dirty in its page table</p>
<p>1220<br>01:16:22,119 –&gt; 01:16:26,119<br>that are never going to get come back again because you’re never going to put the USB stick back in again.</p>
<p>1221<br>01:16:26,119 –&gt; 01:16:27,119<br>Right?</p>
<p>1222<br>01:16:27,119 –&gt; 01:16:29,119<br>Is that the right thing for databases?</p>
<p>1223<br>01:16:29,119 –&gt; 01:16:30,119<br>F***ing hell.</p>
<p>1224<br>01:16:30,119 –&gt; 01:16:31,119<br>Right?</p>
<p>1225<br>01:16:31,119 –&gt; 01:16:33,119<br>We’re not running a USB stick.</p>
<p>1226<br>01:16:33,119 –&gt; 01:16:38,119<br>So again, we need full control of everything to make sure we’re doing things right.</p>
<p>1227<br>01:16:38,119 –&gt; 01:16:45,119<br>Well, it turns out that people didn’t know that F-Sync was broken in this way for 20 years.</p>
<p>1228<br>01:16:45,119 –&gt; 01:16:51,119<br>So in 2018, there was a scandal called F-Sync gate where someone on the Post-GestMate</p>
<p>1229<br>01:16:51,119 –&gt; 01:16:56,119<br>on the Post-GestMailing list reported, hey, Post-Gest lost some of my data.</p>
<p>1230<br>01:16:56,119 –&gt; 01:17:00,119<br>But I never got a kernel panic and I never had a failure.</p>
<p>1231<br>01:17:00,119 –&gt; 01:17:05,119<br>And it turns out because F-Sync, on all these database systems, they would call F-Sync,</p>
<p>1232<br>01:17:05,119 –&gt; 01:17:09,119<br>F-Sync would turn to error and they just put it in a wild loop and call it again.</p>
<p>1233<br>01:17:09,119 –&gt; 01:17:15,119<br>And then F-Sync came back and said, yep, I got it because they marked out your pages that were dirty to clean even though they were never written.</p>
<p>1234<br>01:17:15,119 –&gt; 01:17:17,119<br>It’s not just Post-Gest had this problem.</p>
<p>1235<br>01:17:17,119 –&gt; 01:17:21,119<br>MongoDB had this problem and wiretiger, a bunch of other systems.</p>
<p>1236<br>01:17:21,119 –&gt; 01:17:28,119<br>So now what do they do? Well, F-Sync fails, then the system crashes and then you’ve got to go figure out what’s going on.</p>
<p>1237<br>01:17:28,119 –&gt; 01:17:33,119<br>But for 20 years, people didn’t know this was an issue.</p>
<p>1238<br>01:17:33,119 –&gt; 01:17:44,119<br>Right? And so this is not an issue of the page cache, but this is an example where we need to make sure we have full control of what is getting red and written from disk into memory</p>
<p>1239<br>01:17:44,119 –&gt; 01:17:49,119<br>and that when we write things out the disk, we want to make sure that it’s actually safe and correct.</p>
<p>1240<br>01:17:49,119 –&gt; 01:17:58,119<br>And that the OS can lie to us because the OS doesn’t care about databases because the OS is worried about somebody with the USB stick or whatever,</p>
<p>1241<br>01:17:58,119 –&gt; 01:18:01,119<br>because it’s trying to be a general purpose system.</p>
<p>1242<br>01:18:01,119 –&gt; 01:18:07,119<br>And so we need to make sure that we, as a data system, developers, put the mechanisms in place to make sure that we don’t get screwed.</p>
<p>1243<br>01:18:07,119 –&gt; 01:18:11,119<br>Okay?</p>
<p>1244<br>01:18:12,119 –&gt; 01:18:16,119<br>All right, so there’s multiple polls other than what we’ve talked about.</p>
<p>1245<br>01:18:16,119 –&gt; 01:18:20,119<br>Just think of a formal cache is for joins and things like that. We’ll see that later.</p>
<p>1246<br>01:18:20,119 –&gt; 01:18:27,119<br>Okay, so we’re always be better than the operating system despite what the Linux people say, the OS people say,</p>
<p>1247<br>01:18:27,119 –&gt; 01:18:35,119<br>and because we know what the query plans are wanted to do, we know how queries run access data and we can always do better things.</p>
<p>1248<br>01:18:35,119 –&gt; 01:18:39,119<br>So hash tables next class, but let me talk about Project One very quickly.</p>
<p>1249<br>01:18:39,119 –&gt; 01:18:43,119<br>So you’ll be implementing this in bus tobb obviously, and so you have three parts.</p>
<p>1250<br>01:18:43,119 –&gt; 01:18:50,119<br>You’re LRUK, replace some policy, a disk schedule, a very primitive one, and then the actual bubble manager instance itself.</p>
<p>1251<br>01:18:50,119 –&gt; 01:18:53,119<br>Oh, shit.</p>
<p>1252<br>01:18:53,119 –&gt; 01:18:59,119<br>So for the first one, there’ll be a separate class, the implement, the basically keep track of all the pages,</p>
<p>1253<br>01:18:59,119 –&gt; 01:19:04,119<br>and then there’ll be an API implement that says, I need, give me a page to a bit.</p>
<p>1254<br>01:19:04,119 –&gt; 01:19:11,119<br>So you sort of implement that first, and then there’s, there’s, there’s, you know, there’s tests to make sure this is actually working correctly.</p>
<p>1255<br>01:19:11,119 –&gt; 01:19:16,119<br>If none of the pages have been touched on the same you check, then it’s always a turn the lowest page ID.</p>
<p>1256<br>01:19:16,119 –&gt; 01:19:19,119<br>Because again, you got to fix something.</p>
<p>1257<br>01:19:19,119 –&gt; 01:19:22,119<br>And so you decide what to fix based on that.</p>
<p>1258<br>01:19:22,119 –&gt; 01:19:26,119<br>The next thing you implement is a disk schedule. Basically, you can take a bunch of different requests,</p>
<p>1259<br>01:19:26,119 –&gt; 01:19:35,119<br>or even threads running at the same time, and then have a single queue to decide in which order you should apply those, the, the, the reason rights.</p>
<p>1260<br>01:19:35,119 –&gt; 01:19:42,119<br>And the way you implement this to the API, you, there’ll be a callback mechanism through the C++ Promise API, Promise Strux.</p>
<p>1261<br>01:19:42,119 –&gt; 01:19:50,119<br>And this is a function you invoke once the page, once the data that you, that the, that the, that the, the requester is waiting for is available.</p>
<p>1262<br>01:19:50,119 –&gt; 01:19:52,119<br>And you call that back.</p>
<p>1263<br>01:19:52,119 –&gt; 01:20:02,119<br>It’s not going to be true asynchronous IO, but because, because basically the thread that makes the request will block it from this callback, but this would be the building block to do more sophisticated things.</p>
<p>1264<br>01:20:02,119 –&gt; 01:20:06,119<br>So make sure that what you build here is, is thread safe.</p>
<p>1265<br>01:20:06,119 –&gt; 01:20:12,119<br>The last thing is the buffer manager itself, and this will be built on top of the LUK implementation and the, and your disk scheduler.</p>
<p>1266<br>01:20:12,119 –&gt; 01:20:19,119<br>And you maintain the internal data structure to read and write data, usually disk scheduler, and keep track of what pages are free and when they’re accessed.</p>
<p>1267<br>01:20:19,119 –&gt; 01:20:26,119<br>And the thing that always trips up people every year is make sure you get the order and correct read when you’re pinning an unpainting.</p>
<p>1268<br>01:20:26,119 –&gt; 01:20:35,119<br>So, six might not be the right number, but don’t change any other file, because everything will get over, overwritten when you load it up into grade scope.</p>
<p>1269<br>01:20:35,119 –&gt; 01:20:42,119<br>The project is cumulative. We won’t be writing solutions and then post everything on, on Piazza as you go along.</p>
<p>1270<br>01:20:42,119 –&gt; 01:20:48,119<br>Like in project zero, you have to make sure you have good code quality, so make sure you run, make format, and then check, clang tidy.</p>
<p>1271<br>01:20:48,119 –&gt; 01:20:54,119<br>Because if you don’t do this and you upload the grade scope, you’ll get a zero.</p>
<p>1272<br>01:20:54,119 –&gt; 01:20:58,119<br>We are having a, for this project and all the other projects, there will be extra credit.</p>
<p>1273<br>01:20:58,119 –&gt; 01:21:06,119<br>There’s a leaderboard with the additional tasks that go beyond the core requirements, and then you’ll get ranked when you submit your, submit your thing on grade scope.</p>
<p>1274<br>01:21:06,119 –&gt; 01:21:13,119<br>And then the top 20 students will get bonus points for this project, and this will be available for all four projects.</p>
<p>1275<br>01:21:13,119 –&gt; 01:21:21,119<br>And then the student at the end of the semester has the highest score, bonus points, and all the students will get a limited edition bus tub hoodie.</p>
<p>1276<br>01:21:21,119 –&gt; 01:21:29,119<br>You have to fill out a tax form because their limited edition, they cost $5,000, and again, CME will handle that, the paper will work for that.</p>
<p>1277<br>01:21:29,119 –&gt; 01:21:35,119<br>But it’s highly desirable. Don’t f*** around, don’t plagiarize, because again, the grade scope has the automatic,</p>
<p>1278<br>01:21:35,119 –&gt; 01:21:42,119<br>plasier-room checker, and we go find the randos of GitHub. We put them as fake students, and if you copy them, you’ll get flag.</p>
<p>1279<br>01:21:42,119 –&gt; 01:21:44,119<br>Okay? Hit it.</p>
<p>1280<br>01:22:35,119 –&gt; 01:22:42,119<br>I’m going to get the rand to every state. When I’m acting, how I’m living, I tell them I’m living great.</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CMU15445 P7F202306 DatabaseMemoryDiskI⧸OManagement</div>
      <div>http://example.com/2025/10/24/CMU15445 P7F202306-DatabaseMemoryDiskI⧸OManagement/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月24日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/24/CMU15445%20P6F202305-StorageModelsDatabaseCompression/" title="CMU15445 P6F202305 StorageModelsDatabaseCompression">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CMU15445 P6F202305 StorageModelsDatabaseCompression</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/24/CMU15445%20P5F202304-DatabaseStoragePart2/" title="CMU15445 P5F202304 DatabaseStoragePart2">
                        <span class="hidden-mobile">CMU15445 P5F202304 DatabaseStoragePart2</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
