

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="100:00:00,000 –&gt; 00:00:06,000Cane Gimellan University’s advanced database systems courses 200:00:06,000 –&gt; 00:00:09,000filming front of the live studio audience. 300:00:09,000 –&gt; 00:00:19,000">
<meta property="og:type" content="article">
<meta property="og:title" content="CMU15721 P15S202414 QueryOptimizerImplementation2CMUAdvancedDatabaseSystems">
<meta property="og:url" content="http://example.com/2025/10/24/CMU15721%20P15S202414-QueryOptimizerImplementation2CMUAdvancedDatabaseSystems/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="100:00:00,000 –&gt; 00:00:06,000Cane Gimellan University’s advanced database systems courses 200:00:06,000 –&gt; 00:00:09,000filming front of the live studio audience. 300:00:09,000 –&gt; 00:00:19,000">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-24T11:57:41.745Z">
<meta property="article:modified_time" content="2025-10-24T12:06:28.544Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>CMU15721 P15S202414 QueryOptimizerImplementation2CMUAdvancedDatabaseSystems - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CMU15721 P15S202414 QueryOptimizerImplementation2CMUAdvancedDatabaseSystems"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-24 19:57" pubdate>
          2025年10月24日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.8k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          57 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">CMU15721 P15S202414 QueryOptimizerImplementation2CMUAdvancedDatabaseSystems</h1>
            
            
              <div class="markdown-body">
                
                <p>1<br>00:00:00,000 –&gt; 00:00:06,000<br>Cane Gimellan University’s advanced database systems courses</p>
<p>2<br>00:00:06,000 –&gt; 00:00:09,000<br>filming front of the live studio audience.</p>
<p>3<br>00:00:09,000 –&gt; 00:00:19,000<br>I have one of the chips in my office for some reason.</p>
<p>4<br>00:00:19,000 –&gt; 00:00:22,000<br>They took me on a boat on Hawaii and they’re like,</p>
<p>5<br>00:00:22,000 –&gt; 00:00:25,000<br>here’s a burnt out chip for a spark that has, you know,</p>
<p>6<br>00:00:25,000 –&gt; 00:00:27,000<br>oracle compression built inside of it.</p>
<p>7<br>00:00:27,000 –&gt; 00:00:30,000<br>Okay, I have it. I don’t know what to do with it.</p>
<p>8<br>00:00:30,000 –&gt; 00:00:32,000<br>Anyway, sorry.</p>
<p>9<br>00:00:32,000 –&gt; 00:00:34,000<br>We can go over.</p>
<p>10<br>00:00:34,000 –&gt; 00:00:37,000<br>All right. Data bases.</p>
<p>11<br>00:00:37,000 –&gt; 00:00:38,000<br>Query optimization.</p>
<p>12<br>00:00:38,000 –&gt; 00:00:41,000<br>All right, so last class, we didn’t get through everything.</p>
<p>13<br>00:00:41,000 –&gt; 00:00:43,000<br>We’ll go over this again.</p>
<p>14<br>00:00:43,000 –&gt; 00:00:46,000<br>Again, I’ll go a bit slower than maybe the day last time.</p>
<p>15<br>00:00:46,000 –&gt; 00:00:49,000<br>I’ll just walk through what Cascades is doing and then we’ll finish up with randomize search.</p>
<p>16<br>00:00:49,000 –&gt; 00:00:51,000<br>Before we jump into what today’s paper is about.</p>
<p>17<br>00:00:51,000 –&gt; 00:00:55,000<br>But again, the things we discussed last class</p>
<p>18<br>00:00:55,000 –&gt; 00:00:59,000<br>was going through this progression of how to do more sophisticated things</p>
<p>19<br>00:00:59,000 –&gt; 00:01:03,000<br>with the query optimizers, starting from just if the analysis rules looking for patterns</p>
<p>20<br>00:01:03,000 –&gt; 00:01:08,000<br>that then do some kind of rewrites, which is everyone uses when they first start out.</p>
<p>21<br>00:01:08,000 –&gt; 00:01:14,000<br>And then we saw how system R in the 1970s introduced this call space joint search</p>
<p>22<br>00:01:14,000 –&gt; 00:01:19,000<br>and that’s sort of the backbone of how the ratified search and unified search came along.</p>
<p>23<br>00:01:19,000 –&gt; 00:01:23,000<br>And then randomize search will be the variation of this.</p>
<p>24<br>00:01:23,000 –&gt; 00:01:28,000<br>So the distinction we were talking about last time was again the stratified search and the unified search.</p>
<p>25<br>00:01:28,000 –&gt; 00:01:30,000<br>And as I was saying, the lines are kind of blurry.</p>
<p>26<br>00:01:30,000 –&gt; 00:01:35,000<br>We’re like, okay, Cascades in SQL Server is technically a unified search,</p>
<p>27<br>00:01:35,000 –&gt; 00:01:40,000<br>but the way they invoke some of the rules, the transformation rules, as I was saying in a second,</p>
<p>28<br>00:01:40,000 –&gt; 00:01:43,000<br>it’s basically doing it without a call space search.</p>
<p>29<br>00:01:43,000 –&gt; 00:01:47,000<br>Like they’re doing transformations that you always want to do first.</p>
<p>30<br>00:01:47,000 –&gt; 00:01:51,000<br>And then they do something that is more exploratory search, like you would see in Cascades.</p>
<p>31<br>00:01:51,000 –&gt; 00:01:58,000<br>And so the thing that maybe matters the most is that we want to be able to define the transformation rules</p>
<p>32<br>00:01:58,000 –&gt; 00:02:02,000<br>ideally in the same dialect or DSL, whatever you want to call it,</p>
<p>33<br>00:02:02,000 –&gt; 00:02:07,000<br>that allow us to then be able to decide, do I want to move stuff to be always in this front phase</p>
<p>34<br>00:02:07,000 –&gt; 00:02:11,000<br>that I always want to run or the second phase where I do more exploration stuff.</p>
<p>35<br>00:02:11,000 –&gt; 00:02:13,000<br>So the stratified search is having two separate phases.</p>
<p>36<br>00:02:13,000 –&gt; 00:02:16,000<br>One with just heuristics, sorry, one using the rules,</p>
<p>37<br>00:02:16,000 –&gt; 00:02:19,000<br>but without a cost model, the second one is doing cost-based search.</p>
<p>38<br>00:02:19,000 –&gt; 00:02:23,000<br>And then the unified search is the idea is like you just do everything all at once.</p>
<p>39<br>00:02:23,000 –&gt; 00:02:27,000<br>And you avoid a bunch of expensive transformations or getting stuck in infinite loops.</p>
<p>40<br>00:02:27,000 –&gt; 00:02:30,000<br>We saw again how the memo table is going to help with that.</p>
<p>41<br>00:02:30,000 –&gt; 00:02:34,000<br>So, less so about maybe the stratified search for the unified search,</p>
<p>42<br>00:02:34,000 –&gt; 00:02:40,000<br>the thing that really matters when we understand is that it is going to be top down versus bottom up.</p>
<p>43<br>00:02:40,000 –&gt; 00:02:45,000<br>Right? So the Cascades approach is top down, meaning I start with the outcome that I want.</p>
<p>44<br>00:02:45,000 –&gt; 00:02:47,000<br>Like this is the final output I want for my query.</p>
<p>45<br>00:02:47,000 –&gt; 00:02:53,000<br>I don’t know how I got there in my query plan, but I’m going to go down the tree and assemble the pieces,</p>
<p>46<br>00:02:53,000 –&gt; 00:02:58,000<br>or assemble the operators I need to then feed me into my final output.</p>
<p>47<br>00:02:58,000 –&gt; 00:03:02,000<br>Whereas in the bottom optimization, which is what the system R guys started with,</p>
<p>48<br>00:03:02,000 –&gt; 00:03:10,000<br>is that you start with nothing and you then add the operators you need to get you up to the goal that you want.</p>
<p>49<br>00:03:10,000 –&gt; 00:03:13,000<br>And again, me standing up here and making hand gestures like this and this,</p>
<p>50<br>00:03:13,000 –&gt; 00:03:19,000<br>maybe doesn’t really sink in and mean anything, but there are certain amnesty you can apply more easily in one versus another.</p>
<p>51<br>00:03:19,000 –&gt; 00:03:24,000<br>At a high level, they are composable, they’re communicative, you could use one versus another.</p>
<p>52<br>00:03:24,000 –&gt; 00:03:28,000<br>But there are some optimizations you can do in top down one that maybe you can’t do in bottom up.</p>
<p>53<br>00:03:28,000 –&gt; 00:03:31,000<br>And likewise in bottom up, you can’t do in top down. Yes.</p>
<p>54<br>00:03:31,000 –&gt; 00:03:33,000<br>Is stratified always bottom up?</p>
<p>55<br>00:03:33,000 –&gt; 00:03:35,000<br>No, his question is stratified always bottom up.</p>
<p>56<br>00:03:35,000 –&gt; 00:03:36,000<br>That’s what I’m saying.</p>
<p>57<br>00:03:36,000 –&gt; 00:03:43,000<br>The case case as described by Microsoft is that stratified because they have a bunch of rules that you always run,</p>
<p>58<br>00:03:43,000 –&gt; 00:03:46,000<br>then later on they run the cost based search.</p>
<p>59<br>00:03:46,000 –&gt; 00:03:49,000<br>And in that cost based search, it’s doing top down.</p>
<p>60<br>00:03:49,000 –&gt; 00:03:54,000<br>But the transformation rules are sort of operating in the same way.</p>
<p>61<br>00:03:54,000 –&gt; 00:03:57,000<br>They’re generating these logical plans at a top down manner too.</p>
<p>62<br>00:03:57,000 –&gt; 00:04:01,000<br>But that would be technically that’s a stratified search because you have something you always do,</p>
<p>63<br>00:04:01,000 –&gt; 00:04:04,000<br>and then you have a cost based thing that you can be dynamic about.</p>
<p>64<br>00:04:04,000 –&gt; 00:04:05,000<br>Right.</p>
<p>65<br>00:04:05,000 –&gt; 00:04:10,000<br>So most of the open source systems are going to be bottom up.</p>
<p>66<br>00:04:10,000 –&gt; 00:04:18,000<br>Even the guy that invented cascades said the way you probably want to do a career optimization now</p>
<p>67<br>00:04:18,000 –&gt; 00:04:22,000<br>is start with cascades in a stratified manner like run some initial rules.</p>
<p>68<br>00:04:22,000 –&gt; 00:04:25,000<br>Maybe not necessarily in the full cost based search.</p>
<p>69<br>00:04:25,000 –&gt; 00:04:26,000<br>It wasn’t clear.</p>
<p>70<br>00:04:26,000 –&gt; 00:04:28,000<br>It’s sort of offhand comedy made at a conference.</p>
<p>71<br>00:04:28,000 –&gt; 00:04:32,000<br>And then you want to do the bottom up, or start the bottom up,</p>
<p>72<br>00:04:32,000 –&gt; 00:04:36,000<br>and bottom up, optimization to pick joint ordering.</p>
<p>73<br>00:04:36,000 –&gt; 00:04:37,000<br>All right.</p>
<p>74<br>00:04:37,000 –&gt; 00:04:42,000<br>So, again, today’s class, I just want to spend the first half going over again</p>
<p>75<br>00:04:42,000 –&gt; 00:04:46,000<br>what we missed and rushed through at the end of last class of the unified search and cascades.</p>
<p>76<br>00:04:46,000 –&gt; 00:04:49,000<br>And then we’ll see how we then apply that run by search.</p>
<p>77<br>00:04:49,000 –&gt; 00:04:53,000<br>And then I want to go quickly over some real world examples of what the,</p>
<p>78<br>00:04:53,000 –&gt; 00:04:58,000<br>what some closed source and open source career optimizers actually look like.</p>
<p>79<br>00:04:58,000 –&gt; 00:05:02,000<br>The main is it’s going to be sequels over calcite, orca, and calcish DB.</p>
<p>80<br>00:05:02,000 –&gt; 00:05:09,000<br>And then we’ll finish up with going over at a high level again the unnesting subquery paper you guys were starting to reading.</p>
<p>81<br>00:05:09,000 –&gt; 00:05:13,000<br>Hopefully I wasn’t too dense on the mission, Aldro, but it’s a,</p>
<p>82<br>00:05:13,000 –&gt; 00:05:16,000<br>it’s one of the things where I think everyone should know it.</p>
<p>83<br>00:05:16,000 –&gt; 00:05:19,000<br>We probably should teach it in the intro class.</p>
<p>84<br>00:05:19,000 –&gt; 00:05:22,000<br>Very few systems actually implement it entirely.</p>
<p>85<br>00:05:22,000 –&gt; 00:05:25,000<br>As far as I know, only ducty B, Umbra, and Hyper.</p>
<p>86<br>00:05:25,000 –&gt; 00:05:28,000<br>My former student who took 7201, she’s at Databricks.</p>
<p>87<br>00:05:28,000 –&gt; 00:05:33,000<br>She implemented almost all of it in Databricks and not, not, not everything.</p>
<p>88<br>00:05:33,000 –&gt; 00:05:36,000<br>But we’ll walk through an example there.</p>
<p>89<br>00:05:36,000 –&gt; 00:05:39,000<br>And unfortunately, say a time we’re not going to be able to cover the,</p>
<p>90<br>00:05:39,000 –&gt; 00:05:46,000<br>how Hyper does their, their, their dynamic dynamic program approach or DP approach for finding joiners.</p>
<p>91<br>00:05:46,000 –&gt; 00:05:49,000<br>But we can cover that offline if you want.</p>
<p>92<br>00:05:49,000 –&gt; 00:05:51,000<br>All right, so again, this is just a repeat.</p>
<p>93<br>00:05:51,000 –&gt; 00:05:55,000<br>I’ll tell you in the last class where the cascades optimizer is going to be the,</p>
<p>94<br>00:05:55,000 –&gt; 00:05:59,000<br>the third version, or third generation of a query optimizer,</p>
<p>95<br>00:05:59,000 –&gt; 00:06:02,000<br>this guy, Gertz Graffey built, Exodus came first, then Volcano.</p>
<p>96<br>00:06:02,000 –&gt; 00:06:05,000<br>And it’s the same volcano when we describe the volcano model, this iterator thing.</p>
<p>97<br>00:06:05,000 –&gt; 00:06:12,000<br>But in that, in that system, in that, there’s papers, you also describes how to do parallel queries with the exchange operator.</p>
<p>98<br>00:06:12,000 –&gt; 00:06:16,000<br>And then he has this optimizer generator that he built in Volcano.</p>
<p>99<br>00:06:16,000 –&gt; 00:06:19,000<br>And then after that, he then built cascades.</p>
<p>100<br>00:06:19,000 –&gt; 00:06:22,000<br>But as far as I know, he just wrote the paper on cascades.</p>
<p>101<br>00:06:22,000 –&gt; 00:06:28,000<br>It’s very heavy handed on object-oriented programming because that was the hot thing in late 80s, early 90s.</p>
<p>102<br>00:06:28,000 –&gt; 00:06:36,000<br>And then as far as I know, nobody, he didn’t actually implement it except for being involved in this master’s thesis a few years later at Portland State.</p>
<p>103<br>00:06:36,000 –&gt; 00:06:42,000<br>But then Microsoft hired him to go build their new query optimizer because they were rewriting everything from their fork of cybase.</p>
<p>104<br>00:06:42,000 –&gt; 00:06:47,000<br>And that’s why, again, Microsoft famously is using, using cascades.</p>
<p>105<br>00:06:47,000 –&gt; 00:06:51,000<br>So it’s going to top down approach using a branch bound search.</p>
<p>106<br>00:06:51,000 –&gt; 00:07:09,000<br>And the key idea of what makes cascades interesting and better than what came before was that they were doing the incremental materialization of the possible ways to represent some expression,</p>
<p>107<br>00:07:09,000 –&gt; 00:07:12,000<br>which I’ll say it is a second.</p>
<p>108<br>00:07:12,000 –&gt; 00:07:21,000<br>Some operator in the query plan, whereas in Volcano, when you search down, you land at some node in the tree, you immediately materialized everything, which would explode your search base.</p>
<p>109<br>00:07:21,000 –&gt; 00:07:27,000<br>Even though you may run out of time to examine everything at that operator, at that level of the tree, you still materialize everything.</p>
<p>110<br>00:07:27,000 –&gt; 00:07:34,000<br>And so your memory cost of Volcano would explode.</p>
<p>111<br>00:07:34,000 –&gt; 00:07:42,000<br>So the four key ideas of cascades, as we talked about last class, again, everything is going to be represented as data structures.</p>
<p>112<br>00:07:42,000 –&gt; 00:07:46,000<br>So within a task, we’d have, here’s the pattern I’m looking for in my query plan.</p>
<p>113<br>00:07:46,000 –&gt; 00:07:48,000<br>Here’s the transformation I want to apply.</p>
<p>114<br>00:07:48,000 –&gt; 00:07:56,000<br>And you can have additional things, like a priority that says this thing should be considered more quickly than another one.</p>
<p>115<br>00:07:56,000 –&gt; 00:08:01,000<br>And in the paper, you can actually modify these priorities on the fly.</p>
<p>116<br>00:08:02,000 –&gt; 00:08:06,000<br>But in practice, again, I don’t, the cockroach TV does that, Microsoft does not.</p>
<p>117<br>00:08:06,000 –&gt; 00:08:30,000<br>Then we have explicit definition of these, what properties we need our operators to have to ensure that if data needs be sorted, a certain way, or data needs to come, you know, in a certain compressed form, we can make sure that anything we, any operator we would generate in our query plan, at some level in the tree, meets the expectations of, sorry, anything below us in the tree meets the expectation of the parent we’re feeding into.</p>
<p>118<br>00:08:31,000 –&gt; 00:08:38,000<br>And then we talked about this, you can reorder things on the fly to find the best plan more quickly based on what you know the query plan is done so far.</p>
<p>119<br>00:08:38,000 –&gt; 00:08:50,000<br>And then this last one, again, is important that within the same search engine and the rule definitions, we can do pattern matching and transformations of expressions and ware clauses, having clauses or joint clauses, whatever.</p>
<p>120<br>00:08:50,000 –&gt; 00:08:56,000<br>In the same way that we would do a search for, you know, converting logical operators to physical operators.</p>
<p>121<br>00:08:56,000 –&gt; 00:09:06,000<br>And this is nice again, you don’t have to do like one pass for the ware clause, optimize that and then a separate pass for the query plans themselves, all that’s done in a single engine.</p>
<p>122<br>00:09:06,000 –&gt; 00:09:15,000<br>Like I think my sequel, they treat the expressions and the ware clause separately from the query operators. So they have sort of two optimization passes.</p>
<p>123<br>00:09:16,000 –&gt; 00:09:30,000<br>So the definition we care about in case case is this notion of an expression and it’s just going to be some operation that we want to do in our query plan that is going to have zero or more inputs coming coming into us.</p>
<p>124<br>00:09:30,000 –&gt; 00:09:35,000<br>So you can be a leaf in the query plan or it could be some middle operator.</p>
<p>125<br>00:09:36,000 –&gt; 00:09:42,000<br>And we can sort of group them together and say here’s a here’s a higher level thing that we want to do and we’ll represent that as an expression.</p>
<p>126<br>00:09:42,000 –&gt; 00:09:51,000<br>So for example, if I want to join a, b and c on simple IDs, I got a logical expression that says I’m going to join a with the then join that with c.</p>
<p>127<br>00:09:51,000 –&gt; 00:09:55,000<br>And then if I flip the order, then that’s considered another expression as well.</p>
<p>128<br>00:09:56,000 –&gt; 00:10:09,000<br>And then I can have a physical manifestation of that expression by actually specifying here’s the scan method I’m going to use or access method I’m going to use for that given table and here’s the join algorithm I want to use.</p>
<p>129<br>00:10:09,000 –&gt; 00:10:18,000<br>And then now I’m going to combine or group these together the equivalent expressions based on what we know is the relation algebra rules into what is called a group.</p>
<p>130<br>00:10:18,000 –&gt; 00:10:32,000<br>So the idea is here is that within one container or construct entry in our system in our query optimizer, we would say here’s the output that I expect, you know, a join b join c.</p>
<p>131<br>00:10:32,000 –&gt; 00:10:39,000<br>Then here’s all the equivalent logical expressions, permutations of the join order and then here’s all the equivalent physical expressions.</p>
<p>132<br>00:10:39,000 –&gt; 00:10:47,000<br>So within one entry in our system, we can say here’s everything that here’s all the different possible ways we could actually execute to produce the output we would need for a single group.</p>
<p>133<br>00:10:47,000 –&gt; 00:11:01,000<br>So the entire thing itself is the group and then these are all just the equivalent expressions and they also embed additional information about like here’s the properties that I need to have coming into the data that I want here.</p>
<p>134<br>00:11:01,000 –&gt; 00:11:12,000<br>So then we can combine expressions even further into what’s called a multi expression and this is just basically a placeholder that says there’s some expression below me in the query plan.</p>
<p>135<br>00:11:12,000 –&gt; 00:11:24,000<br>And at this point, at this group in my search tree, I don’t actually know what it is, right, but I’m just going to keep track of like I know something below me can tell me how this thing would actually be executed.</p>
<p>136<br>00:11:24,000 –&gt; 00:11:34,000<br>So for example, if I need to join a b and c, I could have a multi expression that says I’m going to join a and b, I don’t know how and I don’t know what in what order.</p>
<p>137<br>00:11:34,000 –&gt; 00:11:42,000<br>But then I’m going to join whatever the output of that is with c and then you have the various combinations of the joint orders and so forth.</p>
<p>138<br>00:11:42,000 –&gt; 00:11:50,000<br>And likewise, the various combinations for the algorithm we’re going to use to join it.</p>
<p>139<br>00:11:50,000 –&gt; 00:12:05,000<br>So if it’s a bottoms up approach, you’re basically starting with like the smallest atomic multi expression you could have like go reday, right, and then you go add the pieces or the components to that going up towards the optimizer to the final output.</p>
<p>140<br>00:12:05,000 –&gt; 00:12:20,000<br>And in this case, because we’re at the top going top down, we start with this multi expression says I want some output of a join b join c and then I’m going down and then filling in filling in the specifications of the exact details of how to do that.</p>
<p>141<br>00:12:20,000 –&gt; 00:12:31,000<br>Again, this is how they’re going to get away with not having to materialize everything all at once when you land and say in a group as you search down the tree, because now you say I have a placeholder for a and b.</p>
<p>142<br>00:12:31,000 –&gt; 00:12:44,000<br>So I’m going to tell you something. Someone below me is going to tell me how to handle that. But right now I can just reason about whatever expressions I’m looking at within my group directly.</p>
<p>143<br>00:12:44,000 –&gt; 00:12:56,000<br>And then likewise, you can make further decisions based on this priority. So as we talked about, like if I’m trying to consider, should I go look at what happens when I join a and b, should I go look at when I scan c.</p>
<p>144<br>00:12:56,000 –&gt; 00:13:05,000<br>You can decide dynamically as you’re going down the tree, which of these paths you want to look at first.</p>
<p>145<br>00:13:05,000 –&gt; 00:13:12,000<br>So this we’ve already defined again, the rules are just ways to convert logical operators to logical operators or logical to physical.</p>
<p>146<br>00:13:12,000 –&gt; 00:13:20,000<br>And in the end, the database system needs physical operators because that tells you what the system is actually going to do when it when it exits things.</p>
<p>147<br>00:13:20,000 –&gt; 00:13:37,000<br>And then within a rule, we’d say here’s the pattern that I want to match on either in a logical special or physical special, and then here’s the transformation I want to do to put the query plan that I’m looking at or the group that I’m looking at into a new form.</p>
<p>148<br>00:13:37,000 –&gt; 00:14:01,000<br>So this is the example we saw before. I have a my patterns to identify when I have two joins across three groups. And then I would have a logical plan that looks like this. And note here again, I have the multi expression that says I’m joining a and b, but then down below me, now I’m just saying a joint a with b. And then below that, I can specify how max accessing the data.</p>
<p>149<br>00:14:01,000 –&gt; 00:14:13,000<br>So I’m going to have a transformation rule that says is rotated left to right or I can have an implementation rule that says convert all the aqua joins that I have in here into a certain race join or hash join or an acid loop join, so forth.</p>
<p>150<br>00:14:14,000 –&gt; 00:14:31,000<br>And as we said before, to avoid having to get stuck in infinite loops because I go like left to right and right to left and just doing these transformations over again, we’re going to use a memo table to keep track of have I do I know something about what the outcome of this transformation would be.</p>
<p>151<br>00:14:31,000 –&gt; 00:14:49,000<br>And therefore, I don’t need to apply it because I’ve already seen it. So rather than doing that on like on every individual rule for every single possible state of the query plan, I memo tables just can keep track of like, OK, I know that for this multi expression, I have a cost for it.</p>
<p>152<br>00:14:49,000 –&gt; 00:14:56,000<br>And I don’t need to go look at what happens when I make that transformation, if I if that transformation’s cost is going to be.</p>
<p>153<br>00:14:57,000 –&gt; 00:15:03,000<br>Sorry, the cost of the query plan after that transformation is worse than the best I’ve seen that I know I don’t need to go look at it.</p>
<p>154<br>00:15:05,000 –&gt; 00:15:14,000<br>So as we said, the memo table again, the different ways to implement this, I think Microsoft puts this as actually inside the groups themselves.</p>
<p>155<br>00:15:14,000 –&gt; 00:15:24,000<br>I think cockroach TV maintains this as a separate hash table, but it’s basically again some table that’s going to keep track of for a given, given multi expression.</p>
<p>156<br>00:15:25,000 –&gt; 00:15:33,000<br>Here’s the best the best physical operator I’ve seen for it and here’s the best, here’s the lowest cost.</p>
<p>157<br>00:15:34,000 –&gt; 00:15:53,000<br>You’ll also keep track of like the the properties that I care about, whether the data is coming up with this operator for a given multi expression with what again what physical properties and I can know that if I’m looking at something differently, even though I’m looking at a different multi from looking at a different operator that I can</p>
<p>158<br>00:15:53,000 –&gt; 00:16:09,000<br>go look at the data in the group, if it has a different physical property, I can then maybe still evaluate and go further and you would do this things like if the best cost I’ve seen so far is a sequential scan, but I know that for the given group that I’m at, I really wanted to be sorted now because that’ll change my my cost expectations.</p>
<p>159<br>00:16:10,000 –&gt; 00:16:18,000<br>Then if the multi group below me doesn’t now, you know, does not enforce that property or provide that property, I can still go down and look at look for other things.</p>
<p>160<br>00:16:19,000 –&gt; 00:16:35,000<br>So the basic idea hell is going to work, not to get too theoretical is this idea of the principle of optimality and all it says is that if we have a what is the true optimal plan, then any sub plan of that optimal plan is going to be optimal.</p>
<p>161<br>00:16:35,000 –&gt; 00:16:47,000<br>It’s sort of a sort of a sort of self defining like if I have the optimal plan that any portion of that of that query plan is going to be optimal because if it wasn’t optimal, then that wouldn’t be the optimal plan.</p>
<p>162<br>00:16:48,000 –&gt; 00:17:04,000<br>So because of that, this is how we’re going to be able to do branch and bound search to identify that if the if I’m at some some level in my search tree, if the cost to traverse down to my query plan as I go below is now worse than the best possible plan.</p>
<p>163<br>00:17:05,000 –&gt; 00:17:19,000<br>So if the plan I’ve ever seen so far, then I know I don’t need to go down and look further because there’s no magic way that that cost is now going to become less because it’s you know, add you go down the level, you’re adding more physical operators, you’re accumulating more costs estimates, right, that’s this a summation.</p>
<p>164<br>00:17:19,000 –&gt; 00:17:26,000<br>So you’re not magically going to get faster. So we just cut things off and avoid having to search, search further.</p>
<p>165<br>00:17:26,000 –&gt; 00:17:47,000<br>So this is the example that we have before. Again, we want to join a B and C. So the very beginning, we just start with the root and we apply logical transformations to generate different logical multi expressions and then say for rather than materializing much of all the logical multi expressions, what is jumped down the first one we have and see what the cost is.</p>
<p>166<br>00:17:47,000 –&gt; 00:18:12,000<br>So now we come down here, do the same thing. We have the multi expression AB. We do a logical transformation to cover it into a multi expression on a joined by a multi expression on B. But now we need to get the cost of these these inter multi expressions. So we go down here and this is doing the access on a there’s nothing other than just get a there’s not there’s not no other multi logical multi expression.</p>
<p>167<br>00:18:12,000 –&gt; 00:18:35,000<br>So then we’ll materialize the different physical multi expressions so either a sequential scan on a index scan on a for brevity. I’m not showing you like, okay, what index I’m actually using, but you can imagine, you know, for all my possible choices of indexes, you would have additional, you would have mouthwater for each index I could use an index scan on a table. I would have entry for each of those.</p>
<p>168<br>00:18:36,000 –&gt; 00:19:02,000<br>And then again, you can do ranking in the priority, let’s just say, well, only consider the indexes that, you know, rank them, rank the order in which I value the indexes in my in my multi expression list here based on the selectivity of them or the which ones cover the most columns that I need in my query. There’s a bunch of different rules you can do to figure out some just blindly looking at all possible indexes.</p>
<p>169<br>00:19:03,000 –&gt; 00:19:20,000<br>All right, so now that we have these these two different physical multi expressions, we do some cost model look up and say, okay, well, the sequential scan is going to be the fastest has the cost of 10. So we add the multi question on a into our our memo table and with the best physical expression we’ve gotten for the cost of 10.</p>
<p>170<br>00:19:21,000 –&gt; 00:19:28,000<br>Then we go back up the tree do the same thing down the B same thing we convert that to physical multi expressions, we end up with the in sequential scan index and a B.</p>
<p>171<br>00:19:29,000 –&gt; 00:19:37,000<br>So I understand it’s still faster, we get we get a cost of 20 and then now we bounce up bounce back up to our to our multi special on a B.</p>
<p>172<br>00:19:38,000 –&gt; 00:19:49,000<br>We do further transformations to now flip the water of the joints, not B joining a. But now we need again to do the same thing and get the what is the cost of actually accessing these different tables.</p>
<p>173<br>00:19:49,000 –&gt; 00:19:59,000<br>Well, when we go down to these lower notes here, we will see that we’ve already done this costing for us because in our memo table, so we actually don’t even do the do traversal.</p>
<p>174<br>00:19:59,000 –&gt; 00:20:07,000<br>We can at this point here we can go look up the memo table and say what is the best cost for there scanning B and scanning A. And then we just reuse that.</p>
<p>175<br>00:20:08,000 –&gt; 00:20:16,000<br>So now again, say, you know, there’s only a joint being to be joint A. So now we generally all the physical multi expressions.</p>
<p>176<br>00:20:16,000 –&gt; 00:20:26,000<br>And then again, using our cost model, we then figure out that the hash joint is the fastest. So the cost of the hash line plus the cost of the scans on a and B produces the cost of 80 and that goes in our memo table.</p>
<p>177<br>00:20:27,000 –&gt; 00:20:43,000<br>And then we bounce back up and do now go on the other side of C and do the same evaluation. Yada yada so forth until we then maybe exhaust the search for the different joint orders we have for AD and C and we on end up with the lowest cost of 125.</p>
<p>178<br>00:20:46,000 –&gt; 00:21:05,000<br>So this is clear. So this is what cascades are doing again, you’re starting with in this case here, I’m going to join A, B and C not so simply order not specifying how I’m accessing the tables not specifying what the joint algorithm going to use and it traverse down and use the memo table to keep track of the best cost I have.</p>
<p>179<br>00:21:05,000 –&gt; 00:21:18,000<br>Yes, so this is the cost base, but you said there were a few rules that tries to find every single time. Yes, so how would that work? So we first build this table and then or would it do it somehow before?</p>
<p>180<br>00:21:18,000 –&gt; 00:21:28,000<br>So like, like the, what I showed here, like, okay, I have get a and then I take the logical multi expression and convert it to physical multi expression.</p>
<p>181<br>00:21:28,000 –&gt; 00:21:43,000<br>Like the rule could be like you would say if I land here, I know I’m accessing the logical expression on a scan on a, or accessing a table. So let me always run the transformation rule implementation rule that spits out different physical multi expressions.</p>
<p>182<br>00:21:43,000 –&gt; 00:21:53,000<br>So the rule is going to be just say, only speak sequential scan but can. No, no, no, no, no, when I’m saying is that you always generate the most expression that a sequential scan and all possible indexes scans on A.</p>
<p>183<br>00:21:53,000 –&gt; 00:22:08,000<br>That always gets fired. Then you do a cost based search to say, or selection which one of these is the best. Now whether or not you materialize all possible physical multi expressions depends on the complexity or whatever it is that you’re doing because that might balloon up the huge like up, you know, the joiner of above.</p>
<p>184<br>00:22:08,000 –&gt; 00:22:14,000<br>So you have a ranking say like to like preuse I think I should look at the joint owners first.</p>
<p>185<br>00:22:14,000 –&gt; 00:22:15,000<br>Yes.</p>
<p>186<br>00:22:15,000 –&gt; 00:22:35,000<br>Yes. What’s the difference is that when you land and say at the very, very beginning. So back up here, I generate all the logical multi expressions all the physical multi expressions.</p>
<p>187<br>00:22:35,000 –&gt; 00:22:40,000<br>Again, it seems kind of obviously you wouldn’t want to do that, but 80s 90s.</p>
<p>188<br>00:22:40,000 –&gt; 00:22:49,000<br>Right. Volcano didn’t have priorities. Volcano also didn’t have.</p>
<p>189<br>00:22:49,000 –&gt; 00:22:55,000<br>I don’t think you can evaluate the the wear calls expressions in the same method as well.</p>
<p>190<br>00:22:55,000 –&gt; 00:23:05,000<br>Right question this.</p>
<p>191<br>00:23:05,000 –&gt; 00:23:15,000<br>You mean like this right here. Right like it was a question.</p>
<p>192<br>00:23:15,000 –&gt; 00:23:28,000<br>Yeah, so right here saying I want to join a see together, but here you’re not defining how to do it.</p>
<p>193<br>00:23:28,000 –&gt; 00:23:32,000<br>You then go look up the memo table and say what’s the best way for me to have done that.</p>
<p>194<br>00:23:32,000 –&gt; 00:23:40,000<br>Yeah. What do we say we’re applying with before if we’re doing it while we’re doing all the courses.</p>
<p>195<br>00:23:40,000 –&gt; 00:23:45,000<br>This is still entirely unified. Like there isn’t a set of things that you’re doing before.</p>
<p>196<br>00:23:45,000 –&gt; 00:23:53,000<br>You’re doing this entire thing or get where you’re applying these transformations also has to be because picking the best one and then going back on.</p>
<p>197<br>00:23:53,000 –&gt; 00:23:56,000<br>So yeah, so his question is like.</p>
<p>198<br>00:23:56,000 –&gt; 00:24:02,000<br>Yeah, what how can I say that you could use cascades to do a two stage approach.</p>
<p>199<br>00:24:02,000 –&gt; 00:24:13,000<br>So like think of like the when you first show up you convert the AST from the parts SQL query into.</p>
<p>200<br>00:24:13,000 –&gt; 00:24:17,000<br>Some you know you have like a group like this I know I know I’m going to access a.</p>
<p>201<br>00:24:17,000 –&gt; 00:24:23,000<br>So you need to start populating those things. Right and then without.</p>
<p>202<br>00:24:23,000 –&gt; 00:24:27,000<br>I don’t know how Microsoft actually does that whether they can.</p>
<p>203<br>00:24:27,000 –&gt; 00:24:32,000<br>Inject themselves in any point of the tree and start doing transformations or they always start the top and go down.</p>
<p>204<br>00:24:32,000 –&gt; 00:24:34,000<br>But there’s like.</p>
<p>205<br>00:24:34,000 –&gt; 00:24:40,000<br>You could say you could say I’m going to traverse the tree and only apply these rules.</p>
<p>206<br>00:24:40,000 –&gt; 00:24:48,000<br>To put me into a form that when I do a cost based search I’m kind of pushed in the direction where I know it’s going to be a better you know a better plan.</p>
<p>207<br>00:24:48,000 –&gt; 00:24:50,000<br>And building on the corner.</p>
<p>208<br>00:24:50,000 –&gt; 00:24:55,000<br>Which is you said in volcano if one do everything is also but in the.</p>
<p>209<br>00:24:55,000 –&gt; 00:25:03,000<br>I put dot dot dot right like whether it’s power playing like whatever in that it looks at all.</p>
<p>210<br>00:25:03,000 –&gt; 00:25:10,000<br>It is a source no no no because you so again we talked about the when determination rules.</p>
<p>211<br>00:25:10,000 –&gt; 00:25:15,000<br>It could be a timer could be like how many transformations I’ve done could be like I haven’t seen anything better.</p>
<p>212<br>00:25:15,000 –&gt; 00:25:18,000<br>I mean they all had some kind of timer.</p>
<p>213<br>00:25:18,000 –&gt; 00:25:21,000<br>But it’s again whether or not you you you would.</p>
<p>214<br>00:25:21,000 –&gt; 00:25:26,000<br>Again materialize all possible things ahead of time before you look at them.</p>
<p>215<br>00:25:26,000 –&gt; 00:25:28,000<br>Well can it did not do that.</p>
<p>216<br>00:25:28,000 –&gt; 00:25:33,000<br>There’s other like object oriented program and stuff which again is we don’t care about.</p>
<p>217<br>00:25:33,000 –&gt; 00:25:44,000<br>What data is like on limits to make these estimations with like for example like like like the other page information like the something like the action information per page.</p>
<p>218<br>00:25:44,000 –&gt; 00:25:48,000<br>As you know you’re like skip it or not.</p>
<p>219<br>00:25:48,000 –&gt; 00:25:51,000<br>Like that’s not something you like.</p>
<p>220<br>00:25:51,000 –&gt; 00:25:53,000<br>Like for the cost.</p>
<p>221<br>00:25:53,000 –&gt; 00:25:58,000<br>That’s next week right that comes later but like you would.</p>
<p>222<br>00:25:58,000 –&gt; 00:26:03,000<br>The traditional database system like it’s meaning like you have you know statistics you’ve collected by running analyze or whatever.</p>
<p>223<br>00:26:03,000 –&gt; 00:26:13,000<br>Like you would you would you would be cost might would tell you what the selectivity of of you a little operator like this would be like how many data how much do I think I’m going to read.</p>
<p>224<br>00:26:13,000 –&gt; 00:26:17,000<br>You know it’s just a straight to a scan versus like a next scan.</p>
<p>225<br>00:26:17,000 –&gt; 00:26:20,000<br>So this is all day that you have to have a button.</p>
<p>226<br>00:26:20,000 –&gt; 00:26:24,000<br>You’re going to have to touch the data when you’re creating them.</p>
<p>227<br>00:26:24,000 –&gt; 00:26:27,000<br>So let me touch the data.</p>
<p>228<br>00:26:27,000 –&gt; 00:26:30,000<br>There’s only certain things you know after you from the query obviously.</p>
<p>229<br>00:26:30,000 –&gt; 00:26:31,000<br>Yes.</p>
<p>230<br>00:26:31,000 –&gt; 00:26:35,000<br>But like this analytics comes from either previous runs or estimation.</p>
<p>231<br>00:26:35,000 –&gt; 00:26:36,000<br>Correct.</p>
<p>232<br>00:26:36,000 –&gt; 00:26:44,000<br>So you say like these calls on as estimates as I’m describing here are done meeting make using someizations or sketches or whatever you will call it.</p>
<p>233<br>00:26:44,000 –&gt; 00:26:51,000<br>Of the data that you either derive from previous runs or your own analysis.</p>
<p>234<br>00:26:51,000 –&gt; 00:27:00,000<br>But also through a third category and you’ll see on Monday next week is sometimes there’s just a sample of data that’s local and you can run like you know.</p>
<p>235<br>00:27:00,000 –&gt; 00:27:07,000<br>Run the wear calls on that sample data just to see what the estimates going to be right sequels over does that.</p>
<p>236<br>00:27:07,000 –&gt; 00:27:14,000<br>But like all that is is it abstracted away from from this part is through the cost model.</p>
<p>237<br>00:27:14,000 –&gt; 00:27:15,000<br>Yes.</p>
<p>238<br>00:27:15,000 –&gt; 00:27:23,000<br>Why might one want to prefer to join the bottom up then.</p>
<p>239<br>00:27:23,000 –&gt; 00:27:26,000<br>So question why do you want to do bottom up versus top down.</p>
<p>240<br>00:27:26,000 –&gt; 00:27:27,000<br>Yeah.</p>
<p>241<br>00:27:27,000 –&gt; 00:27:28,000<br>So go question.</p>
<p>242<br>00:27:28,000 –&gt; 00:27:35,000<br>So there’s some weird things like you may not be able to do the.</p>
<p>243<br>00:27:35,000 –&gt; 00:27:40,000<br>Do all the branch bounding stuff that we want to do because I got to get to the bottom first.</p>
<p>244<br>00:27:40,000 –&gt; 00:27:44,000<br>Meaning like I can’t say okay well.</p>
<p>245<br>00:27:44,000 –&gt; 00:27:49,000<br>I am at this point here and I know that.</p>
<p>246<br>00:27:49,000 –&gt; 00:27:56,000<br>Maybe I’m farther up in the tree like think of like doing a lot of joints like so I’m up here and.</p>
<p>247<br>00:27:56,000 –&gt; 00:28:06,000<br>I have I can’t do any pruning of the of the search tree below me until something gets to the bottom and produces what I think is the best possible plan.</p>
<p>248<br>00:28:06,000 –&gt; 00:28:12,000<br>So you always have to generate the full plan then you can start pruning other things and sometimes like you can’t.</p>
<p>249<br>00:28:12,000 –&gt; 00:28:17,000<br>You do have to do the materialization of a logical to physical because.</p>
<p>250<br>00:28:17,000 –&gt; 00:28:23,000<br>I don’t know I can’t do cost estimates or I can’t get the the can get the lower bound.</p>
<p>251<br>00:28:23,000 –&gt; 00:28:26,000<br>If it’s just a logical expression.</p>
<p>252<br>00:28:26,000 –&gt; 00:28:30,000<br>I got to convert it to the physical operator to know what the true cost is going to be.</p>
<p>253<br>00:28:30,000 –&gt; 00:28:36,000<br>There’s some tricks you can play around like like doing estimates like you know worst case scenario things.</p>
<p>254<br>00:28:36,000 –&gt; 00:28:45,000<br>But it’s in the you’re going bottom to the top like along each step I have a physical operator I can I can cost things right there.</p>
<p>255<br>00:28:45,000 –&gt; 00:28:50,000<br>The essence is better because starting from the bottom.</p>
<p>256<br>00:28:50,000 –&gt; 00:28:54,000<br>It’s someone gives you more options and it also allows you to materialize physical.</p>
<p>257<br>00:28:54,000 –&gt; 00:28:57,000<br>I mean I mean materialize what sorry.</p>
<p>258<br>00:28:57,000 –&gt; 00:29:04,000<br>There’s other organizations you can do which we don’t have to cover for like the hyper guys of like grouping things together.</p>
<p>259<br>00:29:04,000 –&gt; 00:29:14,000<br>Hypergraphs and like just costing those things separately from other pieces where this is looks at everything all at once.</p>
<p>260<br>00:29:14,000 –&gt; 00:29:15,000<br>Yeah I mean I can.</p>
<p>261<br>00:29:15,000 –&gt; 00:29:18,000<br>It’s like 2006 paper it’s in the reading list.</p>
<p>262<br>00:29:18,000 –&gt; 00:29:22,000<br>I just don’t I might mention I don’t have time to cover it but like they show that like they.</p>
<p>263<br>00:29:22,000 –&gt; 00:29:29,000<br>In practice they find the they find the optimal joint algorithm faster than a joint ordering faster than cascades.</p>
<p>264<br>00:29:29,000 –&gt; 00:29:32,000<br>You know Microsoft has put a ton of effort money into it.</p>
<p>265<br>00:29:32,000 –&gt; 00:29:33,000<br>Yes.</p>
<p>266<br>00:29:33,000 –&gt; 00:29:45,000<br>How does the data properties come in come to play in any of this would be like say that.</p>
<p>267<br>00:29:45,000 –&gt; 00:29:48,000<br>Say that I picked here.</p>
<p>268<br>00:29:48,000 –&gt; 00:29:55,000<br>I’m going to emerge joint say not so not a sort of merge or an emerge joint so I assume that my inputs have to be sorted.</p>
<p>269<br>00:29:55,000 –&gt; 00:29:58,000<br>So as I traverse down.</p>
<p>270<br>00:29:58,000 –&gt; 00:30:08,000<br>Then I could say don’t give me anything that that’s not sorted right and then I could record that actually in the in my memo table say okay for.</p>
<p>271<br>00:30:08,000 –&gt; 00:30:15,000<br>The scan on B here’s the lowest cost with with with these set of properties and here’s the lowest cost with this other set of properties.</p>
<p>272<br>00:30:15,000 –&gt; 00:30:23,000<br>So then I can decide okay if I need those properties I can check the memo to see whether that costs whether that operator providing info.</p>
<p>273<br>00:30:23,000 –&gt; 00:30:30,000<br>So the name of the memo table I’m not showing here because the PowerPoint you would keep track of like what properties.</p>
<p>274<br>00:30:30,000 –&gt; 00:30:37,000<br>You know a given multi expression and any any the best expression for it provides and then you can decide whether that’s going to give you what you need or not.</p>
<p>275<br>00:30:37,000 –&gt; 00:30:45,000<br>So what is the most common one you could say like compression.</p>
<p>276<br>00:30:45,000 –&gt; 00:30:57,000<br>I’m not showing like we’re not showing projections obviously here but like I need these columns stuff like that and then that can change based on what it’s like a column store or a row store.</p>
<p>277<br>00:30:57,000 –&gt; 00:31:04,000<br>Because row store could always shove it up at a common store if it’s like disaggregated across different nodes it becomes more complicated.</p>
<p>278<br>00:31:04,000 –&gt; 00:31:13,000<br>So you have to store every single set of like some set of properties for every single combination of tables.</p>
<p>279<br>00:31:13,000 –&gt; 00:31:19,000<br>Questions would you have to sort of every so if you just think you’re like sorting this out is what it is right.</p>
<p>280<br>00:31:19,000 –&gt; 00:31:22,000<br>Is this one or zero but you have like five.</p>
<p>281<br>00:31:22,000 –&gt; 00:31:25,000<br>No no no no like be sorting me like sort of on what column.</p>
<p>282<br>00:31:25,000 –&gt; 00:31:27,000<br>Oh yeah like that is called.</p>
<p>283<br>00:31:27,000 –&gt; 00:31:32,000<br>Yeah so you have to keep track of like I’m accessing this data and it’s coming into me it’s going to be sort of in this column.</p>
<p>284<br>00:31:32,000 –&gt; 00:31:48,000<br>Or I can then do a transformation to say all right well I’m looking at a merge join here therefore I need my data sorted so you would then have a transformation where you could then say okay populate the thing below me to make sure I’m looking at things being sorted or not.</p>
<p>285<br>00:31:48,000 –&gt; 00:31:54,000<br>Or you can pass hints down say okay I at this point here maybe I don’t I don’t want things sorted so don’t don’t consider it.</p>
<p>286<br>00:31:54,000 –&gt; 00:31:58,000<br>So is this memo table generated at the beginning of everything or is it like.</p>
<p>287<br>00:31:58,000 –&gt; 00:32:01,000<br>Sorry.</p>
<p>288<br>00:32:01,000 –&gt; 00:32:08,000<br>Other let’s say maybe combinations of tables that we may want to exclude from the memo table at the very beginning.</p>
<p>289<br>00:32:08,000 –&gt; 00:32:13,000<br>The question is are there combinations of tables we may want to exclude from the memo table at the beginning.</p>
<p>290<br>00:32:13,000 –&gt; 00:32:19,000<br>Like for example like if I want to sort on like if I have a table with like five columns I really want to sort of one column.</p>
<p>291<br>00:32:19,000 –&gt; 00:32:30,000<br>Yeah so Microsoft does a Microsoft will pre populate the memo table in this first stage and then sort of see it with things that it knows it should probably consider first.</p>
<p>292<br>00:32:30,000 –&gt; 00:32:35,000<br>And in that way when you do this search you you may prefer things that I already know about.</p>
<p>293<br>00:32:35,000 –&gt; 00:32:37,000<br>Yeah.</p>
<p>294<br>00:32:37,000 –&gt; 00:32:38,000<br>Yes.</p>
<p>295<br>00:32:38,000 –&gt; 00:32:49,000<br>Can I say that we need to do bottom up what you adaptivity I know we’re not there only next week’s topic but like if you want to adaptivity you definitely do bottom up.</p>
<p>296<br>00:32:49,000 –&gt; 00:32:53,000<br>The question is if you want to do that activity you have to do bottles up.</p>
<p>297<br>00:32:53,000 –&gt; 00:32:57,000<br>Adaptivity when like while the query is running.</p>
<p>298<br>00:32:57,000 –&gt; 00:32:58,000<br>Yeah.</p>
<p>299<br>00:32:58,000 –&gt; 00:33:00,000<br>Why why would you have to do it.</p>
<p>300<br>00:33:00,000 –&gt; 00:33:06,000<br>Because if you’re bottoms up you start with like a sequential scan and then you can.</p>
<p>301<br>00:33:06,000 –&gt; 00:33:11,000<br>Or like you want to switch to an index and that’s your adaptivity right.</p>
<p>302<br>00:33:11,000 –&gt; 00:33:21,000<br>It’s doing the bottom up when it be like a more easy control what’s happening as opposed to having to go explore on the way from the top.</p>
<p>303<br>00:33:21,000 –&gt; 00:33:28,000<br>His statement is if you want to be adaptive we’ll be easier to do bottoms up versus tops down.</p>
<p>304<br>00:33:28,000 –&gt; 00:33:31,000<br>Is your point like that we’re overriding.</p>
<p>305<br>00:33:31,000 –&gt; 00:33:32,000<br>Yeah.</p>
<p>306<br>00:33:32,000 –&gt; 00:33:37,000<br>So for example we can like at some point we say all like maybe an attempt to do it but.</p>
<p>307<br>00:33:37,000 –&gt; 00:33:40,000<br>Let’s punk this next week to see how they do it.</p>
<p>308<br>00:33:40,000 –&gt; 00:33:47,000<br>The just the way you do at one purchase will see if we’re to do adapt the query execution is you just inject a new physical operator.</p>
<p>309<br>00:33:47,000 –&gt; 00:33:49,000<br>Oh see that’s bad.</p>
<p>310<br>00:33:49,000 –&gt; 00:33:50,000<br>We probably wouldn’t do that.</p>
<p>311<br>00:33:50,000 –&gt; 00:33:51,000<br>Why why’s that bad.</p>
<p>312<br>00:33:51,000 –&gt; 00:33:56,000<br>Because if you’re just if you’re continuously adding more cost.</p>
<p>313<br>00:33:56,000 –&gt; 00:33:59,000<br>If you’re injecting another operator in the middle of the.</p>
<p>314<br>00:33:59,000 –&gt; 00:34:03,000<br>Yes you’re adding cost to what goes above.</p>
<p>315<br>00:34:03,000 –&gt; 00:34:06,000<br>To the total.</p>
<p>316<br>00:34:06,000 –&gt; 00:34:11,000<br>You know the physical operator is like a.</p>
<p>317<br>00:34:11,000 –&gt; 00:34:13,000<br>I don’t I don’t I don’t want to use the word sentinel.</p>
<p>318<br>00:34:13,000 –&gt; 00:34:20,000<br>It’s basically a gate that checks if the data coming out what I expected to look like.</p>
<p>319<br>00:34:20,000 –&gt; 00:34:23,000<br>And then if not you then make a decision.</p>
<p>320<br>00:34:23,000 –&gt; 00:34:31,000<br>It’s like a trigger in the query plan has no like has no substantial cost to the query plan because.</p>
<p>321<br>00:34:31,000 –&gt; 00:34:36,000<br>Is there is like is my selectivity what I think it’s going to be what what I thought it was.</p>
<p>322<br>00:34:36,000 –&gt; 00:34:40,000<br>Yeah that’s next class that’s Monday.</p>
<p>323<br>00:34:40,000 –&gt; 00:34:48,000<br>Yes he’s jumping ahead but to your point like it depends on the invitation like you could.</p>
<p>324<br>00:34:48,000 –&gt; 00:34:54,000<br>Like whether or not you inject the activity pieces why you’re doing this like generating the query plan.</p>
<p>325<br>00:34:54,000 –&gt; 00:35:00,000<br>Or like you just say I got my physical plan you embed now in the operators your cost estimates.</p>
<p>326<br>00:35:00,000 –&gt; 00:35:05,000<br>You know cardinal estimates and then you say okay well here’s you know here’s my leaf note scan.</p>
<p>327<br>00:35:05,000 –&gt; 00:35:08,000<br>I’ll now inject that that trigger check.</p>
<p>328<br>00:35:08,000 –&gt; 00:35:13,000<br>Right above it and if I see that the data is coming out doesn’t match what was in my scam below me.</p>
<p>329<br>00:35:13,000 –&gt; 00:35:16,000<br>Then I’ll do something else but you don’t need to do that potentially for the cost based search.</p>
<p>330<br>00:35:16,000 –&gt; 00:35:20,000<br>You can imagine a scenario we say.</p>
<p>331<br>00:35:20,000 –&gt; 00:35:25,000<br>You could include in your cost estimates to say.</p>
<p>332<br>00:35:25,000 –&gt; 00:35:30,000<br>This is going to be more expensive to do but I’ll add this trigger check to make sure that like I don’t.</p>
<p>333<br>00:35:30,000 –&gt; 00:35:34,000<br>This could be really expensive to be this could be really expensive to do.</p>
<p>334<br>00:35:34,000 –&gt; 00:35:37,000<br>If I.</p>
<p>335<br>00:35:37,000 –&gt; 00:35:42,000<br>If I get it wrong so me at my trigger check to make sure I then I don’t get it wrong.</p>
<p>336<br>00:35:42,000 –&gt; 00:35:46,000<br>And then choose the thing that’s more expensive so you can like do play games like that.</p>
<p>337<br>00:35:46,000 –&gt; 00:35:49,000<br>Let’s let’s punish that so next week.</p>
<p>338<br>00:35:49,000 –&gt; 00:35:56,000<br>Most of the systems that do at activity will be simple push downs of certain operations.</p>
<p>339<br>00:35:56,000 –&gt; 00:36:03,000<br>So snow that snowflake will push down an aggregation to remote node above you know above a join or something like that.</p>
<p>340<br>00:36:03,000 –&gt; 00:36:08,000<br>If it’s see certain things other other triggers be like all right this is waiting this query plans just terrible.</p>
<p>341<br>00:36:08,000 –&gt; 00:36:15,000<br>Stop throw everything away and go back to the organizer and then the other one’s going to be more clever about like switching plans on the fly.</p>
<p>342<br>00:36:15,000 –&gt; 00:36:21,000<br>But nobody does that in practice as far as I know they’ll do like simple movements now.</p>
<p>343<br>00:36:21,000 –&gt; 00:36:25,000<br>Okay the question.</p>
<p>344<br>00:36:25,000 –&gt; 00:36:31,000<br>So there’s a bunch of implementations of cascades again cascades is the name of the paper.</p>
<p>345<br>00:36:31,000 –&gt; 00:36:37,000<br>As far as I know there was no implementation of it like volcano there as far as I know there was a system and code based called volcano that we were using.</p>
<p>346<br>00:36:37,000 –&gt; 00:36:44,000<br>The actual implementations that were out there in the early 90s was this thing called up plus plus out of Wisconsin.</p>
<p>347<br>00:36:44,000 –&gt; 00:36:51,000<br>I think jignesh’s office mate worked on this when he was Wisconsin because he did his piece you there.</p>
<p>348<br>00:36:51,000 –&gt; 00:36:57,000<br>And then Portland State was getting with the Columbia product Columbia system again that was.</p>
<p>349<br>00:36:57,000 –&gt; 00:37:08,000<br>Gerst graph was involved with that Gerst graph is peachy visor is also jignesh’s peachy visor like this guy David where you’ve been in a lot early parallel should be the basis of stuff.</p>
<p>350<br>00:37:08,000 –&gt; 00:37:17,000<br>Green plum built this thing called orco which we’ll cover in a second that actually you know that’s sort of like calcite where it’s like a standalone server optimizer as a service similar or trying to do for optee.</p>
<p>351<br>00:37:17,000 –&gt; 00:37:21,000<br>And then here’s a bunch of the other ones that better implemented in actual full systems.</p>
<p>352<br>00:37:21,000 –&gt; 00:37:25,000<br>So let’s come back to calcades.</p>
<p>353<br>00:37:25,000 –&gt; 00:37:35,000<br>Other and let’s go actually hold on let me do more cascades before we go to randomize algorithms.</p>
<p>354<br>00:37:35,000 –&gt; 00:37:40,000<br>So the Cascades papers like 94.</p>
<p>355<br>00:37:40,000 –&gt; 00:37:46,000<br>Microsoft Hires. Gerst graph is starting building this in seagull server in like 95.</p>
<p>356<br>00:37:46,000 –&gt; 00:38:08,000<br>The there is a single code base or there is a there was a single code base for the cascades optimizer but my understanding from talking Microsoft is like they forked it many many times and basically all the major database products that Microsoft sells on prime in the cloud like what are synapses will cover later.</p>
<p>357<br>00:38:08,000 –&gt; 00:38:16,000<br>Cosmos DB they’re all using scope in the learn they’re all using some derivation of the of the original cascades optimizer.</p>
<p>358<br>00:38:16,000 –&gt; 00:38:29,000<br>Everything’s written in C++ there’s no DSL and then the to do transformations of the where calls expressions all that is just doing if and else calls and not not rules running in the search engine.</p>
<p>359<br>00:38:29,000 –&gt; 00:38:44,000<br>So as we said before the what cast what their cascades going to do is that they’re going to have separate stages that are going to find here’s the rules I actually want to consider at each stage and the idea is that you start the ones that you know you always want to run.</p>
<p>360<br>00:38:44,000 –&gt; 00:38:52,000<br>You always want to run predicate push down you maybe always want to run that like one equals to converge to false and things like that.</p>
<p>361<br>00:38:52,000 –&gt; 00:39:11,000<br>And then so you always do these these these transformations at the very beginning and then at some point you get to this point where I want to the cost based search and that you can you can tweak and specify here’s the priority for some of these transformations based on what I saw in the earlier stages that I evaluated.</p>
<p>362<br>00:39:11,000 –&gt; 00:39:22,000<br>So in the very very beginning you just do basic simplification and normalization so this will be doing logical treat a logical treat transformations so the sub query stuff will talk about a second they had their own rules to do that.</p>
<p>363<br>00:39:22,000 –&gt; 00:39:30,000<br>Outer joins the inner joins predicate push down and then empty result pretty like you know select star from table where where false you can throw those things out.</p>
<p>364<br>00:39:31,000 –&gt; 00:39:47,000<br>Then you get to what they call pre exploration and this is doing not the actual cost based search but this is applying rules to populate the memo table with things you know you think you want to you want to we want to look at as you go down.</p>
<p>365<br>00:39:48,000 –&gt; 00:39:57,000<br>Right because the idea is you don’t want to blindly search in the beginning you can see the memo table if like here’s the things that are going to be interesting and guide the search towards those.</p>
<p>366<br>00:39:57,000 –&gt; 00:40:08,000<br>So trigger plan shortcut select select one right or select star from table limit zero things like that projection normalization how to identify the stats.</p>
<p>367<br>00:40:08,000 –&gt; 00:40:26,000<br>I said projection normalization again cleaning up what’s in the select output they do an interesting thing where they identify at this point here that they don’t have all the stats they would need to do in their cost model to give good estimates they actually stop the query for the next.</p>
<p>368<br>00:40:27,000 –&gt; 00:40:34,000<br>So when you’re planning go tell the system to go run analyze now collect the data that it’s actually missing.</p>
<p>369<br>00:40:34,000 –&gt; 00:40:45,000<br>Imagine the very beginning of you just bulk load table you need something and then when that that’s available then they can come back and start doing some initial car net estimates and then join collapsing what when possible.</p>
<p>370<br>00:40:45,000 –&gt; 00:40:54,000<br>Then they get to the cost based search and this can still as we multi stage where they’re going to have the sort of the first group of transformations that they’re allowed to consider.</p>
<p>371<br>00:40:54,000 –&gt; 00:41:06,000<br>And then over time is the number of transformations that they’re they’re they’re applied because that’s how they’re keeping track of how long the search is going but then expand the the set of transformations that looking at to do more complicated things.</p>
<p>372<br>00:41:06,000 –&gt; 00:41:15,000<br>So in the very beginning it’s for dealing things like trivial plans like look ups on a single table where there’s primary key index stuff like that.</p>
<p>373<br>00:41:15,000 –&gt; 00:41:29,000<br>And if you still don’t find the optimal plan then you expand that out to a quick estimation on how to go parallel parallel plan again now you maybe looking at you know joining or joining multiple tables it’s more than going looking up single table.</p>
<p>374<br>00:41:29,000 –&gt; 00:41:39,000<br>And then if there’s still more time in the clock as you go along then you can you can open up to do a a a larger search for the full plan.</p>
<p>375<br>00:41:39,000 –&gt; 00:41:49,000<br>And then in the last eight step and then this is still within the cascade optimizer rules for all the different database engines or systems that they’re that they’re trying to run support through cascades.</p>
<p>376<br>00:41:49,000 –&gt; 00:41:53,000<br>They will then have engine specific transformations that they can apply.</p>
<p>377<br>00:41:53,000 –&gt; 00:42:08,000<br>So for example I think for synapses like distributed data warehouse based on SQL server will cover it in the semester like you want to do distributed joins or you know broadcast joins and so forth like all those things get applied separately in this lab.</p>
<p>378<br>00:42:08,000 –&gt; 00:42:23,000<br>So for this cost based search and utilization and the creation phase I’m not completely sure I understand how you would decide how to operate.</p>
<p>379<br>00:42:23,000 –&gt; 00:42:30,000<br>I would use the memory table you probably don’t got your search. How do you really don’t think you can sit based on your analysis of the query.</p>
<p>380<br>00:42:30,000 –&gt; 00:42:41,000<br>So the question is how do you pre populate the member table to see the search ahead of time. So like it would be populate the member table also populating like the groups you sort of generated.</p>
<p>381<br>00:42:41,000 –&gt; 00:42:45,000<br>Right say for this multi-expression on this this.</p>
<p>382<br>00:42:45,000 –&gt; 00:42:52,000<br>You say joining three tables if I know something in these early stages about like I always want to have this be the outer table in the inter table.</p>
<p>383<br>00:42:52,000 –&gt; 00:42:56,000<br>So I’ll see that that that’s transformation ahead of time.</p>
<p>384<br>00:42:56,000 –&gt; 00:43:07,000<br>And then if I had the estimate at this point you know getting past this step here then I could I could put that cost in the memory right away.</p>
<p>385<br>00:43:07,000 –&gt; 00:43:19,000<br>So as I said before the timeouts are always be based on the number of transformations not the walk lock time and then what’s nice about this as they bring up is that.</p>
<p>386<br>00:43:19,000 –&gt; 00:43:32,000<br>No matter what hardware you’re running on you could you could still you could always generate the same poor planning given the same database and then if the system gets overloaded because again in this environment it’s not a.</p>
<p>387<br>00:43:32,000 –&gt; 00:43:40,000<br>You know in traditional sequo server it’s like you know a single system where like the optimizer runs in the same box and the same hardware as you know the execution engine.</p>
<p>388<br>00:43:40,000 –&gt; 00:43:50,000<br>So the system gets overloaded and the time it takes actually optimize the queries and take longer because the threads are burning burning up running queries or doing whatever and so.</p>
<p>389<br>00:43:50,000 –&gt; 00:44:08,000<br>If you based on walk lock if I run the query today and it’s the system that overloaded I run the same query tomorrow I may get a different plan if it’s overloaded if I’m looking at walk lock time because everything was so much slower so this guarantees that no matter what I always see the I always get the best plan for the same plan.</p>
<p>390<br>00:44:08,000 –&gt; 00:44:30,000<br>And then as we said before you would pre-properly the memo table with use useful join orderings again this is just your rules rules to make sure that things land sorry that you you see the search in a way that you find the best the best join earlier and as this is very similar to the Oracle one the order that they appear in the SQL queries the order that you know they’ll get seated into the memo table.</p>
<p>391<br>00:44:31,000 –&gt; 00:44:35,000<br>Which sometimes makes sense which Oracle did for a long time.</p>
<p>392<br>00:44:35,000 –&gt; 00:44:43,000<br>All right, CalSci and Orca I don’t want to talk too much about but this I think everyone here is aware of them right these are separate.</p>
<p>393<br>00:44:43,000 –&gt; 00:44:56,000<br>These are standalone query optimizers as a service CalSci is way more is used way more than orca it’s written in Java so that limits how many people actually want to use this.</p>
<p>394<br>00:44:57,000 –&gt; 00:45:12,000<br>But the it’s CalSci is actually beats because they I think they have their own connectors to be able to run queries and things like that like it’s it’s more than just a query optimizer but mostly either for the SQL parser and and then the query optimizer but you basically have to define.</p>
<p>395<br>00:45:12,000 –&gt; 00:45:24,000<br>It comes with a bunch of existing rules but if you want to then extend it to whatever system you want to support you can then define through their Java code here’s the rules I want to transform things here’s how to do call model estimates and so forth.</p>
<p>396<br>00:45:25,000 –&gt; 00:45:36,000<br>This originally came out of a urm he and system called lucidb this went under and then they I think it was a start up and they took the pieces out of this and that became calSci.</p>
<p>397<br>00:45:37,000 –&gt; 00:45:39,000<br>And it’s used for a lot of systems.</p>
<p>398<br>00:45:40,000 –&gt; 00:46:02,000<br>Green plum is the equipment to calSci but maybe the less it’s less pluggable focus for like with calSci you say you have like here’s my snowflake dialect here’s my post-crest dialect it’s for a bunch of different dialects going in and I think a bunch of different dialects going out for orca is more focus on the pure query optimizations so this is originally written at.</p>
<p>399<br>00:46:03,000 –&gt; 00:46:09,000<br>I keep track of I lose track of who bought what green plum got bought by emc emc got bought by.</p>
<p>400<br>00:46:11,000 –&gt; 00:46:12,000<br>Dell.</p>
<p>401<br>00:46:13,000 –&gt; 00:46:16,000<br>VMware and then VMware then.</p>
<p>402<br>00:46:17,000 –&gt; 00:46:38,000<br>Now here’s the emc green plum got by emc then VMware bought another company called pivotal and so emc had a database products and then VMware had data as products and they didn’t know what to do with them so they merged the two they spun out there’s two divisions of these two companies and then they formed pivotal and then pivotal eventually got bought back by VMware.</p>
<p>403<br>00:46:38,000 –&gt; 00:47:07,000<br>Jignesh was out there for a while because his startup got bought by them anyway so they were supporting green plum which is still yesterday is why we use it’s a fork of post-crest make like distributed and run all that queries and then they had this thing called hawk which there was in the high which is sequel top of a doop then rather building a separate query optimizer for hawk and the query optimizer for green plum they decided let’s build a single optimizer of the service and have support both hawk and replum and whatever system you want to.</p>
<p>404<br>00:47:08,000 –&gt; 00:47:29,000<br>Hawk up to it hawk is still around and nobody actually uses it green plum still around and so that’s the primary user of worker but it’s like cal site where again you have this API you have to implement here’s here’s what my catalog looks like here’s what my logical plans and physical plans look like here’s the rules I want you to support and they you plug all that in and you can use it we looked at this.</p>
<p>405<br>00:47:29,000 –&gt; 00:47:36,000<br>Almost 10 years ago use it and says we were building at the time they had like zero documentation and was just like send a bunch of XML files.</p>
<p>406<br>00:47:37,000 –&gt; 00:47:46,000<br>And it would spit things out we said not nothing pursue it but it’s still it’s actually maintained it but again I don’t think it’s used anywhere outside of green plum cal sites more common.</p>
<p>407<br>00:47:46,000 –&gt; 00:47:54,000<br>So there’s a paper that they wrote on orca and they tell about a couple interesting things that are relevant to some of the questions you’ve had.</p>
<p>408<br>00:47:55,000 –&gt; 00:48:05,000<br>This is less of an issue if you’re running you’re not running less of an issue if you’re running on the cloud because you control the machine you control everything you can see everything but at the time for on prem this was this was tricky.</p>
<p>409<br>00:48:05,000 –&gt; 00:48:15,000<br>So if someone’s running your software on the on their hardware if your optimizer crashes produces a bad query plan how do you actually try to debug that improve things.</p>
<p>410<br>00:48:16,000 –&gt; 00:48:28,000<br>So someone sends a support ticket to hey my query went slow you know you don’t have it you can give it the secret query but if you don’t have the right environment if you don’t have the right data and you don’t know what choices the optimizer made when it was doing the search it’s hard to debug this.</p>
<p>411<br>00:48:28,000 –&gt; 00:48:51,000<br>So they had the ability to have the optimizer spit out a complete state of its search for a given query and then send that back to the home base for the developers to then almost like walk through exactly here’s all the decisions that the optimizer made to win a generate the query plan they can use that to figure out why it made certain choices over another.</p>
<p>412<br>00:48:51,000 –&gt; 00:48:58,000<br>Again if you’re running in the cloud you control everything you can figure things out you don’t have to do this.</p>
<p>413<br>00:48:58,000 –&gt; 00:49:20,000<br>But another interesting thing to do is make sure that the cost model estimates are accurate they would do this thing where they would run a take a SQL query run it through the optimizer and they would keep track of the best plan and the second best plan or the top 10 best plans and they would and then in the background they would run all of them and then see that the relative ordering of what the</p>
<p>414<br>00:49:20,000 –&gt; 00:49:28,000<br>aros model thought was the best plans actually matches up with reality when you actually run the queries and they would use that to then to tweak things and improve things yes.</p>
<p>415<br>00:49:28,000 –&gt; 00:49:30,000<br>The one would be be pretty.</p>
<p>416<br>00:49:30,000 –&gt; 00:49:47,000<br>Yes but for like but Mongo didn’t have like had his is MongoDB doesn’t have a cut didn’t have a cost model it literally just like here they are run on and then whatever to come back right this is trying to see whether your cost model is predicting the right you know physical cost.</p>
<p>417<br>00:49:47,000 –&gt; 00:49:50,000<br>They adjusted it just it is off.</p>
<p>418<br>00:49:50,000 –&gt; 00:50:05,000<br>So yes at a high level it’s the same as Mongo but Mongo is not trying to verify whether the cost model estimates are correct just they’re just running it again I actually go check this is still what Mongo does today.</p>
<p>419<br>00:50:05,000 –&gt; 00:50:06,000<br>I’ll just you’ll find out.</p>
<p>420<br>00:50:06,000 –&gt; 00:50:10,000<br>It looks like they might be trying to do with some of the actual cost models.</p>
<p>421<br>00:50:10,000 –&gt; 00:50:11,000<br>Okay.</p>
<p>422<br>00:50:11,000 –&gt; 00:50:21,000<br>When I talk to them before pandemic they didn’t have like a they didn’t have like any logical physical operators which is like here’s like J’s on stuff.</p>
<p>423<br>00:50:21,000 –&gt; 00:50:29,000<br>Copper GP rewrote or wrote from scratch their query optimizer there’s like a renelce they started with something that was based on your</p>
<p>424<br>00:50:29,000 –&gt; 00:50:32,000<br>code and then they wrote one that based on cascades.</p>
<p>425<br>00:50:32,000 –&gt; 00:50:51,000<br>Everything’s written and go and they the more pure to the cascades model then they may be Microsoft was because they would have a DSL that the specified here’s the rules and then and the transformations and in some cases where you can’t do the transformation entirely through their DSL.</p>
<p>426<br>00:50:51,000 –&gt; 00:51:11,000<br>You could escape into go code so here’s basically what they’re what their rules sort of look like right so you have like the matching that you want the DSL and then other things you may want to apply and then this then gets transpiled into go that they’ve been run into the system.</p>
<p>427<br>00:51:11,000 –&gt; 00:51:20,000<br>Let me run rush through randomized really quick because again this exists postgres does this.</p>
<p>428<br>00:51:20,000 –&gt; 00:51:26,000<br>So rather than doing top down or bottom up what do you just if you just did a random walk.</p>
<p>429<br>00:51:26,000 –&gt; 00:51:37,000<br>So you got to start with some some query plan and that one you you just you’re straight conversion of a of the AST from a logical plan into physical plan and just from you that.</p>
<p>430<br>00:51:37,000 –&gt; 00:51:52,000<br>The idea is that you look at a bunch of different possible query plans pick whatever has the best cost keep track of that throw away the ones that are the lowest cost do some kind of randomization or</p>
<p>431<br>00:51:52,000 –&gt; 00:51:57,000<br>permutation on it to then change things and then do another round check over again.</p>
<p>432<br>00:51:57,000 –&gt; 00:52:02,000<br>So you’re just randomly walking to try to see whether you stumble upon the best query plan.</p>
<p>433<br>00:52:02,000 –&gt; 00:52:13,000<br>So the there’s an early paper in 1987 that does this was simulated kneeling again the ideas that you you just swapping operators and like you know the join ordering of two tables randomly.</p>
<p>434<br>00:52:13,000 –&gt; 00:52:23,000<br>If the plan makes it worse then you flip it back flip away to coin and see whether you should keep your sitting that that down that path otherwise you flip it back.</p>
<p>435<br>00:52:23,000 –&gt; 00:52:30,000<br>Now there’s a bunch of rules you got to write to make sure that you don’t do things like if it’s a left out or join where you have to care about one being joined for the other.</p>
<p>436<br>00:52:30,000 –&gt; 00:52:44,000<br>You don’t you know you don’t put things in the wrong order so you have to check to see whether you’re the random change is actually still a correct plan but then if it doesn’t get violated then you can flip things around right nobody does this.</p>
<p>437<br>00:52:44,000 –&gt; 00:52:51,000<br>What people what post does do is use a genetic algorithm I think this was introduced in the mid 2000s.</p>
<p>438<br>00:52:51,000 –&gt; 00:52:58,000<br>So they’re going to use a genetic algorithm where they’re going to have these different generations of different query plans and you pick which one is the best.</p>
<p>439<br>00:52:58,000 –&gt; 00:53:11,000<br>Throw away the ones that are worse then permute the best ones to try to sort of trying to find the traits or the genes of the query plans that make it a good query plan and then hope that you sort of stumble upon the best one.</p>
<p>440<br>00:53:11,000 –&gt; 00:53:19,000<br>So post does this but you only get it when you have you give it a query that has more than 12 tables you try to join in a single query.</p>
<p>441<br>00:53:19,000 –&gt; 00:53:26,000<br>There’s a flag you specify what that cutoff is but by default you don’t get this unless it’s a 13 way joiner higher.</p>
<p>442<br>00:53:26,000 –&gt; 00:53:36,000<br>So let’s take that say we get some random query we have a bunch of random combinations of join orders and and and join algorithms you pick first you cost all them.</p>
<p>443<br>00:53:36,000 –&gt; 00:53:45,000<br>Keep track of the one with the lowest cost up in the corner. It’s the best one I’ve ever seen throw away throw away the one that has the worst cost.</p>
<p>444<br>00:53:45,000 –&gt; 00:53:53,000<br>And then permute some you know some portion of the query plans of the ones you keep around and then the next generation you you populate those.</p>
<p>445<br>00:53:53,000 –&gt; 00:54:02,000<br>Do the same thing check which one has the lowest cost this one does so that’s not near our best cost throw away one throw away the the weakest one right the weakest of this generation.</p>
<p>446<br>00:54:02,000 –&gt; 00:54:06,000<br>Permute them and then and so forth right yes.</p>
<p>447<br>00:54:06,000 –&gt; 00:54:10,000<br>These are the best made of costs why would you realize?</p>
<p>448<br>00:54:10,000 –&gt; 00:54:24,000<br>I don’t like to like take these random queries and then find each random one and then like this is like this is all within the query optimizer only like only Mongo does that like runs everyone like this is like using the cost on as a special talk right next week yes.</p>
<p>449<br>00:54:24,000 –&gt; 00:54:28,000<br>So in this case.</p>
<p>450<br>00:54:28,000 –&gt; 00:54:31,000<br>How does it come with the first generation.</p>
<p>451<br>00:54:31,000 –&gt; 00:54:36,000<br>Yeah.</p>
<p>452<br>00:54:36,000 –&gt; 00:54:38,000<br>Yes.</p>
<p>453<br>00:54:38,000 –&gt; 00:54:41,000<br>Right so I know I had to join our RST.</p>
<p>454<br>00:54:41,000 –&gt; 00:54:45,000<br>So we did different different join owners different physical operators.</p>
<p>455<br>00:54:45,000 –&gt; 00:54:51,000<br>And then this one and just try it out.</p>
<p>456<br>00:54:51,000 –&gt; 00:54:58,000<br>So I know in the case of postgres like they make sure that the the random permutations is terministic because you don’t want to be.</p>
<p>457<br>00:54:58,000 –&gt; 00:55:05,000<br>If you throw the same query at it again you want to end up and you’re using running this you would end up with the same permutation right.</p>
<p>458<br>00:55:05,000 –&gt; 00:55:07,000<br>Yes.</p>
<p>459<br>00:55:07,000 –&gt; 00:55:10,000<br>It seems like a good idea.</p>
<p>460<br>00:55:10,000 –&gt; 00:55:12,000<br>Why is it not used?</p>
<p>461<br>00:55:12,000 –&gt; 00:55:17,000<br>It’s a good idea because if you have 13 join like that’s a lot of them.</p>
<p>462<br>00:55:17,000 –&gt; 00:55:27,000<br>So going from an random algorithm you know approaching it from a almost exhausted free top down the water bottom of one is just too slow.</p>
<p>463<br>00:55:27,000 –&gt; 00:55:34,000<br>And you’re unlikely to get the right joint for every single one of them.</p>
<p>464<br>00:55:34,000 –&gt; 00:55:37,000<br>So if you go from a random algorithm.</p>
<p>465<br>00:55:37,000 –&gt; 00:55:40,000<br>Is that not too much.</p>
<p>466<br>00:55:40,000 –&gt; 00:55:45,000<br>From from the first situation it seems like this should work right.</p>
<p>467<br>00:55:45,000 –&gt; 00:55:49,000<br>There’s an engineering cost to making sure that you don’t permit things incorrectly right.</p>
<p>468<br>00:55:49,000 –&gt; 00:55:51,000<br>So now you’re maintaining code to do that.</p>
<p>469<br>00:55:51,000 –&gt; 00:55:54,000<br>And that’s again that’s pretty much it that else rules.</p>
<p>470<br>00:55:54,000 –&gt; 00:55:57,000<br>For very very large tables.</p>
<p>471<br>00:55:57,000 –&gt; 00:55:59,000<br>Large number of tables.</p>
<p>472<br>00:55:59,000 –&gt; 00:56:01,000<br>You know the.</p>
<p>473<br>00:56:01,000 –&gt; 00:56:04,000<br>A greedy search pilot would be better.</p>
<p>474<br>00:56:04,000 –&gt; 00:56:07,000<br>Again think of like joining 30 tables 40 tables.</p>
<p>475<br>00:56:07,000 –&gt; 00:56:08,000<br>Yeah.</p>
<p>476<br>00:56:08,000 –&gt; 00:56:09,000<br>Yeah.</p>
<p>477<br>00:56:09,000 –&gt; 00:56:15,000<br>Because you use the software and there’s so many cost.</p>
<p>478<br>00:56:15,000 –&gt; 00:56:17,000<br>So.</p>
<p>479<br>00:56:17,000 –&gt; 00:56:18,000<br>Yeah.</p>
<p>480<br>00:56:18,000 –&gt; 00:56:23,000<br>So this is the talk from from the guy that actually works on this and the query happenizer from postgres a few years ago.</p>
<p>481<br>00:56:23,000 –&gt; 00:56:26,000<br>And he basically said that the one in postgres least is broken.</p>
<p>482<br>00:56:26,000 –&gt; 00:56:31,000<br>It’s not truly randomized as much as it should be or they’re not I don’t think they’re.</p>
<p>483<br>00:56:31,000 –&gt; 00:56:36,000<br>They’re not like incorporating the traits that are that are best from one drainage in the next.</p>
<p>484<br>00:56:36,000 –&gt; 00:56:39,000<br>I think that.</p>
<p>485<br>00:56:39,000 –&gt; 00:56:43,000<br>I don’t say it’s a hack but I think that the.</p>
<p>486<br>00:56:43,000 –&gt; 00:56:45,000<br>We don’t have time to cover the hard one.</p>
<p>487<br>00:56:45,000 –&gt; 00:56:47,000<br>The hyper one is the better way to do this if you.</p>
<p>488<br>00:56:47,000 –&gt; 00:56:51,000<br>They’re they have basically an adaptive algorithm that can figure out like.</p>
<p>489<br>00:56:51,000 –&gt; 00:56:56,000<br>If above a certain number joins it’s a good isn’t your greedy based searches back to better.</p>
<p>490<br>00:56:56,000 –&gt; 00:56:59,000<br>We cover this in the reading group we can cover it again.</p>
<p>491<br>00:56:59,000 –&gt; 00:57:01,000<br>I’ll come up all mentioned that next class.</p>
<p>492<br>00:57:01,000 –&gt; 00:57:04,000<br>I just have slides work.</p>
<p>493<br>00:57:04,000 –&gt; 00:57:06,000<br>So again nobody actually does this.</p>
<p>494<br>00:57:06,000 –&gt; 00:57:08,000<br>I would 20 minutes ago.</p>
<p>495<br>00:57:08,000 –&gt; 00:57:12,000<br>Any questions before we switch over to the paper reading.</p>
<p>496<br>00:57:12,000 –&gt; 00:57:13,000<br>Yes.</p>
<p>497<br>00:57:13,000 –&gt; 00:57:23,000<br>So you have a logical plan.</p>
<p>498<br>00:57:23,000 –&gt; 00:57:28,000<br>And then you can you can you can just use the order in the tables they appear in the SQL query.</p>
<p>499<br>00:57:28,000 –&gt; 00:57:30,000<br>That’s the order that’s the initial ordering.</p>
<p>500<br>00:57:30,000 –&gt; 00:57:33,000<br>And then you just flipping things around.</p>
<p>501<br>00:57:33,000 –&gt; 00:57:36,000<br>So it’s not true.</p>
<p>502<br>00:57:36,000 –&gt; 00:57:39,000<br>You have a different equipment logical plan.</p>
<p>503<br>00:57:39,000 –&gt; 00:57:40,000<br>You.</p>
<p>504<br>00:57:40,000 –&gt; 00:57:41,000<br>You.</p>
<p>505<br>00:57:41,000 –&gt; 00:57:42,000<br>Stay.</p>
<p>506<br>00:57:42,000 –&gt; 00:57:44,000<br>It is like the logical plan has some structure.</p>
<p>507<br>00:57:44,000 –&gt; 00:57:45,000<br>Yes.</p>
<p>508<br>00:57:45,000 –&gt; 00:57:49,000<br>And again depending on what if it’s if it’s an interjoined those things are commuted.</p>
<p>509<br>00:57:49,000 –&gt; 00:57:50,000<br>You can swap them anywhere.</p>
<p>510<br>00:57:50,000 –&gt; 00:57:53,000<br>But like if it’s an outer join or one of these core.</p>
<p>511<br>00:57:53,000 –&gt; 00:57:54,000<br>You can swap them anywhere.</p>
<p>512<br>00:57:54,000 –&gt; 00:57:56,000<br>You can swap them anywhere.</p>
<p>513<br>00:57:56,000 –&gt; 00:57:58,000<br>So if it’s an outer join or one of these core.</p>
<p>514<br>00:57:58,000 –&gt; 00:58:01,000<br>It’s like that you have to be careful about it.</p>
<p>515<br>00:58:01,000 –&gt; 00:58:04,000<br>So you’re going to make sure you don’t violate that.</p>
<p>516<br>00:58:04,000 –&gt; 00:58:12,000<br>But like if it’s if things are commutative then you can take you know the logical plan is to join you know join our drawn S.</p>
<p>517<br>00:58:12,000 –&gt; 00:58:19,000<br>You’re like you’ll have that tree structure and you just commute that.</p>
<p>518<br>00:58:19,000 –&gt; 00:58:21,000<br>The rate of war.</p>
<p>519<br>00:58:21,000 –&gt; 00:58:24,000<br>You’re like one you treat in one thing to.</p>
<p>520<br>00:58:24,000 –&gt; 00:58:29,000<br>No the very beginning it it is like you have to generate this this first generation.</p>
<p>521<br>00:58:29,000 –&gt; 00:58:30,000<br>Right.</p>
<p>522<br>00:58:30,000 –&gt; 00:58:35,000<br>But like once you like to look like the root and then all these changes like one change.</p>
<p>523<br>00:58:35,000 –&gt; 00:58:40,000<br>So what do you mean all the like all these changes are like just changing one part of the tree.</p>
<p>524<br>00:58:40,000 –&gt; 00:58:41,000<br>Yeah.</p>
<p>525<br>00:58:41,000 –&gt; 00:58:42,000<br>You’re changing the entire thing.</p>
<p>526<br>00:58:42,000 –&gt; 00:58:43,000<br>Correct.</p>
<p>527<br>00:58:43,000 –&gt; 00:58:44,000<br>Yes.</p>
<p>528<br>00:58:44,000 –&gt; 00:58:45,000<br>Because the idea is that like.</p>
<p>529<br>00:58:45,000 –&gt; 00:58:48,000<br>Like in this case here I somehow figured out the B.</p>
<p>530<br>00:58:48,000 –&gt; 00:58:51,000<br>This hash join on on the hash join with S.</p>
<p>531<br>00:58:51,000 –&gt; 00:58:55,000<br>Followed by R or you know S as the outer R is the inner.</p>
<p>532<br>00:58:55,000 –&gt; 00:58:58,000<br>You don’t know whether that’s the why this you know made this one the best.</p>
<p>533<br>00:58:58,000 –&gt; 00:59:02,000<br>So you want to carry that over to the next one.</p>
<p>534<br>00:59:02,000 –&gt; 00:59:06,000<br>In this case up here so that like and then you permit maybe other things about it.</p>
<p>535<br>00:59:06,000 –&gt; 00:59:14,000<br>So that if it truly is the reason why your costs are lower then that trade will get carried over over time.</p>
<p>536<br>00:59:14,000 –&gt; 00:59:19,000<br>Okay.</p>
<p>537<br>00:59:19,000 –&gt; 00:59:27,000<br>So let’s see how far we can get through.</p>
<p>538<br>00:59:27,000 –&gt; 00:59:28,000<br>Subquires.</p>
<p>539<br>00:59:28,000 –&gt; 00:59:29,000<br>Okay.</p>
<p>540<br>00:59:29,000 –&gt; 00:59:31,000<br>Again this means surprise anyone.</p>
<p>541<br>00:59:31,000 –&gt; 00:59:33,000<br>Subquires are important in SQL.</p>
<p>542<br>00:59:33,000 –&gt; 00:59:37,000<br>It’s wild you can put them anywhere in your SQL query.</p>
<p>543<br>00:59:37,000 –&gt; 00:59:42,000<br>I was unable to I tried to last time I wasn’t able to get it into a necessary into my order by clause.</p>
<p>544<br>00:59:42,000 –&gt; 00:59:43,000<br>No.</p>
<p>545<br>00:59:43,000 –&gt; 00:59:46,000<br>Post guess what that you put in the order by clause but I don’t think it actually does anything.</p>
<p>546<br>00:59:46,000 –&gt; 00:59:51,000<br>I was trying to like have return a string that the name of the table why I want to look up.</p>
<p>547<br>00:59:51,000 –&gt; 00:59:55,000<br>And it runs it but I think it just getting converted to true.</p>
<p>548<br>00:59:55,000 –&gt; 00:59:58,000<br>So you can do you can put a order by clause in the select statement.</p>
<p>549<br>00:59:58,000 –&gt; 01:00:01,000<br>Or sorry in the order by you can put a select statement inside the order by clause.</p>
<p>550<br>01:00:01,000 –&gt; 01:00:03,000<br>In some cases but I don’t think it actually works.</p>
<p>551<br>01:00:03,000 –&gt; 01:00:04,000<br>Right.</p>
<p>552<br>01:00:04,000 –&gt; 01:00:08,000<br>And the way to think of a nested query or subquery is that it’s basically like a function that like.</p>
<p>553<br>01:00:08,000 –&gt; 01:00:13,000<br>I had some outer query I’m going to vote into it and maybe pass in some information or not.</p>
<p>554<br>01:00:13,000 –&gt; 01:00:16,000<br>About what the outer query is the two I’m looking at in the outer query.</p>
<p>555<br>01:00:16,000 –&gt; 01:00:21,000<br>And then I’m going to produce some some some result that I can then use for.</p>
<p>556<br>01:00:21,000 –&gt; 01:00:22,000<br>For my other query.</p>
<p>557<br>01:00:22,000 –&gt; 01:00:28,000<br>And this is important because this allows people to write more expensive things in a single SQL query rather than have.</p>
<p>558<br>01:00:28,000 –&gt; 01:00:31,000<br>To run multiple queries, staging and temp tables or whatever.</p>
<p>559<br>01:00:31,000 –&gt; 01:00:36,000<br>And then put you know put it all together at the end.</p>
<p>560<br>01:00:36,000 –&gt; 01:00:40,000<br>So there’s this key distinction that’s going to matter a lot between uncorrelated and correlated subqueries.</p>
<p>561<br>01:00:40,000 –&gt; 01:00:43,000<br>And the TLDR is that uncorrelated ones are easy.</p>
<p>562<br>01:00:43,000 –&gt; 01:00:45,000<br>Most data systems will handle those.</p>
<p>563<br>01:00:45,000 –&gt; 01:00:49,000<br>It’s the correlated ones that are going to cause problems.</p>
<p>564<br>01:00:49,000 –&gt; 01:00:55,000<br>The uncorrelated ones basically means that the whatever my subquery is doesn’t depend on anything on the outer query.</p>
<p>565<br>01:00:55,000 –&gt; 01:01:01,000<br>You know I’m not using any information any attributes any tuple data from the outer query to run that inner query.</p>
<p>566<br>01:01:01,000 –&gt; 01:01:06,000<br>So I only need to logically execute this inner query once.</p>
<p>567<br>01:01:06,000 –&gt; 01:01:09,000<br>Whether or not the data system is smart enough to do that depends on the implementation.</p>
<p>568<br>01:01:09,000 –&gt; 01:01:13,000<br>But the ones we can we’ll look at we can talk about.</p>
<p>569<br>01:01:13,000 –&gt; 01:01:14,000<br>We’ll handle this.</p>
<p>570<br>01:01:14,000 –&gt; 01:01:26,000<br>So in this example here I want to get the all the students that have the or get finding the student the name of the student that has the highest grade in some class or across all students.</p>
<p>571<br>01:01:26,000 –&gt; 01:01:34,000<br>So this inner query on the select max score and students doesn’t rely on anything from the outer outer query on students.</p>
<p>572<br>01:01:34,000 –&gt; 01:01:43,000<br>So I can run this once materialize result and be able to substitute that in for every tuple I’m looking at from the outer query.</p>
<p>573<br>01:01:43,000 –&gt; 01:01:50,000<br>Again I think for no systems that they should be able to handle all all cases for this.</p>
<p>574<br>01:01:50,000 –&gt; 01:01:51,000<br>Actually that’s not true.</p>
<p>575<br>01:01:51,000 –&gt; 01:01:57,000<br>There are some cases where they can’t they can’t hit on the core of the separate the basic idea which you’re trying to do is basically come.</p>
<p>576<br>01:01:57,000 –&gt; 01:02:01,000<br>You want to move this up and get this to be a join up above.</p>
<p>577<br>01:02:01,000 –&gt; 01:02:04,000<br>Yes.</p>
<p>578<br>01:02:04,000 –&gt; 01:02:07,000<br>What one?</p>
<p>579<br>01:02:07,000 –&gt; 01:02:12,000<br>Yeah there’s read yeah does not thank you yes.</p>
<p>580<br>01:02:12,000 –&gt; 01:02:22,000<br>So what query is the ones we care about again this is where the inner query that’s the sub query is going to reference something in the outer query here.</p>
<p>581<br>01:02:22,000 –&gt; 01:02:33,000<br>So now if we do modify a query to say give me all the students that have the highest grade in their their major across all the students in the same major.</p>
<p>582<br>01:02:33,000 –&gt; 01:02:41,000<br>Then the basic idea is that for this I’m going to have a for loop that’s going to be the going over every single tuple in my outer query.</p>
<p>583<br>01:02:41,000 –&gt; 01:02:51,000<br>And that for each of those tuples I need to do a complete sequential scan or scan on the on the on the inner table the inner sub queries results.</p>
<p>584<br>01:02:51,000 –&gt; 01:02:59,000<br>Right. So let’s say if I start my outer outer query the first one I will look at is with the the first table which is a major computer science.</p>
<p>585<br>01:02:59,000 –&gt; 01:03:12,000<br>So then now when I invoke the inner query I’m going to scan through and then now do that join where I take the outer queries major match it against the inner queries major and then and then get the max score.</p>
<p>586<br>01:03:12,000 –&gt; 01:03:15,000<br>So I’m going to run this entirely and produce a max score of 90.</p>
<p>587<br>01:03:15,000 –&gt; 01:03:19,000<br>And I’m going to pop it is as my output result here.</p>
<p>588<br>01:03:19,000 –&gt; 01:03:29,000<br>Next for the next one again for risen also comp sign do the same thing start from beginning scan began get max score 90 that doesn’t match what the risk score is.</p>
<p>589<br>01:03:29,000 –&gt; 01:03:38,000<br>Yeah, the risk score so therefore that does not pursue output for ODB he’s the only one major in streets so again start beginning scan through it matches.</p>
<p>590<br>01:03:38,000 –&gt; 01:03:53,000<br>So what I just showed here is like the worst thing you could possibly do because for every single tuple in the in the outer at our table I’m re running that that join query over again for an inner table.</p>
<p>591<br>01:03:53,000 –&gt; 01:03:54,000<br>Yes.</p>
<p>592<br>01:03:54,000 –&gt; 01:04:01,000<br>If it’s going to go out how do you want to wear a call or.</p>
<p>593<br>01:04:01,000 –&gt; 01:04:06,000<br>Yeah, this question is like can you have this inner query in a wear clause it given anywhere.</p>
<p>594<br>01:04:06,000 –&gt; 01:04:10,000<br>Right, I can have it as a from calls I could have it the projection output.</p>
<p>595<br>01:04:10,000 –&gt; 01:04:20,000<br>Correct, yes, I can put like again you can have it in limits you can have it in you can mess queries and limits.</p>
<p>596<br>01:04:20,000 –&gt; 01:04:27,000<br>I don’t think it refers to the outer query I don’t think you can correlate a separate limit causes they having can do it like anywhere.</p>
<p>597<br>01:04:27,000 –&gt; 01:04:35,000<br>You don’t know how to query it on from either side in from how could it be lateral joint.</p>
<p>598<br>01:04:35,000 –&gt; 01:04:39,000<br>Right, it’s basically the same thing.</p>
<p>599<br>01:04:39,000 –&gt; 01:05:01,000<br>So the paper you guys read will get see how they do the goal is begin basically want to lift up this this inner query to be at the same level of the outer query because then we can then convert it into a join and we know how to run those officially know how to optimize those right and we know how to give you what we talked about last class is we know how to pick the right best join order for these things as well.</p>
<p>600<br>01:05:01,000 –&gt; 01:05:19,000<br>So for this query here ideally we want to move the we want to move the inner query to be now be in the join calls and the from calls against the outer query here but now we got to be mindful that yes we need the score of the students.</p>
<p>601<br>01:05:19,000 –&gt; 01:05:32,000<br>That should not be us to give it a bad sorry but now we want to group by major because that’s how we’re going to do our join down here because we want to see is for my fun what’s the best score for my outer tuple.</p>
<p>602<br>01:05:32,000 –&gt; 01:05:37,000<br>I can give a major and is it is it my score right.</p>
<p>603<br>01:05:37,000 –&gt; 01:06:05,000<br>So for this example yeah we can look at this we can say okay we could write something recently easily to do this kind of manipulation you know they’re saying since these next queries can appear anywhere and in this case here it’s it’s a straight equality predicate you can imagine like equals any exists less than greater than into joins semi joint like you can have all different combinations and it’s very difficult to do to do right the rules to capture everything.</p>
<p>604<br>01:06:05,000 –&gt; 01:06:10,000<br>But this is what basic basically people have been doing for the last 30 years.</p>
<p>605<br>01:06:10,000 –&gt; 01:06:25,000<br>So in the paper when they specify join the question is in the paper they don’t specify join if they’re a quid line modern single standards as you join like yeah you could just have this be.</p>
<p>606<br>01:06:25,000 –&gt; 01:06:45,000<br>The comma and then the word calls from from the that’s that normalization step that I talked about in in like SQL server like they’ll they won’t they’ll figure out what’s in the word calls and move you know what’s in the word calls that should be part of the joint and move that to be part of the joint calls.</p>
<p>607<br>01:06:45,000 –&gt; 01:07:04,000<br>So again the last I think the first paper on nested queries is like 83 84 I think the SQL standard ended it I think it’s SQL 99 but since then people begin writing much of rules and handle all possible different combinations that they’re aware of.</p>
<p>608<br>01:07:04,000 –&gt; 01:07:29,000<br>So this is from the SQL server paper from 2001 that roughly defines the rules that they apply not going to go through all them but this is how they decide what to win when they can decore they nested queries in SQL server look at the documentation they basically have up to 22 rules it’s bunch of this like if it does this and this and this and this right this is defines how they they’re going to do.</p>
<p>609<br>01:07:29,000 –&gt; 01:07:58,000<br>So again all these are going to be based on heuristics and rules so on the plus side is these are somewhat easily to somewhat easy to write if you know the pattern that you’re looking for and because you can have complete control of like when things get moved and how they get moved but I was saying like it all possible edge cases that you got to deal with all possible ware clauses and any kind of combinations of of these nested queries lateral joins is another thing that’s complicated.</p>
<p>610<br>01:07:58,000 –&gt; 01:08:03,000<br>Then writing these rules by hand is simply to an effective.</p>
<p>611<br>01:08:03,000 –&gt; 01:08:14,000<br>So this is where the German show up in this paper in 2015 so there’s actually two papers in the reading list this is the first one is a fault one in 2017 that covers more about how.</p>
<p>612<br>01:08:14,000 –&gt; 01:08:27,000<br>How they handle joins or other things but I just want to focus on this one because it’s it’s an easy read ish on how to do this correlate some queries but they they actually provide the first general purpose method to do.</p>
<p>613<br>01:08:27,000 –&gt; 01:08:56,000<br>So this method to be able to take all correlated sub queries and rewrite them into direct to regular queries without the nesting and the goal is basically when convert all of these these sub queries into joins regular like inner joins out of whatever whatever whatever it’s supposed to be because again we know how to optimize those and the best case scenario we can go from something really stupid like running the that nested query for every.</p>
<p>614<br>01:08:56,000 –&gt; 01:09:07,000<br>That nested query for every single two point the outer out of query which you know could be and squared costs and a nest loop join we can now convert this into you know look at oh and has joined look up.</p>
<p>615<br>01:09:07,000 –&gt; 01:09:21,000<br>So let me quickly go through one example again we can cover more the hyper stuff next class so here’s that same query that we have before we want to find all the students and their major if they have the.</p>
<p>616<br>01:09:21,000 –&gt; 01:09:50,000<br>So the key idea that they’re going to they’re going to have in this paper they’re going to use this this logical concept of logical object according to pen and join and it’s basically a cross product join or cross join except that it’s a there’s a demarcation or that it’s a marker to say this thing is specifically being used because it’s I’m doing a correlated sub query and the whole goal of what they’re the process thing we’re going to do is just do it.</p>
<p>617<br>01:09:50,000 –&gt; 01:10:00,000<br>So the process thing we’re going to do is try to get rid of that dependent join convert it right to to regga joins and then in optimize it like it like it normally would.</p>
<p>618<br>01:10:00,000 –&gt; 01:10:13,000<br>So in this case here just the outer query itself is a projection with a filter and a scan but inside this filter clause right we have this we have this this you know the sub query inside of this.</p>
<p>619<br>01:10:13,000 –&gt; 01:10:25,000<br>So if we take this and expand this we can convert it into a dependent join because now we have on the the right hand side is the.</p>
<p>620<br>01:10:25,000 –&gt; 01:10:38,000<br>The left hand side maybe the right the left hand side is the look up on on the outer table and then now on the other side the right hand side this is actually the inner query and it’s going to be referencing.</p>
<p>621<br>01:10:38,000 –&gt; 01:10:46,000<br>So in its filter or for its where clause predicate be referencing the thing on the other side right and that that’s what makes the correlative.</p>
<p>622<br>01:10:46,000 –&gt; 01:11:02,000<br>So as I said this dependent join isn’t actually a new physical operator it’s not something we actually implement the system it’s just an extension to relational algebra in our query plan that line allows to reason about we know we’re doing certain transformations in our query out miles or because we it’s a correlated sub query.</p>
<p>623<br>01:11:02,000 –&gt; 01:11:14,000<br>Again you could just convert this to like a cross join and add a little flag and say hey by the way I’m using this for you know keep track of dependencies but keep it clean they they define as a separate operator right.</p>
<p>624<br>01:11:14,000 –&gt; 01:11:23,000<br>So again all you’re doing is that for every single tuple in the in the left hand side you’re going to read around whatever it is on the right hand side pop up populate the output and so forth right.</p>
<p>625<br>01:11:23,000 –&gt; 01:11:39,000<br>So again it’s just like a cross bottom. So what they’re going to want to try to do now is try to push down the dependent join to the right hand side of the query plan where we have our inner query and you eventually want to try to get it to the bottom and then convert it into a regular join.</p>
<p>626<br>01:11:39,000 –&gt; 01:11:50,000<br>And then how you actually do this is going to depend on the semantics of the query and you know of the inner query determine how you actually do these transformations.</p>
<p>627<br>01:11:50,000 –&gt; 01:12:09,000<br>So in this case here I have again the scan on the left hand side and the the the inner query on the right hand side so I can move the dependent join down one and then now just you a join a regular join on the outer you know the outer query and then whatever’s coming up to me from the right hand side here.</p>
<p>628<br>01:12:09,000 –&gt; 01:12:24,000<br>So for this particular query to make this work I have to introduce an additional scan that’s basically going to do duplicate elimination think of like a select clause where the all the the projection apple list is also my group by.</p>
<p>629<br>01:12:24,000 –&gt; 01:12:33,000<br>So there’s guarantees that I’m always going to have distinct set of attributes or set of values coming up for all the attributes for given tuple right.</p>
<p>630<br>01:12:33,000 –&gt; 01:12:58,000<br>So now with this this this this you’re eliminating all the duplicates on this side when I do now a dependent join on this side then this guarantees that I’m only spitting up now the the output that I need to do the join without duplicates as if I was running the the right hand sign query once per tuple on the on the outer table.</p>
<p>631<br>01:12:58,000 –&gt; 01:13:09,000<br>But again I’m doing a max on the student score looking at by major so all I really want is for every major what’s the max score.</p>
<p>632<br>01:13:09,000 –&gt; 01:13:24,000<br>So to avoid duplicates of like okay because there’s there’s two people in computer science and I don’t want to have two entries one with the same values of computer science and the score the duplicate elimination scan when I do my join will remove all that for me.</p>
<p>633<br>01:13:24,000 –&gt; 01:13:34,000<br>Again this is just a logical I believe keeping track of what the dependencies are from the right hand side left hand side as I’m going down.</p>
<p>634<br>01:13:34,000 –&gt; 01:13:52,000<br>So key I want to keep pushing down the pen and join so at the next stage right I can get rid of the back here I can I can I want to get up below the aggregation so I’m going to move my duplicate and the mission scan down with me then put the aggregation above me right and again at this point nothing has changed.</p>
<p>635<br>01:13:52,000 –&gt; 01:14:13,000<br>You think sort of the what the the output is going to be like everything’s still the same because what am I doing here I’m getting all the unique students by by score major and then I want to join it with the with the scan on the student table here so this is going to produce you know for every single student every single major here’s the highest score.</p>
<p>636<br>01:14:13,000 –&gt; 01:14:24,000<br>And then when I feed that out of my dependent join thinking that just as a cross product when I now do my group I hear on the major I’m going to get for one major I’m going to get what the max score for yes.</p>
<p>637<br>01:14:24,000 –&gt; 01:14:53,000<br>So you have to identify to because you have lots to say okay I know that I want to get the I only want to get the single score per major right so the equipment thing you would do here by by putting the aggregation above well I need to make sure that I only get one student per major or one score per major and then you add the group item that happened.</p>
<p>638<br>01:14:53,000 –&gt; 01:15:03,000<br>So there’s a lot to be a reason about what the what the intercredit actually wants when you do the joint above to make sure you don’t have duplicates.</p>
<p>639<br>01:15:03,000 –&gt; 01:15:23,000<br>You know for it’s a question is the way to standard is that it’s in the visual paper and then it it varies based on what the ware clauses right this is like something equals something if it’s less than a greater than knows complicates things to right this makes everything harder.</p>
<p>640<br>01:15:23,000 –&gt; 01:15:28,000<br>We’re well over time so you have to go please go.</p>
<p>641<br>01:15:28,000 –&gt; 01:15:34,000<br>We knew we did last time we can pick up in this last class and beginning of next class.</p>
<p>642<br>01:15:34,000 –&gt; 01:15:52,000<br>So we push the aggregation above again we want to go further we want to get this dependent join now below this filter well that’s easy to do right because there isn’t actually any change to we need to make because it whether or not we put the filter before after the join that’s the same thing if it was a regular query right.</p>
<p>643<br>01:15:52,000 –&gt; 01:16:02,000<br>Like you can do a join stupidly without a where clause and it’s just a cartesian product and then above that then you do the filter same thing here right.</p>
<p>644<br>01:16:02,000 –&gt; 01:16:21,000<br>So in this case here it can it’s just a Cartesian product for every unique student may or every unique major I’m going to join against every unique major and a score I’m going to join against all the students table it’s going to produce all the output I want you know all possible combinations and then this is going to filter out that I only get where the student from this side is.</p>
<p>645<br>01:16:21,000 –&gt; 01:16:37,000<br>So now this point here my dependent join is as far as it can go I can’t go below these guys is making sense because these are the leaf notes I’m scanning the tables right so now I want to actually do further</p>
<p>646<br>01:16:37,000 –&gt; 01:17:00,000<br>optimizations to actually put into a physical form I started put into a form that I know how to optimize like any other query so again these are all still at the logical level we’re not doing any none these are physical operators right so I can convert this dependent join into what it really is which is just a cross join a Cartesian product right so there’s no where clause it’s just just you know everything combined with everything on the other side.</p>
<p>647<br>01:17:00,000 –&gt; 01:17:29,000<br>But then now I have as I was saying before I have a filter above a join that’s just an inner join so now I can collapse these two to a single join operator and just move these guys up right I can go either even further and recognize that well all you know this is basically just for every single major for every single student get their major that’s all this is doing here right because my group I was going to handle the removing remove the duplications.</p>
<p>648<br>01:17:29,000 –&gt; 01:17:58,000<br>So I can then convert this now into just a scan on the table as by itself but now to make sure that I I had to rewrite my my join that I had up here because I was referencing that the duplication scan on the major I need to get rid of that so I can also have a filter above that too so I can just combine that now into a single join where it’s the major on this side join the major on that side and the score on this side equals the max score.</p>
<p>649<br>01:17:58,000 –&gt; 01:18:08,000<br>That I produce as my output here because I have the group I’m the major clause I’m guaranteeing that for every single major I have I have one score.</p>
<p>650<br>01:18:09,000 –&gt; 01:18:22,000<br>So this is the easy case right and again there’s some details on I’m closing over for example he was asking how do I know that I need to push up the group by again it depends on the examination of the where clause in the expression trees.</p>
<p>651<br>01:18:22,000 –&gt; 01:18:34,000<br>So this can then be extended for all possible combinations of of of correlated queries and you can convert everything into a to joins.</p>
<p>652<br>01:18:35,000 –&gt; 01:18:43,000<br>Okay well over time as I was saying only hyper umbra and ductyb can do this fully.</p>
<p>653<br>01:18:44,000 –&gt; 01:18:48,000<br>Databricks can do some of it I don’t know about other systems I haven’t seen whether they make these things as well.</p>
<p>654<br>01:18:49,000 –&gt; 01:18:55,000<br>So like this is like if you’re an ability to just say this is this is the way to do it is paper lays out exactly how to do it.</p>
<p>655<br>01:18:55,000 –&gt; 01:19:09,000<br>Again we will cover the other small cases next class we’ll cover also then how they’re handing handling joint picking joint orders but the other day thing we already alluded to today is like okay all the things I’ve talked about is like hey you have a cost that’s going to be whether one plan is better than other.</p>
<p>656<br>01:19:10,000 –&gt; 01:19:20,000<br>What if your cost cost estimates are wrong or you just don’t know because you haven’t even looked at the data before in a lake house environment some new file should have an s3 you don’t know what’s in them what do you do.</p>
<p>657<br>01:19:20,000 –&gt; 01:19:31,000<br>That’s what we’ll cover on next class right how to do a doctor career organization and in the TLDR is going to be I got to join something I got to join some query plan say I got to run something.</p>
<p>658<br>01:19:32,000 –&gt; 01:19:44,000<br>But I can put in hooks to keep track of whether my estimates are right or wrong and we’ll see how to get feedback from when we scan the table feed that that can across models and see whether that helped or not okay.</p>
<p>659<br>01:19:44,000 –&gt; 01:19:47,000<br>I got to join the weekend see you.</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CMU15721 P15S202414 QueryOptimizerImplementation2CMUAdvancedDatabaseSystems</div>
      <div>http://example.com/2025/10/24/CMU15721 P15S202414-QueryOptimizerImplementation2CMUAdvancedDatabaseSystems/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月24日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/24/CMU15721%20P13S202412-DatabaseNetworkingProtocolsCMUAdvancedDatabaseSystems/" title="CMU15721 P13S202412 DatabaseNetworkingProtocolsCMUAdvancedDatabaseSystems">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CMU15721 P13S202412 DatabaseNetworkingProtocolsCMUAdvancedDatabaseSystems</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/24/CMU15721%20P11S202410-Multi-WayJoinAlgorithms%E2%A7%B8Worst-CaseOptimalJoinsCMUAdvancedD/" title="CMU15721 P11S202410 Multi WayJoinAlgorithms⧸Worst CaseOptimalJoinsCMUAdvancedD">
                        <span class="hidden-mobile">CMU15721 P11S202410 Multi WayJoinAlgorithms⧸Worst CaseOptimalJoinsCMUAdvancedD</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
