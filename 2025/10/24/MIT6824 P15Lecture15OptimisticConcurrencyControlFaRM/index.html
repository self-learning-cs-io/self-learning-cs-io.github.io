

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="100:00:00,000 –&gt; 00:00:03,359Good afternoon. Good evening, good night, wherever you are. 200:00:04,719 –&gt; 00:00:06,400So today I want to talk about foreign. 300:00:06,960 –&gt; 00:00:09,040This">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT6824 P15Lecture15OptimisticConcurrencyControlFaRM">
<meta property="og:url" content="http://example.com/2025/10/24/MIT6824%20P15Lecture15OptimisticConcurrencyControlFaRM/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="100:00:00,000 –&gt; 00:00:03,359Good afternoon. Good evening, good night, wherever you are. 200:00:04,719 –&gt; 00:00:06,400So today I want to talk about foreign. 300:00:06,960 –&gt; 00:00:09,040This">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-24T12:02:19.368Z">
<meta property="article:modified_time" content="2025-10-24T12:06:28.572Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>MIT6824 P15Lecture15OptimisticConcurrencyControlFaRM - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="MIT6824 P15Lecture15OptimisticConcurrencyControlFaRM"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-24 20:02" pubdate>
          2025年10月24日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          10k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          85 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">MIT6824 P15Lecture15OptimisticConcurrencyControlFaRM</h1>
            
            
              <div class="markdown-body">
                
                <p>1<br>00:00:00,000 –&gt; 00:00:03,359<br>Good afternoon. Good evening, good night, wherever you are.</p>
<p>2<br>00:00:04,719 –&gt; 00:00:06,400<br>So today I want to talk about foreign.</p>
<p>3<br>00:00:06,960 –&gt; 00:00:09,040<br>This is a paper from 2015.</p>
<p>4<br>00:00:09,040 –&gt; 00:00:12,640<br>So I want to do a little bit more of a recent paper and then zero research paper.</p>
<p>5<br>00:00:12,800 –&gt; 00:00:17,679<br>And the topic of the research paper is trying to explore some ideas and</p>
<p>6<br>00:00:17,679 –&gt; 00:00:20,400<br>technologies to get high performance transactions.</p>
<p>7<br>00:00:30,800 –&gt; 00:00:38,320<br>And with high performance just to make sure that we’re looking for high</p>
<p>8<br>00:00:38,320 –&gt; 00:00:44,480<br>performance for them means they’re getting 140 million transactions per second</p>
<p>9<br>00:00:45,359 –&gt; 00:00:51,840<br>on this THP benchmark using 90 machines.</p>
<p>10<br>00:00:52,640 –&gt; 00:01:01,440<br>And so, you know, whether there’s numbers impressive or</p>
<p>11<br>00:01:01,440 –&gt; 00:01:03,440<br>curfew depends on the numbers you know.</p>
<p>12<br>00:01:03,440 –&gt; 00:01:06,960<br>It’s so that anybody remembered how many transactions per second spend or could do.</p>
<p>13<br>00:01:16,159 –&gt; 00:01:16,640<br>Anybody?</p>
<p>14<br>00:01:21,840 –&gt; 00:01:31,120<br>So if we remember in the paper, there was sort of an intersection there, you know,</p>
<p>15<br>00:01:31,120 –&gt; 00:01:35,280<br>it took about depending on what you did, you know, 10 to 100 milliseconds.</p>
<p>16<br>00:01:35,280 –&gt; 00:01:41,600<br>So, you know, 10 to 100 transactions per second.</p>
<p>17<br>00:01:41,600 –&gt; 00:01:47,120<br>And so the number of transactions that you know a farm you can do is in a completely</p>
<p>18<br>00:01:47,120 –&gt; 00:01:48,400<br>different order of magnitude.</p>
<p>19<br>00:01:49,040 –&gt; 00:01:51,120<br>And that partly is because they’re completely different systems.</p>
<p>20<br>00:01:52,159 –&gt; 00:01:58,000<br>Spender tries to do synchronous geo replication across the world and farm actually</p>
<p>21<br>00:01:58,000 –&gt; 00:02:00,159<br>everything runs in a single data center.</p>
<p>22<br>00:02:04,560 –&gt; 00:02:08,800<br>And so the applications that are being targeted by farm and</p>
<p>23<br>00:02:08,800 –&gt; 00:02:09,920<br>Spender are quite different.</p>
<p>24<br>00:02:09,920 –&gt; 00:02:13,120<br>You know, Spender is targeting applications that cannot tolerate</p>
<p>25<br>00:02:15,120 –&gt; 00:02:18,240<br>the crash of the data center like you know, and the F1</p>
<p>26<br>00:02:19,200 –&gt; 00:02:23,520<br>add serving database while Spender is much, well,</p>
<p>27<br>00:02:23,520 –&gt; 00:02:28,879<br>Farmer is much more targeting sort of like you’re, you were using my SGL or some other sort of,</p>
<p>28<br>00:02:29,920 –&gt; 00:02:34,320<br>you know, database, you know, Alp in the database system and you want much more high performance</p>
<p>29<br>00:02:35,360 –&gt; 00:02:36,320<br>transactions.</p>
<p>30<br>00:02:36,320 –&gt; 00:02:40,640<br>And then, you know, it’s a farm is sort of a possible design or a possible alternative.</p>
<p>31<br>00:02:41,840 –&gt; 00:02:44,480<br>We do provide strict serializability.</p>
<p>32<br>00:02:48,480 –&gt; 00:02:56,000<br>Which is similar to the external consistency that Spender offered.</p>
<p>33<br>00:02:56,960 –&gt; 00:02:58,879<br>And so all goals again, high performance.</p>
<p>34<br>00:02:58,879 –&gt; 00:03:02,560<br>So the number of ideas that they’re going to achieving high performance,</p>
<p>35<br>00:03:03,280 –&gt; 00:03:04,719<br>one, they shard.</p>
<p>36<br>00:03:05,600 –&gt; 00:03:09,760<br>That’s probably the main, you know, sort of standard technique that they use that</p>
<p>37<br>00:03:09,760 –&gt; 00:03:11,120<br>is going to give us performance.</p>
<p>38<br>00:03:11,120 –&gt; 00:03:16,640<br>For example, if you know, different records are on different charts and the transactions,</p>
<p>39<br>00:03:17,279 –&gt; 00:03:20,959<br>touch the different charts, then these transactions are running parallel.</p>
<p>40<br>00:03:20,959 –&gt; 00:03:27,359<br>And so, you have 90 machines, you know, you get 90 times, you know, the performance of the</p>
<p>41<br>00:03:27,359 –&gt; 00:03:32,159<br>single machine. So sharding is a sort of the starting point. But then they go much for it.</p>
<p>42<br>00:03:33,439 –&gt; 00:03:37,279<br>So they use non-volatile DRM.</p>
<p>43<br>00:03:39,439 –&gt; 00:03:42,639<br>And this is to avoid, you know, the bottleneck over having to write to</p>
<p>44<br>00:03:42,639 –&gt; 00:03:49,679<br>you stable storage devices. So in their design, you don’t have to have to write in the critical path</p>
<p>45<br>00:03:49,679 –&gt; 00:03:55,839<br>to an SSD or a disk. And so they avoid the whole cost of doing so.</p>
<p>46<br>00:03:55,839 –&gt; 00:03:59,119<br>And which can be quite expensive. So for example, you think about your</p>
<p>47<br>00:04:01,039 –&gt; 00:04:07,039<br>implementations or draft, you know, the store, you know, or make data persistent.</p>
<p>48<br>00:04:07,839 –&gt; 00:04:11,839<br>And typically, you know, making something persistent on a stable storage device, you know,</p>
<p>49<br>00:04:11,840 –&gt; 00:04:15,840<br>as in the order of, you know, hundreds of milliseconds, hundreds of,</p>
<p>50<br>00:04:17,280 –&gt; 00:04:21,759<br>a few milliseconds, you know, to you, the tens of milliseconds, to 10 milliseconds, if you’re actually</p>
<p>51<br>00:04:21,759 –&gt; 00:04:26,399<br>using magnetic disks. But the SSD, you know, sort of, sort of a, sort of a millisecond.</p>
<p>52<br>00:04:28,000 –&gt; 00:04:33,040<br>And so given the time frame they operate, you know, that we do too costly. So they use some people</p>
<p>53<br>00:04:33,040 –&gt; 00:04:38,720<br>they call non-volatile DRM. This will talk about in a second. Then so that gets us rid of sort of</p>
<p>54<br>00:04:38,720 –&gt; 00:04:46,320<br>the storage access cost. And so the next, you know, to a bottlenecks, the address is CPU,</p>
<p>55<br>00:04:46,320 –&gt; 00:04:52,480<br>bottlenecks, and network bottlenecks. And for that, they use a technique called kernel bypass.</p>
<p>56<br>00:04:56,960 –&gt; 00:05:02,320<br>It basically avoids the operating system for to talk to the network cart. And then they use</p>
<p>57<br>00:05:02,319 –&gt; 00:05:13,360<br>network cart that have a special feature called RDMA. Now I wish the cart to read and write</p>
<p>58<br>00:05:13,360 –&gt; 00:05:17,680<br>memory from a remote server without actually having to interrupt, you know, that remote server.</p>
<p>59<br>00:05:18,800 –&gt; 00:05:24,480<br>And so this, I guess, is really low latency network access to a remote server.</p>
<p>60<br>00:05:25,839 –&gt; 00:05:29,759<br>Or to remote memory. And this is where partly what the name farm comes from, you know, the arc</p>
<p>61<br>00:05:29,759 –&gt; 00:05:33,039<br>and for remote and for memory. And the F is for fast.</p>
<p>62<br>00:05:35,839 –&gt; 00:05:42,319<br>So those are the, sort of the technologies they use. And then to be able to really exploit these</p>
<p>63<br>00:05:42,319 –&gt; 00:05:46,800<br>technologies, this drives them to a design that uses optimization concurrency control.</p>
<p>64<br>00:05:47,279 –&gt; 00:05:51,279<br>Or OCC, the short version of this. So optimistic.</p>
<p>65<br>00:05:51,439 –&gt; 00:06:01,919<br>And in contrast to many of the designs that we’ve seen so far where they use what we’re typically</p>
<p>66<br>00:06:01,919 –&gt; 00:06:06,959<br>called, pessimistic concurrency control schemes. And pessimistic controls schemes basically acquire</p>
<p>67<br>00:06:06,959 –&gt; 00:06:16,079<br>locks on the objects that are being touched by the transaction. And so when they get to the commit</p>
<p>68<br>00:06:16,079 –&gt; 00:06:23,120<br>time, they own all the locks or the relevant objects and just go in and commit. While we’ve</p>
<p>69<br>00:06:23,120 –&gt; 00:06:28,319<br>optimistic concurrency control, you don’t actually acquire locks particularly in farm, you don’t</p>
<p>70<br>00:06:28,319 –&gt; 00:06:36,399<br>require locks on the read transactions. And when you then go commit, you actually have to validate</p>
<p>71<br>00:06:36,399 –&gt; 00:06:43,519<br>that you read the most recent objects. And if so, you can commit. And if you’re not, you know,</p>
<p>72<br>00:06:43,519 –&gt; 00:06:49,439<br>you have to abort and try again. And the reason they use optimistic concurrency control</p>
<p>73<br>00:06:49,439 –&gt; 00:06:53,439<br>as we’ll see in a second is really driven by the fact that they want to use our DNA.</p>
<p>74<br>00:06:56,799 –&gt; 00:07:00,959<br>Okay, so then the final company I want to make on this is sort of an overview. This is really a research prototype.</p>
<p>75<br>00:07:05,199 –&gt; 00:07:12,959<br>So it would like Spanner, which is a deployed system that’s being active use.</p>
<p>76<br>00:07:14,079 –&gt; 00:07:21,279<br>Farm is really a product of the research arm of Microsoft Research. Try to explore new ideas</p>
<p>77<br>00:07:21,279 –&gt; 00:07:27,680<br>to see how to see if one can achieve higher or really higher performance transactions systems.</p>
<p>78<br>00:07:27,680 –&gt; 00:07:33,919<br>And this is just a very active research. People would love to have the power of transactions.</p>
<p>79<br>00:07:34,799 –&gt; 00:07:36,639<br>And but also the performance.</p>
<p>80<br>00:07:37,519 –&gt; 00:07:43,360<br>Okay, so that’s for the short introduction. Any questions so far?</p>
<p>81<br>00:07:49,919 –&gt; 00:07:53,839<br>Okay, let’s talk a little bit about the setup</p>
<p>82<br>00:07:59,039 –&gt; 00:08:03,279<br>for farm. And so there’s basically nine machines.</p>
<p>83<br>00:08:07,279 –&gt; 00:08:15,120<br>I mean, you have these guys. They’re connected by a high-speed data center network.</p>
<p>84<br>00:08:15,120 –&gt; 00:08:22,000<br>And to see a particular one, I’m just going to draw that as a single line for us to switch networking</p>
<p>85<br>00:08:22,000 –&gt; 00:08:31,279<br>internally. And in basically charge, you know, the data is sharded across these different machines.</p>
<p>86<br>00:08:31,839 –&gt; 00:08:36,799<br>And the level of sharding happens at the something that’s called the region.</p>
<p>87<br>00:08:37,839 –&gt; 00:08:47,360<br>So region is two gigabyte. And I know those regions are sharded across the different networks.</p>
<p>88<br>00:08:48,159 –&gt; 00:08:53,199<br>That is the different machines. The region is live in memory. So these are just DRM.</p>
<p>89<br>00:08:53,200 –&gt; 00:09:04,960<br>And not in, for example, on the disk. And so basically the total data set of your database</p>
<p>90<br>00:09:04,960 –&gt; 00:09:10,240<br>actually has to fit in the joint DRM, so the machine that they’re using. So if your data set is</p>
<p>91<br>00:09:10,240 –&gt; 00:09:13,600<br>larger than your current set of machines, you have to buy more machines that get more DRM,</p>
<p>92<br>00:09:13,600 –&gt; 00:09:20,720<br>so they can actually fit. And again, the reason why they want to use DRM is because they want to know</p>
<p>93<br>00:09:20,720 –&gt; 00:09:29,840<br>what we bottleneck by the performance of storage devices. And so of course, you know, the machine can fail.</p>
<p>94<br>00:09:29,840 –&gt; 00:09:36,080<br>And if the machine fails, it loses a DRM. And so therefore they use replication. And so they</p>
<p>95<br>00:09:36,080 –&gt; 00:09:42,560<br>replicate regions across multiple machines. One machine is the primary for a region. And that</p>
<p>96<br>00:09:42,560 –&gt; 00:09:48,000<br>may say, a region might be replicated on another machine, which is in a backup. So they use primary</p>
<p>97<br>00:09:48,000 –&gt; 00:09:57,759<br>backup for replication. And so this is region one. You know, region two, you know, the backup</p>
<p>98<br>00:09:57,759 –&gt; 00:10:04,240<br>might be on the same machine as the primary for backup for region two. And here, you know, we have</p>
<p>99<br>00:10:04,240 –&gt; 00:10:12,159<br>the primary region two. And so this deals, you know, so one machine has a kernel panic or some device</p>
<p>100<br>00:10:12,319 –&gt; 00:10:19,679<br>goes that or just crashes for some other reason. Then there’s a second machine that actually has</p>
<p>101<br>00:10:19,679 –&gt; 00:10:24,959<br>a copy of the data and just could proceed from there. Of course, then we need some, you know,</p>
<p>102<br>00:10:24,959 –&gt; 00:10:34,000<br>way of keeping track of the mapping from regions two, primary and backups. And so they use</p>
<p>103<br>00:10:34,000 –&gt; 00:10:41,439<br>a configuration manager. The CM, let’s sit on the site. And the CM cell, actually, is coupled,</p>
<p>104<br>00:10:41,440 –&gt; 00:10:46,720<br>you know, with a system that we’ve seen before, it’s a keeper. And it’s really the</p>
<p>105<br>00:10:46,720 –&gt; 00:10:51,200<br>a zookeeper and the configuration manager that kept track of the mapping.</p>
<p>106<br>00:10:55,040 –&gt; 00:11:01,920<br>You know, for a region number to the primary and whatever the backups</p>
<p>107<br>00:11:02,719 –&gt; 00:11:14,399<br>for every region. Okay. Now there’s one, I see there’s problem, of course, here. I talked about</p>
<p>108<br>00:11:14,399 –&gt; 00:11:19,439<br>like well primary, we have primary backup replication. Great. So we have faults. Then I know one</p>
<p>109<br>00:11:19,439 –&gt; 00:11:24,719<br>machine can fail. Another machine can take over. I guess, except the one sort of tricky case that</p>
<p>110<br>00:11:24,719 –&gt; 00:11:29,919<br>this scheme can’t handle so far is when there’s a correlated failure, for example, there’s a power</p>
<p>111<br>00:11:29,919 –&gt; 00:11:35,439<br>failure of the data center and all machines, you know, go down. And to handle that case,</p>
<p>112<br>00:11:36,079 –&gt; 00:11:43,759<br>basically the DRAM has sits on a DPS where every machine sits on an uninterruptible power supply.</p>
<p>113<br>00:11:44,559 –&gt; 00:11:47,439<br>So you can draw these as like a big battery that sits on the site.</p>
<p>114<br>00:11:47,600 –&gt; 00:12:02,080<br>And the battery basically, you know, provides enough energy that if there’s a global power failure,</p>
<p>115<br>00:12:02,960 –&gt; 00:12:07,840<br>the machine can keep running for a little time and in that little time, the machine can actually</p>
<p>116<br>00:12:07,840 –&gt; 00:12:15,120<br>store, you know, the farm will like to store the data on SSDs or basically just flushes, you know,</p>
<p>117<br>00:12:15,120 –&gt; 00:12:20,639<br>the content of its memory, all the regions, all the transactions state, all the</p>
<p>118<br>00:12:22,159 –&gt; 00:12:27,120<br>logs for the transactions, and actually flushes is doing SSD. So like there’s a complete power</p>
<p>119<br>00:12:27,120 –&gt; 00:12:33,039<br>failure of the whole data center, the data center, or some point will come back up and they can load,</p>
<p>120<br>00:12:33,039 –&gt; 00:12:39,600<br>you know, the memory contents of the machines from the SSD and you know, start basically running again.</p>
<p>121<br>00:12:40,560 –&gt; 00:12:47,040<br>And so this is basically the only place where the SSDs are being used to deal with a</p>
<p>122<br>00:12:47,040 –&gt; 00:12:55,040<br>coordinated failure of many machines in the data center. Any questions so far?</p>
<p>123<br>00:13:03,120 –&gt; 00:13:08,879<br>Okay, let me say a little bit about the software. So in the regions, so we have a region here,</p>
<p>124<br>00:13:09,920 –&gt; 00:13:17,600<br>in these regions, objects live. So you can just think about an array region as an array of bytes,</p>
<p>125<br>00:13:17,600 –&gt; 00:13:25,200<br>kind of two gigabits of bytes, and in an array of bytes, objects live. And objects have a unique identifier,</p>
<p>126<br>00:13:29,200 –&gt; 00:13:35,040<br>an OID, and the OID of an object is nothing else than its region number,</p>
<p>127<br>00:13:35,039 –&gt; 00:13:41,599<br>its chiple, the region number, and then the address within the region.</p>
<p>128<br>00:13:49,279 –&gt; 00:13:55,519<br>Sochiated with every object, there’s a little bit of metadata for that particular object,</p>
<p>129<br>00:13:56,319 –&gt; 00:14:01,679<br>and in particular for the object header contains a 64-bit number.</p>
<p>130<br>00:14:05,919 –&gt; 00:14:10,559<br>And the number consists is basically a version number</p>
<p>131<br>00:14:13,519 –&gt; 00:14:20,319<br>in the bottom 63, and then a lot bit, as we’ll see in the top bit, in the higher one a bit.</p>
<p>132<br>00:14:21,360 –&gt; 00:14:28,000<br>So every object has this 64-bit number, I’m just going to refer to it as a version number,</p>
<p>133<br>00:14:28,000 –&gt; 00:14:32,079<br>and I will see a place of important role in the Optimics Frequency Control.</p>
<p>134<br>00:14:32,879 –&gt; 00:14:42,000<br>So the way applications use this system, let me say a little bit about that,</p>
<p>135<br>00:14:42,000 –&gt; 00:14:44,080<br>so the application programmer interface.</p>
<p>136<br>00:14:53,040 –&gt; 00:14:55,759<br>So the API is your start-in-conjaction,</p>
<p>137<br>00:14:55,840 –&gt; 00:15:01,600<br>then you read some objects,</p>
<p>138<br>00:15:05,439 –&gt; 00:15:10,399<br>so there you read the call, and the read call takes an OID, there’s an argument,</p>
<p>139<br>00:15:12,799 –&gt; 00:15:17,360<br>the application then may have a certificate manipulate, change the field,</p>
<p>140<br>00:15:17,919 –&gt; 00:15:24,159<br>in the object, or whatever, add one to it, and then at some point, write,</p>
<p>141<br>00:15:26,720 –&gt; 00:15:28,080<br>the object,</p>
<p>142<br>00:15:31,600 –&gt; 00:15:38,159<br>write the updated object itself, write call, and then commit it using TX and commit.</p>
<p>143<br>00:15:41,279 –&gt; 00:15:46,559<br>And it might also be the case that the transaction needs to be borne,</p>
<p>144<br>00:15:46,559 –&gt; 00:15:49,439<br>or because of the Optimics Frequency Control, in that case,</p>
<p>145<br>00:15:50,080 –&gt; 00:15:52,879<br>the application will typically just retry the transaction.</p>
<p>146<br>00:15:53,360 –&gt; 00:15:58,320<br>And so in the transaction, the way it’s just here, the transaction here,</p>
<p>147<br>00:15:58,320 –&gt; 00:16:00,879<br>there’s only one object manipulated, but there’s actually</p>
<p>148<br>00:16:00,879 –&gt; 00:16:05,279<br>manipulated many, many objects, those objects could live in different regions,</p>
<p>149<br>00:16:06,799 –&gt; 00:16:09,679<br>and so they have to have some plan, as we’ll see,</p>
<p>150<br>00:16:09,679 –&gt; 00:16:16,399<br>for running some two-phase commit-like protocol to do atomic operations across objects</p>
<p>151<br>00:16:16,399 –&gt; 00:16:24,559<br>living in different regions. Any sort of questions about the API and setup?</p>
<p>152<br>00:16:30,240 –&gt; 00:16:36,240<br>Sorry, the address, OID, it is the address in the machine itself.</p>
<p>153<br>00:16:36,879 –&gt; 00:16:40,799<br>Yeah, it’s just the offset within that region.</p>
<p>154<br>00:16:46,480 –&gt; 00:16:47,519<br>Okay?</p>
<p>155<br>00:16:48,399 –&gt; 00:16:50,319<br>This region can move, correct?</p>
<p>156<br>00:16:50,319 –&gt; 00:16:54,639<br>If the re-replicated or the commut migration manager decides to be mapping,</p>
<p>157<br>00:16:55,439 –&gt; 00:16:58,079<br>the actual address where the object lives might change,</p>
<p>158<br>00:16:58,799 –&gt; 00:17:00,559<br>so this is a region number plus an offset.</p>
<p>159<br>00:17:02,000 –&gt; 00:17:04,240<br>If I’m a little bit better here, I should set an offset.</p>
<p>160<br>00:17:10,000 –&gt; 00:17:11,519<br>Sorry, I have another question.</p>
<p>161<br>00:17:11,519 –&gt; 00:17:12,559<br>Yeah, kind of into that.</p>
<p>162<br>00:17:13,519 –&gt; 00:17:18,159<br>What was the design choice or design thinking behind making a global address space?</p>
<p>163<br>00:17:20,319 –&gt; 00:17:23,200<br>To have everything in DRAM.</p>
<p>164<br>00:17:26,559 –&gt; 00:17:28,319<br>I’m not sure that has a clear question, but</p>
<p>165<br>00:17:32,079 –&gt; 00:17:36,159<br>the whole goal of the MIS to actually run the transactions on an in-memory database.</p>
<p>166<br>00:17:36,159 –&gt; 00:17:39,919<br>You know, this is a whole trend of sort of databases where all the data is always in memory,</p>
<p>167<br>00:17:39,920 –&gt; 00:17:44,960<br>it’s called in-memory databases, driven by the fact that DRAM is a reasonable cheap,</p>
<p>168<br>00:17:44,960 –&gt; 00:17:50,640<br>and so that would allow you to basically run transactions without actually having to go to a persistent storage.</p>
<p>169<br>00:17:51,360 –&gt; 00:17:56,960<br>They’re basically jumping on that train in memory databases.</p>
<p>170<br>00:17:58,240 –&gt; 00:18:01,920<br>I see, and that requires like a global address, that they all share.</p>
<p>171<br>00:18:02,880 –&gt; 00:18:04,800<br>The address space is per machine, right?</p>
<p>172<br>00:18:06,480 –&gt; 00:18:08,960<br>Every machine has its own address space from zero to whatever.</p>
<p>173<br>00:18:10,560 –&gt; 00:18:18,720<br>And the objects are really the global numbers for global names.</p>
<p>174<br>00:18:22,080 –&gt; 00:18:22,480<br>Thank you.</p>
<p>175<br>00:18:26,480 –&gt; 00:18:28,080<br>Okay, good.</p>
<p>176<br>00:18:28,080 –&gt; 00:18:29,920<br>So let’s talk so far.</p>
<p>177<br>00:18:30,720 –&gt; 00:18:33,600<br>I think we basically sort of established that, you know,</p>
<p>178<br>00:18:33,600 –&gt; 00:18:36,560<br>they’ve gotten the stable storage devices out of the way.</p>
<p>179<br>00:18:37,279 –&gt; 00:18:43,119<br>And so there’s no bottleneck for reading writing storage devices because they’re basically not</p>
<p>180<br>00:18:43,119 –&gt; 00:18:47,839<br>using them other than in this one exceptional case when the power fails.</p>
<p>181<br>00:18:48,799 –&gt; 00:18:52,639<br>So the next type of things they’re focused on is trying to reduce</p>
<p>182<br>00:18:54,720 –&gt; 00:18:59,359<br>CPU utilization or try to be very efficient with the CPU and be very efficient with the network.</p>
<p>183<br>00:19:00,079 –&gt; 00:19:05,519<br>And there’s two key ideas here that I’m talking about.</p>
<p>184<br>00:19:05,519 –&gt; 00:19:06,319<br>Well, no.</p>
<p>185<br>00:19:06,319 –&gt; 00:19:08,319<br>So the first one is kernel bypass.</p>
<p>186<br>00:19:20,799 –&gt; 00:19:24,799<br>And the story of that is a reasonable simple.</p>
<p>187<br>00:19:24,799 –&gt; 00:19:27,679<br>So we have farmed the drones as a usual level process.</p>
<p>188<br>00:19:30,000 –&gt; 00:19:36,240<br>On top of windows, you know, the windows operating systems are the years of the operating system.</p>
<p>189<br>00:19:36,240 –&gt; 00:19:38,319<br>So let’s move a little bit on the site.</p>
<p>190<br>00:19:38,319 –&gt; 00:19:39,679<br>So here’s the operating system.</p>
<p>191<br>00:19:39,679 –&gt; 00:19:44,319<br>And the operating system, of course, is all the features for scheduling processes,</p>
<p>192<br>00:19:44,319 –&gt; 00:19:47,599<br>for a virtual memory, a standard operating system.</p>
<p>193<br>00:19:47,599 –&gt; 00:19:52,000<br>And it also has drivers for hardware devices.</p>
<p>194<br>00:19:52,000 –&gt; 00:19:56,399<br>And like one of the hardware devices is a network interface card.</p>
<p>195<br>00:20:00,319 –&gt; 00:20:05,439<br>And typically, the OS has a driver inside of it that</p>
<p>196<br>00:20:08,159 –&gt; 00:20:09,919<br>programs the network interface card.</p>
<p>197<br>00:20:09,919 –&gt; 00:20:13,359<br>So the reach of writes and registers on the network interface card to basically send</p>
<p>198<br>00:20:13,359 –&gt; 00:20:17,839<br>like send a packet or to reconfigure the network interface card, et cetera, et cetera.</p>
<p>199<br>00:20:19,519 –&gt; 00:20:25,199<br>And so the typical way that applications interact with the network card is the</p>
<p>200<br>00:20:25,200 –&gt; 00:20:30,720<br>make system calls to do the kernel and ask the kernel to basically send a packet.</p>
<p>201<br>00:20:32,400 –&gt; 00:20:36,880<br>And it involves the operating system, it falls to the TCP stack, the network stack,</p>
<p>202<br>00:20:37,519 –&gt; 00:20:39,519<br>and tends to be quite expensive.</p>
<p>203<br>00:20:41,039 –&gt; 00:20:47,039<br>And so they want to avoid this overhead, they’re going to enter in the kernel, running TCP,</p>
<p>204<br>00:20:47,039 –&gt; 00:20:50,319<br>et cetera. And the way they do that is something that was a technique called</p>
<p>205<br>00:20:50,399 –&gt; 00:20:56,399<br>kernel bypass and network is a sort of a collaboration between the network card and the operating</p>
<p>206<br>00:20:56,399 –&gt; 00:21:00,960<br>system. And basically what it does is that the queues that the network interface has,</p>
<p>207<br>00:21:00,960 –&gt; 00:21:04,639<br>so here’s some sort of queues, for example, send queue and receive queue.</p>
<p>208<br>00:21:05,439 –&gt; 00:21:10,960<br>Those queues are basically directly mapped into the address space of the application.</p>
<p>209<br>00:21:11,519 –&gt; 00:21:17,200<br>So the application can ask, you know, operating system, please, you know, take some queues that</p>
<p>210<br>00:21:17,680 –&gt; 00:21:22,240<br>make hast and map them into the address space of the application. And so you can just think about</p>
<p>211<br>00:21:22,240 –&gt; 00:21:28,720<br>this as queue, this basically is directly accessible from the usual level application. So the usual</p>
<p>212<br>00:21:28,720 –&gt; 00:21:34,240<br>level application, you know, can basically now read and write commands or packets into the network</p>
<p>213<br>00:21:34,240 –&gt; 00:21:40,000<br>interface card, we’re about actually having to involve the operating system at all. And so this cuts</p>
<p>214<br>00:21:40,000 –&gt; 00:21:45,279<br>the whole operating system out of the picture and improves your performance considerably.</p>
<p>215<br>00:21:46,240 –&gt; 00:21:51,119<br>In the case of form, they also don’t want to use interrupts. One way of delivering a packet</p>
<p>216<br>00:21:51,119 –&gt; 00:21:55,119<br>correctly is the packet comes in the network interface card delivers an interrupt to the operating</p>
<p>217<br>00:21:55,119 –&gt; 00:22:02,160<br>system, the operating system, then alerts the application that a packet has arrived. And in form,</p>
<p>218<br>00:22:02,160 –&gt; 00:22:06,079<br>they try to avoid that cost and the way they avoid it that cost is basically they pull</p>
<p>219<br>00:22:06,799 –&gt; 00:22:14,079<br>the receive queue. So there’s basically an usual level thread, you know, that sits in the</p>
<p>220<br>00:22:14,079 –&gt; 00:22:20,319<br>farm application and basically does nothing else than sort of reading the receive queue to see</p>
<p>221<br>00:22:20,319 –&gt; 00:22:27,919<br>if actually packet is available. And so that requires the node need of our, so that avoids the use of</p>
<p>222<br>00:22:27,919 –&gt; 00:22:35,119<br>interrupts and, you know, at the cost of basically having a polling thread that’s, you know,</p>
<p>223<br>00:22:35,119 –&gt; 00:22:39,679<br>sits there doing nothing else than polling. And in farm, it turns out that there is this thread</p>
<p>224<br>00:22:39,679 –&gt; 00:22:45,199<br>actually switches back and forth between running some application code and polling the nick.</p>
<p>225<br>00:22:46,639 –&gt; 00:22:53,039<br>So that’s sort of kernel bypass. And you know, this is a reasonable standard. Some people may,</p>
<p>226<br>00:22:53,039 –&gt; 00:23:03,919<br>some of you may know familiar with the BBZK, which is the data plane development kit,</p>
<p>227<br>00:23:04,880 –&gt; 00:23:11,519<br>which is a development kit to basically leverage, you know, kernel bypass. So there’s a reasonable</p>
<p>228<br>00:23:11,519 –&gt; 00:23:19,680<br>standard fit available in many operating systems. So then the next sort of piece of technology that</p>
<p>229<br>00:23:19,680 –&gt; 00:23:25,279<br>you use is a little bit also well known as lightning standardized, many network carts,</p>
<p>230<br>00:23:26,240 –&gt; 00:23:31,840<br>supported or more high end network carts, supported. And that’s something that’s called RDAM A.</p>
<p>231<br>00:23:34,240 –&gt; 00:23:42,080<br>Which stands for remote, remote direct memory access.</p>
<p>232<br>00:23:50,800 –&gt; 00:23:57,519<br>And the basic idea is that, you know, this requires a mix that actually understand RDAM A.</p>
<p>233<br>00:23:58,160 –&gt; 00:24:02,079<br>And so, you’re here with cable, you’re here we have nick on the other side,</p>
<p>234<br>00:24:02,720 –&gt; 00:24:06,960<br>your operating system may be sitting on top of it, you know, here we have form.</p>
<p>235<br>00:24:12,879 –&gt; 00:24:19,599<br>And then, and basically, you know, the application on this site on the center site,</p>
<p>236<br>00:24:19,599 –&gt; 00:24:26,559<br>you know, can basically put a particular packet into the send queue. And, you know, send,</p>
<p>237<br>00:24:26,799 –&gt; 00:24:32,720<br>an RDMA packet, not necessarily somewhere it is a bit in the header of the packet saying like,</p>
<p>238<br>00:24:32,720 –&gt; 00:24:39,359<br>hey, I’m an RDMA packet. And then the nick will send it over to the nick, the destination nick,</p>
<p>239<br>00:24:39,359 –&gt; 00:24:44,559<br>the destination nick sees that this is a special packet, an RDMA packet, and looks at the</p>
<p>240<br>00:24:44,559 –&gt; 00:24:49,440<br>instruction that, you know, goes along with the RDMA packet. And so, destruction might be, you know,</p>
<p>241<br>00:24:49,440 –&gt; 00:24:54,240<br>read a particular memory location or write a particular memory location. So here it is. So,</p>
<p>242<br>00:24:54,240 –&gt; 00:25:02,000<br>for example, let’s say it’s a read operation. And the read operation basically takes a address.</p>
<p>243<br>00:25:03,759 –&gt; 00:25:11,120<br>And it allows the nick to basically read that the address straight out of memory out of ramp.</p>
<p>244<br>00:25:11,120 –&gt; 00:25:16,880<br>So, for example, let’s say, you know, we have our region, you know, with objects in it.</p>
<p>245<br>00:25:17,840 –&gt; 00:25:29,680<br>And the sending farm application can just say, okay, I want to read, you know, this particular</p>
<p>246<br>00:25:29,680 –&gt; 00:25:35,920<br>address, you know, which will help me correspond to this address of this object. Oh, and we’ll send an</p>
<p>247<br>00:25:35,920 –&gt; 00:25:42,560<br>RDMA packet to the nick on the other site. The nick sees that this is an RDMA packet. And</p>
<p>248<br>00:25:43,519 –&gt; 00:25:49,519<br>basically reads, you know, from memory, the value stored at that particular location and sends them</p>
<p>249<br>00:25:49,519 –&gt; 00:25:58,639<br>straight back, you know, to the source. And what is cool about this technology is that the nick can</p>
<p>250<br>00:25:58,639 –&gt; 00:26:05,839<br>do this without actually interrupting or interfering with the server at all. I don’t have to generate an</p>
<p>251<br>00:26:05,839 –&gt; 00:26:12,240<br>interrupt. I just don’t have to run any code on the processors that run the operating system,</p>
<p>252<br>00:26:12,240 –&gt; 00:26:17,599<br>the application instead, you know, the nick as just firmware that runs, you know, executes those</p>
<p>253<br>00:26:17,599 –&gt; 00:26:23,599<br>instructions and loads, you know, the value stored at those memory, either the requested memory,</p>
<p>254<br>00:26:23,599 –&gt; 00:26:28,000<br>or the rest is, you know, straight into a response packet and sends the response packet back.</p>
<p>255<br>00:26:28,000 –&gt; 00:26:33,200<br>And then, of course, on the receiving site, you know, that will show up in the receive queue. And so</p>
<p>256<br>00:26:33,200 –&gt; 00:26:37,039<br>far, you know, it’s so point, you know, we’ll pull the receive queue and see actually, you know, the</p>
<p>257<br>00:26:37,039 –&gt; 00:26:46,399<br>result of that RDMA. This particular version that I’m describing here, the paper refers to as one</p>
<p>258<br>00:26:46,399 –&gt; 00:26:58,879<br>site at RDMA, and that typically refers in the paper to read operations.</p>
<p>259<br>00:26:58,880 –&gt; 00:27:15,520<br>Can you repeat how the polling of the like Nick Hughes works on the client or yeah, on like,</p>
<p>260<br>00:27:15,520 –&gt; 00:27:24,880<br>there’s almost nothing to it. The client just has a thread that reads a particular memory location</p>
<p>261<br>00:27:25,600 –&gt; 00:27:31,520<br>and which indicates whether a packet is arrived or not. And when the nick receives a packet,</p>
<p>262<br>00:27:31,520 –&gt; 00:27:38,160<br>it sticks it in the receive queue and as a site of set setting it in the receive queue, you know, the flag,</p>
<p>263<br>00:27:38,160 –&gt; 00:27:43,440<br>the bit, you know, turns you to one and the application notes, oh yeah, you know, there’s a packet there.</p>
<p>264<br>00:27:46,320 –&gt; 00:27:52,960<br>Is it a specific thread that, you know, that polls like yeah, in their system, they have a specific</p>
<p>265<br>00:27:53,039 –&gt; 00:27:56,960<br>thread that actually you are dedicated to polling the queue.</p>
<p>266<br>00:27:59,519 –&gt; 00:28:05,200<br>Thanks. Sorry, I’m not open this year. So does the need cooperate with the system or is it</p>
<p>267<br>00:28:05,200 –&gt; 00:28:08,480<br>regularly bringing a job like as in any regular Nick?</p>
<p>268<br>00:28:11,600 –&gt; 00:28:16,000<br>This is not a, you know, whatever you’re standing Nick, right? There’s a Nick that supports both</p>
<p>269<br>00:28:16,000 –&gt; 00:28:23,920<br>kernel bypass and remote directory access and RGMA. And there’s typically for Nick to support</p>
<p>270<br>00:28:26,240 –&gt; 00:28:31,519<br>kernel bypass, it means it has to have multiple receive a send queue and it just gives a pair of</p>
<p>271<br>00:28:31,519 –&gt; 00:28:37,200<br>the sender receives queue to an application. And it cannot like, of course, you know, you can’t have</p>
<p>272<br>00:28:37,920 –&gt; 00:28:42,799<br>send a receive queue for every process running on your machine. So typically there are like 16 of them,</p>
<p>273<br>00:28:42,799 –&gt; 00:28:47,200<br>or 32 of them, and you know, give some of them, you know, to a particular authority OS,</p>
<p>274<br>00:28:47,200 –&gt; 00:28:51,680<br>basically allow some applications to own basically send a receive queue.</p>
<p>275<br>00:28:52,879 –&gt; 00:28:58,000<br>Nice. Thank you so much. And that also means that there’s some specific support for DMA and</p>
<p>276<br>00:28:58,000 –&gt; 00:29:02,879<br>Nick that all work out. So, you know, so it requires a Nick that is, you know, correct,</p>
<p>277<br>00:29:02,879 –&gt; 00:29:05,440<br>and reasonable sophisticated, although it’s in a reasonable standard these days.</p>
<p>278<br>00:29:06,080 –&gt; 00:29:15,840<br>Okay, so that’s one-sided RGMA. They also use RGMA to do rights and to actually implement RPC.</p>
<p>279<br>00:29:17,200 –&gt; 00:29:25,680<br>And so there’s a, they typically call this right RGMA in the paper. It’s basically the same thing,</p>
<p>280<br>00:29:28,080 –&gt; 00:29:34,400<br>except, you know, the sender can put in the RGMA packet saying like, oh, this is a right operation</p>
<p>281<br>00:29:34,400 –&gt; 00:29:42,080<br>and right, you know, the following bytes to a particular address. And the paper uses two places,</p>
<p>282<br>00:29:42,080 –&gt; 00:29:47,360<br>or two things where rights are actually going to. Obviously, I’ve never really written directly</p>
<p>283<br>00:29:47,360 –&gt; 00:29:54,080<br>with RGMA, but there’s two other data structures that are being written with right RGMAs. One is a log.</p>
<p>284<br>00:29:56,160 –&gt; 00:29:57,920<br>And I’ll see you the rule of the log later.</p>
<p>285<br>00:29:57,920 –&gt; 00:30:04,720<br>And this is like a related for the transactions. So it has commit records, and locking records,</p>
<p>286<br>00:30:05,279 –&gt; 00:30:11,920<br>etc, etc. And so the source, once they’ve pinned a log record to this particular log,</p>
<p>287<br>00:30:11,920 –&gt; 00:30:19,200<br>you know, it can use do right RGMA and then the receiving link will just add, you know,</p>
<p>288<br>00:30:19,200 –&gt; 00:30:23,920<br>the new entry in the log to the specific location.</p>
<p>289<br>00:30:24,880 –&gt; 00:30:30,880<br>Okay. And so that means like the sender, and so there’s one of these cues,</p>
<p>290<br>00:30:30,880 –&gt; 00:30:36,240<br>and one of these logs is per sender receives a pair, so that the sender actually can manage and</p>
<p>291<br>00:30:36,240 –&gt; 00:30:42,640<br>know what the beginning and the end of the log are. Then in addition to that, there are some,</p>
<p>292<br>00:30:42,640 –&gt; 00:30:53,360<br>there are message cues. And also a one person pair. And these are basically used to implement</p>
<p>293<br>00:30:53,920 –&gt; 00:31:01,039<br>RPCs. So if you want to do remote procedure call, the client, the sender,</p>
<p>294<br>00:31:02,080 –&gt; 00:31:08,640<br>Nixon, write RGMA packet, writes, you know, the data, the message basically into the remote message</p>
<p>295<br>00:31:08,640 –&gt; 00:31:15,920<br>cue. There’s a thread sitting on the destination site that is basically pulling that message cue,</p>
<p>296<br>00:31:15,920 –&gt; 00:31:21,360<br>we’re pulling all the message cues. If it sees a message, you know, it processes the message,</p>
<p>297<br>00:31:21,359 –&gt; 00:31:25,759<br>and can then send a response back, you know, using a write RGMA.</p>
<p>298<br>00:31:32,799 –&gt; 00:31:37,279<br>And this turns out to be, you know, cheaper, you know, implementing route means user calls using</p>
<p>299<br>00:31:37,279 –&gt; 00:31:43,519<br>RGMA. And it turns out to be cheaper than basically using to understand it, RPC package,</p>
<p>300<br>00:31:43,519 –&gt; 00:31:50,159<br>that, you know, since just package using a regular nick, but without RGMA,</p>
<p>301<br>00:31:50,240 –&gt; 00:31:54,560<br>and has a thread in the other side, you know, the response. Okay.</p>
<p>302<br>00:31:56,400 –&gt; 00:32:01,440<br>So there are any validation step here to make sure that you’re only writing to a region of</p>
<p>303<br>00:32:01,440 –&gt; 00:32:05,600<br>memory that’s like expressly allowed for RGMA, you know, so like you don’t write,</p>
<p>304<br>00:32:05,600 –&gt; 00:32:10,000<br>duplicate onto application memory or something. Yeah, so there’s all kinds of, you know,</p>
<p>305<br>00:32:10,000 –&gt; 00:32:14,800<br>this is sort of the highlight of the idea. There’s all kinds of details here. So when</p>
<p>306<br>00:32:15,119 –&gt; 00:32:24,480<br>you sort of set up one of these RDA in order to do this, one side that RGMA is or write RGMAs,</p>
<p>307<br>00:32:24,480 –&gt; 00:32:30,000<br>you first have to do a connection setup. So there’s a negotiation step between the sender and</p>
<p>308<br>00:32:30,000 –&gt; 00:32:35,839<br>the receiver to set up basically like it’s almost like a TCP channel except, you know, RGMA</p>
<p>309<br>00:32:35,839 –&gt; 00:32:43,519<br>WSTCP, but it’s set up a connection oriented, reliable, ordered channel.</p>
<p>310<br>00:32:46,079 –&gt; 00:32:50,159<br>And so the security checks and the actual control checks are happening at the point of the setup.</p>
<p>311<br>00:32:53,199 –&gt; 00:32:56,559<br>So would you have to do that between every pair of machines? Yes.</p>
<p>312<br>00:32:58,639 –&gt; 00:33:03,839<br>So that would become really costly to add like one machine to a large costler, right?</p>
<p>313<br>00:33:04,639 –&gt; 00:33:10,399<br>We have n-square RGMA connections. And otherwise you would have n-square TCP connections.</p>
<p>314<br>00:33:11,839 –&gt; 00:33:14,480<br>And not clear those major differences there.</p>
<p>315<br>00:33:18,000 –&gt; 00:33:24,319<br>And so just to clarify, so the message in the logs basically they both sit also in memory,</p>
<p>316<br>00:33:24,319 –&gt; 00:33:28,879<br>it is set in different places than where the object sits. Yeah exactly. So if you do,</p>
<p>317<br>00:33:28,880 –&gt; 00:33:34,240<br>as a district of a year on the right, it’s sort of a picture of the memory layout of the farm</p>
<p>318<br>00:33:34,960 –&gt; 00:33:41,360<br>process. You know, there’s an region table, we’re an object table, there’s a region in the memory</p>
<p>319<br>00:33:41,360 –&gt; 00:33:48,560<br>of the server. These regions have objects in them. And in addition to the regions, there are message</p>
<p>320<br>00:33:48,560 –&gt; 00:33:56,880<br>cues and there are logs. And also for the Nick to support the direct access from memory. So since</p>
<p>321<br>00:33:56,880 –&gt; 00:34:03,440<br>here we don’t have any software involved, since the Nick can directly access the memory without even</p>
<p>322<br>00:34:04,240 –&gt; 00:34:10,800<br>notifying the application or the OS, shouldn’t be some coordination on the hardware level or at least</p>
<p>323<br>00:34:10,800 –&gt; 00:34:19,920<br>some support also from the processor to this feature. Yeah, so there’s basically, you know, the Nick</p>
<p>324<br>00:34:19,920 –&gt; 00:34:29,360<br>can read a right, read a right cache lines, atomically. And so to support this, you know, there is</p>
<p>325<br>00:34:29,360 –&gt; 00:34:35,519<br>an interface, you know, to the memory system between the Nick and that it has to be carefully set up,</p>
<p>326<br>00:34:35,519 –&gt; 00:34:41,360<br>you know, between the OS and you know, when the connection setup is done. I see, thank you.</p>
<p>327<br>00:34:41,360 –&gt; 00:34:50,640<br>Sorry, the right to RDMA on the right side that is in red. What happens there?</p>
<p>328<br>00:34:52,160 –&gt; 00:35:00,559<br>So the center, the left machine can do a right RDMA, which basically sends a right RDMA packet</p>
<p>329<br>00:35:00,559 –&gt; 00:35:08,400<br>to the right side, the destination and the Nick, you know, sees that this is a right RDMA packet</p>
<p>330<br>00:35:08,400 –&gt; 00:35:13,599<br>and will write a contact that came in over the network to the address that’s specified in the</p>
<p>331<br>00:35:13,599 –&gt; 00:35:23,280<br>right RDMA command. But that would be just, and so there’s a remote machine, you can just write the</p>
<p>332<br>00:35:23,280 –&gt; 00:35:29,920<br>memory location set of addresses on the destination machine without actually having the server, you know,</p>
<p>333<br>00:35:29,920 –&gt; 00:35:34,639<br>being involved other than doing set up, of course. Thank you.</p>
<p>334<br>00:35:37,119 –&gt; 00:35:47,360<br>So quick question. So the Q, the Q and the Nick is only used for read RDMA, it’s like the right</p>
<p>335<br>00:35:47,360 –&gt; 00:35:54,480<br>rights directly to memory and the receiver. Yeah, on the, on the, okay, so they’re on the right</p>
<p>336<br>00:35:54,480 –&gt; 00:35:58,639<br>RDMA, as you may be noticed in the paper, there can be an acknowledgment coming back.</p>
<p>337<br>00:36:00,000 –&gt; 00:36:06,880<br>So if the center, you know, sends a, does a right RDMA, it can wait from an acknowledgment from</p>
<p>338<br>00:36:06,880 –&gt; 00:36:14,880<br>the receiving Nick that actually indeed performed the right RDMA. Thanks.</p>
<p>339<br>00:36:16,639 –&gt; 00:36:18,240<br>And I will play an important role.</p>
<p>340<br>00:36:18,399 –&gt; 00:36:27,759<br>Any more questions about this part? This sort of a cool piece of technology, you know,</p>
<p>341<br>00:36:27,759 –&gt; 00:36:34,719<br>that that’s going to come into existence, pretty quite widespread in the last decade, and basically</p>
<p>342<br>00:36:34,719 –&gt; 00:36:42,159<br>they want to leverage it. Because it allows them to get very, you know, there’s nothing the latency to</p>
<p>343<br>00:36:42,159 –&gt; 00:36:46,480<br>actually do one of these one-sided RDMAs. It’s about five microseconds.</p>
<p>344<br>00:36:48,960 –&gt; 00:36:51,279<br>So very low latency.</p>
<p>345<br>00:36:54,399 –&gt; 00:36:57,279<br>Much, much, much faster, correct? Then, for example, reading or writing a disk,</p>
<p>346<br>00:36:58,879 –&gt; 00:37:06,159<br>and not much slower, you know, slower than writing your own memory, but, you know, pretty fast.</p>
<p>347<br>00:37:06,159 –&gt; 00:37:12,719<br>I think there’s a low G2 to do, if it’s one microseconds, you can do a million packets per second,</p>
<p>348<br>00:37:12,719 –&gt; 00:37:21,440<br>which is pretty impressive. Okay? So there’s so far, being to really stand at technology,</p>
<p>349<br>00:37:24,960 –&gt; 00:37:33,119<br>cutting edge, but standard. So the real challenge that these sort of paper addresses,</p>
<p>350<br>00:37:36,799 –&gt; 00:37:44,399<br>is actually how to use, you know, RDMA, you know, both write RDMA and one-sided RDMA,</p>
<p>351<br>00:37:44,399 –&gt; 00:37:50,000<br>it’s actually doing transactions. So the challenge is paper addresses, the transactions using RDMA.</p>
<p>352<br>00:37:59,279 –&gt; 00:38:04,079<br>And, you know, to sort of see that this is a challenge, you know, we sort of have to think a</p>
<p>353<br>00:38:04,079 –&gt; 00:38:12,239<br>little bit about all the protocols that we’ve seen so far. So protocols for, you know, for</p>
<p>354<br>00:38:12,239 –&gt; 00:38:22,319<br>transactions, two-phase commit, etc. All of those protocols have required sort of service site</p>
<p>355<br>00:38:22,320 –&gt; 00:38:37,680<br>participation. And so, for example, you know, we’re not immune to that, it is, you know, the</p>
<p>356<br>00:38:38,720 –&gt; 00:38:42,960<br>client sends a request or the transaction coordinator sends a request to one of participants,</p>
<p>357<br>00:38:43,680 –&gt; 00:38:49,760<br>for example, through our Rewalk on a particular object, and you’re going to just wait, you know,</p>
<p>358<br>00:38:49,840 –&gt; 00:38:56,960<br>on the server, or the receiver, until the lock actually becomes available, or, you know, runs,</p>
<p>359<br>00:38:56,960 –&gt; 00:39:05,200<br>you know, the server runs some validation step, you know, to see if the transaction can be committed</p>
<p>360<br>00:39:05,200 –&gt; 00:39:11,120<br>or not. And so, in all those cases, basically, if you have sort of service site participation,</p>
<p>361<br>00:39:11,120 –&gt; 00:39:13,520<br>that means that you have to run code on the server.</p>
<p>362<br>00:39:20,640 –&gt; 00:39:28,960<br>And, you know, that is sort of counter to what RDMA gives you, right? RDMA actually doesn’t,</p>
<p>363<br>00:39:29,600 –&gt; 00:39:35,840<br>we will provide you with the ability to run code on the server. And so, the designers or the</p>
<p>364<br>00:39:35,840 –&gt; 00:39:40,640<br>office of this paper have to come up with sort of protocols that allow you to implement, like,</p>
<p>365<br>00:39:40,640 –&gt; 00:39:47,600<br>two-phase commit, and transactions in general to, without actually, or trying to reduce, no service</p>
<p>366<br>00:39:47,599 –&gt; 00:39:52,639<br>site participation, so that they can use through some part of the operation using RDMA,</p>
<p>367<br>00:39:53,759 –&gt; 00:39:58,159<br>and, you know, some using remote procedure calls, as usual, traditional would do in a</p>
<p>368<br>00:39:58,159 –&gt; 00:40:03,360<br>traditional designs that we’ve seen in the last, you know, a couple of weeks. And so, that’s sort</p>
<p>369<br>00:40:03,360 –&gt; 00:40:12,480<br>of the central challenge in this paper. And this pushes them in this direction, you know, to sort of</p>
<p>370<br>00:40:12,480 –&gt; 00:40:22,079<br>solve that problem, the high level strategy that they use is, the high level strategy that</p>
<p>371<br>00:40:22,079 –&gt; 00:40:35,679<br>they use is optimistic, concurrency control. And, and the really, really were, this shines for them</p>
<p>372<br>00:40:35,679 –&gt; 00:40:40,960<br>is on the read operations. Because, basically, the basic plan is, we’re going to read objects,</p>
<p>373<br>00:40:42,480 –&gt; 00:40:46,400<br>that are part of intersection, we’ve had, you know, acquiring walks.</p>
<p>374<br>00:40:51,119 –&gt; 00:40:57,039<br>In general, we require walks, you know, that would mean interrupting maybe the server, the server</p>
<p>375<br>00:40:57,039 –&gt; 00:41:01,440<br>has to do some work, and then, you know, maybe block the client into the election, the lock is</p>
<p>376<br>00:41:01,440 –&gt; 00:41:08,320<br>available, and then return the object. And, you know, that is not really suitable or messes up nicely</p>
<p>377<br>00:41:08,400 –&gt; 00:41:15,840<br>with, what lines up nicely with, RDMA. And so, they’re going to go to an optimistic scheme,</p>
<p>378<br>00:41:15,840 –&gt; 00:41:20,559<br>where basically reading objects is not going to require a lock at all. Maybe just confection object,</p>
<p>379<br>00:41:21,680 –&gt; 00:41:26,960<br>and start using it. And as we’ll see, you know, of course, you need to have some mechanism to</p>
<p>380<br>00:41:26,960 –&gt; 00:41:30,400<br>discover whether you’re reading an old version or a new version. And as is where the version</p>
<p>381<br>00:41:30,400 –&gt; 00:41:42,720<br>numbers are going to play an important role. So, when you read an object in form, you get the object</p>
<p>382<br>00:41:42,720 –&gt; 00:41:49,200<br>back, and you get also the version overback to that object. And then, the basic idea is that,</p>
<p>383<br>00:41:49,200 –&gt; 00:42:00,079<br>at the point of commit, we’re going to do an evaluation step to check that the objects being</p>
<p>384<br>00:42:00,079 –&gt; 00:42:04,960<br>that you read at the beginning of the transaction are actually having to be modified. And so,</p>
<p>385<br>00:42:04,960 –&gt; 00:42:17,279<br>during the validation step, we’re basically going to check for conflict. And the conflict is basically</p>
<p>386<br>00:42:17,279 –&gt; 00:42:21,599<br>if the version number has been incremented, you know, since, you know, the</p>
<p>387<br>00:42:22,319 –&gt; 00:42:26,799<br>coordinate or actually read the object. So, if the version numbers are different,</p>
<p>388<br>00:42:30,799 –&gt; 00:42:35,920<br>are different, then the transaction is awarded.</p>
<p>389<br>00:42:39,759 –&gt; 00:42:43,440<br>And if they’re the same, are still the same, that basically means that nobody,</p>
<p>390<br>00:42:43,440 –&gt; 00:42:49,039<br>no other transaction action modified the transaction, and do the object, and then, you know,</p>
<p>391<br>00:42:49,039 –&gt; 00:42:55,039<br>we can actually go ahead and commit. And of course, in the case of a board, you know, what</p>
<p>392<br>00:42:55,039 –&gt; 00:43:00,880<br>typically will happen is that the client can only maybe run the whole transaction again.</p>
<p>393<br>00:43:01,519 –&gt; 00:43:06,480<br>Perhaps waiting for a little while before actually doing it for a random period of time.</p>
<p>394<br>00:43:07,759 –&gt; 00:43:13,440<br>So, that’s the basic plan. So, this is just this up next scheme, so that reads can</p>
<p>395<br>00:43:14,159 –&gt; 00:43:20,320<br>completely exploit our DNA. And as we’ll see, in fact, reads well and it required any</p>
<p>396<br>00:43:20,960 –&gt; 00:43:29,119<br>state changes on the servers at all. And so, this is basically sort of the basic idea behind,</p>
<p>397<br>00:43:29,119 –&gt; 00:43:34,240<br>you know, figure four, accepting another result. So, in a second, there’s quite a bit of more</p>
<p>398<br>00:43:34,240 –&gt; 00:43:40,159<br>complications to it. And so, this, again, sort of, I think I used this phrase a little while ago,</p>
<p>399<br>00:43:40,159 –&gt; 00:43:44,960<br>a couple of lectures ago. So, the optimistic scheme in contrast to the pessimistic scheme is,</p>
<p>400<br>00:43:44,960 –&gt; 00:43:49,519<br>you’re basically going to assume that you’re allowed to do the operation. And if it turns out</p>
<p>401<br>00:43:49,519 –&gt; 00:43:54,639<br>you’re not alive, you sort of apologize in the board. In the pessimistic case, you basically first</p>
<p>402<br>00:43:54,639 –&gt; 00:43:59,359<br>ask for approval to do the operation by acquiring walks. And then, you’re basically, again,</p>
<p>403<br>00:43:59,359 –&gt; 00:44:06,719<br>key that I commit time, you can actually commit. Okay. Any questions about optimistic concurrency</p>
<p>404<br>00:44:06,799 –&gt; 00:44:13,919<br>control at a, at a high level? Just a question about the version numbers. How do they ensure that</p>
<p>405<br>00:44:13,919 –&gt; 00:44:19,759<br>two different, that there’s like consistency across different objects, so that you’re not reading</p>
<p>406<br>00:44:20,319 –&gt; 00:44:25,839<br>one object and then like later reading another object, but those, but a transaction modified</p>
<p>407<br>00:44:25,839 –&gt; 00:44:31,919<br>some of those in the tweeting. Yeah, well, and that’s a great question. And so, let’s, I think,</p>
<p>408<br>00:44:31,920 –&gt; 00:44:36,639<br>when we’re going to get out of this, we got to dive into actually figure four. And we just,</p>
<p>409<br>00:44:36,639 –&gt; 00:44:43,599<br>I think, sort of, the core of this paper. So, let’s look at figure four. And</p>
<p>410<br>00:44:50,800 –&gt; 00:44:51,840<br>oops, not that one.</p>
<p>411<br>00:44:51,840 –&gt; 00:44:57,680<br>All right. You’re figure four.</p>
<p>412<br>00:45:00,079 –&gt; 00:45:03,440<br>We’re going to spend quite a bit of time basically talking about figure four.</p>
<p>413<br>00:45:06,000 –&gt; 00:45:11,600<br>And so, at first, you know, fingerless, get this oriented in this figure four. I’m going to</p>
<p>414<br>00:45:11,599 –&gt; 00:45:24,719<br>receive. So, we have a transaction coordinator, the C here. And then really the transaction</p>
<p>415<br>00:45:24,719 –&gt; 00:45:29,839<br>coordinator is the application. And the application runs on the same machines, one of those 90</p>
<p>416<br>00:45:29,839 –&gt; 00:45:34,559<br>machines. But the way I’m going to think about it for the rest of this lecture is that it runs</p>
<p>417<br>00:45:34,559 –&gt; 00:45:40,480<br>on a separate machine. I don’t really care about it that much. Okay. And then there are different</p>
<p>418<br>00:45:40,480 –&gt; 00:45:47,360<br>charts. In this case, there are free charts, you know, one, two, and three. And each chart is</p>
<p>419<br>00:45:47,360 –&gt; 00:45:54,240<br>replicated twice, one’s in the primary and one’s in the backup. Then, you know, we’ll see that</p>
<p>420<br>00:45:54,240 –&gt; 00:45:58,639<br>this is the execution phase of the transaction. So, the transaction has two phases. One is the</p>
<p>421<br>00:45:58,639 –&gt; 00:46:04,960<br>execution phase and then it’s the commit phase. And during the execution phase, this is like where</p>
<p>422<br>00:46:05,039 –&gt; 00:46:10,320<br>the transaction just runs. So, it does it begin, does it read. For example, in this case,</p>
<p>423<br>00:46:10,320 –&gt; 00:46:15,280<br>the free objects are being read, you know, one that was located in the first primary is in one</p>
<p>424<br>00:46:15,280 –&gt; 00:46:18,960<br>object that the second thing is shooting in the chart one, one object that’s sitting in the chart</p>
<p>425<br>00:46:18,960 –&gt; 00:46:28,000<br>free, and one object that sits in the chart two. Okay, we’ll read you two. And we can see, actually,</p>
<p>426<br>00:46:28,000 –&gt; 00:46:33,760<br>you know, we look a little bit ahead. We’ll see that the two of these objects are actually being</p>
<p>427<br>00:46:34,640 –&gt; 00:46:40,320<br>written and one of them is being read. So, the object for number, you know, chart three,</p>
<p>428<br>00:46:40,320 –&gt; 00:46:45,200<br>this is just a read operation. And these are read operations. These are read operations, but</p>
<p>429<br>00:46:45,760 –&gt; 00:46:50,800<br>those objects are going to be modified. So, basically, you have to transaction runs, you know,</p>
<p>430<br>00:46:50,800 –&gt; 00:46:56,880<br>it fetches objects from different machines, modifies them locally, and then, you know, in the commit</p>
<p>431<br>00:46:56,880 –&gt; 00:47:03,119<br>phase, the changes are being applied. And of course, you know, the whole challenge here is that</p>
<p>432<br>00:47:03,119 –&gt; 00:47:07,519<br>in the end, we want to achieve strict serialized ability.</p>
<p>433<br>00:47:07,599 –&gt; 00:47:28,079<br>And in some ways, the protocol for at least rights almost follows, like, sort of very similar</p>
<p>434<br>00:47:28,079 –&gt; 00:47:31,119<br>two phase commit protocols that we’ve seen in the past. You know, there are differences in the</p>
<p>435<br>00:47:31,119 –&gt; 00:47:38,400<br>details, but the basic strategy is the same. And, you know, we can sort of, so let’s assume that,</p>
<p>436<br>00:47:38,400 –&gt; 00:47:42,559<br>now, we’re done with the execution phase. So, we’re at the end of the transaction, and sort of</p>
<p>437<br>00:47:42,559 –&gt; 00:47:46,159<br>transactions, we’re going to try to commit the transaction that could be two outcomes. You know,</p>
<p>438<br>00:47:46,159 –&gt; 00:47:50,400<br>they’re actually going to use successfully commits or it actually aborts. And in a way,</p>
<p>439<br>00:47:50,400 –&gt; 00:47:54,559<br>you’re bored because, like, some other transaction ran concurrently and modifies one of the objects</p>
<p>440<br>00:47:54,639 –&gt; 00:48:02,320<br>that we do read, or whatever we’re trying to write. And so the first thing, so the protocol,</p>
<p>441<br>00:48:02,320 –&gt; 00:48:08,159<br>the commit phase basically has five steps, you know, the locking step, the validation step,</p>
<p>442<br>00:48:08,159 –&gt; 00:48:13,119<br>the commit backup step, the commit primary, and then the trunk, although the trunk aid basically runs</p>
<p>443<br>00:48:14,320 –&gt; 00:48:19,279<br>almost lazily. And so it’s not particularly important. These are rather perspective,</p>
<p>444<br>00:48:19,280 –&gt; 00:48:24,240<br>basically, the point of interest that we’re things are stopping is here. So that’s sort of where the</p>
<p>445<br>00:48:24,240 –&gt; 00:48:32,560<br>end of the transaction is. Okay, so, each of these objects, as I said before, you know, when you read</p>
<p>446<br>00:48:32,560 –&gt; 00:48:41,280<br>them, it has a version, you know, a version number. And there are modifies, this is it locally,</p>
<p>447<br>00:48:41,280 –&gt; 00:48:45,519<br>then at the point of this, you know, when the, when the, this is the commit point, where when the</p>
<p>448<br>00:48:45,519 –&gt; 00:48:52,480<br>application calls and transaction, the, the protocol, but this whole commit phase protocol kicks in.</p>
<p>449<br>00:48:54,159 –&gt; 00:48:59,360<br>And so the first thing it does is what’s called the locking step, step number one,</p>
<p>450<br>00:48:59,360 –&gt; 00:49:05,280<br>and the goal here in this step is to basically acquire locks on all the objects that are being written.</p>
<p>451<br>00:49:06,480 –&gt; 00:49:12,400<br>And so we can see, you know, based on this diagram that apparently two objects are being written,</p>
<p>452<br>00:49:12,400 –&gt; 00:49:18,639<br>namely, the, you know, this object for X, because the context is the primary of</p>
<p>453<br>00:49:19,360 –&gt; 00:49:24,800<br>Shard 1 or region 1, and then this object is being read, and now there’s actually located on</p>
<p>454<br>00:49:24,800 –&gt; 00:49:29,680<br>region 2, right? And apparently the fur object that we read, you know, from primary 3,</p>
<p>455<br>00:49:31,280 –&gt; 00:49:38,320<br>it’s not being read, because it doesn’t participate in the locking phase. So in the locking phase,</p>
<p>456<br>00:49:38,320 –&gt; 00:49:48,000<br>the arrows actually have all kinds of different meanings. So these deaf arrows are one-sided RDMAs.</p>
<p>457<br>00:49:56,960 –&gt; 00:50:01,039<br>And so those objects are being read with RDMAs, they’re just fetched from the remote</p>
<p>458<br>00:50:01,840 –&gt; 00:50:08,800<br>memory location and abroad locally, you know, to the memory of the application or the</p>
<p>459<br>00:50:08,800 –&gt; 00:50:22,480<br>coordinator. The solid ones are radar DMAs, and in this particular case,</p>
<p>460<br>00:50:26,320 –&gt; 00:50:35,680<br>they append a lock entry to the log of the primary. So the primary has a log,</p>
<p>461<br>00:50:36,079 –&gt; 00:50:43,119<br>every primary has a log, so I’m just going to drive like this. And I’m actually using a different</p>
<p>462<br>00:50:43,119 –&gt; 00:50:56,639<br>color. So here we have the primary eye with a log. And basically the coordinator, now it’s a commit</p>
<p>463<br>00:50:56,639 –&gt; 00:51:08,000<br>record, or no, sort of, the lock record is called to the log. Now I’m just going to make it a big</p>
<p>464<br>00:51:08,000 –&gt; 00:51:13,199<br>record so I can write down what’s in it. And in it is the version number of the time of the</p>
<p>465<br>00:51:13,199 –&gt; 00:51:19,759<br>red, and one of the object is red, so that version number that came out here. Now that goes back</p>
<p>466<br>00:51:19,760 –&gt; 00:51:26,160<br>into the lock record, the object ID that’s being read, and the new value for the object.</p>
<p>467<br>00:51:29,600 –&gt; 00:51:42,480<br>And so this record is just appended into the primary one and primary two’s log using a right RDMA.</p>
<p>468<br>00:51:43,280 –&gt; 00:51:48,400<br>And so there’s some thread sitting on those machines that looks at these logs and then actually</p>
<p>469<br>00:51:48,400 –&gt; 00:51:56,079<br>does some operations. So in this particular case, if there’s a thread sitting on the P1 and P2,</p>
<p>470<br>00:51:57,200 –&gt; 00:52:03,599<br>monitors or spins or pulls this log and sees there’s a new log record, and then in this</p>
<p>471<br>00:52:03,599 –&gt; 00:52:09,119<br>particular case what it will do, it will try to get a lock on the object that actually is listed in</p>
<p>472<br>00:52:09,359 –&gt; 00:52:20,239<br>the, in the, in the, uh, transaction. So somewhere there’s an object, and the object has some data in it,</p>
<p>473<br>00:52:20,239 –&gt; 00:52:27,920<br>and it has this lock bit and the version number in it. And so P1, you know, has one object, you know,</p>
<p>474<br>00:52:27,920 –&gt; 00:52:35,679<br>that is being modified by the coordinator. P2 has another object that is modified by the coordinator.</p>
<p>475<br>00:52:35,679 –&gt; 00:52:45,199<br>And basically the, the primary tries to require the lock on the, on the object using a test and</p>
<p>476<br>00:52:45,199 –&gt; 00:52:54,319<br>set instruction. And so it will try to set the lock bit, I’m using a test and set instruction,</p>
<p>477<br>00:52:54,319 –&gt; 00:53:04,159<br>and if the lock bit was zero, and before, and the lock bit was zero, and successfully set the</p>
<p>478<br>00:53:04,159 –&gt; 00:53:11,039<br>bit to one, then it knows that the, the primary knows that it actually required a lock, and in</p>
<p>479<br>00:53:11,039 –&gt; 00:53:18,239<br>the next case, and we’ll send the one RDMA message back to append a message, to the coordinators,</p>
<p>480<br>00:53:18,239 –&gt; 00:53:24,399<br>message curious saying, okay, you successfully acquired locks in the frutis particular objects.</p>
<p>481<br>00:53:26,079 –&gt; 00:53:33,759<br>If the transaction, if the lock was already taken by another transaction, then a double</p>
<p>482<br>00:53:33,760 –&gt; 00:53:40,320<br>point in time, the transaction is aborted. And so, so when the primary eye, you know, tries to get</p>
<p>483<br>00:53:40,320 –&gt; 00:53:46,960<br>the lock, finds out that the lock is already set, using a test and set instruction, then that lock,</p>
<p>484<br>00:53:46,960 –&gt; 00:53:58,800<br>sort of the trilock will fail. And the, the primary rule add a message to the queue of the,</p>
<p>485<br>00:53:58,880 –&gt; 00:54:04,560<br>using, to the queue of the coordinator, saying like, I, you know, I could not acquire the locks,</p>
<p>486<br>00:54:04,560 –&gt; 00:54:07,760<br>and the coordinator in that case will report the transactions.</p>
<p>487<br>00:54:10,080 –&gt; 00:54:11,120<br>And you question so far.</p>
<p>488<br>00:54:13,360 –&gt; 00:54:15,840<br>How are the, are the locks obtained through Zookeeper?</p>
<p>489<br>00:54:16,720 –&gt; 00:54:20,560<br>No, these are, there’s, there’s other set of locks using Zookeeper, it does really for the</p>
<p>490<br>00:54:20,559 –&gt; 00:54:29,679<br>configuration management, like the, the mapping of region number two, primary and backups.</p>
<p>491<br>00:54:29,679 –&gt; 00:54:36,239<br>These are just in memory locks, that the primary maintains. So in the dress space,</p>
<p>492<br>00:54:36,239 –&gt; 00:54:42,000<br>kind of looking a little bit back, correct. We look back at this picture. There was a region has</p>
<p>493<br>00:54:42,000 –&gt; 00:54:48,880<br>objects, every object has some data and a header, and in that header, there is basically a 64-bit</p>
<p>494<br>00:54:48,880 –&gt; 00:54:55,280<br>number that were the top level bit is the lock bit and the 63 other bits from the version number.</p>
<p>495<br>00:54:56,320 –&gt; 00:55:00,960<br>What is the primary goes down? Does the backup have the same locks as the primary?</p>
<p>496<br>00:55:01,760 –&gt; 00:55:06,800<br>If the primary goes down, the whole, what is going to happen is that there’s a whole</p>
<p>497<br>00:55:06,800 –&gt; 00:55:13,840<br>reconfiguration protocol happening and a recovery protocol. The end result of that is that in this</p>
<p>498<br>00:55:13,840 –&gt; 00:55:18,880<br>case, we hope that it actually would be a board, correct, because it never made it to the end.</p>
<p>499<br>00:55:20,000 –&gt; 00:55:23,120<br>We’ll get to the photos in another while. So what’s the shoe for?</p>
<p>500<br>00:55:24,559 –&gt; 00:55:27,760<br>I’m going to talk about it in a couple of boards, and I’ll talk about four panels.</p>
<p>501<br>00:55:27,760 –&gt; 00:55:28,079<br>Thank you.</p>
<p>502<br>00:55:31,680 –&gt; 00:55:36,640<br>So the version number are per object, right? Sure. Per object, yeah.</p>
<p>503<br>00:55:37,279 –&gt; 00:55:38,639<br>Okay.</p>
<p>504<br>00:55:42,319 –&gt; 00:55:44,799<br>Okay, good. So, um,</p>
<p>505<br>00:55:48,559 –&gt; 00:55:53,519<br>why do they choose to abort a transaction rather than blocking and waiting for the lock to be released?</p>
<p>506<br>00:55:55,039 –&gt; 00:56:01,119<br>Because they have all material. They have not read the latest material value,</p>
<p>507<br>00:56:01,199 –&gt; 00:56:03,359<br>and so the transaction has to abort.</p>
<p>508<br>00:56:04,880 –&gt; 00:56:08,880<br>Oh, I see. Because the lock means that it’s going to change the next time.</p>
<p>509<br>00:56:08,880 –&gt; 00:56:12,239<br>Well, they asked for the locks after they’re really written the object,</p>
<p>510<br>00:56:12,880 –&gt; 00:56:17,119<br>right? So the coordinated modifies the object based on some version number,</p>
<p>511<br>00:56:18,159 –&gt; 00:56:22,319<br>submits a bunch of rights, assuming that it’s written on the latest version number.</p>
<p>512<br>00:56:22,880 –&gt; 00:56:29,920<br>And so by the time the, the commits starts to happening and you try to get the locks,</p>
<p>513<br>00:56:30,000 –&gt; 00:56:33,680<br>and you discover that somebody else is locked, it means somebody else is already modifying it.</p>
<p>514<br>00:56:33,680 –&gt; 00:56:36,400<br>And so that would violate the realization, right?</p>
<p>515<br>00:56:37,840 –&gt; 00:56:41,200<br>Yep. Thank you. So in fact, at the point you get the lock here,</p>
<p>516<br>00:56:41,840 –&gt; 00:56:44,400<br>that sort of the serialization point for writing transactions.</p>
<p>517<br>00:56:45,599 –&gt; 00:56:50,159<br>Okay, with this, this point, the transaction has acquired all the locks for all the objects</p>
<p>518<br>00:56:50,159 –&gt; 00:56:55,200<br>is modified. So so nobody else can actually modify them in this particular point in time.</p>
<p>519<br>00:56:55,200 –&gt; 00:56:58,639<br>And so that’s sort of the serialization point for the right part of the transaction.</p>
<p>520<br>00:57:00,240 –&gt; 00:57:05,280<br>Makes sense? Yes, thank you.</p>
<p>521<br>00:57:07,039 –&gt; 00:57:14,079<br>Good. Okay, so now you might have felt like, oh, why not do the same thing for read,</p>
<p>522<br>00:57:14,079 –&gt; 00:57:18,800<br>correct? And you know, get the lock for the read objects, get the lock for the objects that are</p>
<p>523<br>00:57:18,800 –&gt; 00:57:24,480<br>read, you know, check the version number and you’re in good shape. And the reason that that is</p>
<p>524<br>00:57:24,480 –&gt; 00:57:30,400<br>actually in a separate phase, namely the validation phase, is to basically avoid these expensive</p>
<p>525<br>00:57:30,400 –&gt; 00:57:35,360<br>write-rDMAs, right? If you look at this vertical step, you’ll see that there’s a write-rDMA,</p>
<p>526<br>00:57:35,360 –&gt; 00:57:40,559<br>then the server actually has to run something, it basically does the acquiring the locks,</p>
<p>527<br>00:57:40,559 –&gt; 00:57:47,440<br>and then responds with another write-rDMA. So here, this is a full RPC that actually requires</p>
<p>528<br>00:57:47,440 –&gt; 00:57:54,720<br>server for participation. And as we’ll see in a second, to handle the read, and the objects that</p>
<p>529<br>00:57:54,720 –&gt; 00:58:02,159<br>have been read, the farm uses this validation step, and that validation step just used one</p>
<p>530<br>00:58:02,159 –&gt; 00:58:06,240<br>cited RDMAs. And so there’s no real server involvement necessary.</p>
<p>531<br>00:58:07,119 –&gt; 00:58:18,239<br>Okay. So what happens on the, so we’re basically at this point, the, you know,</p>
<p>532<br>00:58:18,239 –&gt; 00:58:23,599<br>where we hear the transaction coordinator actually has the write locks, and now the only thing</p>
<p>533<br>00:58:23,599 –&gt; 00:58:31,599<br>it does is validates the read locks, or basically the read version numbers. And so it, for every object</p>
<p>534<br>00:58:31,599 –&gt; 00:58:35,679<br>that is read, but not modified, so in our particular example, that’s only one object, correct?</p>
<p>535<br>00:58:35,679 –&gt; 00:58:43,440<br>This is the one that actually is being read, the one that region three. So it sends, it basically</p>
<p>536<br>00:58:43,440 –&gt; 00:58:50,559<br>does a one outside an RDMA to read the version number that 64 bit number for the object as being read.</p>
<p>537<br>00:58:51,759 –&gt; 00:58:59,839<br>And when it gets it back, when it gets it back here, it checks two things. If the lock is taken,</p>
<p>538<br>00:58:59,839 –&gt; 00:59:04,639<br>or if the lock is set, that means that some core, that a concurrence action is being,</p>
<p>539<br>00:59:04,639 –&gt; 00:59:10,559<br>is trying to modify it. So that point, a user boards. And so the whole transaction board to get.</p>
<p>540<br>00:59:11,679 –&gt; 00:59:17,599<br>If the version number is identical, and it’s not locked, that means that no other transaction</p>
<p>541<br>00:59:17,599 –&gt; 00:59:24,960<br>is using this particular point of time, and the, the transaction could proceed. Basically,</p>
<p>542<br>00:59:24,960 –&gt; 00:59:30,000<br>all the objects that are being read and modified have the version number at the start of the transaction,</p>
<p>543<br>00:59:30,960 –&gt; 00:59:36,320<br>and nothing has changed yet. And so it is okay for the transaction to commit. This is really the</p>
<p>544<br>00:59:36,320 –&gt; 00:59:41,599<br>true zeroization point. And since the transactions numbers are acquired at the beginning,</p>
<p>545<br>00:59:41,599 –&gt; 00:59:46,719<br>when the version number are read at the beginning of the transaction, the transaction will commit</p>
<p>546<br>00:59:46,719 –&gt; 00:59:53,440<br>in order of the version numbers, basically, and they also will get basically strict serializability.</p>
<p>547<br>00:59:54,559 –&gt; 00:59:59,199<br>Because any transaction that will start after your transaction commits will have a higher version</p>
<p>548<br>00:59:59,199 –&gt; 01:00:08,480<br>number. So therefore, it also will commit later. Okay, so this is the point, basically, where the</p>
<p>549<br>01:00:08,480 –&gt; 01:00:15,919<br>transaction coordinator says, you know, at this point, you know, the, we know that all the,</p>
<p>550<br>01:00:15,919 –&gt; 01:00:20,879<br>we have the, we have acquired the locks, we have verified, validated the version numbers for the</p>
<p>551<br>01:00:20,879 –&gt; 01:00:23,679<br>read objects. And so this is basically the commit point.</p>
<p>552<br>01:00:23,919 –&gt; 01:00:29,440<br>We’ll just start off the commit point. So at this point, the transaction is going to say,</p>
<p>553<br>01:00:30,079 –&gt; 01:00:35,759<br>okay, I’m going to go commit, I’m going to go commit. And you know, there’s a multiple</p>
<p>554<br>01:00:36,239 –&gt; 01:00:40,799<br>messages necessary in the commit points. As we’ve seen, second, those are mostly for fault</p>
<p>555<br>01:00:40,799 –&gt; 01:00:48,960<br>tolerance reasons. And so at this point, namely, only the primary, you know, has been,</p>
<p>556<br>01:00:49,920 –&gt; 01:00:57,119<br>only the primaries have been contacted of the objects that are being modified, but not the</p>
<p>557<br>01:00:57,119 –&gt; 01:01:02,400<br>backgrounds. And of course, you know, we want to ensure that, and write, you know, once it commits,</p>
<p>558<br>01:01:03,280 –&gt; 01:01:08,720<br>will survive, uh, f failures, right? The system is designed to handle f plus one failures.</p>
<p>559<br>01:01:09,440 –&gt; 01:01:15,360<br>In our particular design, there’s one backup. And so it can only survive one failure.</p>
<p>560<br>01:01:16,000 –&gt; 01:01:22,000<br>And so what happens in this final phase to commit backup phase is actually we’re going to write</p>
<p>561<br>01:01:22,640 –&gt; 01:01:31,519<br>to the logs of the primary of the backups. So the backups have log, the years back of i,</p>
<p>562<br>01:01:31,519 –&gt; 01:01:39,680<br>you know, similarly, there’s a log entry in it. And um, what we’re going to do is write, uh,</p>
<p>563<br>01:01:39,680 –&gt; 01:01:41,440<br>what’s called the commit backup record.</p>
<p>564<br>01:01:45,519 –&gt; 01:01:54,320<br>And the commit backup record, right? Exactly. It has the same information as the,</p>
<p>565<br>01:01:55,760 –&gt; 01:02:01,120<br>walking record that we shot earlier. So in it, it’s going to be diversion number, the OID,</p>
<p>566<br>01:02:01,920 –&gt; 01:02:04,240<br>and the new value.</p>
<p>567<br>01:02:08,000 –&gt; 01:02:14,640<br>Okay. And this is, you know, like before, this is actually done using a right</p>
<p>568<br>01:02:15,440 –&gt; 01:02:15,920<br>RDMA.</p>
<p>569<br>01:02:21,200 –&gt; 01:02:25,920<br>Now the backup does what we really have to do any operation at this point, like the server side of</p>
<p>570<br>01:02:25,920 –&gt; 01:02:32,400<br>the backup doesn’t really have to run anything. I just need, uh, and, and so the, the, here’s this trick,</p>
<p>571<br>01:02:33,200 –&gt; 01:02:38,880<br>where basically the center rates and the acknowledgement of the net. And so this, you know,</p>
<p>572<br>01:02:38,880 –&gt; 01:02:44,880<br>doesn’t, this is not a one-sided, or a right RDMA. This is just to make acknowledging that it got</p>
<p>573<br>01:02:44,880 –&gt; 01:02:49,840<br>the right RDMA and that the right RDMA has to be performed. And so that basically acknowledges,</p>
<p>574<br>01:02:49,840 –&gt; 01:02:54,079<br>you know, when we get this particular point in the protocol, the transactual coordinate</p>
<p>575<br>01:02:54,079 –&gt; 01:03:01,280<br>or nodes, the object is in the log of all the primaries and the OID is in the, uh, in the log of all the</p>
<p>576<br>01:03:01,280 –&gt; 01:03:07,200<br>backups. And so now we’re in a good position in third-of-fault tolerance, correct? Because, um,</p>
<p>577<br>01:03:07,200 –&gt; 01:03:11,680<br>if any of one of the two fails, then the other one can actually apply the right operation.</p>
<p>578<br>01:03:11,919 –&gt; 01:03:21,759<br>Then there’s one more step that needs to be performed and that is the, uh, commit primary.</p>
<p>579<br>01:03:21,759 –&gt; 01:03:27,279<br>We’ll talk about a little bit later in the more detail. But this is the final step where,</p>
<p>580<br>01:03:28,079 –&gt; 01:03:32,799<br>there’s one more log record written in the primary name, the commit record.</p>
<p>581<br>01:03:33,600 –&gt; 01:03:42,720<br>And the commit record just assessed the transaction ID that actually is being committed.</p>
<p>582<br>01:03:44,480 –&gt; 01:03:48,960<br>Uh, and so we’re like every, I didn’t write that down in the other records, but every record has</p>
<p>583<br>01:03:48,960 –&gt; 01:03:55,200<br>some transactions ID so that we know which transaction we’re talking about. And, uh, and again,</p>
<p>584<br>01:03:55,200 –&gt; 01:04:01,440<br>this is, or uses the same sort of strategy. There’s a right RDMA to append.</p>
<p>585<br>01:04:03,360 –&gt; 01:04:12,160<br>To the, uh, to the log and, you know, there’s an acknowledgement, the NIC acknowledges,</p>
<p>586<br>01:04:13,440 –&gt; 01:04:20,000<br>the, the right RDMA. And so, but it doesn’t require any interrupts or there’s no,</p>
<p>587<br>01:04:20,000 –&gt; 01:04:25,280<br>the server itself is not being interfered with, just the NIC is involved in these two operations.</p>
<p>588<br>01:04:26,000 –&gt; 01:04:35,040<br>Then, as soon as the one of the NICs, uh, acknowledges the commit record on one of the primaries,</p>
<p>589<br>01:04:35,040 –&gt; 01:04:40,560<br>at that particular point in time, the transaction really truly committed. But this is the true commit point.</p>
<p>590<br>01:04:43,760 –&gt; 01:04:47,200<br>The commit starts basically here and this is actually the actual commit point.</p>
<p>591<br>01:04:47,200 –&gt; 01:04:52,000<br>And at that particular point in time, the, uh, transaction coordinator informs the application.</p>
<p>592<br>01:04:52,000 –&gt; 01:04:55,280<br>Yes, your transaction has committed and is done.</p>
<p>593<br>01:04:57,519 –&gt; 01:05:01,119<br>Then, you know, of course, short points later, the logs need to be cleaned and shorted</p>
<p>594<br>01:05:01,119 –&gt; 01:05:06,480<br>up and truncated and all the kind of stuff. And this is like the truncated face. And that’s basically</p>
<p>595<br>01:05:06,480 –&gt; 01:05:12,559<br>picking back on later walking faces and validation faces. Uh, and so I’m not really going to talk</p>
<p>596<br>01:05:12,559 –&gt; 01:05:17,679<br>about it at all, but basically it is to truncate the logs so that they don’t grow unbiasedly.</p>
<p>597<br>01:05:22,719 –&gt; 01:05:34,400<br>Uh, sorry, but the hardware acts, they just go directly into, into the NIC of the coordinator.</p>
<p>598<br>01:05:35,039 –&gt; 01:05:40,000<br>Yeah, so it is like, let’s go back to the RDDA picture, right? So if a right RDMA happens,</p>
<p>599<br>01:05:41,440 –&gt; 01:05:46,320<br>uh, so you’ve got a right RDMA, the sender to coordinator was running here, right? And</p>
<p>600<br>01:05:46,400 –&gt; 01:05:52,320<br>here’s maybe one of the primary sort of backups. And so the right RDMA goes in, you know,</p>
<p>601<br>01:05:52,320 –&gt; 01:05:58,000<br>writes maybe an entry into the log. Uh, the NIC does that, the NIC, you know, sends an acknowledgement back.</p>
<p>602<br>01:06:00,160 –&gt; 01:06:03,360<br>And the coordinator will see that the acknowledgement in the received queue.</p>
<p>603<br>01:06:07,120 –&gt; 01:06:14,960<br>And so as soon as the coordinator sees the ECK, you know, for, uh, it’s, uh, one, right RDMA, uh, it can, uh,</p>
<p>604<br>01:06:15,039 –&gt; 01:06:18,320<br>proceed. I know it’s that the right RDMA succeeded.</p>
<p>605<br>01:06:23,920 –&gt; 01:06:28,000<br>So does the right RDMA is only right to the log? They,</p>
<p>606<br>01:06:29,119 –&gt; 01:06:36,639<br>they’re used in two cases. Uh, they’re both used for these message queues and for the, uh, the log</p>
<p>607<br>01:06:36,719 –&gt; 01:06:45,679<br>append. Um, so when we say that, uh, that, uh, a right RDMA has been performed, we mean that it</p>
<p>608<br>01:06:45,679 –&gt; 01:06:50,079<br>has been attempted to the log and not actually executed necessarily by the application.</p>
<p>609<br>01:06:50,079 –&gt; 01:06:54,960<br>That’s correct. That’s correct. Uh, so for genital, you know, to, for example, to do the, for the backup to</p>
<p>610<br>01:06:54,960 –&gt; 01:07:01,359<br>actually, uh, perform the update to the object, you know, it needs to read the log entry and then apply</p>
<p>611<br>01:07:01,360 –&gt; 01:07:08,480<br>your update. I see. And also for the log bit for every object. So since everything resides in</p>
<p>612<br>01:07:08,480 –&gt; 01:07:13,599<br>memory and we have like 64 bits for the version number plus the log bit. So I’m assuming that it can</p>
<p>613<br>01:07:13,599 –&gt; 01:07:18,480<br>fit in a single memory address, uh, but we can still have the problem of, let’s say, like, the</p>
<p>614<br>01:07:18,480 –&gt; 01:07:24,240<br>processor fetching that memory address into the register. Uh, and then maybe you have like a multi-core,</p>
<p>615<br>01:07:25,039 –&gt; 01:07:30,800<br>uh, machine, then another core fetching that, uh, like that same address and then both of them</p>
<p>616<br>01:07:30,800 –&gt; 01:07:36,080<br>flipping from zero to one. So, uh, so I’m assuming that there’s some support from the hardware there.</p>
<p>617<br>01:07:36,080 –&gt; 01:07:40,160<br>Yeah. So like I mentioned a little bit earlier, the primary one, it acquired, so the primary is</p>
<p>618<br>01:07:40,160 –&gt; 01:07:46,400<br>actually involved, correct? In the, the primary on the, uh, in the, so the coordinator sends,</p>
<p>619<br>01:07:46,400 –&gt; 01:07:52,880<br>so in the walk step, like this, this step, correct? Step one, the primary or the coordinator sends in,</p>
<p>620<br>01:07:53,840 –&gt; 01:08:04,160<br>a right RDMA to the, to the primaries, asking the primaries to walk the, uh, object. And the</p>
<p>621<br>01:08:04,160 –&gt; 01:08:11,360<br>primaries answer explicitly with a message that we reply. And so the crucial step that happens</p>
<p>622<br>01:08:11,360 –&gt; 01:08:16,960<br>is that the primary one, it actually tries to get the walk. And that walk, uh, is set, is, you know,</p>
<p>623<br>01:08:16,960 –&gt; 01:08:21,840<br>the reason this is a one single 64 bit number is so that you can use a test and set instruction,</p>
<p>624<br>01:08:21,840 –&gt; 01:08:30,079<br>which is atomic, uh, to set the walk. So if two, uh, so there’s never the case, like there’s only</p>
<p>625<br>01:08:30,079 –&gt; 01:08:34,720<br>a two test and set instruction run that it is exactly at the same time, one is going to win, the other’s</p>
<p>626<br>01:08:34,720 –&gt; 01:08:44,239<br>going to lose. I see. Thank you. And that’s the crucial point, right? I’ve got a question</p>
<p>627<br>01:08:44,319 –&gt; 01:08:53,359<br>about the blue cockpit point. Yeah. Um, wouldn’t it? So should I, let me, uh, maybe it’s better to actually,</p>
<p>628<br>01:08:54,159 –&gt; 01:08:58,880<br>open a new slide to the picture again, and just, uh, instead of scribbling you the more over this,</p>
<p>629<br>01:08:59,439 –&gt; 01:09:12,079<br>let me, uh, let’s get one more picture so we can talk about other scenarios.</p>
<p>630<br>01:09:14,319 –&gt; 01:09:22,479<br>A little bit bigger. I think it’s actually doing that. Okay. Uh, so you’re worried about, let me see.</p>
<p>631<br>01:09:23,599 –&gt; 01:09:29,119<br>Yeah, the commit point between step after step two, but before step three. Yeah, so here, um,</p>
<p>632<br>01:09:29,119 –&gt; 01:09:35,760<br>here’s the decision correct here. Right. I can commit and then basically here’s the actual commit point.</p>
<p>633<br>01:09:35,760 –&gt; 01:09:41,439<br>Where? Okay. Um, yeah, I guess I was trying to think about the scenario where,</p>
<p>634<br>01:09:41,599 –&gt; 01:09:50,559<br>when it’d be possible for a completely separate concurrence reaction, that writes only P3 to get</p>
<p>635<br>01:09:50,559 –&gt; 01:09:58,960<br>entered, it’s like start and complete in that space. And then wouldn’t that, no, wouldn’t be problematic.</p>
<p>636<br>01:09:59,519 –&gt; 01:10:02,719<br>Yeah, it would be problematic, but it can’t correct because when it writes, it’s about to get the</p>
<p>637<br>01:10:02,720 –&gt; 01:10:07,520<br>lock at some point. And when we get the lock, we check the version number and the lock bit.</p>
<p>638<br>01:10:10,000 –&gt; 01:10:14,560<br>But does the read, does the read the P3 effect the version number in lock bit?</p>
<p>639<br>01:10:15,360 –&gt; 01:10:23,360<br>No, no, no, it just gets the version number. But they’ve like, let me hold that question,</p>
<p>640<br>01:10:23,360 –&gt; 01:10:27,280<br>if you’re going to come back at this. And then we’ll see what actually happens.</p>
<p>641<br>01:10:28,239 –&gt; 01:10:29,519<br>All right. That’s it. Thanks.</p>
<p>642<br>01:10:31,599 –&gt; 01:10:37,920<br>Any other questions? This might be like a separate scenario, but what happens if, um,</p>
<p>643<br>01:10:39,119 –&gt; 01:10:46,079<br>you know, after the execution phase, um, you know, it tries to acquire a lock and then crashes</p>
<p>644<br>01:10:46,079 –&gt; 01:10:50,800<br>right after that. And the lock has been acquired, but no one else after that can acquire it.</p>
<p>645<br>01:10:52,000 –&gt; 01:10:56,000<br>Yeah. Okay. So well, first of all, that machine disappears from the earth, correct? And the</p>
<p>646<br>01:10:56,079 –&gt; 01:11:03,439<br>memory content is gone too. And, uh, and the whole recovery protocol that is described in the</p>
<p>647<br>01:11:03,439 –&gt; 01:11:09,680<br>next section in the paper, it kicks in. And, uh, that protocol in the end will abort that transaction.</p>
<p>648<br>01:11:17,600 –&gt; 01:11:19,199<br>So that actually will get cleaned up.</p>
<p>649<br>01:11:26,479 –&gt; 01:11:32,560<br>Just another question. Uh, so here, like the coordinator is the client, right? Like it’s the</p>
<p>650<br>01:11:32,560 –&gt; 01:11:38,800<br>application. Yeah. Well, yeah, it is. Sure. Uh, and so the client is basically doing all the steps</p>
<p>651<br>01:11:38,800 –&gt; 01:11:43,840<br>of like log value data. Yeah. Yeah. Yeah. So you could think about the application is running on</p>
<p>652<br>01:11:43,840 –&gt; 01:11:49,359<br>the same set of 90 machines, right? And, you know, running this transaction, which apparently,</p>
<p>653<br>01:11:49,359 –&gt; 01:11:57,279<br>you know, writes two objects are read one and runs the protocol. And so, uh, I guess what’s</p>
<p>654<br>01:11:57,279 –&gt; 01:12:02,799<br>confusing me is, so does the primary not communicate with the backup directly? It’s the</p>
<p>655<br>01:12:02,799 –&gt; 01:12:06,960<br>cool. No, it’s actually indeed. Uh, the primary does not directly communicate with the backup.</p>
<p>656<br>01:12:07,759 –&gt; 01:12:12,960<br>Hmm, nice. Other than doing the recovery protocol, there’s all kinds of communication happening,</p>
<p>657<br>01:12:12,960 –&gt; 01:12:22,399<br>but that’s not shown here. So the coordinator just uses the configuration from the zookeeper.</p>
<p>658<br>01:12:22,399 –&gt; 01:12:27,760<br>Yeah. Yeah. Yeah. Yeah. I gotta go back to this very first picture. Uh, and, you know, there’s all</p>
<p>659<br>01:12:27,760 –&gt; 01:12:32,079<br>kinds of stuff, you know, related to this, too, that I’m not talking about, uh, like this precise</p>
<p>660<br>01:12:32,079 –&gt; 01:12:36,319<br>membership and all that kind of thing. Uh, but basically the zookeeper and the connection manager</p>
<p>661<br>01:12:36,319 –&gt; 01:12:40,239<br>really decided, okay, well, this is the decision, the configuration, the current configuration we’re</p>
<p>662<br>01:12:40,239 –&gt; 01:12:45,199<br>running in, the user, the regions, how they’re mapped, the primers and backups, and all that stuff.</p>
<p>663<br>01:12:46,559 –&gt; 01:12:51,119<br>And if any failure happens, you know, there’s a whole reconfiguration process going on and recovery.</p>
<p>664<br>01:12:53,359 –&gt; 01:12:54,079<br>Let me see. Thank you.</p>
<p>665<br>01:13:00,800 –&gt; 01:13:07,359<br>Okay. Uh, maybe I’m going to skip the breakout room. Uh, I guess I can go a little bit further.</p>
<p>666<br>01:13:08,159 –&gt; 01:13:13,439<br>The question, you know, I want to answer the question that, uh, in the, that was asking the</p>
<p>667<br>01:13:13,439 –&gt; 01:13:17,839<br>post in the lecture, and I’m going to, uh, as a lecture question, I’m just going to do that by</p>
<p>668<br>01:13:17,839 –&gt; 01:13:22,639<br>talking about an example transaction. And this also comes to a really a question about, uh, you know,</p>
<p>669<br>01:13:22,639 –&gt; 01:13:28,239<br>what happens, you know, two transactions run and it rent one version and then it commits, blah, blah, blah,</p>
<p>670<br>01:13:28,239 –&gt; 01:13:34,399<br>all like all this stuff. So, uh, so these are really the topic here is going to do we get strict serializability.</p>
<p>671<br>01:13:37,359 –&gt; 01:13:43,039<br>And what I’m going to do is like I’m not going to give you proof, you know, I’m getting strict</p>
<p>672<br>01:13:43,039 –&gt; 01:13:46,399<br>rounds, I will be instead, but I’m going to do is I’m going to go walk from one of two examples,</p>
<p>673<br>01:13:47,519 –&gt; 01:13:51,839<br>to give build up some intuition. And hopefully that intuition, you know, sort of convinced us,</p>
<p>674<br>01:13:51,839 –&gt; 01:13:56,000<br>you know, that things might actually be fine. So let’s, let’s look at the following</p>
<p>675<br>01:13:56,000 –&gt; 01:14:02,800<br>transaction, we have to pretend again. And this transaction is, you know, uh, like in the beginning,</p>
<p>676<br>01:14:02,800 –&gt; 01:14:03,760<br>that reads an object,</p>
<p>677<br>01:14:08,640 –&gt; 01:14:09,199<br>adds one,</p>
<p>678<br>01:14:13,199 –&gt; 01:14:13,920<br>and then writes,</p>
<p>679<br>01:14:18,239 –&gt; 01:14:24,159<br>the object, and commits, or ends, which commit my fail,</p>
<p>680<br>01:14:26,000 –&gt; 01:14:32,239<br>for that’s the transaction. And you know, we want to ask ourselves like what are the legal outcomes,</p>
<p>681<br>01:14:32,239 –&gt; 01:14:34,159<br>right? What are the outcomes they’re correct?</p>
<p>682<br>01:14:42,159 –&gt; 01:14:44,960<br>Uh, so what are the possible outcomes of this transaction?</p>
<p>683<br>01:14:47,279 –&gt; 01:14:52,399<br>What it could be the state of, let’s say X started at zero and we’re running two transactions,</p>
<p>684<br>01:14:52,399 –&gt; 01:15:00,639<br>you know, T1 and T2. What are the possible outcomes that are fine?</p>
<p>685<br>01:15:04,079 –&gt; 01:15:07,519<br>Um, either one of them could commit or both of them could commit.</p>
<p>686<br>01:15:08,239 –&gt; 01:15:12,000<br>Yeah, and so we can have X2, correct, both commits.</p>
<p>687<br>01:15:13,279 –&gt; 01:15:17,439<br>X is one, it’s a possibility of one commits and you want another board to definitely true</p>
<p>688<br>01:15:17,439 –&gt; 01:15:21,199<br>to run concurrently or something. And any other possible outcomes?</p>
<p>689<br>01:15:23,919 –&gt; 01:15:29,519<br>Yeah, zero, if you know basically both aboard, right? Maybe there’s a crash.</p>
<p>690<br>01:15:30,960 –&gt; 01:15:36,799<br>Okay, so those are the free legal outcomes. Um, and so let’s, we just make that the matured of this</p>
<p>691<br>01:15:36,799 –&gt; 01:15:43,519<br>the case. So let’s say T1 runs, and so does a read operation, it gets X back, maybe at version zero,</p>
<p>692<br>01:15:44,160 –&gt; 01:15:52,080<br>same thing with T2, it reads, you know, uh, X is zero. Um, and so it gets basically to run</p>
<p>693<br>01:15:52,080 –&gt; 01:15:56,640<br>truly concurrent. And you know, this is the question I think that sort of was asked in the</p>
<p>694<br>01:15:56,640 –&gt; 01:16:03,840<br>locks, because we do a lock effects, we do a lock effects. And um, and here sort of the crucial step,</p>
<p>695<br>01:16:03,840 –&gt; 01:16:10,400<br>correct? Because at this particular point, uh, we’re trying to get the locks on object zero.</p>
<p>696<br>01:16:10,399 –&gt; 01:16:17,759<br>And uh, can both succeed in reading, um, getting the lock X.</p>
<p>697<br>01:16:18,639 –&gt; 01:16:21,599<br>Oh, and getting the lock, um, not at the same time.</p>
<p>698<br>01:16:22,239 –&gt; 01:16:27,279<br>No, so one is going to, one is going to succeed, correct? And so let’s say the first one succeeds</p>
<p>699<br>01:16:27,279 –&gt; 01:16:35,359<br>and gets the lock, that means it can commit, right? So this guy will commit, um, and what happens</p>
<p>700<br>01:16:35,359 –&gt; 01:16:40,479<br>with the second guy? Um, the second one, if it tries to obtain the lock at the same time,</p>
<p>701<br>01:16:40,479 –&gt; 01:16:45,279<br>that the first one is holding the lock, it’ll abort and stop. Um, if the first transaction goes</p>
<p>702<br>01:16:45,279 –&gt; 01:16:50,559<br>through all the way and the lock is released, then it will obtain the lock and then check to see</p>
<p>703<br>01:16:50,559 –&gt; 01:16:56,559<br>whether the version that it has for X is still correct. Um, and it will find that the version has been</p>
<p>704<br>01:16:56,559 –&gt; 01:17:02,000<br>changed and then it will abort. Yep, you have to get this exactly the, the two, the two cases.</p>
<p>705<br>01:17:02,000 –&gt; 01:17:05,359<br>And so let me talk about the validation case in the, in the second book of slight,</p>
<p>706<br>01:17:05,359 –&gt; 01:17:09,760<br>you different example to make it more interesting. Uh, but this is basically the outcome, correct?</p>
<p>707<br>01:17:11,520 –&gt; 01:17:16,239<br>Good. And so, uh, even though these transactions mean this particular picture ran, you know,</p>
<p>708<br>01:17:16,239 –&gt; 01:17:21,920<br>exactly at the same time, uh, they’re actually getting ordered and one wins and the other one loses.</p>
<p>709<br>01:17:21,920 –&gt; 01:17:26,640<br>And that means that the other one that lost can run again. It will run, then read our X is one</p>
<p>710<br>01:17:26,640 –&gt; 01:17:29,840<br>and then hopefully succeed in the retry. Okay?</p>
<p>711<br>01:17:32,720 –&gt; 01:17:45,279<br>Okay, so, um, uh, okay, let me do one example and then I’ll stop in a resume on, uh, on, on, on,</p>
<p>712<br>01:17:45,279 –&gt; 01:17:51,680<br>Thursday. Uh, what time is it’s 24? Let me show you, just stop here and then, uh, I’ll do a second</p>
<p>713<br>01:17:51,680 –&gt; 01:17:58,640<br>example that, uh, that answers that earlier question, uh, on, on, on, on Thursday and, uh, also talk about</p>
<p>714<br>01:17:58,640 –&gt; 01:18:02,320<br>full tolerance. Uh, I don’t know when we’re in too much overtime.</p>
<p>715<br>01:18:04,000 –&gt; 01:18:10,000<br>Uh, anybody that has to go, you feel free to go. Uh, and I’ll see you on Thursday. Uh, anybody</p>
<p>716<br>01:18:10,000 –&gt; 01:18:15,119<br>who has, would like to ask more questions, you know, please say that, feel free to stay and I’ll</p>
<p>717<br>01:18:15,119 –&gt; 01:18:21,520<br>try to start the best to answer that. As you see, this is a complicated paper. Uh, and, you know,</p>
<p>718<br>01:18:21,520 –&gt; 01:18:24,640<br>I’m glad that we’re going out, we’re able to go and sort of depth, you know, trying to really</p>
<p>719<br>01:18:24,640 –&gt; 01:18:29,039<br>understand at least the, the, the protocol for normal operation.</p>
<p>720<br>01:18:32,480 –&gt; 01:18:36,800<br>So, let that time, just like when I finished this lecture and you know, see your first thing,</p>
<p>721<br>01:18:36,800 –&gt; 01:18:38,640<br>or if you have any questions, please hang around.</p>
<p>722<br>01:18:40,720 –&gt; 01:18:49,920<br>Uh, I had to, like, the hell of a question, it’s fun. Was, um, this, this whole hardware structure</p>
<p>723<br>01:18:50,000 –&gt; 01:18:55,680<br>that they’re using, would it be useful at all if you’re using it with pessimistic concurrency control?</p>
<p>724<br>01:18:57,039 –&gt; 01:19:00,880<br>Yes. Maybe, you know, I’m sure you can make the pessimistic concurrency pro also better because</p>
<p>725<br>01:19:00,880 –&gt; 01:19:05,760<br>you’re like, your RPCs are just cheaper, correct? Uh, but the real thing, and I haven’t gotten,</p>
<p>726<br>01:19:05,760 –&gt; 01:19:11,119<br>I haven’t been able to point this out yet, but I was planning to, but I can do now, uh, is if you</p>
<p>727<br>01:19:11,119 –&gt; 01:19:17,279<br>look at the read-only transactions here, so read-only transactions. So if you’re a transaction,</p>
<p>728<br>01:19:17,279 –&gt; 01:19:20,479<br>the basically only read-only objects were multiple objects.</p>
<p>729<br>01:19:24,800 –&gt; 01:19:28,000<br>What’s the performance? How good is that? Like, how well is that going to perform?</p>
<p>730<br>01:19:30,479 –&gt; 01:19:34,880<br>Um, probably pretty well since you only do the one-sided.</p>
<p>731<br>01:19:35,439 –&gt; 01:19:40,800<br>Yeah, correct. So if you look at the object that is stored at, uh, reaching free, correct,</p>
<p>732<br>01:19:40,800 –&gt; 01:19:44,880<br>which is the object that’s being read, the only thing that happens is one-sided reads.</p>
<p>733<br>01:19:48,239 –&gt; 01:19:49,920<br>Or one-sided RBMA, correct?</p>
<p>734<br>01:19:51,439 –&gt; 01:20:01,039<br>Uh, and there’s no, uh, rights, uh, nothing at all. Uh, so, uh, those, uh, because of the, uh, this,</p>
<p>735<br>01:20:02,639 –&gt; 01:20:06,079<br>because the read-occurations don’t require walks. There’s nothing to be written.</p>
<p>736<br>01:20:07,359 –&gt; 01:20:11,439<br>Only thing that needs to happen is this validation step, which is also the one-sided RBMA.</p>
<p>737<br>01:20:12,079 –&gt; 01:20:15,279<br>So read-only transactions can just run with two one-sided RBMAs.</p>
<p>738<br>01:20:16,239 –&gt; 01:20:18,800<br>Um, and that’s where the big one comes from.</p>
<p>739<br>01:20:19,439 –&gt; 01:20:23,679<br>And, and the reason that that big point is there is because of the optimistic concurrency control.</p>
<p>740<br>01:20:24,319 –&gt; 01:20:29,759<br>So I think basically to exploit RBMA’s sort of tools foolish, foolish, and I’m trying to make</p>
<p>741<br>01:20:29,759 –&gt; 01:20:36,239<br>read-only transactions really, really fast, um, uh, they got, went to optimistic concurrency control.</p>
<p>742<br>01:20:38,399 –&gt; 01:20:43,840<br>Okay, I see, I see. It makes sense. I met a question about, but security is</p>
<p>743<br>01:20:44,800 –&gt; 01:20:51,039<br>this thing is it going to be secure if it’s, um, I guess the, someone already asked about this, but</p>
<p>744<br>01:20:51,920 –&gt; 01:20:57,119<br>the part where the neck just reads memory, it seems a little scary, so.</p>
<p>745<br>01:20:57,119 –&gt; 01:21:01,279<br>Yeah, yeah, yeah, yeah, it is. It’s a long and scary, right? Uh, and so there, there’s, there’s some</p>
<p>746<br>01:21:01,279 –&gt; 01:21:06,800<br>large of interaction, uh, between, you know, when the RBMA connection is set up, uh, the operating system</p>
<p>747<br>01:21:06,800 –&gt; 01:21:13,039<br>and the application. So the operating system won’t allow, you know, the neck to right to any</p>
<p>748<br>01:21:13,119 –&gt; 01:21:18,159<br>arbitrary location. It will tell it, you know, you’re the addresses, you hear the, uh, VM,</p>
<p>749<br>01:21:18,159 –&gt; 01:21:22,960<br>their delivery addresses that you can write to. Okay, so you can make that</p>
<p>750<br>01:21:23,680 –&gt; 01:21:31,199<br>production. Yeah, okay, okay, okay, okay, okay. I think about the performance. Yep. So if you have,</p>
<p>751<br>01:21:31,199 –&gt; 01:21:38,239<br>so the reads are quick because of the one-sided RBMA’s. Yep. But if you have a lot of rights</p>
<p>752<br>01:21:38,239 –&gt; 01:21:45,199<br>happening, like a lot of data and contention, um, yes, or no, correct? Like what happens if you</p>
<p>753<br>01:21:45,199 –&gt; 01:21:53,359<br>have contention? Actually, we saw this in this particular case, correct? Yeah, and we have a lot</p>
<p>754<br>01:21:53,359 –&gt; 01:22:00,239<br>of contention, one of the transactionable abort. So this is really good for transactions that don’t</p>
<p>755<br>01:22:00,239 –&gt; 01:22:06,479<br>contente or not writing through the same records or same objects. And even the reads, right?</p>
<p>756<br>01:22:07,439 –&gt; 01:22:09,839<br>Yeah, even the reads, right? Because the version numbers might change.</p>
<p>757<br>01:22:13,199 –&gt; 01:22:16,079<br>So what’s like the main, um, I guess, use case for…</p>
<p>758<br>01:22:17,039 –&gt; 01:22:20,959<br>There’s a lot of, okay, so there’s a lot of studies independent of this paper about</p>
<p>759<br>01:22:20,959 –&gt; 01:22:26,879<br>pessimistic versus optimistic concurrency control. And, you know, clearly from the two benchmarks</p>
<p>760<br>01:22:26,879 –&gt; 01:22:32,879<br>that they use in the paper, like TPCC and TATP, there’s not a lot of, not a lot of conflicts.</p>
<p>761<br>01:22:32,880 –&gt; 01:22:39,279<br>So the transactions are submitted maybe by different users or different clients and they basically</p>
<p>762<br>01:22:39,279 –&gt; 01:22:51,600<br>touch different tables. So I have a question, if there’s multiple clients doing transactions</p>
<p>763<br>01:22:51,600 –&gt; 01:22:59,920<br>on the same objects, how… So they want to do a right RDMA, right? To the log.</p>
<p>764<br>01:23:00,079 –&gt; 01:23:07,440<br>Is it possible that there will be like a conflict, like, you know, like one of them will write over</p>
<p>765<br>01:23:07,440 –&gt; 01:23:14,319<br>the other log or… No, no, no, no, there’s one log per pair. One log per pair. So every…</p>
<p>766<br>01:23:14,319 –&gt; 01:23:22,480<br>This is a joke of the reason why. And then, but in the transactions, like, time, is it like,</p>
<p>767<br>01:23:22,480 –&gt; 01:23:28,560<br>you know, like to provide serializability? Is it timed based on what?</p>
<p>768<br>01:23:29,280 –&gt; 01:23:34,160<br>On the version numbers. There’s nothing like true time or anything like that here.</p>
<p>769<br>01:23:35,039 –&gt; 01:23:39,680<br>These logical numbers, like in same way as in Latvian, where you have logical sequence numbers</p>
<p>770<br>01:23:40,640 –&gt; 01:23:45,360<br>for implementing your T-value store. The version numbers play a good play the same role.</p>
<p>771<br>01:23:45,839 –&gt; 01:24:01,920<br>Well, if two transactions got the same number, then only the one that got to the command point first</p>
<p>772<br>01:24:01,920 –&gt; 01:24:08,479<br>is going to get… This is this case, right? One will board, the other ones will succeed.</p>
<p>773<br>01:24:08,479 –&gt; 01:24:17,199<br>If there’s a message queue that is basically established between every pair,</p>
<p>774<br>01:24:17,839 –&gt; 01:24:22,079<br>then how do you know… So then you would have multiple message queues.</p>
<p>775<br>01:24:22,879 –&gt; 01:24:27,919<br>Like in primary. How do you know which order to read those in? So you don’t read them out of order.</p>
<p>776<br>01:24:31,119 –&gt; 01:24:35,119<br>There is… You read all the messages from one source in the same order,</p>
<p>777<br>01:24:35,279 –&gt; 01:24:39,439<br>because they’re all going to be in one queue. So one source writes to one queue.</p>
<p>778<br>01:24:40,800 –&gt; 01:24:48,000<br>Multiple machines might write, you know, concurrently, to different queues. You don’t know what the order</p>
<p>779<br>01:24:48,000 –&gt; 01:24:52,720<br>anyway is. So it couldn’t affect the correctness of the protocol.</p>
<p>780<br>01:24:54,239 –&gt; 01:24:58,880<br>I see. So we don’t rely on the orderings of the incoming concurrent messages.</p>
<p>781<br>01:24:58,880 –&gt; 01:25:02,640<br>That’s correct. You know, you pull them in some order and then you pull the queues in some order,</p>
<p>782<br>01:25:02,640 –&gt; 01:25:05,039<br>and that’s the way that they’re going to be processed.</p>
<p>783<br>01:25:06,960 –&gt; 01:25:13,520<br>Got it. I also have one more specific question. There’s a part where there’s a paper that</p>
<p>784<br>01:25:13,520 –&gt; 01:25:21,920<br>it provides lock-free reads, which we’ve just talked about. But it also provides locality hints,</p>
<p>785<br>01:25:21,920 –&gt; 01:25:27,360<br>which enable programmers to correlate related objects on the same set of machines.</p>
<p>786<br>01:25:27,360 –&gt; 01:25:31,760<br>Yeah. And I did not understand that the latter part of the sentence.</p>
<p>787<br>01:25:33,200 –&gt; 01:25:37,920<br>Okay, so I have to look up the details what it is, but I think what it’s referring to is that if you,</p>
<p>788<br>01:25:38,720 –&gt; 01:25:42,640<br>if you objects are all kinds of different regions, right, like let’s look at this picture here,</p>
<p>789<br>01:25:43,280 –&gt; 01:25:48,320<br>then you would have to talk to lots of different primaries, right? So if you’re like, you’re object 1,</p>
<p>790<br>01:25:48,320 –&gt; 01:25:53,760<br>you know, it’s in this primary, object 2 is in this primary, and if you’re touching many of the</p>
<p>791<br>01:25:53,760 –&gt; 01:25:57,760<br>city, if you’re touching always a cluster of objects together, it would be nice if that cluster of</p>
<p>792<br>01:25:57,760 –&gt; 01:26:02,160<br>objects is all at the same primary. So if you only have to contact one primary instead of many,</p>
<p>793<br>01:26:03,600 –&gt; 01:26:06,560<br>I see. Thank you.</p>
<p>794<br>01:26:13,119 –&gt; 01:26:14,240<br>Any further questions?</p>
<p>795<br>01:26:18,400 –&gt; 01:26:23,680<br>So this, so farms are not really suitable for long transactions, right?</p>
<p>796<br>01:26:25,200 –&gt; 01:26:27,200<br>Because of the misinterference.</p>
<p>797<br>01:26:27,200 –&gt; 01:26:30,000<br>Yeah, you’re more of the longer transactions that you get complex.</p>
<p>798<br>01:26:30,319 –&gt; 01:26:39,439<br>I mean, it also is assuming, I guess, read only transactions since we’re really optimized for them, right?</p>
<p>799<br>01:26:39,439 –&gt; 01:26:44,079<br>Yeah, absolutely. And many of the transactions that people have done studies and, you know,</p>
<p>800<br>01:26:44,079 –&gt; 01:26:49,039<br>and you saw them in the spare paper too, correct? We’re a long fraction of the transactions are read only</p>
<p>801<br>01:26:49,039 –&gt; 01:26:55,199<br>transactions. But that’s clearly a property of the workload.</p>
<p>802<br>01:27:02,079 –&gt; 01:27:08,479<br>I think going to have asked my earlier question, I think I realized I was misunderstanding</p>
<p>803<br>01:27:09,439 –&gt; 01:27:17,600<br>basic about strict serializability. Is it so strict? Okay, so here’s a situation.</p>
<p>804<br>01:27:19,199 –&gt; 01:27:22,560<br>Say there’s one transaction that begins first that writes,</p>
<p>805<br>01:27:23,439 –&gt; 01:27:25,920<br>shard one, shard two, and read shard three.</p>
<p>806<br>01:27:27,680 –&gt; 01:27:32,000<br>So that begins like first at time. Okay, write, write, object,</p>
<p>807<br>01:27:33,359 –&gt; 01:27:39,439<br>zero, write, zero, write x at zero, write y at zero, and then read z.</p>
<p>808<br>01:27:40,159 –&gt; 01:27:48,239<br>Okay, read zero. And then say there’s the second transaction that begins after</p>
<p>809<br>01:27:48,239 –&gt; 01:27:54,319<br>transaction one has started. You know, like here? Yeah, and it writes z.</p>
<p>810<br>01:27:55,679 –&gt; 01:27:59,199<br>So before it writes you, there must have read z, char.</p>
<p>811<br>01:28:00,159 –&gt; 01:28:03,759<br>Yeah, and so, read z, what version number does it read?</p>
<p>812<br>01:28:04,400 –&gt; 01:28:08,880<br>The same one, two, one.</p>
<p>813<br>01:28:10,880 –&gt; 01:28:13,199<br>And then say it reads, then it tries to write z.</p>
<p>814<br>01:28:15,440 –&gt; 01:28:19,680<br>Yep. And then say t2 commits before t1 commits.</p>
<p>815<br>01:28:24,079 –&gt; 01:28:25,680<br>Yes, okay, so this commits, yeah.</p>
<p>816<br>01:28:26,560 –&gt; 01:28:28,960<br>And then t1 commits after t2 commits.</p>
<p>817<br>01:28:29,039 –&gt; 01:28:33,439<br>Or we’ll try to commit, correct? And now we’ll start doing this whole, the whole lock,</p>
<p>818<br>01:28:33,439 –&gt; 01:28:39,920<br>the validation, blah, blah, blah, correct? So before, before, so what’s going to happen,</p>
<p>819<br>01:28:39,920 –&gt; 01:28:43,680<br>correct? Is you know, I was going to get to do this example. That’s an example that I’m</p>
<p>820<br>01:28:43,680 –&gt; 01:28:48,800<br>saving for next lecture, but yeah, basically a bit happens, correct? z will be good,</p>
<p>821<br>01:28:48,800 –&gt; 01:28:53,920<br>z will be good at one. At this point, the z will be a version one, correct?</p>
<p>822<br>01:28:54,560 –&gt; 01:28:57,439<br>So the validation phase will run after the commit. That’s what you said.</p>
<p>823<br>01:28:58,000 –&gt; 01:29:03,519<br>Right. And so here’s a validation of z. And you know, it has zero, correct?</p>
<p>824<br>01:29:03,519 –&gt; 01:29:06,559<br>And then that was one and will this rejection will be a board?</p>
<p>825<br>01:29:07,279 –&gt; 01:29:13,119<br>Okay, so this is what I was wondering about then. So because after the validation phase passes,</p>
<p>826<br>01:29:13,119 –&gt; 01:29:19,519<br>there’s a period of time, after the validation phase passes, a period of time passes,</p>
<p>827<br>01:29:19,519 –&gt; 01:29:25,679<br>the data commits. What if this validation happened before t2 committed? So it still saw the old</p>
<p>828<br>01:29:25,760 –&gt; 01:29:30,320<br>version number? It cannot happen because the after the validation,</p>
<p>829<br>01:29:33,280 –&gt; 01:29:38,240<br>after the commit has completed, correct? The commit backup, you know, has recorded,</p>
<p>830<br>01:29:38,240 –&gt; 01:29:44,240<br>and the primary after more have made to change. Before the application is returned,</p>
<p>831<br>01:29:44,240 –&gt; 01:29:46,560<br>before the after made returns, the energy has been updated.</p>
<p>832<br>01:29:46,560 –&gt; 01:29:57,760<br>I guess what I’m saying is isn’t it possible for t1’s validation phase to happen before,</p>
<p>833<br>01:29:58,800 –&gt; 01:30:04,080<br>I guess maybe what I’m trying to say is isn’t it possible that t2’s commit happens between</p>
<p>834<br>01:30:04,080 –&gt; 01:30:10,080<br>t1’s validate? It happens after t1’s validate, but before t1’s commit?</p>
<p>835<br>01:30:10,720 –&gt; 01:30:17,039<br>Clearly, there’s a risk and there must be excluded.</p>
<p>836<br>01:30:21,519 –&gt; 01:30:28,000<br>And it’s excluded. So you’re worried, let me construct this case and maybe I’ll come back</p>
<p>837<br>01:30:28,000 –&gt; 01:30:31,920<br>to you next week when we’re going to talk anyway. But I think you’re worried about</p>
<p>838<br>01:30:32,399 –&gt; 01:30:36,480<br>let’s see if we can get the picture back. Years over years, we did.</p>
<p>839<br>01:30:39,359 –&gt; 01:30:45,279<br>This guy committed, so he was basically doing the commit phase, correct? This is t1.</p>
<p>840<br>01:30:46,800 –&gt; 01:30:57,680<br>After t2, actually, that’s a t2. So t2 is about doing is here, correct? And then t1 is coming in</p>
<p>841<br>01:30:58,240 –&gt; 01:31:08,400<br>before everything happens before t2 is finished, so t1’s validation also comes in here.</p>
<p>842<br>01:31:09,920 –&gt; 01:31:11,920<br>Okay, let me rewrite it and then we’ll get back to you.</p>
<p>843<br>01:31:11,920 –&gt; 01:31:15,360<br>Okay, I’ll read it through this. This is exactly what I wanted to talk about.</p>
<p>844<br>01:31:15,360 –&gt; 01:31:16,800<br>Okay, all right, thank you.</p>
<p>845<br>01:31:18,240 –&gt; 01:31:23,680<br>Just make sure you’re asking about t2 being like in between stage 2 and 3 of 2 on.</p>
<p>846<br>01:31:23,920 –&gt; 01:31:25,440<br>Yeah, exactly.</p>
<p>847<br>01:31:26,880 –&gt; 01:31:33,360<br>But in that case, then t2, we could we could serialize it as t2 coming in before t1, right?</p>
<p>848<br>01:31:33,360 –&gt; 01:31:33,600<br>Yep.</p>
<p>849<br>01:31:35,520 –&gt; 01:31:42,400<br>So let’s get back to this on first. I have an example of where this is going to go over top of it.</p>
<p>850<br>01:31:46,560 –&gt; 01:31:52,560<br>Sorry, in the validation stage, you just read the version number.</p>
<p>851<br>01:31:52,560 –&gt; 01:31:53,440<br>Yep.</p>
<p>852<br>01:31:58,240 –&gt; 01:32:01,920<br>And serializability allows us to reorder transactions.</p>
<p>853<br>01:32:01,920 –&gt; 01:32:05,840<br>Yeah, but strict serialization will not, correct? Like even if it’s injection,</p>
<p>854<br>01:32:05,840 –&gt; 01:32:10,240<br>strict serializer requires that even transaction starts if somebody asks somebody committed,</p>
<p>855<br>01:32:10,240 –&gt; 01:32:12,480<br>that transaction is also committed after that transaction.</p>
<p>856<br>01:32:14,160 –&gt; 01:32:14,480<br>Right.</p>
<p>857<br>01:32:15,200 –&gt; 01:32:18,480<br>With this vertical guarantee, because of the version number.</p>
<p>858<br>01:32:18,879 –&gt; 01:32:20,639<br>Got it. Thank you.</p>
<p>859<br>01:32:21,839 –&gt; 01:32:31,439<br>But strict serializability doesn’t, if like if t2 ends, it’s not enough for t1 that end after t2 ends.</p>
<p>860<br>01:32:32,319 –&gt; 01:32:38,000<br>t1 had to have started or maybe I need to think about this more, but I think that was this is</p>
<p>861<br>01:32:38,000 –&gt; 01:32:42,559<br>always stripping me up. There’s also a rule about when the transaction starts.</p>
<p>862<br>01:32:42,559 –&gt; 01:32:46,000<br>Yeah, well, what happens in real life, right?</p>
<p>863<br>01:32:46,000 –&gt; 01:32:50,479<br>But there’s actually starts with some particular point of time. And basically if t1,</p>
<p>864<br>01:32:51,600 –&gt; 01:32:53,680<br>if t2 starts after t1 commits,</p>
<p>865<br>01:32:56,239 –&gt; 01:33:02,479<br>right. So then it must be the case that t2 of yours, you know, t2, t1’s changes.</p>
<p>866<br>01:33:02,479 –&gt; 01:33:03,680<br>That’s strict serializability.</p>
<p>867<br>01:33:04,640 –&gt; 01:33:09,520<br>Right. But what happens to t2 starts and commits solely within</p>
<p>868<br>01:33:10,159 –&gt; 01:33:12,640<br>then it’s a concurrent transaction and either outcome is fine.</p>
<p>869<br>01:33:12,880 –&gt; 01:33:13,199<br>Okay.</p>
<p>870<br>01:33:13,840 –&gt; 01:33:15,760<br>I think the answer is for your call.</p>
<p>871<br>01:33:15,760 –&gt; 01:33:16,559<br>Yeah, yeah, yeah.</p>
<p>872<br>01:33:16,559 –&gt; 01:33:18,239<br>Yeah. I think that’s what I was going to use about.</p>
<p>873<br>01:33:19,760 –&gt; 01:33:26,159<br>One day, literally when t2 starts before t1 commits, it’s considered a concurrent transaction.</p>
<p>874<br>01:33:27,279 –&gt; 01:33:33,119<br>And so t1 or t2 can observe or can even be ordered before either app doesn’t matter.</p>
<p>875<br>01:33:33,119 –&gt; 01:33:35,840<br>Okay. Okay. Okay. Thank you.</p>
<p>876<br>01:33:35,840 –&gt; 01:33:38,079<br>I think it’s also the answer to your example.</p>
<p>877<br>01:33:38,079 –&gt; 01:33:40,159<br>Right. Right. Okay. Thank you.</p>
<p>878<br>01:33:40,559 –&gt; 01:33:42,479<br>Okay. We’re having a hub. We got it anyway already.</p>
<p>879<br>01:33:44,239 –&gt; 01:33:49,599<br>You’re saying if t2 start is like between the t1 starting to commit, right?</p>
<p>880<br>01:33:49,599 –&gt; 01:33:50,239<br>Yeah.</p>
<p>881<br>01:33:50,239 –&gt; 01:33:53,439<br>Like, then you know, we can we can go for it more after. It doesn’t matter.</p>
<p>882<br>01:33:53,439 –&gt; 01:33:54,000<br>Okay.</p>
<p>883<br>01:33:55,760 –&gt; 01:33:58,000<br>Oh, can I ask a logistics question?</p>
<p>884<br>01:33:58,800 –&gt; 01:34:03,840<br>Are ever in success, oh, a one, you post these slides too?</p>
<p>885<br>01:34:05,199 –&gt; 01:34:07,359<br>Yes. I mean, yeah, yeah, I didn’t do that here.</p>
<p>886<br>01:34:07,679 –&gt; 01:34:10,719<br>Uh, you’d like to be on the website?</p>
<p>887<br>01:34:11,279 –&gt; 01:34:15,759<br>I think slides are useful if if you just need to like look at the slides,</p>
<p>888<br>01:34:15,759 –&gt; 01:34:17,599<br>and you need to like scroll through the video.</p>
<p>889<br>01:34:18,159 –&gt; 01:34:20,880<br>Okay. Um, I’m going to be the first asking.</p>
<p>890<br>01:34:20,880 –&gt; 01:34:22,559<br>So this is why I haven’t done it.</p>
<p>891<br>01:34:22,559 –&gt; 01:34:23,519<br>Okay.</p>
<p>892<br>01:34:23,519 –&gt; 01:34:25,439<br>Yeah. Yeah. I’m happy to do it.</p>
<p>893<br>01:34:25,439 –&gt; 01:34:26,960<br>I do save them all.</p>
<p>894<br>01:34:29,679 –&gt; 01:34:30,639<br>Thank you so much.</p>
<p>895<br>01:34:30,639 –&gt; 01:34:31,119<br>Thank you.</p>
<p>896<br>01:34:31,119 –&gt; 01:34:32,719<br>That was that was a fun lecture.</p>
<p>897<br>01:34:32,719 –&gt; 01:34:33,039<br>Thanks.</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>MIT6824 P15Lecture15OptimisticConcurrencyControlFaRM</div>
      <div>http://example.com/2025/10/24/MIT6824 P15Lecture15OptimisticConcurrencyControlFaRM/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月24日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/24/MIT6824%20P16Lecture15continued-OptimisticConcurrencyControlFaRMpt2/" title="MIT6824 P16Lecture15continued OptimisticConcurrencyControlFaRMpt2">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">MIT6824 P16Lecture15continued OptimisticConcurrencyControlFaRMpt2</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/24/MIT6824%20P14Lecture14-Spanner/" title="MIT6824 P14Lecture14 Spanner">
                        <span class="hidden-mobile">MIT6824 P14Lecture14 Spanner</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
