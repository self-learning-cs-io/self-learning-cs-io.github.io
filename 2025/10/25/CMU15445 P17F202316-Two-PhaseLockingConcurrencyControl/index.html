

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="100:00:00,000 –&gt; 00:00:28,519Thank you DJ, that’s great. 200:00:28,519 –&gt; 00:00:35,240So did you have any takers for your Tiki Bar thing and the other performances that you had? 300:00:35,240 –&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="CMU15445 P17F202316 Two PhaseLockingConcurrencyControl">
<meta property="og:url" content="http://example.com/2025/10/25/CMU15445%20P17F202316-Two-PhaseLockingConcurrencyControl/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="100:00:00,000 –&gt; 00:00:28,519Thank you DJ, that’s great. 200:00:28,519 –&gt; 00:00:35,240So did you have any takers for your Tiki Bar thing and the other performances that you had? 300:00:35,240 –&amp;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-25T05:03:39.731Z">
<meta property="article:modified_time" content="2025-10-25T05:03:39.732Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>CMU15445 P17F202316 Two PhaseLockingConcurrencyControl - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CMU15445 P17F202316 Two PhaseLockingConcurrencyControl"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-25 13:03" pubdate>
          2025年10月25日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          100 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">CMU15445 P17F202316 Two PhaseLockingConcurrencyControl</h1>
            
            
              <div class="markdown-body">
                
                <p>1<br>00:00:00,000 –&gt; 00:00:28,519<br>Thank you DJ, that’s great.</p>
<p>2<br>00:00:28,519 –&gt; 00:00:35,240<br>So did you have any takers for your Tiki Bar thing and the other performances that you had?</p>
<p>3<br>00:00:35,240 –&gt; 00:00:40,039<br>I thought I was going to pay no attention.</p>
<p>4<br>00:00:40,039 –&gt; 00:00:42,000<br>Okay, okay, that’s great.</p>
<p>5<br>00:00:42,000 –&gt; 00:00:49,640<br>All right, so we are going to get started and needed to clean up a couple things that from</p>
<p>6<br>00:00:49,640 –&gt; 00:00:51,039<br>last lecture.</p>
<p>7<br>00:00:51,039 –&gt; 00:00:57,239<br>Remember this slide where we are looking at the interleaving when we are thinking about schedules</p>
<p>8<br>00:00:57,240 –&gt; 00:01:03,320<br>and we had this schedule and this schedule is actually a correct schedule, right, even though</p>
<p>9<br>00:01:03,320 –&gt; 00:01:12,120<br>there is interleaving because T1 makes change to A, then T2 makes change to A by giving 6%</p>
<p>10<br>00:01:12,120 –&gt; 00:01:13,120<br>interest.</p>
<p>11<br>00:01:13,120 –&gt; 00:01:19,200<br>T1 then comes back and makes changes to B, so puts back the $100 from A to B. So now A and</p>
<p>12<br>00:01:19,200 –&gt; 00:01:21,879<br>B, the sum of that is consistent.</p>
<p>13<br>00:01:21,879 –&gt; 00:01:28,280<br>So now when T2 goes and adds 6% interest to B, this correct, even though there was interleaving,</p>
<p>14<br>00:01:28,280 –&gt; 00:01:33,159<br>that interleaving was safe and you ended up with one of the two legitimate ways in which</p>
<p>15<br>00:01:33,159 –&gt; 00:01:39,519<br>to do this transaction because you had the right final value in the database.</p>
<p>16<br>00:01:39,519 –&gt; 00:01:45,159<br>Okay, so even though this interleaving at first seems like, oh, it shouldn’t work out, if</p>
<p>17<br>00:01:45,159 –&gt; 00:01:49,319<br>this B happened before this read of B, then we would be off.</p>
<p>18<br>00:01:49,319 –&gt; 00:01:51,159<br>Okay, does that make sense?</p>
<p>19<br>00:01:51,159 –&gt; 00:01:59,560<br>The bottom value will still be the same because this is the same as having run T1 followed</p>
<p>20<br>00:01:59,560 –&gt; 00:02:01,280<br>by T2 and that is the whole point.</p>
<p>21<br>00:02:01,280 –&gt; 00:02:03,640<br>This schedule is okay, all right.</p>
<p>22<br>00:02:03,640 –&gt; 00:02:08,840<br>So the main point is some interleaving is okay, some interleaving is not and the whole</p>
<p>23<br>00:02:08,840 –&gt; 00:02:13,840<br>purpose with what we will talk about today is when to determine, is there a mechanism</p>
<p>24<br>00:02:13,840 –&gt; 00:02:17,199<br>to go and determine how to make everything safe.</p>
<p>25<br>00:02:17,199 –&gt; 00:02:23,679<br>The next slide was something that is not safe, which is essentially, T1 starts to make</p>
<p>26<br>00:02:23,679 –&gt; 00:02:31,399<br>change to A, then T2 starts to make changes to both A and B and then T1 makes the remaining</p>
<p>27<br>00:02:31,399 –&gt; 00:02:37,679<br>change that needed to make in its transaction to B and so bad value for A was seen by T2</p>
<p>28<br>00:02:37,679 –&gt; 00:02:42,560<br>and the final result for the values of A and B doesn’t correspond to anyone of the serial</p>
<p>29<br>00:02:42,560 –&gt; 00:02:43,560<br>schedules.</p>
<p>30<br>00:02:43,560 –&gt; 00:02:48,360<br>So we talked about why specifically that T2 is equal to like that, the specific number</p>
<p>31<br>00:02:48,360 –&gt; 00:02:55,159<br>was okay and like how we have to determine specifically that value.</p>
<p>32<br>00:02:55,159 –&gt; 00:02:58,120<br>We talked about that last class, but let me go back to that, right?</p>
<p>33<br>00:02:58,120 –&gt; 00:03:02,719<br>So the whole definition because it’s important, the whole definition of serial schedule is</p>
<p>34<br>00:03:02,719 –&gt; 00:03:10,759<br>that if I’ve got these two transactions, T1 and T2 and I can have a schedule in which T1</p>
<p>35<br>00:03:10,759 –&gt; 00:03:14,840<br>runs followed by T2 and I’ll get a certain number or vice versa.</p>
<p>36<br>00:03:14,840 –&gt; 00:03:21,479<br>So here is the diagram which we’ll come back again in a different form in a little bit</p>
<p>37<br>00:03:21,479 –&gt; 00:03:23,399<br>in about 40 minutes from now.</p>
<p>38<br>00:03:23,399 –&gt; 00:03:29,959<br>Let me just go to that slide in which we had the serial schedule, skip, skip, skip.</p>
<p>39<br>00:03:29,959 –&gt; 00:03:33,719<br>I guess what I was saying, what is there not that?</p>
<p>40<br>00:03:33,719 –&gt; 00:03:39,079<br>If you remember to, and then there’s all of these things, but the point would be 3D.</p>
<p>41<br>00:03:39,080 –&gt; 00:03:40,719<br>Yeah, that’s, so okay.</p>
<p>42<br>00:03:40,719 –&gt; 00:03:43,560<br>So this is the motion of correctness.</p>
<p>43<br>00:03:43,560 –&gt; 00:03:48,400<br>So the question is, T1 followed by T2, there were two possible ways in which the database</p>
<p>44<br>00:03:48,400 –&gt; 00:03:50,280<br>could end up with, right?</p>
<p>45<br>00:03:50,280 –&gt; 00:03:52,680<br>And what we are saying is both of them are correct.</p>
<p>46<br>00:03:52,680 –&gt; 00:03:57,960<br>Both are not correct because we are operating under the serializable assumption that these</p>
<p>47<br>00:03:57,960 –&gt; 00:03:59,760<br>are conflict serializable.</p>
<p>48<br>00:03:59,760 –&gt; 00:04:04,200<br>If we were to say strictly serializable that there’s only one order T1 followed by T2 because</p>
<p>49<br>00:04:04,199 –&gt; 00:04:11,799<br>T1 started first, that would be a more restrictive form of a concurrency control and we wouldn’t</p>
<p>50<br>00:04:11,799 –&gt; 00:04:15,519<br>allow as much parallelism with transactions overlapping with each other.</p>
<p>51<br>00:04:15,519 –&gt; 00:04:17,399<br>So we are doing something that seems funny.</p>
<p>52<br>00:04:17,399 –&gt; 00:04:23,839<br>We are saying it’s okay if T1 came first, but the way in which the database state is,</p>
<p>53<br>00:04:23,839 –&gt; 00:04:27,800<br>looks like T2 ran all of it followed by T1 and that order is okay.</p>
<p>54<br>00:04:27,800 –&gt; 00:04:33,560<br>So we are accepting that little discrepancy because we want to allow more parallelization.</p>
<p>55<br>00:04:33,560 –&gt; 00:04:36,959<br>If we didn’t want to, we could do something, we can come up with a new concurrency control</p>
<p>56<br>00:04:36,959 –&gt; 00:04:41,800<br>protocol in which a simple one, not a good idea, but a simple one that will work with that</p>
<p>57<br>00:04:41,800 –&gt; 00:04:48,000<br>intuitive notion is say if T1 arrives before T2, T1 locks the entire database and then T2</p>
<p>58<br>00:04:48,000 –&gt; 00:04:49,000<br>runs.</p>
<p>59<br>00:04:49,000 –&gt; 00:04:53,199<br>That was the default mechanism by which we would get this isolation property, but it</p>
<p>60<br>00:04:53,199 –&gt; 00:04:54,199<br>would work.</p>
<p>61<br>00:04:54,199 –&gt; 00:04:58,800<br>Everything would seem logical, but you wouldn’t allow enough parallelism in the system.</p>
<p>62<br>00:04:59,360 –&gt; 00:05:05,759<br>Okay, and as I mentioned last time is Spanner has this notion where this T1 followed by T2</p>
<p>63<br>00:05:05,759 –&gt; 00:05:07,000<br>is feeling odd, right?</p>
<p>64<br>00:05:07,000 –&gt; 00:05:12,040<br>Because we are saying a schedule in which T2 finishes and changes the state of the database</p>
<p>65<br>00:05:12,040 –&gt; 00:05:18,120<br>and T1 runs is a fine final state for the database that seems odd because T1 arrives first</p>
<p>66<br>00:05:18,120 –&gt; 00:05:20,000<br>in all the examples we have.</p>
<p>67<br>00:05:20,000 –&gt; 00:05:26,840<br>So Spanner has this additional notion of strict serializable in which it says if they arrive</p>
<p>68<br>00:05:26,839 –&gt; 00:05:31,239<br>in a certain order, then we will actually make it more meaningful while still in a long</p>
<p>69<br>00:05:31,239 –&gt; 00:05:32,239<br>parallelism.</p>
<p>70<br>00:05:32,239 –&gt; 00:05:36,919<br>The protocol is really complicated and I flashed that slide at the end to say if you’re interested</p>
<p>71<br>00:05:36,919 –&gt; 00:05:40,639<br>go take a look at that paper and there’s all kinds of interesting stuff.</p>
<p>72<br>00:05:40,639 –&gt; 00:05:45,439<br>And Cockroach DB is Spanner like, but doesn’t require the atomic clocks that Spanner requires.</p>
<p>73<br>00:05:45,439 –&gt; 00:05:50,000<br>They actually Google keeps the data centers synced the clocks on each of those synced</p>
<p>74<br>00:05:50,000 –&gt; 00:05:54,719<br>that allows them to figure out how much should I hold back a transaction so that I can know</p>
<p>75<br>00:05:54,720 –&gt; 00:05:58,280<br>if some of the transactions started in real time before it so that you’re done in the</p>
<p>76<br>00:05:58,280 –&gt; 00:05:59,280<br>same time order.</p>
<p>77<br>00:05:59,280 –&gt; 00:06:03,920<br>So it’s complicated and take the advanced database class for that but the confusion you</p>
<p>78<br>00:06:03,920 –&gt; 00:06:07,520<br>having and the questions that you guys are asking is like, doesn’t it seem failed</p>
<p>79<br>00:06:07,520 –&gt; 00:06:08,520<br>weird?</p>
<p>80<br>00:06:08,520 –&gt; 00:06:14,080<br>It does feel weird because we are operating under this more relaxed notion of a conflict</p>
<p>81<br>00:06:14,080 –&gt; 00:06:15,080<br>serializer.</p>
<p>82<br>00:06:15,080 –&gt; 00:06:20,680<br>We are saying we’ll allow these schedules because the performance that we need is high enough</p>
<p>83<br>00:06:20,680 –&gt; 00:06:24,079<br>and the change in semantics is reasonable that we think applications are going to be</p>
<p>84<br>00:06:24,079 –&gt; 00:06:25,079<br>fine with it.</p>
<p>85<br>00:06:25,079 –&gt; 00:06:32,319<br>So this is a universal result or like solution.</p>
<p>86<br>00:06:32,319 –&gt; 00:06:33,319<br>Yeah.</p>
<p>87<br>00:06:33,319 –&gt; 00:06:37,160<br>So the question is what’s the universe of solutions if there’s a universe of schedules?</p>
<p>88<br>00:06:37,160 –&gt; 00:06:41,680<br>They will mirror that because conflict serializable will give a certain set of potential solutions</p>
<p>89<br>00:06:41,680 –&gt; 00:06:42,759<br>for the end database, right?</p>
<p>90<br>00:06:42,759 –&gt; 00:06:46,439<br>If you have two transactions, anyone of those two, if there are three, the permutation</p>
<p>91<br>00:06:46,439 –&gt; 00:06:47,439<br>of that.</p>
<p>92<br>00:06:47,680 –&gt; 00:06:51,439<br>It also embodies what’s final state of the database if you had concurrent actions.</p>
<p>93<br>00:06:51,439 –&gt; 00:06:52,439<br>They mirror each other.</p>
<p>94<br>00:06:52,439 –&gt; 00:06:59,319<br>So if I understand your question correct, it’s about like what can you say about the</p>
<p>95<br>00:06:59,319 –&gt; 00:07:01,680<br>properties of the final values in the database?</p>
<p>96<br>00:07:01,680 –&gt; 00:07:03,519<br>They exactly are the definition of this.</p>
<p>97<br>00:07:03,519 –&gt; 00:07:04,879<br>They are one and the same.</p>
<p>98<br>00:07:04,879 –&gt; 00:07:05,879<br>Yep.</p>
<p>99<br>00:07:05,879 –&gt; 00:07:07,120<br>All right.</p>
<p>100<br>00:07:07,120 –&gt; 00:07:12,159<br>Other questions on this before we move on to the topic for today?</p>
<p>101<br>00:07:12,159 –&gt; 00:07:15,399<br>We’ll come back to this diagram in a different form.</p>
<p>102<br>00:07:15,399 –&gt; 00:07:20,599<br>So let’s close this out and bring up the next deck.</p>
<p>103<br>00:07:20,599 –&gt; 00:07:22,399<br>All right.</p>
<p>104<br>00:07:22,399 –&gt; 00:07:31,000<br>So today we’ll talk about two-faced locking and the part that we will worry about is how</p>
<p>105<br>00:07:31,000 –&gt; 00:07:32,759<br>do we make all of these mechanisms happen?</p>
<p>106<br>00:07:32,759 –&gt; 00:07:35,239<br>We talked about dependence graphs in the last slide.</p>
<p>107<br>00:07:35,239 –&gt; 00:07:39,560<br>But before we jump into today’s topic, just there was a request for Project 3 to push</p>
<p>108<br>00:07:39,560 –&gt; 00:07:42,679<br>back the date because we were a few days out in getting that to you.</p>
<p>109<br>00:07:42,680 –&gt; 00:07:44,560<br>So we moved it back by seven days.</p>
<p>110<br>00:07:44,560 –&gt; 00:07:46,120<br>Hopefully you don’t need all the seven days.</p>
<p>111<br>00:07:46,120 –&gt; 00:07:48,120<br>But if you do, you have it.</p>
<p>112<br>00:07:48,120 –&gt; 00:07:51,959<br>As I mentioned in the last class, there are lots of moving parts in the project.</p>
<p>113<br>00:07:51,959 –&gt; 00:07:55,199<br>So don’t wait till like two days before the deadline to do it.</p>
<p>114<br>00:07:55,199 –&gt; 00:07:59,000<br>It will seem harder than it is if you wait that long.</p>
<p>115<br>00:07:59,000 –&gt; 00:08:00,000<br>Okay.</p>
<p>116<br>00:08:00,000 –&gt; 00:08:02,000<br>Knock out the simple things first.</p>
<p>117<br>00:08:02,000 –&gt; 00:08:08,840<br>Humber 4 got pushed out earlier today and that’s due on November 12th.</p>
<p>118<br>00:08:08,840 –&gt; 00:08:09,840<br>All right.</p>
<p>119<br>00:08:10,479 –&gt; 00:08:10,839<br>Okay.</p>
<p>120<br>00:08:10,839 –&gt; 00:08:14,519<br>So let’s jump into the topic for today.</p>
<p>121<br>00:08:14,519 –&gt; 00:08:19,919<br>We will concern ourselves with this conflict serializable class of schedules that we want</p>
<p>122<br>00:08:19,919 –&gt; 00:08:21,599<br>to allow.</p>
<p>123<br>00:08:21,599 –&gt; 00:08:25,519<br>And remember, we also talked about view serializable in which if I knew a little bit about the application</p>
<p>124<br>00:08:25,519 –&gt; 00:08:30,719<br>semantics, I could allow a few more schedules, that tends to be very hard to enforce and practice</p>
<p>125<br>00:08:30,719 –&gt; 00:08:36,559<br>no one does that, but the textbooks have it so that you just know what those things are.</p>
<p>126<br>00:08:36,559 –&gt; 00:08:38,959<br>It’s good to understand that.</p>
<p>127<br>00:08:38,960 –&gt; 00:08:43,000<br>But we’ll focus on conflict serializable and how do we make that work.</p>
<p>128<br>00:08:43,000 –&gt; 00:08:48,040<br>So last class, we said, if you start to draw the dependence graph, you see a cycle we</p>
<p>129<br>00:08:48,040 –&gt; 00:08:49,840<br>are in trouble, right?</p>
<p>130<br>00:08:49,840 –&gt; 00:08:54,360<br>But how do you draw the cycle and we are drawing the cycle after the schedule was done?</p>
<p>131<br>00:08:54,360 –&gt; 00:08:56,000<br>So it’s like, is it too late?</p>
<p>132<br>00:08:56,000 –&gt; 00:08:58,840<br>How do you make sure that these cycles don’t form?</p>
<p>133<br>00:08:58,840 –&gt; 00:09:02,759<br>AKA, give us this notion of correctness that we are looking for, right?</p>
<p>134<br>00:09:02,759 –&gt; 00:09:04,400<br>When is it safe to interleave actions?</p>
<p>135<br>00:09:04,400 –&gt; 00:09:06,240<br>So that’s what we’ll talk about.</p>
<p>136<br>00:09:06,240 –&gt; 00:09:09,080<br>And there are multiple ways to do it.</p>
<p>137<br>00:09:09,080 –&gt; 00:09:14,639<br>We’re going to talk about locks as a mechanism to do that today.</p>
<p>138<br>00:09:14,639 –&gt; 00:09:19,360<br>And if you remember last class, we said there are two broad classes of algorithms.</p>
<p>139<br>00:09:19,360 –&gt; 00:09:22,200<br>One is pessimistic and the other one is optimistic.</p>
<p>140<br>00:09:22,200 –&gt; 00:09:23,200<br>Locks are optimistic.</p>
<p>141<br>00:09:23,200 –&gt; 00:09:25,200<br>Locks are sorry, pessimistic.</p>
<p>142<br>00:09:25,200 –&gt; 00:09:29,720<br>They will try to stop a cycle from forming very early on.</p>
<p>143<br>00:09:29,720 –&gt; 00:09:34,200<br>And when we talk about optimistic, conference control protocols in the next class, we’ll</p>
<p>144<br>00:09:34,200 –&gt; 00:09:35,519<br>see they will do the opposite.</p>
<p>145<br>00:09:35,519 –&gt; 00:09:37,720<br>They’ll say, let everything go.</p>
<p>146<br>00:09:37,720 –&gt; 00:09:41,840<br>And in the end, I will check if something is unsafe, I know how to back out of the unsafe</p>
<p>147<br>00:09:41,840 –&gt; 00:09:42,840<br>parts.</p>
<p>148<br>00:09:42,840 –&gt; 00:09:47,879<br>And locking says, if two things are trying to conflict with each other, they will probably</p>
<p>149<br>00:09:47,879 –&gt; 00:09:48,879<br>do bad things.</p>
<p>150<br>00:09:48,879 –&gt; 00:09:50,960<br>Let me stop them at first touch.</p>
<p>151<br>00:09:50,960 –&gt; 00:09:56,079<br>So that’s what we will talk about today, the lock based pessimistic, concurrency control</p>
<p>152<br>00:09:56,079 –&gt; 00:09:58,000<br>mechanisms.</p>
<p>153<br>00:09:58,000 –&gt; 00:09:59,559<br>So what does it mean?</p>
<p>154<br>00:09:59,559 –&gt; 00:10:03,039<br>You played around with latches, which you did in your very first C++ assignment.</p>
<p>155<br>00:10:03,039 –&gt; 00:10:06,319<br>At that time, you were protecting a data structure in memory.</p>
<p>156<br>00:10:06,319 –&gt; 00:10:09,719<br>You put mechanism, the latch mechanism.</p>
<p>157<br>00:10:09,719 –&gt; 00:10:13,279<br>So that two threads, if they’re trying to make changes, that would have destroyed the data</p>
<p>158<br>00:10:13,279 –&gt; 00:10:15,199<br>structure, left it in a corrupt state.</p>
<p>159<br>00:10:15,199 –&gt; 00:10:16,719<br>That doesn’t happen.</p>
<p>160<br>00:10:16,719 –&gt; 00:10:19,799<br>Locks do the same thing, but for database stuff.</p>
<p>161<br>00:10:19,799 –&gt; 00:10:24,199<br>And what locks, the way you would do things with locks is imagine I have a schedule, I’m</p>
<p>162<br>00:10:24,199 –&gt; 00:10:25,279<br>reading and writing objects.</p>
<p>163<br>00:10:25,279 –&gt; 00:10:29,399<br>So here, you see true transaction, Steve, on NT2.</p>
<p>164<br>00:10:29,399 –&gt; 00:10:32,799<br>And what we’ll do is we will put locks.</p>
<p>165<br>00:10:32,799 –&gt; 00:10:39,079<br>Before we read or write an object, we will acquire the lock before we make that read or write</p>
<p>166<br>00:10:39,079 –&gt; 00:10:40,079<br>operation.</p>
<p>167<br>00:10:40,079 –&gt; 00:10:42,159<br>And locks will come in different forms.</p>
<p>168<br>00:10:42,159 –&gt; 00:10:43,439<br>We’ll get to that in a second.</p>
<p>169<br>00:10:43,439 –&gt; 00:10:47,120<br>But now just as you, before we read A, we will apply the lock.</p>
<p>170<br>00:10:47,120 –&gt; 00:10:52,839<br>And as you see transaction, T1, as it goes a bit further down, after it is done with all</p>
<p>171<br>00:10:52,839 –&gt; 00:10:57,279<br>the stuff it needed to make changes to the lock, it doesn’t unlock.</p>
<p>172<br>00:10:57,279 –&gt; 00:11:02,159<br>Very much like what we’ve been using with the latches in the data structures you were trying</p>
<p>173<br>00:11:02,159 –&gt; 00:11:03,159<br>to protect.</p>
<p>174<br>00:11:03,159 –&gt; 00:11:05,839<br>And similarly, T2 will follow that same protocol.</p>
<p>175<br>00:11:05,839 –&gt; 00:11:11,879<br>And so effectively, there’s this lock manager, which maintains a data structure.</p>
<p>176<br>00:11:11,879 –&gt; 00:11:17,159<br>And it’s going to get requests for saying, here’s the object I want to lock.</p>
<p>177<br>00:11:17,159 –&gt; 00:11:20,279<br>And as you’ll see in a little bit, it’ll also have information about the mode in which</p>
<p>178<br>00:11:20,279 –&gt; 00:11:22,159<br>it wants to lock, exclusive and shared.</p>
<p>179<br>00:11:22,159 –&gt; 00:11:23,879<br>And saying, here’s who I am.</p>
<p>180<br>00:11:23,879 –&gt; 00:11:25,279<br>I’m transaction T.</p>
<p>181<br>00:11:25,279 –&gt; 00:11:27,639<br>And please lock this object for me.</p>
<p>182<br>00:11:27,639 –&gt; 00:11:30,360<br>We won’t get into the details of what that lock manager looks like.</p>
<p>183<br>00:11:30,360 –&gt; 00:11:35,519<br>But it’s often organized as a hash table on the object ID that is being locked.</p>
<p>184<br>00:11:35,519 –&gt; 00:11:42,060<br>And then it will keep track of all the lock holders or holders who are requests to become</p>
<p>185<br>00:11:42,060 –&gt; 00:11:44,840<br>lock holders that have been put on a pending queue.</p>
<p>186<br>00:11:44,840 –&gt; 00:11:49,399<br>That’s all I’ll say about the lock data structure, how to maintain that and do that efficiently.</p>
<p>187<br>00:11:49,399 –&gt; 00:11:50,720<br>Is this super interesting topic?</p>
<p>188<br>00:11:50,720 –&gt; 00:11:54,039<br>If you are interested in those details, we can talk offline.</p>
<p>189<br>00:11:54,039 –&gt; 00:11:57,320<br>So it’s a structure that’s going to keep track of the locks.</p>
<p>190<br>00:11:57,320 –&gt; 00:12:01,960<br>And then at some point here, for example, that second lock request is to the same object</p>
<p>191<br>00:12:01,960 –&gt; 00:12:05,960<br>A. A is being held already by transaction T1.</p>
<p>192<br>00:12:05,960 –&gt; 00:12:07,480<br>So that’s what the lock manager will do.</p>
<p>193<br>00:12:07,480 –&gt; 00:12:10,560<br>It’ll say, whoops, you made that request.</p>
<p>194<br>00:12:10,560 –&gt; 00:12:12,160<br>I can’t grant you that request.</p>
<p>195<br>00:12:12,160 –&gt; 00:12:17,240<br>So transaction T2 gets blocked till that later point in time where the unlock request from</p>
<p>196<br>00:12:17,240 –&gt; 00:12:22,080<br>T1 comes in, the locks now open and T2 can get that request.</p>
<p>197<br>00:12:22,080 –&gt; 00:12:28,440<br>So same thing as you have with latches, locks are doing this here for database objects.</p>
<p>198<br>00:12:28,440 –&gt; 00:12:29,440<br>Okay.</p>
<p>199<br>00:12:29,440 –&gt; 00:12:34,040<br>This is said for now, you can just assume these objects A, B and C are records, but towards</p>
<p>200<br>00:12:34,040 –&gt; 00:12:39,160<br>the end of the class, we’ll talk about locking at different granularities and so on.</p>
<p>201<br>00:12:39,160 –&gt; 00:12:42,440<br>This transaction process and the lock manager will do its thing.</p>
<p>202<br>00:12:42,440 –&gt; 00:12:43,440<br>All right.</p>
<p>203<br>00:12:43,440 –&gt; 00:12:45,280<br>So today we’ll talk about these different lock types.</p>
<p>204<br>00:12:45,280 –&gt; 00:12:49,000<br>We’ll talk about a protocol called two-phase locking.</p>
<p>205<br>00:12:49,000 –&gt; 00:12:52,960<br>And then we’ll talk about some of the bad things that can happen when you do locking called</p>
<p>206<br>00:12:52,960 –&gt; 00:12:55,639<br>deadlocks and how we get around that.</p>
<p>207<br>00:12:55,639 –&gt; 00:13:00,679<br>And then time permitting will get to the hierarchical locking where we lock at different levels</p>
<p>208<br>00:13:00,679 –&gt; 00:13:09,320<br>in the tree, entire database, a table, a page, a record or even a column in a record.</p>
<p>209<br>00:13:09,320 –&gt; 00:13:14,759<br>Before we go, if you’ve taken an operating system class, you’ll probably find the terminology</p>
<p>210<br>00:13:14,759 –&gt; 00:13:20,439<br>over here confusing where when database folks talk about locks, they’re talking about</p>
<p>211<br>00:13:20,439 –&gt; 00:13:25,759<br>things that you’re doing to protect objects, database objects that sit on disk and have</p>
<p>212<br>00:13:25,759 –&gt; 00:13:30,919<br>a lifespan beyond its life and memory.</p>
<p>213<br>00:13:30,919 –&gt; 00:13:35,360<br>We call latches as the things that we want to protect in memory.</p>
<p>214<br>00:13:35,360 –&gt; 00:13:38,039<br>So this terminology is super important.</p>
<p>215<br>00:13:38,039 –&gt; 00:13:40,720<br>So let’s just go through what the differences are.</p>
<p>216<br>00:13:40,720 –&gt; 00:13:44,399<br>And for the longest time, the database folks could never talk to the operating system folks</p>
<p>217<br>00:13:44,399 –&gt; 00:13:48,399<br>because you’d get into like 80s and 90s and you’d say, I’m locking stuff and for them,</p>
<p>218<br>00:13:48,399 –&gt; 00:13:52,240<br>it was locking is the same as latching and the terminology was just way off.</p>
<p>219<br>00:13:52,240 –&gt; 00:13:56,679<br>But this is, even if you become an operating systems person, try to use the better terms</p>
<p>220<br>00:13:56,679 –&gt; 00:13:59,240<br>because they’re very different.</p>
<p>221<br>00:13:59,240 –&gt; 00:14:02,879<br>So locks are database concepts.</p>
<p>222<br>00:14:02,879 –&gt; 00:14:06,000<br>They try to separate user transactions, the T1s and C2.</p>
<p>223<br>00:14:06,000 –&gt; 00:14:09,279<br>We are trying to keep all these concurrent transactions from stepping on each other’s</p>
<p>224<br>00:14:09,919 –&gt; 00:14:13,879<br>latches are trying to keep the threads that are executing on a common data structure in</p>
<p>225<br>00:14:13,879 –&gt; 00:14:16,519<br>memory from stepping on each other’s doors.</p>
<p>226<br>00:14:16,519 –&gt; 00:14:22,319<br>Similar things but at very different levels in terms of what they are trying to do.</p>
<p>227<br>00:14:22,319 –&gt; 00:14:26,000<br>Locks are trying to protect the database contents latches are trying to protect some in memory</p>
<p>228<br>00:14:26,000 –&gt; 00:14:28,120<br>data structure.</p>
<p>229<br>00:14:28,120 –&gt; 00:14:33,480<br>The duration of a lock is the entire transaction whereas the duration of the latch is just</p>
<p>230<br>00:14:33,480 –&gt; 00:14:36,799<br>for the critical sections that the programmer writes.</p>
<p>231<br>00:14:36,799 –&gt; 00:14:40,919<br>Now we’re starting to see some of the differences that are going to emerge as we go further down.</p>
<p>232<br>00:14:40,919 –&gt; 00:14:45,039<br>The different modes for the locks often locks have dozens of different modes.</p>
<p>233<br>00:14:45,039 –&gt; 00:14:47,599<br>We’ll talk about that briefly today.</p>
<p>234<br>00:14:47,599 –&gt; 00:14:50,079<br>Latches are typically simple, weed and right.</p>
<p>235<br>00:14:50,079 –&gt; 00:14:54,559<br>Though latches have also started to become more sophisticated in many programming environments.</p>
<p>236<br>00:14:54,559 –&gt; 00:14:57,399<br>Besides, weed and writes are different levels in there.</p>
<p>237<br>00:14:57,399 –&gt; 00:15:02,199<br>And we’ll talk about that within the context of locks towards the end of this lecture.</p>
<p>238<br>00:15:02,199 –&gt; 00:15:06,599<br>Locks end up needing some mechanism when you get into trouble with locks that are acquired</p>
<p>239<br>00:15:06,600 –&gt; 00:15:08,200<br>so that no progress can be made.</p>
<p>240<br>00:15:08,200 –&gt; 00:15:12,720<br>It’s called deadlocks in the locking scenario and we’ll talk about mechanisms to deal with that.</p>
<p>241<br>00:15:12,720 –&gt; 00:15:17,000<br>Latches the way you avoid that situation where a thread has grabbed the resource,</p>
<p>242<br>00:15:17,000 –&gt; 00:15:21,159<br>another thread has grabbed another resource and now they try to ask for the opposite set of</p>
<p>243<br>00:15:21,159 –&gt; 00:15:21,960<br>resource.</p>
<p>244<br>00:15:21,960 –&gt; 00:15:23,639<br>They will get into trouble.</p>
<p>245<br>00:15:23,639 –&gt; 00:15:28,519<br>The way you avoid that with latches is you say, I as a programmer will write the code so</p>
<p>246<br>00:15:28,519 –&gt; 00:15:30,080<br>that it never happens.</p>
<p>247<br>00:15:30,080 –&gt; 00:15:33,000<br>So it’s a programmer’s responsibility.</p>
<p>248<br>00:15:33,000 –&gt; 00:15:34,160<br>Database guys are nice.</p>
<p>249<br>00:15:34,159 –&gt; 00:15:37,519<br>We actually put into the system mechanism so that if that happens, we can catch it and</p>
<p>250<br>00:15:37,519 –&gt; 00:15:39,000<br>come out of that.</p>
<p>251<br>00:15:39,000 –&gt; 00:15:43,319<br>And typically when you’re using latches in some C++ code, for example, you will say, I’ll</p>
<p>252<br>00:15:43,319 –&gt; 00:15:44,759<br>always follow a sequence.</p>
<p>253<br>00:15:44,759 –&gt; 00:15:49,439<br>I’ll do action a followed by b followed by c so that you can never end up in this deadlock</p>
<p>254<br>00:15:49,439 –&gt; 00:15:50,439<br>situation.</p>
<p>255<br>00:15:50,439 –&gt; 00:15:55,279<br>But it’s the programmer’s responsibility to go and do that right.</p>
<p>256<br>00:15:55,279 –&gt; 00:15:59,319<br>Locks have these inbuilt deadlock mechanisms that allow you to get out of that trouble if</p>
<p>257<br>00:15:59,319 –&gt; 00:16:00,919<br>you get into that.</p>
<p>258<br>00:16:00,919 –&gt; 00:16:05,079<br>And the mechanisms for deadlocks as we’ll see, I’ll wait for and time out mechanisms, programmers</p>
<p>259<br>00:16:05,079 –&gt; 00:16:09,319<br>have to do that when they’re using latches.</p>
<p>260<br>00:16:09,319 –&gt; 00:16:14,519<br>Locks the state for the locks, who has what’s being requested by who is kept in the lock</p>
<p>261<br>00:16:14,519 –&gt; 00:16:15,839<br>manager.</p>
<p>262<br>00:16:15,839 –&gt; 00:16:19,719<br>And for latches when you’re writing that in your C++ code, it’s going to be some protected</p>
<p>263<br>00:16:19,719 –&gt; 00:16:20,719<br>data structure, right?</p>
<p>264<br>00:16:20,719 –&gt; 00:16:27,919<br>You might have a variable that you’re using to keep track of that latch object and that’s</p>
<p>265<br>00:16:27,919 –&gt; 00:16:28,919<br>what you do.</p>
<p>266<br>00:16:28,919 –&gt; 00:16:32,559<br>Latches are in memory, protect threats from getting into trouble.</p>
<p>267<br>00:16:32,559 –&gt; 00:16:38,519<br>Lot of programmer discipline is needed to make sure you don’t get into trouble.</p>
<p>268<br>00:16:38,519 –&gt; 00:16:43,120<br>Locks are for things that are on disk so they get help for a longer amount of time.</p>
<p>269<br>00:16:43,120 –&gt; 00:16:48,120<br>If you remember the graph, the chart that we had in terms of how much time does it take</p>
<p>270<br>00:16:48,120 –&gt; 00:16:52,639<br>to reach an object on disk versus in memory, there were many orders of magnitude.</p>
<p>271<br>00:16:52,639 –&gt; 00:16:56,799<br>So locks are going to be helped for longer amounts of time and they have a lot more mechanisms</p>
<p>272<br>00:16:56,799 –&gt; 00:16:59,279<br>associated with them like deadlock detection.</p>
<p>273<br>00:16:59,279 –&gt; 00:17:00,279<br>Question.</p>
<p>274<br>00:17:00,279 –&gt; 00:17:05,519<br>So there’s a different between the lock manager and the protected data structure.</p>
<p>275<br>00:17:05,519 –&gt; 00:17:07,559<br>Very good question.</p>
<p>276<br>00:17:07,559 –&gt; 00:17:11,759<br>So what’s the difference between the lock manager and the protected data structure?</p>
<p>277<br>00:17:11,759 –&gt; 00:17:16,159<br>The lock manager that I mentioned, which is this hash table, will be written and protected</p>
<p>278<br>00:17:16,159 –&gt; 00:17:17,159<br>by a latch.</p>
<p>279<br>00:17:17,159 –&gt; 00:17:21,680<br>So now he’s the lock manager that’s protected by a latch, which is all compatible still.</p>
<p>280<br>00:17:21,680 –&gt; 00:17:23,559<br>Lock manager is sitting in memory.</p>
<p>281<br>00:17:23,559 –&gt; 00:17:26,000<br>It’s a in memory data structure.</p>
<p>282<br>00:17:26,000 –&gt; 00:17:29,119<br>So transactions are trying to access it.</p>
<p>283<br>00:17:29,119 –&gt; 00:17:33,880<br>So you’ll protect the lock manager by a latch, which is an in memory stuff.</p>
<p>284<br>00:17:33,880 –&gt; 00:17:34,880<br>So they’re compatible.</p>
<p>285<br>00:17:34,880 –&gt; 00:17:39,079<br>A latch, the protected data structure, so these are not incompatible.</p>
<p>286<br>00:17:39,079 –&gt; 00:17:41,079<br>In database, you’ll actually see latches.</p>
<p>287<br>00:17:41,079 –&gt; 00:17:43,799<br>Lockmatch is a great example because that itself is latched.</p>
<p>288<br>00:17:43,799 –&gt; 00:17:46,599<br>And you probably don’t want to put a latch on the entire lock table.</p>
<p>289<br>00:17:46,599 –&gt; 00:17:51,599<br>So you’ll put latches on some chunks of it so that a single request is in block everywhere</p>
<p>290<br>00:17:51,599 –&gt; 00:17:54,559<br>because otherwise the lock manager will become the bottleneck.</p>
<p>291<br>00:17:54,559 –&gt; 00:17:59,799<br>What’s the difference between the proximity on the side?</p>
<p>292<br>00:17:59,799 –&gt; 00:18:01,480<br>They’re protecting very different things.</p>
<p>293<br>00:18:01,480 –&gt; 00:18:03,079<br>So think about the lock manager.</p>
<p>294<br>00:18:03,079 –&gt; 00:18:05,879<br>It’s protecting an in memory structure.</p>
<p>295<br>00:18:05,879 –&gt; 00:18:11,319<br>And the lock manager is protecting the record A and record B. That is in the buffer pool,</p>
<p>296<br>00:18:11,319 –&gt; 00:18:18,720<br>it may get evicted and go on this, but the lock is still held till the transaction is done.</p>
<p>297<br>00:18:18,720 –&gt; 00:18:22,440<br>And now there’s a related question is like when do these locks get acquired?</p>
<p>298<br>00:18:22,440 –&gt; 00:18:25,960<br>Now latch, when you acquire, you explicitly as a programmer writing a code to say acquire</p>
<p>299<br>00:18:25,960 –&gt; 00:18:28,640<br>this latch in this mode.</p>
<p>300<br>00:18:28,640 –&gt; 00:18:35,039<br>Locks, as you’ll see, get acquired implicitly by the database system and your in very rare</p>
<p>301<br>00:18:35,039 –&gt; 00:18:40,120<br>cases explicitly as a programmer in SQL specifying grab this lock.</p>
<p>302<br>00:18:40,120 –&gt; 00:18:45,000<br>And the simplest way you can understand that if you’re locking at the page level is your</p>
<p>303<br>00:18:45,000 –&gt; 00:18:46,799<br>buffer pool that you wrote.</p>
<p>304<br>00:18:46,799 –&gt; 00:18:50,360<br>Imagine the call to the buffer pool also said, hey, please identify which transaction</p>
<p>305<br>00:18:50,360 –&gt; 00:18:51,360<br>you are.</p>
<p>306<br>00:18:51,359 –&gt; 00:18:56,039<br>And oh, by the way, tell me whether you are a read lock or an exclusive lock.</p>
<p>307<br>00:18:56,039 –&gt; 00:19:01,199<br>In which case, the buffer manager called to the page can itself go and make the request</p>
<p>308<br>00:19:01,199 –&gt; 00:19:04,519<br>to the lock manager on behalf of the transaction’s work.</p>
<p>309<br>00:19:04,519 –&gt; 00:19:07,719<br>So that is at the page level, at the record level, it gets more complicated.</p>
<p>310<br>00:19:07,719 –&gt; 00:19:11,759<br>But that’s how databases written is that at appropriate points where the data access</p>
<p>311<br>00:19:11,759 –&gt; 00:19:14,719<br>happened, the locking request will be inbuilt into that.</p>
<p>312<br>00:19:14,719 –&gt; 00:19:18,359<br>So you as a database programmer don’t have to put lock request all over your code.</p>
<p>313<br>00:19:18,359 –&gt; 00:19:21,919<br>The right abstraction will take care of putting in that request.</p>
<p>314<br>00:19:21,919 –&gt; 00:19:24,839<br>And the page level stuff is the easiest to understand because you guys have written a</p>
<p>315<br>00:19:24,839 –&gt; 00:19:27,879<br>buffer pool so you can see how that would work.</p>
<p>316<br>00:19:27,879 –&gt; 00:19:31,799<br>Record level would go a little bit below at the access path for the record when you get</p>
<p>317<br>00:19:31,799 –&gt; 00:19:33,159<br>to the file.</p>
<p>318<br>00:19:33,159 –&gt; 00:19:36,799<br>And as you’re writing all this insert calls and other stuff in this project, you will</p>
<p>319<br>00:19:36,799 –&gt; 00:19:40,399<br>start to think about it like, oh, if I had a transaction management system, which is</p>
<p>320<br>00:19:40,399 –&gt; 00:19:43,399<br>by the way, coming as the next project, where would I put it?</p>
<p>321<br>00:19:43,399 –&gt; 00:19:46,559<br>It would be at one of these levels.</p>
<p>322<br>00:19:46,559 –&gt; 00:19:48,559<br>And the questions?</p>
<p>323<br>00:19:48,559 –&gt; 00:19:51,200<br>All right.</p>
<p>324<br>00:19:51,200 –&gt; 00:19:54,159<br>So we already started to allude towards that.</p>
<p>325<br>00:19:54,159 –&gt; 00:19:55,919<br>Locks come in at least two flavors.</p>
<p>326<br>00:19:55,919 –&gt; 00:19:57,200<br>There are many more.</p>
<p>327<br>00:19:57,200 –&gt; 00:20:03,679<br>A shared lock that says, I’m reading a someone else wants to read a, I don’t care.</p>
<p>328<br>00:20:03,679 –&gt; 00:20:07,480<br>The shared lock is compatible with another shared lock.</p>
<p>329<br>00:20:07,480 –&gt; 00:20:10,639<br>And this is the compatibility matrix.</p>
<p>330<br>00:20:10,639 –&gt; 00:20:15,359<br>And as we’ll see, sometimes there are a lot more lock types besides shared and exclusive.</p>
<p>331<br>00:20:15,359 –&gt; 00:20:18,559<br>And so this compatibility matrix can get bigger.</p>
<p>332<br>00:20:18,559 –&gt; 00:20:23,240<br>And all this is says is a shared lock is compatible with a shared lock, exclusive lock.</p>
<p>333<br>00:20:23,240 –&gt; 00:20:28,079<br>If someone has it on an object, you can get another exclusive lock on that object.</p>
<p>334<br>00:20:28,079 –&gt; 00:20:30,399<br>You can get another shared lock on that object.</p>
<p>335<br>00:20:30,399 –&gt; 00:20:32,879<br>It basically blocks everyone when they’re waiting for it.</p>
<p>336<br>00:20:32,879 –&gt; 00:20:33,879<br>Yep.</p>
<p>337<br>00:20:33,879 –&gt; 00:20:35,559<br>Yeah, we’ll come to that.</p>
<p>338<br>00:20:35,559 –&gt; 00:20:36,559<br>Just hold on to that.</p>
<p>339<br>00:20:36,559 –&gt; 00:20:39,119<br>It sounds bizarre that there are other kinds of locks.</p>
<p>340<br>00:20:39,119 –&gt; 00:20:43,039<br>There are all database systems have at least a dozen different types of locks to allow</p>
<p>341<br>00:20:43,039 –&gt; 00:20:45,759<br>even more parallelism than what we will allow.</p>
<p>342<br>00:20:45,759 –&gt; 00:20:50,159<br>So first we’ll just work with these simple locks and make everything safe.</p>
<p>343<br>00:20:50,159 –&gt; 00:20:53,159<br>And then we’ll very briefly talk about multiple different types of locks.</p>
<p>344<br>00:20:53,159 –&gt; 00:20:55,680<br>And there is a vast amount of material in that.</p>
<p>345<br>00:20:55,680 –&gt; 00:20:59,920<br>So again, this is like a plug for the advanced database class where we can go into that.</p>
<p>346<br>00:20:59,920 –&gt; 00:21:01,319<br>It’s to allow more parallelism.</p>
<p>347<br>00:21:01,319 –&gt; 00:21:05,440<br>So let’s work with just these simple locks and try and make it safe first.</p>
<p>348<br>00:21:05,440 –&gt; 00:21:06,440<br>Okay.</p>
<p>349<br>00:21:06,440 –&gt; 00:21:07,440<br>That’s a great question.</p>
<p>350<br>00:21:07,440 –&gt; 00:21:09,079<br>Why many locks?</p>
<p>351<br>00:21:09,079 –&gt; 00:21:14,679<br>There are systems that have over 50 different types of locks and a compatibility matrix which</p>
<p>352<br>00:21:14,679 –&gt; 00:21:16,720<br>will be like that to allow more parallelism.</p>
<p>353<br>00:21:16,720 –&gt; 00:21:18,279<br>It will allow more parallelism.</p>
<p>354<br>00:21:18,279 –&gt; 00:21:21,359<br>And I’ll get to the intuition of that with the exclusive locks in a little bit.</p>
<p>355<br>00:21:21,359 –&gt; 00:21:24,519<br>It seems like I don’t think there should be additional lock types.</p>
<p>356<br>00:21:24,519 –&gt; 00:21:26,000<br>But here’s an example.</p>
<p>357<br>00:21:26,000 –&gt; 00:21:31,480<br>The different systems over here, they will all let some form publish some information about</p>
<p>358<br>00:21:31,480 –&gt; 00:21:33,799<br>the different lock types that they have.</p>
<p>359<br>00:21:33,799 –&gt; 00:21:37,919<br>And what you saw flash up on screen, maybe I’ll just go back to it and let it come back</p>
<p>360<br>00:21:37,920 –&gt; 00:21:42,160<br>again is the compatibility matrix of things that have been disclosed.</p>
<p>361<br>00:21:42,160 –&gt; 00:21:45,640<br>And as you can see, there are tons and tons of different lock types.</p>
<p>362<br>00:21:45,640 –&gt; 00:21:47,720<br>It’s just not a two by two matrix.</p>
<p>363<br>00:21:47,720 –&gt; 00:21:49,720<br>It’s a much, much bigger matrix.</p>
<p>364<br>00:21:49,720 –&gt; 00:21:51,759<br>Okay.</p>
<p>365<br>00:21:51,759 –&gt; 00:21:52,759<br>And you can take a look.</p>
<p>366<br>00:21:52,759 –&gt; 00:21:55,880<br>You can actually find post-cresses information pretty readily.</p>
<p>367<br>00:21:55,880 –&gt; 00:21:58,160<br>I have another screenshot coming in the last slide.</p>
<p>368<br>00:21:58,160 –&gt; 00:22:02,360<br>But the manual is there and you can start to see some of that lock modes in there.</p>
<p>369<br>00:22:02,360 –&gt; 00:22:06,240<br>All of that is to allow more parallelism and make everything we talk about today also</p>
<p>370<br>00:22:06,240 –&gt; 00:22:07,240<br>safe.</p>
<p>371<br>00:22:08,200 –&gt; 00:22:12,200<br>But the first idea is like how do we work with locks correctly?</p>
<p>372<br>00:22:12,200 –&gt; 00:22:14,319<br>So let’s start on that topic first.</p>
<p>373<br>00:22:14,319 –&gt; 00:22:16,480<br>Staying with just two lock modes now.</p>
<p>374<br>00:22:16,480 –&gt; 00:22:17,240<br>All right.</p>
<p>375<br>00:22:17,240 –&gt; 00:22:22,720<br>So we will have transaction request locks.</p>
<p>376<br>00:22:22,720 –&gt; 00:22:26,160<br>And this is also a notion of lock upgrades which you’re basically going to ignore in this</p>
<p>377<br>00:22:26,160 –&gt; 00:22:27,160<br>class.</p>
<p>378<br>00:22:27,160 –&gt; 00:22:30,720<br>Again, the advanced database class covers that.</p>
<p>379<br>00:22:30,720 –&gt; 00:22:34,319<br>Because sometimes like if you take this buffer pool, if you’re locking at the page level,</p>
<p>380<br>00:22:34,319 –&gt; 00:22:39,639<br>you ask a request for a page in a SQL query and in an application that is a SQL query that</p>
<p>381<br>00:22:39,639 –&gt; 00:22:41,279<br>just scans all the records.</p>
<p>382<br>00:22:41,279 –&gt; 00:22:44,759<br>And then maybe in the next query in that same transaction, it says, I’m going to update</p>
<p>383<br>00:22:44,759 –&gt; 00:22:46,559<br>some of the records I saw.</p>
<p>384<br>00:22:46,559 –&gt; 00:22:48,639<br>So grab all the student records.</p>
<p>385<br>00:22:48,639 –&gt; 00:22:53,799<br>Oh, and for the students that have a B, make it a B plus.</p>
<p>386<br>00:22:53,799 –&gt; 00:22:57,919<br>So it’s only going to update some of the records that it scanned in the first one.</p>
<p>387<br>00:22:57,919 –&gt; 00:23:02,279<br>So the first one first query, it’s all part of the same transaction.</p>
<p>388<br>00:23:02,279 –&gt; 00:23:06,119<br>We just issue requests to fetch in pages to the buffer pool if you’re doing page level</p>
<p>389<br>00:23:06,119 –&gt; 00:23:09,519<br>locking and just grab read locks on it.</p>
<p>390<br>00:23:09,519 –&gt; 00:23:13,119<br>But then some of those pages in which the records of interest are present, you want to</p>
<p>391<br>00:23:13,119 –&gt; 00:23:15,960<br>go and make it a write lock and exclusive lock.</p>
<p>392<br>00:23:15,960 –&gt; 00:23:17,720<br>So that’s called a lock upgrade.</p>
<p>393<br>00:23:17,720 –&gt; 00:23:22,119<br>When the query is running, you don’t know what’s going to happen next.</p>
<p>394<br>00:23:22,119 –&gt; 00:23:25,119<br>When you’re creating that operation to read the page, you know what you want.</p>
<p>395<br>00:23:25,119 –&gt; 00:23:27,440<br>I want to read it because I’m a select query.</p>
<p>396<br>00:23:27,440 –&gt; 00:23:28,759<br>The next one is an update grade.</p>
<p>397<br>00:23:28,759 –&gt; 00:23:31,039<br>Now it needs to update stuff.</p>
<p>398<br>00:23:31,039 –&gt; 00:23:36,720<br>So there are this notion of lock upgrades, which is I, as a transaction, can have asked</p>
<p>399<br>00:23:36,720 –&gt; 00:23:37,720<br>for a read lock.</p>
<p>400<br>00:23:37,720 –&gt; 00:23:40,000<br>By the way, I’m not asking it directly.</p>
<p>401<br>00:23:40,000 –&gt; 00:23:41,879<br>Someone’s asking on my behalf.</p>
<p>402<br>00:23:41,879 –&gt; 00:23:43,480<br>I’m just disclosing what my operation is.</p>
<p>403<br>00:23:43,480 –&gt; 00:23:48,159<br>I’m reading a file and the buffer pool in this case could be asking for read level page</p>
<p>404<br>00:23:48,159 –&gt; 00:23:49,159<br>locks.</p>
<p>405<br>00:23:49,159 –&gt; 00:23:52,279<br>And the update transaction says, I’m getting this page from the buffer pool.</p>
<p>406<br>00:23:52,279 –&gt; 00:23:54,559<br>But oh, by the way, I’m going to change stuff on it.</p>
<p>407<br>00:23:54,559 –&gt; 00:23:58,599<br>So grab exclusive lock at the page level.</p>
<p>408<br>00:23:58,599 –&gt; 00:24:04,079<br>So in the same transaction, first of all, might come back to that same object, a, for a read</p>
<p>409<br>00:24:04,079 –&gt; 00:24:06,519<br>request, for a read lock.</p>
<p>410<br>00:24:06,519 –&gt; 00:24:10,119<br>And later on, it may get upgraded to an exclusive lock.</p>
<p>411<br>00:24:10,119 –&gt; 00:24:11,519<br>So those upgrades happen.</p>
<p>412<br>00:24:11,519 –&gt; 00:24:13,799<br>Everything we talk about works with that scheme.</p>
<p>413<br>00:24:13,799 –&gt; 00:24:15,799<br>There are a few more complications to deal about.</p>
<p>414<br>00:24:15,799 –&gt; 00:24:20,039<br>We will largely ignore that, but just wanted to know that these upgrades happen.</p>
<p>415<br>00:24:20,039 –&gt; 00:24:23,919<br>And the lock flow, the request is getting made on behalf of the queries that are being</p>
<p>416<br>00:24:23,920 –&gt; 00:24:29,120<br>sent at some appropriate abstraction in the database engine.</p>
<p>417<br>00:24:29,120 –&gt; 00:24:33,279<br>The database programmer is not writing explicit lock calls everywhere.</p>
<p>418<br>00:24:33,279 –&gt; 00:24:35,800<br>I’m lying a little bit when you have these dozen different lock modes.</p>
<p>419<br>00:24:35,800 –&gt; 00:24:39,920<br>In the B3 code, for example, you start to see the B3 programmer will have put in a bunch</p>
<p>420<br>00:24:39,920 –&gt; 00:24:42,000<br>of explicit lock calls.</p>
<p>421<br>00:24:42,000 –&gt; 00:24:43,600<br>So ignore that piece, right?</p>
<p>422<br>00:24:43,600 –&gt; 00:24:47,279<br>When you get into multiple lock modes, then you start to see lock calls start to show</p>
<p>423<br>00:24:47,279 –&gt; 00:24:48,800<br>off in specific place.</p>
<p>424<br>00:24:48,800 –&gt; 00:24:52,080<br>And when it’s a, you know, exclusive lock is too strict here.</p>
<p>425<br>00:24:52,079 –&gt; 00:24:55,839<br>And this weaker form of exclusive lock, because I know just what I’m doing.</p>
<p>426<br>00:24:55,839 –&gt; 00:24:58,399<br>And you already have some intuition for that type of stuff, right?</p>
<p>427<br>00:24:58,399 –&gt; 00:25:03,720<br>When you did the lock coupling in the B3, it was like, it was like latches at that time.</p>
<p>428<br>00:25:03,720 –&gt; 00:25:07,639<br>But you could see how you could let go of something at some point and be okay with being</p>
<p>429<br>00:25:07,639 –&gt; 00:25:11,679<br>quote unquote unsafe, because you know, semantically, all you care about is the structure of the</p>
<p>430<br>00:25:11,679 –&gt; 00:25:12,679<br>tree.</p>
<p>431<br>00:25:12,679 –&gt; 00:25:15,839<br>So you didn’t need to hold on to things for the whole time.</p>
<p>432<br>00:25:15,839 –&gt; 00:25:18,079<br>So it’s tricks like that that get played around.</p>
<p>433<br>00:25:18,079 –&gt; 00:25:22,000<br>That’s how you get this explosion of lock modes.</p>
<p>434<br>00:25:22,000 –&gt; 00:25:25,960<br>But again, for now, we’ll just talk about locks in that regular sense and lock upgrades</p>
<p>435<br>00:25:25,960 –&gt; 00:25:26,960<br>happen.</p>
<p>436<br>00:25:26,960 –&gt; 00:25:30,599<br>Lock manager will either grant the request or not grant a request.</p>
<p>437<br>00:25:30,599 –&gt; 00:25:33,799<br>We’ll play around with just these shared and exclusive locks.</p>
<p>438<br>00:25:33,799 –&gt; 00:25:38,519<br>And when an upgrade, when an up when a request comes in, it’s going to update this hash table</p>
<p>439<br>00:25:38,519 –&gt; 00:25:42,680<br>structure, which is protected by a latch to keep track of all the requests that have been</p>
<p>440<br>00:25:42,680 –&gt; 00:25:45,640<br>granted and all the requests that are pending.</p>
<p>441<br>00:25:45,640 –&gt; 00:25:47,400<br>All right.</p>
<p>442<br>00:25:47,400 –&gt; 00:25:50,599<br>So now let’s go back to our example.</p>
<p>443<br>00:25:50,599 –&gt; 00:25:52,959<br>We now have two different types of locks.</p>
<p>444<br>00:25:52,959 –&gt; 00:25:55,919<br>So on transaction T1, it’s not making just a lock request.</p>
<p>445<br>00:25:55,919 –&gt; 00:25:59,159<br>It’s going to say, I have an X lock request because I’m making changes to it.</p>
<p>446<br>00:25:59,159 –&gt; 00:26:00,919<br>I’m an update query.</p>
<p>447<br>00:26:00,919 –&gt; 00:26:02,399<br>And then it unlocks it.</p>
<p>448<br>00:26:02,399 –&gt; 00:26:06,159<br>Similarly, transaction T2 has an X lock request.</p>
<p>449<br>00:26:06,159 –&gt; 00:26:10,879<br>The second request from transaction T1 is a shared lock request for a because all it is</p>
<p>450<br>00:26:10,879 –&gt; 00:26:12,519<br>doing is reading it.</p>
<p>451<br>00:26:12,519 –&gt; 00:26:14,519<br>So now a protocol is slightly different.</p>
<p>452<br>00:26:14,519 –&gt; 00:26:18,439<br>We are not just going to say lock unlock, but we’re also going to say which type.</p>
<p>453<br>00:26:18,440 –&gt; 00:26:22,240<br>And then we shared locks are compatible with shared locks and the lock manager is going</p>
<p>454<br>00:26:22,240 –&gt; 00:26:25,360<br>to make all that grant and blocking requests.</p>
<p>455<br>00:26:25,360 –&gt; 00:26:26,360<br>Okay.</p>
<p>456<br>00:26:26,360 –&gt; 00:26:27,360<br>So pretty straightforward.</p>
<p>457<br>00:26:27,360 –&gt; 00:26:28,880<br>No magic so far.</p>
<p>458<br>00:26:28,880 –&gt; 00:26:29,880<br>All right.</p>
<p>459<br>00:26:29,880 –&gt; 00:26:31,120<br>Yup, question.</p>
<p>460<br>00:26:31,120 –&gt; 00:26:35,840<br>We will do that in a second.</p>
<p>461<br>00:26:35,840 –&gt; 00:26:36,840<br>We will.</p>
<p>462<br>00:26:36,840 –&gt; 00:26:39,120<br>So right now, this is not correct.</p>
<p>463<br>00:26:39,120 –&gt; 00:26:42,000<br>So if that’s what you’re thinking is like, hey, did locks make it work?</p>
<p>464<br>00:26:42,000 –&gt; 00:26:43,519<br>That’s exactly what we are saying.</p>
<p>465<br>00:26:43,519 –&gt; 00:26:47,360<br>This doesn’t mean if you just follow that protocol, I told you, which is not yet a protocol,</p>
<p>466<br>00:26:47,359 –&gt; 00:26:49,959<br>it’s just an idea saying lock stuff.</p>
<p>467<br>00:26:49,959 –&gt; 00:26:51,639<br>It is not correct.</p>
<p>468<br>00:26:51,639 –&gt; 00:26:53,079<br>And we will make it correct in a second.</p>
<p>469<br>00:26:53,079 –&gt; 00:27:00,359<br>So over here is exactly the scenario where we have this lock request, but see this unlock</p>
<p>470<br>00:27:00,359 –&gt; 00:27:03,399<br>for object A happened in T1.</p>
<p>471<br>00:27:03,399 –&gt; 00:27:09,399<br>And then that got read that got written by T2.</p>
<p>472<br>00:27:09,399 –&gt; 00:27:13,000<br>And then T1 reads back what T2 wrote.</p>
<p>473<br>00:27:13,000 –&gt; 00:27:16,759<br>So obviously now if you draw the dependence graph, we have formed a cycle.</p>
<p>474<br>00:27:16,759 –&gt; 00:27:19,160<br>Right there’s a right right request.</p>
<p>475<br>00:27:19,160 –&gt; 00:27:21,720<br>And then there’s a right read request.</p>
<p>476<br>00:27:21,720 –&gt; 00:27:26,480<br>And we have a schedule that is not serializable, right?</p>
<p>477<br>00:27:26,480 –&gt; 00:27:28,400<br>That is not conflict serializable.</p>
<p>478<br>00:27:28,400 –&gt; 00:27:29,400<br>So this is a bad schedule.</p>
<p>479<br>00:27:29,400 –&gt; 00:27:30,319<br>We don’t want to allow this.</p>
<p>480<br>00:27:30,319 –&gt; 00:27:33,920<br>This is leaves a database in an incorrect state.</p>
<p>481<br>00:27:33,920 –&gt; 00:27:34,920<br>Okay.</p>
<p>482<br>00:27:34,920 –&gt; 00:27:36,480<br>So we want to stop that.</p>
<p>483<br>00:27:36,480 –&gt; 00:27:40,720<br>So now locks are not enough, but they are necessary.</p>
<p>484<br>00:27:40,720 –&gt; 00:27:42,720<br>We need a little bit more.</p>
<p>485<br>00:27:42,720 –&gt; 00:27:45,480<br>And we need this thing called two phase locking.</p>
<p>486<br>00:27:45,480 –&gt; 00:27:50,400<br>And this was a breakthrough when the whole theory of two phase locking came about Jim Gray</p>
<p>487<br>00:27:50,400 –&gt; 00:27:53,440<br>and bunch of IBM folks invented that.</p>
<p>488<br>00:27:53,440 –&gt; 00:27:58,799<br>And Jim Gray got a Turing Award, a large part of that was based on this one paper in which</p>
<p>489<br>00:27:58,799 –&gt; 00:28:02,360<br>he talks about the whole theory of two phase locking and the strict two phase locking,</p>
<p>490<br>00:28:02,360 –&gt; 00:28:05,440<br>which we’ll talk about in a little bit, and lock hierarchies and all of that are the</p>
<p>491<br>00:28:05,440 –&gt; 00:28:06,680<br>fun stuff.</p>
<p>492<br>00:28:06,680 –&gt; 00:28:13,839<br>So two phase locking is a protocol that we need to start following to make locks actually</p>
<p>493<br>00:28:13,839 –&gt; 00:28:20,639<br>work to give us this serializable schedule, semantics that we want.</p>
<p>494<br>00:28:20,639 –&gt; 00:28:22,919<br>So we’ll do the following.</p>
<p>495<br>00:28:22,919 –&gt; 00:28:24,279<br>We will acquire locks.</p>
<p>496<br>00:28:24,279 –&gt; 00:28:26,519<br>There was no problem with that so far.</p>
<p>497<br>00:28:26,519 –&gt; 00:28:29,759<br>We must acquire locks before we make changes to the objects.</p>
<p>498<br>00:28:29,759 –&gt; 00:28:34,599<br>But the problem was when we acquired the locks, we let go of it too soon.</p>
<p>499<br>00:28:34,599 –&gt; 00:28:37,879<br>And others could start seeing incorrect data.</p>
<p>500<br>00:28:37,879 –&gt; 00:28:41,480<br>The problem was not that we have these locks in the wrong place.</p>
<p>501<br>00:28:41,480 –&gt; 00:28:47,240<br>The problem is this unlock of A happened to soon and we could start to see this transaction</p>
<p>502<br>00:28:47,240 –&gt; 00:28:51,200<br>T2 could start pick up changes of the transaction that has not yet committed.</p>
<p>503<br>00:28:51,200 –&gt; 00:28:54,360<br>So that’s what two phase locking is going to solve.</p>
<p>504<br>00:28:54,360 –&gt; 00:28:58,880<br>And saying we break up all requests from a transaction in two phases.</p>
<p>505<br>00:28:58,880 –&gt; 00:29:02,519<br>One is a growing phase in which they can keep making requests to the lock manager.</p>
<p>506<br>00:29:02,519 –&gt; 00:29:04,920<br>I as a lock manager is going to keep track.</p>
<p>507<br>00:29:04,920 –&gt; 00:29:08,640<br>Transaction T1 has made a request making more requests stuff like that.</p>
<p>508<br>00:29:08,640 –&gt; 00:29:12,720<br>The minute transaction starts to make an first unlock request.</p>
<p>509<br>00:29:12,720 –&gt; 00:29:17,640<br>I’m going to throw a flag in my lock manager and say T1 has left the growing phase is now</p>
<p>510<br>00:29:17,640 –&gt; 00:29:20,160<br>in the shrinking phase.</p>
<p>511<br>00:29:20,160 –&gt; 00:29:22,040<br>It’s starting to release locks.</p>
<p>512<br>00:29:22,040 –&gt; 00:29:26,720<br>And two phase protocols says once you go into the shrinking phase, you are not allowed</p>
<p>513<br>00:29:26,720 –&gt; 00:29:29,040<br>to ask for any more locks.</p>
<p>514<br>00:29:29,040 –&gt; 00:29:32,680<br>If you ask for any more locks, the lock manager will reject it.</p>
<p>515<br>00:29:32,680 –&gt; 00:29:36,759<br>You have to abort the transaction and start all over.</p>
<p>516<br>00:29:36,759 –&gt; 00:29:38,280<br>So why does it work?</p>
<p>517<br>00:29:38,279 –&gt; 00:29:40,720<br>Let’s see what does that mean.</p>
<p>518<br>00:29:40,720 –&gt; 00:29:46,599<br>If I look at the life of a single transaction, which is what is shown here.</p>
<p>519<br>00:29:46,599 –&gt; 00:29:51,039<br>And this is a single transaction with time on the x axis.</p>
<p>520<br>00:29:51,039 –&gt; 00:29:52,399<br>Y axis is the number of locks.</p>
<p>521<br>00:29:52,399 –&gt; 00:29:56,559<br>As you can see, the first phase where it is growing the locks, it’s acquiring locks,</p>
<p>522<br>00:29:56,559 –&gt; 00:30:00,200<br>acquiring locks, you know, maybe that greed request has come in the select query.</p>
<p>523<br>00:30:00,200 –&gt; 00:30:05,079<br>And it reaches a certain point and then it stays with all those locks and then starts dropping.</p>
<p>524<br>00:30:05,079 –&gt; 00:30:10,119<br>So it is shrinking in this phase over here and once it shrinks, it cannot go back up and</p>
<p>525<br>00:30:10,119 –&gt; 00:30:13,199<br>start to acquire new locks.</p>
<p>526<br>00:30:13,199 –&gt; 00:30:21,439<br>So for in this case, this point, which is the point at which it had grabbed all the locks</p>
<p>527<br>00:30:21,439 –&gt; 00:30:23,879<br>that needed is called the lock point.</p>
<p>528<br>00:30:23,879 –&gt; 00:30:28,279<br>And it’s this magical point which I’ll come back to in terms of what it real, what it</p>
<p>529<br>00:30:28,279 –&gt; 00:30:33,639<br>means in terms of the dependence graph that is getting induced behind the scenes.</p>
<p>530<br>00:30:33,640 –&gt; 00:30:37,960<br>So everyone with me so far as to what the protocol is for two phase locking.</p>
<p>531<br>00:30:37,960 –&gt; 00:30:41,080<br>So we can go up and then start to come down.</p>
<p>532<br>00:30:41,080 –&gt; 00:30:43,680<br>So it’s got to look like a mountain with no valleys.</p>
<p>533<br>00:30:43,680 –&gt; 00:30:45,759<br>It cannot have this valley.</p>
<p>534<br>00:30:45,759 –&gt; 00:30:47,000<br>Right?</p>
<p>535<br>00:30:47,000 –&gt; 00:30:49,680<br>It cannot be I start reaching that lock point.</p>
<p>536<br>00:30:49,680 –&gt; 00:30:51,960<br>I start dropping locks and I start to go up again.</p>
<p>537<br>00:30:51,960 –&gt; 00:30:52,960<br>Cannot do that.</p>
<p>538<br>00:30:52,960 –&gt; 00:30:55,759<br>That will cause a trouble cause trouble.</p>
<p>539<br>00:30:55,759 –&gt; 00:30:57,840<br>And the intuition is the following.</p>
<p>540<br>00:30:57,840 –&gt; 00:31:01,880<br>This is a two phase 2 PL violation, two phase locking violation.</p>
<p>541<br>00:31:01,880 –&gt; 00:31:06,480<br>The intuition, which I hope you can work out by yourself is why there’s two phase locking</p>
<p>542<br>00:31:06,480 –&gt; 00:31:07,480<br>work.</p>
<p>543<br>00:31:07,480 –&gt; 00:31:11,960<br>It’s because if I’ve got two transactions, I’ll go back to this slide.</p>
<p>544<br>00:31:11,960 –&gt; 00:31:15,640<br>If I’ve got two transactions like this is one transaction, another transaction will have</p>
<p>545<br>00:31:15,640 –&gt; 00:31:17,800<br>its own curve, right?</p>
<p>546<br>00:31:17,800 –&gt; 00:31:24,520<br>The transaction that reaches the lock point first is the one that will be the first transaction</p>
<p>547<br>00:31:24,520 –&gt; 00:31:27,280<br>in that final serial schedule.</p>
<p>548<br>00:31:27,280 –&gt; 00:31:30,320<br>So anyone who gets to all the locks they need that they want to conflict with.</p>
<p>549<br>00:31:30,319 –&gt; 00:31:33,799<br>So it’s like who reaches the top of the mountain first I’m before you.</p>
<p>550<br>00:31:33,799 –&gt; 00:31:39,439<br>That’s going to determine the database update in terms of that serializable schedule.</p>
<p>551<br>00:31:39,439 –&gt; 00:31:43,799<br>Okay, so that’s the intuition and that’s why it works.</p>
<p>552<br>00:31:43,799 –&gt; 00:31:44,799<br>Okay.</p>
<p>553<br>00:31:44,799 –&gt; 00:31:45,799<br>Question?</p>
<p>554<br>00:31:45,799 –&gt; 00:31:46,799<br>It’s all a lot of time.</p>
<p>555<br>00:31:46,799 –&gt; 00:31:47,799<br>It’s 111 and it’s the order of the transaction.</p>
<p>556<br>00:31:47,799 –&gt; 00:31:48,799<br>Yeah.</p>
<p>557<br>00:31:48,799 –&gt; 00:31:49,799<br>That’s the order of the transaction.</p>
<p>558<br>00:31:49,799 –&gt; 00:31:52,799<br>How are we making sure that it’s only 312?</p>
<p>559<br>00:31:52,799 –&gt; 00:32:03,960<br>Yeah, so that’s a great question.</p>
<p>560<br>00:32:03,960 –&gt; 00:32:09,440<br>So the question is how are we going to allow T1 from reaching the lock point first?</p>
<p>561<br>00:32:09,440 –&gt; 00:32:12,240<br>We are not going to, here’s what’s going to happen.</p>
<p>562<br>00:32:12,240 –&gt; 00:32:16,839<br>T1 and T2 can start doing the work as we look at the protocol in a little bit.</p>
<p>563<br>00:32:16,839 –&gt; 00:32:23,519<br>As soon as T1, either one of those T1 or T2, either one of them reaches the lock point first,</p>
<p>564<br>00:32:23,519 –&gt; 00:32:24,519<br>that will be the order.</p>
<p>565<br>00:32:24,519 –&gt; 00:32:29,160<br>If T2 reaches it first, see imagine T1 and T2 are running in two threads and they keep</p>
<p>566<br>00:32:29,160 –&gt; 00:32:31,319<br>contact switching or something like that, right?</p>
<p>567<br>00:32:31,319 –&gt; 00:32:35,559<br>And if T2 reaches the lock point first, it will be like the final state of the database is</p>
<p>568<br>00:32:35,559 –&gt; 00:32:37,440<br>T2 followed by T1.</p>
<p>569<br>00:32:37,440 –&gt; 00:32:42,880<br>So we can allow any arbitrary interleaving now and as long as we follow the two-faced</p>
<p>570<br>00:32:42,880 –&gt; 00:32:44,519<br>protocol, it doesn’t matter.</p>
<p>571<br>00:32:44,519 –&gt; 00:32:50,360<br>Whoever reaches that first is going to be ahead in that serial schedule.</p>
<p>572<br>00:32:50,360 –&gt; 00:32:51,640<br>And that’s the beauty, right?</p>
<p>573<br>00:32:51,640 –&gt; 00:32:53,960<br>You don’t have to do anything else with the timing.</p>
<p>574<br>00:32:53,960 –&gt; 00:32:55,600<br>Let the threads all run with each other.</p>
<p>575<br>00:32:55,600 –&gt; 00:32:58,640<br>Let there be hundreds of threads.</p>
<p>576<br>00:32:58,640 –&gt; 00:33:02,799<br>They can all compete for, they can still go after the same database.</p>
<p>577<br>00:33:02,799 –&gt; 00:33:06,240<br>As long as they all follow the lock protocol and two-faced locking, life is going to be</p>
<p>578<br>00:33:06,240 –&gt; 00:33:07,240<br>good.</p>
<p>579<br>00:33:07,240 –&gt; 00:33:08,240<br>Okay?</p>
<p>580<br>00:33:08,240 –&gt; 00:33:09,240<br>Question.</p>
<p>581<br>00:33:09,240 –&gt; 00:33:13,880<br>Q. Is this also what T1 creates of the failed threads and T2 is going to be contacted at</p>
<p>582<br>00:33:13,880 –&gt; 00:33:14,880<br>three threads?</p>
<p>583<br>00:33:14,880 –&gt; 00:33:16,319<br>Yeah, we’ll get to that.</p>
<p>584<br>00:33:16,319 –&gt; 00:33:18,720<br>That induces a deadlock and we’ll talk about that.</p>
<p>585<br>00:33:18,720 –&gt; 00:33:22,799<br>It won’t prevent a deadlock and we have mechanisms to deal with that in a second.</p>
<p>586<br>00:33:22,799 –&gt; 00:33:24,359<br>So hold that question.</p>
<p>587<br>00:33:24,359 –&gt; 00:33:29,279<br>If they go in opposite order, there’s a case where two-faced locking can still end up</p>
<p>588<br>00:33:29,279 –&gt; 00:33:33,039<br>with a situation where no progress is made, that’s called deadlocks and we’ll break it.</p>
<p>589<br>00:33:33,039 –&gt; 00:33:34,039<br>Okay?</p>
<p>590<br>00:33:34,039 –&gt; 00:33:36,039<br>Good thinking.</p>
<p>591<br>00:33:36,039 –&gt; 00:33:37,039<br>Question.</p>
<p>592<br>00:33:37,039 –&gt; 00:33:41,039<br>Q. Is the object in a preset order required?</p>
<p>593<br>00:33:41,039 –&gt; 00:33:42,039<br>Yes.</p>
<p>594<br>00:33:42,039 –&gt; 00:33:46,319<br>The question is, couldn’t you acquire the order, the objects in a preset order?</p>
<p>595<br>00:33:46,319 –&gt; 00:33:47,839<br>You could, but it may get difficult.</p>
<p>596<br>00:33:47,839 –&gt; 00:33:52,879<br>Imagine I’ve got a table R and one transaction is doing a file scan on it.</p>
<p>597<br>00:33:52,879 –&gt; 00:33:54,759<br>The other one is accessing it through an index.</p>
<p>598<br>00:33:54,759 –&gt; 00:33:56,399<br>I don’t know what the order is going to come from.</p>
<p>599<br>00:33:56,399 –&gt; 00:33:57,879<br>The index could be unclustered.</p>
<p>600<br>00:33:57,879 –&gt; 00:34:02,279<br>So I can’t always, because we want all these access paths for efficiency, we can’t induce</p>
<p>601<br>00:34:02,279 –&gt; 00:34:04,519<br>the order in a very strict way.</p>
<p>602<br>00:34:04,519 –&gt; 00:34:05,519<br>Yeah?</p>
<p>603<br>00:34:05,519 –&gt; 00:34:08,800<br>And that was where, in latches, you said the program has to do that, but if you ever write</p>
<p>604<br>00:34:08,800 –&gt; 00:34:14,039<br>a complex C++ application with latches, you’ll find it’s very hard to get all parts of</p>
<p>605<br>00:34:14,039 –&gt; 00:34:17,719<br>the code to follow the same order in which they go through data structures and all kinds</p>
<p>606<br>00:34:17,719 –&gt; 00:34:19,519<br>of crazy bugs pop up.</p>
<p>607<br>00:34:19,519 –&gt; 00:34:20,519<br>Okay?</p>
<p>608<br>00:34:20,519 –&gt; 00:34:21,519<br>Great question.</p>
<p>609<br>00:34:21,519 –&gt; 00:34:23,519<br>I like how you guys are thinking.</p>
<p>610<br>00:34:23,519 –&gt; 00:34:24,519<br>Yep.</p>
<p>611<br>00:34:24,519 –&gt; 00:34:25,519<br>That is correct.</p>
<p>612<br>00:34:25,519 –&gt; 00:34:38,280<br>So the question was, can we say that as long as everyone follows two phase locking, the</p>
<p>613<br>00:34:38,280 –&gt; 00:34:40,320<br>final schedule is conflict serializable?</p>
<p>614<br>00:34:40,320 –&gt; 00:34:41,320<br>Yes.</p>
<p>615<br>00:34:41,320 –&gt; 00:34:45,000<br>And it’s also yes that we are not guaranteeing anything about deadlocks.</p>
<p>616<br>00:34:45,000 –&gt; 00:34:46,360<br>Deadlocks can still happen.</p>
<p>617<br>00:34:46,360 –&gt; 00:34:48,679<br>We’ll find a way to break it.</p>
<p>618<br>00:34:48,679 –&gt; 00:34:49,679<br>Very good.</p>
<p>619<br>00:34:49,679 –&gt; 00:34:50,679<br>Yep.</p>
<p>620<br>00:34:50,679 –&gt; 00:34:51,679<br>Exactly right.</p>
<p>621<br>00:34:51,679 –&gt; 00:34:52,679<br>Yep.</p>
<p>622<br>00:34:53,679 –&gt; 00:34:54,679<br>Does this, sorry?</p>
<p>623<br>00:34:54,679 –&gt; 00:34:55,679<br>Yes.</p>
<p>624<br>00:34:55,679 –&gt; 00:34:56,679<br>Okay.</p>
<p>625<br>00:34:56,679 –&gt; 00:35:00,279<br>Which one is not shrinking?</p>
<p>626<br>00:35:00,279 –&gt; 00:35:03,639<br>This is just a flat line saying all the locks are now being held for a little while.</p>
<p>627<br>00:35:03,639 –&gt; 00:35:04,639<br>Is that what you mean?</p>
<p>628<br>00:35:04,639 –&gt; 00:35:05,639<br>Yeah, yeah, yeah.</p>
<p>629<br>00:35:05,639 –&gt; 00:35:08,919<br>So I scanned my file, I acquired all my locks.</p>
<p>630<br>00:35:08,919 –&gt; 00:35:11,679<br>Now I’m just adding all of them up because I have an aggregate stuff.</p>
<p>631<br>00:35:11,679 –&gt; 00:35:12,679<br>So it’s flat.</p>
<p>632<br>00:35:12,679 –&gt; 00:35:14,559<br>Then I start to drop the locks.</p>
<p>633<br>00:35:14,559 –&gt; 00:35:17,480<br>So it’s just to show that the lock point is when you reach the peak.</p>
<p>634<br>00:35:17,480 –&gt; 00:35:20,079<br>After that, if you’re plateauing out because you’re holding the locks while you’re doing</p>
<p>635<br>00:35:20,079 –&gt; 00:35:22,319<br>something, the lock point is when you reach the peak.</p>
<p>636<br>00:35:22,320 –&gt; 00:35:25,640<br>So it’s a very precise definition of when that event happened.</p>
<p>637<br>00:35:25,640 –&gt; 00:35:26,640<br>Okay.</p>
<p>638<br>00:35:26,640 –&gt; 00:35:27,640<br>Yep.</p>
<p>639<br>00:35:27,640 –&gt; 00:35:32,640<br>Is the lock point have a graph for like nothing, nothing, nothing, nothing, nothing.</p>
<p>640<br>00:35:32,640 –&gt; 00:35:34,680<br>I’ve acquired one and then dropped everything.</p>
<p>641<br>00:35:34,680 –&gt; 00:35:36,360<br>Yes, absolutely.</p>
<p>642<br>00:35:36,360 –&gt; 00:35:38,160<br>That will still be fine.</p>
<p>643<br>00:35:38,160 –&gt; 00:35:41,120<br>So as long as I’m going to a peak and then dropping, it’s fine.</p>
<p>644<br>00:35:41,120 –&gt; 00:35:42,120<br>Is it bad?</p>
<p>645<br>00:35:42,120 –&gt; 00:35:43,400<br>No, it’s not bad in some way.</p>
<p>646<br>00:35:43,400 –&gt; 00:35:46,800<br>In fact, you will see that we will need to do something like that.</p>
<p>647<br>00:35:46,800 –&gt; 00:35:50,760<br>Weak a version of that to make a certain problem in this go away.</p>
<p>648<br>00:35:50,760 –&gt; 00:35:51,760<br>Okay.</p>
<p>649<br>00:35:51,760 –&gt; 00:35:53,960<br>There’s still one tiny problem in two-phase locking.</p>
<p>650<br>00:35:53,960 –&gt; 00:35:56,400<br>So wait for two slides.</p>
<p>651<br>00:35:56,400 –&gt; 00:35:58,880<br>Other questions?</p>
<p>652<br>00:35:58,880 –&gt; 00:36:02,560<br>Because if you get this intuition, then you have the foundation to understand 50 different</p>
<p>653<br>00:36:02,560 –&gt; 00:36:04,680<br>lock modes and all kinds of other crazy stuff.</p>
<p>654<br>00:36:04,680 –&gt; 00:36:09,120<br>But if you don’t get this intuition, there’s no hope of getting to something more sophisticated.</p>
<p>655<br>00:36:09,120 –&gt; 00:36:10,440<br>All right.</p>
<p>656<br>00:36:10,440 –&gt; 00:36:13,200<br>So two-phase violation, peak’s bad, right?</p>
<p>657<br>00:36:13,200 –&gt; 00:36:15,280<br>No valleys.</p>
<p>658<br>00:36:15,280 –&gt; 00:36:17,480<br>So now let’s go back.</p>
<p>659<br>00:36:17,480 –&gt; 00:36:18,600<br>This is going to be very trivial.</p>
<p>660<br>00:36:18,600 –&gt; 00:36:20,320<br>Looks like all of you guys got it.</p>
<p>661<br>00:36:20,320 –&gt; 00:36:22,680<br>You acquired the lock, that’ll get granted.</p>
<p>662<br>00:36:22,680 –&gt; 00:36:29,600<br>Now when you get that second request for the X-lock, it will get pushed down so that you</p>
<p>663<br>00:36:29,600 –&gt; 00:36:38,240<br>won’t be granted that request and you will start to see some of that issues.</p>
<p>664<br>00:36:38,240 –&gt; 00:36:39,600<br>What’s happening in the dependence graph?</p>
<p>665<br>00:36:39,600 –&gt; 00:36:42,039<br>That was the question that was asked, right?</p>
<p>666<br>00:36:42,039 –&gt; 00:36:44,240<br>The first X-lock is for the transaction.</p>
<p>667<br>00:36:44,240 –&gt; 00:36:45,240<br>See the dependence graph?</p>
<p>668<br>00:36:45,240 –&gt; 00:36:47,000<br>We have 2T1 and T2.</p>
<p>669<br>00:36:47,000 –&gt; 00:36:50,519<br>The second X-lock said, I can’t allow you to go any further.</p>
<p>670<br>00:36:50,519 –&gt; 00:36:55,480<br>It’s basically saying, if I let you go forward, I will form an arc from T1 to T2 and I’m going</p>
<p>671<br>00:36:55,480 –&gt; 00:36:56,480<br>to kill that.</p>
<p>672<br>00:36:56,480 –&gt; 00:36:58,239<br>I’m not going to let that happen.</p>
<p>673<br>00:36:58,239 –&gt; 00:37:03,119<br>If I don’t allow that to happen, there is no cycle to be formed because I’m allowing</p>
<p>674<br>00:37:03,119 –&gt; 00:37:06,840<br>disallowing arcs from happening.</p>
<p>675<br>00:37:06,840 –&gt; 00:37:09,079<br>And so it’s a pessimistic form.</p>
<p>676<br>00:37:09,079 –&gt; 00:37:11,960<br>It’s pessimistic because maybe just one arc is okay.</p>
<p>677<br>00:37:11,960 –&gt; 00:37:15,599<br>The cycle has not been completed and so we’ll talk about the optimistic stuff later.</p>
<p>678<br>00:37:15,599 –&gt; 00:37:20,679<br>But that’s kind of the intuition and connecting back to where all this dependence graph is when</p>
<p>679<br>00:37:20,679 –&gt; 00:37:26,039<br>it gets and why that makes sense and why locking works is because it’s breaking these arcs</p>
<p>680<br>00:37:26,039 –&gt; 00:37:28,039<br>as they are getting far.</p>
<p>681<br>00:37:28,039 –&gt; 00:37:30,039<br>Let’s say I have two of these guys.</p>
<p>682<br>00:37:30,039 –&gt; 00:37:34,360<br>Let’s say they look at the guy on the right, right after the X-lock A, the X-lock B,</p>
<p>683<br>00:37:34,360 –&gt; 00:37:35,360<br>right?</p>
<p>684<br>00:37:35,360 –&gt; 00:37:36,360<br>So one C, and then it gets.</p>
<p>685<br>00:37:36,360 –&gt; 00:37:41,319<br>But X-lock A won’t be, so the question is, after X-lock A, T2 has an X-lock B, but X-lock</p>
<p>686<br>00:37:41,319 –&gt; 00:37:43,039<br>A won’t be granted, so it’s going to be waiting.</p>
<p>687<br>00:37:43,039 –&gt; 00:37:44,039<br>So that’s the way.</p>
<p>688<br>00:37:44,039 –&gt; 00:37:45,039<br>Yes.</p>
<p>689<br>00:37:45,039 –&gt; 00:37:46,039<br>So you want it to be.</p>
<p>690<br>00:37:46,039 –&gt; 00:37:50,039<br>So we could see right away if the B-step is independent, we could be using it.</p>
<p>691<br>00:37:50,039 –&gt; 00:37:51,039<br>Yeah, yeah, yeah.</p>
<p>692<br>00:37:51,039 –&gt; 00:37:52,039<br>So hold on for the deadlock stuff.</p>
<p>693<br>00:37:52,039 –&gt; 00:37:56,960<br>Yes, but if you did that and if T1 wanted to use B later, that could be a difference.</p>
<p>694<br>00:37:56,960 –&gt; 00:38:04,719<br>So your question is, oh, if T2 wanted A and B could it say that I tried to get A, but</p>
<p>695<br>00:38:04,719 –&gt; 00:38:07,400<br>it is locked, can I keep making progress with B?</p>
<p>696<br>00:38:07,400 –&gt; 00:38:08,559<br>It can.</p>
<p>697<br>00:38:08,559 –&gt; 00:38:09,559<br>And there are sophisticated protocols.</p>
<p>698<br>00:38:09,559 –&gt; 00:38:13,000<br>I’ll do that and many of these different locking modes will say, do you really want</p>
<p>699<br>00:38:13,000 –&gt; 00:38:16,840<br>an X-lock right away or do you just want to check that you can get it and stuff like that?</p>
<p>700<br>00:38:16,840 –&gt; 00:38:20,880<br>So we’ll get to more sophisticated protocols, most of it in the advanced class, but we’ll</p>
<p>701<br>00:38:20,880 –&gt; 00:38:23,639<br>allude to some of those techniques like that towards the end of this lecture.</p>
<p>702<br>00:38:23,639 –&gt; 00:38:24,639<br>Yeah.</p>
<p>703<br>00:38:24,639 –&gt; 00:38:28,559<br>It’s probably also an advanced protocol, but like, could you do like priorities, if like</p>
<p>704<br>00:38:28,559 –&gt; 00:38:31,840<br>one of them is going to be like, it’s going to lock in and like unlock immediately,</p>
<p>705<br>00:38:31,840 –&gt; 00:38:33,679<br>the other one is going to hold for like an hour.</p>
<p>706<br>00:38:33,679 –&gt; 00:38:34,679<br>Yeah.</p>
<p>707<br>00:38:34,679 –&gt; 00:38:35,679<br>Then we want to prioritize.</p>
<p>708<br>00:38:35,679 –&gt; 00:38:36,679<br>Absolutely.</p>
<p>709<br>00:38:36,679 –&gt; 00:38:37,679<br>You can do all kinds of that.</p>
<p>710<br>00:38:37,679 –&gt; 00:38:40,519<br>And we’ll talk about granularities of locking, where you might say, if I’ve got a scanning</p>
<p>711<br>00:38:40,519 –&gt; 00:38:45,360<br>of file with a billion rows, acquiring a billion locks is very expensive.</p>
<p>712<br>00:38:45,360 –&gt; 00:38:47,440<br>It’s more expensive than reading the record.</p>
<p>713<br>00:38:47,440 –&gt; 00:38:48,440<br>Can I do something better?</p>
<p>714<br>00:38:48,440 –&gt; 00:38:51,119<br>So hold on to that.</p>
<p>715<br>00:38:51,119 –&gt; 00:38:52,119<br>Okay.</p>
<p>716<br>00:38:52,119 –&gt; 00:38:53,119<br>Great.</p>
<p>717<br>00:38:53,119 –&gt; 00:38:54,119<br>All right.</p>
<p>718<br>00:38:54,119 –&gt; 00:38:57,199<br>So basically, all this is saying is that this is why locking works because we are trying</p>
<p>719<br>00:38:57,199 –&gt; 00:38:58,199<br>to break these arcs.</p>
<p>720<br>00:38:58,199 –&gt; 00:39:02,599<br>It brings form from the dependence graph that we talked about, the dependency graph that</p>
<p>721<br>00:39:02,599 –&gt; 00:39:05,480<br>we talked about in the last class.</p>
<p>722<br>00:39:05,480 –&gt; 00:39:10,960<br>So two-phase locking works, but it has one problem.</p>
<p>723<br>00:39:10,960 –&gt; 00:39:13,719<br>That problem is called cascading a bots.</p>
<p>724<br>00:39:13,719 –&gt; 00:39:18,599<br>Remember databases start a transaction with the begin statement.</p>
<p>725<br>00:39:18,599 –&gt; 00:39:23,320<br>And then transaction could end with a commit, which means make all the changes and make</p>
<p>726<br>00:39:23,320 –&gt; 00:39:24,320<br>it permanent.</p>
<p>727<br>00:39:24,320 –&gt; 00:39:27,679<br>What could end within a bot saying whoops, undo everything.</p>
<p>728<br>00:39:27,679 –&gt; 00:39:32,960<br>It is the, and you want to do this all on nothing component with transactions.</p>
<p>729<br>00:39:32,960 –&gt; 00:39:36,159<br>But the point is a bots can also happen.</p>
<p>730<br>00:39:36,159 –&gt; 00:39:37,840<br>Transaction could get a bot.</p>
<p>731<br>00:39:37,840 –&gt; 00:39:43,559<br>And now in the presence of a bots, you start to have this situation where even if I’m</p>
<p>732<br>00:39:43,559 –&gt; 00:39:50,039<br>falling two-phase locking protocol, I have a hole that I’ve dug myself into and I can</p>
<p>733<br>00:39:50,039 –&gt; 00:39:51,039<br>get out of it.</p>
<p>734<br>00:39:51,039 –&gt; 00:39:52,039<br>What’s that hole?</p>
<p>735<br>00:39:52,039 –&gt; 00:39:54,280<br>Let’s illustrate that with an example.</p>
<p>736<br>00:39:54,280 –&gt; 00:39:58,559<br>So here is a schedule in which transaction T1 starts.</p>
<p>737<br>00:39:58,559 –&gt; 00:40:03,880<br>This following two-phase protocol, T2 is also doing the same and acquires its lock.</p>
<p>738<br>00:40:03,880 –&gt; 00:40:09,599<br>Then unlocks it because it doesn’t need any of A anymore.</p>
<p>739<br>00:40:09,599 –&gt; 00:40:14,559<br>So it reaches its lock point and now after unlock all two-phase locking says you can’t do</p>
<p>740<br>00:40:14,559 –&gt; 00:40:16,360<br>any more locks.</p>
<p>741<br>00:40:16,360 –&gt; 00:40:21,440<br>But it’s still continuing to work on B because it has an unlocked B.</p>
<p>742<br>00:40:21,440 –&gt; 00:40:25,000<br>T2 gets the lock for A because that was released.</p>
<p>743<br>00:40:25,000 –&gt; 00:40:26,719<br>What should do its work?</p>
<p>744<br>00:40:26,719 –&gt; 00:40:34,239<br>But later on, T1 proceeds and says, oh no, something’s wrong, I need to abort.</p>
<p>745<br>00:40:34,239 –&gt; 00:40:41,880<br>Now we are all following two-phase locking but T2 has read a value A that has to be undone.</p>
<p>746<br>00:40:41,880 –&gt; 00:40:44,440<br>So it’s read a dirty value.</p>
<p>747<br>00:40:44,440 –&gt; 00:40:46,559<br>It’s a dirty read.</p>
<p>748<br>00:40:46,559 –&gt; 00:40:51,320<br>Now we can’t unwind ourselves from this even though we are following two-phase locking.</p>
<p>749<br>00:40:51,320 –&gt; 00:40:52,320<br>We are in trouble.</p>
<p>750<br>00:40:52,320 –&gt; 00:40:54,120<br>So we reached the abort call comes to the database.</p>
<p>751<br>00:40:54,120 –&gt; 00:40:55,120<br>What are you going to do?</p>
<p>752<br>00:40:55,120 –&gt; 00:40:56,800<br>You have to now undo T2.</p>
<p>753<br>00:40:56,800 –&gt; 00:41:00,920<br>What if T2 was already committed and had already paid out that $25?</p>
<p>754<br>00:41:00,920 –&gt; 00:41:02,720<br>You can’t undo that.</p>
<p>755<br>00:41:02,720 –&gt; 00:41:11,039<br>So we can’t let T2 go if it has got a dependency on T1 and T1’s not committed.</p>
<p>756<br>00:41:11,039 –&gt; 00:41:15,400<br>So how can you make two-phase locking safer to this type of problem?</p>
<p>757<br>00:41:15,400 –&gt; 00:41:18,440<br>It’s already safe for serializable purposes.</p>
<p>758<br>00:41:18,440 –&gt; 00:41:22,840<br>But now it still will require us to deal with this cascading abort problem because</p>
<p>759<br>00:41:22,840 –&gt; 00:41:24,360<br>transactions can abort.</p>
<p>760<br>00:41:24,360 –&gt; 00:41:27,720<br>Everyone does that make sense?</p>
<p>761<br>00:41:27,720 –&gt; 00:41:35,599<br>So the way to make it safe is to do something a little bit more with the two-phase locking.</p>
<p>762<br>00:41:35,599 –&gt; 00:41:42,000<br>So this permissible schedule, we want to make it unadmitable in a new protocol and the</p>
<p>763<br>00:41:42,000 –&gt; 00:41:45,720<br>protocol is called strong strict two-phase locking.</p>
<p>764<br>00:41:45,719 –&gt; 00:41:49,079<br>The textbook also calls rigorous two-phase locking.</p>
<p>765<br>00:41:49,079 –&gt; 00:41:52,359<br>And if you understand this lock point business that we talked about, right?</p>
<p>766<br>00:41:52,359 –&gt; 00:41:57,079<br>So if you go back here, can you think about what you would do to this graph to make this</p>
<p>767<br>00:41:57,079 –&gt; 00:41:58,480<br>problem better?</p>
<p>768<br>00:41:58,480 –&gt; 00:42:01,199<br>So this is the correct protocol that we’ve been following so far.</p>
<p>769<br>00:42:01,199 –&gt; 00:42:03,599<br>But cascading abort happens.</p>
<p>770<br>00:42:03,599 –&gt; 00:42:04,599<br>What?</p>
<p>771<br>00:42:04,599 –&gt; 00:42:10,079<br>Can you think of something to do to the shape of this graph to stop cascading abort?</p>
<p>772<br>00:42:10,079 –&gt; 00:42:11,359<br>What was the root cause of cascading?</p>
<p>773<br>00:42:11,359 –&gt; 00:42:12,359<br>Yup.</p>
<p>774<br>00:42:13,360 –&gt; 00:42:14,360<br>Correct.</p>
<p>775<br>00:42:14,360 –&gt; 00:42:15,720<br>Release all at once.</p>
<p>776<br>00:42:15,720 –&gt; 00:42:17,519<br>And when do you release it?</p>
<p>777<br>00:42:17,519 –&gt; 00:42:19,519<br>Or adopted.</p>
<p>778<br>00:42:19,519 –&gt; 00:42:20,519<br>Exactly.</p>
<p>779<br>00:42:20,519 –&gt; 00:42:21,519<br>So what did we say?</p>
<p>780<br>00:42:21,519 –&gt; 00:42:24,960<br>You climbed the mountain and there’s a plateau and then there’s a cliff.</p>
<p>781<br>00:42:24,960 –&gt; 00:42:27,000<br>Which means you never unlock early.</p>
<p>782<br>00:42:27,000 –&gt; 00:42:34,320<br>No one can see that A transaction, the A object that was grabbed was basically, see, now</p>
<p>783<br>00:42:34,320 –&gt; 00:42:38,280<br>if you had come up with that in 1970s, you would have won an award.</p>
<p>784<br>00:42:38,280 –&gt; 00:42:44,480<br>So, but it was very hard at that time to just get your head around all of this stuff.</p>
<p>785<br>00:42:44,480 –&gt; 00:42:46,800<br>It becomes easy because now I’ve shown you the graph.</p>
<p>786<br>00:42:46,800 –&gt; 00:42:50,360<br>This is always the case where when someone explains to you something, simply you say, oh,</p>
<p>787<br>00:42:50,360 –&gt; 00:42:51,360<br>it is trivial.</p>
<p>788<br>00:42:51,360 –&gt; 00:42:55,519<br>But if you didn’t have that, it just took a long time to conceptualize that and abstraction</p>
<p>789<br>00:42:55,519 –&gt; 00:42:59,600<br>in that right way is the art of coming up with breakthroughs.</p>
<p>790<br>00:42:59,600 –&gt; 00:43:02,280<br>So this is what we do.</p>
<p>791<br>00:43:02,280 –&gt; 00:43:07,080<br>The problem we ran into is unlock of A allowed the other transaction to come in who was following</p>
<p>792<br>00:43:07,079 –&gt; 00:43:10,119<br>two-phase locking and start to see bad stuff.</p>
<p>793<br>00:43:10,119 –&gt; 00:43:14,199<br>But now if you do this strict, strong, strict two-phase locking, you say, climb the mountain,</p>
<p>794<br>00:43:14,199 –&gt; 00:43:19,039<br>it’s a plateau all the way through and then in the end, drop all the locks simultaneously.</p>
<p>795<br>00:43:19,039 –&gt; 00:43:23,880<br>In just a little tidbit, obviously you won’t drop all the locks simultaneously.</p>
<p>796<br>00:43:23,880 –&gt; 00:43:25,799<br>It’ll be get dropped one at a time.</p>
<p>797<br>00:43:25,799 –&gt; 00:43:27,519<br>Multiple operations are happening to the hash table.</p>
<p>798<br>00:43:27,519 –&gt; 00:43:31,719<br>So it’s a little bit of semantics, but even though it takes a little bit of time, you</p>
<p>799<br>00:43:31,719 –&gt; 00:43:33,719<br>can commit the transaction at that cliff.</p>
<p>800<br>00:43:33,719 –&gt; 00:43:36,319<br>As we talk about durability, you’ll write that commit log.</p>
<p>801<br>00:43:36,320 –&gt; 00:43:38,200<br>And then you can start to draw.</p>
<p>802<br>00:43:38,200 –&gt; 00:43:42,400<br>So there’s this different type of mechanism to make that peak look like a peak, like that</p>
<p>803<br>00:43:42,400 –&gt; 00:43:46,000<br>sharp edge look like an edge, but ignore that for now.</p>
<p>804<br>00:43:46,000 –&gt; 00:43:50,400<br>Obviously, if you drop a billion rocks, you can’t make a billion operations to the hash</p>
<p>805<br>00:43:50,400 –&gt; 00:43:51,400<br>table instantaneously, right?</p>
<p>806<br>00:43:51,400 –&gt; 00:43:56,960<br>It’ll take some time to make that happen.</p>
<p>807<br>00:43:56,960 –&gt; 00:43:58,760<br>But now hopefully this intuition makes sense.</p>
<p>808<br>00:43:58,760 –&gt; 00:44:04,360<br>This way whoever reaches the lock point is ahead in the dependency graph that you draw,</p>
<p>809<br>00:44:04,360 –&gt; 00:44:05,360<br>right?</p>
<p>810<br>00:44:05,360 –&gt; 00:44:09,400<br>No one can see changes made by a transaction till it’s committed or abort it.</p>
<p>811<br>00:44:09,400 –&gt; 00:44:14,200<br>So no dirty reads will get passed across and the later abort doesn’t cause you to unwind</p>
<p>812<br>00:44:14,200 –&gt; 00:44:19,480<br>a transaction whose state might have already been determined.</p>
<p>813<br>00:44:19,480 –&gt; 00:44:20,480<br>Questions?</p>
<p>814<br>00:44:20,480 –&gt; 00:44:39,559<br>So if I understand the question correctly, is that the transaction that reaches the lock</p>
<p>815<br>00:44:39,559 –&gt; 00:44:44,920<br>point first, can you make it commit first?</p>
<p>816<br>00:44:44,920 –&gt; 00:44:46,960<br>So it depends upon why is the plateau?</p>
<p>817<br>00:44:46,960 –&gt; 00:44:51,039<br>The plateau is because I’ve gotten all my data, locked all the data I need.</p>
<p>818<br>00:44:51,039 –&gt; 00:44:55,119<br>Now I’m processing the data like computing an aggregate and computing a joint or something</p>
<p>819<br>00:44:55,119 –&gt; 00:44:56,119<br>like that.</p>
<p>820<br>00:44:56,119 –&gt; 00:44:59,760<br>So that time here is still going to be taken for doing the work that I want to do for</p>
<p>821<br>00:44:59,760 –&gt; 00:45:00,760<br>the query.</p>
<p>822<br>00:45:00,760 –&gt; 00:45:02,240<br>So I can’t just drop it right there.</p>
<p>823<br>00:45:02,240 –&gt; 00:45:05,119<br>I have to wait till all of that work is done.</p>
<p>824<br>00:45:05,119 –&gt; 00:45:11,440<br>Does that make sense or maybe I didn’t understand your question?</p>
<p>825<br>00:45:11,440 –&gt; 00:45:15,079<br>I thought your question is why do we have a plateau?</p>
<p>826<br>00:45:15,079 –&gt; 00:45:16,920<br>Why can’t we just drop at the lock point?</p>
<p>827<br>00:45:16,920 –&gt; 00:45:17,920<br>Correct?</p>
<p>828<br>00:45:17,920 –&gt; 00:45:23,360<br>Yeah, because the plateau is where the work on that lock on all the things that we have</p>
<p>829<br>00:45:23,360 –&gt; 00:45:26,559<br>read is probably getting done.</p>
<p>830<br>00:45:26,559 –&gt; 00:45:28,280<br>So could you have a transaction?</p>
<p>831<br>00:45:28,280 –&gt; 00:45:30,079<br>Could the plateau be zero in some cases?</p>
<p>832<br>00:45:30,079 –&gt; 00:45:31,079<br>Yes.</p>
<p>833<br>00:45:31,079 –&gt; 00:45:35,480<br>If all the work it needed, for example, if this were an update query and the last thing</p>
<p>834<br>00:45:35,480 –&gt; 00:45:39,159<br>that when it reached the lock point was the last record it needed to update, it updated</p>
<p>835<br>00:45:39,159 –&gt; 00:45:42,159<br>and drops it, the plateau will be very small.</p>
<p>836<br>00:45:42,159 –&gt; 00:45:43,159<br>Yeah.</p>
<p>837<br>00:45:43,159 –&gt; 00:45:46,840<br>Does that make sense?</p>
<p>838<br>00:45:46,840 –&gt; 00:45:51,200<br>It’s also possible that I grab a lock here and then I’m plathing for a long time before</p>
<p>839<br>00:45:51,200 –&gt; 00:45:53,039<br>I grab a the locks.</p>
<p>840<br>00:45:53,039 –&gt; 00:45:56,579<br>You know, I read a table, then I’m going to do some work with it, then I decide I want</p>
<p>841<br>00:45:56,579 –&gt; 00:45:59,440<br>to do something else based upon the contents of what I read.</p>
<p>842<br>00:45:59,440 –&gt; 00:46:02,039<br>So it’s not, you know, the plateaus and peaks.</p>
<p>843<br>00:46:02,039 –&gt; 00:46:06,519<br>All we have is that the growing phase is only going up, it’s monotonically increasing, plateau</p>
<p>844<br>00:46:06,519 –&gt; 00:46:07,519<br>and then drop.</p>
<p>845<br>00:46:07,519 –&gt; 00:46:14,079<br>And two phase locking, it’s a monotonically increasing and then monotonically decreasing curve.</p>
<p>846<br>00:46:14,079 –&gt; 00:46:16,079<br>It can be platoes on both sides.</p>
<p>847<br>00:46:16,079 –&gt; 00:46:26,519<br>You can have that, but that causes cascading a bot, right?</p>
<p>848<br>00:46:26,519 –&gt; 00:46:27,759<br>That was the whole point.</p>
<p>849<br>00:46:27,759 –&gt; 00:46:29,079<br>If, yeah, go ahead.</p>
<p>850<br>00:46:29,079 –&gt; 00:46:34,079<br>First thing that’s in the first thing, is that the second thing, we’re supposed to be</p>
<p>851<br>00:46:34,079 –&gt; 00:46:35,079<br>30% abort.</p>
<p>852<br>00:46:35,079 –&gt; 00:46:36,079<br>Yeah, I see what you’re saying.</p>
<p>853<br>00:46:36,079 –&gt; 00:46:37,079<br>Very good, very good.</p>
<p>854<br>00:46:37,079 –&gt; 00:46:39,319<br>So you are saying, oh, you know what?</p>
<p>855<br>00:46:39,320 –&gt; 00:46:41,760<br>There wasn’t really a problem here.</p>
<p>856<br>00:46:41,760 –&gt; 00:46:48,240<br>What if you said, let this guy go, don’t let it come it till the outcome is done.</p>
<p>857<br>00:46:48,240 –&gt; 00:46:50,120<br>That’s exactly what some protocols do.</p>
<p>858<br>00:46:50,120 –&gt; 00:46:54,720<br>Like Microsoft, Hackathon server, Hackathon system, and I worked on that with a whole bunch</p>
<p>859<br>00:46:54,720 –&gt; 00:46:56,720<br>of really smart people at Microsoft.</p>
<p>860<br>00:46:56,720 –&gt; 00:47:02,360<br>Internally, we’ll keep track of this dependent stuff and then won’t let that transaction</p>
<p>861<br>00:47:02,360 –&gt; 00:47:06,800<br>T2 to come it because it has taken a dependence on some of the transaction.</p>
<p>862<br>00:47:06,800 –&gt; 00:47:10,400<br>So even if you say, come it here, it’ll say, no, no, no, I got to hold you because you’ve</p>
<p>863<br>00:47:10,400 –&gt; 00:47:11,400<br>read something else.</p>
<p>864<br>00:47:11,400 –&gt; 00:47:13,560<br>I need to know that before I let you go.</p>
<p>865<br>00:47:13,560 –&gt; 00:47:14,560<br>Absolutely, absolutely.</p>
<p>866<br>00:47:14,560 –&gt; 00:47:17,080<br>So the more advanced protocols will do stuff like that.</p>
<p>867<br>00:47:17,080 –&gt; 00:47:18,080<br>So that’s great.</p>
<p>868<br>00:47:18,080 –&gt; 00:47:21,640<br>You’re already designing the next generation of protocols, which is good.</p>
<p>869<br>00:47:21,640 –&gt; 00:47:22,640<br>Yeah.</p>
<p>870<br>00:47:22,640 –&gt; 00:47:24,640<br>Other questions?</p>
<p>871<br>00:47:24,640 –&gt; 00:47:25,640<br>Yeah.</p>
<p>872<br>00:47:25,639 –&gt; 00:47:38,279<br>So the question is, the longer I hold the lock, am I not reducing the parallelism?</p>
<p>873<br>00:47:38,279 –&gt; 00:47:39,279<br>Absolutely.</p>
<p>874<br>00:47:39,279 –&gt; 00:47:41,480<br>That’s why more lock modes.</p>
<p>875<br>00:47:41,480 –&gt; 00:47:44,599<br>They will hold the locks, but weaker locks so other locks can get in.</p>
<p>876<br>00:47:44,599 –&gt; 00:47:47,920<br>So wait for that and we may not get to it today, but that’s okay.</p>
<p>877<br>00:47:47,920 –&gt; 00:47:50,519<br>We’ll get to it.</p>
<p>878<br>00:47:50,519 –&gt; 00:47:51,519<br>All right.</p>
<p>879<br>00:47:51,519 –&gt; 00:47:53,119<br>So let’s keep moving.</p>
<p>880<br>00:47:53,119 –&gt; 00:48:00,400<br>Hopefully this makes sense to everyone and we now have a solution that works and gets</p>
<p>881<br>00:48:00,400 –&gt; 00:48:03,719<br>us out of this cascading approach.</p>
<p>882<br>00:48:03,719 –&gt; 00:48:04,719<br>All right.</p>
<p>883<br>00:48:04,719 –&gt; 00:48:09,359<br>So let’s take a look at this example really quickly just to make sure everything is solidified.</p>
<p>884<br>00:48:09,359 –&gt; 00:48:13,319<br>I think everyone got it based on this discussion, but just give you a little bit of time to digest</p>
<p>885<br>00:48:13,319 –&gt; 00:48:14,319<br>this too.</p>
<p>886<br>00:48:14,319 –&gt; 00:48:17,119<br>Consider two transactions, T1 and T2.</p>
<p>887<br>00:48:17,119 –&gt; 00:48:18,839<br>Andy tells me he has a bookie.</p>
<p>888<br>00:48:18,840 –&gt; 00:48:24,160<br>So he keeps transferring money from his account to his bookies account and then you need to go</p>
<p>889<br>00:48:24,160 –&gt; 00:48:26,640<br>and compute the total across both those accounts.</p>
<p>890<br>00:48:26,640 –&gt; 00:48:28,840<br>So those are the two transactions.</p>
<p>891<br>00:48:28,840 –&gt; 00:48:33,640<br>A non-2PL example, and this is again to make sure we are all on the same page.</p>
<p>892<br>00:48:33,640 –&gt; 00:48:39,039<br>You’ll acquire that S lock and then you’ll get into the situation where you end up with</p>
<p>893<br>00:48:39,039 –&gt; 00:48:40,039<br>an incorrect value.</p>
<p>894<br>00:48:40,039 –&gt; 00:48:41,039<br>Right.</p>
<p>895<br>00:48:41,039 –&gt; 00:48:43,039<br>By now, I think everyone gets that.</p>
<p>896<br>00:48:43,039 –&gt; 00:48:45,400<br>That’s the type of bad stuff that can happen.</p>
<p>897<br>00:48:45,400 –&gt; 00:48:51,200<br>Two-phase locking, if we end up doing that, we’ll use the locks and then move things around</p>
<p>898<br>00:48:51,200 –&gt; 00:48:53,599<br>so that we end up with the correct state.</p>
<p>899<br>00:48:53,599 –&gt; 00:48:54,599<br>Right.</p>
<p>900<br>00:48:54,599 –&gt; 00:48:57,920<br>Still doesn’t avoid cascading boards which we just talked about, but you can now, you can</p>
<p>901<br>00:48:57,920 –&gt; 00:49:02,639<br>take this thing, put in an independent graph and do that by yourself and see that we broke</p>
<p>902<br>00:49:02,639 –&gt; 00:49:03,639<br>that cycle.</p>
<p>903<br>00:49:03,639 –&gt; 00:49:05,639<br>We didn’t let the cycle get far.</p>
<p>904<br>00:49:05,639 –&gt; 00:49:06,639<br>Okay.</p>
<p>905<br>00:49:06,639 –&gt; 00:49:07,639<br>All right.</p>
<p>906<br>00:49:07,639 –&gt; 00:49:12,920<br>And strong strict two-phase locking in this case would basically require that A and B</p>
<p>907<br>00:49:12,920 –&gt; 00:49:21,079<br>both be held till the end and you basically effectively running T1 after T2.</p>
<p>908<br>00:49:21,079 –&gt; 00:49:22,079<br>Right.</p>
<p>909<br>00:49:22,079 –&gt; 00:49:24,320<br>There’s no parallelism there in this case.</p>
<p>910<br>00:49:24,320 –&gt; 00:49:25,320<br>Okay.</p>
<p>911<br>00:49:25,320 –&gt; 00:49:27,639<br>All right.</p>
<p>912<br>00:49:27,639 –&gt; 00:49:31,920<br>So going back to this, serial schedule, right.</p>
<p>913<br>00:49:31,920 –&gt; 00:49:33,440<br>A bigger subset of that.</p>
<p>914<br>00:49:33,440 –&gt; 00:49:35,559<br>We are doing that because we want to allow more stuff.</p>
<p>915<br>00:49:35,559 –&gt; 00:49:38,480<br>Use the database, make it more efficient.</p>
<p>916<br>00:49:38,480 –&gt; 00:49:42,760<br>Use serializable theoretical, but good to know what it does.</p>
<p>917<br>00:49:42,760 –&gt; 00:49:44,719<br>Cascading about picture looks like this.</p>
<p>918<br>00:49:44,719 –&gt; 00:49:46,480<br>It cuts across that.</p>
<p>919<br>00:49:46,480 –&gt; 00:49:52,639<br>There are some complex serializable schedule that it will remove from consideration but make</p>
<p>920<br>00:49:52,639 –&gt; 00:49:54,920<br>it safer so that you don’t have the cascading about case.</p>
<p>921<br>00:49:54,920 –&gt; 00:49:58,000<br>So we restricted that space a little bit more.</p>
<p>922<br>00:49:58,000 –&gt; 00:49:59,000<br>Okay.</p>
<p>923<br>00:49:59,000 –&gt; 00:50:02,360<br>Obviously, a serial schedule is not going to have that because you know the outcome before</p>
<p>924<br>00:50:02,360 –&gt; 00:50:03,360<br>you go.</p>
<p>925<br>00:50:03,360 –&gt; 00:50:05,000<br>So it’s covered under that stuff.</p>
<p>926<br>00:50:05,000 –&gt; 00:50:08,719<br>But when we start to do strict two-phase locking, we’re saying we’re going to have a little</p>
<p>927<br>00:50:08,719 –&gt; 00:50:10,119<br>less parallelism.</p>
<p>928<br>00:50:10,119 –&gt; 00:50:14,199<br>But we’re doing that because we want to avoid these cascading about.</p>
<p>929<br>00:50:14,199 –&gt; 00:50:15,719<br>Okay.</p>
<p>930<br>00:50:15,719 –&gt; 00:50:18,039<br>All right.</p>
<p>931<br>00:50:18,039 –&gt; 00:50:20,280<br>Questions on this?</p>
<p>932<br>00:50:20,280 –&gt; 00:50:22,079<br>All right.</p>
<p>933<br>00:50:22,079 –&gt; 00:50:27,000<br>So now let’s just make sure we have everything together.</p>
<p>934<br>00:50:27,000 –&gt; 00:50:29,880<br>We talked about the strong strict two-phase locking.</p>
<p>935<br>00:50:29,880 –&gt; 00:50:36,119<br>As many of you have already asked, what about that situation where transactions T1 and T2</p>
<p>936<br>00:50:36,119 –&gt; 00:50:38,960<br>go after two objects A and B in a different order.</p>
<p>937<br>00:50:38,960 –&gt; 00:50:41,200<br>That’s exactly the example here.</p>
<p>938<br>00:50:41,200 –&gt; 00:50:50,320<br>A locks a transaction T1 locks A. Transaction T2 locks B. T1 and then asked for A. Lock manager</p>
<p>939<br>00:50:50,320 –&gt; 00:50:52,559<br>says, whoa, I need to put you on the pending queue.</p>
<p>940<br>00:50:52,559 –&gt; 00:50:53,559<br>You need to wait.</p>
<p>941<br>00:50:53,559 –&gt; 00:51:02,000<br>T2 later comes back and says, I need B. T2 can’t get A because T1 has it and vice versa.</p>
<p>942<br>00:51:02,000 –&gt; 00:51:03,799<br>So this is a deadlock.</p>
<p>943<br>00:51:03,799 –&gt; 00:51:05,119<br>No progress is going to be made.</p>
<p>944<br>00:51:05,119 –&gt; 00:51:06,799<br>We follow strict two-phase locking.</p>
<p>945<br>00:51:06,799 –&gt; 00:51:09,519<br>We can still get ourselves into this trouble.</p>
<p>946<br>00:51:09,519 –&gt; 00:51:10,599<br>Okay.</p>
<p>947<br>00:51:10,599 –&gt; 00:51:12,039<br>So we need to get out of this.</p>
<p>948<br>00:51:12,039 –&gt; 00:51:15,920<br>And for that, there are these mechanisms to find deadlocks.</p>
<p>949<br>00:51:15,920 –&gt; 00:51:18,880<br>So that situation is called a deadlock.</p>
<p>950<br>00:51:18,880 –&gt; 00:51:21,920<br>And there are two ways that you can deal with deadlocks.</p>
<p>951<br>00:51:21,920 –&gt; 00:51:24,400<br>The first one is called deadlock detection.</p>
<p>952<br>00:51:24,400 –&gt; 00:51:28,880<br>Periodically, you will run some background thread to go look through the lock manager and</p>
<p>953<br>00:51:28,880 –&gt; 00:51:30,480<br>say, do I see a deadlock cycle?</p>
<p>954<br>00:51:30,480 –&gt; 00:51:32,680<br>We’ll talk about that in a second.</p>
<p>955<br>00:51:32,680 –&gt; 00:51:36,200<br>And if so, I’m going to kill one of the transactions and break the cycle.</p>
<p>956<br>00:51:36,200 –&gt; 00:51:37,920<br>This is a cycle for deadlocks.</p>
<p>957<br>00:51:37,920 –&gt; 00:51:40,800<br>Different than the cycle for dependency graph.</p>
<p>958<br>00:51:40,800 –&gt; 00:51:44,519<br>And then deadlock prevention, which is in some sense, think of it as being pessimistic.</p>
<p>959<br>00:51:44,519 –&gt; 00:51:48,200<br>It’s going to say, I’m going to stop you as early as possible.</p>
<p>960<br>00:51:48,200 –&gt; 00:51:50,079<br>But now this is for deadlocks, right?</p>
<p>961<br>00:51:50,079 –&gt; 00:51:52,360<br>Not for the dependency graph stuff.</p>
<p>962<br>00:51:52,360 –&gt; 00:51:57,059<br>Similar concepts, but different applications, different problems that we are trying to solve.</p>
<p>963<br>00:51:57,059 –&gt; 00:52:01,039<br>So we create these things called the wait for graphs.</p>
<p>964<br>00:52:01,039 –&gt; 00:52:05,119<br>They look like dependency graphs, similar ideas, but for deadlocks.</p>
<p>965<br>00:52:05,119 –&gt; 00:52:06,119<br>Okay.</p>
<p>966<br>00:52:06,119 –&gt; 00:52:07,119<br>All right.</p>
<p>967<br>00:52:07,119 –&gt; 00:52:12,440<br>So imagine I have wait for graphs, the are going to be constructed from the lock manager</p>
<p>968<br>00:52:12,440 –&gt; 00:52:15,519<br>state of what’s been locked, right?</p>
<p>969<br>00:52:15,519 –&gt; 00:52:18,599<br>Not in terms of the read write stuff, which is what the dependency graph stuff.</p>
<p>970<br>00:52:18,599 –&gt; 00:52:19,599<br>But they’re different.</p>
<p>971<br>00:52:19,599 –&gt; 00:52:20,599<br>Don’t get those confused.</p>
<p>972<br>00:52:20,599 –&gt; 00:52:21,599<br>Okay.</p>
<p>973<br>00:52:21,599 –&gt; 00:52:24,319<br>But they’re also related.</p>
<p>974<br>00:52:24,319 –&gt; 00:52:28,079<br>If you think about it a little bit, and we can have a separate conversation, but the concepts</p>
<p>975<br>00:52:28,079 –&gt; 00:52:29,079<br>are different.</p>
<p>976<br>00:52:29,079 –&gt; 00:52:31,559<br>This will get built from the lock manager.</p>
<p>977<br>00:52:31,559 –&gt; 00:52:35,839<br>The lock manager knows which transaction has been granted, which type of lock for which</p>
<p>978<br>00:52:35,839 –&gt; 00:52:37,799<br>object and who’s waiting for that.</p>
<p>979<br>00:52:37,799 –&gt; 00:52:41,239<br>And from that information, you can put this and put this thing together.</p>
<p>980<br>00:52:41,239 –&gt; 00:52:44,519<br>So here’s a schedule of three transactions.</p>
<p>981<br>00:52:44,519 –&gt; 00:52:48,360<br>T1, locks A, and then tries to lock B.</p>
<p>982<br>00:52:48,360 –&gt; 00:52:53,440<br>T2 locks B, then tries to lock C. And T3 tries to lock C, and then A.</p>
<p>983<br>00:52:53,440 –&gt; 00:52:58,400<br>So just showing an example with like three transactions previously saw a deadlock with two</p>
<p>984<br>00:52:58,400 –&gt; 00:53:02,119<br>transactions, but they can happen across three transactions.</p>
<p>985<br>00:53:02,119 –&gt; 00:53:06,599<br>So as you can see, this thing is done slightly differently in the lock manager.</p>
<p>986<br>00:53:06,599 –&gt; 00:53:11,360<br>We will go in the backward fashion in this to say, oh, who is waiting for what?</p>
<p>987<br>00:53:11,360 –&gt; 00:53:13,800<br>And that’s what becomes an arc here.</p>
<p>988<br>00:53:14,200 –&gt; 00:53:15,840<br>The dependence graph was this way, right?</p>
<p>989<br>00:53:15,840 –&gt; 00:53:20,519<br>In time, here this graph is this way, in time.</p>
<p>990<br>00:53:20,519 –&gt; 00:53:25,760<br>So say, T1 is waiting for something from T2.</p>
<p>991<br>00:53:25,760 –&gt; 00:53:30,160<br>T2 is waiting for something from T3.</p>
<p>992<br>00:53:30,160 –&gt; 00:53:33,760<br>And the deadlock completes when that last request comes in.</p>
<p>993<br>00:53:33,760 –&gt; 00:53:36,440<br>At this point, no progress will be made across these three transactions.</p>
<p>994<br>00:53:36,440 –&gt; 00:53:42,000<br>The system will just wait forever unless we break it.</p>
<p>995<br>00:53:42,000 –&gt; 00:53:44,000<br>Questions? Does that make sense?</p>
<p>996<br>00:53:46,000 –&gt; 00:53:48,079<br>Any cycle in the waste for graph?</p>
<p>997<br>00:53:48,079 –&gt; 00:53:51,000<br>Any cycle in the waste for graph will be a deadlock.</p>
<p>998<br>00:53:51,000 –&gt; 00:53:56,519<br>And a cool observation has been that most cycles tend to be of length two.</p>
<p>999<br>00:53:56,519 –&gt; 00:54:01,119<br>So a deadlock detection itself is a complex algorithm to run, computationally very expensive.</p>
<p>1000<br>00:54:01,119 –&gt; 00:54:05,840<br>So many times people will run, you know, so there’s a question of how frequently should I run this background thread</p>
<p>1001<br>00:54:05,840 –&gt; 00:54:10,159<br>to go through all the locks in the lock manager and compute this graph?</p>
<p>1002<br>00:54:10,159 –&gt; 00:54:13,119<br>The lock manager could have millions of entries in it.</p>
<p>1003<br>00:54:13,119 –&gt; 00:54:15,799<br>So computing this graph can be very expensive.</p>
<p>1004<br>00:54:15,799 –&gt; 00:54:20,159<br>But there are cheaper algorithms to say find cycles of length two,</p>
<p>1005<br>00:54:20,159 –&gt; 00:54:22,239<br>which can be done a lot faster.</p>
<p>1006<br>00:54:22,239 –&gt; 00:54:27,159<br>And wow, balloons went up over here because of this whole camera thing here.</p>
<p>1007<br>00:54:28,399 –&gt; 00:54:36,039<br>So you can have the background thread run more frequently to just find cycles of length two,</p>
<p>1008<br>00:54:36,039 –&gt; 00:54:38,039<br>but less frequently for the bigger cycles.</p>
<p>1009<br>00:54:39,039 –&gt; 00:54:41,039<br>Okay, that’s just a tidbit.</p>
<p>1010<br>00:54:41,039 –&gt; 00:54:47,039<br>In case you get super interested and excited about the deadlock detection stuff.</p>
<p>1011<br>00:54:47,039 –&gt; 00:54:53,039<br>The main point is finding this graph if you’ve got a large lock manager table,</p>
<p>1012<br>00:54:53,039 –&gt; 00:54:55,039<br>where there are lots of entries is expensive.</p>
<p>1013<br>00:54:55,039 –&gt; 00:54:57,039<br>So you can just run this all the time.</p>
<p>1014<br>00:54:57,039 –&gt; 00:54:59,039<br>You’re going to have to run it periodically.</p>
<p>1015<br>00:54:59,039 –&gt; 00:55:04,039<br>Okay, so that’s the tradeoff between the frequency of checking and how long the transactions wait.</p>
<p>1016<br>00:55:05,039 –&gt; 00:55:06,039<br>You can check all the time.</p>
<p>1017<br>00:55:06,039 –&gt; 00:55:10,039<br>You’ll find the deadlock quickly, but you’re spending a lot of cycles in just finding deadlocks.</p>
<p>1018<br>00:55:10,039 –&gt; 00:55:14,039<br>If you check, let’s say every day, then a deadlock that’s been formed for a day,</p>
<p>1019<br>00:55:14,039 –&gt; 00:55:16,039<br>you won’t find it for a long time.</p>
<p>1020<br>00:55:16,039 –&gt; 00:55:20,039<br>So if you follow the container draft,</p>
<p>1021<br>00:55:20,039 –&gt; 00:55:24,039<br>the lock can check for the client find the dynamite.</p>
<p>1022<br>00:55:24,039 –&gt; 00:55:25,039<br>Yeah.</p>
<p>1023<br>00:55:25,039 –&gt; 00:55:33,039<br>So the question is, can I maintain this lock graph dynamically every time I do?</p>
<p>1024<br>00:55:33,039 –&gt; 00:55:38,039<br>And entry, if you make a request to the lock manager, you could, but then that will add more cost.</p>
<p>1025<br>00:55:38,039 –&gt; 00:55:41,039<br>See, you’re trying to make this lock manager go really fast.</p>
<p>1026<br>00:55:41,039 –&gt; 00:55:42,039<br>I’m acquiring a lock, let it go.</p>
<p>1027<br>00:55:42,039 –&gt; 00:55:46,039<br>And if you start to say I also need to update and graph, that’s a tradeoff you’re making.</p>
<p>1028<br>00:55:46,039 –&gt; 00:55:49,039<br>It will double triple the time of each lock requests.</p>
<p>1029<br>00:55:49,039 –&gt; 00:55:53,039<br>And so what you would rather do is to have these locks,</p>
<p>1030<br>00:55:53,039 –&gt; 00:55:59,039<br>not have as many chance of having these types of conflicts, stop them early.</p>
<p>1031<br>00:55:59,039 –&gt; 00:56:02,039<br>That’s what the hierarchical locking will do as we’ll see in a little bit.</p>
<p>1032<br>00:56:02,039 –&gt; 00:56:10,039<br>And so there are all kinds of methods, but there’s a cost to dynamically keeping that graph in memory all the time.</p>
<p>1033<br>00:56:10,039 –&gt; 00:56:14,039<br>And sometimes when you’re in a distributed system, that state is not in one place.</p>
<p>1034<br>00:56:14,039 –&gt; 00:56:17,039<br>The lock manager is at each node and the deadlock detection.</p>
<p>1035<br>00:56:17,039 –&gt; 00:56:21,039<br>Someone is to bring all of it together to one node and then do this stuff.</p>
<p>1036<br>00:56:21,039 –&gt; 00:56:25,039<br>So you don’t even have a global graph till you bring it together in a distributed system.</p>
<p>1037<br>00:56:25,039 –&gt; 00:56:29,039<br>And most database systems like Snowflake, Databricks,</p>
<p>1038<br>00:56:29,039 –&gt; 00:56:33,039<br>all the things that Microsoft, Amazon and Google offer, they’re distributed.</p>
<p>1039<br>00:56:33,039 –&gt; 00:56:36,039<br>And so it’s starting to one place.</p>
<p>1040<br>00:56:36,039 –&gt; 00:56:38,039<br>So even more expensive.</p>
<p>1041<br>00:56:38,039 –&gt; 00:56:42,039<br>Are the questions?</p>
<p>1042<br>00:56:42,039 –&gt; 00:56:44,039<br>Okay, so deadlock detection.</p>
<p>1043<br>00:56:44,039 –&gt; 00:56:46,039<br>How are we going to do that?</p>
<p>1044<br>00:56:46,039 –&gt; 00:56:48,039<br>Let’s say we found a cycle.</p>
<p>1045<br>00:56:48,039 –&gt; 00:56:52,039<br>Now we have to choose which node to kill, which transaction to abort.</p>
<p>1046<br>00:56:52,039 –&gt; 00:56:56,039<br>And this is remember last time we talked about how a transaction we start.</p>
<p>1047<br>00:56:56,039 –&gt; 00:56:59,039<br>And sometimes the database may abort the transaction for you.</p>
<p>1048<br>00:56:59,039 –&gt; 00:57:02,039<br>So you as an application programmer write your code.</p>
<p>1049<br>00:57:02,039 –&gt; 00:57:06,039<br>And you have to be ready for what happens if it gets aborted.</p>
<p>1050<br>00:57:06,039 –&gt; 00:57:12,039<br>So often in good applications, you’ll say if a bot retry five times or whatever before you give up and throw an application error.</p>
<p>1051<br>00:57:12,039 –&gt; 00:57:16,039<br>Why would someone, why would the database abort that deadlock happen?</p>
<p>1052<br>00:57:16,039 –&gt; 00:57:17,039<br>Is the common reason, right?</p>
<p>1053<br>00:57:17,039 –&gt; 00:57:20,039<br>You were doing something, some of the application code was doing something.</p>
<p>1054<br>00:57:20,039 –&gt; 00:57:22,039<br>And the database detects a deadlock.</p>
<p>1055<br>00:57:22,039 –&gt; 00:57:27,039<br>One of those application code, one of those SQL queries has to get aborted.</p>
<p>1056<br>00:57:27,039 –&gt; 00:57:34,039<br>And that’s the bot is not because the programmer had an explicit bot call is because the database has to abort for a deadlock.</p>
<p>1057<br>00:57:34,039 –&gt; 00:57:37,039<br>And how would you choose what the victim is?</p>
<p>1058<br>00:57:37,039 –&gt; 00:57:41,039<br>There are multiple ways you could say, no, a timestamp.</p>
<p>1059<br>00:57:41,039 –&gt; 00:57:45,039<br>Or you could say, I will abort the transaction that has done the least amount of work.</p>
<p>1060<br>00:57:45,039 –&gt; 00:57:51,039<br>You might have some definition of work saying, oh, you fired 10 queries in the between the beginning and end statements.</p>
<p>1061<br>00:57:51,039 –&gt; 00:57:58,039<br>10 have been fired. The other one is just fired to some going to go kill the transaction, which has done less amount of work.</p>
<p>1062<br>00:57:58,039 –&gt; 00:58:03,039<br>By the number of items that are locked in the lock table, because that may be a proxy of the amount of work that some one’s done.</p>
<p>1063<br>00:58:03,039 –&gt; 00:58:06,039<br>Basically, when you abort a transaction, you’re losing all that work, right?</p>
<p>1064<br>00:58:06,039 –&gt; 00:58:10,039<br>Then you’ll have to get redone. So you’re trying to optimize for that.</p>
<p>1065<br>00:58:10,039 –&gt; 00:58:17,039<br>But the balancing part is that if you abort a transaction that has done the least amount of work or made the least amount of progress,</p>
<p>1066<br>00:58:17,039 –&gt; 00:58:23,039<br>then you could end up starving some transaction that can never make progress, because the older transactions could always be ahead of it.</p>
<p>1067<br>00:58:23,039 –&gt; 00:58:34,039<br>So you want to avoid starvation. And so sometimes what you happen, what you end up doing is to say, if I’m using a timestamp based protocol, which is pretty common, then when I abort the transaction and gets resend,</p>
<p>1068<br>00:58:34,039 –&gt; 00:58:42,039<br>I will keep the original timestamp. So the transaction gets higher and higher priority so that it has some chance of finishing at some point in time.</p>
<p>1069<br>00:58:42,039 –&gt; 00:58:45,039<br>If you give it a new timestamp, it may never get run.</p>
<p>1070<br>00:58:45,039 –&gt; 00:58:56,039<br>All right. So now when you have to undo a transaction and it has to be killed, there are two different ways to do it.</p>
<p>1071<br>00:58:56,039 –&gt; 00:59:05,039<br>One is you could abort the entire transaction. And in SQL, you’re also allowed, let’s see, you’re writing application code in which there are 10 SQL statements that the application needs, right?</p>
<p>1072<br>00:59:05,039 –&gt; 00:59:16,039<br>The first one is your flight has been confirmed. The hotel has been confirmed. Stuff like that. And you reach the, reach the ninth step and realize the last query is the one that costs trouble.</p>
<p>1073<br>00:59:16,039 –&gt; 00:59:24,039<br>You may want to say, don’t abort everything. Just roll back to the previous save point. So you can explicitly put save point calls.</p>
<p>1074<br>00:59:24,039 –&gt; 00:59:30,039<br>So you as a programmer have to do that. And then you can say, if it aborts, just roll back to that and I’ll try again just that last step.</p>
<p>1075<br>00:59:30,039 –&gt; 00:59:37,039<br>So you as an application programmer have to explicitly put these save points, but there’s a mechanism so that you can tell the database.</p>
<p>1076<br>00:59:37,039 –&gt; 00:59:43,039<br>If you need to abort me, just abort me to this level. All right.</p>
<p>1077<br>00:59:43,039 –&gt; 00:59:53,039<br>The other side of dealing with deadlocks is deadlock prevention. So what it’s going to do is I’m going to stop the deadlock at the first touch.</p>
<p>1078<br>00:59:54,039 –&gt; 01:00:10,039<br>And so here’s what it will do is imagine two transactions, T1 and T2 are have come into the system and T1 is older than T2.</p>
<p>1079<br>01:00:10,039 –&gt; 01:00:16,039<br>So the first protocol called weight die says if the transaction that is requesting has a higher priority.</p>
<p>1080<br>01:00:16,039 –&gt; 01:00:26,039<br>So it’s older than the transaction who already has the lock. Then what I’m going to do is to allow that requesting transaction.</p>
<p>1081<br>01:00:29,039 –&gt; 01:00:36,039<br>Then the requesting transaction can wait for it. So if I’m an older transaction, I’m allowed to wait for the younger transaction who has the lock.</p>
<p>1082<br>01:00:37,039 –&gt; 01:00:47,039<br>So that’s the way tie the wound weight is a little terrible. If you think the old and the young analogy is like family old transaction and the young person has it.</p>
<p>1083<br>01:00:47,039 –&gt; 01:00:59,039<br>I can abort it involuntarily and take away its locks. So it’s called wound weight, which means I wound the transaction because I’m older and I get the locks that they have.</p>
<p>1084<br>01:00:59,039 –&gt; 01:01:06,039<br>Both of them will prevent that cycle from happening because the minute someone starts to wait and all starts to form you saying, whoops, let’s kill it.</p>
<p>1085<br>01:01:06,039 –&gt; 01:01:13,039<br>So it’s a little aggressive, but it doesn’t require maintaining the weight for graphs and it doesn’t require going through this lock table and stuff like that.</p>
<p>1086<br>01:01:13,039 –&gt; 01:01:17,039<br>And hence it is simpler in that way, but maybe more ways for.</p>
<p>1087<br>01:01:18,039 –&gt; 01:01:26,039<br>And so if you want to look at an example up over here, let’s just go look at that.</p>
<p>1088<br>01:01:26,039 –&gt; 01:01:35,039<br>You’ve got the first situation where there’s T1 followed by T2 will go by timestamp. So T1 is older than T2 in both these examples.</p>
<p>1089<br>01:01:36,039 –&gt; 01:01:45,039<br>And so when T1 is waiting for T2 because T2 already at the lock on A in the weight die, T1 is allowed to wait. It’s older so it can wait.</p>
<p>1090<br>01:01:45,039 –&gt; 01:01:52,039<br>But if it is wound weight, T1 will be nasty. It will kill T2 and make progress.</p>
<p>1091<br>01:01:53,039 –&gt; 01:02:02,039<br>The other way around is T2 comes in and now wants to make a request for something that the older transaction has.</p>
<p>1092<br>01:02:02,039 –&gt; 01:02:11,039<br>The situation flips around in weight die. T2 will abort. It’s like young people can’t wait for old people and wound weight says, yeah, fine, if you’re younger, you can wait.</p>
<p>1093<br>01:02:12,039 –&gt; 01:02:17,039<br>So you follow one of those protocols, you can mismatch like that, right? Or there is a point work. So you just follow one of the protocols.</p>
<p>1094<br>01:02:17,039 –&gt; 01:02:24,039<br>Essentially it says, as soon as I decide in some way in which the direction of the R codes in that waits for a graph.</p>
<p>1095<br>01:02:24,039 –&gt; 01:02:35,039<br>And as soon as I see an R capping, I stop it. That doesn’t mean the cycle is formed. I just don’t form Oxford. If you don’t allow Oxford to form, no cycles will form.</p>
<p>1096<br>01:02:36,039 –&gt; 01:02:44,039<br>Don’t mix and match in the same system. You have to follow only one. Otherwise it won’t work. You’ll get into a mess.</p>
<p>1097<br>01:02:44,039 –&gt; 01:02:51,039<br>So you can’t mix and match and say, for this part, I’ll do that. It’s just like follow one protocol.</p>
<p>1098<br>01:02:51,039 –&gt; 01:02:53,039<br>So what’s better for what scenarios?</p>
<p>1099<br>01:02:53,039 –&gt; 01:03:02,039<br>That’s a great question. There isn’t a very good answer for both of that. I think it depends on the application and the workload and the scenario.</p>
<p>1100<br>01:03:03,039 –&gt; 01:03:14,039<br>But people still research into what ways to break deadlocks and what to do with that. So it’s an open question. But there isn’t a not that I know of a very approved that says is better than me.</p>
<p>1101<br>01:03:16,039 –&gt; 01:03:17,039<br>If you find one, let me know.</p>
<p>1102<br>01:03:18,039 –&gt; 01:03:32,039<br>Okay. So we’ve talked about why these guarantees, why these systems work, you know, hopefully getting to understand that when we deal with transactions, we like to visualize things that graphs and cycles are bad.</p>
<p>1103<br>01:03:32,039 –&gt; 01:03:40,039<br>And all that’s happening across the dependence graph and wait for graphs is we are trying to, we are basically finding ways to not have these cycles get formed.</p>
<p>1104<br>01:03:41,039 –&gt; 01:03:51,039<br>All right. So so far what we talked about is all these schemes that we have have a one to one mapping from the database objects to the locks.</p>
<p>1105<br>01:03:51,039 –&gt; 01:03:59,039<br>And if you want to update a billion records, as we just mentioned towards the beginning of the class, will be acquired a billion locks.</p>
<p>1106<br>01:03:59,039 –&gt; 01:04:06,039<br>And that’s very expensive, right. Baking changes to the hash table is pretty expensive and can we do better.</p>
<p>1107<br>01:04:07,039 –&gt; 01:04:20,039<br>So there is this notion called hierarchies of locking and space on a very simple observation saying database objects.</p>
<p>1108<br>01:04:20,039 –&gt; 01:04:29,039<br>Let’s think about a record doesn’t sit by itself. We put record into pages. We put pages into tables tables into databases.</p>
<p>1109<br>01:04:30,039 –&gt; 01:04:39,039<br>So we have a hierarchical structure for how we’ve organized the data. And in fact, that hierarchical structure is also how we access the data, right.</p>
<p>1110<br>01:04:39,039 –&gt; 01:04:45,039<br>In the execution code that you wrote for your operators, you open a file and start scanning the record, right.</p>
<p>1111<br>01:04:45,039 –&gt; 01:04:53,039<br>First you start with the database, then the table and then the pages and then the records. So you’re following that hierarchical structure.</p>
<p>1112<br>01:04:53,039 –&gt; 01:05:00,039<br>So the question is can we try to acquire locks at different granularities.</p>
<p>1113<br>01:05:00,039 –&gt; 01:05:12,039<br>So I could have a page level lock, a record level lock, sorry, a column level lock, but also a table level lock or a database level lock and allow mix and matching of all of those.</p>
<p>1114<br>01:05:12,039 –&gt; 01:05:20,039<br>Oh, and by the way, let’s also have different types of locks. Some that are more relaxed. So that sounds like bizarre, but that’s where the breakthrough that.</p>
<p>1115<br>01:05:20,039 –&gt; 01:05:27,039<br>This this paper had and the work that IBM and Jim graded was so exciting and totally changed the field.</p>
<p>1116<br>01:05:27,039 –&gt; 01:05:37,039<br>So here’s how it looks. I have a database structure hierarchy databases have tables tables have pages pages, pages have records and records have columns or attributes.</p>
<p>1117<br>01:05:37,039 –&gt; 01:05:41,039<br>So now what I’m going to do is I will say I’m going to allow.</p>
<p>1118<br>01:05:41,039 –&gt; 01:05:54,039<br>So if I’ve got a transaction T1, if it wants to acquire a table level lock, it’s kind of like I can lock the table object and implicitly it’s locked everything below it.</p>
<p>1119<br>01:05:54,039 –&gt; 01:06:00,039<br>So now instead of record locking a billion records, I’ll just lock the table because I’m scanning the whole table.</p>
<p>1120<br>01:06:00,039 –&gt; 01:06:07,039<br>Way cheaper, right. And I can make everything that we talked about correct. And we’ll talk about this protocol at a very high level.</p>
<p>1121<br>01:06:07,039 –&gt; 01:06:17,039<br>So the whole paper on it, it takes a full lecture to go through this. And again, that’s going to be talked about in the database systems last, but hopefully you get the intuition for how it works.</p>
<p>1122<br>01:06:17,039 –&gt; 01:06:21,039<br>So database systems will actually allow things like that. They’ll say, you know what you can.</p>
<p>1123<br>01:06:21,039 –&gt; 01:06:33,039<br>The locking mechanism internally can lock at the database level, which is pretty rare. We talked about how in the early days of MongoDB, that’s the only lock they allowed at the database level, because it was easy to implement.</p>
<p>1124<br>01:06:33,039 –&gt; 01:06:44,039<br>It’s easy to implement. You get correctness, but no parallelism, right. So it performance suffers. But database systems now have these hierarchy of locking table level lock is very common for systems to have implemented.</p>
<p>1125<br>01:06:44,039 –&gt; 01:06:51,039<br>Page level is also very common. It’s very easy to put as you can imagine. The first time you access a patient, the buffer pool is when you can go.</p>
<p>1126<br>01:06:51,039 –&gt; 01:06:57,039<br>The buffer manager can make a request for the locks table stuff when you open the file that request can be made, right.</p>
<p>1127<br>01:06:57,039 –&gt; 01:07:08,039<br>If you’re doing record level locking, then when you’re scanning the records in the page is when that request can be made and very rarely systems also do attribute level locking.</p>
<p>1128<br>01:07:08,039 –&gt; 01:07:16,039<br>So an assistant that supports attribute level locking, obviously you can do a lot more parallelism because I’m doing record level locking and two transactions.</p>
<p>1129<br>01:07:16,039 –&gt; 01:07:28,039<br>One of them wants to update one column. The other one wants to update another column. They really don’t conflict. But if I only do record level locking, I will make them go one after the other.</p>
<p>1130<br>01:07:28,039 –&gt; 01:07:36,039<br>Right. So you go further down. You’ll get more parallelism, but you’ll also be do a lot more locking. So what you want is to allow if you want to do allow all of that.</p>
<p>1131<br>01:07:36,039 –&gt; 01:07:46,039<br>Can you mix and match that? Can you get the best of both worlds? And the answer is yes. And to do all of that correctly, you’re going to have to introduce this notion.</p>
<p>1132<br>01:07:46,039 –&gt; 01:07:47,039<br>Yep.</p>
<p>1133<br>01:07:47,039 –&gt; 01:07:59,039<br>I think you’ve tried to get as you know a lot, but they will go low to the entire thing. You had like a decomposed storage model where all the columns were particularly possible to block the columns like directly.</p>
<p>1134<br>01:07:59,039 –&gt; 01:08:15,039<br>Yeah. Very good. Excellent question. If I have a column store or a decomposed storage model, can I lock an entire column? Yes. You’ll just adjust the structure of this to say tables becomes columns. And so pages you’ll get columns and before caught below columns, you might have pages.</p>
<p>1135<br>01:08:15,039 –&gt; 01:08:24,039<br>And then it then that you would have columns. So absolutely. As long as you have a structural hierarchy for a column store, it would look different. That’s a great observation.</p>
<p>1136<br>01:08:24,039 –&gt; 01:08:43,039<br>Common or is it common or rare? It is pretty common because column stores get used in analytic systems. That’s a way in which you would be in an analytic system. Now, if you’re building the next question that you probably have is like, how common is it to do updates in a column store?</p>
<p>1137<br>01:08:43,039 –&gt; 01:08:53,039<br>The answer is more and more common because now people are trying to build these things called etched app systems. So typically what people will say I’ve got an analytic system and I’ve got a transaction system.</p>
<p>1138<br>01:08:53,039 –&gt; 01:09:05,039<br>But now I’m maintaining two systems. So an etched app system says I want to allow transactions and analytics and do that efficiently, but analytic workloads want column stores, whereas transactional systems wants to roast doors.</p>
<p>1139<br>01:09:05,039 –&gt; 01:09:18,039<br>So there’s a huge bunch of research going on on how to make that work. As long as you have a storage hierarchy, you can make the theory of this thing work. And that’s the beauty of this technique. It works with any hierarchical data structure.</p>
<p>1140<br>01:09:18,039 –&gt; 01:09:27,039<br>But how to make etched app systems work where I might have a row store and a column store is something that is being researched intensely in the community right now.</p>
<p>1141<br>01:09:27,039 –&gt; 01:09:34,039<br>So the question that I specifically specifically like having walked in on the entire column that common in the lab system.</p>
<p>1142<br>01:09:34,039 –&gt; 01:09:42,039<br>In all app systems, that’s what you would do. If it is not read only, if it’s not a read only database, if it’s read only database, everything you’re talking about won’t matter.</p>
<p>1143<br>01:09:42,039 –&gt; 01:09:54,039<br>Yeah, right. So there are all app systems to say, I designate you as just read only and no updates. This means none of the supplies. Right. Great.</p>
<p>1144<br>01:09:54,039 –&gt; 01:10:07,039<br>Other questions. Okay, and we won’t finish everything today, but that’s okay. Let’s see how much we can get to keep asking questions because this material takes a little time to digest.</p>
<p>1145<br>01:10:07,039 –&gt; 01:10:20,039<br>So to make all these hierarchies work, if you just kept a shared and exclusive lock, we won’t get much performance because you know if someone locks the entire database, there’s no parallelism, right. So it will backfire on us.</p>
<p>1146<br>01:10:20,039 –&gt; 01:10:30,039<br>So we need this thing called intentional locks, which sort of seems weird and connects to the question that was asked earlier. What are the more than two types of locks. Yeah, there are lots and lots of different types of locks.</p>
<p>1147<br>01:10:30,039 –&gt; 01:10:41,039<br>The simplest one is going to be one where we have something called intention to share. And what this says is look, I am traversing I’m T1, I’m traversing table T1.</p>
<p>1148<br>01:10:41,039 –&gt; 01:10:56,039<br>I don’t want to grab a shared lock on T1 because it may be too much. I only want to look at some records in T1. Right. Maybe I’m just accessing an index and only the records that match. And I don’t know what will end up. Maybe that index can.</p>
<p>1149<br>01:10:56,039 –&gt; 01:11:06,039<br>Ends up the predicate ranges such that I need to access every record or it is so narrow that I might access zero records or only one record in the table. I don’t know that.</p>
<p>1150<br>01:11:06,039 –&gt; 01:11:16,039<br>But I have to acquire that lock as I come down this hierarchy first. So I could acquire the shared lock on the table, but that could be really bad. Very few records actually need to be read.</p>
<p>1151<br>01:11:16,039 –&gt; 01:11:26,039<br>So here’s what I’m going to do. I’m going to say I haven’t I intend to grab a shared lock somewhere down below. So I will grab an is lock and intention to share lock.</p>
<p>1152<br>01:11:26,039 –&gt; 01:11:39,039<br>And the beauty of an is lock is it’s compatible with an I X lock, which is intention to right to get an exclusive lock somewhere down below. So the main line is I could grab an is lock. So other readers can of course go through.</p>
<p>1153<br>01:11:39,039 –&gt; 01:11:47,039<br>I’m just saying I intend to share down when I get below and actually grab a shared lock on the thing that I’m reading, but at the top level and not bragging.</p>
<p>1154<br>01:11:47,039 –&gt; 01:11:57,039<br>So I’m have this fight between if I just do let’s say a tuple level locking life is good with strict strong trick to face locking.</p>
<p>1155<br>01:11:57,039 –&gt; 01:12:04,039<br>But if I have to scan a lot of records, my locking overhead is too high. So I’m trying to balance the locking overhead with how much parallelism I allow.</p>
<p>1156<br>01:12:04,039 –&gt; 01:12:23,039<br>So the is locks come in different flavors. The cream in flavors are intention to share intention to grab a shared lock somewhere below I X is intention to grab an exclusive lock somewhere below and shared intention to six locks is I will read everything below.</p>
<p>1157<br>01:12:23,039 –&gt; 01:12:40,039<br>I know that already, but some things I may actually update so it may be I don’t have index built at all let’s say on a student record table student table and I want to scan everything and take everyone who’s got a B minus and move them to a B.</p>
<p>1158<br>01:12:40,039 –&gt; 01:12:45,039<br>I don’t know which ones I’m going to grab an exclusive lock, but I know I’m going to read everything.</p>
<p>1159<br>01:12:45,039 –&gt; 01:12:54,039<br>So I will say please don’t make me grab shared lock down below assume I’ve shared locked everything so just one lock and let’s say there’s only one student that I need to update out of 800 students.</p>
<p>1160<br>01:12:54,039 –&gt; 01:13:05,039<br>I will only grab one exclusive lock later for that one student that I need to change so it’s very efficient to locks right as opposed to having to grab 100 plus locks.</p>
<p>1161<br>01:13:05,039 –&gt; 01:13:25,039<br>So how does that work? We need a compatibility matrix before we can proceed and that compatibility matrix has a couple interesting points that I’d like to draw attention to one is that an is lock is compatible with an I X lock and what that is saying is that yes you intend to share.</p>
<p>1162<br>01:13:25,039 –&gt; 01:13:54,039<br>So do some read below this level in the hierarchy you will grab a proper shared lock on the stuff that you actually want to read and hey if someone else wants to grab an exclusive lock down below they could say at this level I’m just an I X lock in is and I X lock are compatible right and you’ll see that with an example and then the six lock is compatible with the is lock because six lock is like I’ve got a shared lock and everything below so of course read is compatible with a read including compatible with an intention.</p>
<p>1163<br>01:13:54,039 –&gt; 01:14:10,039<br>So that is also compatible. Okay, so let’s see we’ve got five minutes that should be enough to go through some of the core parts here. Let’s take this example of getting a balance from and he’s shady offshore bank account.</p>
<p>1164<br>01:14:10,039 –&gt; 01:14:22,039<br>I don’t think he really has one. There’s just an example so don’t tell people it’s real and then increase the bookies account balance by 1% and let’s go and look at what that looks like.</p>
<p>1165<br>01:14:22,039 –&gt; 01:14:50,039<br>So we’ve got a table of all these bank account information and we’ll start with the first transaction to read that record at that point we might only want to read that one record. So what we might say is at that I declare an I S walk on the table and then you know assuming there’s only one Andy I’m only going to read that one tuple and basically write a shared lock so two locks and done and I’m going to scan the entire table I’ll only grab shared locks on what I need to.</p>
<p>1166<br>01:14:50,039 –&gt; 01:15:08,039<br>Now at the same time the parallelism that is allowable here is that transaction T2 could be working concurrently while those locks are being held and can grab an I X lock and as long as it does not want to update the same record that is Andy’s record that transaction is allowed to proceed.</p>
<p>1167<br>01:15:20,039 –&gt; 01:15:38,039<br>Yeah, so the question is if you know you’re modifying the table can you grab an exclusive lock so there is some situations where you would do that for example maybe and that’s again a maybe if I’m trying to make a schema change to the table that means I’m going to change everything and for that you would say oh I would need to grab an exclusive lock on the table.</p>
<p>1168<br>01:15:38,039 –&gt; 01:15:51,039<br>So if you know that you’re going to make changes to everything below then you would stop the hierarchy and grab the lock nothing in the hierarchy called locking says that I couldn’t have grabbed an X lock on table R so it depends upon what I’m trying to do.</p>
<p>1169<br>01:15:51,039 –&gt; 01:15:53,039<br>Yep.</p>
<p>1170<br>01:15:53,039 –&gt; 01:16:05,039<br>So in this situation is it possible for us to grab all the way down and so we would like to go ahead and say for example in.</p>
<p>1171<br>01:16:05,039 –&gt; 01:16:14,039<br>Yeah, so you’re saying should transaction T2 have grabbed the read lock on the table and then upgraded to an X lock later.</p>
<p>1172<br>01:16:14,039 –&gt; 01:16:19,039<br>Sure, but also could it just like both of these transactions.</p>
<p>1173<br>01:16:19,039 –&gt; 01:16:23,039<br>Grab a shared lock on the entire table.</p>
<p>1174<br>01:16:23,039 –&gt; 01:16:26,039<br>Yeah, because we did that for the people.</p>
<p>1175<br>01:16:26,039 –&gt; 01:16:40,039<br>Yep, yep, and what are you trying to get so but that could prevent someone from doing an update this would not happen if both of them see right now we allowed an update to a record happen at the same time as a read to another record.</p>
<p>1176<br>01:16:40,039 –&gt; 01:16:47,039<br>We allowed update if I grabbed an S lock on the table no updates can happen on the records.</p>
<p>1177<br>01:16:47,039 –&gt; 01:16:55,039<br>So look what happened here right we allowed as long as they’re touching different parts of the same table we said it’s okay and this hierarchical locking allows that.</p>
<p>1178<br>01:16:55,039 –&gt; 01:16:59,039<br>That’s a logically we still have the intent.</p>
<p>1179<br>01:16:59,039 –&gt; 01:17:05,039<br>So the protocol is you’ll go down the hierarchy of the database structure.</p>
<p>1180<br>01:17:05,039 –&gt; 01:17:11,039<br>You can issue an is lock I X lock or six lock any of the lock modes we talked about.</p>
<p>1181<br>01:17:11,039 –&gt; 01:17:21,039<br>But if you do intention lock then down below you must grab a proper lock so if you do an is or X lock you must grab a S or an X lock below right.</p>
<p>1182<br>01:17:21,039 –&gt; 01:17:25,039<br>What is the benefit.</p>
<p>1183<br>01:17:25,039 –&gt; 01:17:38,039<br>Yeah, the benefit is imagine this query so here let’s go to this example and that will make it clear okay so imagine I’ve got this transaction T1 T2 and T3 and we’ll stop after this slide and pick it up in the next class.</p>
<p>1184<br>01:17:38,039 –&gt; 01:17:43,039<br>T1 wants to scan all the records and update only one.</p>
<p>1185<br>01:17:43,039 –&gt; 01:17:52,039<br>So now imagine this is a billion rows in it so here what we can do is T1 can come in and grab a six lock.</p>
<p>1186<br>01:17:52,039 –&gt; 01:17:59,039<br>S lock says implicitly now down below go ahead and read anything you’ve got the free permission free rights go do that.</p>
<p>1187<br>01:17:59,039 –&gt; 01:18:10,039<br>But the record you want to go update ask for an X lock if you get it go ahead and do your work only two locks as opposed to a billion locks being acquired right.</p>
<p>1188<br>01:18:10,039 –&gt; 01:18:20,039<br>And another transaction could come in that wants to read a single record it is allowed to go through at the same time because it will acquire an is lock which is compatible with the six lock.</p>
<p>1189<br>01:18:20,039 –&gt; 01:18:36,039<br>So more parallelism is being allowed fewer locks are being gathered are being issued efficient more parallel is allowed because at the same table that we request is allowed to go through a third transaction comes in that scans all the records.</p>
<p>1190<br>01:18:36,039 –&gt; 01:18:57,039<br>So allow to do all of its work till it gets to that last record so if it’s going to transaction that last transaction if it wants to grab an s lock it will wait till the table are because it has a six lock which is incompatible with an s lock so it will wait for that till it goes further down.</p>
<p>1191<br>01:18:57,039 –&gt; 01:19:18,039<br>And then when it is done it goes get that request so you know you could have said oh transaction to could have grabbed an is lock and then grab the billion reads till it got to the last record even that would be allowed at the transaction so wanted to do that if it wanted to say I want to go and I don’t mind paying the cost for the locks because I want to get this balance you could do that.</p>
<p>1192<br>01:19:18,039 –&gt; 01:19:43,039<br>So it probably wouldn’t do that because it make the protocol very hard but essentially what you saw here even with transaction T1 and T2 is that very few locks were requests were made and you allowed this level of parallelism right so you really get a much higher performance database system then you would get through the other ways if you didn’t have the intentional locks and hierarchies you will not get this level of parallelism.</p>
<p>1193<br>01:19:43,039 –&gt; 01:19:50,039<br>Alright I’m going to stop here I can take questions offline and then I’ll pick up from this slide in the next class Shubham hit it.</p>
<p>1194<br>01:20:13,039 –&gt; 01:20:43,039<br>So I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to</p>
<p>1195<br>01:20:43,039 –&gt; 01:21:06,359<br>stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here I’m going to stop here in the sea I’m going to stop here I’m going to stop here I’m going to stop here in the sea I’m going to stop here yes please I’m going to stop watching here in the ocean go home I’m going to stop here</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CMU15445 P17F202316 Two PhaseLockingConcurrencyControl</div>
      <div>http://example.com/2025/10/25/CMU15445 P17F202316-Two-PhaseLockingConcurrencyControl/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/25/CMU15445%20P18F202317-TimestampOrderingConcurrencyControl/" title="CMU15445 P18F202317 TimestampOrderingConcurrencyControl">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CMU15445 P18F202317 TimestampOrderingConcurrencyControl</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/25/CMU15445%20P16F202315-ConcurrencyControlTheory/" title="CMU15445 P16F202315 ConcurrencyControlTheory">
                        <span class="hidden-mobile">CMU15445 P16F202315 ConcurrencyControlTheory</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
