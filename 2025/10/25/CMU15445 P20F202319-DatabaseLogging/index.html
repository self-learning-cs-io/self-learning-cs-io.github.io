

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="100:00:00,000 –&gt; 00:00:28,000All right, Shubham, I think you have a couple announcements. 200:00:28,000 –&gt; 00:00:30,000You had something to share with the class? 300:00:30,000 –&gt; 00:00:32,000">
<meta property="og:type" content="article">
<meta property="og:title" content="CMU15445 P20F202319 DatabaseLogging">
<meta property="og:url" content="http://example.com/2025/10/25/CMU15445%20P20F202319-DatabaseLogging/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="100:00:00,000 –&gt; 00:00:28,000All right, Shubham, I think you have a couple announcements. 200:00:28,000 –&gt; 00:00:30,000You had something to share with the class? 300:00:30,000 –&gt; 00:00:32,000">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-25T05:03:39.734Z">
<meta property="article:modified_time" content="2025-10-25T05:03:39.735Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>CMU15445 P20F202319 DatabaseLogging - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CMU15445 P20F202319 DatabaseLogging"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-25 13:03" pubdate>
          2025年10月25日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          99 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">CMU15445 P20F202319 DatabaseLogging</h1>
            
            
              <div class="markdown-body">
                
                <p>1<br>00:00:00,000 –&gt; 00:00:28,000<br>All right, Shubham, I think you have a couple announcements.</p>
<p>2<br>00:00:28,000 –&gt; 00:00:30,000<br>You had something to share with the class?</p>
<p>3<br>00:00:30,000 –&gt; 00:00:32,000<br>Yeah, happy Diwali to everyone.</p>
<p>4<br>00:00:32,000 –&gt; 00:00:33,000<br>How was your Diwali?</p>
<p>5<br>00:00:33,000 –&gt; 00:00:36,000<br>It was good, it was good, but it’s like shifted, right?</p>
<p>6<br>00:00:36,000 –&gt; 00:00:42,000<br>So the Diwali in India just happened, but then there’s a US Diwali that’s happening the next weekend, because everyone has to do it twice.</p>
<p>7<br>00:00:42,000 –&gt; 00:00:43,000<br>So yeah.</p>
<p>8<br>00:00:43,000 –&gt; 00:00:45,000<br>I mean, that was nice.</p>
<p>9<br>00:00:45,000 –&gt; 00:00:50,000<br>And my goal was to visit me all the weekend and she was really interested in finding goals and in flowering.</p>
<p>10<br>00:00:50,000 –&gt; 00:00:54,000<br>And we came into the lab, so there was an interesting conversation.</p>
<p>11<br>00:00:54,000 –&gt; 00:00:57,000<br>Thank you, Andy, and you did that.</p>
<p>12<br>00:00:57,000 –&gt; 00:01:03,000<br>And I might be playing a couple of shows next weekend, so I’ll post you guys on that as well.</p>
<p>13<br>00:01:03,000 –&gt; 00:01:04,000<br>Great, wonderful.</p>
<p>14<br>00:01:04,000 –&gt; 00:01:06,000<br>Thank you.</p>
<p>15<br>00:01:06,000 –&gt; 00:01:09,000<br>All right, we have a bunch to cover today.</p>
<p>16<br>00:01:09,000 –&gt; 00:01:17,000<br>So we have a few things left over from the multi-version concurrency control part that we just started discussing last class.</p>
<p>17<br>00:01:17,000 –&gt; 00:01:22,000<br>And I’m going to spend about like 20, 25 minutes on the MVCC.</p>
<p>18<br>00:01:22,000 –&gt; 00:01:29,000<br>And there’s some portions of this that, depending on how much we make through today,</p>
<p>19<br>00:01:29,000 –&gt; 00:01:36,000<br>might just relegate to stuff that you read on your own that won’t be material for the exam, but I’ll tell you when we hit that point.</p>
<p>20<br>00:01:36,000 –&gt; 00:01:45,000<br>And then what you want to do for the bulk of today is to get started on the recovery component, which is going to be split across today and the next lecture.</p>
<p>21<br>00:01:45,000 –&gt; 00:01:49,000<br>So if you remember, we were doing this multi-version concurrency control.</p>
<p>22<br>00:01:49,000 –&gt; 00:01:57,000<br>So if I go back a couple of slides, we were essentially doing things where as changes were happening to these objects,</p>
<p>23<br>00:01:57,000 –&gt; 00:02:00,000<br>we were creating these chains of objects.</p>
<p>24<br>00:02:00,000 –&gt; 00:02:04,000<br>So let’s go to slides seven, where there you go.</p>
<p>25<br>00:02:04,000 –&gt; 00:02:08,000<br>So you saw how in this case, A was being read and written a bunch of times.</p>
<p>26<br>00:02:08,000 –&gt; 00:02:12,000<br>And what was happening in the databases, we were keeping track of all those versions.</p>
<p>27<br>00:02:12,000 –&gt; 00:02:21,000<br>We had to begin an end time stamp that basically told us, what is that value like A zero is valid from 0 to 1, from 1 to 2.</p>
<p>28<br>00:02:21,000 –&gt; 00:02:25,000<br>There’s a different value and two onwards till sometime in the future.</p>
<p>29<br>00:02:25,000 –&gt; 00:02:27,000<br>There’s a third value.</p>
<p>30<br>00:02:27,000 –&gt; 00:02:29,000<br>So that’s what multi-version does.</p>
<p>31<br>00:02:29,000 –&gt; 00:02:31,000<br>It’s going to create these different versions.</p>
<p>32<br>00:02:31,000 –&gt; 00:02:36,000<br>And now we, the readers are going to come in and find the right versions to work with.</p>
<p>33<br>00:02:36,000 –&gt; 00:02:40,000<br>So multi-version is really, really popular.</p>
<p>34<br>00:02:40,000 –&gt; 00:02:49,000<br>And in fact, if you look at the systems that use it, just about every modern system will use multi-version concurrency control.</p>
<p>35<br>00:02:49,000 –&gt; 00:02:56,000<br>Now, we’ll go and dig into the details of the other components that we need besides MVCC.</p>
<p>36<br>00:02:56,000 –&gt; 00:02:59,000<br>We need a version management component as we talked about.</p>
<p>37<br>00:02:59,000 –&gt; 00:03:04,000<br>And with those versions, you can decide which version of readers are allowed to see based upon their time stamp.</p>
<p>38<br>00:03:04,000 –&gt; 00:03:09,000<br>But we have a couple of other things to discuss about the MVCC design considerations.</p>
<p>39<br>00:03:09,000 –&gt; 00:03:15,000<br>So you’re going to try and knock through most of this today and see how far we can get.</p>
<p>40<br>00:03:15,000 –&gt; 00:03:20,000<br>And we are time-bucketing about 25 minutes to cover this component.</p>
<p>41<br>00:03:20,000 –&gt; 00:03:28,000<br>So we’ve talked about a whole bunch of concurrency control protocols, optimistic concurrency control, two-faced locking.</p>
<p>42<br>00:03:28,000 –&gt; 00:03:33,000<br>So the natural question you may be asking is, how is this related to MVCC?</p>
<p>43<br>00:03:33,000 –&gt; 00:03:39,000<br>So the best way to think about this is that MVCC is a mechanism that tells you how to maintain multiple versions.</p>
<p>44<br>00:03:39,000 –&gt; 00:03:45,000<br>You still need a way to protect that mechanism with a concurrency control protocol.</p>
<p>45<br>00:03:45,000 –&gt; 00:03:51,000<br>Multi-version basically creates a linked list of different versions.</p>
<p>46<br>00:03:51,000 –&gt; 00:03:56,000<br>And at some point, there is some writer that’s potentially writing and creating a new version.</p>
<p>47<br>00:03:56,000 –&gt; 00:03:58,000<br>We saw in those examples.</p>
<p>48<br>00:03:59,000 –&gt; 00:04:04,000<br>So obviously, we have to guard against things like two people trying to write and create new values.</p>
<p>49<br>00:04:04,000 –&gt; 00:04:08,000<br>Like if you have a single linked list, only one person can add to that linked list at the time.</p>
<p>50<br>00:04:08,000 –&gt; 00:04:11,000<br>So only one person can be creating a new version at the time.</p>
<p>51<br>00:04:11,000 –&gt; 00:04:19,000<br>And so we’re going to have a concurrency control mechanism that we need in addition to the mechanism of keeping these versions.</p>
<p>52<br>00:04:19,000 –&gt; 00:04:27,000<br>What this version stuff allows is that if I am a transaction that is reading something and my timestamp allows me to do that,</p>
<p>53<br>00:04:27,000 –&gt; 00:04:31,000<br>I can read an older version and the readers can get past the writers.</p>
<p>54<br>00:04:31,000 –&gt; 00:04:33,000<br>The writers don’t block the readers.</p>
<p>55<br>00:04:33,000 –&gt; 00:04:40,000<br>If the readers have the right timestamp or they have the appropriate serialization, serialization order, where they can pass through.</p>
<p>56<br>00:04:40,000 –&gt; 00:04:45,000<br>In two-faced locking, if I grab the right lock, there’s only one version.</p>
<p>57<br>00:04:45,000 –&gt; 00:04:46,000<br>Everyone has to wait for it.</p>
<p>58<br>00:04:46,000 –&gt; 00:04:48,000<br>A reader has to wait for it.</p>
<p>59<br>00:04:48,000 –&gt; 00:04:53,000<br>And that’s where we started to relax things with the intentional locking and things like that.</p>
<p>60<br>00:04:53,000 –&gt; 00:04:59,000<br>But still, writers will block readers in the end case with two-faced locking.</p>
<p>61<br>00:04:59,000 –&gt; 00:05:07,000<br>So the concurrency control protocols you have, you can see I can do a multi-version, which is a mechanism to allow what can be read at what time.</p>
<p>62<br>00:05:07,000 –&gt; 00:05:09,000<br>You’re keeping these different versions around.</p>
<p>63<br>00:05:09,000 –&gt; 00:05:17,000<br>Can be combined with optimistic concurrency control, where you’ll just run the three-faced protocol, except in the private workspaces, where you’ll keep these new versions.</p>
<p>64<br>00:05:17,000 –&gt; 00:05:24,000<br>Or two-faced locking, where you’ll use locking for objects that are getting created like the writers, not interfering with writers.</p>
<p>65<br>00:05:24,000 –&gt; 00:05:33,000<br>Or if a reader needs to read that version that is being written because the timestamp says you need to be at a version that has been written, they’ll have to wait for that.</p>
<p>66<br>00:05:33,000 –&gt; 00:05:36,000<br>So locking can be used to do that.</p>
<p>67<br>00:05:36,000 –&gt; 00:05:38,000<br>You can also do something very simple.</p>
<p>68<br>00:05:38,000 –&gt; 00:05:43,000<br>You’re not going to talk about that, but timestamp ordering where you have some mechanism for picking a timestamp.</p>
<p>69<br>00:05:43,000 –&gt; 00:05:46,000<br>And then use that to determine the serial order.</p>
<p>70<br>00:05:46,000 –&gt; 00:05:57,000<br>Effectively, all that says you can come up with even simpler mechanisms where you say, I grab a timestamp, let’s say at the beginning of the transaction, and I only read versions as of my timestamp, which is kind of what snapshot isolation does.</p>
<p>71<br>00:05:57,000 –&gt; 00:06:00,000<br>So you can get that data protocol.</p>
<p>72<br>00:06:00,000 –&gt; 00:06:04,000<br>What we’re going to concern ourselves with is these other topics now, right?</p>
<p>73<br>00:06:04,000 –&gt; 00:06:10,000<br>There are five things we need to talk about in addition to MVCC as a mechanism that creates this version.</p>
<p>74<br>00:06:10,000 –&gt; 00:06:14,000<br>The first one was concurrency control. They’re going to start knocking these other things down.</p>
<p>75<br>00:06:14,000 –&gt; 00:06:18,000<br>Like, next thing we’re going to look at is, how is the storage for this version maintained?</p>
<p>76<br>00:06:18,000 –&gt; 00:06:21,000<br>It’s a single link list that we are maintaining.</p>
<p>77<br>00:06:21,000 –&gt; 00:06:23,000<br>What are the different ways of organizing that?</p>
<p>78<br>00:06:23,000 –&gt; 00:06:29,000<br>Just as we looked at what are different ways of organizing records and pages and structures like that.</p>
<p>79<br>00:06:29,000 –&gt; 00:06:33,000<br>So let’s get to the version storage.</p>
<p>80<br>00:06:33,000 –&gt; 00:06:42,000<br>Now, we are creating these version chains and these version chains have these beginning and timestamps that are associated with it.</p>
<p>81<br>00:06:42,000 –&gt; 00:06:46,000<br>And there are different ways in which we could create these version chains.</p>
<p>82<br>00:06:46,000 –&gt; 00:06:51,000<br>As we’ll see, for all of the remainder topics that we have for MVCC for each of those mechanisms,</p>
<p>83<br>00:06:51,000 –&gt; 00:06:57,000<br>each of these addition things that we need to consider for MVCC, we’ll see there are some number of options.</p>
<p>84<br>00:06:57,000 –&gt; 00:07:02,000<br>There’ll be three, four, five options, and then each one of them will have their pros and cons.</p>
<p>85<br>00:07:02,000 –&gt; 00:07:07,000<br>So the first question we are going to look at with version storage is, how do we store these versions?</p>
<p>86<br>00:07:07,000 –&gt; 00:07:10,000<br>Guess what? There are three ways to do it.</p>
<p>87<br>00:07:10,000 –&gt; 00:07:14,000<br>Both of them have their pros and cons and some historical context.</p>
<p>88<br>00:07:14,000 –&gt; 00:07:21,000<br>The first one is a Pandone Lee storage where I’m going to create the chains, kind of like what we’ve been seeing in the diagram so far.</p>
<p>89<br>00:07:21,000 –&gt; 00:07:30,000<br>We’re in the same table where the record is, you’re going to create the version way, the components of those records.</p>
<p>90<br>00:07:30,000 –&gt; 00:07:40,000<br>Time travel, which is used by systems that didn’t have MVCC, but then realize that, wow, with MVCC you can get a lot more concurrency, especially for the readers.</p>
<p>91<br>00:07:40,000 –&gt; 00:07:48,000<br>So they slapped on a mechanism to keep versions by saying, I’ll just create a second copy of the table where all my versions are maintained and we’ll see that in a little bit.</p>
<p>92<br>00:07:48,000 –&gt; 00:07:54,000<br>The preferred way is delta storage. If you’re building an MVCC system from scratch, that’s kind of what you will use.</p>
<p>93<br>00:07:54,000 –&gt; 00:07:59,000<br>So what’s the simplest? It’s kind of what our diagrams have been.</p>
<p>94<br>00:07:59,000 –&gt; 00:08:12,000<br>So here I’ve got two records A and B and the entire records, even though only one value is being shown, like 111 in the first one, think of it as being the entire record.</p>
<p>95<br>00:08:12,000 –&gt; 00:08:25,000<br>That’s what’s getting stored in the table. And as you create new versions, you will create that essentially as a new record in that same table, in that same physical table or the physical file that is keeping track of all the records in there.</p>
<p>96<br>00:08:25,000 –&gt; 00:08:36,000<br>That’s because the new record has the same schema. All of them now have this additional, what is shown as a pointer, but that pointer is like that big and end time stamp and bunch of other information that’s associated with it.</p>
<p>97<br>00:08:36,000 –&gt; 00:08:45,000<br>So you’ll just create the new version and then you’ll maintain the pointers internal, right? So you can think of it as your slotted page organization being used to create a file.</p>
<p>98<br>00:08:45,000 –&gt; 00:08:56,000<br>And in that file, you have record IDs. So A0 is a record ID. A1 is a different record ID, but this is extra field of pointer that chains them together and allows you to maintain your singly linked list.</p>
<p>99<br>00:08:56,000 –&gt; 00:09:10,000<br>Right? Pretty straightforward. Easy to implement if you start with this slotted page organization and you had extra fields that you’re designing the first place with this big and end time stamp to keep track of all these pointers.</p>
<p>100<br>00:09:10,000 –&gt; 00:09:30,000<br>There is an interesting question where the version chain is a singly linked list. The question is where does a new version sit? Is it at the end of the chain or is there at the beginning of the chain and you could decide the implementation and their pros and cons to that from a perspective of what is easy to implement.</p>
<p>101<br>00:09:30,000 –&gt; 00:09:47,000<br>It’s very easy to implement something that goes from oldest to the new us because you just create a new record as we were just doing up over here. A new value, a value needs to be created, a new tuple, you just created at the end and then connect everything back to it like that.</p>
<p>102<br>00:09:47,000 –&gt; 00:10:05,000<br>So oldest to new us is the easiest and that’s what will get used as the mechanism in this last project assignment that you have in bus stop. But obviously the downside of that is if I have to find the latest version, I have to traverse the chain and notice these chains may actually be spread across multiple pages.</p>
<p>103<br>00:10:05,000 –&gt; 00:10:12,000<br>So you may have to go through multiple pages to go get a record ID that you’re interested in.</p>
<p>104<br>00:10:13,000 –&gt; 00:10:26,000<br>The other way is new as to all this but that’s more difficult to implement. It’s kind of logically you have to create the new record, move everything around to get that the change to work in the reverse direction.</p>
<p>105<br>00:10:26,000 –&gt; 00:10:35,000<br>And you’ll see there’s a circle point associated with both of these as to how does an index refer to the record ID right so if I create a three version.</p>
<p>106<br>00:10:36,000 –&gt; 00:10:48,000<br>The chain for the record a as you saw in the slides a little while back is like I have an index which one does it point to and the implications of this oldest to newest to oldest will become a little bit more apparent as we go through some of that.</p>
<p>107<br>00:10:48,000 –&gt; 00:10:57,000<br>But there are two ways that’s all we need to know of organizing this list and it can go from one forward to backward or the other way around.</p>
<p>108<br>00:10:58,000 –&gt; 00:11:01,000<br>So all the later the point to the question.</p>
<p>109<br>00:11:02,000 –&gt; 00:11:12,000<br>Yeah so are you in the newest to oldest the question is how are you updating that so imagine this is you can just think of it as a single link list.</p>
<p>110<br>00:11:12,000 –&gt; 00:11:24,000<br>And so here is a single link list maintained in a pen only storage going from oldest to newest if it’s the other way around you just have to flip the pointers around so there’s more pointer management stuff that you end up having to do.</p>
<p>111<br>00:11:25,000 –&gt; 00:11:32,000<br>You create a new record that becomes the head and what does it mean to be at the head it means that’s what someone else refers to if they’re coming from outside.</p>
<p>112<br>00:11:33,000 –&gt; 00:11:41,000<br>So it will become clear in a second as we get to the index box right the only thing you need to know is that yeah I can when I get to a record from somewhere else most of the time.</p>
<p>113<br>00:11:42,000 –&gt; 00:12:03,000<br>Often from an index do I land on the oldest or the newest and depending on the scheme to find my newest record have to chase down the chain if it’s newest to oldest if I’m only looking for new stuff which is often the most common pattern I’ll find it right away I don’t have to access a chain and these change can span across pages so it can be very expensive to chase this chain down.</p>
<p>114<br>00:12:03,000 –&gt; 00:12:10,000<br>Okay all right second type of storage is time travel and this is systems that.</p>
<p>115<br>00:12:11,000 –&gt; 00:12:32,000<br>Globden and NBCC system when they didn’t have one before will use something like that which requires the least destructive change to your existing storage structure so here if I have a record and I create a new record a two it will get put in the main table and then I’ve got a time travel table and that time travel table I’ll put the old values and the old values keep will keep getting accumulated.</p>
<p>116<br>00:12:33,000 –&gt; 00:12:58,000<br>In that second table so now if I need if I’m a reader and I’m only allowed to read a two I will start from the main table go down to a second table which is a different file so obviously that’s more expensive that way you won’t ever get locality to chase down that you’re crossing table boundaries but it doesn’t disrupt the main table with just has a single copy the most recent copy and as you can see over here.</p>
<p>117<br>00:12:58,000 –&gt; 00:13:07,000<br>And that most recent copy may not be the one that eventually gets committed will start talking about the recovery protocols a little bit but it’s the most recent copy in the chain.</p>
<p>118<br>00:13:07,000 –&gt; 00:13:10,000<br>At exists at that point in time.</p>
<p>119<br>00:13:10,000 –&gt; 00:13:19,000<br>If you do time travel storage it implicitly gives you new us to all this yes that’s correct that’s a good observation.</p>
<p>120<br>00:13:19,000 –&gt; 00:13:30,000<br>That’s correct and basically it’s done as you can imagine if you had a 30 year old database system and all of a seven NBC see is the way you get more</p>
<p>121<br>00:13:30,000 –&gt; 00:13:35,000<br>concurrency especially for the readers this is the least disruptive change you would make to your system.</p>
<p>122<br>00:13:35,000 –&gt; 00:13:39,000<br>Okay because your indices can keep pointing to the latest copy in the main table.</p>
<p>123<br>00:13:39,000 –&gt; 00:13:43,000<br>All right and the record ID hasn’t changed it’s still in the same slot in the same page.</p>
<p>124<br>00:13:43,000 –&gt; 00:13:48,000<br>Why is it a new installments like I get the head the service in the same version.</p>
<p>125<br>00:13:48,000 –&gt; 00:13:52,000<br>The newest is there yeah so.</p>
<p>126<br>00:13:52,000 –&gt; 00:14:02,000<br>Yeah and so here in this diagram as you can see it’s a little weird a two is the oldest which is wanting to a one which is which is not necessarily the old the newest but.</p>
<p>127<br>00:14:02,000 –&gt; 00:14:06,000<br>And you can flip it around and switch it around in a different way.</p>
<p>128<br>00:14:06,000 –&gt; 00:14:17,000<br>So it’s it can be hybrid between newest to oldest and oldest to newest but the newest copies always going to be in the main table through which you saw the access and that’s the main point.</p>
<p>129<br>00:14:17,000 –&gt; 00:14:33,000<br>A two is the newest one but you can imagine a weird scheme in which a two is in the main table but that points to something else that you know the chain for it become a one a two a three and a three is in the main table you could say yeah a three points to a one from the main table to the</p>
<p>130<br>00:14:33,000 –&gt; 00:14:41,000<br>time travel table you can come up with schemes like that to be not purely newest to oldest but if you have to say which one it sort of makes more sense it’s like the main table has a new</p>
<p>131<br>00:14:41,000 –&gt; 00:14:50,000<br>way stuff right which is where you’re starting your access from so you can do all kinds of fiber and with all of this stuff that’s I’m going to speed through it a little bit even find like 50 different schemes and there’s a full</p>
<p>132<br>00:14:50,000 –&gt; 00:14:56,000<br>pledge paper which I’ll leave you with because we could spend like four weeks just talking about NBC see.</p>
<p>133<br>00:14:56,000 –&gt; 00:15:02,000<br>All right so master version in this case is going to be get written in place.</p>
<p>134<br>00:15:02,000 –&gt; 00:15:14,000<br>All right so now let’s go on and so here that just showing that the master is getting written the preferred ways this delta storage so far all of this storage if I made</p>
<p>135<br>00:15:14,000 –&gt; 00:15:25,000<br>change to a single column I was actually making a full copy of the record and the record may have hundreds of columns so if I just changed one I’m doing everything I’m making a large amount of copy where the</p>
<p>136<br>00:15:25,000 –&gt; 00:15:36,000<br>difference really small so delta storage is essentially that keyword diff and I’ll only take the value the column that I’m changing which could be more than one in a given record depending upon what that</p>
<p>137<br>00:15:36,000 –&gt; 00:15:53,000<br>update query is and I’m going to store in delta storage that the value that has changed and then keep track of that through through a pointer right so essentially the big difference between the delta storage and the other</p>
<p>138<br>00:15:53,000 –&gt; 00:16:03,000<br>method is here you just keep track of just the value that has changed and this can get complicated to because there could be multiple values in a column that has changed as you can imagine you can</p>
<p>139<br>00:16:03,000 –&gt; 00:16:08,000<br>generalize that stuff to only keep in track of the change that you’ve made.</p>
<p>140<br>00:16:08,000 –&gt; 00:16:19,000<br>So I noticed that whether you use delta storage for our time travel you always keep the content of the data values in the other.</p>
<p>141<br>00:16:19,000 –&gt; 00:16:27,000<br>When you update the main table or do you add it like after you update the main.</p>
<p>142<br>00:16:27,000 –&gt; 00:16:37,000<br>Yeah yeah yeah so you’re asking when do I make a change in the main table versus the delta storage table so again there’s going to be a bunch of details but most of the time what you’re going to do is you</p>
<p>143<br>00:16:37,000 –&gt; 00:16:48,000<br>take the copy put it over there then update the value in that you’ll move the old one step out to the where is your backup storage or where is the change storage before you make it because you</p>
<p>144<br>00:16:48,000 –&gt; 00:16:58,000<br>remember that and you have to make that copy before because what happens if there’s a crash between you making those changes and both the values are the same they’ll have the same time stamp you can go clean some of that stuff if you needed to.</p>
<p>145<br>00:16:58,000 –&gt; 00:17:18,000<br>Yeah yeah yeah and so you’re getting into a little bit of this recovery protocols and the fact that sometimes you may want to undo some change because something about it absolutely all of that will happen with</p>
<p>146<br>00:17:18,000 –&gt; 00:17:46,000<br>versioning too and you’ll get to what we’ll do like literally what we’ll do is before we go and along with the changes that we make we’ll also write what we are going to talk about next which is log records to maintain the change and then depending upon how you’re using those log records you could do one of different schemes but we’ll record stuff to undo things so all you need to know now is yeah that things can happen while you’re making these changes that’s the recovery stuff we’ll start talking about where we’ll keep track of logs to to be able to back ourselves out of some unsafe state if we see some changes.</p>
<p>147<br>00:17:46,000 –&gt; 00:17:55,000<br>So that’s out of some unsafe state if we started to make this change and things crash in the middle or the transaction about it right yeah good question.</p>
<p>148<br>00:17:55,000 –&gt; 00:18:14,000<br>All right so delta storage is that transactions can recreate in all of these things transactions can recreate old values in the tuple based schemes which is go to the tuple and they get the whole thing here you can create old versions by applying the delta in the reverse order because it’s creating is keeping track of the delta right even though it’s not quite shown value is being changed.</p>
<p>149<br>00:18:14,000 –&gt; 00:18:25,000<br>It will say it might have some sort of a delta associated with it and we’ll talk about that from the logging perspective to with that notion of delta is effectively the same.</p>
<p>150<br>00:18:25,000 –&gt; 00:18:43,000<br>Now the minute you have versions you also need to do garbage collection and because as you keep building the version chains lots of updates let’s say happen to a record at some point the version chains will build up new readers are coming in they have a new time stamp no one’s reading no reader has a time stamp that was really really old.</p>
<p>151<br>00:18:43,000 –&gt; 00:18:59,000<br>So we need to clean up those versions and so there are again multiple ways in which you can go do this and you have to look for these expired versions and then we have to decide when it is safe to go and reclaim that.</p>
<p>152<br>00:18:59,000 –&gt; 00:19:20,000<br>Now when it is safe to do this expired version is typically you’re going to say I have some sort of transaction number or time stamp that I’m assigning to transactions and I kind of know what’s the oldest transaction that is running in the system anything older than that I don’t need so you have a way to go and figure out what portion of the tail of this version chain you can throw away.</p>
<p>153<br>00:19:20,000 –&gt; 00:19:49,000<br>Now the question is when you have this type of garbage collection that you need now you determine what you can throw away when do you go about doing that again there are two approaches you can do it at the top level going through the chains and I’m just going to assume everything is at the top level the same thing will generalize if it’s not and the two methods for the top level background vacuuming background thread does this cooperative cleaning is kind of where you bust your own tables right so when you see something wrong you go fix it that’s the second approach.</p>
<p>154<br>00:19:50,000 –&gt; 00:20:19,000<br>And then there’s something to do at the transaction now so let’s go through each of those techniques the top level GC is pretty straightforward I’ve got some background vacuuming thread that starts up every once in a while it goes and looks through all the place where the versions are right depending on the scheme is going to be in a different place and then it’s going to say I know what the latest transactions are so as these things are getting changed you end up with a place where you say at this point I can determine.</p>
<p>155<br>00:20:20,000 –&gt; 00:20:49,000<br>So I’m saying that a one the hundred anything with the version of hundred is no longer needed because I know all the transactions that are in the system no one needs a value older than hundred and I can basically go and start to vacuum those out and remove that now remember these version chains could be long they could be spread across different pages and things like that so this vacuuming process can be pretty expensive and making extensive changes to that entire database which should obviously is not just one file one table but it’s just one table.</p>
<p>156<br>00:20:50,000 –&gt; 00:21:20,000<br>So all the tables could have had this type of version management that is needed one optimization you could do in surf saying I’m always going to scan all the files from start to the end from the first page to the last page every time some update happens to a page will keep track of a simple metadata which might have one bit per page that marks the page as dirty so you’ve got a billion pages in your database and only 1000 of them were touched the vacuum process doesn’t need to go and read the billion pages to determine have you been touched right is there a version tail in the</p>
<p>157<br>00:21:20,000 –&gt; 00:21:29,000<br>are page that I need to clean up it will just go and look at the pages that are the ones that need this cleanup and only go and change those.</p>
<p>158<br>00:21:29,000 –&gt; 00:21:43,000<br>Okay so that’s an obvious optimization you build especially if you’re doing this on a large scale cooperative cleaning is you know if you don’t if you go to a sit down restaurant they’ll bring all the food for you and take away the plates from you but if you go to a place where you’re</p>
<p>159<br>00:21:43,000 –&gt; 00:22:12,000<br>busing it yourself you’ll go to the counter pick up your food and clean up your tray it’s kind of like that with cooperative cleaning as you do the work the workers as they do the work will identify if they see something that needs to be cleaned up and they will do the cleanup themselves and sometimes it’s like when do you do the cleanup while you’re doing the work or after transaction comments those are the choices that we can make will ignore those comments but the difference is that you don’t have a separate background thread that’s doing that you basically do.</p>
<p>160<br>00:22:12,000 –&gt; 00:22:40,000<br>You basically do a page forward style of work where imagine I am a transaction that wants to get a value a use an index to get to that that index now gets me to the a record but that a record imagine the chaining technique that we use is oldest to newest so it brings me to the head of the oldest I know what my time stamp is right so I know I don’t need that I need to keep chasing it down till I get to the one that I should be reading.</p>
<p>161<br>00:22:40,000 –&gt; 00:23:08,000<br>But as I do that since I’m already chasing down the version chain I’m bringing the pages into this if I need to might as a goal and help clean up till I get to the the value the record that I need to read which may by the way not be at the end of the chain right because it may be depending on what my transaction number is I should be reading that value a to and there may be newer versions behind it but whenever I need to stop I’ll stop and clean up stuff before me.</p>
<p>162<br>00:23:10,000 –&gt; 00:23:39,000<br>So I’m sure some some chain is really long that you never access yes so it can even happen that if I’ve got a chain that is really long and that record is no longer access it was very hot in 2020 and a billion you know Taylor Swift ticket counter and the Taylor Swift ticket counter for a venue was really popular and had a billion version chains million entries built up in the version chain now she is a very popular person.</p>
<p>163<br>00:23:40,000 –&gt; 00:23:55,000<br>There’s a new venue and no one’s going and cleaning that up and that could happen you could ask a more philosophical question is why did the chains build up if everyone is cleaning up on the fly but will defer that sometimes they may be deferring that I thought that’s what you’re going to ask but that can that can happen.</p>
<p>164<br>00:23:55,000 –&gt; 00:24:09,000<br>Okay and again as I said there are like so many million ways of combining these things in different ways that all you need to know is that there are these different schemes to do it and there are exclusive exclusive large number of ways in which you could combine all of this.</p>
<p>165<br>00:24:09,000 –&gt; 00:24:23,000<br>I do want to get to the indexing part which is important but before we do that remember two slides ago we said garbage collection tuple level and transaction level right so we finished the tuple level stuff now let’s go to the transaction level stuff.</p>
<p>166<br>00:24:23,000 –&gt; 00:24:36,000<br>The transaction level stuff is very is different every transaction is going to keep track of all the stuff that it is doing including things that it is now out dating because it created new versions.</p>
<p>167<br>00:24:36,000 –&gt; 00:24:52,000<br>A transaction knows right when it has added something to the version chain so in this approach as a transaction proceeds it’s doing an update and then the second operation comes in it’s creating these old versions the basic thing is when a transaction is done it knows that it’s going to be a new version.</p>
<p>168<br>00:24:52,000 –&gt; 00:25:21,000<br>It knows I created two versions one for record a one for record B and at that point a vacuum process can be handed over those versions and now that can determine saying by old is version I need is 10 onwards if all of these are less than 10 I can go clean it up right so the vacuum process doesn’t have to go through each and every page even with that dirty page marker to German where these versions are transaction just handed over to you so the and those are the things that I’m going to do.</p>
<p>169<br>00:25:21,000 –&gt; 00:25:33,000<br>And those are the things that need to get cleaned up so just a different way of doing that at clearing up the versions now this I want to suspend a little bit of time.</p>
<p>170<br>00:25:33,000 –&gt; 00:25:53,000<br>The rest of this material I’ll just basically leave it in slides and let you worry about it in other words index management is stuff up to all of this material material for exam questions with the last part I’m going to skim over and you don’t need to worry about so pay attention now all right so</p>
<p>171<br>00:25:54,000 –&gt; 00:26:02,000<br>indices point to object ideas to record ideas right imagine you have a slaughter page organization is going to say page number and the slot number.</p>
<p>172<br>00:26:03,000 –&gt; 00:26:19,000<br>Now if I’ve got the primary key index and I could be updating the primary key and I’m making changes to that I now need to figure out how I’m going to keep track of that version chain and version chain stuff we can keep track of the techniques we talked about but now I have to go and update that primary key.</p>
<p>173<br>00:26:19,000 –&gt; 00:26:37,000<br>That gets very tricky so often what happens when you’re doing this versioning type of mechanism for primary key updates you’ll basically treat it like a delete followed by an insert it makes the semantic clean and you won’t have that version chain develop right because you delete everything’s gone and do an insert.</p>
<p>174<br>00:26:37,000 –&gt; 00:27:06,000<br>The problem becomes more interesting with secondary keys because they are more complicated right in some sense the primary key controls the record right because you’re accessing the record the record idea and the primary key in many ways are analogous you can do these things like insert delete but for the secondary keys you can’t do that right it is a secondary key and there’s a very famous incident that happened at over a few years ago where they used to be on my sequel that had a good way of doing secondary indices.</p>
<p>175<br>00:27:07,000 –&gt; 00:27:32,000<br>And Postgres doesn’t have a good way so it is multi version both of them are multi version and as a result if you have lots of updates happening in your system the performance will go down quite poorly unless you have the good way of doing secondary indices so we’ll talk about the good and the bad way and so Uber went back and changed it again to Postgres from Postgres to my sequel because they realize that this was a problem so you know they hadn’t taken this class.</p>
<p>176<br>00:27:32,000 –&gt; 00:28:01,000<br>So secondary indices are going to point to logical pointers and herons some is going to be the problem is like those are think of it as surrogate pointers they can control the object they can’t really need to do this delete followed by an insert technique and the two approaches one is a logical pointer in a physical pointer so just look at it with a diagram I’ve got a version chain a for to a one and if I have a pendant stuff to it and let’s assume this is newest to us.</p>
<p>177<br>00:28:02,000 –&gt; 00:28:31,000<br>And same things will apply for other schemes but newest to all this is the is the interesting one I say get this value a from this primary key and I will go I’ll get the record ID right that’s what the index is going to have the record ID and I’ll go find the record a for which is the fourth version of the record a but it’s a physical record that I’m going to get I’m going to get a physical record ID and I can locate a for so far everything is good no problem but now you can see if the primary key is getting updated if I delete an insert it.</p>
<p>178<br>00:28:32,000 –&gt; 00:29:01,000<br>Then I don’t have to worry about a bunch of this the secondary indices however if I say get something which has to get to this record a the record ID is going to point to a for and that’s okay except I could have multiple secondary indices on the record a you know it has five columns I could have built a secondary index on each of those five columns now each of these secondary indices is going to point to that first record for older the newest.</p>
<p>179<br>00:29:02,000 –&gt; 00:29:28,000<br>So far everything is good nothing nothing bad has happened so far now you start to get into some issues which is if I have to go and update this value and create a new version a five what’s going to happen and have to update a five I’ll get a new record in a page fix the version change using these</p>
<p>180<br>00:29:28,000 –&gt; 00:29:47,000<br>that we discussed maybe a delta storage now I have to go and update each of the secondary indices to have the record ID is point to the new a five which is a lot of updates so one update to the record will cause every secondary index to be updated.</p>
<p>181<br>00:29:47,000 –&gt; 00:29:59,000<br>So you can see how this starts to become a huge problem right what would be the way to avoid it.</p>
<p>182<br>00:29:59,000 –&gt; 00:30:15,000<br>I already showed you yeah good good good but you’re paying attention that’s great seen computer science in direction is a very powerful technique you know 50% of problems can be solved with in direction right so instead of secondary indices pointing to the record IDs what you would do is you would say.</p>
<p>183<br>00:30:15,000 –&gt; 00:30:42,000<br>Because the primary key is kind of like a record ID the secondary index will say i’m just going to point to the primary key which does mean that when i’m accessing a record through the secondary key I have to go to the primary key and then get the record ID one extra hop if it’s if it’s hot that probably the primary key index is already in the buffer pool so it’s not too bad but what that gives me is that now if I change a record all I do is make the changes in the primary index the secondary index stuff doesn’t have to change.</p>
<p>184<br>00:30:42,000 –&gt; 00:31:00,000<br>So single update to a single column think about an ubers case if they change the rate for a taxi service and that’s changing all the time and that’s one field that was changed in a record now all the indices have to change that just causes the massive problem enhance that huge performance problem.</p>
<p>185<br>00:31:00,000 –&gt; 00:31:28,000<br>There’s another way to do the in direction which is to say what if you had a global structure that converted double ID to the to some sort of an address in every one went to that into the primary key you could do that but no one does that because the primary key index is essentially that they’ve been proposals that talk about doing that because hey does this mean if I’ve to use this more fancy scheme which is better for performance with the secondary key indices that I must have a primary key index the answer is yes.</p>
<p>186<br>00:31:28,000 –&gt; 00:31:41,000<br>The primary key index is typically always built because that’s how the system enforces primary key constraint so you can assume special in that environment you have that so that scheme is basically the preferred scheme to do it.</p>
<p>187<br>00:31:41,000 –&gt; 00:31:48,000<br>So if you’re doing versioning with just about every system does you have to be careful as to what your secondary indices point to.</p>
<p>188<br>00:31:48,000 –&gt; 00:31:51,000<br>Okay question.</p>
<p>189<br>00:31:51,000 –&gt; 00:32:17,000<br>So this works well when you’re new as to old as if my newest comes in an A5 it’s got a new record ID right so in this case it’ll have a new record ID that I need to point to.</p>
<p>190<br>00:32:17,000 –&gt; 00:32:24,000<br>You could have said if I had oldest to newest I wouldn’t have this problem which.</p>
<p>191<br>00:32:24,000 –&gt; 00:32:37,000<br>So the primary key point was when it’s point was the table index like where in the table you have to work yourself or do you have the point that actually.</p>
<p>192<br>00:32:38,000 –&gt; 00:32:53,000<br>Yeah so depends on the scheme if I’ve newest to oldest every index is going to point to the newest head of the leg okay and so we said look for primary key updates we’re going to assume that it’s delete followed by an insert so ignore that case right we swept it away by.</p>
<p>193<br>00:32:53,000 –&gt; 00:33:03,000<br>Different type of implementation so in this case now I’ve got newest to oldest and the version chain has build up a for is a new is which is being referred to by all the indices.</p>
<p>194<br>00:33:03,000 –&gt; 00:33:13,000<br>Right so now if I add let’s say a new a five version then all the secondary indices have to point to a five because you know they have to see the whole version chain to traverse through it.</p>
<p>195<br>00:33:13,000 –&gt; 00:33:26,000<br>But in the time time version that in the same position you are saying in the time travel where I had my you’re talking about the scheme number two where the main table had it yep.</p>
<p>196<br>00:33:26,000 –&gt; 00:33:50,000<br>So that’s right so in that scheme and you’re exactly right in the scheme where we had a separate time travel table that was the lowest lift for someone to go and get MVCC they’re the appointing to that main table so the record ID hasn’t moved it’s the same page ID slot ID and this problem is is is simpler over there absolutely.</p>
<p>197<br>00:33:50,000 –&gt; 00:34:06,000<br>But as I said look there are all kinds of schemes that will go through that I don’t want to spend an infinite amount of time in looking through all the combinations I believe you with a paper that talks about a lot of these combinations okay and then what are the different pros and cons but I’ll take that final question before you move on.</p>
<p>198<br>00:34:06,000 –&gt; 00:34:27,000<br>So you said for time travel you know but for Delta and you know again it will get into some other nuances even for time travel you can think about there’s a version chain that’s maintained but the head if it remains over there in the page ID and the record ID and it’s updated in place then this problem doesn’t happen if you have update in place and that’s the head of that table.</p>
<p>199<br>00:34:27,000 –&gt; 00:34:30,000<br>So how they have played for itself.</p>
<p>200<br>00:34:30,000 –&gt; 00:34:49,000<br>You can come up with all kinds of schemes to avoid this problem but most systems will do some sort of version management that may end up having this problem just need you to be aware that if your record IDs are moving around then if you’re using any sort of version management scheme and you’re going to run to trouble like this okay.</p>
<p>201<br>00:34:49,000 –&gt; 00:34:59,000<br>Okay good the rest of it from here onwards slide 27 onwards it’s not going to be material for the exam so I’m just going to skim through it really fast.</p>
<p>202<br>00:34:59,000 –&gt; 00:35:18,000<br>Because MVCC looks like the keys can be duplicate it turns out that even the primary keys if I’m using the scheme in which I’m updating a primary key and I have versions it’ll kind of look like if you think about the implementation of B tree for typically for a primary key you have implemented to say I can never have a duplicate key but in some sense I’m going to do it.</p>
<p>203<br>00:35:18,000 –&gt; 00:35:32,000<br>But in some sense the keys can have you may need duplicates for a little bit of time okay so again is a said I’m not going to go into the details for it but let you look for that and you can read the chapter in the book that talks about that but you have to worry about those components.</p>
<p>204<br>00:35:32,000 –&gt; 00:35:45,000<br>There’s also the issue of deletes again I’ll let you read that by yourself but there are different ways to implement the delete function by keeping a delete flag or a tombstone flag this has to do with I’ve got a version chain and if I’ve deleted.</p>
<p>205<br>00:35:45,000 –&gt; 00:36:14,000<br>There are different ways of deleting that and sometimes it’s better to just mark a record has been deleted and then eventually it can get cleaned up or you can have a tombstone based approach to basically clean up this version within a in a two step process so again the details for this not material for the exam but I encourage you to read the textbook but up to here the key problem I do want you to know and we may ask you questions about that okay.</p>
<p>206<br>00:36:14,000 –&gt; 00:36:37,000<br>Last piece over here just for those of you who have vocary or city is the there’s an explosion in the combinations as you can achieve with all of these different ways what’s my garbage collection what’s my index doing is it pointing to a physical record ID or is it pointing to a logical record ID that I can create in one of many different ways including pointing to the primary index.</p>
<p>207<br>00:36:37,000 –&gt; 00:37:06,000<br>What’s the protocol I use to protect the right objects right as versions are getting created I still need to protect that new versions getting created and you can do two face walking or optimistic concurrency control post cases some combination is to PL and also a time order protocol so a lot of these things are feasible as combination if you’re curious about the types of things that are feasible there are two papers that you may want to read that one is Andy had a beautiful paper on in memory MVCC so even a small number of people are going to be able to see the picture.</p>
<p>208<br>00:37:07,000 –&gt; 00:37:36,000<br>The smaller version then on this based MVCC which is even more choices for you but even in that the explosion number of choices is huge and it is an excellent job here in a students of cataloging the different mechanisms giving them proper names and categories is a beautiful paper to read if you’re interested in that and in memory MVCC super interesting because a lot of transactional databases fit in memory because today you can get a photo by server and very few transactional databases need a lot more than eight or 10 of them.</p>
<p>209<br>00:37:37,000 –&gt; 00:37:45,000<br>So I think that’s one of the things that I think is really important to me is to really do all of the work load including with replication and a little bit of fault tolerance.</p>
<p>210<br>00:37:46,000 –&gt; 00:37:53,000<br>There’s another paper if you wanted to go into a depth of one specific protocol I’d recommend the hackathon paper which is very clean.</p>
<p>211<br>00:37:53,000 –&gt; 00:38:18,000<br>There’s a guy that’s got these guys at Microsoft including Paul Larson who’s a giant in that field he’s since retired but one of my students worked on this it’s a very clean protocol as simple as all could make it without from others and it also has an interesting aspect because they had SQL server which is an on this stuff and they wanted to add this MVCC in memory stuff and they’re very interesting ways in which they could clean the put that together.</p>
<p>212<br>00:38:18,000 –&gt; 00:38:31,000<br>So hackathon is the in memory MVCC which can be put as an extension to SQL server which is an on this system so very clever engineering and a very clean protocol for the in memory case.</p>
<p>213<br>00:38:31,000 –&gt; 00:38:47,000<br>So those of you have been asking a million questions I love that please go take a look at that these papers won’t be covered in the graduate database class but if you’re interested stop by my office or I’d be happy to walk you to the paper and take questions and I’m sure Andy would too.</p>
<p>214<br>00:38:48,000 –&gt; 00:39:02,000<br>Alright you guys are doing a good job of making sure the exam is not going to have a lot of material so great but let’s keep moving.</p>
<p>215<br>00:39:02,000 –&gt; 00:39:13,000<br>Alright and let me just make sure sharing is still working great.</p>
<p>216<br>00:39:14,000 –&gt; 00:39:37,000<br>Alright so we’re going to talk about logging next and it’s part of a two piece component we’ll figure out how to log things so that we can make changes but if something crashes like some of the questions that were asked is like what happens if I’m adjusting this chain but I haven’t finished fixing the chain or I fixed the chain and something bad happens.</p>
<p>217<br>00:39:37,000 –&gt; 00:40:07,000<br>So I’m just going to talk about the things that are going to happen and I’m going to talk about the things that are going to happen and I’m going to talk about the things that are going to happen and I’m going to talk about the things that are going to happen and I’m going to talk about the things that are going to happen and I’m going to talk about the things that are going to happen and I’m going to talk about the things that are going to happen and I’m going to talk about the things that are going to happen and I’m going to talk about the things that are going to happen and I’m going to talk about the things that are going to happen and I’m going to talk about the things that are going to happen and I’m going to talk about the things that are going to happen and I’m going to talk about the things that are going to happen and I’m going to talk about the things that are going to happen and I’m going to talk about the things that are going to happen and I’m going to talk about the things that</p>
<p>218<br>00:40:07,000 –&gt; 00:40:28,639<br>you’ve needed 4000 and I’ve earlier prepared all these things, but you haven’t been able to pass through an online course or or actually it can be used for updates and Video Ads. there, and you can use</p>
<p>219<br>00:40:28,639 –&gt; 00:40:30,119<br>Project 4 is on Conquerancy Control.</p>
<p>220<br>00:40:30,119 –&gt; 00:40:33,960<br>It’s going to be out today and that’s due December 10th.</p>
<p>221<br>00:40:33,960 –&gt; 00:40:35,480<br>So you have a little bit of time for it,</p>
<p>222<br>00:40:35,480 –&gt; 00:40:36,559<br>but there’s a bunch in there.</p>
<p>223<br>00:40:36,559 –&gt; 00:40:39,920<br>So don’t wait again to the last minute for going through that.</p>
<p>224<br>00:40:39,920 –&gt; 00:40:43,319<br>And the write up on Fortune is going to be a little bit</p>
<p>225<br>00:40:43,319 –&gt; 00:40:45,799<br>detailed because getting into Conquerancy Control,</p>
<p>226<br>00:40:45,799 –&gt; 00:40:47,719<br>like optimization, it’s hard.</p>
<p>227<br>00:40:47,719 –&gt; 00:40:50,159<br>The optimization piece that you did was very light.</p>
<p>228<br>00:40:50,159 –&gt; 00:40:54,119<br>But here we’re going to have to get you into MVCC</p>
<p>229<br>00:40:54,119 –&gt; 00:40:55,039<br>and stuff like that.</p>
<p>230<br>00:40:55,039 –&gt; 00:40:57,599<br>So buckle up, it’s going to be fun.</p>
<p>231<br>00:40:57,599 –&gt; 00:41:00,679<br>But you’re going to get to do some interesting things</p>
<p>232<br>00:41:00,679 –&gt; 00:41:04,839<br>with MVCC and O2N type of version chains.</p>
<p>233<br>00:41:04,839 –&gt; 00:41:06,400<br>A bunch of database talks.</p>
<p>234<br>00:41:06,400 –&gt; 00:41:08,279<br>There are three more left in this.</p>
<p>235<br>00:41:08,279 –&gt; 00:41:12,839<br>And I think this is the last three in the semester.</p>
<p>236<br>00:41:12,839 –&gt; 00:41:16,239<br>I strongly recommend not missing, especially the Alibaba talk,</p>
<p>237<br>00:41:16,239 –&gt; 00:41:19,039<br>because they’re doing something at a massive scale.</p>
<p>238<br>00:41:19,039 –&gt; 00:41:21,679<br>And it’ll be super interesting to see what they talk about.</p>
<p>239<br>00:41:21,679 –&gt; 00:41:25,360<br>The PG vector stuff and Chroma is coming after that.</p>
<p>240<br>00:41:25,360 –&gt; 00:41:25,679<br>All right.</p>
<p>241<br>00:41:25,679 –&gt; 00:41:28,399<br>So let’s get to recovery protocols today.</p>
<p>242<br>00:41:28,399 –&gt; 00:41:29,719<br>Really fun stuff.</p>
<p>243<br>00:41:29,719 –&gt; 00:41:33,719<br>So you remember we had the asset components?</p>
<p>244<br>00:41:33,719 –&gt; 00:41:37,159<br>So far, we’ve only done I, which is the isolation stuff.</p>
<p>245<br>00:41:37,159 –&gt; 00:41:38,879<br>We still have A and D to cover.</p>
<p>246<br>00:41:38,879 –&gt; 00:41:42,559<br>And C, as we talked about, is consistency based upon databases</p>
<p>247<br>00:41:42,559 –&gt; 00:41:44,719<br>and integric constraints and other forms</p>
<p>248<br>00:41:44,719 –&gt; 00:41:48,039<br>of defining what semantics need to be enforced and we</p>
<p>249<br>00:41:48,039 –&gt; 00:41:48,839<br>will enforce that.</p>
<p>250<br>00:41:48,839 –&gt; 00:41:52,399<br>So let’s start getting into the recovery component,</p>
<p>251<br>00:41:52,399 –&gt; 00:41:55,599<br>which is the last missing piece, to complete the asset components.</p>
<p>252<br>00:41:56,559 –&gt; 00:42:00,000<br>So we’re going to want transactions to be all or nothing.</p>
<p>253<br>00:42:00,000 –&gt; 00:42:04,360<br>And we want to A part and we need transactions to be durable.</p>
<p>254<br>00:42:04,360 –&gt; 00:42:07,239<br>So if transaction is declared committed,</p>
<p>255<br>00:42:07,239 –&gt; 00:42:09,079<br>even after that, if the system crashes,</p>
<p>256<br>00:42:09,079 –&gt; 00:42:12,799<br>the changes are recorded in the state of the database.</p>
<p>257<br>00:42:12,799 –&gt; 00:42:17,759<br>So we’ll start simple with motivation, simple transaction,</p>
<p>258<br>00:42:17,759 –&gt; 00:42:19,519<br>reading writing stuff.</p>
<p>259<br>00:42:19,519 –&gt; 00:42:21,839<br>And now we have a buffer pool, which obviously</p>
<p>260<br>00:42:21,839 –&gt; 00:42:23,279<br>database systems have.</p>
<p>261<br>00:42:23,279 –&gt; 00:42:25,400<br>But now we’re going to make it explicit in our diagrams</p>
<p>262<br>00:42:25,400 –&gt; 00:42:27,559<br>because it’s because of the buffer pool</p>
<p>263<br>00:42:27,559 –&gt; 00:42:30,280<br>that we’re going to have to worry about a lot of things.</p>
<p>264<br>00:42:30,280 –&gt; 00:42:32,280<br>So we bring in a page.</p>
<p>265<br>00:42:32,280 –&gt; 00:42:34,639<br>The page has a lot of stuff, a lot of records,</p>
<p>266<br>00:42:34,639 –&gt; 00:42:36,200<br>a lot of columns in each record.</p>
<p>267<br>00:42:36,200 –&gt; 00:42:39,800<br>But one of them is that value A that we are trying to write,</p>
<p>268<br>00:42:39,800 –&gt; 00:42:43,440<br>the column A. And we’ll go bring that in.</p>
<p>269<br>00:42:43,440 –&gt; 00:42:46,720<br>And then when we write it, we will go and update that</p>
<p>270<br>00:42:46,720 –&gt; 00:42:48,599<br>in the buffer pool.</p>
<p>271<br>00:42:48,599 –&gt; 00:42:49,760<br>That’s what we do.</p>
<p>272<br>00:42:49,760 –&gt; 00:42:51,840<br>The updates happen in the buffer pool.</p>
<p>273<br>00:42:51,840 –&gt; 00:42:57,640<br>Now, at the time that we get to do a commit, what do we do?</p>
<p>274<br>00:42:57,640 –&gt; 00:43:02,160<br>To get durability, we could insist on taking any change</p>
<p>275<br>00:43:02,160 –&gt; 00:43:04,960<br>that has been made and push it out to disk.</p>
<p>276<br>00:43:04,960 –&gt; 00:43:07,160<br>And if we do that, we will get durability.</p>
<p>277<br>00:43:07,160 –&gt; 00:43:09,360<br>But it will be very slow.</p>
<p>278<br>00:43:09,360 –&gt; 00:43:11,200<br>But let’s say we have other protocols</p>
<p>279<br>00:43:11,200 –&gt; 00:43:14,519<br>that don’t require us to flush everything to disk at</p>
<p>280<br>00:43:14,519 –&gt; 00:43:16,039<br>commit time because this transaction could</p>
<p>281<br>00:43:16,039 –&gt; 00:43:18,480<br>have touched the billion records and the billion pages.</p>
<p>282<br>00:43:18,480 –&gt; 00:43:20,240<br>You don’t want to flush a billion pages.</p>
<p>283<br>00:43:20,239 –&gt; 00:43:22,119<br>But what happens if the power goes out?</p>
<p>284<br>00:43:22,119 –&gt; 00:43:24,799<br>Or someone zaps the memory?</p>
<p>285<br>00:43:24,799 –&gt; 00:43:27,879<br>And if they zaps the memory, we’ve committed the transaction.</p>
<p>286<br>00:43:27,879 –&gt; 00:43:31,519<br>But the change was only in the buffer pool and we’ve lost it.</p>
<p>287<br>00:43:31,519 –&gt; 00:43:35,599<br>So we don’t have a durable transaction anymore.</p>
<p>288<br>00:43:35,599 –&gt; 00:43:38,959<br>There is Andy’s picture of saying a bad guy comes and zaps it.</p>
<p>289<br>00:43:38,959 –&gt; 00:43:40,759<br>So all right.</p>
<p>290<br>00:43:40,759 –&gt; 00:43:43,039<br>So that’s what crash recovery is all about.</p>
<p>291<br>00:43:43,039 –&gt; 00:43:46,279<br>And we have to go and get this atomicity and durability</p>
<p>292<br>00:43:46,279 –&gt; 00:43:47,399<br>components.</p>
<p>293<br>00:43:47,399 –&gt; 00:43:49,199<br>And we’re going to do this in two parts.</p>
<p>294<br>00:43:49,199 –&gt; 00:43:50,079<br>So there are two lectures.</p>
<p>295<br>00:43:50,079 –&gt; 00:43:52,839<br>Today we’ll talk about the first part is what actions</p>
<p>296<br>00:43:52,839 –&gt; 00:43:56,199<br>do we need to take during regular transaction processing</p>
<p>297<br>00:43:56,199 –&gt; 00:43:59,279<br>to create stuff that we need to recover from.</p>
<p>298<br>00:43:59,279 –&gt; 00:44:01,279<br>The second part, which is once you have</p>
<p>299<br>00:44:01,279 –&gt; 00:44:04,960<br>kept stuff that you need to keep around, how do you recover?</p>
<p>300<br>00:44:04,960 –&gt; 00:44:07,879<br>That’s the second lecture on Wednesday.</p>
<p>301<br>00:44:07,879 –&gt; 00:44:11,319<br>So today, what do we need to do?</p>
<p>302<br>00:44:11,319 –&gt; 00:44:16,079<br>So here are the six things that we need to worry about.</p>
<p>303<br>00:44:16,079 –&gt; 00:44:18,399<br>First, we’ll talk about why failures happen.</p>
<p>304<br>00:44:18,400 –&gt; 00:44:20,440<br>Then we’ll talk about buffer pool policies</p>
<p>305<br>00:44:20,440 –&gt; 00:44:21,920<br>because that is at the heart of why</p>
<p>306<br>00:44:21,920 –&gt; 00:44:24,400<br>we need to do these fancy new things.</p>
<p>307<br>00:44:24,400 –&gt; 00:44:26,119<br>And then we’ll talk about two different mechanisms,</p>
<p>308<br>00:44:26,119 –&gt; 00:44:27,960<br>shadow paging and right-ahead logging</p>
<p>309<br>00:44:27,960 –&gt; 00:44:30,840<br>as a way of keeping track of changes that we make.</p>
<p>310<br>00:44:30,840 –&gt; 00:44:32,960<br>And I’ll tell you, shadow paging is a bad idea.</p>
<p>311<br>00:44:32,960 –&gt; 00:44:34,880<br>It’s what old system you use.</p>
<p>312<br>00:44:34,880 –&gt; 00:44:36,680<br>It has all kinds of issues.</p>
<p>313<br>00:44:36,680 –&gt; 00:44:38,599<br>I will only touch upon it and then</p>
<p>314<br>00:44:38,599 –&gt; 00:44:41,920<br>move to right-ahead logging, which is the main part that we need.</p>
<p>315<br>00:44:41,920 –&gt; 00:44:43,680<br>And then we’ll talk about some of the logging schemes,</p>
<p>316<br>00:44:43,680 –&gt; 00:44:47,240<br>what do you put in these logs and then checkpointing.</p>
<p>317<br>00:44:47,239 –&gt; 00:44:50,799<br>So first, we’re going to have to concern ourselves</p>
<p>318<br>00:44:50,799 –&gt; 00:44:52,919<br>with these different storage types.</p>
<p>319<br>00:44:52,919 –&gt; 00:44:54,519<br>And we’ve talked about this.</p>
<p>320<br>00:44:54,519 –&gt; 00:44:56,839<br>I’m going to go to the next slide and come back to it.</p>
<p>321<br>00:44:56,839 –&gt; 00:44:58,919<br>You remember this slide on the right that we had,</p>
<p>322<br>00:44:58,919 –&gt; 00:45:02,279<br>which is, which talked about data is in different places.</p>
<p>323<br>00:45:02,279 –&gt; 00:45:05,079<br>And there’s a reason why we have processor caches and DRAM</p>
<p>324<br>00:45:05,079 –&gt; 00:45:08,679<br>and SSDs and slow SSDs and fast SSDs.</p>
<p>325<br>00:45:08,679 –&gt; 00:45:10,679<br>Because as you go down this hierarchy,</p>
<p>326<br>00:45:10,679 –&gt; 00:45:13,919<br>you get more capacity, but it’s also slower.</p>
<p>327<br>00:45:13,919 –&gt; 00:45:16,519<br>And you don’t want to have all the data</p>
<p>328<br>00:45:16,519 –&gt; 00:45:19,840<br>be in the lowest capacity, let’s say SSD or a spinning disk.</p>
<p>329<br>00:45:19,840 –&gt; 00:45:21,599<br>If you didn’t have a buffer pool, the database system</p>
<p>330<br>00:45:21,599 –&gt; 00:45:22,679<br>would be very slow.</p>
<p>331<br>00:45:22,679 –&gt; 00:45:25,400<br>So we want to use the highest level, which</p>
<p>332<br>00:45:25,400 –&gt; 00:45:28,639<br>is going to be volatile storage, which is DRAM.</p>
<p>333<br>00:45:28,639 –&gt; 00:45:30,639<br>Because that’s where you want to make all of your changes.</p>
<p>334<br>00:45:30,639 –&gt; 00:45:32,400<br>That’s fast.</p>
<p>335<br>00:45:32,400 –&gt; 00:45:34,440<br>But it’s volatile.</p>
<p>336<br>00:45:34,440 –&gt; 00:45:36,759<br>The non-volatile storage, the SSD layer,</p>
<p>337<br>00:45:36,759 –&gt; 00:45:40,759<br>is where you want to make sure you put your changes in there</p>
<p>338<br>00:45:40,759 –&gt; 00:45:44,280<br>so that if the bad guy comes in and zaps the DRAM,</p>
<p>339<br>00:45:44,280 –&gt; 00:45:47,120<br>the volatile storage, you still can provide this durability</p>
<p>340<br>00:45:47,120 –&gt; 00:45:50,600<br>property that you have to guarantee.</p>
<p>341<br>00:45:50,600 –&gt; 00:45:51,920<br>Now, this is a third type of storage</p>
<p>342<br>00:45:51,920 –&gt; 00:45:55,480<br>described in the text book, which is real, called stable storage.</p>
<p>343<br>00:45:55,480 –&gt; 00:45:58,120<br>And that basically is something that</p>
<p>344<br>00:45:58,120 –&gt; 00:46:00,680<br>survives all possible failure scenarios.</p>
<p>345<br>00:46:00,680 –&gt; 00:46:02,640<br>Such a theoretical storage doesn’t exist,</p>
<p>346<br>00:46:02,640 –&gt; 00:46:06,440<br>but you can come close by making replicas of everything</p>
<p>347<br>00:46:06,440 –&gt; 00:46:06,960<br>that you do.</p>
<p>348<br>00:46:06,960 –&gt; 00:46:09,280<br>You can replicate the disk and synchronize</p>
<p>349<br>00:46:09,280 –&gt; 00:46:12,360<br>the replicas using distributed transaction protocols.</p>
<p>350<br>00:46:12,360 –&gt; 00:46:15,160<br>We’ll talk about that in the last three lectures of the class</p>
<p>351<br>00:46:15,160 –&gt; 00:46:16,760<br>briefly.</p>
<p>352<br>00:46:16,760 –&gt; 00:46:19,960<br>So stable storage, we won’t touch at all today.</p>
<p>353<br>00:46:19,960 –&gt; 00:46:22,920<br>So we want dirty pages to sit.</p>
<p>354<br>00:46:22,920 –&gt; 00:46:24,160<br>Now, we’ll just concern ourselves</p>
<p>355<br>00:46:24,160 –&gt; 00:46:26,360<br>with the two-tier scenario for the remainder</p>
<p>356<br>00:46:26,360 –&gt; 00:46:30,599<br>of today’s lecture and tomorrow, which is buffer pool in DRAM.</p>
<p>357<br>00:46:30,599 –&gt; 00:46:33,800<br>And that gets spilled out to some stable storage, like SSD</p>
<p>358<br>00:46:33,800 –&gt; 00:46:38,400<br>or disk, which can survive a power failure.</p>
<p>359<br>00:46:38,400 –&gt; 00:46:40,039<br>So let’s begin.</p>
<p>360<br>00:46:40,039 –&gt; 00:46:41,720<br>Why do transactions fail?</p>
<p>361<br>00:46:41,719 –&gt; 00:46:43,359<br>There are multiple reasons.</p>
<p>362<br>00:46:43,359 –&gt; 00:46:46,039<br>First, transactions can fail because there</p>
<p>363<br>00:46:46,039 –&gt; 00:46:48,559<br>are logical errors in the transaction.</p>
<p>364<br>00:46:48,559 –&gt; 00:46:54,480<br>I updated a record and ops the integrity constraint</p>
<p>365<br>00:46:54,480 –&gt; 00:46:58,039<br>fail or a constraint on the database fail, the C part.</p>
<p>366<br>00:46:58,039 –&gt; 00:47:00,759<br>So now I need to abort this transaction.</p>
<p>367<br>00:47:00,759 –&gt; 00:47:03,919<br>Or it could be the transaction failed</p>
<p>368<br>00:47:03,919 –&gt; 00:47:05,919<br>because everything that it’s doing is fine,</p>
<p>369<br>00:47:05,919 –&gt; 00:47:08,439<br>but it’s deadlocking with another transaction.</p>
<p>370<br>00:47:08,439 –&gt; 00:47:10,759<br>And sorry, but you got picked as a transaction</p>
<p>371<br>00:47:10,760 –&gt; 00:47:12,600<br>that needs to be killed.</p>
<p>372<br>00:47:12,600 –&gt; 00:47:15,320<br>So transactions can fail for a variety of reasons.</p>
<p>373<br>00:47:15,320 –&gt; 00:47:19,000<br>And that will all get part of the atomicity and durability</p>
<p>374<br>00:47:19,000 –&gt; 00:47:21,040<br>that we are doing because a transaction that has failed</p>
<p>375<br>00:47:21,040 –&gt; 00:47:23,000<br>may have already started to make some changes.</p>
<p>376<br>00:47:23,000 –&gt; 00:47:26,640<br>We’ll have to undo all of those changes.</p>
<p>377<br>00:47:26,640 –&gt; 00:47:31,000<br>They can also be system failures, such as surprise, surprise,</p>
<p>378<br>00:47:31,000 –&gt; 00:47:32,800<br>software sometimes have bugs.</p>
<p>379<br>00:47:32,800 –&gt; 00:47:34,960<br>Operating systems sometimes has bugs.</p>
<p>380<br>00:47:34,960 –&gt; 00:47:37,560<br>So your system could crash for a software failure.</p>
<p>381<br>00:47:37,560 –&gt; 00:47:39,080<br>And part of the work may have been done.</p>
<p>382<br>00:47:39,080 –&gt; 00:47:40,560<br>Transaction has not committed.</p>
<p>383<br>00:47:40,559 –&gt; 00:47:43,279<br>Or it has committed the changes were in buffer pool.</p>
<p>384<br>00:47:43,279 –&gt; 00:47:45,960<br>And we still need to make sure the right thing happens.</p>
<p>385<br>00:47:45,960 –&gt; 00:47:47,639<br>There could be hardware failures.</p>
<p>386<br>00:47:47,639 –&gt; 00:47:49,599<br>In the early days of data centers,</p>
<p>387<br>00:47:49,599 –&gt; 00:47:53,000<br>there is to be a failure that the meta guys then</p>
<p>388<br>00:47:53,000 –&gt; 00:47:55,480<br>called Facebook had written papers about saying,</p>
<p>389<br>00:47:55,480 –&gt; 00:47:57,159<br>the DRAMs that were put on the servers</p>
<p>390<br>00:47:57,159 –&gt; 00:47:59,079<br>because all of them were so close by.</p>
<p>391<br>00:47:59,079 –&gt; 00:48:00,599<br>And they hadn’t really figured it out</p>
<p>392<br>00:48:00,599 –&gt; 00:48:02,400<br>as to what happens at that scale, not just them,</p>
<p>393<br>00:48:02,400 –&gt; 00:48:03,279<br>but everyone.</p>
<p>394<br>00:48:03,279 –&gt; 00:48:04,920<br>The DRAM chips would come off.</p>
<p>395<br>00:48:04,920 –&gt; 00:48:06,799<br>And one of the common failures was after a little while,</p>
<p>396<br>00:48:06,799 –&gt; 00:48:08,159<br>live into everything was fine.</p>
<p>397<br>00:48:08,159 –&gt; 00:48:10,159<br>The DRAM chips would just come off their slots.</p>
<p>398<br>00:48:10,159 –&gt; 00:48:12,679<br>Now they glue it most of the time.</p>
<p>399<br>00:48:12,679 –&gt; 00:48:14,399<br>Don’t want that to happen.</p>
<p>400<br>00:48:14,399 –&gt; 00:48:16,199<br>So hardware could fail for a variety of reasons.</p>
<p>401<br>00:48:16,199 –&gt; 00:48:17,639<br>It could be something like that.</p>
<p>402<br>00:48:17,639 –&gt; 00:48:21,639<br>Or it could be the part actually failed, the system crashes,</p>
<p>403<br>00:48:21,639 –&gt; 00:48:23,199<br>all kinds of things that happen.</p>
<p>404<br>00:48:23,199 –&gt; 00:48:24,559<br>One thing we’re going to assume today</p>
<p>405<br>00:48:24,559 –&gt; 00:48:27,559<br>is that the non-walletized storage, the SSD or the disk,</p>
<p>406<br>00:48:27,559 –&gt; 00:48:29,000<br>does come back and has the contents</p>
<p>407<br>00:48:29,000 –&gt; 00:48:30,559<br>because we don’t have this ideal storage</p>
<p>408<br>00:48:30,559 –&gt; 00:48:32,039<br>with the replication stuff.</p>
<p>409<br>00:48:32,039 –&gt; 00:48:34,960<br>So just reiterating that component.</p>
<p>410<br>00:48:34,960 –&gt; 00:48:39,199<br>The storage media could fail, where you thought</p>
<p>411<br>00:48:39,199 –&gt; 00:48:41,559<br>you wrote a page to disk, but it actually didn’t get rid</p>
<p>412<br>00:48:41,559 –&gt; 00:48:42,079<br>in the disk.</p>
<p>413<br>00:48:42,079 –&gt; 00:48:43,960<br>Driver came back and said, yeah, it’s written.</p>
<p>414<br>00:48:43,960 –&gt; 00:48:45,759<br>But the bit Scott corrupted on that.</p>
<p>415<br>00:48:45,759 –&gt; 00:48:48,119<br>We’ve talked about bit rotting and other kinds of things.</p>
<p>416<br>00:48:48,119 –&gt; 00:48:49,960<br>You will need other types of mechanisms</p>
<p>417<br>00:48:49,960 –&gt; 00:48:51,879<br>with the replication to deal with that.</p>
<p>418<br>00:48:51,879 –&gt; 00:48:53,119<br>And again, we won’t cover that.</p>
<p>419<br>00:48:53,119 –&gt; 00:48:55,799<br>We will assume that something else takes care of that.</p>
<p>420<br>00:48:55,799 –&gt; 00:48:57,960<br>We’ll concern ourselves with just this two-tier stuff</p>
<p>421<br>00:48:57,960 –&gt; 00:49:00,000<br>that we talked about, OK?</p>
<p>422<br>00:49:00,000 –&gt; 00:49:03,199<br>Where the primary storage is in this non-walletized DRAM</p>
<p>423<br>00:49:03,199 –&gt; 00:49:06,759<br>storage and the main storage is in this walletile storage.</p>
<p>424<br>00:49:06,760 –&gt; 00:49:09,360<br>Now what we need to do as a database system</p>
<p>425<br>00:49:09,360 –&gt; 00:49:12,120<br>is to make sure committed transactions</p>
<p>426<br>00:49:12,120 –&gt; 00:49:15,160<br>changes make it to the stable storage.</p>
<p>427<br>00:49:15,160 –&gt; 00:49:16,880<br>And no partial changes are left around.</p>
<p>428<br>00:49:16,880 –&gt; 00:49:18,680<br>Even if they made it to durable storage,</p>
<p>429<br>00:49:18,680 –&gt; 00:49:22,680<br>we can unwind ourselves from that.</p>
<p>430<br>00:49:22,680 –&gt; 00:49:25,440<br>We need two key mechanisms to do this.</p>
<p>431<br>00:49:25,440 –&gt; 00:49:28,640<br>One is called undo, which is whoops.</p>
<p>432<br>00:49:28,640 –&gt; 00:49:31,840<br>I put something into stable storage,</p>
<p>433<br>00:49:31,840 –&gt; 00:49:35,280<br>into the non-walletile storage, that</p>
<p>434<br>00:49:35,280 –&gt; 00:49:38,720<br>was changes made by a transaction that got aborted,</p>
<p>435<br>00:49:38,720 –&gt; 00:49:40,240<br>because it was a transaction failure.</p>
<p>436<br>00:49:40,240 –&gt; 00:49:42,360<br>One of these are the failures we talked about.</p>
<p>437<br>00:49:42,360 –&gt; 00:49:44,040<br>And now I need to undo that.</p>
<p>438<br>00:49:44,040 –&gt; 00:49:46,840<br>And the other one is redo, which is, oh, the committed</p>
<p>439<br>00:49:46,840 –&gt; 00:49:49,320<br>transaction made changes that were just in the buffer pool.</p>
<p>440<br>00:49:49,320 –&gt; 00:49:50,680<br>But the transaction is committed.</p>
<p>441<br>00:49:50,680 –&gt; 00:49:53,640<br>We told the world that the transaction has committed.</p>
<p>442<br>00:49:53,640 –&gt; 00:49:57,920<br>But now we need to go and reapply those changes.</p>
<p>443<br>00:49:57,920 –&gt; 00:50:00,640<br>So those are the two mechanisms that we need to build</p>
<p>444<br>00:50:00,640 –&gt; 00:50:02,640<br>into our system.</p>
<p>445<br>00:50:02,639 –&gt; 00:50:05,960<br>So another example is start with the buffer pool.</p>
<p>446<br>00:50:05,960 –&gt; 00:50:07,440<br>And you read a page.</p>
<p>447<br>00:50:07,440 –&gt; 00:50:09,719<br>You get the page, which has a bunch of things in it,</p>
<p>448<br>00:50:09,719 –&gt; 00:50:11,480<br>including the A value.</p>
<p>449<br>00:50:11,480 –&gt; 00:50:12,279<br>You write it.</p>
<p>450<br>00:50:12,279 –&gt; 00:50:13,719<br>You have a new value.</p>
<p>451<br>00:50:13,719 –&gt; 00:50:16,839<br>Then stuff happens where these change</p>
<p>452<br>00:50:16,839 –&gt; 00:50:20,440<br>by a different transaction on the same page,</p>
<p>453<br>00:50:20,440 –&gt; 00:50:23,079<br>as where A is that was updated by transaction T1.</p>
<p>454<br>00:50:23,079 –&gt; 00:50:26,599<br>So now two transactions have made changes to the same page.</p>
<p>455<br>00:50:26,599 –&gt; 00:50:28,440<br>And remember, we moved stuff from the buffer pool</p>
<p>456<br>00:50:28,440 –&gt; 00:50:30,879<br>to the disk in pages.</p>
<p>457<br>00:50:30,880 –&gt; 00:50:33,360<br>So now this page has two different things</p>
<p>458<br>00:50:33,360 –&gt; 00:50:35,000<br>from two different transactions.</p>
<p>459<br>00:50:35,000 –&gt; 00:50:38,760<br>T2 commits, what do we do at this point?</p>
<p>460<br>00:50:38,760 –&gt; 00:50:42,320<br>If we said we can flush that page to disk</p>
<p>461<br>00:50:42,320 –&gt; 00:50:46,119<br>to ensure that T2’s changes are durable,</p>
<p>462<br>00:50:46,119 –&gt; 00:50:49,400<br>we will also carry along with us A’s changes.</p>
<p>463<br>00:50:49,400 –&gt; 00:50:53,760<br>And A’s outcome is T1’s outcome to A is not yet known.</p>
<p>464<br>00:50:53,760 –&gt; 00:50:54,840<br>We don’t know what’s going to happen.</p>
<p>465<br>00:50:54,840 –&gt; 00:50:57,960<br>Because if we flush all of that to disk,</p>
<p>466<br>00:50:57,960 –&gt; 00:50:59,920<br>ultimately, T2 could abort.</p>
<p>467<br>00:50:59,920 –&gt; 00:51:04,280<br>And we need to go unwind the changes that made it to disk.</p>
<p>468<br>00:51:04,280 –&gt; 00:51:06,360<br>So there’ll be all kinds of schemes you can come up with.</p>
<p>469<br>00:51:06,360 –&gt; 00:51:09,639<br>We’ll categorize this into a nice quad chart shortly.</p>
<p>470<br>00:51:09,639 –&gt; 00:51:13,360<br>But basically saying, because things are on the same page</p>
<p>471<br>00:51:13,360 –&gt; 00:51:16,000<br>and the buffer pool can move things around in pages,</p>
<p>472<br>00:51:16,000 –&gt; 00:51:17,880<br>in a given page, might be changes</p>
<p>473<br>00:51:17,880 –&gt; 00:51:20,039<br>for multiple transactions in different states.</p>
<p>474<br>00:51:20,039 –&gt; 00:51:24,760<br>And we have to make everything work with that scenario.</p>
<p>475<br>00:51:24,760 –&gt; 00:51:25,519<br>All right?</p>
<p>476<br>00:51:25,519 –&gt; 00:51:27,280<br>So if T2 needs to be rolled back, I</p>
<p>477<br>00:51:27,280 –&gt; 00:51:30,240<br>needed to know that the previous value was not A3.</p>
<p>478<br>00:51:30,240 –&gt; 00:51:31,840<br>Now that may be sitting in a version chain.</p>
<p>479<br>00:51:31,840 –&gt; 00:51:34,280<br>If that’s the storage technique that I’m using,</p>
<p>480<br>00:51:34,280 –&gt; 00:51:37,120<br>but I have to go chase it down and I have to go figure it out.</p>
<p>481<br>00:51:37,120 –&gt; 00:51:40,080<br>I still have to keep track of the changes that I made,</p>
<p>482<br>00:51:40,080 –&gt; 00:51:41,519<br>which is the logging stuff, which</p>
<p>483<br>00:51:41,519 –&gt; 00:51:43,040<br>works with all of these techniques</p>
<p>484<br>00:51:43,040 –&gt; 00:51:44,400<br>that we’ve discussed before.</p>
<p>485<br>00:51:44,400 –&gt; 00:51:47,000<br>It’s orthogonal to all of that.</p>
<p>486<br>00:51:47,000 –&gt; 00:51:48,560<br>But as I said, today, if you just concern</p>
<p>487<br>00:51:48,560 –&gt; 00:51:52,480<br>yourself with a single version component of this,</p>
<p>488<br>00:51:52,480 –&gt; 00:51:54,519<br>you can do all kinds of a little bit more interesting thing</p>
<p>489<br>00:51:54,519 –&gt; 00:51:55,280<br>with multi-version.</p>
<p>490<br>00:51:55,280 –&gt; 00:51:57,560<br>But let’s get the single version foundation in first.</p>
<p>491<br>00:52:01,240 –&gt; 00:52:07,000<br>The other complication arises from the buffer pools</p>
<p>492<br>00:52:07,000 –&gt; 00:52:08,480<br>replacement policy.</p>
<p>493<br>00:52:08,480 –&gt; 00:52:10,600<br>So you guys implemented the LREU2 policy</p>
<p>494<br>00:52:10,600 –&gt; 00:52:12,080<br>when you wrote the buffer pool.</p>
<p>495<br>00:52:12,080 –&gt; 00:52:14,480<br>And that gave a lot of freedom to the buffer manager,</p>
<p>496<br>00:52:14,480 –&gt; 00:52:16,519<br>simple piece of code that can decide,</p>
<p>497<br>00:52:16,519 –&gt; 00:52:19,519<br>I’ll keep track of the recency of a page based</p>
<p>498<br>00:52:19,519 –&gt; 00:52:22,000<br>on the LREU2 counters.</p>
<p>499<br>00:52:22,000 –&gt; 00:52:23,920<br>And I’ll decide when to kick something out,</p>
<p>500<br>00:52:23,920 –&gt; 00:52:25,440<br>when an eviction needs to happen.</p>
<p>501<br>00:52:25,440 –&gt; 00:52:27,680<br>The only thing we said is that if a page is spin,</p>
<p>502<br>00:52:27,680 –&gt; 00:52:29,880<br>someone’s actually using it, can’t kick it out.</p>
<p>503<br>00:52:29,880 –&gt; 00:52:33,039<br>But if a page is unpin, it could be dirty,</p>
<p>504<br>00:52:33,039 –&gt; 00:52:34,360<br>and I can kick it out.</p>
<p>505<br>00:52:34,360 –&gt; 00:52:37,240<br>So the buffer pool to get maximum performance,</p>
<p>506<br>00:52:37,240 –&gt; 00:52:43,240<br>maximum use of the space is a cache of that caching efficiency</p>
<p>507<br>00:52:43,240 –&gt; 00:52:46,039<br>is saying I’m allowed to kick things out,</p>
<p>508<br>00:52:46,039 –&gt; 00:52:49,960<br>even if there are dirty changes that are made to that page.</p>
<p>509<br>00:52:49,960 –&gt; 00:52:53,079<br>So that we’ll call as the steel policy.</p>
<p>510<br>00:52:53,079 –&gt; 00:52:57,319<br>There’s a second component that’s one dimension</p>
<p>511<br>00:52:57,319 –&gt; 00:52:58,319<br>to this problem.</p>
<p>512<br>00:52:58,319 –&gt; 00:52:59,880<br>And stealing is saying the buffer manager</p>
<p>513<br>00:52:59,880 –&gt; 00:53:02,920<br>can take a page that is unpin and flush it to disk,</p>
<p>514<br>00:53:02,920 –&gt; 00:53:05,840<br>even if it’s dirty, and the transaction that’s dirty</p>
<p>515<br>00:53:05,840 –&gt; 00:53:07,960<br>that hasn’t committed yet.</p>
<p>516<br>00:53:07,960 –&gt; 00:53:12,239<br>So we’ll write uncommitted changes to the stable storage,</p>
<p>517<br>00:53:12,239 –&gt; 00:53:14,360<br>and that’s OK.</p>
<p>518<br>00:53:14,360 –&gt; 00:53:16,079<br>No steel is saying, no, no, I’m going</p>
<p>519<br>00:53:16,079 –&gt; 00:53:18,199<br>to take away this power of replacement policy</p>
<p>520<br>00:53:18,199 –&gt; 00:53:18,799<br>from you.</p>
<p>521<br>00:53:18,799 –&gt; 00:53:21,360<br>Certain things besides spin pages, you</p>
<p>522<br>00:53:21,360 –&gt; 00:53:24,000<br>can’t steal pages for transactions that are running.</p>
<p>523<br>00:53:24,000 –&gt; 00:53:26,599<br>And that’s obviously going to give you a lot less flexibility.</p>
<p>524<br>00:53:26,599 –&gt; 00:53:29,440<br>It’ll be a poorer performing system.</p>
<p>525<br>00:53:29,440 –&gt; 00:53:31,480<br>The second dimension to steal, no steal,</p>
<p>526<br>00:53:31,480 –&gt; 00:53:34,200<br>is the force policy, which is at the commit time.</p>
<p>527<br>00:53:34,200 –&gt; 00:53:35,920<br>What do I do?</p>
<p>528<br>00:53:35,920 –&gt; 00:53:38,840<br>At the commit time, if I say all the changes that were made</p>
<p>529<br>00:53:38,840 –&gt; 00:53:40,480<br>by the transaction that is committing</p>
<p>530<br>00:53:40,480 –&gt; 00:53:44,400<br>must be forced into disk before committing,</p>
<p>531<br>00:53:44,400 –&gt; 00:53:46,559<br>then I’ll get durability.</p>
<p>532<br>00:53:46,559 –&gt; 00:53:50,599<br>But it will be very expensive, because imagine</p>
<p>533<br>00:53:50,599 –&gt; 00:53:53,960<br>I’m a transaction that’s touching one byte</p>
<p>534<br>00:53:53,960 –&gt; 00:53:57,400<br>in 100 byte records for a billion records.</p>
<p>535<br>00:53:57,400 –&gt; 00:53:59,159<br>I’m just changing one billion bytes,</p>
<p>536<br>00:53:59,159 –&gt; 00:54:02,119<br>but I’ve touched everything, and I have to bring everything</p>
<p>537<br>00:54:02,119 –&gt; 00:54:04,839<br>into memory, update all of that stuff,</p>
<p>538<br>00:54:04,839 –&gt; 00:54:07,759<br>and then write all of that stuff at commit time.</p>
<p>539<br>00:54:07,759 –&gt; 00:54:10,000<br>So that will be a lot of changes that</p>
<p>540<br>00:54:10,000 –&gt; 00:54:13,119<br>have to be flushed at commit time, and you have a slow system,</p>
<p>541<br>00:54:13,119 –&gt; 00:54:16,719<br>but that could be how you could work in that case.</p>
<p>542<br>00:54:16,719 –&gt; 00:54:19,839<br>So force says at commit time, I will force the committed</p>
<p>543<br>00:54:19,840 –&gt; 00:54:22,559<br>transaction changes to disk, no force says no, no, no,</p>
<p>544<br>00:54:22,559 –&gt; 00:54:25,200<br>don’t force that, find a better way to do the commit</p>
<p>545<br>00:54:25,200 –&gt; 00:54:28,480<br>that is more efficient, and then deal with that things</p>
<p>546<br>00:54:28,480 –&gt; 00:54:30,160<br>that can happen in a different way,</p>
<p>547<br>00:54:30,160 –&gt; 00:54:31,920<br>which is where logging is going to commit.</p>
<p>548<br>00:54:34,039 –&gt; 00:54:36,680<br>So let’s look at one of the simplest policies</p>
<p>549<br>00:54:36,680 –&gt; 00:54:40,240<br>of these combinations of steal, no steal, force, no force.</p>
<p>550<br>00:54:40,240 –&gt; 00:54:43,120<br>The easiest one is no steal, but for who can do much,</p>
<p>551<br>00:54:43,120 –&gt; 00:54:46,400<br>it can steal a page, and forces you write stuff.</p>
<p>552<br>00:54:46,400 –&gt; 00:54:49,079<br>So it’s this combination that works,</p>
<p>553<br>00:54:49,079 –&gt; 00:54:50,799<br>but it’s obviously pretty slow.</p>
<p>554<br>00:54:50,799 –&gt; 00:54:52,960<br>But let’s see in that, just an example</p>
<p>555<br>00:54:52,960 –&gt; 00:54:55,319<br>as to what happens with this simple scheme,</p>
<p>556<br>00:54:55,319 –&gt; 00:54:56,440<br>which is not realistic, right?</p>
<p>557<br>00:54:56,440 –&gt; 00:54:58,400<br>We want to do better and V-ville.</p>
<p>558<br>00:54:58,400 –&gt; 00:55:01,119<br>So you have a read of A, bring that page in,</p>
<p>559<br>00:55:01,119 –&gt; 00:55:03,039<br>you’ve seen this page multiple times now,</p>
<p>560<br>00:55:03,039 –&gt; 00:55:05,599<br>you go right to that, second transaction comes in,</p>
<p>561<br>00:55:05,599 –&gt; 00:55:07,880<br>makes it’s right, and force means,</p>
<p>562<br>00:55:07,880 –&gt; 00:55:11,279<br>I will now force the changes of this page to disk,</p>
<p>563<br>00:55:11,279 –&gt; 00:55:16,279<br>but because I have changes to A that was made by T1,</p>
<p>564<br>00:55:17,200 –&gt; 00:55:19,880<br>which is not done, if I’m doing a force policy,</p>
<p>565<br>00:55:19,880 –&gt; 00:55:21,400<br>I’m still going to need to figure out</p>
<p>566<br>00:55:21,400 –&gt; 00:55:23,960<br>what’s the older version of this page,</p>
<p>567<br>00:55:23,960 –&gt; 00:55:26,760<br>I need some mechanism to go keep track of that,</p>
<p>568<br>00:55:26,760 –&gt; 00:55:29,440<br>and then only flush that out to disk.</p>
<p>569<br>00:55:30,960 –&gt; 00:55:33,280<br>So just want to know, even if it’s in simplest scheme</p>
<p>570<br>00:55:33,280 –&gt; 00:55:36,120<br>that you can think of, you’re gonna have a little complication.</p>
<p>571<br>00:55:37,120 –&gt; 00:55:38,440<br>But we’ll do much better than that.</p>
<p>572<br>00:55:38,440 –&gt; 00:55:40,640<br>This just an example, no one implements it like that,</p>
<p>573<br>00:55:40,640 –&gt; 00:55:43,040<br>because this will still be a very slow system.</p>
<p>574<br>00:55:44,039 –&gt; 00:55:46,320<br>Okay, but there’s no free lunch,</p>
<p>575<br>00:55:46,320 –&gt; 00:55:47,920<br>even with the simplest combination,</p>
<p>576<br>00:55:47,920 –&gt; 00:55:49,400<br>you still have complications.</p>
<p>577<br>00:55:50,719 –&gt; 00:55:54,320<br>All right, so easier scheme to implement,</p>
<p>578<br>00:55:55,679 –&gt; 00:55:57,719<br>it has a couple other problems with it.</p>
<p>579<br>00:55:57,719 –&gt; 00:56:01,199<br>One is if the number of objects that I’m writing to,</p>
<p>580<br>00:56:01,199 –&gt; 00:56:04,000<br>imagine you have a buffer pool with a million pages,</p>
<p>581<br>00:56:04,000 –&gt; 00:56:08,119<br>and you want to update in a transaction,</p>
<p>582<br>00:56:08,119 –&gt; 00:56:11,320<br>a table that then you want to update a field</p>
<p>583<br>00:56:11,320 –&gt; 00:56:14,280<br>for all the records in a table,</p>
<p>584<br>00:56:14,280 –&gt; 00:56:16,720<br>and the table has a million plus one pages,</p>
<p>585<br>00:56:16,720 –&gt; 00:56:21,120<br>you can do this because according to no steel force policy,</p>
<p>586<br>00:56:21,120 –&gt; 00:56:23,440<br>every page has to be brought into memory</p>
<p>587<br>00:56:23,440 –&gt; 00:56:26,039<br>and can we push out till,</p>
<p>588<br>00:56:26,039 –&gt; 00:56:27,640<br>because of the no steel part,</p>
<p>589<br>00:56:27,640 –&gt; 00:56:30,680<br>can we push out to disk till the transaction is done?</p>
<p>590<br>00:56:30,680 –&gt; 00:56:33,640<br>So this just to say that the no steel part</p>
<p>591<br>00:56:33,640 –&gt; 00:56:35,160<br>can be really problematic,</p>
<p>592<br>00:56:35,160 –&gt; 00:56:38,080<br>the force part is not trivial to,</p>
<p>593<br>00:56:38,080 –&gt; 00:56:39,400<br>because you have to go figure out</p>
<p>594<br>00:56:40,360 –&gt; 00:56:42,280<br>which part of that page changed.</p>
<p>595<br>00:56:42,280 –&gt; 00:56:45,840<br>So we need to ultimately live in a world</p>
<p>596<br>00:56:45,840 –&gt; 00:56:48,320<br>where we have to try to make the opposite of this happens,</p>
<p>597<br>00:56:48,320 –&gt; 00:56:51,320<br>which is to have the most high-performance scheme,</p>
<p>598<br>00:56:51,320 –&gt; 00:56:53,320<br>which is to do steel no force.</p>
<p>599<br>00:56:55,160 –&gt; 00:56:57,480<br>Now, as we start to make changes,</p>
<p>600<br>00:56:57,480 –&gt; 00:56:59,960<br>we’ll have to keep track of what we have changed</p>
<p>601<br>00:56:59,960 –&gt; 00:57:02,200<br>and work with that.</p>
<p>602<br>00:57:02,200 –&gt; 00:57:05,280<br>So one of the options that we will have to do,</p>
<p>603<br>00:57:05,280 –&gt; 00:57:07,400<br>and this is running out of battery for some reason,</p>
<p>604<br>00:57:07,400 –&gt; 00:57:08,840<br>even though I’ve got this plugged in.</p>
<p>605<br>00:57:08,840 –&gt; 00:57:10,920<br>So hold on, before everything dies out here.</p>
<p>606<br>00:57:12,920 –&gt; 00:57:15,160<br>Maybe this thing is broken here.</p>
<p>607<br>00:57:20,079 –&gt; 00:57:20,920<br>Geez.</p>
<p>608<br>00:57:23,360 –&gt; 00:57:26,240<br>Not good, it’s saying I’m gonna shut you down in a minute,</p>
<p>609<br>00:57:27,200 –&gt; 00:57:28,039<br>but,</p>
<p>610<br>00:57:32,119 –&gt; 00:57:34,360<br>yeah, it should power through it.</p>
<p>611<br>00:57:35,360 –&gt; 00:57:38,400<br>Otherwise, I’m gonna have to take a little time</p>
<p>612<br>00:57:38,400 –&gt; 00:57:40,440<br>in this a series.</p>
<p>613<br>00:57:40,440 –&gt; 00:57:41,280<br>So hold on.</p>
<p>614<br>00:57:43,280 –&gt; 00:57:44,280<br>There we go.</p>
<p>615<br>00:57:44,280 –&gt; 00:57:45,880<br>Now, I have to switch this guy out here</p>
<p>616<br>00:57:45,880 –&gt; 00:57:47,519<br>and then set everything back up again.</p>
<p>617<br>00:57:47,519 –&gt; 00:57:48,440<br>Give me a minute.</p>
<p>618<br>00:57:49,840 –&gt; 00:57:50,680<br>Fun.</p>
<p>619<br>00:57:53,280 –&gt; 00:57:54,640<br>That gives you a little bit of downtime</p>
<p>620<br>00:57:54,640 –&gt; 00:57:55,760<br>to think about all this stuff.</p>
<p>621<br>00:57:55,760 –&gt; 00:57:56,599<br>So,</p>
<p>622<br>00:57:57,800 –&gt; 00:58:00,519<br>let’s stop for the final.</p>
<p>623<br>00:58:00,519 –&gt; 00:58:03,599<br>I have half a mind to record a 20 minute lecture</p>
<p>624<br>00:58:03,599 –&gt; 00:58:05,519<br>and make it part of it, but you guys will kill me.</p>
<p>625<br>00:58:05,519 –&gt; 00:58:06,440<br>So I won’t do that.</p>
<p>626<br>00:58:06,440 –&gt; 00:58:08,119<br>I won’t do that.</p>
<p>627<br>00:58:08,119 –&gt; 00:58:10,519<br>But I was thinking, ways to get out of this.</p>
<p>628<br>00:58:13,599 –&gt; 00:58:14,440<br>Sorry.</p>
<p>629<br>00:58:16,480 –&gt; 00:58:18,759<br>No, no, no, I’m nearly there.</p>
<p>630<br>00:58:18,759 –&gt; 00:58:20,679<br>I’m fighting here, guys, for every minute.</p>
<p>631<br>00:58:20,679 –&gt; 00:58:21,880<br>Thanks for all the help.</p>
<p>632<br>00:58:25,920 –&gt; 00:58:28,079<br>Okay, I think we are back.</p>
<p>633<br>00:58:28,079 –&gt; 00:58:29,360<br>Let’s make sure,</p>
<p>634<br>00:58:31,039 –&gt; 00:58:32,519<br>oh, good.</p>
<p>635<br>00:58:32,519 –&gt; 00:58:36,000<br>Now, this thing, today this connector</p>
<p>636<br>00:58:36,000 –&gt; 00:58:38,679<br>to the external monitors, very finicky.</p>
<p>637<br>00:58:40,079 –&gt; 00:58:43,199<br>It seems to not want to do that.</p>
<p>638<br>00:58:43,199 –&gt; 00:58:44,440<br>Okay, there we go.</p>
<p>639<br>00:58:44,440 –&gt; 00:58:46,880<br>I think we are back in business.</p>
<p>640<br>00:58:46,880 –&gt; 00:58:49,599<br>And hopefully the lecture is still recording.</p>
<p>641<br>00:58:49,599 –&gt; 00:58:51,360<br>So there’s all recorded at home</p>
<p>642<br>00:58:51,360 –&gt; 00:58:53,280<br>and add extra material for the exam.</p>
<p>643<br>00:58:53,280 –&gt; 00:58:54,400<br>Just kidding.</p>
<p>644<br>00:58:54,400 –&gt; 00:58:55,559<br>Won’t do that.</p>
<p>645<br>00:58:55,559 –&gt; 00:58:56,400<br>All right.</p>
<p>646<br>00:58:56,400 –&gt; 00:58:58,960<br>So we still have to record what we need</p>
<p>647<br>00:58:58,960 –&gt; 00:59:02,480<br>to unwind from or make sure it made it to disk.</p>
<p>648<br>00:59:02,800 –&gt; 00:59:05,119<br>The two techniques, one is shadow paging.</p>
<p>649<br>00:59:05,119 –&gt; 00:59:06,239<br>It’s a bad idea.</p>
<p>650<br>00:59:06,239 –&gt; 00:59:07,199<br>No one does it.</p>
<p>651<br>00:59:07,199 –&gt; 00:59:09,000<br>This was the first thing that people did</p>
<p>652<br>00:59:09,000 –&gt; 00:59:11,239<br>when they realized they need recovery protocol.</p>
<p>653<br>00:59:11,239 –&gt; 00:59:13,920<br>So I’ll describe it, but I’m gonna skip through</p>
<p>654<br>00:59:13,920 –&gt; 00:59:16,759<br>the slides that are in there over here</p>
<p>655<br>00:59:16,759 –&gt; 00:59:19,119<br>and I will refer you to the deck</p>
<p>656<br>00:59:19,119 –&gt; 00:59:20,719<br>if you needed to go to the cap.</p>
<p>657<br>00:59:20,719 –&gt; 00:59:22,039<br>What shadow paging?</p>
<p>658<br>00:59:22,039 –&gt; 00:59:24,159<br>So remember we ran into this trouble</p>
<p>659<br>00:59:24,159 –&gt; 00:59:27,599<br>where two transactions that changes were on the same page</p>
<p>660<br>00:59:27,599 –&gt; 00:59:29,440<br>and we had to worry about that.</p>
<p>661<br>00:59:29,440 –&gt; 00:59:32,000<br>There’s a bigger version of this problem</p>
<p>662<br>00:59:32,679 –&gt; 00:59:35,320<br>where I’ve got bunch of changes that I’m making</p>
<p>663<br>00:59:35,320 –&gt; 00:59:36,400<br>and shadow paging.</p>
<p>664<br>00:59:36,400 –&gt; 00:59:38,280<br>Effectively what we need is we need to keep track</p>
<p>665<br>00:59:38,280 –&gt; 00:59:41,480<br>of a before and after version of the changes we are making.</p>
<p>666<br>00:59:41,480 –&gt; 00:59:42,320<br>Okay.</p>
<p>667<br>00:59:42,320 –&gt; 00:59:47,480<br>One way to do that is to keep track of a scheme</p>
<p>668<br>00:59:47,480 –&gt; 00:59:51,320<br>in which I have all the pages that I have on disk</p>
<p>669<br>00:59:51,320 –&gt; 00:59:53,880<br>and I’ll keep track in memory something</p>
<p>670<br>00:59:53,880 –&gt; 00:59:55,760<br>called a master page table.</p>
<p>671<br>00:59:55,760 –&gt; 00:59:57,920<br>Kind of like your operating system,</p>
<p>672<br>00:59:57,920 –&gt; 00:59:59,960<br>those of you who’ve taken an operating system class</p>
<p>673<br>00:59:59,960 –&gt; 01:00:01,760<br>know that there’s a page mapping table</p>
<p>674<br>01:00:01,760 –&gt; 01:00:04,559<br>from your virtual address space to a physical address space.</p>
<p>675<br>01:00:04,559 –&gt; 01:00:05,559<br>Right.</p>
<p>676<br>01:00:05,559 –&gt; 01:00:09,800<br>Kind of like that, but not that complicated here is just saying</p>
<p>677<br>01:00:09,800 –&gt; 01:00:14,800<br>page one is disk position in my stable storage.</p>
<p>678<br>01:00:17,199 –&gt; 01:00:21,360<br>It’s just a pointer, it’s just a list of where the pages are.</p>
<p>679<br>01:00:21,360 –&gt; 01:00:23,519<br>And when a transaction comes in,</p>
<p>680<br>01:00:23,519 –&gt; 01:00:26,360<br>it will make a copy of that page table.</p>
<p>681<br>01:00:26,360 –&gt; 01:00:28,480<br>Effectively think of it as getting a snapshot</p>
<p>682<br>01:00:28,480 –&gt; 01:00:30,320<br>by virtue of copying this.</p>
<p>683<br>01:00:30,320 –&gt; 01:00:32,360<br>And now when it makes changes,</p>
<p>684<br>01:00:32,360 –&gt; 01:00:36,440<br>it’s going to make changes if page one has to be updated.</p>
<p>685<br>01:00:36,440 –&gt; 01:00:38,960<br>It’ll make a new copy of that page a shadow,</p>
<p>686<br>01:00:38,960 –&gt; 01:00:42,159<br>make a full new copy of itself of that page.</p>
<p>687<br>01:00:42,159 –&gt; 01:00:43,960<br>Make changes just there.</p>
<p>688<br>01:00:43,960 –&gt; 01:00:46,519<br>So if some of the transactions making changes to page one,</p>
<p>689<br>01:00:46,519 –&gt; 01:00:48,480<br>it’ll make another full copy of page one.</p>
<p>690<br>01:00:49,719 –&gt; 01:00:51,440<br>And there are ways to merge it and combine that</p>
<p>691<br>01:00:51,440 –&gt; 01:00:54,039<br>but assume it just as one at a time.</p>
<p>692<br>01:00:54,039 –&gt; 01:00:57,960<br>And then effectively all the changes will create new pages.</p>
<p>693<br>01:00:57,960 –&gt; 01:01:01,280<br>Those are only pointed to by my shadow page table copy.</p>
<p>694<br>01:01:02,400 –&gt; 01:01:04,920<br>And then ultimately when I’m ready to commit,</p>
<p>695<br>01:01:04,920 –&gt; 01:01:06,280<br>I will do the following,</p>
<p>696<br>01:01:06,280 –&gt; 01:01:08,599<br>which is I take the, there’s a pointer in memory</p>
<p>697<br>01:01:08,599 –&gt; 01:01:10,440<br>to the root of the master page table,</p>
<p>698<br>01:01:10,440 –&gt; 01:01:12,960<br>which is pointing to the old page table.</p>
<p>699<br>01:01:12,960 –&gt; 01:01:14,920<br>A copy of that is also kept on disk, right?</p>
<p>700<br>01:01:14,920 –&gt; 01:01:16,920<br>Because that’s the stable point when the disk,</p>
<p>701<br>01:01:16,920 –&gt; 01:01:19,119<br>when the database system starts from scratch,</p>
<p>702<br>01:01:19,119 –&gt; 01:01:22,960<br>it’ll read that stuff because it knows kind of where everything is.</p>
<p>703<br>01:01:22,960 –&gt; 01:01:26,280<br>And then I will go flush that out over there,</p>
<p>704<br>01:01:26,280 –&gt; 01:01:29,360<br>then switch the pointer to the new shadow page.</p>
<p>705<br>01:01:29,360 –&gt; 01:01:31,040<br>And now that becomes the master</p>
<p>706<br>01:01:31,040 –&gt; 01:01:33,600<br>and eventually some background stuff goes clean stuff, things up.</p>
<p>707<br>01:01:34,519 –&gt; 01:01:37,600<br>So this was the easiest implementation as you can imagine.</p>
<p>708<br>01:01:37,600 –&gt; 01:01:41,040<br>Someone who wanted to get this type of recovery protocol.</p>
<p>709<br>01:01:41,040 –&gt; 01:01:41,880<br>No one does that.</p>
<p>710<br>01:01:41,880 –&gt; 01:01:43,880<br>I guess there are some systems to do that,</p>
<p>711<br>01:01:43,880 –&gt; 01:01:45,120<br>where it’s a bad idea.</p>
<p>712<br>01:01:45,120 –&gt; 01:01:47,519<br>The better approach is what we are going to talk about</p>
<p>713<br>01:01:47,519 –&gt; 01:01:49,160<br>with the right to head logging protocol.</p>
<p>714<br>01:01:49,160 –&gt; 01:01:50,600<br>Obviously massive problems, right?</p>
<p>715<br>01:01:50,600 –&gt; 01:01:51,680<br>Use fragmentation.</p>
<p>716<br>01:01:51,680 –&gt; 01:01:54,519<br>Now you’re doing this garbage collection at the page level</p>
<p>717<br>01:01:54,519 –&gt; 01:01:57,360<br>and you’ll make copies and copies of pages and stuff like that.</p>
<p>718<br>01:01:57,360 –&gt; 01:01:59,039<br>So lots and lots of problems.</p>
<p>719<br>01:01:59,039 –&gt; 01:02:00,480<br>We won’t talk about that.</p>
<p>720<br>01:02:00,480 –&gt; 01:02:03,960<br>But as I said here, you can look at last year’s lecture</p>
<p>721<br>01:02:03,960 –&gt; 01:02:06,719<br>on this, which spends about 10, 15 minutes</p>
<p>722<br>01:02:06,719 –&gt; 01:02:08,239<br>on the next two slides.</p>
<p>723<br>01:02:08,239 –&gt; 01:02:10,800<br>Including, this I would recommend just for learning purposes</p>
<p>724<br>01:02:10,800 –&gt; 01:02:13,320<br>to go back and look at what SQLite used to do.</p>
<p>725<br>01:02:13,320 –&gt; 01:02:15,960<br>They had the old scheme with shadow pageing</p>
<p>726<br>01:02:15,960 –&gt; 01:02:17,880<br>because they started in 2000.</p>
<p>727<br>01:02:17,880 –&gt; 01:02:21,360<br>People hadn’t advanced in all these protocols as much at that time.</p>
<p>728<br>01:02:21,360 –&gt; 01:02:23,759<br>But then they switched over to right head logging,</p>
<p>729<br>01:02:23,760 –&gt; 01:02:26,280<br>which we’re going to talk about next.</p>
<p>730<br>01:02:26,280 –&gt; 01:02:27,800<br>And so it makes copies and copies where</p>
<p>731<br>01:02:27,800 –&gt; 01:02:29,360<br>it does copies in a slightly different way,</p>
<p>732<br>01:02:29,360 –&gt; 01:02:31,480<br>but effectively the same time.</p>
<p>733<br>01:02:31,480 –&gt; 01:02:33,880<br>All right, this is what we need to pay attention to.</p>
<p>734<br>01:02:33,880 –&gt; 01:02:36,360<br>Material for exam starts back again.</p>
<p>735<br>01:02:36,360 –&gt; 01:02:40,000<br>We won’t ask you questions on shadow pageing.</p>
<p>736<br>01:02:40,000 –&gt; 01:02:44,160<br>Right ahead log is the way you implement the Bay Foundation</p>
<p>737<br>01:02:44,160 –&gt; 01:02:46,480<br>for the recovery protocol.</p>
<p>738<br>01:02:46,480 –&gt; 01:02:49,880<br>The idea is we want to make the steel no force,</p>
<p>739<br>01:02:49,880 –&gt; 01:02:53,160<br>the opposite of the easiest scheme, the hardest scheme,</p>
<p>740<br>01:02:53,159 –&gt; 01:02:54,839<br>the steel no force work.</p>
<p>741<br>01:02:54,839 –&gt; 01:02:58,799<br>And for that, we’ll have to keep track of what changes</p>
<p>742<br>01:02:58,799 –&gt; 01:03:02,559<br>are being made and use those changes in two different ways.</p>
<p>743<br>01:03:02,559 –&gt; 01:03:05,079<br>So we’ll create something called a log file.</p>
<p>744<br>01:03:05,079 –&gt; 01:03:08,480<br>Don’t confuse this with a log structured file system.</p>
<p>745<br>01:03:08,480 –&gt; 01:03:11,759<br>I’ll make a comment about that in a little bit.</p>
<p>746<br>01:03:11,759 –&gt; 01:03:16,480<br>Quick preview of that is even a log structured file system</p>
<p>747<br>01:03:16,480 –&gt; 01:03:19,359<br>for the men table will do logging like this, the right ahead</p>
<p>748<br>01:03:19,359 –&gt; 01:03:20,440<br>logging.</p>
<p>749<br>01:03:20,440 –&gt; 01:03:22,319<br>So this is database logs.</p>
<p>750<br>01:03:22,320 –&gt; 01:03:25,120<br>And we’ll keep that in a database log file,</p>
<p>751<br>01:03:25,120 –&gt; 01:03:27,039<br>which is a different file.</p>
<p>752<br>01:03:27,039 –&gt; 01:03:30,200<br>And the log records, we are going to create log records</p>
<p>753<br>01:03:30,200 –&gt; 01:03:34,280<br>and they’ll get created in the buffer pool in pages that</p>
<p>754<br>01:03:34,280 –&gt; 01:03:36,760<br>will eventually get flushed out to the log file.</p>
<p>755<br>01:03:36,760 –&gt; 01:03:39,240<br>OK, so there’s a separate file called the log file.</p>
<p>756<br>01:03:39,240 –&gt; 01:03:41,240<br>OK, and it will go through the buffer pool too.</p>
<p>757<br>01:03:41,240 –&gt; 01:03:43,200<br>And usually there’s a separate place in the buffer pool</p>
<p>758<br>01:03:43,200 –&gt; 01:03:46,080<br>for buffering log pages.</p>
<p>759<br>01:03:46,080 –&gt; 01:03:50,000<br>So you can think of a design space as having these two</p>
<p>760<br>01:03:50,000 –&gt; 01:03:53,440<br>dimensions, force, yes, no, at transaction</p>
<p>761<br>01:03:53,440 –&gt; 01:03:57,000<br>commit time to a force, the changes to disk,</p>
<p>762<br>01:03:57,000 –&gt; 01:04:00,280<br>or how flexible is the buffer pool?</p>
<p>763<br>01:04:00,280 –&gt; 01:04:01,840<br>Does it allow to steal pages?</p>
<p>764<br>01:04:01,840 –&gt; 01:04:04,480<br>We want that because that makes it more efficient</p>
<p>765<br>01:04:04,480 –&gt; 01:04:05,519<br>or not allowed to steal.</p>
<p>766<br>01:04:05,519 –&gt; 01:04:08,639<br>And we already talked about the no-steel force policy</p>
<p>767<br>01:04:08,639 –&gt; 01:04:10,079<br>has been trivial.</p>
<p>768<br>01:04:10,079 –&gt; 01:04:13,000<br>And what we want is that desired space.</p>
<p>769<br>01:04:13,000 –&gt; 01:04:16,000<br>So no force steal policy on the force aspect basically</p>
<p>770<br>01:04:16,000 –&gt; 01:04:19,400<br>says for every update, flushed the updated page to disk.</p>
<p>771<br>01:04:19,400 –&gt; 01:04:21,920<br>And this means transactions are durable.</p>
<p>772<br>01:04:21,920 –&gt; 01:04:23,720<br>Committed transactions changes are on disk.</p>
<p>773<br>01:04:23,720 –&gt; 01:04:25,240<br>So for committed transaction, you can say,</p>
<p>774<br>01:04:25,240 –&gt; 01:04:28,280<br>I’ve met the D property for you.</p>
<p>775<br>01:04:28,280 –&gt; 01:04:29,840<br>But it’ll be poor response time because you’ve</p>
<p>776<br>01:04:29,840 –&gt; 01:04:32,440<br>to flush a lot of pages to disk for transactions</p>
<p>777<br>01:04:32,440 –&gt; 01:04:34,760<br>that update a lot.</p>
<p>778<br>01:04:34,760 –&gt; 01:04:37,800<br>The steal policy and the force plus no-steel</p>
<p>779<br>01:04:37,800 –&gt; 01:04:39,119<br>is the easiest combination, right?</p>
<p>780<br>01:04:39,119 –&gt; 01:04:42,079<br>But all no-steel policies, what they will say</p>
<p>781<br>01:04:42,079 –&gt; 01:04:45,840<br>is the buffer manager cannot take a page away for a transaction</p>
<p>782<br>01:04:45,840 –&gt; 01:04:47,240<br>that is still working.</p>
<p>783<br>01:04:47,239 –&gt; 01:04:49,919<br>And that works for a bought-it transaction</p>
<p>784<br>01:04:49,919 –&gt; 01:04:53,239<br>because their changes will make it to disk, right?</p>
<p>785<br>01:04:53,239 –&gt; 01:04:56,239<br>But it will be a low throughput because very soon,</p>
<p>786<br>01:04:56,239 –&gt; 01:04:59,919<br>the buffer manager has very few degrees of freedom</p>
<p>787<br>01:04:59,919 –&gt; 01:05:03,519<br>to take pages and do the replacement policy.</p>
<p>788<br>01:05:03,519 –&gt; 01:05:06,679<br>So we really want the no force and steal policy.</p>
<p>789<br>01:05:06,679 –&gt; 01:05:09,159<br>What’s the complication with the no force?</p>
<p>790<br>01:05:09,159 –&gt; 01:05:13,919<br>So remember, no force are concern is that, at commit time,</p>
<p>791<br>01:05:13,919 –&gt; 01:05:16,799<br>I’m not requiring the dirty pages we flush to disk.</p>
<p>792<br>01:05:16,800 –&gt; 01:05:19,680<br>We let the allowed U time send dictate that</p>
<p>793<br>01:05:19,680 –&gt; 01:05:21,840<br>when the pages written out.</p>
<p>794<br>01:05:21,840 –&gt; 01:05:23,960<br>But what happens if a page crashes</p>
<p>795<br>01:05:23,960 –&gt; 01:05:25,400<br>before it changes make it to disk?</p>
<p>796<br>01:05:25,400 –&gt; 01:05:27,640<br>The example we started out with Putin</p>
<p>797<br>01:05:27,640 –&gt; 01:05:30,519<br>zapping up the page that we have to go deal with that.</p>
<p>798<br>01:05:30,519 –&gt; 01:05:34,280<br>So what we’ll do is we’ll write these things called logs,</p>
<p>799<br>01:05:34,280 –&gt; 01:05:38,480<br>which are essentially diffs of changes that we made.</p>
<p>800<br>01:05:38,480 –&gt; 01:05:42,120<br>And we’ll use that at recovery protocol time,</p>
<p>801<br>01:05:42,120 –&gt; 01:05:44,640<br>next lecture, to redo the changes that</p>
<p>802<br>01:05:44,639 –&gt; 01:05:47,759<br>should have been in the stable storage in the first place.</p>
<p>803<br>01:05:47,759 –&gt; 01:05:52,119<br>So we need logs to redo changes that we should do.</p>
<p>804<br>01:05:53,359 –&gt; 01:05:56,879<br>The steal policy, we want stealing allowed.</p>
<p>805<br>01:05:56,879 –&gt; 01:05:59,559<br>And this is like 2023.</p>
<p>806<br>01:05:59,559 –&gt; 01:06:02,159<br>So probably if all of these techniques were invented now,</p>
<p>807<br>01:06:02,159 –&gt; 01:06:04,000<br>we’d probably not call it steal and force.</p>
<p>808<br>01:06:04,000 –&gt; 01:06:07,079<br>But there’s a non-PC times when these terms were invented.</p>
<p>809<br>01:06:07,079 –&gt; 01:06:08,639<br>So part of that.</p>
<p>810<br>01:06:08,639 –&gt; 01:06:11,239<br>But we’ll stay with the terms that are in the literature.</p>
<p>811<br>01:06:11,239 –&gt; 01:06:13,839<br>So with the steal policy, our concern is that a page</p>
<p>812<br>01:06:13,840 –&gt; 01:06:16,960<br>that was stolen and flushed to disk may have changes</p>
<p>813<br>01:06:16,960 –&gt; 01:06:19,160<br>that were made by an uncommitted transaction.</p>
<p>814<br>01:06:19,160 –&gt; 01:06:20,640<br>Now we need to undo that.</p>
<p>815<br>01:06:20,640 –&gt; 01:06:23,840<br>So we’re going to need logging to allow us to undo that.</p>
<p>816<br>01:06:23,840 –&gt; 01:06:26,240<br>So logging is going to be used.</p>
<p>817<br>01:06:26,240 –&gt; 01:06:29,240<br>Logging must have enough information to allow us to redo</p>
<p>818<br>01:06:29,240 –&gt; 01:06:31,880<br>and undo and the recovery protocol that we’ll talk about</p>
<p>819<br>01:06:31,880 –&gt; 01:06:35,640<br>in the next class will decide whether it deeds a log record,</p>
<p>820<br>01:06:35,640 –&gt; 01:06:37,440<br>whether it has to redo or undo.</p>
<p>821<br>01:06:38,920 –&gt; 01:06:42,440<br>But along with that, there’s another fundamental protocol</p>
<p>822<br>01:06:42,440 –&gt; 01:06:43,440<br>that we need.</p>
<p>823<br>01:06:43,440 –&gt; 01:06:46,159<br>And that is called right ahead logging.</p>
<p>824<br>01:06:46,159 –&gt; 01:06:49,679<br>The two very foundational pieces that you need in databases</p>
<p>825<br>01:06:49,679 –&gt; 01:06:52,159<br>one is this notion of two-phase logging</p>
<p>826<br>01:06:52,159 –&gt; 01:06:54,360<br>because from that you’ve got the dependence graph</p>
<p>827<br>01:06:54,360 –&gt; 01:06:55,880<br>of which everything is based for you</p>
<p>828<br>01:06:55,880 –&gt; 01:06:58,360<br>to understand how to get isolation.</p>
<p>829<br>01:06:58,360 –&gt; 01:07:00,360<br>The other piece is right ahead logging,</p>
<p>830<br>01:07:00,360 –&gt; 01:07:04,840<br>which is the protocol that says, what at what point</p>
<p>831<br>01:07:04,840 –&gt; 01:07:09,960<br>can I declare a transaction status to be committed or important?</p>
<p>832<br>01:07:09,960 –&gt; 01:07:13,639<br>There’s a magical moment in the protocol where you say,</p>
<p>833<br>01:07:13,639 –&gt; 01:07:16,320<br>at the point where x happens that x is going to be</p>
<p>834<br>01:07:16,320 –&gt; 01:07:19,880<br>when the commit log hits disk,</p>
<p>835<br>01:07:19,880 –&gt; 01:07:23,079<br>the transaction changes its status from active to committed.</p>
<p>836<br>01:07:23,079 –&gt; 01:07:26,119<br>It has to be one very finite boundary</p>
<p>837<br>01:07:26,119 –&gt; 01:07:28,159<br>in that magical moment is determined</p>
<p>838<br>01:07:28,159 –&gt; 01:07:30,320<br>by this right ahead logging protocol.</p>
<p>839<br>01:07:30,320 –&gt; 01:07:34,039<br>And what that says is that the database system is going</p>
<p>840<br>01:07:34,039 –&gt; 01:07:37,400<br>to log records, this stays in volatile storage,</p>
<p>841<br>01:07:37,400 –&gt; 01:07:41,200<br>and all records updated to a page are stayed</p>
<p>842<br>01:07:41,200 –&gt; 01:07:45,039<br>in this non-volatile log buffer pool storage.</p>
<p>843<br>01:07:45,039 –&gt; 01:07:49,840<br>But before I write a page to stable storage,</p>
<p>844<br>01:07:49,840 –&gt; 01:07:53,880<br>I must make sure its log is written before I can write the page.</p>
<p>845<br>01:07:53,880 –&gt; 01:07:56,800<br>That’s the right ahead logging protocol says,</p>
<p>846<br>01:07:56,800 –&gt; 01:08:00,119<br>that way I have the log information to undo and redo.</p>
<p>847<br>01:08:02,320 –&gt; 01:08:04,840<br>So before I can write the page</p>
<p>848<br>01:08:04,840 –&gt; 01:08:07,800<br>and overwrite it in stable storage,</p>
<p>849<br>01:08:07,800 –&gt; 01:08:10,200<br>all of its log must hit the disk.</p>
<p>850<br>01:08:10,200 –&gt; 01:08:12,240<br>And without that, all of the stuff that we’ll talk about</p>
<p>851<br>01:08:12,240 –&gt; 01:08:12,920<br>will fail.</p>
<p>852<br>01:08:12,920 –&gt; 01:08:14,280<br>So right ahead logging protocol says,</p>
<p>853<br>01:08:14,280 –&gt; 01:08:17,079<br>this is the way you’re going to get that log information.</p>
<p>854<br>01:08:17,079 –&gt; 01:08:19,279<br>And intuitively it makes sense, right?</p>
<p>855<br>01:08:19,279 –&gt; 01:08:22,319<br>If I wrote the page and then crashed before the log hit it,</p>
<p>856<br>01:08:22,319 –&gt; 01:08:26,079<br>I don’t know how to redo and undo the things that I may need to.</p>
<p>857<br>01:08:28,119 –&gt; 01:08:31,680<br>So, record your changes, record,</p>
<p>858<br>01:08:31,680 –&gt; 01:08:34,119<br>take that record of changes, put it in some place,</p>
<p>859<br>01:08:34,119 –&gt; 01:08:37,000<br>save that is stable before you can make the page,</p>
<p>860<br>01:08:37,000 –&gt; 01:08:40,520<br>the changes pushed out to stable storage.</p>
<p>861<br>01:08:40,520 –&gt; 01:08:41,720<br>What’s the stable storage?</p>
<p>862<br>01:08:41,720 –&gt; 01:08:42,720<br>Yes, log width.</p>
<p>863<br>01:08:42,720 –&gt; 01:08:43,720<br>So there are two things happening.</p>
<p>864<br>01:08:43,720 –&gt; 01:08:45,960<br>I’ve got a table in which I’m making changes</p>
<p>865<br>01:08:45,960 –&gt; 01:08:47,720<br>or bunch of tables in the database.</p>
<p>866<br>01:08:47,720 –&gt; 01:08:50,119<br>All of those changes we’re going to record in a log</p>
<p>867<br>01:08:50,119 –&gt; 01:08:51,680<br>that is sitting in the buffer pool,</p>
<p>868<br>01:08:51,680 –&gt; 01:08:53,800<br>because we also don’t want the log to be written</p>
<p>869<br>01:08:53,800 –&gt; 01:08:55,600<br>to disk every time that’s slow.</p>
<p>870<br>01:08:55,600 –&gt; 01:08:58,600<br>But in that buffer pool, we’ll flush the buffer pool,</p>
<p>871<br>01:08:58,600 –&gt; 01:09:01,200<br>the logs portion of the buffer pool to disk.</p>
<p>872<br>01:09:02,480 –&gt; 01:09:07,320<br>So if I’m page 13 and the buffer manager says,</p>
<p>873<br>01:09:07,320 –&gt; 01:09:09,400<br>I want to evict page 13.</p>
<p>874<br>01:09:09,400 –&gt; 01:09:11,880<br>First, I’m going to say to the log manager,</p>
<p>875<br>01:09:11,880 –&gt; 01:09:13,720<br>which is managing the log buffer pool,</p>
<p>876<br>01:09:13,720 –&gt; 01:09:15,280<br>different buffer pool, right?</p>
<p>877<br>01:09:15,280 –&gt; 01:09:16,640<br>Make them from the same memory space,</p>
<p>878<br>01:09:16,640 –&gt; 01:09:18,440<br>where it’s a different manager and say,</p>
<p>879<br>01:09:18,440 –&gt; 01:09:23,480<br>hey, log manager, flush all your logs for page 13.</p>
<p>880<br>01:09:23,480 –&gt; 01:09:24,880<br>And tell me when you’re done,</p>
<p>881<br>01:09:24,880 –&gt; 01:09:28,480<br>the log manager will flush it to the log file</p>
<p>882<br>01:09:28,479 –&gt; 01:09:30,279<br>and it’ll all the rights to this log file</p>
<p>883<br>01:09:30,279 –&gt; 01:09:32,239<br>are going to be sequential.</p>
<p>884<br>01:09:32,239 –&gt; 01:09:35,599<br>And then basically come back and now the buffer manager</p>
<p>885<br>01:09:35,599 –&gt; 01:09:37,279<br>can go and evict page 13.</p>
<p>886<br>01:09:41,599 –&gt; 01:09:43,799<br>Yeah, we’ll see the logs, the structure of that log.</p>
<p>887<br>01:09:43,799 –&gt; 01:09:44,719<br>So that’s coming.</p>
<p>888<br>01:09:44,719 –&gt; 01:09:48,000<br>What’s in the logs and what that looks like is coming.</p>
<p>889<br>01:09:49,000 –&gt; 01:09:50,599<br>But basically just think about it that way.</p>
<p>890<br>01:09:50,599 –&gt; 01:09:54,599<br>When a buffer pool, a dirty page, only on a dirty page,</p>
<p>891<br>01:09:54,599 –&gt; 01:09:55,839<br>if it’s a clean page, you don’t have to talk</p>
<p>892<br>01:09:55,839 –&gt; 01:09:57,519<br>to the log manager, you as the buffer manager.</p>
<p>893<br>01:09:57,520 –&gt; 01:10:01,960<br>But the buffer pool manager on evicting a dirty page</p>
<p>894<br>01:10:01,960 –&gt; 01:10:04,840<br>has to first tell the log manager, please flush everything</p>
<p>895<br>01:10:04,840 –&gt; 01:10:07,560<br>because the right-hand protocol requires you to do that</p>
<p>896<br>01:10:07,560 –&gt; 01:10:09,200<br>before you can do anything else.</p>
<p>897<br>01:10:09,200 –&gt; 01:10:12,520<br>So to say that the page already has a stable storage,</p>
<p>898<br>01:10:12,520 –&gt; 01:10:15,800<br>then you can say that all records pertinent</p>
<p>899<br>01:10:15,800 –&gt; 01:10:18,720<br>to an updated page are written to non-volatile storage.</p>
<p>900<br>01:10:18,720 –&gt; 01:10:20,000<br>It says non-volatile storage.</p>
<p>901<br>01:10:20,000 –&gt; 01:10:21,160<br>Non-volatile is stable.</p>
<p>902<br>01:10:21,160 –&gt; 01:10:23,200<br>Yeah, the disk and SSDs.</p>
<p>903<br>01:10:23,200 –&gt; 01:10:25,360<br>Yeah, I know that textbooks say it’s non-volatile.</p>
<p>904<br>01:10:25,359 –&gt; 01:10:27,159<br>Previously, people used to call it stable</p>
<p>905<br>01:10:27,159 –&gt; 01:10:28,679<br>before that they used to call it disk.</p>
<p>906<br>01:10:28,679 –&gt; 01:10:30,639<br>So terms are changing like every few years</p>
<p>907<br>01:10:30,639 –&gt; 01:10:32,960<br>because the storage hierarchy is changing.</p>
<p>908<br>01:10:32,960 –&gt; 01:10:35,599<br>Yeah, so non-volatile is a good stuff</p>
<p>909<br>01:10:35,599 –&gt; 01:10:36,880<br>that will not get zapped.</p>
<p>910<br>01:10:40,199 –&gt; 01:10:41,559<br>So the slide is correct.</p>
<p>911<br>01:10:41,559 –&gt; 01:10:42,399<br>Great.</p>
<p>912<br>01:10:42,399 –&gt; 01:10:46,119<br>So besides this, we’re gonna do a couple more things.</p>
<p>913<br>01:10:46,119 –&gt; 01:10:48,239<br>We’re going to write a special type of a log record</p>
<p>914<br>01:10:48,239 –&gt; 01:10:49,839<br>called a begin log record.</p>
<p>915<br>01:10:49,839 –&gt; 01:10:51,639<br>And when a transaction finishes,</p>
<p>916<br>01:10:51,639 –&gt; 01:10:53,960<br>with the commit status, we’ll write a commit log record.</p>
<p>917<br>01:10:53,960 –&gt; 01:10:55,199<br>This is also in a bot log record.</p>
<p>918<br>01:10:55,199 –&gt; 01:10:57,039<br>We’ll see that in the next class.</p>
<p>919<br>01:10:57,039 –&gt; 01:11:02,119<br>And then again, this says before I commit the transaction,</p>
<p>920<br>01:11:02,119 –&gt; 01:11:04,239<br>this magical moment for a commit,</p>
<p>921<br>01:11:04,239 –&gt; 01:11:05,239<br>right?</p>
<p>922<br>01:11:05,239 –&gt; 01:11:06,079<br>A protocol has two components.</p>
<p>923<br>01:11:06,079 –&gt; 01:11:08,480<br>One is a mixture of a dirty page.</p>
<p>924<br>01:11:08,480 –&gt; 01:11:11,119<br>Please flush your logs before you flush the page.</p>
<p>925<br>01:11:11,119 –&gt; 01:11:12,920<br>And the other thing it says,</p>
<p>926<br>01:11:12,920 –&gt; 01:11:14,279<br>when you commit a transaction,</p>
<p>927<br>01:11:14,279 –&gt; 01:11:17,239<br>that commit log record must be created,</p>
<p>928<br>01:11:18,239 –&gt; 01:11:22,439<br>written in the log buffer pool.</p>
<p>929<br>01:11:22,439 –&gt; 01:11:26,519<br>And that log page must be flushed to disk</p>
<p>930<br>01:11:26,519 –&gt; 01:11:28,759<br>into this non-volatile storage.</p>
<p>931<br>01:11:28,759 –&gt; 01:11:30,639<br>When you get the signal back,</p>
<p>932<br>01:11:30,639 –&gt; 01:11:32,479<br>that the page has been written correctly,</p>
<p>933<br>01:11:32,479 –&gt; 01:11:35,119<br>that’s the magical moment when the commit happens.</p>
<p>934<br>01:11:35,119 –&gt; 01:11:37,759<br>And now you can tell the world that transactions come in.</p>
<p>935<br>01:11:37,759 –&gt; 01:11:38,919<br>So right now, the logging protocol</p>
<p>936<br>01:11:38,919 –&gt; 01:11:40,439<br>will have those two components.</p>
<p>937<br>01:11:40,439 –&gt; 01:11:42,960<br>Dirty pages, essentially it says,</p>
<p>938<br>01:11:42,960 –&gt; 01:11:46,599<br>the when a log of the change you’re trying to make,</p>
<p>939<br>01:11:46,599 –&gt; 01:11:48,199<br>hits stable storage.</p>
<p>940<br>01:11:48,199 –&gt; 01:11:51,479<br>At that point, we can declare that we now have a mechanism</p>
<p>941<br>01:11:51,479 –&gt; 01:11:55,319<br>to unwind ourselves out from any changes that we need to move out to,</p>
<p>942<br>01:11:55,319 –&gt; 01:11:56,799<br>or reapply changes as we need to,</p>
<p>943<br>01:11:56,799 –&gt; 01:11:59,559<br>because logs will have the redo and undo information.</p>
<p>944<br>01:12:01,039 –&gt; 01:12:02,039<br>Okay?</p>
<p>945<br>01:12:03,079 –&gt; 01:12:04,799<br>All right, questions?</p>
<p>946<br>01:12:05,719 –&gt; 01:12:06,959<br>I want to make sure I get this part</p>
<p>947<br>01:12:06,959 –&gt; 01:12:09,599<br>because this is the foundation for understanding everything</p>
<p>948<br>01:12:09,599 –&gt; 01:12:11,919<br>today and the rest of the next lecture.</p>
<p>949<br>01:12:11,919 –&gt; 01:12:16,359<br>I get why we can put the binary key first.</p>
<p>950<br>01:12:16,359 –&gt; 01:12:18,719<br>The begin bracket is just to say this is the markup.</p>
<p>951<br>01:12:18,719 –&gt; 01:12:20,159<br>And you’ll see when we get to check pointing</p>
<p>952<br>01:12:20,159 –&gt; 01:12:22,199<br>to help us figure out what’s the boundary of that.</p>
<p>953<br>01:12:22,199 –&gt; 01:12:24,399<br>Otherwise, if you have to scan a big log file,</p>
<p>954<br>01:12:24,399 –&gt; 01:12:26,680<br>the log file can have millions of billions of records.</p>
<p>955<br>01:12:26,680 –&gt; 01:12:29,119<br>You’ll say, where did transaction T1 start?</p>
<p>956<br>01:12:29,119 –&gt; 01:12:30,599<br>You have to scan everything.</p>
<p>957<br>01:12:30,599 –&gt; 01:12:33,079<br>This tells you, oh, I don’t need to go any further</p>
<p>958<br>01:12:33,079 –&gt; 01:12:34,720<br>if I’m worried about transaction T1.</p>
<p>959<br>01:12:36,039 –&gt; 01:12:36,960<br>So you want that.</p>
<p>960<br>01:12:38,000 –&gt; 01:12:41,399<br>All right, so what’s in this log, records?</p>
<p>961<br>01:12:42,639 –&gt; 01:12:45,199<br>I’m going to simplify it at a big dramatic level.</p>
<p>962<br>01:12:45,199 –&gt; 01:12:48,399<br>There’s a whole set of papers on what to put in the log records,</p>
<p>963<br>01:12:48,399 –&gt; 01:12:50,319<br>but they all pretty much have this</p>
<p>964<br>01:12:50,319 –&gt; 01:12:51,799<br>in the different type of log records too,</p>
<p>965<br>01:12:51,799 –&gt; 01:12:54,639<br>besides begin, commit, and the ones I’m telling you.</p>
<p>966<br>01:12:54,639 –&gt; 01:12:55,839<br>Again, we’re going to ignore that.</p>
<p>967<br>01:12:55,839 –&gt; 01:12:59,159<br>There’s a big fact textbook they can come that Jim Gray wrote</p>
<p>968<br>01:12:59,159 –&gt; 01:13:01,679<br>on all the details you’d ever want to know about transactions</p>
<p>969<br>01:13:01,679 –&gt; 01:13:02,879<br>and logging.</p>
<p>970<br>01:13:02,879 –&gt; 01:13:05,359<br>Borrow it from me if you’re interested in that.</p>
<p>971<br>01:13:05,359 –&gt; 01:13:09,000<br>For this course, we are going to assume logs</p>
<p>972<br>01:13:09,000 –&gt; 01:13:11,519<br>have this common structure.</p>
<p>973<br>01:13:11,519 –&gt; 01:13:13,799<br>They’ll record which transaction do I belong to?</p>
<p>974<br>01:13:13,799 –&gt; 01:13:15,879<br>What object am I logging?</p>
<p>975<br>01:13:15,879 –&gt; 01:13:16,559<br>Record.</p>
<p>976<br>01:13:16,559 –&gt; 01:13:18,279<br>And we’re just going to assume its record level</p>
<p>977<br>01:13:18,279 –&gt; 01:13:19,359<br>for this class.</p>
<p>978<br>01:13:19,359 –&gt; 01:13:21,840<br>And then what type of information am I logging?</p>
<p>979<br>01:13:21,840 –&gt; 01:13:24,960<br>Is it something that I use for undo or for redo?</p>
<p>980<br>01:13:24,960 –&gt; 01:13:28,519<br>And obviously, the undo stuff, which means give me my old value,</p>
<p>981<br>01:13:28,519 –&gt; 01:13:30,039<br>is something you wouldn’t do if you’re working</p>
<p>982<br>01:13:30,039 –&gt; 01:13:32,119<br>with an NBCC based storage system.</p>
<p>983<br>01:13:33,519 –&gt; 01:13:36,399<br>So little connection across that.</p>
<p>984<br>01:13:36,399 –&gt; 01:13:37,880<br>But rest of it again, we are going to work</p>
<p>985<br>01:13:37,880 –&gt; 01:13:39,479<br>with a single version system to keep</p>
<p>986<br>01:13:39,479 –&gt; 01:13:42,399<br>all the PowerPoints sensible.</p>
<p>987<br>01:13:42,399 –&gt; 01:13:46,239<br>So right ahead, logging example, start with the transaction.</p>
<p>988<br>01:13:46,239 –&gt; 01:13:49,039<br>Now, as you can see, the Buffer Pool has a Buffer Pool</p>
<p>989<br>01:13:49,039 –&gt; 01:13:50,159<br>for your pages.</p>
<p>990<br>01:13:50,159 –&gt; 01:13:53,719<br>And a little additional thing called the right ahead buffer.</p>
<p>991<br>01:13:53,719 –&gt; 01:13:57,479<br>So it’s a Buffer Pool like your page-oriented Buffer Pool</p>
<p>992<br>01:13:57,479 –&gt; 01:13:59,679<br>probably much smaller.</p>
<p>993<br>01:13:59,679 –&gt; 01:14:03,479<br>And it’s things from that get evicted from top to end.</p>
<p>994<br>01:14:03,479 –&gt; 01:14:07,519<br>It’s the log, as you’ll see, is a linear sequence of log records</p>
<p>995<br>01:14:07,519 –&gt; 01:14:08,840<br>they’re ordered.</p>
<p>996<br>01:14:08,840 –&gt; 01:14:10,920<br>And so effectively, the right ahead Buffer Pool</p>
<p>997<br>01:14:10,920 –&gt; 01:14:12,079<br>is typically pretty small.</p>
<p>998<br>01:14:12,079 –&gt; 01:14:15,559<br>It might just have a small number of pages</p>
<p>999<br>01:14:15,560 –&gt; 01:14:16,840<br>you need at least two.</p>
<p>1000<br>01:14:16,840 –&gt; 01:14:18,320<br>It might have a few hundred.</p>
<p>1001<br>01:14:18,320 –&gt; 01:14:20,640<br>And everything’s going to get flushed from top to bottom.</p>
<p>1002<br>01:14:20,640 –&gt; 01:14:22,640<br>And that will become more clear when we talk about the recovery</p>
<p>1003<br>01:14:22,640 –&gt; 01:14:24,760<br>protocol in the next class.</p>
<p>1004<br>01:14:24,760 –&gt; 01:14:26,560<br>So it’s a sequential file.</p>
<p>1005<br>01:14:26,560 –&gt; 01:14:28,200<br>Little bit different than the other files.</p>
<p>1006<br>01:14:28,200 –&gt; 01:14:29,440<br>But it has a Buffer Pool.</p>
<p>1007<br>01:14:29,440 –&gt; 01:14:31,400<br>So that when log records are created,</p>
<p>1008<br>01:14:31,400 –&gt; 01:14:33,240<br>they get created in the Buffer Pool.</p>
<p>1009<br>01:14:33,240 –&gt; 01:14:36,200<br>So transaction T1 started, has a begin.</p>
<p>1010<br>01:14:36,200 –&gt; 01:14:38,039<br>Now, T1 is getting written.</p>
<p>1011<br>01:14:38,039 –&gt; 01:14:39,400<br>So that transaction is recording.</p>
<p>1012<br>01:14:39,400 –&gt; 01:14:40,720<br>Your old value is one.</p>
<p>1013<br>01:14:40,720 –&gt; 01:14:42,360<br>New value is eight.</p>
<p>1014<br>01:14:42,359 –&gt; 01:14:44,119<br>Sorry, old value is eight.</p>
<p>1015<br>01:14:44,119 –&gt; 01:14:45,559<br>New value is one.</p>
<p>1016<br>01:14:45,559 –&gt; 01:14:48,759<br>And so that’s why that record has T1 and 8,</p>
<p>1017<br>01:14:48,759 –&gt; 01:14:49,960<br>because 8 was the old values.</p>
<p>1018<br>01:14:49,960 –&gt; 01:14:54,279<br>Now, in the log record, I’m keeping track of my old and new value.</p>
<p>1019<br>01:14:54,279 –&gt; 01:14:55,960<br>New pins, as we just talked about,</p>
<p>1020<br>01:14:55,960 –&gt; 01:14:59,519<br>you can optimize that stuff if you’re in NBCC.</p>
<p>1021<br>01:14:59,519 –&gt; 01:15:01,039<br>And now, we got written.</p>
<p>1022<br>01:15:01,039 –&gt; 01:15:04,199<br>Again, I’ve got old and new value when I write,</p>
<p>1023<br>01:15:04,199 –&gt; 01:15:05,880<br>when the transaction is ready to commit.</p>
<p>1024<br>01:15:05,880 –&gt; 01:15:09,000<br>Even though that log Buffer Pool page is not full for that</p>
<p>1025<br>01:15:09,000 –&gt; 01:15:11,719<br>right ahead blog file, I will flush that</p>
<p>1026<br>01:15:11,720 –&gt; 01:15:16,560<br>half full page to disk before I can declare from it.</p>
<p>1027<br>01:15:16,560 –&gt; 01:15:20,159<br>When that page comes back with a OK, the page was written,</p>
<p>1028<br>01:15:20,159 –&gt; 01:15:22,800<br>the transaction is declared committed.</p>
<p>1029<br>01:15:22,800 –&gt; 01:15:25,079<br>Now, obviously, at the time we’ve</p>
<p>1030<br>01:15:25,079 –&gt; 01:15:26,560<br>optimized a lot of things.</p>
<p>1031<br>01:15:26,560 –&gt; 01:15:29,560<br>If this transaction were touching a million objects,</p>
<p>1032<br>01:15:29,560 –&gt; 01:15:32,840<br>then it may have just created, if it were touching just one byte</p>
<p>1033<br>01:15:32,840 –&gt; 01:15:36,159<br>in the million objects, it may have just created a few log pages,</p>
<p>1034<br>01:15:36,159 –&gt; 01:15:39,920<br>as opposed to having to write million data pages to disk.</p>
<p>1035<br>01:15:39,920 –&gt; 01:15:42,079<br>That’s why you can see why this is faster.</p>
<p>1036<br>01:15:42,079 –&gt; 01:15:46,239<br>But it’s still slow, because at commit time,</p>
<p>1037<br>01:15:46,239 –&gt; 01:15:49,079<br>I still have to wait for that disk I ought to come back.</p>
<p>1038<br>01:15:49,079 –&gt; 01:15:53,640<br>And those are, as you know, many tens of milliseconds, right?</p>
<p>1039<br>01:15:53,640 –&gt; 01:15:56,840<br>And so, even though it is safe, this can be slow.</p>
<p>1040<br>01:15:59,840 –&gt; 01:16:03,840<br>And if the, now at that commit time, if the Buffer Pool gets</p>
<p>1041<br>01:16:03,840 –&gt; 01:16:07,000<br>zapped out, the DRAM gets zapped out, which means I’ve lost both</p>
<p>1042<br>01:16:07,000 –&gt; 01:16:10,479<br>Buffer Pool and can reconstruct from that log file.</p>
<p>1043<br>01:16:10,479 –&gt; 01:16:13,439<br>But it’s still slow, because for each commit,</p>
<p>1044<br>01:16:13,439 –&gt; 01:16:16,000<br>I have to wait for the disk to finish.</p>
<p>1045<br>01:16:16,000 –&gt; 01:16:18,039<br>Now, imagine I’ve got 100 transactions running.</p>
<p>1046<br>01:16:18,039 –&gt; 01:16:20,399<br>They all are ready to commit.</p>
<p>1047<br>01:16:20,399 –&gt; 01:16:22,720<br>The first transaction will come at, wait for that page</p>
<p>1048<br>01:16:22,720 –&gt; 01:16:24,680<br>to come back.</p>
<p>1049<br>01:16:24,680 –&gt; 01:16:26,960<br>The other transaction cannot come at till the page comes back.</p>
<p>1050<br>01:16:26,960 –&gt; 01:16:29,960<br>So now, you’re blocking transactions from tens of milliseconds,</p>
<p>1051<br>01:16:29,960 –&gt; 01:16:31,000<br>which is an eternity.</p>
<p>1052<br>01:16:31,000 –&gt; 01:16:34,079<br>I still have a pretty slow system, much better</p>
<p>1053<br>01:16:34,079 –&gt; 01:16:37,159<br>than the no-steel force policy that we had,</p>
<p>1054<br>01:16:37,159 –&gt; 01:16:39,119<br>but can be make it better.</p>
<p>1055<br>01:16:39,119 –&gt; 01:16:42,319<br>So, most systems for high performance</p>
<p>1056<br>01:16:42,319 –&gt; 01:16:44,479<br>will do something called group commit.</p>
<p>1057<br>01:16:44,479 –&gt; 01:16:47,159<br>It’s a very simple idea, is that I’m</p>
<p>1058<br>01:16:47,159 –&gt; 01:16:50,760<br>going to batch up the commits that are coming together.</p>
<p>1059<br>01:16:50,760 –&gt; 01:16:52,920<br>I’m going to pick an intro of like five milliseconds</p>
<p>1060<br>01:16:52,920 –&gt; 01:16:53,640<br>or something like that.</p>
<p>1061<br>01:16:53,640 –&gt; 01:16:54,800<br>It’s pretty common.</p>
<p>1062<br>01:16:54,800 –&gt; 01:16:56,519<br>And even though a transaction is ready to commit,</p>
<p>1063<br>01:16:56,519 –&gt; 01:17:01,319<br>like T1 comes in, creates that stuff in the Buffer Pool here.</p>
<p>1064<br>01:17:01,319 –&gt; 01:17:03,479<br>It’s in the right-ahead Buffer Pool.</p>
<p>1065<br>01:17:03,479 –&gt; 01:17:05,679<br>Now, I’m not showing the data Buffer Pool.</p>
<p>1066<br>01:17:05,679 –&gt; 01:17:08,000<br>Remainter of this class will only</p>
<p>1067<br>01:17:08,000 –&gt; 01:17:10,759<br>care about the right-ahead log Buffer Pool,</p>
<p>1068<br>01:17:10,759 –&gt; 01:17:13,519<br>or the log manager’s Buffer Pool.</p>
<p>1069<br>01:17:13,519 –&gt; 01:17:17,959<br>This comes in, starts to go, and that page gets flushed</p>
<p>1070<br>01:17:17,959 –&gt; 01:17:21,039<br>to disk, and that’s fine, because maybe we need that page.</p>
<p>1071<br>01:17:21,039 –&gt; 01:17:23,279<br>We start writing to that new page.</p>
<p>1072<br>01:17:23,279 –&gt; 01:17:26,079<br>And one of the transactions is ready to commit.</p>
<p>1073<br>01:17:26,079 –&gt; 01:17:28,519<br>As you can see, the other transaction</p>
<p>1074<br>01:17:28,519 –&gt; 01:17:30,279<br>is going to come at very shortly.</p>
<p>1075<br>01:17:30,279 –&gt; 01:17:32,719<br>We don’t know that, but with the group commit,</p>
<p>1076<br>01:17:32,720 –&gt; 01:17:34,800<br>what you do is you’ll say, I as a transaction</p>
<p>1077<br>01:17:34,800 –&gt; 01:17:36,079<br>and ready to commit.</p>
<p>1078<br>01:17:36,079 –&gt; 01:17:36,680<br>But you know what?</p>
<p>1079<br>01:17:36,680 –&gt; 01:17:39,079<br>I’m going to hold off for five milliseconds,</p>
<p>1080<br>01:17:39,079 –&gt; 01:17:40,520<br>whatever is the timeout.</p>
<p>1081<br>01:17:40,520 –&gt; 01:17:43,520<br>And wait for anyone else who wants to write a commit log</p>
<p>1082<br>01:17:43,520 –&gt; 01:17:47,199<br>record to everything that’s in the Buffer Pool.</p>
<p>1083<br>01:17:47,199 –&gt; 01:17:48,960<br>And then every five milliseconds, I’m going to take</p>
<p>1084<br>01:17:48,960 –&gt; 01:17:51,320<br>everyone that is waiting to be committed,</p>
<p>1085<br>01:17:51,320 –&gt; 01:17:53,720<br>because they’ve declared, I’ve thrown my commit flag,</p>
<p>1086<br>01:17:53,720 –&gt; 01:17:56,600<br>tell me when I’m done, you collect all of their log records,</p>
<p>1087<br>01:17:56,600 –&gt; 01:17:58,880<br>and then you’ll flush that out to disk.</p>
<p>1088<br>01:17:58,880 –&gt; 01:18:01,520<br>And so effectively, when you write that page,</p>
<p>1089<br>01:18:01,520 –&gt; 01:18:04,640<br>everything that you’ve written, all the transactions</p>
<p>1090<br>01:18:04,640 –&gt; 01:18:06,320<br>that were ready to commit, they’ll</p>
<p>1091<br>01:18:06,320 –&gt; 01:18:10,160<br>wait an average of five milliseconds is your timeout interval.</p>
<p>1092<br>01:18:10,160 –&gt; 01:18:12,560<br>They’ll wait an average of 2.5 milliseconds.</p>
<p>1093<br>01:18:12,560 –&gt; 01:18:16,800<br>But what you’ll get is a much higher throughput system,</p>
<p>1094<br>01:18:16,800 –&gt; 01:18:19,040<br>though you’ve added a little bit of latency</p>
<p>1095<br>01:18:19,040 –&gt; 01:18:21,960<br>to each transaction on average 2.5 in this case.</p>
<p>1096<br>01:18:21,960 –&gt; 01:18:24,280<br>But the throughput of the system will be much higher.</p>
<p>1097<br>01:18:24,280 –&gt; 01:18:26,920<br>Because one disk I will commit a whole bunch of transactions.</p>
<p>1098<br>01:18:26,920 –&gt; 01:18:29,240<br>If lots of transaction systems are active,</p>
<p>1099<br>01:18:29,240 –&gt; 01:18:31,000<br>maybe you’ve got 100 transactions</p>
<p>1100<br>01:18:31,000 –&gt; 01:18:33,640<br>that were ready to commit in that five milliseconds period.</p>
<p>1101<br>01:18:33,640 –&gt; 01:18:36,399<br>So you’ll get a much higher throughput system than you have.</p>
<p>1102<br>01:18:36,399 –&gt; 01:18:38,920<br>So pretty much everyone does some form of group commit</p>
<p>1103<br>01:18:38,920 –&gt; 01:18:39,640<br>to do that.</p>
<p>1104<br>01:18:39,640 –&gt; 01:18:41,840<br>Some might even play around with a little bit of tricks,</p>
<p>1105<br>01:18:41,840 –&gt; 01:18:44,920<br>like, oh, that I won’t even wait.</p>
<p>1106<br>01:18:44,920 –&gt; 01:18:46,119<br>They will go even further.</p>
<p>1107<br>01:18:46,119 –&gt; 01:18:48,560<br>You’ll see, I will write this out to disk.</p>
<p>1108<br>01:18:48,560 –&gt; 01:18:52,079<br>I’ve initiated the disk I.O. I won’t even wait for the I.O.</p>
<p>1109<br>01:18:52,079 –&gt; 01:18:53,760<br>to come back and tell you it’s committed.</p>
<p>1110<br>01:18:53,760 –&gt; 01:18:54,840<br>And you can read the manuals.</p>
<p>1111<br>01:18:54,840 –&gt; 01:18:57,399<br>And sometimes you’ll see that in all the database vendors,</p>
<p>1112<br>01:18:57,399 –&gt; 01:18:59,640<br>like, oh, you could set it up that way, which means it’s</p>
<p>1113<br>01:18:59,640 –&gt; 01:19:01,920<br>like what’s your tolerance to that failure</p>
<p>1114<br>01:19:01,920 –&gt; 01:19:05,119<br>in that short amount of time while that I.O. happens?</p>
<p>1115<br>01:19:05,119 –&gt; 01:19:08,119<br>There are options like that, you will see.</p>
<p>1116<br>01:19:08,119 –&gt; 01:19:08,880<br>A couple more slides.</p>
<p>1117<br>01:19:08,880 –&gt; 01:19:11,000<br>And then I promise I will stop.</p>
<p>1118<br>01:19:11,000 –&gt; 01:19:14,640<br>The logging schemes are, I want to finish the logging schemes</p>
<p>1119<br>01:19:14,640 –&gt; 01:19:16,280<br>and then they’ll stop.</p>
<p>1120<br>01:19:16,280 –&gt; 01:19:17,920<br>There are three different types of logging schemes.</p>
<p>1121<br>01:19:17,920 –&gt; 01:19:19,280<br>Let’s just go through that.</p>
<p>1122<br>01:19:19,280 –&gt; 01:19:21,480<br>The first one is physical logging, which</p>
<p>1123<br>01:19:21,480 –&gt; 01:19:25,079<br>is to say, what I’m going to record is effectively</p>
<p>1124<br>01:19:25,079 –&gt; 01:19:26,600<br>like a good diff.</p>
<p>1125<br>01:19:26,600 –&gt; 01:19:30,960<br>I’m going to record in the log, the before and after image</p>
<p>1126<br>01:19:30,960 –&gt; 01:19:32,760<br>of what was changed.</p>
<p>1127<br>01:19:32,760 –&gt; 01:19:36,640<br>Now, usually that is done at the value level.</p>
<p>1128<br>01:19:36,640 –&gt; 01:19:38,400<br>But as you can imagine, this diff can start</p>
<p>1129<br>01:19:38,400 –&gt; 01:19:40,440<br>to become really large.</p>
<p>1130<br>01:19:40,440 –&gt; 01:19:42,800<br>Now, the challenge with this scheme</p>
<p>1131<br>01:19:42,800 –&gt; 01:19:46,280<br>is that if I’m doing this, imagine I’ve got a page.</p>
<p>1132<br>01:19:46,280 –&gt; 01:19:49,920<br>And that page is a slotted page structure.</p>
<p>1133<br>01:19:49,920 –&gt; 01:19:53,440<br>And records can move around in a slotted page structure</p>
<p>1134<br>01:19:53,440 –&gt; 01:19:55,240<br>while still keeping the slot ID.</p>
<p>1135<br>01:19:55,239 –&gt; 01:19:58,479<br>You might have compaction happening inside the page, for example.</p>
<p>1136<br>01:19:58,479 –&gt; 01:20:01,039<br>This physical logging, when I’m keeping</p>
<p>1137<br>01:20:01,039 –&gt; 01:20:03,800<br>before and after images might record changes</p>
<p>1138<br>01:20:03,800 –&gt; 01:20:06,399<br>at the page level of stuff that is not even changed</p>
<p>1139<br>01:20:06,399 –&gt; 01:20:07,479<br>by this transaction.</p>
<p>1140<br>01:20:07,479 –&gt; 01:20:10,479<br>Because it was just the before and after images</p>
<p>1141<br>01:20:10,479 –&gt; 01:20:13,559<br>might have physically looking at the bytes that</p>
<p>1142<br>01:20:13,559 –&gt; 01:20:16,359<br>have been changed on the page before and after</p>
<p>1143<br>01:20:16,359 –&gt; 01:20:17,639<br>and might get a whole bunch of stuff that</p>
<p>1144<br>01:20:17,639 –&gt; 01:20:19,599<br>is irrelevant to the actual changes,</p>
<p>1145<br>01:20:19,599 –&gt; 01:20:23,439<br>which is a cue to the physiological logging that is coming next.</p>
<p>1146<br>01:20:23,439 –&gt; 01:20:26,279<br>As the other extreme, which is to say logical logging,</p>
<p>1147<br>01:20:26,279 –&gt; 01:20:29,279<br>I’m just going to record the data function</p>
<p>1148<br>01:20:29,279 –&gt; 01:20:32,279<br>that caused this value to change.</p>
<p>1149<br>01:20:32,279 –&gt; 01:20:35,239<br>In a very simple form, it is recording the query.</p>
<p>1150<br>01:20:35,239 –&gt; 01:20:39,319<br>More often, it’s going to be, I incremented the value by 10.</p>
<p>1151<br>01:20:39,319 –&gt; 01:20:42,119<br>If that was an update like that, if the update query</p>
<p>1152<br>01:20:42,119 –&gt; 01:20:44,759<br>is at 8 plus 10, this would actually record,</p>
<p>1153<br>01:20:44,759 –&gt; 01:20:46,079<br>I’m an increment function.</p>
<p>1154<br>01:20:46,079 –&gt; 01:20:48,239<br>And my parameter was 10 to this record.</p>
<p>1155<br>01:20:48,239 –&gt; 01:20:52,319<br>So it would logically record what was changed.</p>
<p>1156<br>01:20:52,319 –&gt; 01:20:55,079<br>Or it might say, I updated 10 for everything</p>
<p>1157<br>01:20:55,079 –&gt; 01:20:58,000<br>that has a predicate of B greater than 10.</p>
<p>1158<br>01:20:58,000 –&gt; 01:21:00,239<br>Effectively, take whatever is in the query,</p>
<p>1159<br>01:21:00,239 –&gt; 01:21:02,159<br>find some representation for that,</p>
<p>1160<br>01:21:02,159 –&gt; 01:21:05,799<br>and represent that in the logical structure, in the log.</p>
<p>1161<br>01:21:05,799 –&gt; 01:21:12,799<br>Now, you can get a much more compact log record.</p>
<p>1162<br>01:21:12,799 –&gt; 01:21:16,239<br>But when you have to go and apply these changes,</p>
<p>1163<br>01:21:16,239 –&gt; 01:21:19,159<br>you have to actually go run that query again to redo it.</p>
<p>1164<br>01:21:19,159 –&gt; 01:21:21,079<br>And if that query took an hour to run,</p>
<p>1165<br>01:21:21,079 –&gt; 01:21:22,880<br>while applying the log, you’re going to have to take an hour</p>
<p>1166<br>01:21:22,880 –&gt; 01:21:23,880<br>to run.</p>
<p>1167<br>01:21:23,880 –&gt; 01:21:25,600<br>And so that could be very expensive.</p>
<p>1168<br>01:21:25,600 –&gt; 01:21:27,199<br>So people don’t do logical logging.</p>
<p>1169<br>01:21:27,199 –&gt; 01:21:30,439<br>What people do is this, basic theological logging, which</p>
<p>1170<br>01:21:30,439 –&gt; 01:21:32,640<br>basically, going back to the previous slide,</p>
<p>1171<br>01:21:32,640 –&gt; 01:21:35,239<br>is it’s physical to a page.</p>
<p>1172<br>01:21:35,239 –&gt; 01:21:41,199<br>So at the page level, you’ll keep track of the before and after</p>
<p>1173<br>01:21:41,199 –&gt; 01:21:42,039<br>images.</p>
<p>1174<br>01:21:42,039 –&gt; 01:21:46,559<br>But for every page that you change,</p>
<p>1175<br>01:21:46,559 –&gt; 01:21:48,600<br>you’re going to create a log record.</p>
<p>1176<br>01:21:48,600 –&gt; 01:21:50,359<br>But within the page, you’ll just say</p>
<p>1177<br>01:21:50,439 –&gt; 01:21:51,439<br>what was the update made?</p>
<p>1178<br>01:21:51,439 –&gt; 01:21:54,759<br>So if the records got moved around, you won’t have that.</p>
<p>1179<br>01:21:54,759 –&gt; 01:21:57,559<br>The downside is that a given operation log record</p>
<p>1180<br>01:21:57,559 –&gt; 01:21:59,359<br>might now generate multiple log records.</p>
<p>1181<br>01:21:59,359 –&gt; 01:22:04,159<br>So if something changed an update to a record</p>
<p>1182<br>01:22:04,159 –&gt; 01:22:06,960<br>might have involved or updated to in the transaction,</p>
<p>1183<br>01:22:06,960 –&gt; 01:22:09,159<br>might have involved changes to multiple pages.</p>
<p>1184<br>01:22:09,159 –&gt; 01:22:11,679<br>You’ll have one log record per page.</p>
<p>1185<br>01:22:11,679 –&gt; 01:22:14,519<br>The bottom line is there are different logging schemes.</p>
<p>1186<br>01:22:14,519 –&gt; 01:22:16,359<br>And what we will use this logging schemes</p>
<p>1187<br>01:22:16,359 –&gt; 01:22:19,599<br>is to do the redo and undo, and we’ll pick up on that</p>
<p>1188<br>01:22:19,600 –&gt; 01:22:20,600<br>in the next class.</p>
<p>1189<br>01:22:21,600 –&gt; 01:22:23,600<br>I’m the poppy with the motherfucking hog.</p>
<p>1190<br>01:22:23,600 –&gt; 01:22:26,600<br>28 gram, the pen and all, if it’s the pop.</p>
<p>1191<br>01:22:26,600 –&gt; 01:22:28,600<br>You ain’t hit the mob yet.</p>
<p>1192<br>01:22:28,600 –&gt; 01:22:30,600<br>Still got your shut up.</p>
<p>1193<br>01:22:30,600 –&gt; 01:22:32,600<br>I smack you with the bottom of the clip.</p>
<p>1194<br>01:22:32,600 –&gt; 01:22:33,600<br>I’ll tell you, little dog.</p>
<p>1195<br>01:22:33,600 –&gt; 01:22:35,600<br>Show me what it’s safe set.</p>
<p>1196<br>01:22:35,600 –&gt; 01:22:39,200<br>For I blow your face, I’m the poppy with the</p>
<p>1197<br>01:22:39,200 –&gt; 01:22:40,600<br>motherfucking hog.</p>
<p>1198<br>01:22:40,600 –&gt; 01:22:42,600<br>28 gram, the pen and all, if it’s the pop.</p>
<p>1199<br>01:22:42,600 –&gt; 01:22:44,600<br>You ain’t hit the mob yet.</p>
<p>1200<br>01:22:44,600 –&gt; 01:22:45,600<br>Still got your shut up.</p>
<p>1201<br>01:22:45,600 –&gt; 01:22:47,600<br>I smack you with the bottom of the clip.</p>
<p>1202<br>01:22:47,600 –&gt; 01:22:48,600<br>I’ll tell you, little dog.</p>
<p>1203<br>01:22:48,600 –&gt; 01:22:49,600<br>Show me what it’s safe set.</p>
<p>1204<br>01:22:49,600 –&gt; 01:22:50,600<br>For I blow your face back.</p>
<p>1205<br>01:22:50,600 –&gt; 01:22:51,600<br>I got a block on top.</p>
<p>1206<br>01:22:51,600 –&gt; 01:22:53,600<br>The feds can’t trace that.</p>
<p>1207<br>01:22:53,600 –&gt; 01:22:55,600<br>Style is like temp, but proof.</p>
<p>1208<br>01:22:55,600 –&gt; 01:22:57,600<br>You can’t lace that at the Dominican.</p>
<p>1209<br>01:22:57,600 –&gt; 01:22:59,600<br>Oh, you could call me Dominican.</p>
<p>1210<br>01:22:59,600 –&gt; 01:23:00,600<br>Black Skelly, black, nothing.</p>
<p>1211<br>01:23:00,600 –&gt; 01:23:01,600<br>Blacks, sweat, dimmelons.</p>
<p>1212<br>01:23:01,600 –&gt; 01:23:04,600<br>My whole black, dirty eight, send you to the purly gates.</p>
<p>1213<br>01:23:04,600 –&gt; 01:23:05,600<br>You get the slumber, trying to skate.</p>
<p>1214<br>01:23:05,600 –&gt; 01:23:06,600<br>And that’s your first mistake.</p>
<p>1215<br>01:23:06,600 –&gt; 01:23:08,600<br>I ain’t lying for that cake.</p>
<p>1216<br>01:23:08,600 –&gt; 01:23:09,600<br>You’re famous.</p>
<p>1217<br>01:23:09,600 –&gt; 01:23:10,600<br>See you, wait.</p>
<p>1218<br>01:23:10,600 –&gt; 01:23:11,600<br>My grandson’s happy, wait.</p>
<p>1219<br>01:23:11,600 –&gt; 01:23:12,600<br>The ran through every state.</p>
<p>1220<br>01:23:12,600 –&gt; 01:23:14,600<br>When they asked me how I’m living, I tell them I’m living great.</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CMU15445 P20F202319 DatabaseLogging</div>
      <div>http://example.com/2025/10/25/CMU15445 P20F202319-DatabaseLogging/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/25/CMU15445%20P1F202300-CourseOverviewLogistics/" title="CMU15445 P1F202300 CourseOverviewLogistics">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CMU15445 P1F202300 CourseOverviewLogistics</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/25/CMU15445%20P19F202318-Multi-VersionConcurrencyControl/" title="CMU15445 P19F202318 Multi VersionConcurrencyControl">
                        <span class="hidden-mobile">CMU15445 P19F202318 Multi VersionConcurrencyControl</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
