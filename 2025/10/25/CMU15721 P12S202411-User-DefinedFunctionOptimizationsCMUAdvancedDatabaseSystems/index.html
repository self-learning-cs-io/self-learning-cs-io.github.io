

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="100:00:00,000 –&gt; 00:00:06,000Canneke-Melen University’s advanced database systems courses 200:00:06,000 –&gt; 00:00:09,000filming front of the live studio audience? 300:00:09,000 –&gt; 00:00:11,000">
<meta property="og:type" content="article">
<meta property="og:title" content="CMU15721 P12S202411 User DefinedFunctionOptimizationsCMUAdvancedDatabaseSystems">
<meta property="og:url" content="http://example.com/2025/10/25/CMU15721%20P12S202411-User-DefinedFunctionOptimizationsCMUAdvancedDatabaseSystems/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="100:00:00,000 –&gt; 00:00:06,000Canneke-Melen University’s advanced database systems courses 200:00:06,000 –&gt; 00:00:09,000filming front of the live studio audience? 300:00:09,000 –&gt; 00:00:11,000">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-25T05:03:39.747Z">
<meta property="article:modified_time" content="2025-10-25T05:03:39.747Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>CMU15721 P12S202411 User DefinedFunctionOptimizationsCMUAdvancedDatabaseSystems - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CMU15721 P12S202411 User DefinedFunctionOptimizationsCMUAdvancedDatabaseSystems"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-25 13:03" pubdate>
          2025年10月25日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          108 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">CMU15721 P12S202411 User DefinedFunctionOptimizationsCMUAdvancedDatabaseSystems</h1>
            
            
              <div class="markdown-body">
                
                <p>1<br>00:00:00,000 –&gt; 00:00:06,000<br>Canneke-Melen University’s advanced database systems courses</p>
<p>2<br>00:00:06,000 –&gt; 00:00:09,000<br>filming front of the live studio audience?</p>
<p>3<br>00:00:09,000 –&gt; 00:00:11,000<br>I don’t know why I don’t want that in the club.</p>
<p>4<br>00:00:11,000 –&gt; 00:00:13,000<br>I don’t want that in the club.</p>
<p>5<br>00:00:13,000 –&gt; 00:00:14,000<br>I don’t want that in the club.</p>
<p>6<br>00:00:14,000 –&gt; 00:00:15,000<br>Nobody knows.</p>
<p>7<br>00:00:15,000 –&gt; 00:00:16,000<br>Money is just there.</p>
<p>8<br>00:00:16,000 –&gt; 00:00:20,000<br>OK, so today’s class is a little bit different than what we talked about</p>
<p>9<br>00:00:20,000 –&gt; 00:00:23,000<br>throughout the semester because so far we’ve most been discussing about</p>
<p>10<br>00:00:23,000 –&gt; 00:00:25,000<br>OK, here’s the internals of a database system</p>
<p>11<br>00:00:25,000 –&gt; 00:00:31,000<br>at the lowest levels and how to make queries run faster.</p>
<p>12<br>00:00:31,000 –&gt; 00:00:37,000<br>And so today’s me a different topic where we’re going to be further up</p>
<p>13<br>00:00:37,000 –&gt; 00:00:39,000<br>the stack now in the system.</p>
<p>14<br>00:00:39,000 –&gt; 00:00:43,000<br>We’re going to do a bunch of tricks up in the, before we even get to the query optimizer,</p>
<p>15<br>00:00:43,000 –&gt; 00:00:47,000<br>when the SQL query shows up, and how to make a query runs faster,</p>
<p>16<br>00:00:47,000 –&gt; 00:00:50,000<br>given the architecture we design below.</p>
<p>17<br>00:00:50,000 –&gt; 00:00:53,000<br>And so this will then be from this point going into the semester,</p>
<p>18<br>00:00:53,000 –&gt; 00:00:56,000<br>like for this lecture, a next lecture will be about getting things in and out</p>
<p>19<br>00:00:56,000 –&gt; 00:00:58,000<br>of the database quickly.</p>
<p>20<br>00:00:58,000 –&gt; 00:01:01,000<br>And the next week will spend a lot more time on the query optimizer.</p>
<p>21<br>00:01:01,000 –&gt; 00:01:04,000<br>And I know I need to update, finally, post the papers we’re reading next week,</p>
<p>22<br>00:01:04,000 –&gt; 00:01:07,000<br>but I’ll take care of that today or tomorrow.</p>
<p>23<br>00:01:07,000 –&gt; 00:01:09,000<br>So this can remind her before the break.</p>
<p>24<br>00:01:09,000 –&gt; 00:01:12,000<br>We spent two lectures discussing join algorithms.</p>
<p>25<br>00:01:12,000 –&gt; 00:01:16,000<br>And we discussed how to do parallel hash joins because I said that’s what,</p>
<p>26<br>00:01:16,000 –&gt; 00:01:19,000<br>you know, every database system needs to do it with hash joins.</p>
<p>27<br>00:01:19,000 –&gt; 00:01:22,000<br>Right, if you’re relational, it’s pretty SQL, you need joins.</p>
<p>28<br>00:01:22,000 –&gt; 00:01:24,000<br>And hash joins always is going to be the fastest.</p>
<p>29<br>00:01:24,000 –&gt; 00:01:27,000<br>And then we spent a whole lecture talking about worst case optimal joins.</p>
<p>30<br>00:01:27,000 –&gt; 00:01:31,000<br>And although very, very few systems do this now,</p>
<p>31<br>00:01:31,000 –&gt; 00:01:35,000<br>this is something they’re all going to need to sport within the next decade,</p>
<p>32<br>00:01:35,000 –&gt; 00:01:40,000<br>as people start doing more graph-like things on their databases.</p>
<p>33<br>00:01:40,000 –&gt; 00:01:46,000<br>All right, so today’s lecture, again, we’re really focusing on how to embed more complicated things</p>
<p>34<br>00:01:46,000 –&gt; 00:01:50,000<br>inside of a database system to execute queries.</p>
<p>35<br>00:01:50,000 –&gt; 00:01:55,000<br>Now, loosely categorize these as embedded database logic.</p>
<p>36<br>00:01:55,000 –&gt; 00:02:01,000<br>And so we made the assumption that the scenario that we’re supporting in our conceptual database system</p>
<p>37<br>00:02:01,000 –&gt; 00:02:07,000<br>is that there is an application or some tool that the user is using.</p>
<p>38<br>00:02:07,000 –&gt; 00:02:10,000<br>And they’re interacting with the application,</p>
<p>39<br>00:02:10,000 –&gt; 00:02:13,000<br>they’re either typing all SQL queries in or they’re using a dashboard.</p>
<p>40<br>00:02:13,000 –&gt; 00:02:18,000<br>And then the application is sending over SQL queries that we then compute in their entirety</p>
<p>41<br>00:02:18,000 –&gt; 00:02:20,000<br>and then send back the result.</p>
<p>42<br>00:02:20,000 –&gt; 00:02:26,000<br>And so the scope of what that query, those queries, can execute or operate on,</p>
<p>43<br>00:02:26,000 –&gt; 00:02:33,000<br>the computation they can perform on our data is limited to whatever the database system itself actually supports.</p>
<p>44<br>00:02:33,000 –&gt; 00:02:37,000<br>And so in some cases, very common, especially in the Python Pandas world,</p>
<p>45<br>00:02:37,000 –&gt; 00:02:42,000<br>you’ll see people just do select star queries to get all the data out of the data system,</p>
<p>46<br>00:02:42,000 –&gt; 00:02:45,000<br>then bring it into your Jupyter Notebook or Pandas, whatever you want,</p>
<p>47<br>00:02:45,000 –&gt; 00:02:50,000<br>then do some additional computation on it and then push the result back to the database server.</p>
<p>48<br>00:02:50,000 –&gt; 00:02:54,000<br>And so if we can avoid that, some cases we can, some cases we cannot.</p>
<p>49<br>00:02:54,000 –&gt; 00:03:00,000<br>If we can avoid that, then obviously the database system will have a complete view of what you’re trying to do in your query on your data</p>
<p>50<br>00:03:00,000 –&gt; 00:03:05,000<br>and it can optimize accordingly, assuming you have some of the techniques that we’ll talk about today.</p>
<p>51<br>00:03:05,000 –&gt; 00:03:09,000<br>But it’s always going to be a better position to, you know,</p>
<p>52<br>00:03:09,000 –&gt; 00:03:14,000<br>it’s always better to operate on the data where it resides rather than then always having to bring it out to an external application.</p>
<p>53<br>00:03:15,000 –&gt; 00:03:18,000<br>So this is what we end up by embedding the database logic.</p>
<p>54<br>00:03:18,000 –&gt; 00:03:20,000<br>So the benefits are kind of obvious, right?</p>
<p>55<br>00:03:20,000 –&gt; 00:03:26,000<br>Fear network around trips, as I said, like if I can just do one query, have all the computation I need for whatever the result I’m looking for,</p>
<p>56<br>00:03:26,000 –&gt; 00:03:30,000<br>the met single query request, then that’s fantastic, rather than having to go back and forth.</p>
<p>57<br>00:03:31,000 –&gt; 00:03:38,000<br>Obviously, if now, if, you know, if I’m incorporating changes, this maybe not so much matters in the lake house world,</p>
<p>58<br>00:03:39,000 –&gt; 00:03:46,000<br>we’re talking about, but like rather than me having sort of a stale snapshot of my data that I’m processing locally,</p>
<p>59<br>00:03:46,000 –&gt; 00:03:52,000<br>if I’m going to push all my computation to the database server, then as new things arrive, new data arrives, then I’ll see those updates immediately.</p>
<p>60<br>00:03:53,000 –&gt; 00:04:00,000<br>And we’re not going to have transactions, but think, you know, if you, if you’re in a transaction word, if I call it begin, run a query,</p>
<p>61<br>00:04:00,000 –&gt; 00:04:04,000<br>get back result, do some processing on the application side, the database server is holding locks.</p>
<p>62<br>00:04:05,000 –&gt; 00:04:11,000<br>While I’m doing that computation, so if I can push all my computation to the database server, then I don’t have to go to those, go to those around trips.</p>
<p>63<br>00:04:11,000 –&gt; 00:04:22,000<br>This one is, is debatable whether like you, you’re not, you’re not allowed your developers to be, to not have to implement functionality by using a better database logic.</p>
<p>64<br>00:04:22,000 –&gt; 00:04:32,000<br>And I say it’s debatable because oftentimes in the, in sort of large corporations or enterprises, the people that write the application build that software,</p>
<p>65<br>00:04:33,000 –&gt; 00:04:41,000<br>aren’t the same people managing the database servers. So the application developers might be on one sort of engineering cycle, but the database, database developers are usually very conservative.</p>
<p>66<br>00:04:41,000 –&gt; 00:04:51,000<br>And you may say, hey, here’s my new, my new user defined function, UDF, or service teacher, but the DBA is like, well, I got a vet this, it’s going to take a couple weeks for this to actually happens.</p>
<p>67<br>00:04:51,000 –&gt; 00:04:56,000<br>So you end up having developers just re-evolving the same thing, just in different code bases.</p>
<p>68<br>00:04:57,000 –&gt; 00:05:06,000<br>We certainly saw that in the case of the, the Velox paper, right, they talked about how there’s 11 implementations of substring in all of Facebook.</p>
<p>69<br>00:05:06,000 –&gt; 00:05:14,000<br>And then this last one again, this is, this is a compass is all of this, but now we’re going to be able to extend the function out of the data system to go beyond what the built in capabilities is.</p>
<p>70<br>00:05:14,000 –&gt; 00:05:25,000<br>And this last one here is what the, one of the original motivations of user defined types, the user defined functions, that Stoenberger likes to talk about, like when he was building, when he built, they built ingress, they started giving,</p>
<p>71<br>00:05:25,000 –&gt; 00:05:35,000<br>trying to start selling it to a bunch of banks, but all the banks were computing interest for accounts on the Julling calendar, whereas, you know, the rest of the world is running the Gagorean calendar.</p>
<p>72<br>00:05:35,000 –&gt; 00:05:38,000<br>So in ingress at the time, they didn’t have a Julling date type.</p>
<p>73<br>00:05:38,000 –&gt; 00:05:42,000<br>So that meant the developers had to go modify the data system to add this new date type.</p>
<p>74<br>00:05:42,000 –&gt; 00:05:52,000<br>But if you can, all of them support, you define types, you define functions and other things, then the developers can extend the system without having to recompile the binary.</p>
<p>75<br>00:05:52,000 –&gt; 00:05:57,000<br>So the type on, there’s different categories of types of embedded database logic.</p>
<p>76<br>00:05:57,000 –&gt; 00:06:01,000<br>The most common two are going to be user defined functions and store procedures.</p>
<p>77<br>00:06:01,000 –&gt; 00:06:09,000<br>There are conceptually the same thing, like it’s a function of some kind of procedural code in, that you can run in your database server.</p>
<p>78<br>00:06:09,000 –&gt; 00:06:15,000<br>The, the difference is that in a sort of procedure, you don’t need to, you don’t, you can invoke it outside of a SQL query.</p>
<p>79<br>00:06:15,000 –&gt; 00:06:21,000<br>Like I can call execute and then the name of the function and I’ll just run it like an RPC call.</p>
<p>80<br>00:06:21,000 –&gt; 00:06:27,000<br>Whereas in the EDF, it has to be embedded inside of a, inside of a, you know, select statement or a SQL query.</p>
<p>81<br>00:06:27,000 –&gt; 00:06:33,000<br>In some systems like SQL server, they make the distinction that user defined functions cannot update tables.</p>
<p>82<br>00:06:33,000 –&gt; 00:06:35,000<br>Like you can’t call insert update delete in the EDF.</p>
<p>83<br>00:06:35,000 –&gt; 00:06:37,000<br>Periscuss doesn’t let you do that.</p>
<p>84<br>00:06:37,000 –&gt; 00:06:42,000<br>Whereas an instructor, a seizure and SQL server, you can only, that’s where you can call update queries.</p>
<p>85<br>00:06:42,000 –&gt; 00:06:49,000<br>Right, so again, a bunch of these should be mostly from very with, but the one we’re going to care about today is user defined functions.</p>
<p>86<br>00:06:49,000 –&gt; 00:06:58,000<br>And this survey comes from the, a follow up paper from the four paper you guys read, where they actually did a survey of real customer databases and Azure.</p>
<p>87<br>00:06:58,000 –&gt; 00:07:02,000<br>And it is, it is counted, you know, what, what a real EDF and store procedures look like.</p>
<p>88<br>00:07:02,000 –&gt; 00:07:07,000<br>And that’s where they came up with this pie chart like this.</p>
<p>89<br>00:07:07,000 –&gt; 00:07:11,000<br>All right, so user defined function, this can, this should be review for everyone here.</p>
<p>90<br>00:07:11,000 –&gt; 00:07:21,000<br>Your defined function is basically, it’s going to be a function that’s rewritten by the application developer that allows us to extend the functionality of the database system beyond its built in operations, built in functions.</p>
<p>91<br>00:07:21,000 –&gt; 00:07:30,000<br>Right, so the SQL standard specifies there’s a substring function and every system that, you know, most support SQL standard is going to have their own implementation of it.</p>
<p>92<br>00:07:30,000 –&gt; 00:07:43,000<br>But if I have some weird, weird wonky substring version that I want to use for whatever reason, right, it’s not realistic for me to assume that my database server is going to have that, but I can write it as a user defined function that have the exact capabilities that I want.</p>
<p>93<br>00:07:43,000 –&gt; 00:07:46,000<br>And then I can put my application technically anywhere.</p>
<p>94<br>00:07:46,000 –&gt; 00:07:53,000<br>A lot of times when you see people that have like migration services, well, like, I’m running an Oracle and I want to switch to Postgres.</p>
<p>95<br>00:07:53,000 –&gt; 00:08:05,000<br>I’m running a terror data when I switch to Postgres or something, they’ll take whatever the custom functions you’re using from the different prepared, prepared database servers and they’ll re implement them as user defined functions to ensure compatibility.</p>
<p>96<br>00:08:05,000 –&gt; 00:08:17,000<br>All right, so the function is pretty straightforward, right, you’re taking some input arguments, always as scalers, you can perform some kind of computation on it and then you can return result either as a scalar or a table.</p>
<p>97<br>00:08:17,000 –&gt; 00:08:30,000<br>For our purposes here, we’re going to assume that the UDFs are not pure functions, another neighbor, but basically you can’t, they’re not going to call it outside things.</p>
<p>98<br>00:08:30,000 –&gt; 00:08:34,000<br>In some database servers, you can actually make RPC calls to remote services.</p>
<p>99<br>00:08:34,000 –&gt; 00:08:42,000<br>To keep things simple today, we’re going to assume that everything is going to run inside of the function itself and doesn’t escape.</p>
<p>100<br>00:08:42,000 –&gt; 00:08:46,000<br>Although we can call one function can call other functions.</p>
<p>101<br>00:08:46,000 –&gt; 00:08:50,000<br>All right, so again, conceptually looks like this. This is our application.</p>
<p>102<br>00:08:50,000 –&gt; 00:08:59,000<br>We want to execute some SQL that has some kind of program logic, where conditional clauses, whatever, calling whatever libraries at once, execute more SQL and then some program logic and so forth.</p>
<p>103<br>00:08:59,000 –&gt; 00:09:08,000<br>So what would happen is that if we can take maybe these two portions here and then embed them as functions inside the database server,</p>
<p>104<br>00:09:08,000 –&gt; 00:09:13,000<br>then now we can rewrite our application just to invoke the queries and the functions like this.</p>
<p>105<br>00:09:13,000 –&gt; 00:09:22,000<br>Then now there isn’t this back and forth, where maybe pulling a bunch of data, processing it, and then passing it on the next query, so forth, I could keep everything always on the server side.</p>
<p>106<br>00:09:22,000 –&gt; 00:09:29,000<br>And obviously for some things, like if we call machine learning libraries, like PyTorch, this doesn’t quite make sense.</p>
<p>107<br>00:09:29,000 –&gt; 00:09:44,000<br>To express everything as a UDF in the native language of the database server, there are tools, there are extensions to Postgres and other systems where you can make calls into PyTorch.</p>
<p>108<br>00:09:44,000 –&gt; 00:09:50,000<br>They basically have UDF wrappers for that. Like I said, we’re going to ignore that for today.</p>
<p>109<br>00:09:50,000 –&gt; 00:09:58,000<br>So today we’re talking about the background of the challenges of the UDFs. Then we’ll talk about three techniques to optimize them.</p>
<p>110<br>00:09:58,000 –&gt; 00:10:09,000<br>The first one is going to be the inlining approach from Microsoft that you guys read. Then there’ll be a follow-up work from other sets of Germans to convert UDFs into common table expressions or CTEs with lateral joins.</p>
<p>111<br>00:10:09,000 –&gt; 00:10:16,000<br>And then we’ll finish off with bashing and some numbers about which systems can support these various techniques.</p>
<p>112<br>00:10:16,000 –&gt; 00:10:27,000<br>All right, so I’ve already said this. Use the function basically is going to be, you know, take some input, do some processing, compute the output.</p>
<p>113<br>00:10:27,000 –&gt; 00:10:41,000<br>But there’s, there’s broadly two categories of UDFs that we’re going to care about. The first of these SQL functions where the inside of the function is literally just going to be queries, one after another, separate by sending columns.</p>
<p>114<br>00:10:41,000 –&gt; 00:10:51,000<br>And then the output of whatever this, the function will be when you invoke it, whatever the output of the last query is. Right.</p>
<p>115<br>00:10:51,000 –&gt; 00:11:05,000<br>And so, here’s input arguments, you know, take integers. There is this return argument which defines which can return. So in this case, we’re going to return a, a, a, a, the two pulls from the table that have the same scheme as the table foo.</p>
<p>116<br>00:11:05,000 –&gt; 00:11:17,000<br>And then we have our computation, the function body down here. So for this example here, I can either invoke it in the, as a, as a query without a from clause or embedded inside the from clause stuff.</p>
<p>117<br>00:11:17,000 –&gt; 00:11:23,000<br>Or some of the cases I can put in the where clause, you can put these function calls calls anywhere.</p>
<p>118<br>00:11:23,000 –&gt; 00:11:44,000<br>So this is not that interesting from our perspective today because we can make more of this cheap. This is like a macro. So like in this, in this case here, you know, the calling get food inside the select query, I can, the Davies over literally would take all the SQL queries inside the function body and just embed it injected inside of this thing instead of an nested query.</p>
<p>119<br>00:11:45,000 –&gt; 00:12:05,000<br>Right. And then at that point, they optimize the nose nose nose when it’s operating on because it’s dealing with SQL queries. I can do whatever once. Now you see why SQL server doesn’t allow you to do update queries because I update queries inside of this thing that can certainly change the order which I actually thinks and if it’s a select query with updates inside of it, then things get weird.</p>
<p>120<br>00:12:06,000 –&gt; 00:12:18,000<br>The types of you that we’re going to care about today are going to be ones that are written in a external programming language. So the SQL standard specifies something called SQL PSM as persistence store modules.</p>
<p>121<br>00:12:18,000 –&gt; 00:12:21,000<br>And that goes back to like the night. Yes, question.</p>
<p>122<br>00:12:21,000 –&gt; 00:12:31,000<br>So, like, when updates are permitted in the sequential SQL bucket, yes, does the media must be forced like strict ordering on the answer to?</p>
<p>123<br>00:12:31,000 –&gt; 00:12:38,000<br>It’s question is whether the data system enforce strict ordering when you update queries. I think yes, like a literally blind leads copy it in. Yes.</p>
<p>124<br>00:12:39,000 –&gt; 00:12:46,000<br>I actually don’t know what postgres does you have updated in there? Well, they’ll just blindly copy it in. It’s almost like a view.</p>
<p>125<br>00:12:47,000 –&gt; 00:12:55,000<br>In that case, there’s rewrite it was on postgres. They literally drop it in but they have a big query. I don’t know what they do. But yeah, you wouldn’t keep the order incorrect.</p>
<p>126<br>00:12:55,000 –&gt; 00:13:06,000<br>All right. Again, so the SQL standard specifies the thing called SQL PSM. And as all cases in SQL, there’s a standard. But nobody exactly follows it. Everyone’s going to do slightly slightly different.</p>
<p>127<br>00:13:07,000 –&gt; 00:13:24,000<br>But at a high level, they’re all going to look the same. All these the built in or the standard programming language for UDS is going to look very similar to Ada because the story goes the guy that invented store or UDS to serve as teachers was really into Ada.</p>
<p>128<br>00:13:24,000 –&gt; 00:13:36,000<br>If you’ve never heard Ada, it’s like a modern variant at Pascal. Right. It’s an older language in the 70s or so. But that’s why you have the clear declarative variables in the beginning. It’s all very archaic.</p>
<p>129<br>00:13:36,000 –&gt; 00:13:47,000<br>But so the SQL standard specifies SQL PSM. All of course got their own PL SQL postgres has their their their own dialect of PL SQL called PL PG SQL.</p>
<p>130<br>00:13:47,000 –&gt; 00:13:57,000<br>It has some postgres idioms in there. DB2 has had their own UDF language. But now I think you can stall SQL PL modules that look like the Oracle one.</p>
<p>131<br>00:13:57,000 –&gt; 00:14:04,000<br>And then one more time. Most of the time talking about today is this thing called transact SQL from originally from Sybase.</p>
<p>132<br>00:14:04,000 –&gt; 00:14:16,000<br>Again, it’s going to look a lot like the SQL PL SQL or SQL PSM in the SQL standard. There’s those at signs are going to use everywhere to declare variables. Right. Where is the SQL PL SQL doesn’t have that.</p>
<p>133<br>00:14:16,000 –&gt; 00:14:28,000<br>So again, for more circle circle background, Sybase came first. Sybase was at 1980s. I think they were the first I think they were one of the first things to support UDS.</p>
<p>134<br>00:14:28,000 –&gt; 00:14:38,000<br>Ingress had UDTs in the 70s. But Sybase had had UDS. Microsoft bought a license to the source code of Sybase in the early 90s.</p>
<p>135<br>00:14:38,000 –&gt; 00:14:47,000<br>Deported to Windows NT to competing as IBM. And then since then they’ve they’ve had they forked the hard fork of the source code.</p>
<p>136<br>00:14:47,000 –&gt; 00:14:56,000<br>SQL Server has basically been rewritten. Sybase is still around. There’s still making a lot of money. But like no news chart. I’m going to use Sybase. It’s used a lot of the banks.</p>
<p>137<br>00:14:56,000 –&gt; 00:15:02,000<br>But for historical reasons because Sybase had transact SQL, that’s why SQL Server has transact SQL.</p>
<p>138<br>00:15:02,000 –&gt; 00:15:10,000<br>There’s other programming language you can get like in Postgres you can get like you can get tickle, you can get Python, you can get Pearl, you get PGS and any arbitrary language.</p>
<p>139<br>00:15:10,000 –&gt; 00:15:23,000<br>If you’re crazy you can get you can get you write UDS in C, which is a bad idea, right? Because if you’re operating the data system because now you’re linking in a shared object in C, which can touch anything in your dress space.</p>
<p>140<br>00:15:23,000 –&gt; 00:15:33,000<br>And for security reasons it’s a nightmare and obviously for stability reasons it’s a nightmare. So in some cases like in Oracle for example, you can write UDS in C.</p>
<p>141<br>00:15:33,000 –&gt; 00:15:44,000<br>But then again they transpile them to Postgres C, which is their dialect. And then they run you as a separate process. So if you crash you take down the UDF and not the whole system.</p>
<p>142<br>00:15:44,000 –&gt; 00:15:52,000<br>So this is an example here of what a PL SQL look like or sorry a UDF written in in this case here is transact SQL.</p>
<p>143<br>00:15:52,000 –&gt; 00:16:03,000<br>So this is a really simple UDF where we’re going to take a customer ID and a customer key. And then we’re going to discount the number orders that they pay for over the lifetime of being a customer.</p>
<p>144<br>00:16:03,000 –&gt; 00:16:10,000<br>And then depending whether they spend a certain amount of money they’ll get a platinum level or they’re like a regular customer.</p>
<p>145<br>00:16:11,000 –&gt; 00:16:27,000<br>And so in this case here we’re invoking the UDF inside of the projection output of the select statement. So you sort of think of this as like a for loop iterating every single customer and then they’re going to vote this customer level function by passing in that customer key.</p>
<p>146<br>00:16:27,000 –&gt; 00:16:39,000<br>And again in this because it’s based on Adal Pascal we declare our variables in the beginning and then the at sign tells us that it’s transact SQL.</p>
<p>147<br>00:16:39,000 –&gt; 00:16:54,000<br>So a lot of these already said right UDF so great because they’re going to allow us to to break up complex logic in our application into separate functions and potentially allow different parts of the code in our application be able to reuse that those capabilities.</p>
<p>148<br>00:16:54,000 –&gt; 00:17:04,000<br>Some scenarios also too some you see applications written in different languages like there’s the mobile app and then there’s the the the web server app.</p>
<p>149<br>00:17:04,000 –&gt; 00:17:16,000<br>In that case they’re usually always talking to a student application server but in some cases you can go directly to the server and now set up having to re implement logic in the different program languages and if they’re all UDFs and you can just reuse that.</p>
<p>150<br>00:17:16,000 –&gt; 00:17:31,000<br>We’ve already talked about reducing network round trips and then for some things where you just can be very helpful is that you’ll be easier to write some complex logic in UDS versus like SQL.</p>
<p>151<br>00:17:31,000 –&gt; 00:17:34,000<br>So data analysis stuff is very common with this.</p>
<p>152<br>00:17:34,000 –&gt; 00:17:50,000<br>All right so this all sounds great. Why aren’t UDS maybe more common then? Well the number one problem that we’re going to face is that the query optimizers if the UDF is written in an external programming language like PL SQL or PLBG SQL doesn’t know what’s inside of that function.</p>
<p>153<br>00:17:50,000 –&gt; 00:18:08,000<br>Again SQL is declarative so it’s the SQL query itself is specifying here’s the answer I want. Now the data system optimizer can reason about the expressions the operators within that query plan to make estimations on selectivities of these different computational steps in the query plan.</p>
<p>154<br>00:18:08,000 –&gt; 00:18:37,000<br>But now if I had this function that I’m calling in some language that isn’t SQL what is the cost of things right so if I have like my workles where value equals my UDF123 will say UDF123 this my UDF is written in C right even PL you know PL SQL do I know what the selectivity of what you know what whether we’ll pretend that I’m going to imagine this you don’t because you don’t know what’s inside of the function.</p>
<p>155<br>00:18:37,000 –&gt; 00:19:06,000<br>So that’s going to be the number one number one we’re going to face. The other challenges is going to be that we’re going to be hard for us to paralyze our UDS and take advantage of the vectorized query processing model or even running the query across multiple threads because again we don’t know what’s inside of the function right it may just be like we may is doing an implicit nested loop nested loop.</p>
<p>156<br>00:19:06,000 –&gt; 00:19:19,000<br>And that’s a nested loop join because the outer queries invoking the function once per tuple inside of that now I’m just doing another look up inside of that function to another table it’s basically doing a join.</p>
<p>157<br>00:19:19,000 –&gt; 00:19:32,000<br>And because there’s a separation between the SQL side and the UDS side the optimizer can’t have a holistic view of the entire query itself and you know do all the optimizations we knew how to do about switching the hash joins and so forth.</p>
<p>158<br>00:19:33,000 –&gt; 00:19:56,000<br>Well the things get really nasty but fortunately they’re not that common is that some UDS actually will construct a string inside of the UDS like they’re incrementally built up a select statement and then invoke it you’re allowed to do that in PL SQL being like declare string select like what’s the condition I’m adding a pending literary sequel to it and then I execute it.</p>
<p>159<br>00:19:56,000 –&gt; 00:20:04,000<br>In that case you have no idea what you possibly could possibly do it because you don’t know what the SQL query is going to be into actually run the function to your screw.</p>
<p>160<br>00:20:04,000 –&gt; 00:20:13,000<br>And for this one here no one’s going to solve this again we did a survey where we scraped GitHub and we try to see how common this was it’s less than 5% it’s not that common.</p>
<p>161<br>00:20:13,000 –&gt; 00:20:22,000<br>At least again that’s for a static evaluation of just looking at the UDS we don’t have numbers say how often they’re invoked but we don’t think they’re very common.</p>
<p>162<br>00:20:23,000 –&gt; 00:20:48,000<br>So the related to what I was saying before about this parallelization stuff so if you can’t figure out what’s inside the UDS and now you’re just going to be looping over the outer table or the calling SQL query and for every single two point inside the outer query you’re invoking the function you’re literally calling the UDS one at a time right for every single record.</p>
<p>163<br>00:20:48,000 –&gt; 00:20:53,000<br>So in the Microsoft world they call this row by agonizing row bar bar.</p>
<p>164<br>00:20:53,000 –&gt; 00:21:10,000<br>And as I said if you don’t inside of UDS you’re invoking other queries that you can’t see to actually run it then the atmosphere has no way to be able to say oh these are just a join let me let me combine these together or I’m executing the same query over again let me cash it and leave it over you.</p>
<p>165<br>00:21:11,000 –&gt; 00:21:38,000<br>Right so the so this is sort of been well known for a while that UDS are bad all right they’re going to make your queries on slower so there’s this sort of semi-famous blog article from 2006 where they’re very very blunt and say T SQL that’s transact SQL scale of functions are evil in SQL server and they give a bunch of examples that site a bunch of the problems that I just talked about right.</p>
<p>166<br>00:21:38,000 –&gt; 00:21:49,000<br>So here’s one query that takes you know 2,000 2,600 milliseconds so that’s 2.6 seconds but then if you add the UDS it goes to 38 seconds right just by adding a UDS.</p>
<p>167<br>00:21:49,000 –&gt; 00:21:59,000<br>So so they the sort of the developers and DBAs of SQL server and other other systems right this is not just a SQL server problem the all every system has this problem.</p>
<p>168<br>00:21:59,000 –&gt; 00:22:17,000<br>You know this is sort of a month for a while and then Microsoft actually just came out and said it themselves in 2008 so few years after this one so this is an updated article where they introduced a new way to do compiled UDS but in here they basically use the term like oh yeah R bar the row by exiting row that’s going to make your queries go slow.</p>
<p>169<br>00:22:17,000 –&gt; 00:22:29,000<br>So I think SQL and carnit or something or evil incarnate like evil personified they’re very blunt so Microsoft is trying to solve this problem for a while.</p>
<p>170<br>00:22:29,000 –&gt; 00:22:44,000<br>So again this is like what I’m telling you is not like any big secret people have known this for a long time and like UDS are so important and make developers lives like easier than we want to figure out a way to try to optimize them.</p>
<p>171<br>00:22:45,000 –&gt; 00:23:13,000<br>So here’s another example from Microsoft this is from the the fluid paper this is from TPCH query 12 and they basically took the where clause that is just checking to see the customer key is null or and they just they made a UDF that just does a look up on the customer table and to see whether returns back a valid customer key right so this is like contrived example because you’re taking the original TPCH query that didn’t have this UDF and you’re adding this one piece here.</p>
<p>172<br>00:23:14,000 –&gt; 00:23:27,000<br>And so without this UDF the query is going to take 0.8 seconds so 800 milliseconds but if you add in just this UDF which is really not doing that much then it goes to 13 hours.</p>
<p>173<br>00:23:28,000 –&gt; 00:23:56,000<br>Right because again the database server doesn’t know that for this I’m working as function and I’m just checking to see what the output is null what’s the customer key right I’m doing look on the customer table here no it’s the customer key from the order table it’s not going to be null right but because it doesn’t know what the computation is inside of this thing the optimizer just gives his hands you know throws up his hands says okay well I probably need to I’m just going to execute this for every single row.</p>
<p>174<br>00:23:56,000 –&gt; 00:24:19,000<br>And then now you get the overhead of you know that’s pretty significant. So we’ll see Freud in a second Freud is going to be able to take this in line and back into this function and get this query back down to 900 milliseconds so not exactly as it was without the you know without introducing the not exactly what it was before you added this piece here but certainly not the 13 hours that they’re getting before yes.</p>
<p>175<br>00:24:26,000 –&gt; 00:24:44,000<br>Yes same as this example here is a SQL DF but I don’t think that this example here I don’t think because I’m declaring variables and I’m a return clause this is not considered a SQL UDF a SQL UDF you don’t have variables returns it’s just the SQL queries in by themselves.</p>
<p>176<br>00:24:45,000 –&gt; 00:24:58,000<br>So in that case yes if I got rid of the declare got rid of their term just got rid of this assignment to the variable and if it was just this then that would get in line and the optimizer could figure that out.</p>
<p>177<br>00:24:59,000 –&gt; 00:25:25,000<br>Okay so how are we not going to optimize this well there’s basically there’s four basic approaches compilation we’ve talked about before right we can just take our interpreted you know take our UDF we normally interpret it we could compile it into native code and that’ll run faster doesn’t solve our optimizer problem because now we have all the function now compiled is me much faster it’s you know it’s it’s still going to be a black box to the query optimizer.</p>
<p>178<br>00:25:26,000 –&gt; 00:25:31,000<br>I said Oracle does this and SQL server already does this now I mean it did it since 2016.</p>
<p>179<br>00:25:32,000 –&gt; 00:25:45,000<br>Another approach is to extend the the probing language for the UDF to introduce pragmas or directives or other hints to the database server that could tell it what portions the query could be optimized.</p>
<p>180<br>00:25:46,000 –&gt; 00:26:06,000<br>So SQL store or sorry SQL single store has has their own variant of the PL SQL called came out when they were called mems equals was called MPL mems SQL programming language but they have a parallel version where you can write UDFs and you can use them and that’s additionally hints to the optimizer figure how to parallel stuff.</p>
<p>181<br>00:26:06,000 –&gt; 00:26:10,000<br>But again as far as I know for that programming language the optimizer still sees a black box with the UDF.</p>
<p>182<br>00:26:12,000 –&gt; 00:26:27,000<br>Inlining the person that we’re going to talk about today is how to convert the UDF into some kind of declarative form that is that we can natively embed into our query plan as if it was just much SQL queries and then let the optimizer optimize that accordingly.</p>
<p>183<br>00:26:28,000 –&gt; 00:26:45,000<br>And then the last one is a is actually predates inlining but it was rediscovered by us and other Germans a few years ago you basically take the UDF and you convert it into a bunch of SQL queries that run in batch or multiple tools at a time.</p>
<p>184<br>00:26:46,000 –&gt; 00:26:54,000<br>And then now you don’t have the invocation cost of invoking this single function and you’re sort of operating things all together again I’ll show examples of that as we go along.</p>
<p>185<br>00:26:54,000 –&gt; 00:27:01,000<br>So today’s class we’re going to focus on these two because again this is quite different than everything we’ve talked about so far.</p>
<p>186<br>00:27:02,000 –&gt; 00:27:03,000<br>Okay.</p>
<p>187<br>00:27:04,000 –&gt; 00:27:12,000<br>So you definitely inlining again the idea here from Freud again we’ll use the term Freud described because that’s what it’s called in the paper.</p>
<p>188<br>00:27:12,000 –&gt; 00:27:20,000<br>I think in the obviously in the when you pay for SQL server down the SQL server it’s not called Freud if you look for Freud in the documentation you’re not going to see it.</p>
<p>189<br>00:27:20,000 –&gt; 00:27:27,000<br>I think they call it the UDF inlining but again the research name of the project was Freud.</p>
<p>190<br>00:27:27,000 –&gt; 00:27:41,000<br>So the idea is that we’re going to take our UDS and we’re going to convert them to relational algebra expressions that we can then inline into the SQL queries themselves and we’re going to do this before we get to the actually cost based search for the joins or in other parts of the query optimizer.</p>
<p>191<br>00:27:41,000 –&gt; 00:27:58,000<br>So you can think of the static transformation rules that we can do this conversion transformation of the UDF into relational algebra without needing a cost model because we’ll just let the query optimizer handle as if it was any other query.</p>
<p>192<br>00:27:59,000 –&gt; 00:28:10,000<br>So as I said we’re going to do this before we get to the cost based optimizer because our cost based optimizer in theory in theory level cover this later.</p>
<p>193<br>00:28:10,000 –&gt; 00:28:17,000<br>So you should be able to handle the sub queries effectively. SQL server is not going to be able to do that.</p>
<p>194<br>00:28:17,000 –&gt; 00:28:28,000<br>The hyper umbra germans can do this. Dr. B can do this because we did a forum. We’ll cover that in a second.</p>
<p>195<br>00:28:28,000 –&gt; 00:28:35,000<br>Let’s talk about these other queries again. I’m not going to say how to do it exactly the German way to do it.</p>
<p>196<br>00:28:35,000 –&gt; 00:28:55,000<br>But this is going to be the challenge. This is what the inlining approaches are going to leverage because they’re going to assume that the optimizer will be able to take care of these these these that’s the sub queries and then we’re going to introduce lateral joins because that’s how we’re going to change these things together to ensure that things execute in order that need to execute in UDF.</p>
<p>197<br>00:28:55,000 –&gt; 00:29:08,000<br>But again things will fall apart if it gets too complicated. So again sub queries basic idea this is just a refresher from the interclass that we just have a nested query like a select query inside of that there’s another select query.</p>
<p>198<br>00:29:08,000 –&gt; 00:29:15,000<br>It can be anywhere. It can be the projection output can be the from clause, me the where clause can be having like group by anywhere you want.</p>
<p>199<br>00:29:16,000 –&gt; 00:29:40,000<br>And so the two ways to handle them is to rewrite the query to decorate a flatten them to joins. And this will be the best case scenario. This is what you always want to do, but not not everyone can or you just pull out the nested query. Run it once, put its results to a temp table and then join that temp table against the the calling table or the calling query.</p>
<p>200<br>00:29:41,000 –&gt; 00:29:56,000<br>And some systems do this. I think if I have my where clause I have something that wants to aggregate like the max value of a column. I can run that once we sterilize that as a the temp table and then just join against it later on.</p>
<p>201<br>00:29:56,000 –&gt; 00:30:08,000<br>And people you have to do this when you don’t we can’t support DAGs in your query plan. Again we’ll cover how to do this all more thoroughly next week in the and we’ll talk with crew opposition for the Germans.</p>
<p>202<br>00:30:08,000 –&gt; 00:30:18,000<br>Question sorry. All right, so rewriting is a table before we take this guy. This is some query and we have inside of our where clause we have nested query.</p>
<p>203<br>00:30:18,000 –&gt; 00:30:27,000<br>And then we can pull this out and basically do a join and we see that we’re doing a join on the order table with the user table.</p>
<p>204<br>00:30:27,000 –&gt; 00:30:37,000<br>And this guy this person here we would recognize that there’s a we know the relationship between the order table and the user table and we realize, oh, we don’t even need to access the user table because everything we need is in the order table itself.</p>
<p>205<br>00:30:37,000 –&gt; 00:30:47,000<br>So in this case here is the best case scenario that we went from a nested query. Instead of having to invoke this nested query for every single row, every single record on the order table, we can just remove the accessing the order table entirely.</p>
<p>206<br>00:30:47,000 –&gt; 00:30:52,000<br>So the user table entirely. And that’ll be a big win.</p>
<p>207<br>00:30:53,000 –&gt; 00:31:00,000<br>All right, so the other thing we’re going to rely on in addition to nest queries is through lateral joins. I think we covered that also in interclass as well. I think the first homework required it.</p>
<p>208<br>00:31:00,000 –&gt; 00:31:17,000<br>And the idea here a lateral joint is that it’s going to allow a sub query in our from clause to reference a values or attributes in other nested queries at the same sort of nesting level.</p>
<p>209<br>00:31:18,000 –&gt; 00:31:29,000<br>Again, you can’t do this in joins, right? Typically if you have a sub query join a sub query, those two sub queries can’t can’t peek into each each other and see what they’re actually what they have.</p>
<p>210<br>00:31:29,000 –&gt; 00:31:36,000<br>A lateral joint allows you to do that. And this is how going to be able to guarantee that again will execute the queries in the order that they’re specified in the EDF.</p>
<p>211<br>00:31:37,000 –&gt; 00:31:46,000<br>So this thing of that is like a much like sort of sort of for loops where for each each clause in the lateral join, I’m iterating over every single tuple.</p>
<p>212<br>00:31:46,000 –&gt; 00:31:54,000<br>And if necessary, I can then invoke and look to lookups on the the previous join or the previous table.</p>
<p>213<br>00:31:54,000 –&gt; 00:32:00,000<br>So look at example like this. So here I’m just fine that I have an inner inner join with a lateral.</p>
<p>214<br>00:32:01,000 –&gt; 00:32:08,000<br>And then inside of this nested query here, you can see that I’m allowed to reference the the select query up here.</p>
<p>215<br>00:32:08,000 –&gt; 00:32:14,000<br>I can reference like the the order user ID and other things up up in here.</p>
<p>216<br>00:32:14,000 –&gt; 00:32:20,000<br>Right? So this reference here, oh, I U.S.D. is this one up here and this first order is this one up there.</p>
<p>217<br>00:32:21,000 –&gt; 00:32:29,000<br>And again, the query optimizer just knows that okay, the binder needs to figure out, okay, I’m referencing these things here.</p>
<p>218<br>00:32:29,000 –&gt; 00:32:34,000<br>And a lateral joint allows me to get a peak up to the one above me and be able to see what they have.</p>
<p>219<br>00:32:34,000 –&gt; 00:32:40,000<br>This example is a bit abstract when we walk through the UDF, I think it’ll make more sense.</p>
<p>220<br>00:32:40,000 –&gt; 00:32:43,000<br>All right, let’s go through the five steps of fluid.</p>
<p>221<br>00:32:44,000 –&gt; 00:32:51,000<br>So the very first thing we did do is take our UDF and we’re going to transform the T-seq statements or PLC statements, whatever is written in into SQL queries.</p>
<p>222<br>00:32:51,000 –&gt; 00:33:02,000<br>And for everything that’s in the SQL standard, some exceptions are like you can’t use exceptions, you can’t use other constructs.</p>
<p>223<br>00:33:02,000 –&gt; 00:33:10,000<br>In case of Freud, they’re not able to have how wild loops or conditional loops, but if calls and other things, you’ve been convert all those things into the corresponding SQL queries.</p>
<p>224<br>00:33:11,000 –&gt; 00:33:14,000<br>Then we’re going to break our UDF up into regions.</p>
<p>225<br>00:33:14,000 –&gt; 00:33:19,000<br>It allows a reason about their contents and understand the dependencies between those regions.</p>
<p>226<br>00:33:19,000 –&gt; 00:33:23,000<br>Because their dependencies are then going to express through these lateral joints.</p>
<p>227<br>00:33:23,000 –&gt; 00:33:37,000<br>Then we’re going to go and merge the expressions based on trying to combine the multiple expressions within one region and then we’re going to link them together with lateral joints.</p>
<p>228<br>00:33:38,000 –&gt; 00:33:51,000<br>And then we take our UDF that we put together through lateral joints, or take our SQL query that we generated with all the lateral joints, and then embed that now to the calling query, the thing that was invoking the UDF, so we’re doing it at runtime.</p>
<p>229<br>00:33:51,000 –&gt; 00:33:54,000<br>And then we run this now through our query optimizer.</p>
<p>230<br>00:33:54,000 –&gt; 00:34:02,000<br>So in all my examples here, I’m going to show it through SQL statements, or like the conversions will be from the UDF statements into SQL.</p>
<p>231<br>00:34:03,000 –&gt; 00:34:08,000<br>As I said, in Freud, there are going to be based on relational algebra, but the upflow approach will see afterwards.</p>
<p>232<br>00:34:08,000 –&gt; 00:34:11,000<br>They’re going to do everything at the SQL level.</p>
<p>233<br>00:34:13,000 –&gt; 00:34:24,000<br>So this is that example we have in the beginning where given some custom ID, we’re going to look up and say, how much money they spent with us and then what customer status are we going to give them.</p>
<p>234<br>00:34:24,000 –&gt; 00:34:34,000<br>So again, the first step is we’re just trying to transform the contents of the UDF, the literally the lines of code with semicolons into corresponding SQL queries.</p>
<p>235<br>00:34:34,000 –&gt; 00:34:39,000<br>So in the case, the first case here, we’re declaring a variable called level, and we’ll set it the value to regular.</p>
<p>236<br>00:34:39,000 –&gt; 00:34:49,000<br>Well, that’s just a select query without a from clause where we pass the constant string regular and assign it to an attribute called level.</p>
<p>237<br>00:34:50,000 –&gt; 00:34:52,000<br>Nothing special there.</p>
<p>238<br>00:34:52,000 –&gt; 00:35:03,000<br>In this case here, the next query, we’re taking, we’re taking the, the, the aggregation on the order table and we’ll assign it to the, to the, the total variable.</p>
<p>239<br>00:35:03,000 –&gt; 00:35:12,000<br>That’s the same thing as just taking the nested, the query in here, just nest again inside of a select query, and then just assigning the, re naming the output to be total.</p>
<p>240<br>00:35:12,000 –&gt; 00:35:17,000<br>Then that assigns it to the variable total.</p>
<p>241<br>00:35:17,000 –&gt; 00:35:22,000<br>And the last one here, SQL itself does not have if clauses, it has case wins.</p>
<p>242<br>00:35:22,000 –&gt; 00:35:27,000<br>I think my SQL might break that, my SQL might have if statements, but case wins in the SQL standard.</p>
<p>243<br>00:35:27,000 –&gt; 00:35:34,000<br>So I can convert this if clause into a case when, you know, in total is greater than million, then to get platinum.</p>
<p>244<br>00:35:34,000 –&gt; 00:35:41,000<br>Otherwise, we set the, the output to null, and again, then we assign that to the level variable.</p>
<p>245<br>00:35:41,000 –&gt; 00:35:42,000<br>Yes.</p>
<p>246<br>00:35:43,000 –&gt; 00:35:49,000<br>It’s question should be lateral doing all these. Yes, we’re not there yet. Two more steps.</p>
<p>247<br>00:35:49,000 –&gt; 00:36:00,000<br>Right. So this part seems pretty simple, right? Like I can, I can, I can conceptually see how I can map things like, oh, a variable name of that’s just an attribute name in my projection output, my select, select statement.</p>
<p>248<br>00:36:00,000 –&gt; 00:36:08,000<br>So in this example here, it’s, it’s basically one to one mapping between like a statement in the UDF to a SQL query.</p>
<p>249<br>00:36:08,000 –&gt; 00:36:20,000<br>It doesn’t have to be that way. It can be multiple statements could get combined into a single SQL query, or you could have one SQL statement, sorry, one UDF statement, get, you know, split out across multiple SQL queries.</p>
<p>250<br>00:36:20,000 –&gt; 00:36:26,000<br>For our purposes here to keep it simple, it’s, we’re just assuming one to one.</p>
<p>251<br>00:36:26,000 –&gt; 00:36:46,000<br>All right. So next thing is now we want to take this UDF and break it up into regions, right? And then for each region, we’re going to do the transformation I just showed where we’re converting the statement inside the, the statements inside of that UDF, or that the statements inside that portion of the UDF region into corresponding SQL queries.</p>
<p>252<br>00:36:46,000 –&gt; 00:36:56,000<br>So in this case here, I declare two variables total and, and level, and then I have this necessary query here where I signed the output of the aggregation to the total variable.</p>
<p>253<br>00:36:56,000 –&gt; 00:37:12,000<br>Well, that’s the same thing as in my, I joined a SQL query where first I, I assigned level, the level variable to null, and then I have this, this, this necessary here where I’m going to compute the aggregation, and then I signed that to total.</p>
<p>254<br>00:37:12,000 –&gt; 00:37:20,000<br>And then now for this region, I’m going to assign the output of this nested portion of the query to this temp table called ER1, right?</p>
<p>255<br>00:37:20,000 –&gt; 00:37:29,000<br>It’s an ephemeral temp table in theory should, should reside entirely in memory, right? It’s not persistent catalog. It disappears once the query is over.</p>
<p>256<br>00:37:29,000 –&gt; 00:37:34,000<br>So I can assign it into this. It’s like a table A L this in a query.</p>
<p>257<br>00:37:34,000 –&gt; 00:37:48,000<br>Do the same thing with this next, the next region here, right? Convert this into this case when statement, and then do the same thing and then sign the output into, into this temp table ER2.</p>
<p>258<br>00:37:48,000 –&gt; 00:37:59,000<br>But notice here now that my, I had this variable total that I’m now referencing in, in the region above me, right?</p>
<p>259<br>00:38:00,000 –&gt; 00:38:06,000<br>So that’s where the, this is where the lateral join is going to help us because I have basically now two, two, two nested queries, two, two separate queries here.</p>
<p>260<br>00:38:06,000 –&gt; 00:38:14,000<br>But one of them needs to reference the other one has a dependency going up. So the lateral joins is how we’re going to connect them together.</p>
<p>261<br>00:38:14,000 –&gt; 00:38:28,000<br>Same thing, same thing for level here. And then I have this, this next piece here, again, the, the else clause, and it’s just the inverse of that where, where, if the total is less than a million, less than equal to million, than I, than my status is regular.</p>
<p>262<br>00:38:28,000 –&gt; 00:38:38,000<br>Right? Same thing, total can reference the one up there, and then level, this level here is actually referencing what was passed before us, in that one.</p>
<p>263<br>00:38:39,000 –&gt; 00:38:49,000<br>Are we done at this point? What’s the last one? Return, exactly, yes. So how are we going to handle that?</p>
<p>264<br>00:38:50,000 –&gt; 00:38:51,000<br>Well, what’s that?</p>
<p>265<br>00:38:51,000 –&gt; 00:39:00,000<br>Finger, he’s a slick level, yes. It’s just another slick, another nested query. So we can take all these now regions, we can turn to SQL statements, and we put them all together into one giant SQL query now.</p>
<p>266<br>00:39:00,000 –&gt; 00:39:12,000<br>Right? And so, yes, I know I just talked about lateral joins in the SQL standard, in the SQL standard, it’s not lateral join, the SQL standard is apply or cross apply, SQL server uses cross apply,</p>
<p>267<br>00:39:12,000 –&gt; 00:39:34,000<br>and SQL light and Oracle, they all use lateral join, they’re basically the same thing. Right? So, as she said, like, the last step was to do the, the return clause, but again, that’s just a return, sorry, that’s just the output of the select statement above that wraps all this together.</p>
<p>268<br>00:39:35,000 –&gt; 00:39:44,000<br>And again, in this case here, at the very top, I’m referencing ER3, and that’s generated down here for this nested query here, and they’re linked together through the lateral joints.</p>
<p>269<br>00:39:48,000 –&gt; 00:39:49,000<br>Yes.</p>
<p>270<br>00:39:49,000 –&gt; 00:39:51,000<br>Why is the else block a different region?</p>
<p>271<br>00:39:51,000 –&gt; 00:39:57,000<br>This question is, why is the else block a different region, because I think basically I suppose goes like, in theory, it should just be this, right?</p>
<p>272<br>00:39:58,000 –&gt; 00:40:06,000<br>Because in this, they’re trying to be pedantic in this example, like showing you the different regions, but also too, you could have going back to the original UDF, right?</p>
<p>273<br>00:40:06,000 –&gt; 00:40:15,000<br>You could have arbitrary things inside of this, right? That you could then not, you couldn’t be able to express through a, through the case one exactly.</p>
<p>274<br>00:40:15,000 –&gt; 00:40:25,000<br>But yes, in that, in this case here, I think there’s being overly rebose, because they’re also, they’re going to say later on, once I get it to this form, to my query optimizer,</p>
<p>275<br>00:40:26,000 –&gt; 00:40:38,000<br>the query optimizer can figure out, oh, this is referencing this, and here’s this case statement, and here’s this case statement, well, they’re just, you know, they’re disjoint regions, I could just merge these together.</p>
<p>276<br>00:40:38,000 –&gt; 00:40:42,000<br>Because the optimizer already knows how to do that for where it causes anyway.</p>
<p>277<br>00:40:42,000 –&gt; 00:40:45,000<br>But they just sent it like this.</p>
<p>278<br>00:40:45,000 –&gt; 00:40:48,000<br>Other questions?</p>
<p>279<br>00:40:49,000 –&gt; 00:40:58,000<br>I have you guys read this paper, we’ll see the, the app felt paper in a second. This one I feel like I can understand, right? Because it’s transforming SQL, that’s all fine and any.</p>
<p>280<br>00:40:58,000 –&gt; 00:41:09,000<br>The, the alpha one is being, we’re complicated because this is basically converted to IR, IR that’s used in compilers, and that, and PL stuff, which is not my area.</p>
<p>281<br>00:41:10,000 –&gt; 00:41:32,000<br>Okay, so now we want to actually inline the expression, so this is the original calling query, they call this UDF, right? So when, when this thing shows up, we then just wrap this, this customer level invocation, that just basically gets replaced with the entire, you know, this entire block here, which is the, the converter form of the UDF, yes.</p>
<p>282<br>00:41:33,000 –&gt; 00:41:46,000<br>I don’t know why you would ever do this, but it goes to the previous example and in the hit condition, right? If you actually go to the DC pool, right? So instead of having that else that, I should say we remove the ads, we say we always set levels right.</p>
<p>283<br>00:41:46,000 –&gt; 00:42:00,000<br>Of course, you would never do that in terms of, as long as people do stupid things. So yeah, so how would that work? Because you would not know which levels you’re up to, right? Because there’s a year to level and there’s a year, three levels.</p>
<p>284<br>00:42:01,000 –&gt; 00:42:06,000<br>So you’re saying, so if I give it this, this else calls, and it’s just, yes.</p>
<p>285<br>00:42:09,000 –&gt; 00:42:15,000<br>Yes. Then you said, yes. And then you set it to level, equal regular, always.</p>
<p>286<br>00:42:15,000 –&gt; 00:42:24,000<br>No, no, so in that, oh, so you should be given to the else and just had this be without it. And so it’s a no matter what, you just overwrite it.</p>
<p>287<br>00:42:30,000 –&gt; 00:42:47,000<br>So it would be this. It would just take set level equals regular and I would generate this regular as level. So then now in here, from my third region here, I would have that select regular as level and then as ER3.</p>
<p>288<br>00:42:48,000 –&gt; 00:42:51,000<br>So no matter what happens here, then it just gets overwritten.</p>
<p>289<br>00:42:52,000 –&gt; 00:42:59,000<br>The question is the compiler, sorry, is the query out the most smart enough to figure out? Oh, this, this thing, whatever happens here, gets overwritten by this.</p>
<p>290<br>00:43:00,000 –&gt; 00:43:02,000<br>We have to open circles or run two down.</p>
<p>291<br>00:43:07,000 –&gt; 00:43:14,000<br>But it’s still not to use ER2 level of this. It needs to be.</p>
<p>292<br>00:43:15,000 –&gt; 00:43:23,000<br>No, no, it literally will be select regular, select constant regular as level as ER3, ER3.</p>
<p>293<br>00:43:23,000 –&gt; 00:43:28,000<br>No, no, no. So in the else, in that log, exactly where the query goes.</p>
<p>294<br>00:43:28,000 –&gt; 00:43:39,000<br>No, this case when goes away, if you, if your example, it’s just set set level as regular, this goes away. It’s it’s this. It’s this query up here.</p>
<p>295<br>00:43:40,000 –&gt; 00:43:41,000<br>Select regular as level.</p>
<p>296<br>00:43:42,000 –&gt; 00:43:44,000<br>Then just overwrite it.</p>
<p>297<br>00:43:44,000 –&gt; 00:43:49,000<br>And then going forward, when I put it all together here,</p>
<p>298<br>00:43:49,000 –&gt; 00:43:53,000<br>then as I do my select ER3 level,</p>
<p>299<br>00:43:53,000 –&gt; 00:43:55,000<br>well, that’s just whatever came out of this one.</p>
<p>300<br>00:44:01,000 –&gt; 00:44:04,000<br>OK.</p>
<p>301<br>00:44:04,000 –&gt; 00:44:06,000<br>So now, if you do this with the query app,</p>
<p>302<br>00:44:06,000 –&gt; 00:44:08,000<br>you need to see what they were.</p>
<p>303<br>00:44:08,000 –&gt; 00:44:11,000<br>What you end up with is all this cross-supplies,</p>
<p>304<br>00:44:11,000 –&gt; 00:44:17,000<br>get turned out and simplified into just a left-out or join</p>
<p>305<br>00:44:17,000 –&gt; 00:44:21,000<br>against the order table.</p>
<p>306<br>00:44:21,000 –&gt; 00:44:26,000<br>So you’re looping every single customer record,</p>
<p>307<br>00:44:26,000 –&gt; 00:44:30,000<br>and then you do a left-out or join to compute the maximum number</p>
<p>308<br>00:44:30,000 –&gt; 00:44:34,000<br>of the total amount of items that they bought.</p>
<p>309<br>00:44:34,000 –&gt; 00:44:36,000<br>If they don’t have them bought anything,</p>
<p>310<br>00:44:36,000 –&gt; 00:44:38,000<br>you get null, that’s fine.</p>
<p>311<br>00:44:38,000 –&gt; 00:44:42,000<br>Otherwise, you didn’t compute what the true output is.</p>
<p>312<br>00:44:45,000 –&gt; 00:44:48,000<br>Pretty cool.</p>
<p>313<br>00:44:48,000 –&gt; 00:44:51,000<br>Again, I’ll say this next week, for most things,</p>
<p>314<br>00:44:51,000 –&gt; 00:44:56,000<br>SQL Server will have the best query app miser in the world.</p>
<p>315<br>00:44:56,000 –&gt; 00:44:59,000<br>Not for some things, right?</p>
<p>316<br>00:44:59,000 –&gt; 00:45:03,000<br>For joins, for nest queries, the umbral hyper ones will be better,</p>
<p>317<br>00:45:03,000 –&gt; 00:45:06,000<br>and Dr. B is getting there.</p>
<p>318<br>00:45:06,000 –&gt; 00:45:10,000<br>I’ll give a preview of what we’ll talk about next week</p>
<p>319<br>00:45:10,000 –&gt; 00:45:12,000<br>at the end of this class today.</p>
<p>320<br>00:45:12,000 –&gt; 00:45:15,000<br>So in this case here now, what do we have?</p>
<p>321<br>00:45:15,000 –&gt; 00:45:20,000<br>There was an implicit join in our UDF</p>
<p>322<br>00:45:20,000 –&gt; 00:45:24,000<br>that because we converted it into this cross-supply,</p>
<p>323<br>00:45:24,000 –&gt; 00:45:29,000<br>this lateral join contraption here,</p>
<p>324<br>00:45:29,000 –&gt; 00:45:31,000<br>that the query app miser was able to figure out,</p>
<p>325<br>00:45:31,000 –&gt; 00:45:35,000<br>oh, it’s actually, it is a join against the order table,</p>
<p>326<br>00:45:35,000 –&gt; 00:45:37,000<br>between the orders and customer table.</p>
<p>327<br>00:45:37,000 –&gt; 00:45:39,000<br>And in particular, it’s a left-outer join,</p>
<p>328<br>00:45:39,000 –&gt; 00:45:42,000<br>because I may not always have an order record for a customer.</p>
<p>329<br>00:45:42,000 –&gt; 00:45:46,000<br>And so now I can just inline or do a join,</p>
<p>330<br>00:45:46,000 –&gt; 00:45:48,000<br>as I normally would, do the hash join really quickly,</p>
<p>331<br>00:45:48,000 –&gt; 00:45:50,000<br>but we know how to do.</p>
<p>332<br>00:45:50,000 –&gt; 00:45:53,000<br>All of the operations that were previously a black box inside</p>
<p>333<br>00:45:53,000 –&gt; 00:45:56,000<br>of our UDF are now embedded as SQL,</p>
<p>334<br>00:45:56,000 –&gt; 00:45:58,000<br>and the query optimizer can use all the statistics</p>
<p>335<br>00:45:58,000 –&gt; 00:46:00,000<br>and other information that it has to be able to reason</p>
<p>336<br>00:46:00,000 –&gt; 00:46:03,000<br>about the selectivity estimates for our query.</p>
<p>337<br>00:46:03,000 –&gt; 00:46:07,000<br>It’s paralysable now, because we know there’s no weird dependencies</p>
<p>338<br>00:46:07,000 –&gt; 00:46:12,000<br>between invoking this query from one record to the next.</p>
<p>339<br>00:46:12,000 –&gt; 00:46:16,000<br>So all my threads can be running this in parallel at the same time.</p>
<p>340<br>00:46:16,000 –&gt; 00:46:20,000<br>There’s no function call overhead of setting up the call stack</p>
<p>341<br>00:46:20,000 –&gt; 00:46:23,000<br>to go into some function for every single record.</p>
<p>342<br>00:46:23,000 –&gt; 00:46:26,000<br>Furthermore, though, they claim that in the Freud paper,</p>
<p>343<br>00:46:26,000 –&gt; 00:46:28,000<br>one of the big advantages of their approaches</p>
<p>344<br>00:46:28,000 –&gt; 00:46:30,000<br>didn’t require any engineering changes or changes</p>
<p>345<br>00:46:30,000 –&gt; 00:46:32,000<br>to the query optimizer itself.</p>
<p>346<br>00:46:32,000 –&gt; 00:46:36,000<br>That’s a whole complicated piece of a machinery inside the Davis server,</p>
<p>347<br>00:46:36,000 –&gt; 00:46:39,000<br>and then if you can avoid having to modify that,</p>
<p>348<br>00:46:39,000 –&gt; 00:46:43,000<br>and therefore you know there won’t be any regressions for anybody else,</p>
<p>349<br>00:46:43,000 –&gt; 00:46:48,000<br>then this is fantastic.</p>
<p>350<br>00:46:48,000 –&gt; 00:46:51,000<br>So if your query optimizer is very sophisticated,</p>
<p>351<br>00:46:51,000 –&gt; 00:46:53,000<br>in the case of SQL Server 1 is,</p>
<p>352<br>00:46:53,000 –&gt; 00:46:55,000<br>you actually get a lot of same optimization advantages</p>
<p>353<br>00:46:55,000 –&gt; 00:46:58,000<br>you would get in a what I’ll call traditional optimizer,</p>
<p>354<br>00:46:58,000 –&gt; 00:47:01,000<br>or compiler, optimizing compiler,</p>
<p>355<br>00:47:01,000 –&gt; 00:47:05,000<br>like for Clang or GCC, you basically get the same benefits</p>
<p>356<br>00:47:05,000 –&gt; 00:47:08,000<br>in now inside your UDF.</p>
<p>357<br>00:47:08,000 –&gt; 00:47:10,000<br>So let’s say I have a really simple UDF,</p>
<p>358<br>00:47:10,000 –&gt; 00:47:13,000<br>giving some integer, and I return back whether it’s a high value,</p>
<p>359<br>00:47:13,000 –&gt; 00:47:15,000<br>the string high value or low value.</p>
<p>360<br>00:47:15,000 –&gt; 00:47:18,000<br>So I would invoke it as select get value as passing</p>
<p>361<br>00:47:18,000 –&gt; 00:47:21,000<br>in some kind of constant here.</p>
<p>362<br>00:47:21,000 –&gt; 00:47:24,000<br>So if I Freud this mofo, I’m going to get,</p>
<p>363<br>00:47:24,000 –&gt; 00:47:26,000<br>at least in the first version, something like this.</p>
<p>364<br>00:47:26,000 –&gt; 00:47:29,000<br>We have the case when statement, if the value is greater than 1,000,</p>
<p>365<br>00:47:29,000 –&gt; 00:47:32,000<br>set up high, otherwise give it low,</p>
<p>366<br>00:47:32,000 –&gt; 00:47:36,000<br>and then we do an outer apply, we can know what that is on that,</p>
<p>367<br>00:47:36,000 –&gt; 00:47:40,000<br>and we get, you know, we return back the string high value, low value.</p>
<p>368<br>00:47:40,000 –&gt; 00:47:45,000<br>Well, in a query optimizer, a traditional optimizer,</p>
<p>369<br>00:47:45,000 –&gt; 00:47:49,000<br>it would be to recognize that because I’m invoking this with a constant value</p>
<p>370<br>00:47:49,000 –&gt; 00:47:52,000<br>of what was it? 5,000?</p>
<p>371<br>00:47:52,000 –&gt; 00:47:54,000<br>Yes, yeah, 5,000.</p>
<p>372<br>00:47:54,000 –&gt; 00:47:56,000<br>That I can do dynamic slicing and identify,</p>
<p>373<br>00:47:56,000 –&gt; 00:48:00,000<br>but I’m never going to go down the else clause for low value,</p>
<p>374<br>00:48:00,000 –&gt; 00:48:03,000<br>and I just remove that dead code entirely.</p>
<p>375<br>00:48:03,000 –&gt; 00:48:04,000<br>Right?</p>
<p>376<br>00:48:04,000 –&gt; 00:48:08,000<br>In the case of the SQL query, it’s the same thing as I’ve removed my case when,</p>
<p>377<br>00:48:08,000 –&gt; 00:48:14,000<br>and I just have, you know, just spit out the constant value high.</p>
<p>378<br>00:48:14,000 –&gt; 00:48:17,000<br>And furthermore, I can do constant propagation and folding.</p>
<p>379<br>00:48:17,000 –&gt; 00:48:20,000<br>Again, a traditional compiler optimizer would recognize that,</p>
<p>380<br>00:48:20,000 –&gt; 00:48:25,000<br>well, I don’t need to concatenate high and value as separate steps,</p>
<p>381<br>00:48:26,000 –&gt; 00:48:30,000<br>I can just put them two together at the very beginning by propagating the constant up.</p>
<p>382<br>00:48:30,000 –&gt; 00:48:34,000<br>Same thing in our SQL query, the query optimizer could figure out,</p>
<p>383<br>00:48:34,000 –&gt; 00:48:36,000<br>oh, well, this is just taking high,</p>
<p>384<br>00:48:36,000 –&gt; 00:48:42,000<br>appending it to the string vowel, so why do that as an outer apply with separate SQL queries,</p>
<p>385<br>00:48:42,000 –&gt; 00:48:45,000<br>and we just do it in one statement.</p>
<p>386<br>00:48:45,000 –&gt; 00:48:48,000<br>In further, you do more dead code elimination,</p>
<p>387<br>00:48:48,000 –&gt; 00:48:53,000<br>saying, well, I don’t need to declare an outer query return value</p>
<p>388<br>00:48:54,000 –&gt; 00:48:56,000<br>or setting up the variable and then returning it,</p>
<p>389<br>00:48:56,000 –&gt; 00:48:59,000<br>it’s just select high value.</p>
<p>390<br>00:49:01,000 –&gt; 00:49:05,000<br>So again, you get all the same benefits as if it was a traditional optimizer,</p>
<p>391<br>00:49:05,000 –&gt; 00:49:07,000<br>but the query optimizer is doing this,</p>
<p>392<br>00:49:07,000 –&gt; 00:49:09,000<br>because it already can do this for queries today.</p>
<p>393<br>00:49:09,000 –&gt; 00:49:12,000<br>SQL Server can not everyone can.</p>
<p>394<br>00:49:12,000 –&gt; 00:49:16,000<br>I don’t think Postgres can do this.</p>
<p>395<br>00:49:18,000 –&gt; 00:49:19,000<br>Right?</p>
<p>396<br>00:49:19,000 –&gt; 00:49:20,000<br>Yes.</p>
<p>397<br>00:49:20,000 –&gt; 00:49:22,000<br>So what does this work so well?</p>
<p>398<br>00:49:22,000 –&gt; 00:49:25,000<br>Can you just stop teaching people, see, and pull in these media.</p>
<p>399<br>00:49:25,000 –&gt; 00:49:27,000<br>Stabbing is, if this works so well,</p>
<p>400<br>00:49:27,000 –&gt; 00:49:30,000<br>could we just stop teaching people SQL and use you desks or everything?</p>
<p>401<br>00:49:30,000 –&gt; 00:49:32,000<br>So again, it doesn’t support everything.</p>
<p>402<br>00:49:32,000 –&gt; 00:49:34,000<br>So in 2019, this is what you can do.</p>
<p>403<br>00:49:34,000 –&gt; 00:49:37,000<br>You can do clairs and sets, you have select queries,</p>
<p>404<br>00:49:37,000 –&gt; 00:49:40,000<br>if then else, or if else, else if,</p>
<p>405<br>00:49:40,000 –&gt; 00:49:44,000<br>if return clause in multiple locations of the function,</p>
<p>406<br>00:49:44,000 –&gt; 00:49:46,000<br>which they can handle that,</p>
<p>407<br>00:49:46,000 –&gt; 00:49:48,000<br>and they can do all basic relational operators,</p>
<p>408<br>00:49:48,000 –&gt; 00:49:50,000<br>out of operators, exist, not exist,</p>
<p>409<br>00:49:50,000 –&gt; 00:49:54,000<br>is null in any and so forth.</p>
<p>410<br>00:49:54,000 –&gt; 00:49:56,000<br>They don’t support exceptions,</p>
<p>411<br>00:49:56,000 –&gt; 00:49:58,000<br>they don’t support dynamic SQL queries,</p>
<p>412<br>00:49:58,000 –&gt; 00:50:00,000<br>and they don’t support updates.</p>
<p>413<br>00:50:00,000 –&gt; 00:50:02,000<br>Again, in SQL Server, that’s not a big deal,</p>
<p>414<br>00:50:02,000 –&gt; 00:50:05,000<br>but in Postgres and other queries,</p>
<p>415<br>00:50:05,000 –&gt; 00:50:07,000<br>or other data systems, you could.</p>
<p>416<br>00:50:07,000 –&gt; 00:50:08,000<br>So the original question is,</p>
<p>417<br>00:50:08,000 –&gt; 00:50:09,000<br>why do we need SQL,</p>
<p>418<br>00:50:09,000 –&gt; 00:50:11,000<br>instead of just using UDS?</p>
<p>419<br>00:50:11,000 –&gt; 00:50:14,000<br>You want you to still need both, right?</p>
<p>420<br>00:50:14,000 –&gt; 00:50:16,000<br>There are certain things you would not,</p>
<p>421<br>00:50:16,000 –&gt; 00:50:19,000<br>like, to do the things you would want to,</p>
<p>422<br>00:50:19,000 –&gt; 00:50:22,000<br>we do in a, on your database server,</p>
<p>423<br>00:50:22,000 –&gt; 00:50:26,000<br>like your UDS is going to start making SQL query calls in it.</p>
<p>424<br>00:50:26,000 –&gt; 00:50:28,000<br>Right?</p>
<p>425<br>00:50:28,000 –&gt; 00:50:33,000<br>So SQL doesn’t go away.</p>
<p>426<br>00:50:33,000 –&gt; 00:50:37,000<br>So this is the result they had in the paper that they share,</p>
<p>427<br>00:50:37,000 –&gt; 00:50:41,000<br>where they had a bunch of different workloads</p>
<p>428<br>00:50:41,000 –&gt; 00:50:43,000<br>that are real from real customers,</p>
<p>429<br>00:50:43,000 –&gt; 00:50:46,000<br>and I think they got permission to extract out the UDS</p>
<p>430<br>00:50:46,000 –&gt; 00:50:48,000<br>and sample the data,</p>
<p>431<br>00:50:48,000 –&gt; 00:50:52,000<br>and they showed what benefit they’re getting for a bunch of UDS</p>
<p>432<br>00:50:52,000 –&gt; 00:50:54,000<br>by inlining it with Freud.</p>
<p>433<br>00:50:54,000 –&gt; 00:50:58,000<br>So for the first workload, it had 90 UDS,</p>
<p>434<br>00:50:58,000 –&gt; 00:51:02,000<br>and 82 of them could be, could be in line with Freud,</p>
<p>435<br>00:51:02,000 –&gt; 00:51:05,000<br>and the second one was 178 UDS,</p>
<p>436<br>00:51:05,000 –&gt; 00:51:07,000<br>and 150 work of battle.</p>
<p>437<br>00:51:07,000 –&gt; 00:51:10,000<br>And so, you can sort of see the long tail here,</p>
<p>438<br>00:51:10,000 –&gt; 00:51:13,000<br>with only one UDF actually had a regression,</p>
<p>439<br>00:51:13,000 –&gt; 00:51:16,000<br>and I think it’s going to be because the SQL server</p>
<p>440<br>00:51:16,000 –&gt; 00:51:19,000<br>is going to choke on the, you know,</p>
<p>441<br>00:51:19,000 –&gt; 00:51:23,000<br>going to choke on, and handling a large amount of lateral joins,</p>
<p>442<br>00:51:23,000 –&gt; 00:51:25,000<br>the same thing for the little one here.</p>
<p>443<br>00:51:25,000 –&gt; 00:51:27,000<br>But like, this is pretty significant, right?</p>
<p>444<br>00:51:27,000 –&gt; 00:51:31,000<br>Some customers are getting almost 1,000 X speed up, right?</p>
<p>445<br>00:51:31,000 –&gt; 00:51:33,000<br>That’s huge. That’s insane.</p>
<p>446<br>00:51:33,000 –&gt; 00:51:35,000<br>Like, that almost never happens in databases,</p>
<p>447<br>00:51:35,000 –&gt; 00:51:37,000<br>unless you, like, rewrite your application,</p>
<p>448<br>00:51:37,000 –&gt; 00:51:39,000<br>or like switch vendors, go from like, you know,</p>
<p>449<br>00:51:39,000 –&gt; 00:51:41,000<br>a row store to a column store.</p>
<p>450<br>00:51:41,000 –&gt; 00:51:44,000<br>Without having to make any changes to the UDF itself,</p>
<p>451<br>00:51:44,000 –&gt; 00:51:48,000<br>just with Freud in inlining, the performance win is significant.</p>
<p>452<br>00:51:48,000 –&gt; 00:51:49,000<br>Right?</p>
<p>453<br>00:51:49,000 –&gt; 00:51:51,000<br>And the inventor of Freud, this guy, Carthick,</p>
<p>454<br>00:51:51,000 –&gt; 00:51:53,000<br>he was a Pichestudent IAT Bombay,</p>
<p>455<br>00:51:53,000 –&gt; 00:51:55,000<br>which is the best database school in India,</p>
<p>456<br>00:51:55,000 –&gt; 00:51:58,000<br>and then he was at the Gray Systems Lab</p>
<p>457<br>00:51:58,000 –&gt; 00:52:01,000<br>in Madison, Wisconsin, with Gignesh,</p>
<p>458<br>00:52:01,000 –&gt; 00:52:04,000<br>and where he worked at Microsoft on this.</p>
<p>459<br>00:52:04,000 –&gt; 00:52:09,000<br>He got it, the paper came out, I think, in 2016, 2017.</p>
<p>460<br>00:52:09,000 –&gt; 00:52:11,000<br>You know, that he, the paper predates it,</p>
<p>461<br>00:52:11,000 –&gt; 00:52:13,000<br>but they got it shipped in SQL Server in 2019,</p>
<p>462<br>00:52:13,000 –&gt; 00:52:15,000<br>in like, three years, which is insane.</p>
<p>463<br>00:52:15,000 –&gt; 00:52:17,000<br>So there’s a bunch of his tweets that shows it, like,</p>
<p>464<br>00:52:17,000 –&gt; 00:52:19,000<br>people are talking about how, like, the benefit they’re getting</p>
<p>465<br>00:52:19,000 –&gt; 00:52:21,000<br>with Freud is, you know, 20X faster, you know,</p>
<p>466<br>00:52:21,000 –&gt; 00:52:23,000<br>it’s significantly more.</p>
<p>467<br>00:52:23,000 –&gt; 00:52:26,000<br>Or this case, the query went from four minutes to nine seconds,</p>
<p>468<br>00:52:26,000 –&gt; 00:52:29,000<br>but just turning on the flags says, use Freud.</p>
<p>469<br>00:52:29,000 –&gt; 00:52:31,000<br>Again, that’s a huge win without having</p>
<p>470<br>00:52:31,000 –&gt; 00:52:34,000<br>to make any change your application, right?</p>
<p>471<br>00:52:34,000 –&gt; 00:52:37,000<br>I think in the paper, they talk about the overall compatibility</p>
<p>472<br>00:52:37,000 –&gt; 00:52:43,000<br>or support for UDS in all of the top 100 Azure databases,</p>
<p>473<br>00:52:43,000 –&gt; 00:52:45,000<br>I think was about like 60%.</p>
<p>474<br>00:52:45,000 –&gt; 00:52:50,000<br>So 60% of the UDS could be converted into, could be in line with Freud.</p>
<p>475<br>00:52:55,000 –&gt; 00:52:57,000<br>All right, so this is one approach.</p>
<p>476<br>00:52:57,000 –&gt; 00:53:00,000<br>This is like, this is how to again, take the UDF,</p>
<p>477<br>00:53:00,000 –&gt; 00:53:04,000<br>convert it into relation algebra, and then inline that.</p>
<p>478<br>00:53:04,000 –&gt; 00:53:07,000<br>And I showed how to do it through SQL.</p>
<p>479<br>00:53:07,000 –&gt; 00:53:09,000<br>So here’s another, yes, question.</p>
<p>480<br>00:53:09,000 –&gt; 00:53:13,000<br>So what are the challenges that you’ve been in the same approach</p>
<p>481<br>00:53:13,000 –&gt; 00:53:16,000<br>with effectively UDS? Why is the UDS?</p>
<p>482<br>00:53:16,000 –&gt; 00:53:18,000<br>A question.</p>
<p>483<br>00:53:18,000 –&gt; 00:53:20,000<br>What are the challenges that you’re doing with scale UDS?</p>
<p>484<br>00:53:20,000 –&gt; 00:53:22,000<br>Where’s the vector UDS?</p>
<p>485<br>00:53:22,000 –&gt; 00:53:24,000<br>Well, I’m sorry for scale UDS.</p>
<p>486<br>00:53:24,000 –&gt; 00:53:26,000<br>We’ve roomed the scope of scale UDS.</p>
<p>487<br>00:53:26,000 –&gt; 00:53:28,000<br>What are the additional challenges that prevent</p>
<p>488<br>00:53:28,000 –&gt; 00:53:30,000<br>from going into vector?</p>
<p>489<br>00:53:30,000 –&gt; 00:53:34,000<br>Scale UDS is a construct in UDS.</p>
<p>490<br>00:53:34,000 –&gt; 00:53:37,000<br>Like they return a single value.</p>
<p>491<br>00:53:37,000 –&gt; 00:53:40,000<br>If you return multiple values, they’re called table value functions.</p>
<p>492<br>00:53:40,000 –&gt; 00:53:42,000<br>Sorry, I made the problem.</p>
<p>493<br>00:53:42,000 –&gt; 00:53:44,000<br>Yeah.</p>
<p>494<br>00:53:44,000 –&gt; 00:53:48,000<br>So actually, it’s like, why can’t you do this for everything?</p>
<p>495<br>00:53:51,000 –&gt; 00:53:54,000<br>I don’t know.</p>
<p>496<br>00:53:55,000 –&gt; 00:53:57,000<br>Yes, of course. I don’t remember.</p>
<p>497<br>00:53:57,000 –&gt; 00:54:01,000<br>Most functions out there are scale UDS anyway.</p>
<p>498<br>00:54:01,000 –&gt; 00:54:02,000<br>Yes.</p>
<p>499<br>00:54:02,000 –&gt; 00:54:05,000<br>Are there any restrictions on UDS to make sure they always terminate?</p>
<p>500<br>00:54:05,000 –&gt; 00:54:07,000<br>The question is, are there restrictions on UDS to make sure</p>
<p>501<br>00:54:07,000 –&gt; 00:54:08,000<br>they always terminate?</p>
<p>502<br>00:54:08,000 –&gt; 00:54:12,000<br>That’s usually a construct of the execution engine itself,</p>
<p>503<br>00:54:12,000 –&gt; 00:54:14,000<br>like how long a query can run.</p>
<p>504<br>00:54:14,000 –&gt; 00:54:18,000<br>So you set your time out to say, the query can run for one minute.</p>
<p>505<br>00:54:18,000 –&gt; 00:54:21,000<br>The data system doesn’t care whether you’re spending all your time in UDF or not.</p>
<p>506<br>00:54:22,000 –&gt; 00:54:24,000<br>So yes, could you write an infinite loop in UDF?</p>
<p>507<br>00:54:24,000 –&gt; 00:54:25,000<br>Yes.</p>
<p>508<br>00:54:25,000 –&gt; 00:54:27,000<br>Why did it convert for loop for one minute?</p>
<p>509<br>00:54:27,000 –&gt; 00:54:29,000<br>The question is, is that why they can’t convert for loops?</p>
<p>510<br>00:54:29,000 –&gt; 00:54:33,000<br>I don’t think it’s a limitation of what a time out.</p>
<p>511<br>00:54:33,000 –&gt; 00:54:36,000<br>I think the discussion of limitation of the paper,</p>
<p>512<br>00:54:36,000 –&gt; 00:54:38,000<br>and they have a cursor for the code,</p>
<p>513<br>00:54:38,000 –&gt; 00:54:42,000<br>so they can get out of the volume to point the areas with the limitation</p>
<p>514<br>00:54:42,000 –&gt; 00:54:46,000<br>that they’re setting the common memory and they don’t want the UDS to end.</p>
<p>515<br>00:54:46,000 –&gt; 00:54:48,000<br>There’s a follow-up paper we’re not going to cover call it Agify,</p>
<p>516<br>00:54:48,000 –&gt; 00:54:53,000<br>where they show how to do aggregations, like loops in an UDF.</p>
<p>517<br>00:54:53,000 –&gt; 00:54:57,000<br>For that one, they’re actually going to rewrite your portion of the UDF</p>
<p>518<br>00:54:57,000 –&gt; 00:55:00,000<br>as a user-writing aggregate and evoke that.</p>
<p>519<br>00:55:00,000 –&gt; 00:55:03,000<br>That’s doing transpiration.</p>
<p>520<br>00:55:03,000 –&gt; 00:55:06,000<br>We don’t want to focus on that.</p>
<p>521<br>00:55:06,000 –&gt; 00:55:09,000<br>And that, as far as I know, didn’t make a production.</p>
<p>522<br>00:55:12,000 –&gt; 00:55:14,000<br>Exceptions are the other way or one, too, because they didn’t know that it’s a sport.</p>
<p>523<br>00:55:14,000 –&gt; 00:55:16,000<br>That’s literally like, it’s like a go-to statement.</p>
<p>524<br>00:55:16,000 –&gt; 00:55:19,000<br>You’re jumping to another part and they don’t support that.</p>
<p>525<br>00:55:19,000 –&gt; 00:55:25,000<br>All right, so I want to talk about how to do SQL or UDF into SQL,</p>
<p>526<br>00:55:25,000 –&gt; 00:55:30,000<br>using the app file approach from other set of Germans at Toburgin,</p>
<p>527<br>00:55:30,000 –&gt; 00:55:33,000<br>and then when I finish up talking about batching,</p>
<p>528<br>00:55:33,000 –&gt; 00:55:36,000<br>which is another alternative to inlining.</p>
<p>529<br>00:55:36,000 –&gt; 00:55:40,000<br>So for this app file approach, what they’re going to do is they’re going to take your UDS</p>
<p>530<br>00:55:40,000 –&gt; 00:55:45,000<br>and they’re going to vert them into commentable expressions.</p>
<p>531<br>00:55:45,000 –&gt; 00:55:47,000<br>Basically, SQL statements.</p>
<p>532<br>00:55:47,000 –&gt; 00:55:50,000<br>And this is going to allow them to do the looping that Freud can’t do</p>
<p>533<br>00:55:50,000 –&gt; 00:55:53,000<br>and additional constructs that Freud can’t handle.</p>
<p>534<br>00:55:53,000 –&gt; 00:55:56,000<br>So instead of actually embedding this and having the database server,</p>
<p>535<br>00:55:56,000 –&gt; 00:56:01,000<br>they actually wrote this as a separate middleware, as a standalone compiler.</p>
<p>536<br>00:56:01,000 –&gt; 00:56:03,000<br>I can give it a quick demo.</p>
<p>537<br>00:56:03,000 –&gt; 00:56:09,000<br>So if you go to that website here, you have on one side you have the UDF.</p>
<p>538<br>00:56:09,000 –&gt; 00:56:12,000<br>I think you’re going to need to make a false name.</p>
<p>539<br>00:56:12,000 –&gt; 00:56:14,000<br>So what’s that?</p>
<p>540<br>00:56:14,000 –&gt; 00:56:15,000<br>The core natural.</p>
<p>541<br>00:56:15,000 –&gt; 00:56:17,000<br>Yeah, they’re always going to have the core lateral,</p>
<p>542<br>00:56:17,000 –&gt; 00:56:20,000<br>but they’re going to recruit the CTs for this as well.</p>
<p>543<br>00:56:20,000 –&gt; 00:56:22,000<br>So again, so this is the original UDF,</p>
<p>544<br>00:56:22,000 –&gt; 00:56:24,000<br>and then this is what it’ll spit out.</p>
<p>545<br>00:56:24,000 –&gt; 00:56:27,000<br>And you see a lot of lateral joins and mess acquires.</p>
<p>546<br>00:56:27,000 –&gt; 00:56:30,000<br>So I can do something really stupid.</p>
<p>547<br>00:56:30,000 –&gt; 00:56:32,000<br>You know, x.</p>
<p>548<br>00:56:37,000 –&gt; 00:56:39,000<br>And then it spits it out.</p>
<p>549<br>00:56:39,000 –&gt; 00:56:41,000<br>Now, like, it’s including x variable.</p>
<p>550<br>00:56:41,000 –&gt; 00:56:43,000<br>And it’s doing some of the same things.</p>
<p>551<br>00:56:43,000 –&gt; 00:56:47,000<br>Like it’s setting up the variables in the same way that we saw before.</p>
<p>552<br>00:56:47,000 –&gt; 00:56:49,000<br>So I change this to 99.</p>
<p>553<br>00:56:49,000 –&gt; 00:56:50,000<br>Right?</p>
<p>554<br>00:56:50,000 –&gt; 00:56:52,000<br>Then you get the same.</p>
<p>555<br>00:56:52,000 –&gt; 00:56:54,000<br>It’s very similar to what we saw in Freud.</p>
<p>556<br>00:56:54,000 –&gt; 00:56:57,000<br>And then if I actually run this, though,</p>
<p>557<br>00:56:57,000 –&gt; 00:57:00,000<br>so this is Postgres.</p>
<p>558<br>00:57:00,000 –&gt; 00:57:01,000<br>So I’ve already installed it.</p>
<p>559<br>00:57:01,000 –&gt; 00:57:04,000<br>So here’s the real simple function.</p>
<p>560<br>00:57:04,000 –&gt; 00:57:07,000<br>And then I execute it as.</p>
<p>561<br>00:57:08,000 –&gt; 00:57:10,000<br>You can’t see.</p>
<p>562<br>00:57:10,000 –&gt; 00:57:13,000<br>Right?</p>
<p>563<br>00:57:13,000 –&gt; 00:57:15,000<br>So if I run it out,</p>
<p>564<br>00:57:15,000 –&gt; 00:57:18,000<br>it takes about half a second to do the original UDF.</p>
<p>565<br>00:57:18,000 –&gt; 00:57:22,000<br>But if I run there, giant,</p>
<p>566<br>00:57:22,000 –&gt; 00:57:25,000<br>the lateral join one like this,</p>
<p>567<br>00:57:25,000 –&gt; 00:57:29,000<br>that’s how it’s going to install it.</p>
<p>568<br>00:57:29,000 –&gt; 00:57:30,000<br>That was a great function.</p>
<p>569<br>00:57:30,000 –&gt; 00:57:34,000<br>So now I invoke it.</p>
<p>570<br>00:57:34,000 –&gt; 00:57:37,000<br>Now we’re taking what two milliseconds?</p>
<p>571<br>00:57:37,000 –&gt; 00:57:38,000<br>Yeah.</p>
<p>572<br>00:57:38,000 –&gt; 00:57:39,000<br>So in this case here,</p>
<p>573<br>00:57:39,000 –&gt; 00:57:44,000<br>the UDF call in Postgres is actually faster than using the Freud one.</p>
<p>574<br>00:57:48,000 –&gt; 00:57:50,000<br>Totally explained.</p>
<p>575<br>00:57:50,000 –&gt; 00:57:51,000<br>Yep.</p>
<p>576<br>00:57:51,000 –&gt; 00:57:53,000<br>Yep, yep, yep, yep, I got it.</p>
<p>577<br>00:57:53,000 –&gt; 00:57:57,000<br>This is why I always use my laptop and I give demos in the class.</p>
<p>578<br>00:57:57,000 –&gt; 00:57:58,000<br>I want to keep it quick.</p>
<p>579<br>00:57:58,000 –&gt; 00:57:59,000<br>Right?</p>
<p>580<br>00:57:59,000 –&gt; 00:58:00,000<br>In this case here,</p>
<p>581<br>00:58:00,000 –&gt; 00:58:03,000<br>there’s the cause just invoking that function.</p>
<p>582<br>00:58:03,000 –&gt; 00:58:04,000<br>Right?</p>
<p>583<br>00:58:04,000 –&gt; 00:58:08,000<br>You see how Postgres at the optimization level can expand the SQL query</p>
<p>584<br>00:58:08,000 –&gt; 00:58:11,000<br>because it’s in bed inside that UDF.</p>
<p>585<br>00:58:11,000 –&gt; 00:58:13,000<br>Right?</p>
<p>586<br>00:58:13,000 –&gt; 00:58:17,000<br>And again, the link in the slides if you guys want to play with it.</p>
<p>587<br>00:58:17,000 –&gt; 00:58:18,000<br>All right.</p>
<p>588<br>00:58:18,000 –&gt; 00:58:20,000<br>So this is a great little PLE and capyla-y.</p>
<p>589<br>00:58:20,000 –&gt; 00:58:21,000<br>So bear with me.</p>
<p>590<br>00:58:21,000 –&gt; 00:58:23,000<br>And again, I’m not an expert in this area.</p>
<p>591<br>00:58:23,000 –&gt; 00:58:26,000<br>So like, I know enough how it maps to the SQL stuff,</p>
<p>592<br>00:58:26,000 –&gt; 00:58:28,000<br>but beyond this,</p>
<p>593<br>00:58:28,000 –&gt; 00:58:30,000<br>you know, this is all,</p>
<p>594<br>00:58:30,000 –&gt; 00:58:31,000<br>you know,</p>
<p>595<br>00:58:31,000 –&gt; 00:58:32,000<br>I can’t go too deep in this.</p>
<p>596<br>00:58:32,000 –&gt; 00:58:35,000<br>So the idea is that we take our UDF</p>
<p>597<br>00:58:35,000 –&gt; 00:58:41,000<br>and we’re going to convert this into a phone call SSA.</p>
<p>598<br>00:58:41,000 –&gt; 00:58:44,000<br>A static single assignment form.</p>
<p>599<br>00:58:44,000 –&gt; 00:58:49,000<br>And this is going to allow us to basically convert the arbitrary code</p>
<p>600<br>00:58:49,000 –&gt; 00:58:53,000<br>that we had in our UDF into some form that’s going to use go-tos</p>
<p>601<br>00:58:53,000 –&gt; 00:58:55,000<br>to define blocks of things.</p>
<p>602<br>00:58:55,000 –&gt; 00:58:58,000<br>And then we’re going to take this SSA thing and convert it into</p>
<p>603<br>00:58:58,000 –&gt; 00:59:00,000<br>administrative normal form,</p>
<p>604<br>00:59:00,000 –&gt; 00:59:03,000<br>which is going to use mutually-tailed recursive functions that</p>
<p>605<br>00:59:03,000 –&gt; 00:59:06,000<br>allows again to simplify the blocks of the regions themselves.</p>
<p>606<br>00:59:06,000 –&gt; 00:59:09,000<br>Then we convert the administrative normal form</p>
<p>607<br>00:59:09,000 –&gt; 00:59:12,000<br>with using mutual recursion into direct conversion,</p>
<p>608<br>00:59:12,000 –&gt; 00:59:13,000<br>recursion,</p>
<p>609<br>00:59:13,000 –&gt; 00:59:20,000<br>and then that gets converted into SQL using with recursive CTEs.</p>
<p>610<br>00:59:20,000 –&gt; 00:59:23,000<br>And then we, that produces our SQL query and we run it through our query optimizer.</p>
<p>611<br>00:59:23,000 –&gt; 00:59:24,000<br>So buckle up.</p>
<p>612<br>00:59:24,000 –&gt; 00:59:26,000<br>We’ll go through the list.</p>
<p>613<br>00:59:26,000 –&gt; 00:59:29,000<br>So let’s say we have a really simple function, this PAL function,</p>
<p>614<br>00:59:29,000 –&gt; 00:59:30,000<br>given an x, given an n,</p>
<p>615<br>00:59:30,000 –&gt; 00:59:33,000<br>we’re just going to have this part we care about as this loop here.</p>
<p>616<br>00:59:33,000 –&gt; 00:59:37,000<br>We can add our every i and multiply x by itself,</p>
<p>617<br>00:59:37,000 –&gt; 00:59:40,000<br>right, by some power.</p>
<p>618<br>00:59:40,000 –&gt; 00:59:41,000<br>So in the first step,</p>
<p>619<br>00:59:41,000 –&gt; 00:59:43,000<br>we want to convert this to SSA form.</p>
<p>620<br>00:59:43,000 –&gt; 00:59:46,000<br>It’s going to look something like this where we define these blocks</p>
<p>621<br>00:59:46,000 –&gt; 00:59:51,000<br>with these labels and then we’re using go-tos to jump around where we need.</p>
<p>622<br>00:59:51,000 –&gt; 00:59:52,000<br>Right?</p>
<p>623<br>00:59:52,000 –&gt; 00:59:53,000<br>You’re happy.</p>
<p>624<br>00:59:53,000 –&gt; 00:59:54,000<br>Look how happy you are.</p>
<p>625<br>00:59:54,000 –&gt; 00:59:55,000<br>Right?</p>
<p>626<br>00:59:55,000 –&gt; 00:59:56,000<br>See me on the ground.</p>
<p>627<br>00:59:56,000 –&gt; 00:59:57,000<br>Yeah.</p>
<p>628<br>00:59:57,000 –&gt; 00:59:58,000<br>All right.</p>
<p>629<br>00:59:58,000 –&gt; 01:00:01,000<br>This is what they do to you.</p>
<p>630<br>01:00:01,000 –&gt; 01:00:03,000<br>All right.</p>
<p>631<br>01:00:03,000 –&gt; 01:00:04,000<br>So again,</p>
<p>632<br>01:00:04,000 –&gt; 01:00:07,000<br>in SSA form,</p>
<p>633<br>01:00:07,000 –&gt; 01:00:08,000<br>as far as they know,</p>
<p>634<br>01:00:08,000 –&gt; 01:00:10,000<br>we’re only defined each variable once.</p>
<p>635<br>01:00:10,000 –&gt; 01:00:11,000<br>We’re all shaking their head.</p>
<p>636<br>01:00:11,000 –&gt; 01:00:12,000<br>Yes, same, same.</p>
<p>637<br>01:00:12,000 –&gt; 01:00:13,000<br>Yes.</p>
<p>638<br>01:00:13,000 –&gt; 01:00:16,000<br>And this is what the traditional compiler would do on the inside.</p>
<p>639<br>01:00:16,000 –&gt; 01:00:20,000<br>So then now we’re going to take our SSA form</p>
<p>640<br>01:00:20,000 –&gt; 01:00:22,000<br>and we’re going to convert this into administrative normal form.</p>
<p>641<br>01:00:22,000 –&gt; 01:00:25,000<br>And this is going to allow us to have a tail of recursion,</p>
<p>642<br>01:00:25,000 –&gt; 01:00:30,000<br>meaning in the last statement of every sort of function that we can call another function,</p>
<p>643<br>01:00:30,000 –&gt; 01:00:34,000<br>and we’re allowed to call recursively ourselves and other functions,</p>
<p>644<br>01:00:34,000 –&gt; 01:00:36,000<br>and those functions can then call us back.</p>
<p>645<br>01:00:36,000 –&gt; 01:00:37,000<br>Right?</p>
<p>646<br>01:00:37,000 –&gt; 01:00:40,000<br>So you have this, you can have cycles in this.</p>
<p>647<br>01:00:40,000 –&gt; 01:00:41,000<br>Right?</p>
<p>648<br>01:00:41,000 –&gt; 01:00:42,000<br>So in this case here,</p>
<p>649<br>01:00:42,000 –&gt; 01:00:43,000<br>for our while loop,</p>
<p>650<br>01:00:43,000 –&gt; 01:00:45,000<br>we’re going to loop through and do our computation,</p>
<p>651<br>01:00:45,000 –&gt; 01:00:47,000<br>and then we’re recursively calling ourselves,</p>
<p>652<br>01:00:47,000 –&gt; 01:00:49,000<br>but then when we want to finish the last one,</p>
<p>653<br>01:00:49,000 –&gt; 01:00:50,000<br>then we break out.</p>
<p>654<br>01:00:50,000 –&gt; 01:00:51,000<br>Right?</p>
<p>655<br>01:00:51,000 –&gt; 01:00:56,000<br>And then whatever the return result is whatever the last iteration was.</p>
<p>656<br>01:00:56,000 –&gt; 01:00:57,000<br>Yes.</p>
<p>657<br>01:00:57,000 –&gt; 01:00:58,000<br>So this is your tail of recursion.</p>
<p>658<br>01:00:58,000 –&gt; 01:01:02,000<br>It’s just like the calls to do the other labels that is recursive.</p>
<p>659<br>01:01:02,000 –&gt; 01:01:05,000<br>You’re still allowed to computation before the calls.</p>
<p>660<br>01:01:05,000 –&gt; 01:01:06,000<br>Yes.</p>
<p>661<br>01:01:06,000 –&gt; 01:01:07,000<br>Yeah.</p>
<p>662<br>01:01:07,000 –&gt; 01:01:09,000<br>And the question is,</p>
<p>663<br>01:01:09,000 –&gt; 01:01:11,000<br>are we allowed to do computation before we have the calls?</p>
<p>664<br>01:01:11,000 –&gt; 01:01:13,000<br>Yes, so that’s what this is.</p>
<p>665<br>01:01:13,000 –&gt; 01:01:14,000<br>Down here.</p>
<p>666<br>01:01:14,000 –&gt; 01:01:15,000<br>Right?</p>
<p>667<br>01:01:15,000 –&gt; 01:01:17,000<br>So again, this is doing mutual recursion,</p>
<p>668<br>01:01:17,000 –&gt; 01:01:19,000<br>meaning one function can call other function,</p>
<p>669<br>01:01:19,000 –&gt; 01:01:21,000<br>and that function can call you back.</p>
<p>670<br>01:01:21,000 –&gt; 01:01:24,000<br>We want to convert this to direct recursion,</p>
<p>671<br>01:01:24,000 –&gt; 01:01:27,000<br>and that’s just doing another transformation,</p>
<p>672<br>01:01:27,000 –&gt; 01:01:29,000<br>and that’s going to basically now,</p>
<p>673<br>01:01:29,000 –&gt; 01:01:31,000<br>where we only have recursive calls in the,</p>
<p>674<br>01:01:31,000 –&gt; 01:01:34,000<br>as the tail is the last thing we do within our function,</p>
<p>675<br>01:01:34,000 –&gt; 01:01:36,000<br>and then the, the,</p>
<p>676<br>01:01:36,000 –&gt; 01:01:39,000<br>the, the, the embedding of recursion calls can only get in one direction.</p>
<p>677<br>01:01:39,000 –&gt; 01:01:41,000<br>So run can call run,</p>
<p>678<br>01:01:41,000 –&gt; 01:01:42,000<br>pow can call run,</p>
<p>679<br>01:01:42,000 –&gt; 01:01:44,000<br>but run cannot call pow.</p>
<p>680<br>01:01:44,000 –&gt; 01:01:47,000<br>And the reason why we’re going to do this is because we care about,</p>
<p>681<br>01:01:47,000 –&gt; 01:01:50,000<br>getting the last output of what the,</p>
<p>682<br>01:01:50,000 –&gt; 01:01:51,000<br>of whatever this,</p>
<p>683<br>01:01:51,000 –&gt; 01:01:52,000<br>in our tail recursion calls,</p>
<p>684<br>01:01:52,000 –&gt; 01:01:53,000<br>call stack,</p>
<p>685<br>01:01:53,000 –&gt; 01:01:54,000<br>and that then gets,</p>
<p>686<br>01:01:54,000 –&gt; 01:01:56,000<br>as produces the output to the,</p>
<p>687<br>01:01:56,000 –&gt; 01:01:59,000<br>the, the, the select statement within our,</p>
<p>688<br>01:01:59,000 –&gt; 01:02:02,000<br>in our, in our, in our nested queries, right?</p>
<p>689<br>01:02:02,000 –&gt; 01:02:04,000<br>This is the outermost query is going to,</p>
<p>690<br>01:02:04,000 –&gt; 01:02:05,000<br>is going to, is to produce the output,</p>
<p>691<br>01:02:05,000 –&gt; 01:02:06,000<br>and that’s going to be the,</p>
<p>692<br>01:02:06,000 –&gt; 01:02:08,000<br>the, the intermost recursive call.</p>
<p>693<br>01:02:08,000 –&gt; 01:02:09,000<br>So, all right,</p>
<p>694<br>01:02:09,000 –&gt; 01:02:12,000<br>so then we take this thing,</p>
<p>695<br>01:02:12,000 –&gt; 01:02:14,000<br>and now we convert this into SQL.</p>
<p>696<br>01:02:14,000 –&gt; 01:02:16,000<br>So again, I’m not going to go through all the details,</p>
<p>697<br>01:02:17,000 –&gt; 01:02:18,000<br>what it’s all this, but,</p>
<p>698<br>01:02:18,000 –&gt; 01:02:19,000<br>basically, a thing of like,</p>
<p>699<br>01:02:19,000 –&gt; 01:02:21,000<br>here’s the, the, the,</p>
<p>700<br>01:02:21,000 –&gt; 01:02:22,000<br>the setup, all the variables.</p>
<p>701<br>01:02:22,000 –&gt; 01:02:23,000<br>Well, that’s, this,</p>
<p>702<br>01:02:23,000 –&gt; 01:02:25,000<br>this nested query inside of this.</p>
<p>703<br>01:02:25,000 –&gt; 01:02:27,000<br>Uh, and then we have our,</p>
<p>704<br>01:02:27,000 –&gt; 01:02:28,000<br>our, our if and else,</p>
<p>705<br>01:02:28,000 –&gt; 01:02:30,000<br>and then this, this recursion calls here, right?</p>
<p>706<br>01:02:30,000 –&gt; 01:02:31,000<br>And that corresponds to this,</p>
<p>707<br>01:02:31,000 –&gt; 01:02:33,000<br>this, this SQL statement like this.</p>
<p>708<br>01:02:33,000 –&gt; 01:02:34,000<br>Right?</p>
<p>709<br>01:02:34,000 –&gt; 01:02:38,000<br>And then compiler magic happens,</p>
<p>710<br>01:02:38,000 –&gt; 01:02:39,000<br>and then, and then this works.</p>
<p>711<br>01:02:39,000 –&gt; 01:02:44,000<br>All right, so,</p>
<p>712<br>01:02:44,000 –&gt; 01:02:46,000<br>does it make a difference?</p>
<p>713<br>01:02:46,000 –&gt; 01:02:48,000<br>Well, in, uh,</p>
<p>714<br>01:02:48,000 –&gt; 01:02:49,000<br>for this one, they didn’t,</p>
<p>715<br>01:02:49,000 –&gt; 01:02:51,000<br>they, they didn’t have Freud,</p>
<p>716<br>01:02:51,000 –&gt; 01:02:53,000<br>uh, so they can’t compare against, you know,</p>
<p>717<br>01:02:53,000 –&gt; 01:02:54,000<br>is their approach better than what,</p>
<p>718<br>01:02:54,000 –&gt; 01:02:56,000<br>what Microsoft is doing.</p>
<p>719<br>01:02:56,000 –&gt; 01:02:58,000<br>They just compare to how much faster they’re</p>
<p>720<br>01:02:58,000 –&gt; 01:02:59,000<br>approach using all these,</p>
<p>721<br>01:02:59,000 –&gt; 01:03:00,000<br>and SSTTEs,</p>
<p>722<br>01:03:00,000 –&gt; 01:03:02,000<br>or his versus, uh,</p>
<p>723<br>01:03:02,000 –&gt; 01:03:03,000<br>you know,</p>
<p>724<br>01:03:03,000 –&gt; 01:03:04,000<br>just letting,</p>
<p>725<br>01:03:04,000 –&gt; 01:03:05,000<br>postgres, just, you know,</p>
<p>726<br>01:03:05,000 –&gt; 01:03:06,000<br>call the UDF,</p>
<p>727<br>01:03:06,000 –&gt; 01:03:08,000<br>uh, as it normally does.</p>
<p>728<br>01:03:08,000 –&gt; 01:03:10,000<br>And in my example before,</p>
<p>729<br>01:03:10,000 –&gt; 01:03:11,000<br>I showed how the,</p>
<p>730<br>01:03:11,000 –&gt; 01:03:12,000<br>my, my,</p>
<p>731<br>01:03:12,000 –&gt; 01:03:13,000<br>the trial just showed before,</p>
<p>732<br>01:03:13,000 –&gt; 01:03:15,000<br>like, for that really simple function,</p>
<p>733<br>01:03:15,000 –&gt; 01:03:16,000<br>it’s actually faster,</p>
<p>734<br>01:03:16,000 –&gt; 01:03:17,000<br>just call the UDF,</p>
<p>735<br>01:03:17,000 –&gt; 01:03:18,000<br>and sure, for real simple things,</p>
<p>736<br>01:03:18,000 –&gt; 01:03:19,000<br>this doesn’t make sense.</p>
<p>737<br>01:03:19,000 –&gt; 01:03:20,000<br>But if you’re getting,</p>
<p>738<br>01:03:20,000 –&gt; 01:03:21,000<br>if you’re going to evoke the,</p>
<p>739<br>01:03:21,000 –&gt; 01:03:22,000<br>the UDF over,</p>
<p>740<br>01:03:22,000 –&gt; 01:03:24,000<br>over a very large table,</p>
<p>741<br>01:03:24,000 –&gt; 01:03:25,000<br>then now you can start to see</p>
<p>742<br>01:03:25,000 –&gt; 01:03:28,000<br>the divergence between the different approaches.</p>
<p>743<br>01:03:28,000 –&gt; 01:03:29,000<br>I would say also too,</p>
<p>744<br>01:03:29,000 –&gt; 01:03:30,000<br>that the,</p>
<p>745<br>01:03:30,000 –&gt; 01:03:31,000<br>I would,</p>
<p>746<br>01:03:31,000 –&gt; 01:03:33,000<br>I would say that the reason why this is not,</p>
<p>747<br>01:03:33,000 –&gt; 01:03:34,000<br>the,</p>
<p>748<br>01:03:34,000 –&gt; 01:03:35,000<br>the performance gap is not as more significant,</p>
<p>749<br>01:03:35,000 –&gt; 01:03:36,000<br>it’s because,</p>
<p>750<br>01:03:36,000 –&gt; 01:03:37,000<br>and the postgres query out of my,</p>
<p>751<br>01:03:37,000 –&gt; 01:03:38,000<br>is not as sophisticated as,</p>
<p>752<br>01:03:38,000 –&gt; 01:03:39,000<br>as micr saws.</p>
<p>753<br>01:03:39,000 –&gt; 01:03:40,000<br>So therefore,</p>
<p>754<br>01:03:40,000 –&gt; 01:03:42,000<br>it’s not going to be able to do all the,</p>
<p>755<br>01:03:42,000 –&gt; 01:03:43,000<br>the,</p>
<p>756<br>01:03:43,000 –&gt; 01:03:45,000<br>all the optimizations that I was showing before,</p>
<p>757<br>01:03:45,000 –&gt; 01:03:46,000<br>breaking it down,</p>
<p>758<br>01:03:46,000 –&gt; 01:03:47,000<br>removing dead code and,</p>
<p>759<br>01:03:47,000 –&gt; 01:03:48,000<br>and other things.</p>
<p>760<br>01:03:48,000 –&gt; 01:03:49,000<br>All right,</p>
<p>761<br>01:03:49,000 –&gt; 01:03:53,000<br>so the last one of the project I’m going to show you is bashing.</p>
<p>762<br>01:03:53,000 –&gt; 01:03:54,000<br>Again, so the background here,</p>
<p>763<br>01:03:54,000 –&gt; 01:03:56,000<br>this actually came out of a 721 project,</p>
<p>764<br>01:03:56,000 –&gt; 01:03:57,000<br>uh,</p>
<p>765<br>01:03:57,000 –&gt; 01:03:58,000<br>that Sam and,</p>
<p>766<br>01:03:58,000 –&gt; 01:03:59,000<br>and another student</p>
<p>767<br>01:03:59,000 –&gt; 01:04:00,000<br>were working on last year,</p>
<p>768<br>01:04:00,000 –&gt; 01:04:01,000<br>um,</p>
<p>769<br>01:04:01,000 –&gt; 01:04:02,000<br>and the,</p>
<p>770<br>01:04:02,000 –&gt; 01:04:03,000<br>the,</p>
<p>771<br>01:04:03,000 –&gt; 01:04:04,000<br>the,</p>
<p>772<br>01:04:04,000 –&gt; 01:04:05,000<br>and the,</p>
<p>773<br>01:04:05,000 –&gt; 01:04:06,000<br>the CMU undergrad,</p>
<p>774<br>01:04:06,000 –&gt; 01:04:07,000<br>sort of independently,</p>
<p>775<br>01:04:07,000 –&gt; 01:04:08,000<br>uh,</p>
<p>776<br>01:04:08,000 –&gt; 01:04:09,000<br>developed this,</p>
<p>777<br>01:04:09,000 –&gt; 01:04:10,000<br>this technique,</p>
<p>778<br>01:04:10,000 –&gt; 01:04:11,000<br>and then we found a,</p>
<p>779<br>01:04:11,000 –&gt; 01:04:14,000<br>a master’s thesis from the Germans that did app fell,</p>
<p>780<br>01:04:14,000 –&gt; 01:04:15,000<br>that’s,</p>
<p>781<br>01:04:15,000 –&gt; 01:04:16,000<br>they invented this bashing technique,</p>
<p>782<br>01:04:16,000 –&gt; 01:04:17,000<br>but then we found another paper from,</p>
<p>783<br>01:04:17,000 –&gt; 01:04:18,000<br>from the,</p>
<p>784<br>01:04:18,000 –&gt; 01:04:19,000<br>Freud guys,</p>
<p>785<br>01:04:19,000 –&gt; 01:04:20,000<br>P.C.</p>
<p>786<br>01:04:20,000 –&gt; 01:04:21,000<br>advisor from 2008,</p>
<p>787<br>01:04:21,000 –&gt; 01:04:22,000<br>who actually invented before anyone else,</p>
<p>788<br>01:04:22,000 –&gt; 01:04:23,000<br>but in that version 2008,</p>
<p>789<br>01:04:23,000 –&gt; 01:04:25,000<br>required changes to the query optimizer itself,</p>
<p>790<br>01:04:25,000 –&gt; 01:04:26,000<br>to make this all work,</p>
<p>791<br>01:04:26,000 –&gt; 01:04:29,000<br>in our version that they developed here,</p>
<p>792<br>01:04:29,000 –&gt; 01:04:30,000<br>uh,</p>
<p>793<br>01:04:30,000 –&gt; 01:04:31,000<br>and with the,</p>
<p>794<br>01:04:31,000 –&gt; 01:04:32,000<br>with the,</p>
<p>795<br>01:04:33,000 –&gt; 01:04:34,000<br>with the,</p>
<p>796<br>01:04:34,000 –&gt; 01:04:35,000<br>the toy gun Germans,</p>
<p>797<br>01:04:35,000 –&gt; 01:04:36,000<br>the app fell Germans,</p>
<p>798<br>01:04:36,000 –&gt; 01:04:38,000<br>you don’t have to make any changes to the optimizer, right?</p>
<p>799<br>01:04:38,000 –&gt; 01:04:39,000<br>So the idea here is that,</p>
<p>800<br>01:04:39,000 –&gt; 01:04:41,000<br>we’re going to translate the,</p>
<p>801<br>01:04:41,000 –&gt; 01:04:43,000<br>a UDF into a series of</p>
<p>802<br>01:04:43,000 –&gt; 01:04:45,000<br>update statements.</p>
<p>803<br>01:04:45,000 –&gt; 01:04:47,000<br>We’re not connecting them together with lateral joins,</p>
<p>804<br>01:04:47,000 –&gt; 01:04:48,000<br>it’s literally like,</p>
<p>805<br>01:04:48,000 –&gt; 01:04:50,000<br>it’s going to be one query evoked after another.</p>
<p>806<br>01:04:50,000 –&gt; 01:04:52,000<br>And what they’re going to do is,</p>
<p>807<br>01:04:52,000 –&gt; 01:04:53,000<br>they’re going to do some amount of computation</p>
<p>808<br>01:04:53,000 –&gt; 01:04:55,000<br>in the set clauses,</p>
<p>809<br>01:04:55,000 –&gt; 01:04:57,000<br>to then set values in a state table,</p>
<p>810<br>01:04:57,000 –&gt; 01:04:58,000<br>that’s going to be,</p>
<p>811<br>01:04:58,000 –&gt; 01:04:59,000<br>as if we’re maintaining those,</p>
<p>812<br>01:04:59,000 –&gt; 01:05:00,000<br>the,</p>
<p>813<br>01:05:01,000 –&gt; 01:05:03,000<br>the equipment to the variables that are in the UDF,</p>
<p>814<br>01:05:03,000 –&gt; 01:05:04,000<br>uh,</p>
<p>815<br>01:05:04,000 –&gt; 01:05:05,000<br>uh, UDF itself.</p>
<p>816<br>01:05:05,000 –&gt; 01:05:06,000<br>So when we evoke the UDF,</p>
<p>817<br>01:05:06,000 –&gt; 01:05:07,000<br>we first create this temp table,</p>
<p>818<br>01:05:07,000 –&gt; 01:05:09,000<br>we instantiate all the,</p>
<p>819<br>01:05:09,000 –&gt; 01:05:12,000<br>the attributes for each variables that are in the UDF,</p>
<p>820<br>01:05:12,000 –&gt; 01:05:13,000<br>then we have a series of updates,</p>
<p>821<br>01:05:13,000 –&gt; 01:05:15,000<br>that then update these variables,</p>
<p>822<br>01:05:15,000 –&gt; 01:05:18,000<br>corresponding to the computation that would be in the UDF.</p>
<p>823<br>01:05:18,000 –&gt; 01:05:20,000<br>So we’re doing that same translation we saw,</p>
<p>824<br>01:05:20,000 –&gt; 01:05:21,000<br>with Freud,</p>
<p>825<br>01:05:21,000 –&gt; 01:05:23,000<br>of converting the UDF procedural statements</p>
<p>826<br>01:05:23,000 –&gt; 01:05:24,000<br>into, uh,</p>
<p>827<br>01:05:24,000 –&gt; 01:05:26,000<br>corresponding SQL queries.</p>
<p>828<br>01:05:26,000 –&gt; 01:05:29,000<br>So this is going to be useful for any database system,</p>
<p>829<br>01:05:30,000 –&gt; 01:05:31,000<br>which we’ll see in a second,</p>
<p>830<br>01:05:31,000 –&gt; 01:05:33,000<br>that is not able to do the decorrelation stuff</p>
<p>831<br>01:05:33,000 –&gt; 01:05:34,000<br>that,</p>
<p>832<br>01:05:34,000 –&gt; 01:05:36,000<br>that Freud and Optel rely on.</p>
<p>833<br>01:05:36,000 –&gt; 01:05:37,000<br>I mean, I’m going to convert these lateral joins</p>
<p>834<br>01:05:37,000 –&gt; 01:05:39,000<br>and get them down into V,</p>
<p>835<br>01:05:39,000 –&gt; 01:05:40,000<br>uh,</p>
<p>836<br>01:05:40,000 –&gt; 01:05:42,000<br>to nested queries.</p>
<p>837<br>01:05:42,000 –&gt; 01:05:44,000<br>So this is a,</p>
<p>838<br>01:05:44,000 –&gt; 01:05:45,000<br>uh,</p>
<p>839<br>01:05:45,000 –&gt; 01:05:46,000<br>this is a UDF from Procbench,</p>
<p>840<br>01:05:46,000 –&gt; 01:05:47,000<br>we’ll talk about in a second.</p>
<p>841<br>01:05:47,000 –&gt; 01:05:48,000<br>This is the,</p>
<p>842<br>01:05:48,000 –&gt; 01:05:49,000<br>this is the,</p>
<p>843<br>01:05:49,000 –&gt; 01:05:50,000<br>a paper,</p>
<p>844<br>01:05:50,000 –&gt; 01:05:51,000<br>a follow-up paper that the,</p>
<p>845<br>01:05:51,000 –&gt; 01:05:52,000<br>Freud guys put out,</p>
<p>846<br>01:05:52,000 –&gt; 01:05:54,000<br>of a real benchmark that’s based on,</p>
<p>847<br>01:05:54,000 –&gt; 01:05:56,000<br>all these UDFs they were seeing in,</p>
<p>848<br>01:05:56,000 –&gt; 01:05:57,000<br>in real customers.</p>
<p>849<br>01:05:57,000 –&gt; 01:05:58,000<br>So it’s sort of,</p>
<p>850<br>01:05:58,000 –&gt; 01:06:00,000<br>it’s a synthetic version of,</p>
<p>851<br>01:06:00,000 –&gt; 01:06:01,000<br>of what UDFs look like.</p>
<p>852<br>01:06:01,000 –&gt; 01:06:02,000<br>So this is from,</p>
<p>853<br>01:06:02,000 –&gt; 01:06:03,000<br>from their example here.</p>
<p>854<br>01:06:03,000 –&gt; 01:06:04,000<br>The, the,</p>
<p>855<br>01:06:04,000 –&gt; 01:06:05,000<br>the gist of it is that you’re,</p>
<p>856<br>01:06:05,000 –&gt; 01:06:07,000<br>you’re, you’re doing a look-up on a,</p>
<p>857<br>01:06:07,000 –&gt; 01:06:08,000<br>uh,</p>
<p>858<br>01:06:08,000 –&gt; 01:06:11,000<br>on an item ID to figure out what manufacturer has,</p>
<p>859<br>01:06:11,000 –&gt; 01:06:13,000<br>has sold the most of it.</p>
<p>860<br>01:06:13,000 –&gt; 01:06:14,000<br>Right?</p>
<p>861<br>01:06:14,000 –&gt; 01:06:15,000<br>So you have this,</p>
<p>862<br>01:06:15,000 –&gt; 01:06:16,000<br>like, select query here.</p>
<p>863<br>01:06:16,000 –&gt; 01:06:17,000<br>I say this,</p>
<p>864<br>01:06:17,000 –&gt; 01:06:18,000<br>this is,</p>
<p>865<br>01:06:18,000 –&gt; 01:06:19,000<br>there’s three portions here.</p>
<p>866<br>01:06:19,000 –&gt; 01:06:20,000<br>There’s three nested,</p>
<p>867<br>01:06:20,000 –&gt; 01:06:21,000<br>uh, select queries here,</p>
<p>868<br>01:06:21,000 –&gt; 01:06:22,000<br>in these different blocks.</p>
<p>869<br>01:06:22,000 –&gt; 01:06:23,000<br>And then say this is the call and query,</p>
<p>870<br>01:06:23,000 –&gt; 01:06:24,000<br>that’s going to invoke it, right?</p>
<p>871<br>01:06:24,000 –&gt; 01:06:25,000<br>And so inside of this,</p>
<p>872<br>01:06:25,000 –&gt; 01:06:26,000<br>you have the,</p>
<p>873<br>01:06:26,000 –&gt; 01:06:27,000<br>uh,</p>
<p>874<br>01:06:27,000 –&gt; 01:06:29,000<br>you have some additional computation you’re doing.</p>
<p>875<br>01:06:29,000 –&gt; 01:06:31,000<br>And then for every single record within this,</p>
<p>876<br>01:06:31,000 –&gt; 01:06:32,000<br>this query here,</p>
<p>877<br>01:06:32,000 –&gt; 01:06:33,000<br>because you’re trying to get all the,</p>
<p>878<br>01:06:33,000 –&gt; 01:06:35,000<br>all the, um,</p>
<p>879<br>01:06:35,000 –&gt; 01:06:37,000<br>the first 25,000 most bought items,</p>
<p>880<br>01:06:37,000 –&gt; 01:06:38,000<br>then you,</p>
<p>881<br>01:06:38,000 –&gt; 01:06:40,000<br>you’re, you’re going to book the UDF up above.</p>
<p>882<br>01:06:40,000 –&gt; 01:06:41,000<br>So,</p>
<p>883<br>01:06:41,000 –&gt; 01:06:43,000<br>I’m not going to go through all this,</p>
<p>884<br>01:06:43,000 –&gt; 01:06:44,000<br>in a little bit of detail,</p>
<p>885<br>01:06:44,000 –&gt; 01:06:45,000<br>but you think of this as like,</p>
<p>886<br>01:06:45,000 –&gt; 01:06:47,000<br>the combination of the UDF,</p>
<p>887<br>01:06:47,000 –&gt; 01:06:48,000<br>plus the calling SQL query,</p>
<p>888<br>01:06:48,000 –&gt; 01:06:51,000<br>will get converted into a sequence of,</p>
<p>889<br>01:06:51,000 –&gt; 01:06:53,000<br>of SQL queries like this.</p>
<p>890<br>01:06:53,000 –&gt; 01:06:54,000<br>And you can almost treat this as,</p>
<p>891<br>01:06:54,000 –&gt; 01:06:55,000<br>like,</p>
<p>892<br>01:06:55,000 –&gt; 01:06:56,000<br>again, like,</p>
<p>893<br>01:06:56,000 –&gt; 01:06:57,000<br>like a SQL function,</p>
<p>894<br>01:06:57,000 –&gt; 01:06:58,000<br>although it has updates in it.</p>
<p>895<br>01:06:58,000 –&gt; 01:06:59,000<br>Like, just think of like a macro,</p>
<p>896<br>01:06:59,000 –&gt; 01:07:00,000<br>this thing would get embedded,</p>
<p>897<br>01:07:00,000 –&gt; 01:07:01,000<br>when you call,</p>
<p>898<br>01:07:01,000 –&gt; 01:07:03,000<br>when you call the out query like this.</p>
<p>899<br>01:07:03,000 –&gt; 01:07:04,000<br>So, in the first step here at the top,</p>
<p>900<br>01:07:04,000 –&gt; 01:07:06,000<br>here’s that temp table we’re creating.</p>
<p>901<br>01:07:06,000 –&gt; 01:07:07,000<br>And inside of that,</p>
<p>902<br>01:07:07,000 –&gt; 01:07:09,000<br>you see that we’re declaring attributes,</p>
<p>903<br>01:07:09,000 –&gt; 01:07:10,000<br>inside our temp table,</p>
<p>904<br>01:07:10,000 –&gt; 01:07:11,000<br>to correspond to,</p>
<p>905<br>01:07:11,000 –&gt; 01:07:13,000<br>all the variables that we defined, right?</p>
<p>906<br>01:07:13,000 –&gt; 01:07:14,000<br>So, we defined about,</p>
<p>907<br>01:07:14,000 –&gt; 01:07:15,000<br>a man variable,</p>
<p>908<br>01:07:15,000 –&gt; 01:07:16,000<br>count one, count two,</p>
<p>909<br>01:07:16,000 –&gt; 01:07:19,000<br>all those are getting defined in the,</p>
<p>910<br>01:07:19,000 –&gt; 01:07:21,000<br>in the create table itself.</p>
<p>911<br>01:07:21,000 –&gt; 01:07:23,000<br>But then we’re also going to have this special return,</p>
<p>912<br>01:07:23,000 –&gt; 01:07:24,000<br>Boolean,</p>
<p>913<br>01:07:24,000 –&gt; 01:07:25,000<br>that’s going to tell us whether this,</p>
<p>914<br>01:07:25,000 –&gt; 01:07:27,000<br>we want the value of this,</p>
<p>915<br>01:07:27,000 –&gt; 01:07:29,000<br>we want this record within this temp table,</p>
<p>916<br>01:07:29,000 –&gt; 01:07:31,000<br>corresponding to a tuple that was passed into us,</p>
<p>917<br>01:07:31,000 –&gt; 01:07:33,000<br>should get returned.</p>
<p>918<br>01:07:33,000 –&gt; 01:07:36,000<br>Or not, right?</p>
<p>919<br>01:07:36,000 –&gt; 01:07:38,000<br>So, you can sort of think as like the,</p>
<p>920<br>01:07:38,000 –&gt; 01:07:40,000<br>every single tuple in the,</p>
<p>921<br>01:07:40,000 –&gt; 01:07:41,000<br>the temp table,</p>
<p>922<br>01:07:41,000 –&gt; 01:07:43,000<br>is going to correspond to a tuple</p>
<p>923<br>01:07:43,000 –&gt; 01:07:45,000<br>that would get passed into the UDF.</p>
<p>924<br>01:07:45,000 –&gt; 01:07:46,000<br>So, I have a thousand tuples,</p>
<p>925<br>01:07:46,000 –&gt; 01:07:47,000<br>like a thousand,</p>
<p>926<br>01:07:47,000 –&gt; 01:07:49,000<br>what is this?</p>
<p>927<br>01:07:49,000 –&gt; 01:07:50,000<br>Web sales of,</p>
<p>928<br>01:07:50,000 –&gt; 01:07:51,000<br>a thousand Web sale items,</p>
<p>929<br>01:07:51,000 –&gt; 01:07:52,000<br>or item IDs,</p>
<p>930<br>01:07:52,000 –&gt; 01:07:54,000<br>that I have a thousand items</p>
<p>931<br>01:07:54,000 –&gt; 01:07:56,000<br>in my, in my temp table.</p>
<p>932<br>01:07:56,000 –&gt; 01:07:58,000<br>I’m just basically updating this giant state table,</p>
<p>933<br>01:07:58,000 –&gt; 01:08:00,000<br>as I go along.</p>
<p>934<br>01:08:00,000 –&gt; 01:08:02,000<br>And now, when I do all my computations,</p>
<p>935<br>01:08:02,000 –&gt; 01:08:04,000<br>these, these, you know,</p>
<p>936<br>01:08:04,000 –&gt; 01:08:07,000<br>what was done at sort of one record at a time,</p>
<p>937<br>01:08:07,000 –&gt; 01:08:08,000<br>in my original UDF,</p>
<p>938<br>01:08:08,000 –&gt; 01:08:10,000<br>I can now invoke across all of the,</p>
<p>939<br>01:08:10,000 –&gt; 01:08:12,000<br>the, the tuples that are being passed into the UDF,</p>
<p>940<br>01:08:12,000 –&gt; 01:08:13,000<br>at the same time.</p>
<p>941<br>01:08:13,000 –&gt; 01:08:18,000<br>And they’re all independently updating their state table.</p>
<p>942<br>01:08:18,000 –&gt; 01:08:19,000<br>And so, the way I would invoke this,</p>
<p>943<br>01:08:19,000 –&gt; 01:08:21,000<br>this generate series is in SQLStandard.</p>
<p>944<br>01:08:21,000 –&gt; 01:08:23,000<br>Basically, you can generate a,</p>
<p>945<br>01:08:23,000 –&gt; 01:08:25,000<br>a list of numbers from one to whatever,</p>
<p>946<br>01:08:25,000 –&gt; 01:08:26,000<br>or zero for whatever.</p>
<p>947<br>01:08:26,000 –&gt; 01:08:28,000<br>And it’s doing a lot of doing that.</p>
<p>948<br>01:08:28,000 –&gt; 01:08:29,000<br>So, sort of,</p>
<p>949<br>01:08:29,000 –&gt; 01:08:32,000<br>seeding the computation to invoke the,</p>
<p>950<br>01:08:32,000 –&gt; 01:08:34,000<br>the, the,</p>
<p>951<br>01:08:34,000 –&gt; 01:08:35,000<br>to generate the result that I’m looking for,</p>
<p>952<br>01:08:35,000 –&gt; 01:08:36,000<br>and produce the output that, that I need.</p>
<p>953<br>01:08:36,000 –&gt; 01:08:38,000<br>And that’s equivalent to invoking it,</p>
<p>954<br>01:08:38,000 –&gt; 01:08:40,000<br>the original UDF.</p>
<p>955<br>01:08:40,000 –&gt; 01:08:41,000<br>Yes.</p>
<p>956<br>01:08:41,000 –&gt; 01:08:44,000<br>Become a real public audience for every single,</p>
<p>957<br>01:08:44,000 –&gt; 01:08:46,000<br>like, your balance is,</p>
<p>958<br>01:08:46,000 –&gt; 01:08:47,000<br>I don’t think that’s going to work out,</p>
<p>959<br>01:08:47,000 –&gt; 01:08:48,000<br>because I’m not a real guy,</p>
<p>960<br>01:08:48,000 –&gt; 01:08:50,000<br>but I’m not a real public audience for every UDF.</p>
<p>961<br>01:08:50,000 –&gt; 01:08:51,000<br>Same as,</p>
<p>962<br>01:08:51,000 –&gt; 01:08:52,000<br>it’s not going to work for every,</p>
<p>963<br>01:08:52,000 –&gt; 01:08:53,000<br>work out for every UDF.</p>
<p>964<br>01:08:53,000 –&gt; 01:08:54,000<br>I think it does,</p>
<p>965<br>01:08:54,000 –&gt; 01:08:56,000<br>because even exceptions,</p>
<p>966<br>01:08:56,000 –&gt; 01:08:59,000<br>you could handle that through the state table.</p>
<p>967<br>01:08:59,000 –&gt; 01:09:01,000<br>I think it’s a more generalizable than,</p>
<p>968<br>01:09:01,000 –&gt; 01:09:03,000<br>than, for later, I felt.</p>
<p>969<br>01:09:03,000 –&gt; 01:09:05,000<br>Uh,</p>
<p>970<br>01:09:05,000 –&gt; 01:09:06,000<br>because again,</p>
<p>971<br>01:09:06,000 –&gt; 01:09:07,000<br>so you,</p>
<p>972<br>01:09:07,000 –&gt; 01:09:08,000<br>actually, you could,</p>
<p>973<br>01:09:08,000 –&gt; 01:09:10,000<br>you could potentially handle dynamic queries,</p>
<p>974<br>01:09:10,000 –&gt; 01:09:12,000<br>because you just put the string that you’re</p>
<p>975<br>01:09:12,000 –&gt; 01:09:13,000<br>concatenating to the SQL,</p>
<p>976<br>01:09:13,000 –&gt; 01:09:15,000<br>you could put that in the state table.</p>
<p>977<br>01:09:15,000 –&gt; 01:09:16,000<br>It’s a little weird,</p>
<p>978<br>01:09:16,000 –&gt; 01:09:18,000<br>but you could do it.</p>
<p>979<br>01:09:18,000 –&gt; 01:09:21,000<br>Okay.</p>
<p>980<br>01:09:21,000 –&gt; 01:09:23,000<br>So,</p>
<p>981<br>01:09:23,000 –&gt; 01:09:25,000<br>I think I’ve already mentioned this, right?</p>
<p>982<br>01:09:25,000 –&gt; 01:09:26,000<br>So the,</p>
<p>983<br>01:09:26,000 –&gt; 01:09:28,000<br>these are slides from Sam from last year, right?</p>
<p>984<br>01:09:28,000 –&gt; 01:09:30,000<br>So the Microsoft guys wrote the Freud paper,</p>
<p>985<br>01:09:30,000 –&gt; 01:09:31,000<br>they wrote the follow-up paper to Agify,</p>
<p>986<br>01:09:31,000 –&gt; 01:09:32,000<br>and then they put together the certain source bench,</p>
<p>987<br>01:09:32,000 –&gt; 01:09:33,000<br>like, the SQL Procbench.</p>
<p>988<br>01:09:33,000 –&gt; 01:09:35,000<br>That was, you know,</p>
<p>989<br>01:09:35,000 –&gt; 01:09:36,000<br>they argued was a,</p>
<p>990<br>01:09:36,000 –&gt; 01:09:37,000<br>faith representation of what the,</p>
<p>991<br>01:09:37,000 –&gt; 01:09:39,000<br>what real UDFs actually looked like,</p>
<p>992<br>01:09:39,000 –&gt; 01:09:40,000<br>because prior to this,</p>
<p>993<br>01:09:40,000 –&gt; 01:09:41,000<br>it wasn’t anything.</p>
<p>994<br>01:09:41,000 –&gt; 01:09:43,000<br>And you sort of classify the,</p>
<p>995<br>01:09:43,000 –&gt; 01:09:46,000<br>the UDFs into sort of two categories in the Procbench.</p>
<p>996<br>01:09:47,000 –&gt; 01:09:48,000<br>The first are going to be,</p>
<p>997<br>01:09:48,000 –&gt; 01:09:51,000<br>UDFs without any input parameters, right?</p>
<p>998<br>01:09:51,000 –&gt; 01:09:53,000<br>So select max return,</p>
<p>999<br>01:09:53,000 –&gt; 01:09:55,000<br>reason web, right?</p>
<p>1000<br>01:09:55,000 –&gt; 01:09:56,000<br>Nothing gets passed into it,</p>
<p>1001<br>01:09:56,000 –&gt; 01:09:58,000<br>and I’m just invoking this once.</p>
<p>1002<br>01:09:58,000 –&gt; 01:10:00,000<br>And so in this case here,</p>
<p>1003<br>01:10:00,000 –&gt; 01:10:02,000<br>there isn’t actually any advantage using inlining or,</p>
<p>1004<br>01:10:02,000 –&gt; 01:10:05,000<br>or batching because this UDF is just invoked once.</p>
<p>1005<br>01:10:05,000 –&gt; 01:10:08,000<br>And there’s really nothing special about it, right?</p>
<p>1006<br>01:10:08,000 –&gt; 01:10:10,000<br>The ones that matter the most is you have things like,</p>
<p>1007<br>01:10:10,000 –&gt; 01:10:11,000<br>where you,</p>
<p>1008<br>01:10:11,000 –&gt; 01:10:12,000<br>where we told before,</p>
<p>1009<br>01:10:12,000 –&gt; 01:10:15,000<br>where you are passing in some kind of input value,</p>
<p>1010<br>01:10:15,000 –&gt; 01:10:17,000<br>that you’re iterating over in the,</p>
<p>1011<br>01:10:17,000 –&gt; 01:10:18,000<br>in the calling query,</p>
<p>1012<br>01:10:18,000 –&gt; 01:10:20,000<br>in the outside, right?</p>
<p>1013<br>01:10:20,000 –&gt; 01:10:24,000<br>So I think that when Sam did his analysis,</p>
<p>1014<br>01:10:24,000 –&gt; 01:10:26,000<br>looking for a Procbench,</p>
<p>1015<br>01:10:26,000 –&gt; 01:10:30,000<br>despite Microsoft inventing the inlining technique with Freud,</p>
<p>1016<br>01:10:30,000 –&gt; 01:10:33,000<br>they could only inline a small portion of within their benchmark</p>
<p>1017<br>01:10:33,000 –&gt; 01:10:34,000<br>of these queries,</p>
<p>1018<br>01:10:34,000 –&gt; 01:10:35,000<br>because a bunch of them just,</p>
<p>1019<br>01:10:35,000 –&gt; 01:10:36,000<br>it couldn’t reason about,</p>
<p>1020<br>01:10:36,000 –&gt; 01:10:38,000<br>and it wasn’t able to handle it.</p>
<p>1021<br>01:10:38,000 –&gt; 01:10:39,000<br>Or in some cases,</p>
<p>1022<br>01:10:39,000 –&gt; 01:10:40,000<br>it did do it,</p>
<p>1023<br>01:10:40,000 –&gt; 01:10:41,000<br>it didn’t actually get it,</p>
<p>1024<br>01:10:41,000 –&gt; 01:10:42,000<br>and it got to perform its benefit,</p>
<p>1025<br>01:10:42,000 –&gt; 01:10:43,000<br>because it wasn’t able to,</p>
<p>1026<br>01:10:43,000 –&gt; 01:10:44,000<br>to do that decorelation.</p>
<p>1027<br>01:10:44,000 –&gt; 01:10:45,000<br>The sub queries, yes.</p>
<p>1028<br>01:10:45,000 –&gt; 01:10:47,000<br>The question to Sam, actually.</p>
<p>1029<br>01:10:47,000 –&gt; 01:10:51,000<br>So was it because the if conditions were to complex,</p>
<p>1030<br>01:10:51,000 –&gt; 01:10:52,000<br>or was it,</p>
<p>1031<br>01:10:52,000 –&gt; 01:10:54,000<br>there was something that it just didn’t,</p>
<p>1032<br>01:10:54,000 –&gt; 01:10:55,000<br>like, there was declared set,</p>
<p>1033<br>01:10:55,000 –&gt; 01:10:56,000<br>and there was something,</p>
<p>1034<br>01:10:56,000 –&gt; 01:10:57,000<br>that was in DC,</p>
<p>1035<br>01:10:57,000 –&gt; 01:10:58,000<br>one that they did not support,</p>
<p>1036<br>01:10:58,000 –&gt; 01:10:59,000<br>Freud didn’t support.</p>
<p>1037<br>01:10:59,000 –&gt; 01:11:01,000<br>Yeah, so I guess,</p>
<p>1038<br>01:11:01,000 –&gt; 01:11:02,000<br>and you can explain this,</p>
<p>1039<br>01:11:02,000 –&gt; 01:11:04,000<br>but essentially the problem is that,</p>
<p>1040<br>01:11:04,000 –&gt; 01:11:05,000<br>when you get into the,</p>
<p>1041<br>01:11:05,000 –&gt; 01:11:07,000<br>and then you inline it,</p>
<p>1042<br>01:11:07,000 –&gt; 01:11:09,000<br>you get a very complicated sub query</p>
<p>1043<br>01:11:09,000 –&gt; 01:11:11,000<br>in a bunch of languages.</p>
<p>1044<br>01:11:11,000 –&gt; 01:11:12,000<br>And then,</p>
<p>1045<br>01:11:13,000 –&gt; 01:11:15,000<br>when you put that into the people sub and optimize them,</p>
<p>1046<br>01:11:15,000 –&gt; 01:11:18,000<br>it’s unable to be calling that sub query,</p>
<p>1047<br>01:11:18,000 –&gt; 01:11:20,000<br>and then you get that in that column.</p>
<p>1048<br>01:11:20,000 –&gt; 01:11:21,000<br>Oh, yeah.</p>
<p>1049<br>01:11:21,000 –&gt; 01:11:23,000<br>In ways that you use the German way,</p>
<p>1050<br>01:11:23,000 –&gt; 01:11:25,000<br>if you call it a sub query,</p>
<p>1051<br>01:11:25,000 –&gt; 01:11:27,000<br>you can be calling any sub query,</p>
<p>1052<br>01:11:27,000 –&gt; 01:11:29,000<br>and you get really good sub query to the line.</p>
<p>1053<br>01:11:29,000 –&gt; 01:11:30,000<br>Yes.</p>
<p>1054<br>01:11:30,000 –&gt; 01:11:31,000<br>We’ll cover that.</p>
<p>1055<br>01:11:31,000 –&gt; 01:11:34,000<br>We’ll cover this in more detail next week as well.</p>
<p>1056<br>01:11:34,000 –&gt; 01:11:38,000<br>All right, so this is the table we had in the paper,</p>
<p>1057<br>01:11:38,000 –&gt; 01:11:41,000<br>that we just came out two months ago,</p>
<p>1058<br>01:11:41,000 –&gt; 01:11:43,000<br>and we compared it against SQL Server Oracle,</p>
<p>1059<br>01:11:43,000 –&gt; 01:11:44,000<br>DuckDB, and Postgres.</p>
<p>1060<br>01:11:44,000 –&gt; 01:11:45,000<br>So Postgres, again,</p>
<p>1061<br>01:11:45,000 –&gt; 01:11:47,000<br>can’t handle any of these things, right?</p>
<p>1062<br>01:11:47,000 –&gt; 01:11:50,000<br>Because the optimizer is not as sophisticated as the commercial ones.</p>
<p>1063<br>01:11:50,000 –&gt; 01:11:52,000<br>Oracle will just ignore,</p>
<p>1064<br>01:11:52,000 –&gt; 01:11:54,000<br>but in the case of here DuckDB,</p>
<p>1065<br>01:11:54,000 –&gt; 01:11:55,000<br>well DuckDB got,</p>
<p>1066<br>01:11:55,000 –&gt; 01:11:57,000<br>you could handle everything.</p>
<p>1067<br>01:11:57,000 –&gt; 01:11:58,000<br>How’s that in the case?</p>
<p>1068<br>01:11:58,000 –&gt; 01:12:00,000<br>Well, because last year,</p>
<p>1069<br>01:12:00,000 –&gt; 01:12:02,000<br>the SAM 721 project with two other master students</p>
<p>1070<br>01:12:02,000 –&gt; 01:12:05,000<br>added support for flattening Nesr-Laddle joins</p>
<p>1071<br>01:12:05,000 –&gt; 01:12:08,000<br>so that they can support the inlining and the bashing stuff</p>
<p>1072<br>01:12:08,000 –&gt; 01:12:10,000<br>that we’ve been talking about.</p>
<p>1073<br>01:12:10,000 –&gt; 01:12:11,000<br>Oh, sorry.</p>
<p>1074<br>01:12:11,000 –&gt; 01:12:14,000<br>And furthermore, they actually submitted the PR to DuckDB,</p>
<p>1075<br>01:12:14,000 –&gt; 01:12:15,000<br>that actually got merged.</p>
<p>1076<br>01:12:15,000 –&gt; 01:12:16,000<br>When you download DuckDB,</p>
<p>1077<br>01:12:16,000 –&gt; 01:12:19,000<br>you’re getting SAMs and other 721 students code</p>
<p>1078<br>01:12:19,000 –&gt; 01:12:22,000<br>to handle the inlining stuff, right?</p>
<p>1079<br>01:12:22,000 –&gt; 01:12:24,000<br>Well, what about Microsoft, right?</p>
<p>1080<br>01:12:24,000 –&gt; 01:12:30,000<br>So inlining, you can see for these select UDS in Procbench,</p>
<p>1081<br>01:12:30,000 –&gt; 01:12:32,000<br>then the Microsoft benchmark base on their UDS,</p>
<p>1082<br>01:12:32,000 –&gt; 01:12:34,000<br>they can only handle two of them.</p>
<p>1083<br>01:12:34,000 –&gt; 01:12:36,000<br>So what’s going on?</p>
<p>1084<br>01:12:36,000 –&gt; 01:12:37,000<br>And the issue is that,</p>
<p>1085<br>01:12:37,000 –&gt; 01:12:39,000<br>because, as Sam already said,</p>
<p>1086<br>01:12:39,000 –&gt; 01:12:42,000<br>they are not as sophisticated as,</p>
<p>1087<br>01:12:42,000 –&gt; 01:12:44,000<br>their approach to decorulating subquers</p>
<p>1088<br>01:12:44,000 –&gt; 01:12:45,000<br>is not as sophisticated as,</p>
<p>1089<br>01:12:45,000 –&gt; 01:12:48,000<br>this German approach of which we keep alluding to.</p>
<p>1090<br>01:12:48,000 –&gt; 01:12:51,000<br>And so they’re going to basically have these handwritten rules</p>
<p>1091<br>01:12:51,000 –&gt; 01:12:54,000<br>that allow you to do the rewriting inside the query optimizer</p>
<p>1092<br>01:12:54,000 –&gt; 01:12:57,000<br>for different use cases,</p>
<p>1093<br>01:12:57,000 –&gt; 01:12:59,000<br>but not all of them.</p>
<p>1094<br>01:12:59,000 –&gt; 01:13:02,000<br>And this paper came out in 2001.</p>
<p>1095<br>01:13:02,000 –&gt; 01:13:05,000<br>It’s before Freud and these computer-generated,</p>
<p>1096<br>01:13:05,000 –&gt; 01:13:07,000<br>you know, monstrosity queries</p>
<p>1097<br>01:13:07,000 –&gt; 01:13:10,000<br>and all these lateral drawings existed.</p>
<p>1098<br>01:13:10,000 –&gt; 01:13:12,000<br>So they didn’t, I guess they didn’t,</p>
<p>1099<br>01:13:12,000 –&gt; 01:13:15,000<br>they didn’t know, these things at the time,</p>
<p>1100<br>01:13:15,000 –&gt; 01:13:17,000<br>they didn’t try to cover them in their rule base,</p>
<p>1101<br>01:13:17,000 –&gt; 01:13:19,000<br>and they haven’t updated it since then.</p>
<p>1102<br>01:13:19,000 –&gt; 01:13:21,000<br>So in this case here, Microsoft is simply,</p>
<p>1103<br>01:13:21,000 –&gt; 01:13:25,000<br>the sequencer, we simply can’t handle the kind of monstrosity queries</p>
<p>1104<br>01:13:25,000 –&gt; 01:13:29,000<br>that something like Freud or Opfel is going to generate.</p>
<p>1105<br>01:13:29,000 –&gt; 01:13:31,000<br>And so the German approach,</p>
<p>1106<br>01:13:31,000 –&gt; 01:13:32,000<br>which we’ll see next week,</p>
<p>1107<br>01:13:32,000 –&gt; 01:13:36,000<br>it can handle any possible, you know,</p>
<p>1108<br>01:13:36,000 –&gt; 01:13:39,000<br>de-query relation for subquers,</p>
<p>1109<br>01:13:39,000 –&gt; 01:13:41,000<br>because one, they’re going to be able to,</p>
<p>1110<br>01:13:41,000 –&gt; 01:13:44,000<br>there’s a more DAGs instead of trees in the query plans,</p>
<p>1111<br>01:13:44,000 –&gt; 01:13:46,000<br>because allows them reuse the computation</p>
<p>1112<br>01:13:46,000 –&gt; 01:13:49,000<br>for one nested query for another part of a query,</p>
<p>1113<br>01:13:49,000 –&gt; 01:13:52,000<br>and they’ll introduce these additional constructs</p>
<p>1114<br>01:13:52,000 –&gt; 01:13:54,000<br>like a dependent join to keep track of the dependencies</p>
<p>1115<br>01:13:54,000 –&gt; 01:13:57,000<br>between, you know, two different ware clauses</p>
<p>1116<br>01:13:57,000 –&gt; 01:13:58,000<br>from clauses and so forth.</p>
<p>1117<br>01:13:58,000 –&gt; 01:14:01,000<br>And therefore they can take any possible subquery combination</p>
<p>1118<br>01:14:01,000 –&gt; 01:14:03,000<br>you can think of, and throw it at the query optimizer,</p>
<p>1119<br>01:14:03,000 –&gt; 01:14:06,000<br>and it’ll be able to handle this.</p>
<p>1120<br>01:14:06,000 –&gt; 01:14:09,000<br>Dr. Bee can do this, because they’re based off of what,</p>
<p>1121<br>01:14:09,000 –&gt; 01:14:11,000<br>what Umbra did, or hyper did,</p>
<p>1122<br>01:14:11,000 –&gt; 01:14:13,000<br>and then Sam and his team came along and extended</p>
<p>1123<br>01:14:13,000 –&gt; 01:14:16,000<br>for the lateral join stuff that we needed.</p>
<p>1124<br>01:14:16,000 –&gt; 01:14:19,000<br>So that’s the preview for next week, right?</p>
<p>1125<br>01:14:19,000 –&gt; 01:14:20,000<br>We’re going to talk about why,</p>
<p>1126<br>01:14:20,000 –&gt; 01:14:24,000<br>how this works in hyper.</p>
<p>1127<br>01:14:24,000 –&gt; 01:14:28,000<br>So the main takeaway, going back to, you know,</p>
<p>1128<br>01:14:28,000 –&gt; 01:14:29,000<br>this table here,</p>
<p>1129<br>01:14:29,000 –&gt; 01:14:31,000<br>inlining is fantastic,</p>
<p>1130<br>01:14:31,000 –&gt; 01:14:34,000<br>but if your database server query optimizer can handle</p>
<p>1131<br>01:14:34,000 –&gt; 01:14:37,000<br>the large queries that these things are going to spit out,</p>
<p>1132<br>01:14:37,000 –&gt; 01:14:41,000<br>and few can.</p>
<p>1133<br>01:14:41,000 –&gt; 01:14:45,000<br>Okay, so, again, I said this before,</p>
<p>1134<br>01:14:45,000 –&gt; 01:14:48,000<br>but like this is a big deal if you can get,</p>
<p>1135<br>01:14:48,000 –&gt; 01:14:50,000<br>if your query optimizer can handle the kind of things</p>
<p>1136<br>01:14:50,000 –&gt; 01:14:52,000<br>that that outfell or forward is going to generate,</p>
<p>1137<br>01:14:52,000 –&gt; 01:14:55,000<br>then you get a huge win for speeding up a UDS</p>
<p>1138<br>01:14:55,000 –&gt; 01:14:58,000<br>without making any changes to your application code.</p>
<p>1139<br>01:14:58,000 –&gt; 01:15:01,000<br>And that rarely happens in the world CS or, you know,</p>
<p>1140<br>01:15:01,000 –&gt; 01:15:03,000<br>software.</p>
<p>1141<br>01:15:03,000 –&gt; 01:15:04,000<br>So that’s a big deal, but again, you need to be,</p>
<p>1142<br>01:15:04,000 –&gt; 01:15:06,000<br>sort of, the German style, the Umbra style,</p>
<p>1143<br>01:15:06,000 –&gt; 01:15:09,000<br>a de-coilation.</p>
<p>1144<br>01:15:09,000 –&gt; 01:15:12,000<br>The, we talked a little bit about how to compile the machine code.</p>
<p>1145<br>01:15:12,000 –&gt; 01:15:14,000<br>This is going to help some,</p>
<p>1146<br>01:15:14,000 –&gt; 01:15:16,000<br>some, some performance slow down,</p>
<p>1147<br>01:15:16,000 –&gt; 01:15:18,000<br>but again, since it’s still going to look at a black box</p>
<p>1148<br>01:15:18,000 –&gt; 01:15:20,000<br>to the optimizer, it’s, you know,</p>
<p>1149<br>01:15:20,000 –&gt; 01:15:21,000<br>it’s not going to be the,</p>
<p>1150<br>01:15:21,000 –&gt; 01:15:24,000<br>not going to get the best performance.</p>
<p>1151<br>01:15:24,000 –&gt; 01:15:27,000<br>All right, any questions?</p>
<p>1152<br>01:15:27,000 –&gt; 01:15:28,000<br>Yes.</p>
<p>1153<br>01:15:28,000 –&gt; 01:15:30,000<br>So, this is some, some, some, some time.</p>
<p>1154<br>01:15:30,000 –&gt; 01:15:32,000<br>Can I ask a question about the code that we looked at</p>
<p>1155<br>01:15:32,000 –&gt; 01:15:34,000<br>for the conversion?</p>
<p>1156<br>01:15:34,000 –&gt; 01:15:35,000<br>Sure, yes.</p>
<p>1157<br>01:15:35,000 –&gt; 01:15:37,000<br>I mean, this one?</p>
<p>1158<br>01:15:37,000 –&gt; 01:15:38,000<br>Yes?</p>
<p>1159<br>01:15:38,000 –&gt; 01:15:40,000<br>No, actually the one that we do get from this,</p>
<p>1160<br>01:15:40,000 –&gt; 01:15:41,000<br>the Freud example.</p>
<p>1161<br>01:15:41,000 –&gt; 01:15:44,000<br>Oh.</p>
<p>1162<br>01:15:46,000 –&gt; 01:15:48,000<br>So they’re going, going back to like this?</p>
<p>1163<br>01:15:48,000 –&gt; 01:15:49,000<br>Yeah.</p>
<p>1164<br>01:15:49,000 –&gt; 01:15:52,000<br>I was thinking this might actually not be possible if we have,</p>
<p>1165<br>01:15:52,000 –&gt; 01:15:53,000<br>instead of that else clause, right there,</p>
<p>1166<br>01:15:53,000 –&gt; 01:15:54,000<br>the third one.</p>
<p>1167<br>01:15:54,000 –&gt; 01:15:58,000<br>If we replace that else with a simple if condition,</p>
<p>1168<br>01:15:58,000 –&gt; 01:16:02,000<br>like that just says if at total is less than a million,</p>
<p>1169<br>01:16:02,000 –&gt; 01:16:04,000<br>I can not move here, a million.</p>
<p>1170<br>01:16:04,000 –&gt; 01:16:08,000<br>In that case, if you look at the block over there,</p>
<p>1171<br>01:16:08,000 –&gt; 01:16:10,000<br>it says ER2.level,</p>
<p>1172<br>01:16:10,000 –&gt; 01:16:13,000<br>it won’t be able to do ER2.level.</p>
<p>1173<br>01:16:13,000 –&gt; 01:16:15,000<br>It will need to do ER1 or ER2,</p>
<p>1174<br>01:16:15,000 –&gt; 01:16:18,000<br>depending on when that condition is true.</p>
<p>1175<br>01:16:18,000 –&gt; 01:16:20,000<br>So it will become,</p>
<p>1176<br>01:16:20,000 –&gt; 01:16:23,000<br>it won’t easily translate from the left to the right.</p>
<p>1177<br>01:16:24,000 –&gt; 01:16:26,000<br>So the statement is, if you have it now inside of this,</p>
<p>1178<br>01:16:26,000 –&gt; 01:16:28,000<br>another if it’s nested if calls.</p>
<p>1179<br>01:16:28,000 –&gt; 01:16:29,000<br>No, not nested.</p>
<p>1180<br>01:16:29,000 –&gt; 01:16:31,000<br>You should replace the else with this,</p>
<p>1181<br>01:16:31,000 –&gt; 01:16:32,000<br>this is the place the else is.</p>
<p>1182<br>01:16:32,000 –&gt; 01:16:34,000<br>Oh, so this if ends.</p>
<p>1183<br>01:16:34,000 –&gt; 01:16:35,000<br>No.</p>
<p>1184<br>01:16:35,000 –&gt; 01:16:36,000<br>Then you have another if.</p>
<p>1185<br>01:16:36,000 –&gt; 01:16:37,000<br>Yes.</p>
<p>1186<br>01:16:37,000 –&gt; 01:16:39,000<br>And then in that case,</p>
<p>1187<br>01:16:39,000 –&gt; 01:16:43,000<br>if it’s less than a million,</p>
<p>1188<br>01:16:43,000 –&gt; 01:16:45,000<br>set it to regular.</p>
<p>1189<br>01:16:45,000 –&gt; 01:16:46,000<br>Right.</p>
<p>1190<br>01:16:46,000 –&gt; 01:16:48,000<br>And then in that case, implicitly then,</p>
<p>1191<br>01:16:48,000 –&gt; 01:16:52,000<br>the value is ER1, which is null.</p>
<p>1192<br>01:16:52,000 –&gt; 01:16:55,000<br>It happens, or it gets confused.</p>
<p>1193<br>01:16:55,000 –&gt; 01:16:57,000<br>And that’s how it’s actually successful,</p>
<p>1194<br>01:16:57,000 –&gt; 01:16:59,000<br>because you don’t know anything about the initial.</p>
<p>1195<br>01:16:59,000 –&gt; 01:17:01,000<br>More of the exhaust flow trenches,</p>
<p>1196<br>01:17:01,000 –&gt; 01:17:03,000<br>and you have an initialized,</p>
<p>1197<br>01:17:03,000 –&gt; 01:17:04,000<br>or a bubble action.</p>
<p>1198<br>01:17:04,000 –&gt; 01:17:05,000<br>Exactly.</p>
<p>1199<br>01:17:05,000 –&gt; 01:17:06,000<br>How will it happen?</p>
<p>1200<br>01:17:06,000 –&gt; 01:17:07,000<br>But the initial,</p>
<p>1201<br>01:17:07,000 –&gt; 01:17:09,000<br>the level is initialized as null.</p>
<p>1202<br>01:17:09,000 –&gt; 01:17:12,000<br>At the top, so you just manage to return null.</p>
<p>1203<br>01:17:17,000 –&gt; 01:17:18,000<br>Okay.</p>
<p>1204<br>01:17:18,000 –&gt; 01:17:20,000<br>You see what I know that is that ER2,</p>
<p>1205<br>01:17:20,000 –&gt; 01:17:21,000<br>right?</p>
<p>1206<br>01:17:21,000 –&gt; 01:17:22,000<br>Yes.</p>
<p>1207<br>01:17:22,000 –&gt; 01:17:23,000<br>One problem is that ER2.</p>
<p>1208<br>01:17:23,000 –&gt; 01:17:24,000<br>No, I’m getting that.</p>
<p>1209<br>01:17:24,000 –&gt; 01:17:25,000<br>Yes.</p>
<p>1210<br>01:17:25,000 –&gt; 01:17:29,000<br>That one will have some full-length change.</p>
<p>1211<br>01:17:29,000 –&gt; 01:17:30,000<br>Yeah, that’s okay.</p>
<p>1212<br>01:17:30,000 –&gt; 01:17:31,000<br>You can call it ER1.</p>
<p>1213<br>01:17:31,000 –&gt; 01:17:35,000<br>But that’s not the logic that the UDF would</p>
<p>1214<br>01:17:35,000 –&gt; 01:17:37,000<br>be trying to represent here, right?</p>
<p>1215<br>01:17:37,000 –&gt; 01:17:39,000<br>So if level less than a million,</p>
<p>1216<br>01:17:39,000 –&gt; 01:17:41,000<br>set the regular, right?</p>
<p>1217<br>01:17:41,000 –&gt; 01:17:45,000<br>So that would just be similar to this.</p>
<p>1218<br>01:17:45,000 –&gt; 01:17:46,000<br>Right.</p>
<p>1219<br>01:17:46,000 –&gt; 01:17:49,000<br>I see what you’re saying,</p>
<p>1220<br>01:17:49,000 –&gt; 01:17:50,000<br>because there would be…</p>
<p>1221<br>01:17:50,000 –&gt; 01:17:52,000<br>It’s changed in ER2.</p>
<p>1222<br>01:17:52,000 –&gt; 01:17:54,000<br>And we want to activate ER2 if…</p>
<p>1223<br>01:17:54,000 –&gt; 01:17:55,000<br>Yeah.</p>
<p>1224<br>01:17:55,000 –&gt; 01:17:56,000<br>The division is true.</p>
<p>1225<br>01:17:56,000 –&gt; 01:17:58,000<br>Or we want to access ER1.</p>
<p>1226<br>01:17:58,000 –&gt; 01:17:59,000<br>Level if a different division.</p>
<p>1227<br>01:17:59,000 –&gt; 01:18:01,000<br>I understand your point.</p>
<p>1228<br>01:18:01,000 –&gt; 01:18:04,000<br>Do you get to imagine…</p>
<p>1229<br>01:18:04,000 –&gt; 01:18:05,000<br>I don’t know if it does this.</p>
<p>1230<br>01:18:05,000 –&gt; 01:18:08,000<br>Do you get to imagine it’s combining them if and else?</p>
<p>1231<br>01:18:08,000 –&gt; 01:18:09,000<br>I can’t guess it.</p>
<p>1232<br>01:18:09,000 –&gt; 01:18:10,000<br>Go for it.</p>
<p>1233<br>01:18:10,000 –&gt; 01:18:11,000<br>Yes.</p>
<p>1234<br>01:18:11,000 –&gt; 01:18:14,000<br>So basically the idea is you’ll have one table</p>
<p>1235<br>01:18:14,000 –&gt; 01:18:16,000<br>which will have the column with normal.</p>
<p>1236<br>01:18:16,000 –&gt; 01:18:17,000<br>Right.</p>
<p>1237<br>01:18:17,000 –&gt; 01:18:19,000<br>And then you have another table,</p>
<p>1238<br>01:18:19,000 –&gt; 01:18:20,000<br>which is going to say,</p>
<p>1239<br>01:18:20,000 –&gt; 01:18:22,000<br>okay, if this condition is true,</p>
<p>1240<br>01:18:22,000 –&gt; 01:18:24,000<br>then it’s just due to our use.</p>
<p>1241<br>01:18:24,000 –&gt; 01:18:27,000<br>Otherwise, it’s the level from the previous table.</p>
<p>1242<br>01:18:27,000 –&gt; 01:18:28,000<br>Right.</p>
<p>1243<br>01:18:28,000 –&gt; 01:18:31,000<br>And you can follow and currently keep doing this.</p>
<p>1244<br>01:18:31,000 –&gt; 01:18:34,000<br>So each thing is just a region that returns to the column</p>
<p>1245<br>01:18:34,000 –&gt; 01:18:35,000<br>from the previous table.</p>
<p>1246<br>01:18:35,000 –&gt; 01:18:38,000<br>So it’s basically doing the opposite.</p>
<p>1247<br>01:18:38,000 –&gt; 01:18:40,000<br>Okay.</p>
<p>1248<br>01:18:40,000 –&gt; 01:18:42,000<br>And use another case within this lecture.</p>
<p>1249<br>01:18:42,000 –&gt; 01:18:44,000<br>We can choose between those.</p>
<p>1250<br>01:18:44,000 –&gt; 01:18:45,000<br>Okay.</p>
<p>1251<br>01:18:45,000 –&gt; 01:18:46,000<br>Right.</p>
<p>1252<br>01:18:46,000 –&gt; 01:18:47,000<br>Okay.</p>
<p>1253<br>01:18:47,000 –&gt; 01:18:48,000<br>We are over time.</p>
<p>1254<br>01:18:48,000 –&gt; 01:18:51,000<br>So let me jump to…</p>
<p>1255<br>01:18:51,000 –&gt; 01:18:53,000<br>All right.</p>
<p>1256<br>01:18:53,000 –&gt; 01:18:54,000<br>So next class, which is what…</p>
<p>1257<br>01:18:54,000 –&gt; 01:18:55,000<br>Debate is doing the conducting protocols.</p>
<p>1258<br>01:18:55,000 –&gt; 01:19:00,000<br>And the reason why I’m doing this after UDS is because this UDF idea is like,</p>
<p>1259<br>01:19:00,000 –&gt; 01:19:02,000<br>okay, I have my application logic.</p>
<p>1260<br>01:19:02,000 –&gt; 01:19:04,000<br>Let me try to embed that in the database server.</p>
<p>1261<br>01:19:04,000 –&gt; 01:19:06,000<br>The arrow guys and ductyb guys are saying,</p>
<p>1262<br>01:19:06,000 –&gt; 01:19:08,000<br>no, no, no, no, it’s actually the opposite.</p>
<p>1263<br>01:19:08,000 –&gt; 01:19:12,000<br>Embed your database system inside of your application.</p>
<p>1264<br>01:19:12,000 –&gt; 01:19:16,000<br>And then use something like arrow to get the data in and out very quickly.</p>
<p>1265<br>01:19:16,000 –&gt; 01:19:17,000<br>Okay.</p>
<p>1266<br>01:19:17,000 –&gt; 01:19:20,000<br>So the paper you’ll read is from the ductyb guys.</p>
<p>1267<br>01:19:20,000 –&gt; 01:19:23,000<br>I think it’s on Monday to be like, before ductyb was invented.</p>
<p>1268<br>01:19:23,000 –&gt; 01:19:27,000<br>But it’s basically showing how terrible existing networking protocols are for database servers</p>
<p>1269<br>01:19:27,000 –&gt; 01:19:30,000<br>and how that, for OLAB queries, it’s not the ideal.</p>
<p>1270<br>01:19:30,000 –&gt; 01:19:35,000<br>And then we’ll see how arrow will fix this and then another project out of size.</p>
<p>1271<br>01:19:35,000 –&gt; 01:19:37,000<br>So, I’m going to project out of Simon Frage of University.</p>
<p>1272<br>01:19:37,000 –&gt; 01:19:38,000<br>Okay?</p>
<p>1273<br>01:19:38,000 –&gt; 01:19:39,000<br>All right guys.</p>
<p>1274<br>01:19:39,000 –&gt; 01:19:40,000<br>See ya.</p>
<p>1275<br>01:20:05,000 –&gt; 01:20:07,000<br>Okay.</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CMU15721 P12S202411 User DefinedFunctionOptimizationsCMUAdvancedDatabaseSystems</div>
      <div>http://example.com/2025/10/25/CMU15721 P12S202411-User-DefinedFunctionOptimizationsCMUAdvancedDatabaseSystems/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/25/CMU15721%20P14S202413-QueryOptimizerImplementation1CMUAdvancedDatabaseSystems/" title="CMU15721 P14S202413 QueryOptimizerImplementation1CMUAdvancedDatabaseSystems">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CMU15721 P14S202413 QueryOptimizerImplementation1CMUAdvancedDatabaseSystems</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/25/CMU15721%20P13S202412-DatabaseNetworkingProtocolsCMUAdvancedDatabaseSystems/" title="CMU15721 P13S202412 DatabaseNetworkingProtocolsCMUAdvancedDatabaseSystems">
                        <span class="hidden-mobile">CMU15721 P13S202412 DatabaseNetworkingProtocolsCMUAdvancedDatabaseSystems</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
