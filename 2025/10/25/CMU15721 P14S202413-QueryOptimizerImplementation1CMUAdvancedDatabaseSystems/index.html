

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="100:00:00,000 –&gt; 00:00:06,000Canneke Mellon University’s advanced database systems courses 200:00:06,000 –&gt; 00:00:09,000filming front of the live studio audience. 300:00:09,000 –&gt; 00:00:10,00">
<meta property="og:type" content="article">
<meta property="og:title" content="CMU15721 P14S202413 QueryOptimizerImplementation1CMUAdvancedDatabaseSystems">
<meta property="og:url" content="http://example.com/2025/10/25/CMU15721%20P14S202413-QueryOptimizerImplementation1CMUAdvancedDatabaseSystems/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="100:00:00,000 –&gt; 00:00:06,000Canneke Mellon University’s advanced database systems courses 200:00:06,000 –&gt; 00:00:09,000filming front of the live studio audience. 300:00:09,000 –&gt; 00:00:10,00">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-25T05:03:39.748Z">
<meta property="article:modified_time" content="2025-10-25T05:03:39.749Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>CMU15721 P14S202413 QueryOptimizerImplementation1CMUAdvancedDatabaseSystems - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CMU15721 P14S202413 QueryOptimizerImplementation1CMUAdvancedDatabaseSystems"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-25 13:03" pubdate>
          2025年10月25日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          8.7k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          73 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">CMU15721 P14S202413 QueryOptimizerImplementation1CMUAdvancedDatabaseSystems</h1>
            
            
              <div class="markdown-body">
                
                <p>1<br>00:00:00,000 –&gt; 00:00:06,000<br>Canneke Mellon University’s advanced database systems courses</p>
<p>2<br>00:00:06,000 –&gt; 00:00:09,000<br>filming front of the live studio audience.</p>
<p>3<br>00:00:09,000 –&gt; 00:00:10,000<br>Hi.</p>
<p>4<br>00:00:10,000 –&gt; 00:00:20,000<br>So today’s class, I’m going to try to get as much as I can into today’s lecture.</p>
<p>5<br>00:00:20,000 –&gt; 00:00:24,000<br>It might spill over a little bit into next class, but this is it.</p>
<p>6<br>00:00:24,000 –&gt; 00:00:26,000<br>We’ve been talking about this for a long time.</p>
<p>7<br>00:00:26,000 –&gt; 00:00:30,000<br>We’re finally getting to discussing how we actually want to build the query optimizer,</p>
<p>8<br>00:00:30,000 –&gt; 00:00:34,000<br>which is the arguably the most important part of a data management system.</p>
<p>9<br>00:00:34,000 –&gt; 00:00:40,000<br>Every year I debate whether to even bother teaching 721 and just teach a topic course on query optimization.</p>
<p>10<br>00:00:40,000 –&gt; 00:00:43,000<br>Admittedly, this is the part of data business that I know the least about.</p>
<p>11<br>00:00:43,000 –&gt; 00:00:46,000<br>For people that are actually working on the query optimizer here,</p>
<p>12<br>00:00:46,000 –&gt; 00:00:49,000<br>at this point you guys probably know more than I do.</p>
<p>13<br>00:00:49,000 –&gt; 00:00:53,000<br>But this is the hardest piece because obviously we can build the fastest engine,</p>
<p>14<br>00:00:53,000 –&gt; 00:00:57,000<br>but if our query plans are terrible, then it’s all wasted.</p>
<p>15<br>00:00:57,000 –&gt; 00:01:00,000<br>You okay?</p>
<p>16<br>00:01:00,000 –&gt; 00:01:02,000<br>Okay.</p>
<p>17<br>00:01:02,000 –&gt; 00:01:03,000<br>Alright.</p>
<p>18<br>00:01:03,000 –&gt; 00:01:09,000<br>Alright, so this refresher last class we were talking about networking protocols.</p>
<p>19<br>00:01:09,000 –&gt; 00:01:14,000<br>And again, the main takeaway from this discussion was it looks and smells a lot like</p>
<p>20<br>00:01:14,000 –&gt; 00:01:16,000<br>when we talked about storage on disk.</p>
<p>21<br>00:01:16,000 –&gt; 00:01:20,000<br>If we have a, if our application is going on queries,</p>
<p>22<br>00:01:20,000 –&gt; 00:01:25,000<br>it really cares about a small number of tuples, then a row-oriented API or network protocol</p>
<p>23<br>00:01:25,000 –&gt; 00:01:33,000<br>that’s going over a row-oriented API or row-oriented network protocol that’s being accessed through a row-oriented API,</p>
<p>24<br>00:01:33,000 –&gt; 00:01:36,000<br>like ODBC or GDBC, that’s going to be sufficient.</p>
<p>25<br>00:01:36,000 –&gt; 00:01:40,000<br>But when we start doing queries that want to get a lot of data out of the data system,</p>
<p>26<br>00:01:40,000 –&gt; 00:01:44,000<br>or do bulk export, then we want to use something that looks,</p>
<p>27<br>00:01:44,000 –&gt; 00:01:48,000<br>that’s a column art, take advantage of all the things we talked about before.</p>
<p>28<br>00:01:48,000 –&gt; 00:01:53,000<br>And as I said, the arrow data’s connectivity library is one that facilitate that.</p>
<p>29<br>00:01:53,000 –&gt; 00:01:59,000<br>I think that’s the future of overlap systems are all going to support this if they don’t already.</p>
<p>30<br>00:01:59,000 –&gt; 00:02:02,000<br>And so as I said already, the next two weeks is related to our query optimization.</p>
<p>31<br>00:02:02,000 –&gt; 00:02:08,000<br>So today’s class and next class we’ll be talking about how you actually want to implement the optimizer itself</p>
<p>32<br>00:02:08,000 –&gt; 00:02:12,000<br>at a high level, like how you’re going to define the rules,</p>
<p>33<br>00:02:12,000 –&gt; 00:02:16,000<br>how you then do the search to figure out what transformations you want to apply to optimize things.</p>
<p>34<br>00:02:17,000 –&gt; 00:02:21,000<br>We’ll talk a little bit about query writing and obviously planing the operation as part of this.</p>
<p>35<br>00:02:21,000 –&gt; 00:02:23,000<br>Cost models will discuss more next week.</p>
<p>36<br>00:02:23,000 –&gt; 00:02:32,000<br>Next class will be, sorry, next week, we’ll then talk about, sorry, next class will be further into the dynamic programming approach</p>
<p>37<br>00:02:32,000 –&gt; 00:02:35,000<br>that’s used by hyper and umber from the Germans.</p>
<p>38<br>00:02:35,000 –&gt; 00:02:39,000<br>And then on Monday next week we’ll talk about doing adaptive query optimization.</p>
<p>39<br>00:02:39,000 –&gt; 00:02:43,000<br>Like the query runs for bit and you make decisions on the fly whether it’s changed things.</p>
<p>40<br>00:02:43,000 –&gt; 00:02:45,000<br>And then that’ll feed into the cost model discussion in next week.</p>
<p>41<br>00:02:45,000 –&gt; 00:02:51,000<br>So the next two weeks is getting purely on uh on query optimization because again it’s super important.</p>
<p>42<br>00:02:51,000 –&gt; 00:02:53,000<br>So what do we care about in this scope?</p>
<p>43<br>00:02:53,000 –&gt; 00:03:01,000<br>So this is obviously a refresher from the intro class but the goal of the Davies systems query optimizer sometimes called the query planner,</p>
<p>44<br>00:03:01,000 –&gt; 00:03:08,000<br>sometimes called the query compiler if you’re if you’re an older system or an old person right because that that’s a remnant of the 1970s</p>
<p>45<br>00:03:08,000 –&gt; 00:03:15,000<br>when the original model came along by the idea of taking a high level language like SQL and and converting it into a low level,</p>
<p>46<br>00:03:15,000 –&gt; 00:03:19,000<br>not assembly but execution instructions to run the query.</p>
<p>47<br>00:03:19,000 –&gt; 00:03:28,000<br>Like they saw that being akin to writing a high level language like C because C was considered high super high level back in the day and converting that into a low level assembly or machine code.</p>
<p>48<br>00:03:29,000 –&gt; 00:03:42,000<br>So the idea of the query optimizer is that we want to generate a for a given query, we want to generate a a correct physical plan that will execute that query ideally with the lowest cost.</p>
<p>49<br>00:03:42,000 –&gt; 00:03:53,000<br>And I’m underlying the the word correct here because obviously it doesn’t matter if we have this super fast query plan if it does not actually produce the result that we want then it’s you know it’s useless.</p>
<p>50<br>00:03:54,000 –&gt; 00:04:03,000<br>For that one we get an or approximate query processing stuff. We really want an exact match we’re given SQL query we’re going to use the exact output.</p>
<p>51<br>00:04:03,000 –&gt; 00:04:15,000<br>And the cost is in quotes because as we’ll see next week this is going to be a relative term that’s going to get it’s going to change depending on a on the system itself that’s actually implementing this.</p>
<p>52<br>00:04:15,000 –&gt; 00:04:28,000<br>So the cost is going to be some internal metric that we can use to compare one plan to another and decide this one’s better than another based on number two bulls red or CPU instructions used or network traffic.</p>
<p>53<br>00:04:28,000 –&gt; 00:04:37,000<br>And again that’s going to change from from one system to the next and typically this cost is not usually mapped to something in the real world like like runtime.</p>
<p>54<br>00:04:37,000 –&gt; 00:04:44,000<br>Some of the enterprise systems I know DB2 can do this where they’re actually spit out this query is expected to run this long.</p>
<p>55<br>00:04:44,000 –&gt; 00:04:55,000<br>But here I look like post dresses output of explain analyze or SQL light or other systems it’s always going to be some number that does that’s meaningless outside of that system.</p>
<p>56<br>00:04:56,000 –&gt; 00:05:07,000<br>So the as I said before this is going to be the hardest part of the system just picking the joiner is proving to be I think MP hard but the whole the whole problem of thinking of what’s the optimal query plan is is MP complete.</p>
<p>57<br>00:05:07,000 –&gt; 00:05:24,000<br>And so that means that despite the name optimizer we’re never almost never going to really find the true optimal plan right if it’s something really stupid like select one semi colon right that one actually that that usually didn’t get past the optimizer like some systems or recognize that immediately send you back for the result doesn’t execute it like they they’re not going to be able to do that.</p>
<p>58<br>00:05:24,000 –&gt; 00:05:28,000<br>So we’re not going to execute it like they’re a little short circuit it.</p>
<p>59<br>00:05:28,000 –&gt; 00:05:35,000<br>But for for things like looking up on a single index on one table like yeah that will be optimal because we know how to find exactly what we want.</p>
<p>60<br>00:05:35,000 –&gt; 00:05:41,000<br>But once we start adding joins that’s when things get really tricky.</p>
<p>61<br>00:05:41,000 –&gt; 00:06:01,000<br>And so because we can’t find the we can’t do an exhaustive search to find optimal plan we’re going to have to use a bunch of methods to just trim down the number of choices we had to consider and try to guide the optimizer towards a good plan right because we can’t we can’t prove that it’s going to be optimal.</p>
<p>62<br>00:06:01,000 –&gt; 00:06:20,000<br>And then because it is too expensive to for all these possible choices we could have to actually run them to see whether they you know what their cost actually is this is with a cost model is going to help us speak things up but it’s going to be an estimation of what we think the the systems actually going to do when encounters real data that you’re targeting.</p>
<p>63<br>00:06:20,000 –&gt; 00:06:29,000<br>So this is going to be super super hard and I’ll try to break it down and walk through the different approaches that were discussing the paper you guys were assigned.</p>
<p>64<br>00:06:29,000 –&gt; 00:06:44,000<br>And the old joke for query optimization is like if say you want to be a rocket scientist sorry other way around if you want to be working query optimizers and you can’t hack it and it doesn’t work out then the backup plan could be rocket science because query optimization is considered harder than rocket science.</p>
<p>65<br>00:06:44,000 –&gt; 00:06:50,000<br>Of course you know database don’t blow things up in the air so maybe that’s a debate.</p>
<p>66<br>00:06:50,000 –&gt; 00:07:04,000<br>Okay. So the important thing not to say nested to is the distinction between a logical plan and the physical plan and the terms are going to be sometimes conflated in the earlier optimizer optimizer and</p>
<p>67<br>00:07:04,000 –&gt; 00:07:20,000<br>the conditions we’re going to see because they might not even have logical plans they’ll go immediately from like a sequel query into physical plans but the cascades approach and the stratified search from starbursts that we’ll see in a second they’ll have a clean clean distinction between the logical and physical plan.</p>
<p>68<br>00:07:20,000 –&gt; 00:07:31,000<br>And so the idea of the logical plan is the high level operators we want we want to execute for a query based on something that looks like relational algebra.</p>
<p>69<br>00:07:31,000 –&gt; 00:07:40,000<br>Like I want to scan this table I want to join these two tables but it’s not specifying what actual algorithm you want to use to execute those different operators.</p>
<p>70<br>00:07:40,000 –&gt; 00:07:53,000<br>So the optimizer is going to take a the parse tree from the from the sequel query that shows up do some transformation to convert that into logical plans that represent what that that sequel query was trying to do.</p>
<p>71<br>00:07:53,000 –&gt; 00:08:07,000<br>And then now it can do further optimizations or further transformations of those logical plans into new logical plans or it can convert the logical plans into physical operators a physical plan that will define how we actually want to execute things.</p>
<p>72<br>00:08:07,000 –&gt; 00:08:12,000<br>And this physical plan can oftentimes will depend on what the data actually looks like on disk.</p>
<p>73<br>00:08:12,000 –&gt; 00:08:17,000<br>Do we expect things to be sorted is it going to be processed a certain way.</p>
<p>74<br>00:08:17,000 –&gt; 00:08:23,000<br>And the you know it will specify also again what algorithm want to use to produce that result.</p>
<p>75<br>00:08:23,000 –&gt; 00:08:28,000<br>So we’re not always going to have a one to one mapping from a logical operator to a physical operator.</p>
<p>76<br>00:08:28,000 –&gt; 00:08:34,000<br>Like you could have a logical join a logical order by could be combined together into a physical sort merge join.</p>
<p>77<br>00:08:34,000 –&gt; 00:08:43,000<br>But once you’re in a physical form you typically don’t like a physical operator form you typically don’t don’t convert that back to logical that doesn’t make sense.</p>
<p>78<br>00:08:43,000 –&gt; 00:08:47,000<br>And that’s a explodes in search base if you actually want to consider something like that.</p>
<p>79<br>00:08:47,000 –&gt; 00:08:52,000<br>So it’s mostly logical logical or logical physical.</p>
<p>80<br>00:08:52,000 –&gt; 00:09:01,000<br>And this I’ve already said but again the cost estimation is how we’re going to use what we’re going to use internally to figure out what whether one query plan is going to be better than another during our search process.</p>
<p>81<br>00:09:01,000 –&gt; 00:09:10,000<br>Again we’ll talk about this next week but basically it’s going to be a combination of these different metrics like how much data I think I’m going to read from disk or read from from my for my child operator.</p>
<p>82<br>00:09:10,000 –&gt; 00:09:17,000<br>How much data I’m going to spit out based on the selectivity of the cardinality of any operations I’m doing on that data as it comes in.</p>
<p>83<br>00:09:17,000 –&gt; 00:09:21,000<br>Is the data skewed is a compress where it’s actually physically located.</p>
<p>84<br>00:09:21,000 –&gt; 00:09:26,000<br>All these things we have to consider to have a true cost estimate but it’s never going to be exactly perfect.</p>
<p>85<br>00:09:26,000 –&gt; 00:09:35,000<br>And the paper you guys read next week from the Germans will show you that once you do like two joins then all these estimates get way out of whack.</p>
<p>86<br>00:09:35,000 –&gt; 00:09:43,000<br>And the query optimizer the cost model estimates will be woefully underestimating the amount of tubos that are coming out.</p>
<p>87<br>00:09:43,000 –&gt; 00:09:47,000<br>And so again it’ll lead it to choose an incorrect plan.</p>
<p>88<br>00:09:47,000 –&gt; 00:09:51,000<br>So today we’re going to try to get through all five hundred approaches you could have.</p>
<p>89<br>00:09:51,000 –&gt; 00:09:52,000<br>We’ll see how far we can get.</p>
<p>90<br>00:09:52,000 –&gt; 00:09:56,000<br>We don’t get to randomize search as fine because nobody actually does this except for Postgres.</p>
<p>91<br>00:09:56,000 –&gt; 00:10:00,000<br>And Postgres only does it if you have 13 tables in your query.</p>
<p>92<br>00:10:00,000 –&gt; 00:10:03,000<br>But we’ll cover that next class if you’re not at the time.</p>
<p>93<br>00:10:03,000 –&gt; 00:10:07,000<br>The main two ones that we’re going to focus on are the middle three.</p>
<p>94<br>00:10:07,000 –&gt; 00:10:14,000<br>So again we’re going to sort of walk through the in order of complexity from like simplest to hardest.</p>
<p>95<br>00:10:14,000 –&gt; 00:10:18,000<br>Although stratified and unified are essentially equivalent.</p>
<p>96<br>00:10:18,000 –&gt; 00:10:24,000<br>And we’re going to walk through like here’s how people implement these different query optimizers.</p>
<p>97<br>00:10:24,000 –&gt; 00:10:27,000<br>What are the pros and cons of them? What can’t they handle?</p>
<p>98<br>00:10:27,000 –&gt; 00:10:33,000<br>And then how the sort of the next approach as we go down tries to solve the problems to the previous one.</p>
<p>99<br>00:10:33,000 –&gt; 00:10:37,000<br>And we’ll sprinkle discussion a little bit about how like real world systems do this.</p>
<p>100<br>00:10:38,000 –&gt; 00:10:46,000<br>And the TLDR is going to be stratified search and unified search are going to be the most common approaches.</p>
<p>101<br>00:10:46,000 –&gt; 00:10:52,000<br>So say you’re a brand new startup and you’re building a brand new database system of scratch.</p>
<p>102<br>00:10:52,000 –&gt; 00:10:57,000<br>You’re not like 14 postgres. You’re just literally starting from nothing.</p>
<p>103<br>00:10:57,000 –&gt; 00:11:01,000<br>The heuristic based optimizer is probably what most people almost everyone builds first.</p>
<p>104<br>00:11:02,000 –&gt; 00:11:13,000<br>Because it’s super simple. It’s a bunch of if and else clauses that look for patterns in the SQL query and then apply some transformation to convert them into a better form.</p>
<p>105<br>00:11:13,000 –&gt; 00:11:21,000<br>And the reason why this works is that it’s based on domain knowledge about what we know as humans about query optimization and queries in general.</p>
<p>106<br>00:11:21,000 –&gt; 00:11:28,000<br>And we’re basically codifying that in our code to always apply those changes without worrying about whether the right thing to do or not.</p>
<p>107<br>00:11:28,000 –&gt; 00:11:30,000<br>Yes.</p>
<p>108<br>00:11:30,000 –&gt; 00:11:36,000<br>As far as I I have to double check I don’t think I don’t think they have a call space optimizer.</p>
<p>109<br>00:11:36,000 –&gt; 00:11:40,000<br>The way MongoDB works is that they generate all the query plans.</p>
<p>110<br>00:11:40,000 –&gt; 00:11:41,000<br>Run them all.</p>
<p>111<br>00:11:41,000 –&gt; 00:11:44,000<br>Whenever one comes back first, that’s what they pick.</p>
<p>112<br>00:11:44,000 –&gt; 00:11:47,000<br>Because that’s what it was a year or two ago.</p>
<p>113<br>00:11:47,000 –&gt; 00:11:52,000<br>So you don’t run like like you generate all the query plans.</p>
<p>114<br>00:11:52,000 –&gt; 00:11:53,000<br>You pick one.</p>
<p>115<br>00:11:53,000 –&gt; 00:11:55,000<br>You send that out first. See how long it takes.</p>
<p>116<br>00:11:55,000 –&gt; 00:11:57,000<br>Next time the query shows up, pick the next one and run that.</p>
<p>117<br>00:11:57,000 –&gt; 00:11:59,000<br>And you pick what you want to.</p>
<p>118<br>00:11:59,000 –&gt; 00:12:01,000<br>You laugh, but it’s pretty simple. It works.</p>
<p>119<br>00:12:01,000 –&gt; 00:12:03,000<br>And then after like 20 iterations, they’ll try again.</p>
<p>120<br>00:12:03,000 –&gt; 00:12:04,000<br>Yes.</p>
<p>121<br>00:12:04,000 –&gt; 00:12:06,000<br>If you’re not like you don’t play all the query,</p>
<p>122<br>00:12:06,000 –&gt; 00:12:08,000<br>you sort of look like this.</p>
<p>123<br>00:12:08,000 –&gt; 00:12:09,000<br>Or not not.</p>
<p>124<br>00:12:09,000 –&gt; 00:12:11,000<br>But you’re writing simply.</p>
<p>125<br>00:12:11,000 –&gt; 00:12:13,000<br>It’s David is the MongoDB approach works.</p>
<p>126<br>00:12:13,000 –&gt; 00:12:17,000<br>If you assume the query is going to be very similar to each other, maybe just different input parameters.</p>
<p>127<br>00:12:17,000 –&gt; 00:12:18,000<br>Yes, you could do that.</p>
<p>128<br>00:12:18,000 –&gt; 00:12:26,000<br>And in the old to be world operational workloads that Mongo initially targeted, this works.</p>
<p>129<br>00:12:26,000 –&gt; 00:12:29,000<br>Because again, it’s like go look up any record.</p>
<p>130<br>00:12:29,000 –&gt; 00:12:31,000<br>Go look up Kyle’s record.</p>
<p>131<br>00:12:31,000 –&gt; 00:12:34,000<br>It’s the same query, just different input parameters.</p>
<p>132<br>00:12:34,000 –&gt; 00:12:36,000<br>I want to get two boggles on Mongo.</p>
<p>133<br>00:12:36,000 –&gt; 00:12:38,000<br>And again, I’m not knocking them.</p>
<p>134<br>00:12:38,000 –&gt; 00:12:43,000<br>I’m just saying it’s cleverly simplistic.</p>
<p>135<br>00:12:43,000 –&gt; 00:12:47,000<br>There’s other things to bang on them about like M-map.</p>
<p>136<br>00:12:47,000 –&gt; 00:12:50,000<br>For this one, when I was like, oh yeah, I can see why you would do this.</p>
<p>137<br>00:12:50,000 –&gt; 00:12:52,000<br>Because again, what did I just say at the beginning?</p>
<p>138<br>00:12:52,000 –&gt; 00:12:54,000<br>This is the hardest part of David systems.</p>
<p>139<br>00:12:54,000 –&gt; 00:12:56,000<br>Trying to get a system up and running right away.</p>
<p>140<br>00:12:56,000 –&gt; 00:12:58,000<br>They’re getting huge growth.</p>
<p>141<br>00:12:58,000 –&gt; 00:13:02,000<br>They got that far without a query optimization.</p>
<p>142<br>00:13:02,000 –&gt; 00:13:06,000<br>So again, this heuristic based on it’s going to be if and else statements.</p>
<p>143<br>00:13:06,000 –&gt; 00:13:14,000<br>That look for patterns in the query plan and then applies some transformation to put it into a different form.</p>
<p>144<br>00:13:14,000 –&gt; 00:13:20,000<br>So the most obvious thing you can do is always do the most restrictive selection first.</p>
<p>145<br>00:13:20,000 –&gt; 00:13:23,000<br>Because usually I’m just trying to filter things out as soon as possible.</p>
<p>146<br>00:13:23,000 –&gt; 00:13:28,000<br>Because we know as humans, if you know why spend time copying data from one upper to the next,</p>
<p>147<br>00:13:28,000 –&gt; 00:13:33,000<br>if I know I’m not going to need it, so let me go ahead and try to throw things out as soon as possible.</p>
<p>148<br>00:13:33,000 –&gt; 00:13:37,000<br>So that’s pretty much down limits, projections and so forth.</p>
<p>149<br>00:13:37,000 –&gt; 00:13:43,000<br>For join ordering, if you’re lucky, they’ll have rules that’ll look at actually cardinality estimates.</p>
<p>150<br>00:13:43,000 –&gt; 00:13:46,000<br>And maybe say, oh, this one’s bigger than the other one, swap them.</p>
<p>151<br>00:13:46,000 –&gt; 00:13:48,000<br>We’ll see in the case of the oracles.</p>
<p>152<br>00:13:48,000 –&gt; 00:13:52,000<br>Their first implementation didn’t do that.</p>
<p>153<br>00:13:52,000 –&gt; 00:13:57,000<br>So the two out of the three first relational database systems built in the 19,</p>
<p>154<br>00:13:57,000 –&gt; 00:14:02,000<br>the major relational database systems built in the United States in the 1970s all did this.</p>
<p>155<br>00:14:02,000 –&gt; 00:14:07,000<br>So ingress did this up until the mid 80s or could did this up to the mid 90s.</p>
<p>156<br>00:14:07,000 –&gt; 00:14:12,000<br>But in the case of the other the other major one system are at IBM research,</p>
<p>157<br>00:14:12,000 –&gt; 00:14:16,000<br>they’re actually going to do a call space search, which we’ll see next.</p>
<p>158<br>00:14:16,000 –&gt; 00:14:24,000<br>Again, most new database systems, unless you can reuse something like CalSight or Orca or an existing courty-optimizer like Postgres,</p>
<p>159<br>00:14:24,000 –&gt; 00:14:27,000<br>this is pretty much everyone does.</p>
<p>160<br>00:14:27,000 –&gt; 00:14:30,000<br>And long term, it’s not sustainable.</p>
<p>161<br>00:14:30,000 –&gt; 00:14:35,000<br>The reason I qualifies it, the two out of three first relational database systems in the US,</p>
<p>162<br>00:14:35,000 –&gt; 00:14:39,000<br>because there was another one in Sweden called Mimer’s SQL,</p>
<p>163<br>00:14:39,000 –&gt; 00:14:42,000<br>and there was a German one called AidaBoss, but I don’t know what those guys actually did.</p>
<p>164<br>00:14:42,000 –&gt; 00:14:45,000<br>So they’re all relational database at the time, yes.</p>
<p>165<br>00:14:45,000 –&gt; 00:14:48,000<br>Sternbreaker built ingress, yes.</p>
<p>166<br>00:14:48,000 –&gt; 00:14:50,000<br>Why is it called Postgres?</p>
<p>167<br>00:14:50,000 –&gt; 00:14:53,000<br>Because it’s Post-Engress.</p>
<p>168<br>00:14:53,000 –&gt; 00:15:00,000<br>He built ingress, it stands for something interactive, graphical.</p>
<p>169<br>00:15:00,000 –&gt; 00:15:05,000<br>They got a grant to build it for a GIS application,</p>
<p>170<br>00:15:05,000 –&gt; 00:15:08,000<br>and then they started building it out to be more general purpose.</p>
<p>171<br>00:15:08,000 –&gt; 00:15:10,000<br>Right, yes.</p>
<p>172<br>00:15:10,000 –&gt; 00:15:14,000<br>So about the last one, I thought cardinality was the most important thing to consider the cardinality?</p>
<p>173<br>00:15:14,000 –&gt; 00:15:18,000<br>It’s a bit of a cost model.</p>
<p>174<br>00:15:18,000 –&gt; 00:15:24,000<br>But the difference is going to be, there isn’t a search process where I’m in new-burning every different plans,</p>
<p>175<br>00:15:24,000 –&gt; 00:15:25,000<br>I say, is this one better than this?</p>
<p>176<br>00:15:25,000 –&gt; 00:15:30,000<br>It’s literally like, if I have a join, and the cardinality estimate is this one is greater than this one,</p>
<p>177<br>00:15:30,000 –&gt; 00:15:33,000<br>as literally all it is.</p>
<p>178<br>00:15:36,000 –&gt; 00:15:39,000<br>All right, getting back in the day, data is sort of small.</p>
<p>179<br>00:15:39,000 –&gt; 00:15:42,000<br>You didn’t have CTEs, you didn’t have window functions,</p>
<p>180<br>00:15:42,000 –&gt; 00:15:44,000<br>you didn’t have all these other stuff we’ve been talking about.</p>
<p>181<br>00:15:44,000 –&gt; 00:15:46,000<br>So this would get you pretty far.</p>
<p>182<br>00:15:46,000 –&gt; 00:15:49,000<br>And for OTP, again, this will get you pretty far.</p>
<p>183<br>00:15:49,000 –&gt; 00:15:52,000<br>So let’s look at some basic optimizations that you can do with this.</p>
<p>184<br>00:15:52,000 –&gt; 00:15:57,000<br>So these, again, this is a refresher for the intro class,</p>
<p>185<br>00:15:57,000 –&gt; 00:16:04,000<br>but I’m going to show you these, because this will be what some of the heuristic rules will look like when we look at the stratified search and the other stuff.</p>
<p>186<br>00:16:04,000 –&gt; 00:16:08,000<br>Because again, this is, you can do this without a cost model.</p>
<p>187<br>00:16:08,000 –&gt; 00:16:12,000<br>And for the, like a heuristic, pure heuristic-based approach,</p>
<p>188<br>00:16:12,000 –&gt; 00:16:14,000<br>this is a generator plan you can then run.</p>
<p>189<br>00:16:14,000 –&gt; 00:16:26,000<br>But the idea when we do have a cost-based search, we want to use these transformations to guide us and push us towards what will at least be a starting point in our search for a reasonable plan.</p>
<p>190<br>00:16:26,000 –&gt; 00:16:29,000<br>So we’re not like blindly starting from the most stupidest query plan.</p>
<p>191<br>00:16:29,000 –&gt; 00:16:37,000<br>And then spending all our search time, just getting us into a basic form that we’ve could have gotten instantaneously using one of these rules.</p>
<p>192<br>00:16:37,000 –&gt; 00:16:41,000<br>So say we have a query like this, this is a three-way join on appears,</p>
<p>193<br>00:16:41,000 –&gt; 00:16:46,000<br>artists appears in album, and we’re going to look up all the people, all the artists that are on my mix tape.</p>
<p>194<br>00:16:46,000 –&gt; 00:16:49,000<br>So the first thing you do is just split, split conjunctor predicate.</p>
<p>195<br>00:16:49,000 –&gt; 00:16:56,000<br>So splitting any filter on the AND clauses to break them up into separate filter operators.</p>
<p>196<br>00:16:56,000 –&gt; 00:17:07,000<br>So you identify that I have a filter operator within the filter operator’s expression, I have an ANDs, I spin the the ANDs, and I create additional filter operators for that.</p>
<p>197<br>00:17:07,000 –&gt; 00:17:11,000<br>Again, I don’t need to cost money to do that. I know I always want to do that.</p>
<p>198<br>00:17:12,000 –&gt; 00:17:20,000<br>So now, if I have these different filter operators, I can easily do now predicate pushdown to push the filter B below any join operator.</p>
<p>199<br>00:17:20,000 –&gt; 00:17:27,000<br>Because again, why do I join on table on data? I know I’m going to throw away above.</p>
<p>200<br>00:17:27,000 –&gt; 00:17:32,000<br>So I just push all of them down, I said to be right above the join, in this case here.</p>
<p>201<br>00:17:32,000 –&gt; 00:17:37,000<br>But I guess the below this join appears. So these are the filters that are combining two tables,</p>
<p>202<br>00:17:38,000 –&gt; 00:17:42,000<br>every new the Cartesian product, then I do the join. Then I applied the filter.</p>
<p>203<br>00:17:42,000 –&gt; 00:17:46,000<br>Then the next step obviously, we want to get rid of the Cartesian products.</p>
<p>204<br>00:17:46,000 –&gt; 00:17:51,000<br>So we just convert the, we recognize that we have an aquatic predicate right above us.</p>
<p>205<br>00:17:51,000 –&gt; 00:17:56,000<br>So we can convert any Cartesian product into an inner join or an aqua join.</p>
<p>206<br>00:17:56,000 –&gt; 00:17:59,000<br>That’s always going to be faster.</p>
<p>207<br>00:17:59,000 –&gt; 00:18:03,000<br>And then depending on the system, I may also want to do projection pushdown.</p>
<p>208<br>00:18:04,000 –&gt; 00:18:12,000<br>But whether or not I have a cost model that decides whether the size of the table, then I’m, or the data that I’m pushing up between one upper to the next, is really big or not.</p>
<p>209<br>00:18:12,000 –&gt; 00:18:20,000<br>But I can recognize that rather than copying all the data that I know I’m not going to need, I’ll just push down the projections to be below any join operator.</p>
<p>210<br>00:18:20,000 –&gt; 00:18:24,000<br>So I’m only passing along the minimum amount of data from one upper to the next.</p>
<p>211<br>00:18:24,000 –&gt; 00:18:27,000<br>So all these, what are these four or five steps I should right here.</p>
<p>212<br>00:18:27,000 –&gt; 00:18:32,000<br>Again, these are logical transformations that I can do without having to have a cost model.</p>
<p>213<br>00:18:32,000 –&gt; 00:18:36,000<br>And it didn’t specify what join algorithm I’m using or how I’m accessing these tables.</p>
<p>214<br>00:18:36,000 –&gt; 00:18:39,000<br>I can just operate directly on the, on the logical plan to do this.</p>
<p>215<br>00:18:39,000 –&gt; 00:18:46,000<br>And again, we know this is always me faster than what I started out with, which is like, again, the canonical form of converting SQL into relational algebra.</p>
<p>216<br>00:18:46,000 –&gt; 00:18:47,000<br>Yes.</p>
<p>217<br>00:18:47,000 –&gt; 00:18:51,000<br>I think there are actually some edge cases where the predicate is really really expensive.</p>
<p>218<br>00:18:51,000 –&gt; 00:18:53,000<br>And the technical problem.</p>
<p>219<br>00:18:53,000 –&gt; 00:19:03,000<br>The statement is, there are some cases where if the predicate, I mean, valuation of the predicate is very expensive from a computational standpoint, then pushing down the predicate is a bad idea.</p>
<p>220<br>00:19:03,000 –&gt; 00:19:04,000<br>Yes.</p>
<p>221<br>00:19:04,000 –&gt; 00:19:07,000<br>But you know, there you have it.</p>
<p>222<br>00:19:07,000 –&gt; 00:19:11,000<br>You don’t know that at this point here.</p>
<p>223<br>00:19:11,000 –&gt; 00:19:18,000<br>Right. Because how do you weigh the number of two tables going in to the filter?</p>
<p>224<br>00:19:19,000 –&gt; 00:19:20,000<br>That’s a projection.</p>
<p>225<br>00:19:20,000 –&gt; 00:19:28,000<br>Like, how do I know the number of two is coming in to the, to the, to the join is going to be, say, this comparison is super expensive.</p>
<p>226<br>00:19:28,000 –&gt; 00:19:35,000<br>How do I know that the number of two is going in would outweigh the cost of applying this for everyone versus above after the join?</p>
<p>227<br>00:19:35,000 –&gt; 00:19:36,000<br>You don’t know.</p>
<p>228<br>00:19:36,000 –&gt; 00:19:38,000<br>You need a cost model.</p>
<p>229<br>00:19:38,000 –&gt; 00:19:39,000<br>You need a cost model.</p>
<p>230<br>00:19:39,000 –&gt; 00:19:41,000<br>You need to use the statistics.</p>
<p>231<br>00:19:41,000 –&gt; 00:19:46,000<br>And the very beginning didn’t have any of that.</p>
<p>232<br>00:19:46,000 –&gt; 00:19:49,000<br>All right. So let me show what ingress did back in the day.</p>
<p>233<br>00:19:49,000 –&gt; 00:19:57,000<br>And again, this is like kind of the MongoDB one where I was saying like, it’s, it’s a delightfully stupid.</p>
<p>234<br>00:19:57,000 –&gt; 00:20:09,000<br>Meaning like, you would never want to do this today, but given the constraints that they had at the time and the hard they were working with, without having a cost model, a creaponizer is actually kind of clever.</p>
<p>235<br>00:20:09,000 –&gt; 00:20:14,000<br>So the dirty secret about ingress is the first version of it is it actually couldn’t do joins.</p>
<p>236<br>00:20:15,000 –&gt; 00:20:20,000<br>Yes, first version ingress in like 1974ish, threeish, could five.</p>
<p>237<br>00:20:20,000 –&gt; 00:20:21,000<br>Couldn’t do joins.</p>
<p>238<br>00:20:21,000 –&gt; 00:20:25,000<br>They couldn’t even do that.</p>
<p>239<br>00:20:25,000 –&gt; 00:20:27,000<br>Okay.</p>
<p>240<br>00:20:27,000 –&gt; 00:20:30,000<br>Yeah, all to be stuff back in the day.</p>
<p>241<br>00:20:30,000 –&gt; 00:20:33,000<br>Let’s see how they, but like, but they want to support the query like this.</p>
<p>242<br>00:20:33,000 –&gt; 00:20:38,000<br>The example they always have in the old papers is like employer employee salary like, like, or department.</p>
<p>243<br>00:20:38,000 –&gt; 00:20:40,000<br>Yeah, they’re all pulling up.</p>
<p>244<br>00:20:40,000 –&gt; 00:20:41,000<br>Let’s see how they do this.</p>
<p>245<br>00:20:41,000 –&gt; 00:20:48,000<br>So to say we had the same query before, so three way join on artists appears at album, but now I’m going to throw in this order by clause for the artist ID.</p>
<p>246<br>00:20:48,000 –&gt; 00:20:57,000<br>So the first thing they’re going to do is they’re going to rewrite the SQL query into single value queries, meaning the same case of the first one here.</p>
<p>247<br>00:20:57,000 –&gt; 00:21:07,000<br>I take the first query, I extract out and move out the look up on artists and appears, and I have a singular query looking up on the album based on the album name.</p>
<p>248<br>00:21:08,000 –&gt; 00:21:13,000<br>But then I’m going to materialize the output into temp 1, some table here.</p>
<p>249<br>00:21:13,000 –&gt; 00:21:23,000<br>Now I’m going to further decompose query 2 into two new queries, where the first one does a look up on appears, and a join with temp 1.</p>
<p>250<br>00:21:23,000 –&gt; 00:21:26,000<br>And the second one is going to do a look up on artists and a join with temp 2.</p>
<p>251<br>00:21:26,000 –&gt; 00:21:30,000<br>Again, this one is materializing the output into temp 2.</p>
<p>252<br>00:21:30,000 –&gt; 00:21:40,000<br>So now what I’m going to do is run the queries 1 by 1, starting from the top to the bottom, and whatever the result is, I then inject that into the next query I’m going to execute.</p>
<p>253<br>00:21:40,000 –&gt; 00:21:47,000<br>So if I run this first query, query 1, look up the album based on the name, it’s going to produce album ID 999.</p>
<p>254<br>00:21:48,000 –&gt; 00:22:02,000<br>So then I take that, map that into the rewritten query on the appears table, and substitute what would have been the join clause on the artist table, or sort of the album table, and now inject 99999.</p>
<p>255<br>00:22:02,000 –&gt; 00:22:11,000<br>And then this thing produces a result, two results here, and then I’m going to do a four on the bottom of that, and run each of those queries 1 by 1.</p>
<p>256<br>00:22:11,000 –&gt; 00:22:12,000<br>Yes.</p>
<p>257<br>00:22:13,000 –&gt; 00:22:15,000<br>And there are easy ones for query 2.</p>
<p>258<br>00:22:15,000 –&gt; 00:22:17,000<br>Going back here.</p>
<p>259<br>00:22:17,000 –&gt; 00:22:26,000<br>Query 2 got rewritten into, so query 2 got rewritten to a three by join, or two of the two of the artists and peers, and that gets rewritten into 3 and 4.</p>
<p>260<br>00:22:29,000 –&gt; 00:22:30,000<br>And the question, yes.</p>
<p>261<br>00:22:30,000 –&gt; 00:22:33,000<br>What is the definition of a single value query?</p>
<p>262<br>00:22:33,000 –&gt; 00:22:36,000<br>What is the definition of a single value query?</p>
<p>263<br>00:22:36,000 –&gt; 00:22:38,000<br>Like one tuple for one table.</p>
<p>264<br>00:22:38,000 –&gt; 00:22:39,000<br>Oh.</p>
<p>265<br>00:22:39,000 –&gt; 00:22:40,000<br>Yeah.</p>
<p>266<br>00:22:43,000 –&gt; 00:22:46,000<br>Right, so like, well, in this case here, you would run it.</p>
<p>267<br>00:22:46,000 –&gt; 00:22:51,000<br>Well, I could be for one table, so you would get this query would run once, you get two results.</p>
<p>268<br>00:22:51,000 –&gt; 00:23:00,000<br>They could support multiple tuples in the output, and then now you take these two values, then just expand that out into different instances of the same query.</p>
<p>269<br>00:23:00,000 –&gt; 00:23:02,000<br>What’s the name of the query?</p>
<p>270<br>00:23:02,000 –&gt; 00:23:11,000<br>Yeah, I mean one table queries, single table queries.</p>
<p>271<br>00:23:11,000 –&gt; 00:23:17,000<br>So I’m showing this at the SQL level, but they did this all at the logical level, which is logical query plans, and then they would just sort of run this.</p>
<p>272<br>00:23:17,000 –&gt; 00:23:25,000<br>And so why I say this to like stupidly clever is, you’re actually running the query optimizer every single time you generate one of these queries.</p>
<p>273<br>00:23:25,000 –&gt; 00:23:43,000<br>So for whatever reason, if like for this artist ID equals one, two, three, if there was a better way to execute that than doing a lookup in four, five, six, you could actually support that because you would take this query plan, run it through the planner and might choose a different execution path than this other one here.</p>
<p>274<br>00:23:43,000 –&gt; 00:23:48,000<br>And because it’s choosing on a per single value within the lookup, what’s the best thing to do?</p>
<p>275<br>00:23:48,000 –&gt; 00:23:56,000<br>So it’s sort of an early example of adaptive query optimization, which we’ll see next week, but like, because you’re running the optimizer on a per query basis, but obviously this would be super slow.</p>
<p>276<br>00:23:56,000 –&gt; 00:23:58,000<br>You wouldn’t actually want to do this.</p>
<p>277<br>00:23:58,000 –&gt; 00:24:01,000<br>Right?</p>
<p>278<br>00:24:01,000 –&gt; 00:24:06,000<br>So again, it’s a nice, to me, it’s a nice historical curiosity.</p>
<p>279<br>00:24:06,000 –&gt; 00:24:13,000<br>So there is a big conversation is the easiest implement in debug because against just a bunch of if and else’s, this would pretty much everyone does.</p>
<p>280<br>00:24:13,000 –&gt; 00:24:18,000<br>And for simple queries, you’re not going to get any faster than this because you don’t mean any taining state.</p>
<p>281<br>00:24:18,000 –&gt; 00:24:24,000<br>You’re not doing any lookup in the queries against the cost model, do estimations.</p>
<p>282<br>00:24:24,000 –&gt; 00:24:28,000<br>It’s like boom, boom, boom, and then here’s the query and run it.</p>
<p>283<br>00:24:28,000 –&gt; 00:24:34,000<br>Obviously, the downside is going to be this is going to be a nightmare to expand when you want to start doing more complicated things.</p>
<p>284<br>00:24:34,000 –&gt; 00:24:39,000<br>It’s going to lie in magic consents to say like, how much better really is something than another.</p>
<p>285<br>00:24:39,000 –&gt; 00:24:46,000<br>If you start weighing in like the number of tools, this operator is going to spit out if you’re flipping one versus another.</p>
<p>286<br>00:24:46,000 –&gt; 00:24:52,000<br>And then anytime you have like a nested query and then that becomes a trainback.</p>
<p>287<br>00:24:52,000 –&gt; 00:25:00,000<br>And most obviously actually not in just nest squares, and then you have joins to figure out what’s the right join ordering would be a total nightmare.</p>
<p>288<br>00:25:00,000 –&gt; 00:25:10,000<br>Going back to this one here, the reason why we started with query one on the out my D, because that’s the only input we have to the query.</p>
<p>289<br>00:25:10,000 –&gt; 00:25:20,000<br>We know what the starting point is. But if it was just a join across the tables without any input, then you have to pick what is the starting point, which is the first for a table you want to put in part of the join.</p>
<p>290<br>00:25:20,000 –&gt; 00:25:24,000<br>And then it all falls apart.</p>
<p>291<br>00:25:24,000 –&gt; 00:25:29,000<br>So I said, this is roughly what ingress and oracle did back in the day. System R we’ll see in the next two slides.</p>
<p>292<br>00:25:29,000 –&gt; 00:25:33,000<br>They’re going to have a call space search for at least for the for the joins.</p>
<p>293<br>00:25:33,000 –&gt; 00:25:42,000<br>If you read the unofficial biography of Larry Ellison, there’s this nice little paragraph here somewhere where Stemberger talks about the oracle’s query optimizer.</p>
<p>294<br>00:25:42,000 –&gt; 00:25:52,000<br>Again, this is about the mid 19, with this book he met in the 1990s, but he’s talking about the sort of the race between oracle and ingress in the 1980s.</p>
<p>295<br>00:25:52,000 –&gt; 00:26:01,000<br>And he talks about how ingress actually built a query optimizer that’s going to look like IBMs, but oracle was kept going on in how that was actually the wrong way to do it.</p>
<p>296<br>00:26:01,000 –&gt; 00:26:04,000<br>And the right way to do is what oracle did.</p>
<p>297<br>00:26:04,000 –&gt; 00:26:11,000<br>And that instead of calling it like a heuristic based optimizer, they call it a semantic optimizer, because they couldn’t do cross-based search.</p>
<p>298<br>00:26:11,000 –&gt; 00:26:18,000<br>So the to figure out the join order. So the join order was whatever the order that the tables appeared in the actual SQL string.</p>
<p>299<br>00:26:18,000 –&gt; 00:26:24,000<br>And they call that in or Larry Ellison would call that a semantic optimizer.</p>
<p>300<br>00:26:24,000 –&gt; 00:26:33,000<br>So good marketing. And then like I said, IBM or oracle is going to be right there is in the 1990s and make it more state of the art.</p>
<p>301<br>00:26:33,000 –&gt; 00:26:39,000<br>So at the same time, the ingress and oracle guys are building their heuristic based optimizers.</p>
<p>302<br>00:26:39,000 –&gt; 00:26:48,000<br>IBM researcher, IBM was building system R. And they end up building the first cost-based query optimizer.</p>
<p>303<br>00:26:48,000 –&gt; 00:26:55,000<br>And the idea is that it’s going to use a heuristic stage just like we saw before where you can do the logical, logical optimizations.</p>
<p>304<br>00:26:55,000 –&gt; 00:27:02,000<br>But then they’re going to plan a new relation and transform physical operators.</p>
<p>305<br>00:27:02,000 –&gt; 00:27:06,000<br>Actually, that’s backwards. It should be logical and not physical, logical.</p>
<p>306<br>00:27:06,000 –&gt; 00:27:13,000<br>They would transfer it to physical operators and try to find one with the lowest cost.</p>
<p>307<br>00:27:13,000 –&gt; 00:27:19,000<br>And obviously to do this, you need a cost model, you need estimates, but each operator is going to spit out.</p>
<p>308<br>00:27:19,000 –&gt; 00:27:26,000<br>And you can’t guarantee that you’re going to find the the optimal plan, but there’s things they do would try to at least get to a good plan.</p>
<p>309<br>00:27:26,000 –&gt; 00:27:31,000<br>Like only choosing left deep trees instead of pushing trees. There’s a cut down the search base.</p>
<p>310<br>00:27:31,000 –&gt; 00:27:36,000<br>So this is what system R did in the very beginning. This is what IBM DB2, at least in the early 1980s,</p>
<p>311<br>00:27:36,000 –&gt; 00:27:41,000<br>because that was the first commercialization of a relational database at IBM.</p>
<p>312<br>00:27:41,000 –&gt; 00:27:45,000<br>They did something based on this. And then most of the other source database systems are out today.</p>
<p>313<br>00:27:45,000 –&gt; 00:27:54,000<br>Postgres, MySQL, SQLite. They’re going to do something that looks and not smells like this.</p>
<p>314<br>00:27:54,000 –&gt; 00:28:01,000<br>So for this one, actually, let’s skip. But basically converting the query pans, logic operators, physical operators,</p>
<p>315<br>00:28:01,000 –&gt; 00:28:09,000<br>to do this correctly, we need to understand what the table is going to look like, what the inputs are going to be to this given operator,</p>
<p>316<br>00:28:09,000 –&gt; 00:28:14,000<br>whether data is going to be located. All this is related to the cost model stuff that we talked about before.</p>
<p>317<br>00:28:14,000 –&gt; 00:28:20,000<br>And we’ll talk about more next week. So to numerate the plans, there’s basically two categories.</p>
<p>318<br>00:28:20,000 –&gt; 00:28:26,000<br>And this is going to be similar to the debate between, do I want to partition my hash showing or not?</p>
<p>319<br>00:28:26,000 –&gt; 00:28:31,000<br>Like, you know, the people go back and forth in this. But for query optimization, the question is going to be,</p>
<p>320<br>00:28:31,000 –&gt; 00:28:38,000<br>do I want to enumerate plans and build things up the physical plan from the bottom of the query plan?</p>
<p>321<br>00:28:38,000 –&gt; 00:28:46,000<br>To the top or from the top to the bottom? Or another way to think about this is, am I going to use a generative approach or a transformative approach?</p>
<p>322<br>00:28:46,000 –&gt; 00:28:52,000<br>So a generative approach would be, I start with nothing. Like, I have no physical operators on my query plan.</p>
<p>323<br>00:28:52,000 –&gt; 00:29:01,000<br>And then I’m going to iterally assemble and inject new physical operators to work myself up to the final output, the root of the query plan,</p>
<p>324<br>00:29:01,000 –&gt; 00:29:08,000<br>that’s going to produce the final result. And I can do cost-based selection as I go from one level to the next.</p>
<p>325<br>00:29:08,000 –&gt; 00:29:15,000<br>So this is what system R is going to do. This is what Starburst, which is the query optimizer that IBM built later on in the 1980s, early 1990s.</p>
<p>326<br>00:29:15,000 –&gt; 00:29:18,000<br>This is what they’re going to do as well. Right?</p>
<p>327<br>00:29:18,000 –&gt; 00:29:27,000<br>The alternative approach is to do the top down transformation where I start with the goal that I want, which is the root of the query plan.</p>
<p>328<br>00:29:28,000 –&gt; 00:29:37,000<br>I want my final output of my query plan to look like this. Right? I’m joining these tables. It’s sort of this way. Whatever it is, that’s what I want.</p>
<p>329<br>00:29:37,000 –&gt; 00:29:50,000<br>And then I’m going to permute it, the query plan going down and adding new operators that will then feed into my root to then produce the final result that I want.</p>
<p>330<br>00:29:51,000 –&gt; 00:29:56,000<br>It sort of seems like I’m just making hand gestures and going up and down like this. It doesn’t make any sense.</p>
<p>331<br>00:29:56,000 –&gt; 00:30:04,000<br>But it does have implications for the scope in which you can examine and operate on the query plan when you apply different time to transformations.</p>
<p>332<br>00:30:04,000 –&gt; 00:30:17,000<br>And how you’re actually going to cost them. In the end, they’re doing a dynamic approach. It’s just the way they’re doing the costing and pruning things will differ.</p>
<p>333<br>00:30:21,000 –&gt; 00:30:30,000<br>So let’s look at the system or optimize it. Let’s see an early version of a bottom-up approach. And then we’ll see how that think it’s expanded into a little bit at Starburst.</p>
<p>334<br>00:30:30,000 –&gt; 00:30:40,000<br>And as I said, next class, we’ll go into more details of the state of the art approach of bottoms-up plan and emeration that the Germans do in hyper.</p>
<p>335<br>00:30:40,000 –&gt; 00:30:43,000<br>And I think DuckDB does the same thing as well.</p>
<p>336<br>00:30:43,000 –&gt; 00:30:52,000<br>So the way system art is going to work is that the queries are going to show up. And they’re going to break it up the query plan into blocks that have logical operators for each block.</p>
<p>337<br>00:30:52,000 –&gt; 00:31:01,000<br>Sort of thinking of like a block would be like a pipeline breaker or it could be a nested subquery. It’s going to be some subcomponent or subplan of the overall query plan.</p>
<p>338<br>00:31:01,000 –&gt; 00:31:10,000<br>And then for the logical operator within a subplan or block, they’re going to generate the set of physical operators that could possibly implement it.</p>
<p>339<br>00:31:11,000 –&gt; 00:31:23,000<br>And they’re primarily going to be focusing on genre access paths. So figuring out how can I scan this table, your index or a central scan, and then what sort of, sorry, we’re joined algorithm I’m going to want to use.</p>
<p>340<br>00:31:23,000 –&gt; 00:31:30,000<br>And again, to reduce the complexity of the search base, they’re only going to look at left-deep trees. So they’re not going to sit at right-deep or bushy trees.</p>
<p>341<br>00:31:30,000 –&gt; 00:31:38,000<br>Again, this is a relic of the 1970s and limited computing harbor. But a lot of systems still today make this big assumption.</p>
<p>342<br>00:31:39,000 –&gt; 00:31:48,000<br>Right? As far as I know, left-deep and right-deep are always going to be equivalent, but sometimes you do actually want a bushy plan and you know, they’re not going to be able to find those.</p>
<p>343<br>00:31:48,000 –&gt; 00:31:55,000<br>And so they’re going to literally construct this left-deep join tree and they want to choose the one that’s going to have the minimal cost at the end.</p>
<p>344<br>00:31:55,000 –&gt; 00:31:58,000<br>Again, based on some cost-bound estimate.</p>
<p>345<br>00:31:59,000 –&gt; 00:32:08,000<br>So we go back to our query we haven’t had before. So in the first step, we’re going to choose the best access paths for all the tables that we’re going to, we’re going to, we’re touching in the query.</p>
<p>346<br>00:32:08,000 –&gt; 00:32:21,000<br>So independently, we’re going to decide, oh, we want to do a sequential scan on artists and appears. But then we, we identify that the best look up for the album table will be on the index we have on name.</p>
<p>347<br>00:32:22,000 –&gt; 00:32:28,000<br>So all of those are occurring, occurring independently of what the, of how we’re actually going to do the joint.</p>
<p>348<br>00:32:28,000 –&gt; 00:32:44,000<br>Then we’re going to numerate all possible joinerings for the tables and this literally is just a Cartesian product with all possible combinations or commonatorial combination of all the possible ways we could do a joint, different joint algorithms, different joint orders, whether or not we even do a Cartesian product.</p>
<p>349<br>00:32:45,000 –&gt; 00:32:51,000<br>The simple thing system are going to do is sort of what I said in the beginning is recognize that I know was a never going to do Cartesian product.</p>
<p>350<br>00:32:51,000 –&gt; 00:32:54,000<br>So I can immediately throw all those away.</p>
<p>351<br>00:32:54,000 –&gt; 00:33:02,000<br>And then now I’m going to do this bottom up based search for all these different combinations that I have to figure out what the joint order is that I want to be.</p>
<p>352<br>00:33:02,000 –&gt; 00:33:10,000<br>So again, the, in this diagram here, think of the top as the final output. And the bottom here is my starting point.</p>
<p>353<br>00:33:11,000 –&gt; 00:33:17,000<br>So my final output is what I want to have joined artists appears in album. But at the bottom here, I haven’t joined anything.</p>
<p>354<br>00:33:17,000 –&gt; 00:33:22,000<br>I assume also two I’ve selected for each of these integer tables as I showed in the previous slide.</p>
<p>355<br>00:33:22,000 –&gt; 00:33:31,000<br>I’ve already selected what access method I’m going to use. So there’s sequential scans for artists and appears and then the index look up on an album.</p>
<p>356<br>00:33:31,000 –&gt; 00:33:39,000<br>So again, so they’re going to do a bottom approach. So starting here at the bottom, they’re going to say here’s all the possible joint combinations I could have for these three tables.</p>
<p>357<br>00:33:40,000 –&gt; 00:33:45,000<br>And because it’s PowerPoint and for simplicity, right, assuming goes all the way to the side with all possible combinations.</p>
<p>358<br>00:33:45,000 –&gt; 00:33:56,000<br>I’m truncating here in the sake of time. Right. And then now these physical operators then produce an output that’s going to either add, then there’s going to choose one of the two tables to be joined together.</p>
<p>359<br>00:33:56,000 –&gt; 00:34:04,000<br>And then the third table is just waiting to be joined after this. Right. So I can do hash joins, merge joins, and so forth.</p>
<p>360<br>00:34:05,000 –&gt; 00:34:14,000<br>And then now for all these possible paths up to the next level, I’m going to choose for each of these next nodes at the next level above.</p>
<p>361<br>00:34:14,000 –&gt; 00:34:23,000<br>What’s the path that has the lowest cost? Right. So for each of these, I’m going to choose one of them as the best one based on my cost model estimates.</p>
<p>362<br>00:34:24,000 –&gt; 00:34:36,000<br>And then now, again, proceed at the next level to the exact same thing for each of these possible choices here, choose the different physical joint operators that then get me to my final result that I want.</p>
<p>363<br>00:34:36,000 –&gt; 00:34:44,000<br>And then once I’ve done that, do the same thing, choose along which one of these has the shortest of the least cost.</p>
<p>364<br>00:34:44,000 –&gt; 00:34:49,000<br>And then now, since I’ve reached the top of my query plan, I know this is the final result that I want.</p>
<p>365<br>00:34:49,000 –&gt; 00:34:58,000<br>Now I just recurse back and figure out which of these is the cheapest path. And that’s what I’m choosing as the optimal query plan for us. Yes.</p>
<p>366<br>00:35:15,000 –&gt; 00:35:32,000<br>The question is, when do other organizations going to apply like predicate push out here? For this approach in system R, they’re only going to pick this in joint ordering.</p>
<p>367<br>00:35:32,000 –&gt; 00:35:48,000<br>In the case of in high policy next week, they’re going to DP just for joint ordering. The way you would handle the additional things that you’re talking about is that you would define those additional transformation rules in like a stratified search and you apply them potentially with the cost model as well.</p>
<p>368<br>00:35:48,000 –&gt; 00:35:53,000<br>And then you do this this DP search. Cast case will integrate everything all at once.</p>
<p>369<br>00:35:53,000 –&gt; 00:36:09,000<br>So this approach where you literally try all the physical operative possible. Is this in my correct saying this is only practical for a joint ordering? And then if you want to do something like that, put it down to the mother more band population.</p>
<p>370<br>00:36:09,000 –&gt; 00:36:16,000<br>This question is, would you only want to do this bottom approach? Could you would you only do this for joint ordering? Yes.</p>
<p>371<br>00:36:16,000 –&gt; 00:36:27,000<br>Because again, like you’re trying to like march through if I have to do recognize what I want to do predicate push down yet to go back insert it in somewhere and then go back up. Be kind of funky.</p>
<p>372<br>00:36:27,000 –&gt; 00:36:37,000<br>Question. So I think you mentioned that blog for the high point. So is there a special handling for aggregations?</p>
<p>373<br>00:36:37,000 –&gt; 00:36:47,000<br>So there’s special handling for aggregations. You would have to you would treat the aggregation as as a block. And you could subject by that further.</p>
<p>374<br>00:36:47,000 –&gt; 00:37:04,000<br>Like this one is great block. Think of this as a query block. And so yeah, in this case, the aggregation would be the if it’s no necessary query, the aggregation is the final output. So it would be a gray block above this. Yes.</p>
<p>375<br>00:37:04,000 –&gt; 00:37:14,000<br>And then the same thing you could choose what aggregation algorithm I want to use, which most of those are going to be hash joined for the hash aggregate.</p>
<p>376<br>00:37:14,000 –&gt; 00:37:21,000<br>Yes.</p>
<p>377<br>00:37:21,000 –&gt; 00:37:35,000<br>The statement is I said in this approach here, you first pick the access method you’re going to use. Then you pick joint ordering. Is it possible that there would be a different access method would be better for a different joint order? Yes.</p>
<p>378<br>00:37:35,000 –&gt; 00:37:42,000<br>If I recognize that I have an index and I should be doing nested loop joins instead of a hash join.</p>
<p>379<br>00:37:42,000 –&gt; 00:37:53,000<br>But if I’m picking to always do extra join before I check my joiner, yes, I would have a disconnect between the access method and the joiner. For this approach, yes, that’s a problem.</p>
<p>380<br>00:37:53,000 –&gt; 00:38:01,000<br>The stratified search and unified search will fix that because we’ll get everything out once.</p>
<p>381<br>00:38:02,000 –&gt; 00:38:15,000<br>So what’s one problem with this query here? It’s actually not correct, right? Because my original query said I wanted to join these three tables, but I also wanted to do an order by on the final output.</p>
<p>382<br>00:38:15,000 –&gt; 00:38:22,000<br>So in the original implementation of system R, this dynamic programming search piece had no notion of physical properties of data.</p>
<p>383<br>00:38:22,000 –&gt; 00:38:39,000<br>So I’m choosing to do a hash join. If I go back here, what my choices could have been, you know, a certain merge join. So maybe in the case, I wouldn’t better off doing the certain merge join because then my data would have been sorted.</p>
<p>384<br>00:38:40,000 –&gt; 00:38:51,000<br>So the way IBM handles this, or the system R handle this is that they would keep track of the best plan they’ve seen with and without a physical property like the sort order.</p>
<p>385<br>00:38:51,000 –&gt; 00:38:59,000<br>And then they would have that, they would have two plans at the end, and then they would say, okay, my data needs to be sorted.</p>
<p>386<br>00:38:59,000 –&gt; 00:39:13,000<br>So if I have an estimate what the sort cost is going to be, if I add that on to my unsorted data query plan, is that going to be less than the cost of doing the sorting directly within the sort of merge join?</p>
<p>387<br>00:39:13,000 –&gt; 00:39:26,000<br>And if it’s still less, then you pick that one. So it’s sort of like an afterthought they had to add the additional step to deal with physical properties of the data because they had no way to handle that natively in the search.</p>
<p>388<br>00:39:26,000 –&gt; 00:39:37,000<br>Yes. So what are you talking during after the total parameters are, you do the sort of our just part of the join, like you do the sorting of part of the join, or you add an order by like a sort of node above?</p>
<p>389<br>00:39:37,000 –&gt; 00:39:44,000<br>Yes, correct, yes. So saving is what I’m talking about in this case here because the query wants the data to be sorted by artist ID.</p>
<p>390<br>00:39:44,000 –&gt; 00:39:54,000<br>If I if I did a sort of join on artist ID here, then this the output of this would have been sort of on the way that the query wants.</p>
<p>391<br>00:39:54,000 –&gt; 00:40:03,000<br>So you keep track of this query plan and then because it says it’s the best one of all the ones that are sorted, then you keep track of the one that you pick that is not sorted.</p>
<p>392<br>00:40:03,000 –&gt; 00:40:13,000<br>And then at the end of the end you do this final step to say, okay, if I add an order sort operator on the unsorted hash join, is that going to be less than choosing the path of merge join?</p>
<p>393<br>00:40:13,000 –&gt; 00:40:18,000<br>If yes, then I choose it. If no, then I then I revert back to my merge join. Yes.</p>
<p>394<br>00:40:18,000 –&gt; 00:40:23,000<br>So simple downfall over here is not looking at the entire query plan just to get to the endfall.</p>
<p>395<br>00:40:23,000 –&gt; 00:40:27,000<br>Is it saving is the down, it’s a downfall?</p>
<p>396<br>00:40:27,000 –&gt; 00:40:30,000<br>I mean the reason it’s bad. It’s not again, it’s not bad.</p>
<p>397<br>00:40:30,000 –&gt; 00:40:39,000<br>The reason why this is maybe insufficient for what we need is that they can’t holistically look at all the possible choices you could have in the actual query.</p>
<p>398<br>00:40:39,000 –&gt; 00:40:51,000<br>Right? In addition to the heuristic set that they have in the beginning, is they actually going to look a lot like the thing we saw before with the ingress and others.</p>
<p>399<br>00:40:51,000 –&gt; 00:40:56,000<br>Not how ingress to joins, but those logical transformations are going to be written as if and else close.</p>
<p>400<br>00:40:57,000 –&gt; 00:41:04,000<br>When these transformations have any like idea of underlying algorithms, like you know, like, what’s the other layers of tables need to start rescuering?</p>
<p>401<br>00:41:04,000 –&gt; 00:41:13,000<br>If you have like merges that preserve what sort of fluidiness is, is it equal to like popping up that opposite of absolute capture of the Earth?</p>
<p>402<br>00:41:13,000 –&gt; 00:41:21,000<br>His question is, is it possible the transformation rules to understand what the data’s properties look like so that and encounter that in its decisions?</p>
<p>403<br>00:41:21,000 –&gt; 00:41:26,000<br>System R does not, they have later ones will. Right? Yes.</p>
<p>404<br>00:41:26,000 –&gt; 00:41:33,000<br>So, if you wanted to do the rest of the code, you’re probably going to do it after building up the tree right to the way you have ingress one.</p>
<p>405<br>00:41:33,000 –&gt; 00:41:37,000<br>You say it is, if you want to start doing heuristic rules, you do this after this search thing?</p>
<p>406<br>00:41:37,000 –&gt; 00:41:38,000<br>Yeah.</p>
<p>407<br>00:41:38,000 –&gt; 00:41:39,000<br>No, you do this at the end.</p>
<p>408<br>00:41:39,000 –&gt; 00:41:40,000<br>You do this at the end?</p>
<p>409<br>00:41:40,000 –&gt; 00:41:44,000<br>Yes. You can go back and touch it up. What purpose does? Right?</p>
<p>410<br>00:41:44,000 –&gt; 00:41:49,000<br>If you do this search, then they go back and do some other addition operations potentially.</p>
<p>411<br>00:41:49,000 –&gt; 00:41:59,000<br>Right. And then you would be sort of forced if you wanted to do the exact same after the joint search you need to make sure that the bone log is on there.</p>
<p>412<br>00:41:59,000 –&gt; 00:42:00,000<br>Right?</p>
<p>413<br>00:42:00,000 –&gt; 00:42:01,000<br>Yes.</p>
<p>414<br>00:42:01,000 –&gt; 00:42:03,000<br>Because then this generation is for the cooperator.</p>
<p>415<br>00:42:03,000 –&gt; 00:42:04,000<br>Yes.</p>
<p>416<br>00:42:04,000 –&gt; 00:42:08,000<br>So, if you want to do transformations, logical things, you need to do it.</p>
<p>417<br>00:42:08,000 –&gt; 00:42:16,000<br>You need to have a physical plan. You can do digital physical transformations on it.</p>
<p>418<br>00:42:16,000 –&gt; 00:42:20,000<br>Presca says, you’re looking at the Presca’s code, they do the joint sort.</p>
<p>419<br>00:42:20,000 –&gt; 00:42:25,000<br>They pick the joint, they do a bunch of transformations at the beginning, then they do the, there’s cost-based joint-journal ring.</p>
<p>420<br>00:42:25,000 –&gt; 00:42:29,000<br>Then they go back and touch it up and do additional physical optimizations.</p>
<p>421<br>00:42:29,000 –&gt; 00:42:31,000<br>So, the touch ups would be physical and physical transformation?</p>
<p>422<br>00:42:31,000 –&gt; 00:42:33,000<br>Correct. The touch ups would be physical and physical. Yes.</p>
<p>423<br>00:42:33,000 –&gt; 00:42:39,000<br>Okay.</p>
<p>424<br>00:42:39,000 –&gt; 00:42:46,000<br>So, as I said before, this is an NP-complete problem.</p>
<p>425<br>00:42:46,000 –&gt; 00:42:54,000<br>We could run this forever and may not ever actually find the two physical plans.</p>
<p>426<br>00:42:54,000 –&gt; 00:42:57,000<br>So, we need a way to know when we should stop.</p>
<p>427<br>00:42:57,000 –&gt; 00:42:59,000<br>So, we need a notion of search termination.</p>
<p>428<br>00:42:59,000 –&gt; 00:43:04,000<br>And this will both arise in, we need this for lectures and so far in System R.</p>
<p>429<br>00:43:04,000 –&gt; 00:43:09,000<br>But we’ll need this in the stratified search and the unified search of the catkids.</p>
<p>430<br>00:43:09,000 –&gt; 00:43:13,000<br>So, the simplest thing they do is to do wall clock time.</p>
<p>431<br>00:43:13,000 –&gt; 00:43:23,000<br>This is basically, you know, with Presca’s and other systems, you can set basically a time out of how long you want the career optimizer to actually run based on a physical wall clock time.</p>
<p>432<br>00:43:23,000 –&gt; 00:43:33,000<br>You can set a cost threshold where you recognize that if I generate a, the first plan that I see has some kind of cost estimate.</p>
<p>433<br>00:43:33,000 –&gt; 00:43:44,000<br>And then if I run for a certain amount of time and I produce a plan that’s maybe 10% better or some remember like that, then I just say, all right, that’s probably good enough and you stop.</p>
<p>434<br>00:43:44,000 –&gt; 00:43:49,000<br>Of course, now, because you still need the wall clock time because this thing could be unbounded because maybe you never find actually anything better.</p>
<p>435<br>00:43:49,000 –&gt; 00:43:54,000<br>So, you still need to account for that and maybe cut things all right.</p>
<p>436<br>00:43:54,000 –&gt; 00:44:00,000<br>You can try to be dynamic on this, right?</p>
<p>437<br>00:44:00,000 –&gt; 00:44:04,000<br>If you can estimate the complexity of the query and say, okay, well, it’s a 20 table join.</p>
<p>438<br>00:44:04,000 –&gt; 00:44:11,000<br>So, let me go ahead and give it, you know, 10 seconds versus like a one, two table join, you know, maybe give it, you know, half a second or something like that.</p>
<p>439<br>00:44:11,000 –&gt; 00:44:21,000<br>But that’s a really hard problem because you’re essentially trying to predict how long a query is going to run before it actually, you actually know what the query plan is going to be.</p>
<p>440<br>00:44:21,000 –&gt; 00:44:26,000<br>It is possible to just recognize that I bet there’s no more things for me to examine.</p>
<p>441<br>00:44:26,000 –&gt; 00:44:30,000<br>Let me go ahead and stop so you can do this on the sub plan or the group we’ll see in cascades.</p>
<p>442<br>00:44:30,000 –&gt; 00:44:35,000<br>Like if I know that there’s nothing ever, there’s no other permutations I need to consider for some sub plan.</p>
<p>443<br>00:44:35,000 –&gt; 00:44:42,000<br>Let me just go ahead and stop and keep spending wheels trying to try additional things.</p>
<p>444<br>00:44:42,000 –&gt; 00:45:03,000<br>The last one actually comes from Microsoft, which I think is actually really clever and it seems, and it seems obvious after they sort of say it, where they found that instead of specifying any of these other metrics, like, you know, the walk-alk time, which you really care about is the number of transformations that you’ve actually considered.</p>
<p>445<br>00:45:03,000 –&gt; 00:45:08,000<br>And that’s what they use to just determine whether to stop or not.</p>
<p>446<br>00:45:08,000 –&gt; 00:45:14,000<br>Because the idea is that some transformations may be cheap to apply, some may be expensive.</p>
<p>447<br>00:45:14,000 –&gt; 00:45:31,000<br>So I want to know, like, I get a rough estimate of how long you think a transformation is going to take on average and the number of trends I need to apply, and then you sort of calibrate that to see, this is when I see most of the benefit for the queries that I’m showing throwing into it.</p>
<p>448<br>00:45:31,000 –&gt; 00:45:45,000<br>And then now that’s independent of actually the hardware. So no matter whether someone’s running on a cell phone or a really expensive, you know, high end server, to get the right query plan, it’s the number of transformation you apply rather than the walk-alk time.</p>
<p>449<br>00:45:45,000 –&gt; 00:45:46,000<br>Yes.</p>
<p>450<br>00:45:46,000 –&gt; 00:45:53,000<br>So the server transformations just, like, somewhere easier as 100 to apply, but they, like, waited, sort of, like, it’s, like, not just a hard number.</p>
<p>451<br>00:45:53,000 –&gt; 00:45:57,000<br>Waited in terms of, like, the, oh, for, like, the count?</p>
<p>452<br>00:45:57,000 –&gt; 00:45:58,000<br>Yeah.</p>
<p>453<br>00:45:58,000 –&gt; 00:45:59,000<br>Actually, I don’t know.</p>
<p>454<br>00:45:59,000 –&gt; 00:46:01,000<br>I don’t think they mentioned it.</p>
<p>455<br>00:46:01,000 –&gt; 00:46:02,000<br>Who’s they?</p>
<p>456<br>00:46:02,000 –&gt; 00:46:03,000<br>Microsoft.</p>
<p>457<br>00:46:03,000 –&gt; 00:46:04,000<br>In their talk.</p>
<p>458<br>00:46:04,000 –&gt; 00:46:05,000<br>Yeah.</p>
<p>459<br>00:46:05,000 –&gt; 00:46:08,000<br>Yeah, they don’t mention it.</p>
<p>460<br>00:46:08,000 –&gt; 00:46:09,000<br>All right.</p>
<p>461<br>00:46:09,000 –&gt; 00:46:10,000<br>So, uh,</p>
<p>462<br>00:46:11,000 –&gt; 00:46:15,000<br>the pros and cons of this, this actually works pretty well in practice.</p>
<p>463<br>00:46:15,000 –&gt; 00:46:21,000<br>As I said, most of, most of the participants are going to use something that looks a lot like this.</p>
<p>464<br>00:46:21,000 –&gt; 00:46:30,000<br>And you can do additional rules, again, to filter out things, like, only looking at my deep joins, to prune this, the, the search base to limit the scope and how long it things actually can take.</p>
<p>465<br>00:46:30,000 –&gt; 00:46:39,000<br>The outside is going to be, like, if you start throwing away things, like, but she joins, then you may be just, just, clearly, missing what the actual two optimal plans are going to be.</p>
<p>466<br>00:46:39,000 –&gt; 00:46:40,000<br>Right?</p>
<p>467<br>00:46:40,000 –&gt; 00:46:46,000<br>Because you’re making these decisions to prune things out, without considering, uh, anything about cost.</p>
<p>468<br>00:46:46,000 –&gt; 00:46:54,000<br>And as we said, in the case of some R case, you got to do extra steps to deal with the physical property.</p>
<p>469<br>00:46:54,000 –&gt; 00:47:10,000<br>So, the two approaches that I showed so far, these are typically written in embedded inside the database system, as I was saying, as more or less, if the analysis causes, if my query plan looks like this, then do this transformation.</p>
<p>470<br>00:47:10,000 –&gt; 00:47:11,000<br>Right?</p>
<p>471<br>00:47:11,000 –&gt; 00:47:20,000<br>And if you ever looked at the Postgres code, at least with the query optimizer, and the sub plan, sub plan function, it is like, I do these, check these things, then I check these things, then I check these things, then I check these things.</p>
<p>472<br>00:47:20,000 –&gt; 00:47:28,000<br>And when you go look at them, there are more or less, if the analysis causes, that are looking for queries for certain pattern.</p>
<p>473<br>00:47:28,000 –&gt; 00:47:48,000<br>But the challenge is that, is that, of these approaches, it’s really hard to write a query optimizer in this style code, because it’s, you’re writing it in procedural code, and you’re going to make mistakes, or you’re going to deal with a lot of duplicate logic to identify patterns and so forth, and then apply certain rules.</p>
<p>474<br>00:47:48,000 –&gt; 00:47:55,000<br>And then check to see whether the rule you just apply breaks some other assumption you have about the query plan.</p>
<p>475<br>00:47:55,000 –&gt; 00:47:57,000<br>Right?</p>
<p>476<br>00:47:57,000 –&gt; 00:48:16,000<br>So, a better approach to do this, and what people figured out in late 80s, and what is used in the state of systems today, is that, instead of writing the code, for, here’s actually the check I want to apply, and then the change I want to make, you write the pattern in a high level DSL,</p>
<p>477<br>00:48:16,000 –&gt; 00:48:27,000<br>that’s looking for queries of a certain type, with notes, operatives of certain type, and then the transformation rule, ideally in a DSL, but not always the case, because you can’t do that.</p>
<p>478<br>00:48:27,000 –&gt; 00:48:37,000<br>And then you, you then have a optimizer, or you have your system, generate the code that does those pattern checks and transformations for you.</p>
<p>479<br>00:48:37,000 –&gt; 00:48:41,000<br>It’s very similar to the JIT or Code Gen stuff we talked about for queries.</p>
<p>480<br>00:48:42,000 –&gt; 00:48:55,000<br>So, in the late 80s, early 90s, there was this big movement on what are creating what are called optimizer generators, where again, the idea is that you declare in a high level language, here’s the patterns I want to check for, and then here’s transformations I want to apply when those patterns match.</p>
<p>481<br>00:48:55,000 –&gt; 00:49:09,000<br>And now I can build these, I can then convert these into a, and a code gen, you know, code gen into the actual code, that I put inside my database system, and I only do this when I’m actually compiling the thing, and not like, you know, on a per-cordy basis.</p>
<p>482<br>00:49:09,000 –&gt; 00:49:18,000<br>And then now I can then build the search strategy, or the search mechanism to then look for those patterns and apply them independently of the rules themselves.</p>
<p>483<br>00:49:18,000 –&gt; 00:49:23,000<br>So, somebody, so one team can go ahead and build the search engine, another team can go ahead and define the rules.</p>
<p>484<br>00:49:23,000 –&gt; 00:49:30,000<br>And now I’ve been in this single location, I have all my rules to find, and I can easily extend them and expand them over time.</p>
<p>485<br>00:49:31,000 –&gt; 00:49:40,000<br>So, this is what we’re going to see in all the newer approaches, either doing stratified search and unified search, these are all based on optimizer generators.</p>
<p>486<br>00:49:40,000 –&gt; 00:49:55,000<br>And the two big projects at the time that sort of led this idea was IBM Starburst, which is still using DB2 today, and the first version was Exodus, which is a precursor to the volcano, which is a precursor to cascades.</p>
<p>487<br>00:49:56,000 –&gt; 00:50:02,000<br>In at building the guy built three chore optimizers, cascades is the last one he ended up on.</p>
<p>488<br>00:50:02,000 –&gt; 00:50:08,000<br>So again, the idea is getting your co-genic, the chore optimizer’s patterns based on some higher level language.</p>
<p>489<br>00:50:08,000 –&gt; 00:50:12,000<br>So, the two ways to approach this are going to be a stratified search and a unified search.</p>
<p>490<br>00:50:12,000 –&gt; 00:50:24,000<br>And I’ve already started talking about this already, but the stratified search is that I’m going to do a bunch of transformations in the beginning based on heuristics, things where I know I always want to apply certain rules.</p>
<p>491<br>00:50:24,000 –&gt; 00:50:27,000<br>And then I go ahead and do my call space search.</p>
<p>492<br>00:50:27,000 –&gt; 00:50:30,000<br>The unified search is trying to do this all at once.</p>
<p>493<br>00:50:30,000 –&gt; 00:50:38,000<br>And for, again, another way to, it’s not exactly always going to be top down versus bottom up, right?</p>
<p>494<br>00:50:38,000 –&gt; 00:50:41,000<br>But you can think cascades is a unified search and that’s a top down approach.</p>
<p>495<br>00:50:41,000 –&gt; 00:50:43,000<br>Because everything’s all in the mix and you’re trying to figure things out.</p>
<p>496<br>00:50:43,000 –&gt; 00:50:49,000<br>And then Starburst and others are going to be stratified search, but they’re primarily going to be using the bottoms up.</p>
<p>497<br>00:50:49,000 –&gt; 00:50:55,000<br>But you could do this in a stratified search. You could do a top down search and stratified search.</p>
<p>498<br>00:50:55,000 –&gt; 00:51:08,000<br>Basically, that’s what Microsoft does. They have a bunch of rules that you know you always want to apply, like Praticant pushdown, and even though they’re defined in the same DSL that you would use for the cost based search, they sort of fire those at the very beginning.</p>
<p>499<br>00:51:08,000 –&gt; 00:51:12,000<br>And only at the end later on, then they do the unified search to clean things up further.</p>
<p>500<br>00:51:12,000 –&gt; 00:51:13,000<br>Yes.</p>
<p>501<br>00:51:13,000 –&gt; 00:51:16,000<br>What would a complicate thing say?</p>
<p>502<br>00:51:16,000 –&gt; 00:51:19,000<br>CalSai, I think they claim they’re based on volcano.</p>
<p>503<br>00:51:19,000 –&gt; 00:51:20,000<br>Yeah.</p>
<p>504<br>00:51:20,000 –&gt; 00:51:24,000<br>But they claim that, but I think when we look at it, the lines get blurry.</p>
<p>505<br>00:51:24,000 –&gt; 00:51:27,000<br>They claim the volcano, but it looks like cascades when I look at it.</p>
<p>506<br>00:51:27,000 –&gt; 00:51:30,000<br>And as far as I can tell, I think they’re doing stratified.</p>
<p>507<br>00:51:30,000 –&gt; 00:51:33,000<br>Because they’re doing a bunch of rules you want to apply.</p>
<p>508<br>00:51:33,000 –&gt; 00:51:35,000<br>And then they do a cost based search.</p>
<p>509<br>00:51:35,000 –&gt; 00:51:38,000<br>But I may be wrong. I haven’t looked at the code in a long time.</p>
<p>510<br>00:51:38,000 –&gt; 00:51:39,000<br>Yes.</p>
<p>511<br>00:51:39,000 –&gt; 00:51:42,000<br>If you’re applying, you always want to apply a negative blockade.</p>
<p>512<br>00:51:42,000 –&gt; 00:51:44,000<br>Isn’t that just stratified?</p>
<p>513<br>00:51:44,000 –&gt; 00:51:46,000<br>Yes, I’m saying the lines get blurred.</p>
<p>514<br>00:51:46,000 –&gt; 00:51:48,000<br>So cascades is a unified approach.</p>
<p>515<br>00:51:48,000 –&gt; 00:51:57,000<br>The way Microsoft implements cascades is a stratified plus, you know, is the heuristics, then the search.</p>
<p>516<br>00:51:57,000 –&gt; 00:51:58,000<br>Yes.</p>
<p>517<br>00:51:58,000 –&gt; 00:52:07,000<br>So what’s the DSL, which you can work the logical plan into some DSL and you just met with a recommendation before you come pilot?</p>
<p>518<br>00:52:07,000 –&gt; 00:52:14,000<br>The question is, would you convert the DSL, would you convert the logical plan into a…</p>
<p>519<br>00:52:14,000 –&gt; 00:52:20,000<br>Something similar to what the DSL is, like, like, a negative blockade rule and then you convert or is it…</p>
<p>520<br>00:52:20,000 –&gt; 00:52:23,000<br>No, the DSL would say like, I want to find…</p>
<p>521<br>00:52:23,000 –&gt; 00:52:34,000<br>If I see these, something high level construct, or definitely just say, if I see these three operator nodes next to each other, or in line, then apply this rule.</p>
<p>522<br>00:52:34,000 –&gt; 00:52:41,000<br>So you’re not, like, you’re defining what you want to see in the data structure of the query plan.</p>
<p>523<br>00:52:41,000 –&gt; 00:52:51,000<br>And then the transformation rule, ideally, if you can write that into the DSL, but nobody actually does, that’s usually, like, going to be C++ or something that’s the same language that the system’s written in.</p>
<p>524<br>00:52:51,000 –&gt; 00:52:55,000<br>The transformation rules still means the procedure.</p>
<p>525<br>00:52:55,000 –&gt; 00:53:00,000<br>The transformation you actually apply doesn’t…</p>
<p>526<br>00:53:00,000 –&gt; 00:53:07,000<br>Like, the original definition of these upmatched generators did not define it like that and practice everyone does.</p>
<p>527<br>00:53:07,000 –&gt; 00:53:18,000<br>I think in Cocker’s DB, I think they have it for the rules themselves. They have it in their DSL, but you can then escape that and fall back down the go.</p>
<p>528<br>00:53:18,000 –&gt; 00:53:20,000<br>Yes?</p>
<p>529<br>00:53:20,000 –&gt; 00:53:28,000<br>Is the difference between these two that a unified search is already in the same DSL and start by search search?</p>
<p>530<br>00:53:28,000 –&gt; 00:53:36,000<br>No, so his question is, is the key difference that the unified search and start by search is that these are all written in the same DSL and these are all written separately?</p>
<p>531<br>00:53:36,000 –&gt; 00:53:43,000<br>No. It’s like, are you going to do… are you going to apply much transformation rules without a cost model?</p>
<p>532<br>00:53:43,000 –&gt; 00:53:46,000<br>Or do you do everything all at once with a cost model?</p>
<p>533<br>00:53:46,000 –&gt; 00:53:50,000<br>But SQL Server is a… is there a fight about the cost model?</p>
<p>534<br>00:53:50,000 –&gt; 00:53:53,000<br>They’re using Cascades. That’s what I’m saying, the lines are blurry.</p>
<p>535<br>00:53:53,000 –&gt; 00:53:57,000<br>Let’s not… I’m working on top down versus bottom up. How about that?</p>
<p>536<br>00:53:57,000 –&gt; 00:54:02,000<br>Okay. So, again, stratified search, again, the thing we’ve already talked about.</p>
<p>537<br>00:54:02,000 –&gt; 00:54:07,000<br>You first do all the transformation rules on the logical plans.</p>
<p>538<br>00:54:07,000 –&gt; 00:54:12,000<br>And you don’t consider cost.</p>
<p>539<br>00:54:12,000 –&gt; 00:54:17,000<br>And you basically, as the programmer, the system, you define, here’s the rules I always want to consider.</p>
<p>540<br>00:54:17,000 –&gt; 00:54:24,000<br>Now, you can search engine, it could be clever, and figure out, okay, well, I know the properties of the query plan,</p>
<p>541<br>00:54:24,000 –&gt; 00:54:35,000<br>and I would have enforcer rules in my… from enforcer rules that make sure the properties are being maintained when going from one plane to the next,</p>
<p>542<br>00:54:35,000 –&gt; 00:54:41,000<br>you can have all that in the mix, but the idea, again, we’re doing these transformations without any kind of cost model.</p>
<p>543<br>00:54:41,000 –&gt; 00:54:44,000<br>So, it’s not an exhaustive search.</p>
<p>544<br>00:54:44,000 –&gt; 00:54:50,000<br>And then I do the cost based search to figure out the logical plan, convert the logical plan to a physical plan.</p>
<p>545<br>00:54:50,000 –&gt; 00:54:54,000<br>So, Starburst was the first one that did something like this.</p>
<p>546<br>00:54:54,000 –&gt; 00:55:00,000<br>And again, you see the basic two stages, the rewrite stage, where I’m just like before in System R,</p>
<p>547<br>00:55:00,000 –&gt; 00:55:04,000<br>I’m breaking down this Chinese SQL query into blocks.</p>
<p>548<br>00:55:04,000 –&gt; 00:55:11,000<br>In this case here, they’re actually converting the query plan into relational calculus, not relational algebra.</p>
<p>549<br>00:55:11,000 –&gt; 00:55:15,000<br>It’s… take that little line.</p>
<p>550<br>00:55:15,000 –&gt; 00:55:21,000<br>It’s like existential qualifiers and things like that.</p>
<p>551<br>00:55:21,000 –&gt; 00:55:26,000<br>It’s less… it doesn’t map easily to executable code.</p>
<p>552<br>00:55:26,000 –&gt; 00:55:28,000<br>It’s more mathematical.</p>
<p>553<br>00:55:28,000 –&gt; 00:55:34,000<br>I don’t teach relational calculus anymore because unless you go work on query optimizers, what she’s going to do, sorry.</p>
<p>554<br>00:55:34,000 –&gt; 00:55:37,000<br>Like most people don’t need this.</p>
<p>555<br>00:55:37,000 –&gt; 00:55:43,000<br>We use the teacher, we don’t teach normal forms, there’s a bunch of stuff like in the text where we just don’t teach.</p>
<p>556<br>00:55:43,000 –&gt; 00:55:50,000<br>Basically, again, it’s more higher level expressiveness for relational algebra in relational calculus.</p>
<p>557<br>00:55:50,000 –&gt; 00:55:56,000<br>I don’t… I don’t know if Cod invented it. It’s from the 70s though.</p>
<p>558<br>00:55:56,000 –&gt; 00:56:05,000<br>So they convert it to this higher level form, do a bunch of these rewrites, then they convert that back to a logical plan,</p>
<p>559<br>00:56:05,000 –&gt; 00:56:11,000<br>or the query graph model they call it, and then you do a System R style, bottoms up, dynamic programming,</p>
<p>560<br>00:56:11,000 –&gt; 00:56:14,000<br>phase to figure out the join or additional optimizations.</p>
<p>561<br>00:56:14,000 –&gt; 00:56:18,000<br>So this is what DB2 still even uses today.</p>
<p>562<br>00:56:18,000 –&gt; 00:56:25,000<br>And as far as I know, again, the lines get blurry, is CalSight technically doing stratified search?</p>
<p>563<br>00:56:25,000 –&gt; 00:56:30,000<br>Yes, but I don’t think anybody converts to relational calculus other than IBM.</p>
<p>564<br>00:56:30,000 –&gt; 00:56:39,000<br>And so, for this exact invitation of relational calculus into logical plans and then logical and physical in the step-per-step here,</p>
<p>565<br>00:56:39,000 –&gt; 00:56:41,000<br>as far as I know only DB2 does it.</p>
<p>566<br>00:56:41,000 –&gt; 00:56:46,000<br>But the tricky thing is DB2 doesn’t do this for all… Sorry. IBM doesn’t do this for all versions of DB2.</p>
<p>567<br>00:56:46,000 –&gt; 00:56:51,000<br>So this, I mean, I know that there’s actually four separate code bases of DB2.</p>
<p>568<br>00:56:51,000 –&gt; 00:56:59,000<br>There’s DB2 for ZOS, DB2 for the A900 thing from the 1970s, and there’s…</p>
<p>569<br>00:56:59,000 –&gt; 00:57:03,000<br>Then there’s one for Linux, Unix, and Windows, and there’s a fourth one I’m forgetting.</p>
<p>570<br>00:57:03,000 –&gt; 00:57:05,000<br>But they’re all completely separate code bases.</p>
<p>571<br>00:57:05,000 –&gt; 00:57:14,000<br>And the one that they built for Linux and Unix is actually derived from an earlier project called OS2 Database Manager,</p>
<p>572<br>00:57:14,000 –&gt; 00:57:16,000<br>who here has ever heard of OS2?</p>
<p>573<br>00:57:16,000 –&gt; 00:57:23,000<br>One. It’s the operating system that IBM built in the late 80s or 90s to overtake Windows before Windows became huge.</p>
<p>574<br>00:57:23,000 –&gt; 00:57:28,000<br>Because IBM was… IBM made the first personal PCs, but they made it overcome out of your hardware.</p>
<p>575<br>00:57:28,000 –&gt; 00:57:36,000<br>Everybody started cloning them. So if you look at old magazines, they talk about PCs being IBM PC compatible or cloning compatible.</p>
<p>576<br>00:57:36,000 –&gt; 00:57:41,000<br>They’re just redoing similar things that IBM did. IBM wasn’t making any money off of that.</p>
<p>577<br>00:57:41,000 –&gt; 00:57:47,000<br>They got back into the operating system business for personal computers. They made OS2, Windows killed them.</p>
<p>578<br>00:57:47,000 –&gt; 00:57:52,000<br>Anyway, so they had this database manager system that they built for OS2,</p>
<p>579<br>00:57:52,000 –&gt; 00:57:57,000<br>that then one of the poor renamed OS2 to DB2 and port this.</p>
<p>580<br>00:57:57,000 –&gt; 00:58:05,000<br>But in this great blog article from James Hamilton, James Hamilton basically helped set up all 80bOS’s infrastructure and clogged up beating stuff.</p>
<p>581<br>00:58:05,000 –&gt; 00:58:11,000<br>He’s a big deal there. But he has this great blog article because he used to work on IBM and actually SQL Server as well.</p>
<p>582<br>00:58:11,000 –&gt; 00:58:17,000<br>But it talks about how in the early 1990s, they had this crappy implementation of a database system in OS2,</p>
<p>583<br>00:58:17,000 –&gt; 00:58:22,000<br>but then they went to IBM Research and got the Starburst query up and put that in.</p>
<p>584<br>00:58:22,000 –&gt; 00:58:28,000<br>So the links on the slides, it’s a really good blog article. Yes.</p>
<p>585<br>00:58:28,000 –&gt; 00:58:35,000<br>What do you generally then do you think you can bring into relation to the relationship of the line of countries where it’s there?</p>
<p>586<br>00:58:35,000 –&gt; 00:58:42,000<br>What do the advantages to operating on relational calculus rather than statistical operators?</p>
<p>587<br>00:58:42,000 –&gt; 00:58:47,000<br>I don’t know offhand. I’m sure there are.</p>
<p>588<br>00:58:47,000 –&gt; 00:58:55,000<br>Yeah. It might be just a higher form that you then can apply additional optimizations on. I don’t know.</p>
<p>589<br>00:58:56,000 –&gt; 00:59:06,000<br>Again, outside of Starburst, I don’t, you know, across anything that’s outside of theory in database systems that operate on relational calculus.</p>
<p>590<br>00:59:06,000 –&gt; 00:59:13,000<br>All right. In the sake of time, we’ll just skip this. But like the Starburst operator works ground practice.</p>
<p>591<br>00:59:13,000 –&gt; 00:59:20,000<br>But in the, I don’t think the paper you guys read talked about this, but in a lot of the follow up papers from IBM, they talk about there are struggles of writing the,</p>
<p>592<br>00:59:20,000 –&gt; 00:59:27,000<br>the engineer’s struggle with writing the transformation rules in this DSL that IBM had.</p>
<p>593<br>00:59:27,000 –&gt; 00:59:34,000<br>Again, I think part of it is because you’re operating on relational calculus, which is unnatural. Again, we can cover that further if you want to apply.</p>
<p>594<br>00:59:34,000 –&gt; 00:59:40,000<br>All right. So the last 20 minutes are going to try to cover cascades. Let’s see how far we can get with this.</p>
<p>595<br>00:59:40,000 –&gt; 00:59:46,000<br>Okay. So again, unified search is that logical logical and logical physical or all within one giant stage.</p>
<p>596<br>00:59:46,000 –&gt; 00:59:51,000<br>Of course, the challenge is going to be that there can be a lot of transformations that we’re going to generate as we do this.</p>
<p>597<br>00:59:51,000 –&gt; 01:00:01,000<br>And so we’re going to try to, we’re going to use memoization as a way to keep track of what we’ve done in an efficient manner and try to reduce the amount of, we’re done at work or done in computation that we’re doing.</p>
<p>598<br>01:00:01,000 –&gt; 01:00:07,000<br>So in the future, what volcano does was, and then we’ll see deficiencies of that and then we’ll jump into cascades.</p>
<p>599<br>01:00:07,000 –&gt; 01:00:15,000<br>So, so, vol, again, the computing is, there’s a volcano approach. The due to the legendary. So the, the volcano project of the system,</p>
<p>600<br>01:00:15,000 –&gt; 01:00:20,000<br>defines the iterator model that we all know about, defines the exchange operator due to parallel computation.</p>
<p>601<br>01:00:20,000 –&gt; 01:00:25,000<br>But then he’s also about a state of their optimizer generator that could be used for these things as well.</p>
<p>602<br>01:00:25,000 –&gt; 01:00:30,000<br>As far as they know, nobody does us, although calcite claims they do this, there’s based on this.</p>
<p>603<br>01:00:30,000 –&gt; 01:00:38,000<br>But this is one of the first approaches that doing a, a, a top down on search to generate query plants.</p>
<p>604<br>01:00:38,000 –&gt; 01:00:43,000<br>So, again, in the top down approach, you start with the top. You start with like, this is the output I want.</p>
<p>605<br>01:00:43,000 –&gt; 01:00:48,000<br>They’re going to work down from the bottom and assemble the pieces you need to get back to that top.</p>
<p>606<br>01:00:48,000 –&gt; 01:01:00,000<br>So the, you’re basically going to vote all these, these transformation rules that you have to, to, to generate new physical nodes and logical nodes based on where you’re at in the query plant.</p>
<p>607<br>01:01:00,000 –&gt; 01:01:07,000<br>Right? So here’s all the things, you know, combinations I could have just like before leading down to the individual scans on each of the tables.</p>
<p>608<br>01:01:07,000 –&gt; 01:01:23,000<br>So in the first step here, I could apply transformation rules to convert the, the, the physical join or sort of the logical join and artists appears an album into a emerge join onto the, two of the tables and then have a third table just being fed into it.</p>
<p>609<br>01:01:23,000 –&gt; 01:01:32,000<br>Right? So then I traverse down here and then I say, okay, well for this physical operator, these are the logical operators that fed into me to get me to, to this result.</p>
<p>610<br>01:01:32,000 –&gt; 01:01:40,000<br>So then I applied transformation rules to, to then generate the physical operators that produced the result that I was fed into there.</p>
<p>611<br>01:01:40,000 –&gt; 01:01:48,000<br>And as I’m going down, I’m estimating the cost which I’m not showing here of each of these physical operators summing up the total back up to the root.</p>
<p>612<br>01:01:48,000 –&gt; 01:01:52,000<br>And that tells me the cost to, you know, where I’m at at this branch in the search stream.</p>
<p>613<br>01:01:52,000 –&gt; 01:01:57,000<br>Again, then I get down here and say, well, what fed into, get me to this.</p>
<p>614<br>01:01:57,000 –&gt; 01:02:03,000<br>And then I could, I’m not showing here, but you could pick then the access method for you individual tables.</p>
<p>615<br>01:02:03,000 –&gt; 01:02:11,000<br>Go back up here, traverse down the other side. Here’s the merge join for the other two tables, produce this same thing I’m causing as I’m going along.</p>
<p>616<br>01:02:11,000 –&gt; 01:02:15,000<br>Right? You just keep doing this and over and over until you produce the final result.</p>
<p>617<br>01:02:15,000 –&gt; 01:02:32,000<br>And again, because we care about what the, the sort order is for the table in the output, I have these additional portion rules that I’m defining to make sure that any data that’s being fed into me from operators down below is putting the data in the, in the, in the physical property that I need or expect.</p>
<p>618<br>01:02:32,000 –&gt; 01:02:44,000<br>So in this case here, because I care about the, the data being sorted by artist ID, if I, if I then apply transformation rule that generates a, a hash join, in this case here, that hash join cannot guarantee the data is sorted.</p>
<p>619<br>01:02:44,000 –&gt; 01:02:50,000<br>So I can go ahead and just cut this off and I know don’t need to any further traversal down into to that branch.</p>
<p>620<br>01:02:50,000 –&gt; 01:02:56,000<br>Likewise, if I say, okay, I have a quick sort operator, well that, that I get my data sorted that the way I wanted.</p>
<p>621<br>01:02:56,000 –&gt; 01:03:02,000<br>But then if I come down here, expand it out now to say, well, what was the physical operators, operators feeding into me?</p>
<p>622<br>01:03:02,000 –&gt; 01:03:05,000<br>If I then say, oh, I could do a hash join below.</p>
<p>623<br>01:03:05,000 –&gt; 01:03:13,000<br>And now the cumulative cost of the quick sort plus the hash join is greater than the lowest path I’ve seen down to the bottom.</p>
<p>624<br>01:03:13,000 –&gt; 01:03:18,000<br>Then I know I don’t need to expand this any further and I can cut off this branch right there.</p>
<p>625<br>01:03:18,000 –&gt; 01:03:23,000<br>This is classic branch of balance search, nothing fancy here.</p>
<p>626<br>01:03:23,000 –&gt; 01:03:26,000<br>All right, so let’s jump the cascades.</p>
<p>627<br>01:03:26,000 –&gt; 01:03:32,000<br>So the reason why I don’t have you read the original cascades paper is that it’s actually not that great.</p>
<p>628<br>01:03:32,000 –&gt; 01:03:35,000<br>Have you guys read it?</p>
<p>629<br>01:03:35,000 –&gt; 01:03:42,000<br>It’s not like you keep banging on how great his stuff is object oriented because that was the hot thing in the 90s and volcano and Exodus were not.</p>
<p>630<br>01:03:42,000 –&gt; 01:03:46,000<br>But you can’t, you can’t actually can’t take this paper and actually implement it.</p>
<p>631<br>01:03:46,000 –&gt; 01:03:52,000<br>The best you could do is this thing from, it’s a master’s thesis from, from 1998 at a Portland State,</p>
<p>632<br>01:03:52,000 –&gt; 01:03:57,000<br>or the first 30 pages tells you actually what cascades is actually doing way better than the original paper is.</p>
<p>633<br>01:03:57,000 –&gt; 01:04:03,000<br>So if you want to know what cascades is, you could read again pages one to 31 and I’ll tell you how to do it in there.</p>
<p>634<br>01:04:03,000 –&gt; 01:04:06,000<br>But this will begin to be a quick crash course on it.</p>
<p>635<br>01:04:06,000 –&gt; 01:04:11,000<br>So the key, just like in volcano, we’re going to top down approach, backward chaining.</p>
<p>636<br>01:04:11,000 –&gt; 01:04:24,000<br>But the key thing is that now we’re going to sport rewriting through these direct mapping functions that can iteratively generate the transformations apply them to fan out the search tree rather than doing them all at once.</p>
<p>637<br>01:04:24,000 –&gt; 01:04:33,000<br>So I didn’t show in the case of volcano because it’s PowerPoint. But like every time I went down to another node, I immediately applied the transformation rule that generate all the possible combinations below me.</p>
<p>638<br>01:04:33,000 –&gt; 01:04:43,000<br>And then I would iteratively look at them one by one. Of course now that would be super sensitive to do if it really complex query plan because now the search base is going to balloon and you’re going to run out and run out of memory.</p>
<p>639<br>01:04:43,000 –&gt; 01:04:52,000<br>So the key idea they’re going to do is they’re going to introduce placeholders to say, here’s what the data should look like below me at this part of the tree.</p>
<p>640<br>01:04:52,000 –&gt; 01:04:58,000<br>But I don’t actually know what the right way to execute it just yet is. So I’m just going to have a placeholder for now.</p>
<p>641<br>01:04:58,000 –&gt; 01:05:10,000<br>And then only when when I care about going that further, then I can expand it out. But now I can expand it incrementally based on a priority that I can define to say, here’s the things actually I should be looking at first.</p>
<p>642<br>01:05:11,000 –&gt; 01:05:16,000<br>And you define that all within the construct of the DSL that you’re defining these rules.</p>
<p>643<br>01:05:17,000 –&gt; 01:05:30,000<br>So the four key ideas, one is that all the options in the task are going to be self-contained data structures. So node, if analysis, think of these like structs or objects to say, here’s the pattern I want to match in my query plan.</p>
<p>644<br>01:05:31,000 –&gt; 01:05:42,000<br>And if you match, apply this rule and the additional metadata specify like what are the properties I need, I need a guarantee or that I’ll generate from this transformation rule for this operator and what priority do I want to give it?</p>
<p>645<br>01:05:44,000 –&gt; 01:05:53,000<br>And this priority stuff is going to be interesting because now as I’m traversing down, I can dynamically change, although Microsoft doesn’t do this, but in the virtual paper they talk about it or the master’s thesis.</p>
<p>646<br>01:05:54,000 –&gt; 01:06:04,000<br>You can, as you look, go down and you recognize my query plan is looking a certain way, I can say, well, I want to apply these transformation rules because I think that’s going to help me out better than just picking one at random.</p>
<p>647<br>01:06:09,000 –&gt; 01:06:21,000<br>And then the other key thing is that, although Microsoft doesn’t do this, but CochlearDB does, is that when you think about doing optimization on the where clause, the expression, the predicates inside the query plan, well, that’s just another tree.</p>
<p>648<br>01:06:22,000 –&gt; 01:06:35,000<br>And so, within the same search engine or the rules engine, you can do optimization for the where clause expressions, in the same way you can do optimizations for the operator tree.</p>
<p>649<br>01:06:36,000 –&gt; 01:06:45,000<br>So simple things like, I can identify where one equals two, you could have a rule that then gets fired to say convert one equals two into false.</p>
<p>650<br>01:06:46,000 –&gt; 01:06:51,000<br>Instead of having to do these optimizations separately.</p>
<p>651<br>01:06:53,000 –&gt; 01:06:54,000<br>So, yes.</p>
<p>652<br>01:06:55,000 –&gt; 01:06:56,000<br>You go over the second term.</p>
<p>653<br>01:06:57,000 –&gt; 01:06:58,000<br>Question, go to the second term.</p>
<p>654<br>01:06:59,000 –&gt; 01:07:13,000<br>So, this, so basically you define in the implementation of the, of the, of the, the, the optimization task, like a pattern plus a transformation rule, you define in that within directly, here’s the properties that I need you to enforce.</p>
<p>655<br>01:07:14,000 –&gt; 01:07:21,000<br>And then the, the surgeon can recognize, okay, suddenly feeding into me is going to violate that. So, therefore I can’t, I can’t choose anything below that.</p>
<p>656<br>01:07:22,000 –&gt; 01:07:28,000<br>And the second one basically says, like, if I recognize as I’m going along, I’m trying to think, I have an example here.</p>
<p>657<br>01:07:29,000 –&gt; 01:07:46,000<br>Yeah, I don’t have an, I don’t want to make an example. Like, if I’m, if, as I’m traversing, I may want to consider some transformations more sooner, sooner than others.</p>
<p>658<br>01:07:46,000 –&gt; 01:08:07,000<br>Like, for example, if I know my, if my, my operator, but me say is an index nest at loop join, when I go down below, rather than that looking all possible transformations from logical to physical, like choosing a sweatshirt scan, and then adding, adding a sort, I may want to just choose the index probe first.</p>
<p>659<br>01:08:08,000 –&gt; 01:08:11,000<br>Because then that, that gives me the data in the right order that I need going up.</p>
<p>660<br>01:08:12,000 –&gt; 01:08:14,000<br>So, that also applies in the hot, the priority.</p>
<p>661<br>01:08:15,000 –&gt; 01:08:24,000<br>Yes, this is what the priority, it’s, it’s generated on the fly. Well, so, the case of Microsoft, I think they just like hard coded it. So, yes, part of the task itself.</p>
<p>662<br>01:08:25,000 –&gt; 01:08:35,000<br>And there is no paper, which, which, cockroaches you be, I think, I think they said they actually do. I actually, actually, I, I don’t know whether anybody does this, but in theory, you could, you could dynamically change this as you go along.</p>
<p>663<br>01:08:35,000 –&gt; 01:08:44,000<br>So, even though you may, you may revisit the same, you may come back to the, to a same group later on.</p>
<p>664<br>01:08:45,000 –&gt; 01:08:50,000<br>Because you did maybe not value everything, you could change the order, you, you, you by way stuff.</p>
<p>665<br>01:08:52,000 –&gt; 01:09:02,000<br>All right, so this part is, I mean, confusing because I use expressions, it typically mean like the predicates and a wear cause, but in cascades, expressions going to be some, some operation within the query plan.</p>
<p>666<br>01:09:02,000 –&gt; 01:09:16,000<br>That’s going to do something, right, or, you know, do some, some amount of computation in the query plan. So, a logical expression could be, you know, three by join on a, B and C where I joined a, B and first followed by joining C.</p>
<p>667<br>01:09:17,000 –&gt; 01:09:25,000<br>And the physical expression could then be the, I do a hash on it on, on a sweatshirt scan on for this, a special one for that, then to do this, let join on index probe on this.</p>
<p>668<br>01:09:25,000 –&gt; 01:09:36,000<br>So, it’s defining like some set of, I don’t say operators, but tasks within our query plan that we want to then transform into physical operators.</p>
<p>669<br>01:09:37,000 –&gt; 01:09:53,000<br>Right. And so, the key thing that we’re going to exploit is obviously, equivalency rules in relational algebra, because we would know that, you know, we could switch the order of, of A, join B, to be, B, join A. And that will still produce this, you know, the same correct result that we would want.</p>
<p>670<br>01:09:53,000 –&gt; 01:10:06,000<br>And so, we, we use that to define, when we do our transformations, if we’re permuting things a certain way, that we’re not violating any of those, these community, community properties, or other properties that we care about relational algebra.</p>
<p>671<br>01:10:07,000 –&gt; 01:10:20,000<br>So, then now we have the definition of a group, and that’ll be, for a given expression, it’ll be all the, the logical and physical expressions that are equivalent to some output that, that would expect.</p>
<p>672<br>01:10:21,000 –&gt; 01:10:35,000<br>So, in this case here, I want to, I want to produce the result of joining A, B, and C together, and my logical expressions within that group will be all the different permutations of, of doing those joins, and the physical expressions will be all the actual implementations of, of that.</p>
<p>673<br>01:10:38,000 –&gt; 01:10:45,000<br>So, again, it’s all the logical forms, and then all the physical forms that can be derived, that, from, from these, from these logical forms.</p>
<p>674<br>01:10:46,000 –&gt; 01:10:58,000<br>So, the entire collection of these things is the group, in addition with the properties that we, we would, we would, we would need to be enforced going into this, and then we have all, again, all the equivalent expressions for the logical and physical.</p>
<p>675<br>01:10:59,000 –&gt; 01:11:14,000<br>And then now we’re going to find a multi expression, which is sort of confusing, but that’s basically meant to be as a placeholder to say, here’s some expression that I, that I have, but I don’t know exactly the details what’s going on in this.</p>
<p>676<br>01:11:15,000 –&gt; 01:11:42,000<br>So, I’m going to go inside of it, and it’s a placeholder to say, there’s something below me in the search tree. So, for example, I want to join A, B, and C, so I could have, oops, sorry, I could have a, a multi expression to say, okay, there’s a joint and A, B together, I don’t know what order in which way, logically, and then I join with C, or I could join B, and C, and I don’t define, again, what way I’m doing that, but it’s just a placeholder to say, something below me in the tree is going to be, tell me how to do this.</p>
<p>677<br>01:11:42,000 –&gt; 01:11:53,000<br>So, the idea is that we’re using these multi expressions as a way to reduce the number of unique operators that we have to look at in this giant search tree.</p>
<p>678<br>01:11:54,000 –&gt; 01:12:03,000<br>So, the idea again, because we’re top down, we can make decisions by looking at this placeholder at this point, at some level in the tree, without having to go all the way to the bottom.</p>
<p>679<br>01:12:04,000 –&gt; 01:12:11,000<br>In the case of a bottom-ups optimizer, you’re enumerating all the multi expressions one at time and putting them together, going up to the top.</p>
<p>680<br>01:12:12,000 –&gt; 01:12:17,000<br>In that case, they have not been materialized yet, because you’re starting from the bottom, going to the top.</p>
<p>681<br>01:12:17,000 –&gt; 01:12:24,000<br>In the case of the top down one, you assume sort of roughly that you have the path going down the bottom, even though you don’t actually, at this point.</p>
<p>682<br>01:12:26,000 –&gt; 01:12:31,000<br>So, this we’ve already talked about before, but basically, transformation rules, logical, logical, logical, physical.</p>
<p>683<br>01:12:32,000 –&gt; 01:12:38,000<br>In the Cascades parlance, they’ll say, a transformation rule is logical, logical, and the implementation rule is logical, physical.</p>
<p>684<br>01:12:38,000 –&gt; 01:12:49,000<br>And then they’ll have this pattern defined as the structure of the logical expression that you want to look for, and then you have a substitution to define the rule of the new structure you expect to see after you do this.</p>
<p>685<br>01:12:50,000 –&gt; 01:13:01,000<br>Now, in some cases, you don’t actually want to maintain the previous history, or the previous plan you’ve permitted or transformed the plan into, because you know something you always want to do.</p>
<p>686<br>01:13:02,000 –&gt; 01:13:13,000<br>So, for example, converting one equals two in a false, I don’t want to maintain that history of like, oh yeah, I did this transformation to convert one equals two to false, because you never want to go back.</p>
<p>687<br>01:13:14,000 –&gt; 01:13:22,000<br>And so, there are ways to just always apply the change, and then not keep history, because you don’t want to balloon up your history space.</p>
<p>688<br>01:13:23,000 –&gt; 01:13:27,000<br>So, here’s a look at a simple example of a rule.</p>
<p>689<br>01:13:28,000 –&gt; 01:13:34,000<br>So, my pattern is that I want to have two equa joints with a right deep joint tree.</p>
<p>690<br>01:13:35,000 –&gt; 01:13:42,000<br>So, each of these nodes here are corresponding to groups, because I’m not defining, at the rule level, what actually is going on inside this group.</p>
<p>691<br>01:13:43,000 –&gt; 01:13:47,000<br>This could be an in-ex scan, it could be another joint, it could be whatever, it doesn’t matter, it’s just some group, it’s a placeholder.</p>
<p>692<br>01:13:48,000 –&gt; 01:13:54,000<br>We have to have a distinct equa joint, these are logical operatives, in this case here, you know, I’m joining two tables together.</p>
<p>693<br>01:13:55,000 –&gt; 01:14:13,000<br>So, say this is my plan that matches this, so again, you see that I have my multi-expression at the top, doing A and B, but I’m not defining how I actually want to do this, but then when you traverse down and below, it says I’m joining A and B, and below that we have some get operatives corresponding to the axis path, the way you’re actually retrieving this data.</p>
<p>694<br>01:14:14,000 –&gt; 01:14:28,000<br>So, this plan here, a logical plan, would match to this rule, and I could have two types of transformations, two types of permutations, I don’t really need to transformation, because that’s a type of rule.</p>
<p>695<br>01:14:29,000 –&gt; 01:14:38,000<br>But I could do a transformation rule that converts me from a left deep joint to a right deep joint, just rotating the tree so that the joints are coming down the right side.</p>
<p>696<br>01:14:38,000 –&gt; 01:14:51,000<br>But again, this is converting a logical operators to another set of logical operators, or I could have an implementation rule that converts all the equa joints into, then to be all certainers joints, or hash joints, or whatever I want.</p>
<p>697<br>01:14:52,000 –&gt; 01:15:00,000<br>So again, these are kind of, this is what the patterns are going to look like, and then we would match on this, and then we can do these changes based on that.</p>
<p>698<br>01:15:01,000 –&gt; 01:15:14,000<br>In this case here, you can see how, in this case, we’ve joined with A and B on the server’s join, but again, in this one here, we have to start the placeholder for the multi-expression, because that’s feeding up into it.</p>
<p>699<br>01:15:15,000 –&gt; 01:15:26,000<br>What’s one obvious problem with this top one here? Because I’m going logical, logical, same with another plan that does right to left.</p>
<p>700<br>01:15:27,000 –&gt; 01:15:33,000<br>We’re going to end up with, same plan, infinite loop, you just keep flipping it back and forth.</p>
<p>701<br>01:15:34,000 –&gt; 01:15:45,000<br>So this is where the memo table is going to help us out, because we can use that to keep track of, I’ve already applied this transformation, because I know the cost of the query plan at this point to avoid getting stuck in these infinite loops.</p>
<p>702<br>01:15:47,000 –&gt; 01:15:56,000<br>So the memo table, at least in the original implementation or definition of the Columbia paper, talks about being a separate data structure, but you could actually embed this information into the groups themselves.</p>
<p>703<br>01:15:57,000 –&gt; 01:16:04,000<br>In the sake of time, this is too heavy to go into for like the last three minutes.</p>
<p>704<br>01:16:05,000 –&gt; 01:16:12,000<br>Let me show one example now, and then we’ll come back to this. We’ll start next class with this all over again.</p>
<p>705<br>01:16:13,000 –&gt; 01:16:15,000<br>It’s all this build, or at least we want to show what it looks like.</p>
<p>706<br>01:16:16,000 –&gt; 01:16:24,000<br>So say this is our query plan we want to look like. Again, the memo table just keeps track of for any multi-expression. Here’s the best physical expression we’ve seen with the given cost.</p>
<p>707<br>01:16:25,000 –&gt; 01:16:32,000<br>So in the very beginning, we start at the top. We want to have a joint between A, B, and C, and we have no physical properties because we’re not doing the order by for simplicity.</p>
<p>708<br>01:16:33,000 –&gt; 01:16:47,000<br>So I could do a logical transformation to convert the transformation rule, apply it to my output, to generate a multi-expression on A and B, joined by C.</p>
<p>709<br>01:16:48,000 –&gt; 01:17:00,000<br>So now I want to start costing this inside whether it’s a worth pursuing further inspection of this multi-expression by traversing down to the query plan, say now my output would be A and join A and B.</p>
<p>710<br>01:17:01,000 –&gt; 01:17:10,000<br>Well, I could join A, the one way to do this is join A followed by join B. And the reason why A and B are both the expressions is because I’m not defining how I’m actually getting this data, I’m not defining what the access method is.</p>
<p>711<br>01:17:11,000 –&gt; 01:17:17,000<br>So to get further information about what this possible sub-plank will look like, I have to go down down to the tree now.</p>
<p>712<br>01:17:18,000 –&gt; 01:17:26,000<br>And now in this case here, the only way to access A is to do a logical operator called get A. That’s not interesting, I can’t cost that because it doesn’t tell me how I’m going to do it.</p>
<p>713<br>01:17:27,000 –&gt; 01:17:33,000<br>But I can then do implementation rules to transform this into either a sequential scan on A or an index scan on A.</p>
<p>714<br>01:17:34,000 –&gt; 01:17:42,000<br>But then let’s say for whatever reason for this data, whether it’s query plan is, the sequential scan is faster.</p>
<p>715<br>01:17:43,000 –&gt; 01:17:52,000<br>So now in my memo table for the multi-expression on looking up A, the sequential scan is the best physical operator I have for this and then the cost is 10.</p>
<p>716<br>01:17:53,000 –&gt; 01:18:02,000<br>I do the same thing, I bounce up back up here, do look on the other side of the join, now I do a look at the B multi-expression, same thing, I have a logical operator B.</p>
<p>717<br>01:18:03,000 –&gt; 01:18:12,000<br>I transform that into a sequential scan on B, index scan on B, for whatever reason it’s a sequential scan is faster, then I update my memo table here.</p>
<p>718<br>01:18:13,000 –&gt; 01:18:22,000<br>So now I bounce back up here and now I just, now the transformation rule to go from, you know, to swapping the order for B and A and that’s commuter that’s a lot to do.</p>
<p>719<br>01:18:23,000 –&gt; 01:18:31,000<br>But now when I would do the same thing, I say I have this multi-expression on B and a multi-expression on A, I got to go down to the groups below me and forget what the cost of those things are.</p>
<p>720<br>01:18:32,000 –&gt; 01:18:42,000<br>Well, I’ve already done that, right, because I can go look up on my memo table, recognize that I know the best operator for B and the best operator for A based on what’s up in here.</p>
<p>721<br>01:18:43,000 –&gt; 01:18:49,000<br>So I actually don’t need to do that traversal because I have this information already. I just have to look up on the memo table.</p>
<p>722<br>01:18:50,000 –&gt; 01:18:58,000<br>So now, since I’ve exhausted all my logical expressions that are transformations that I could do, then I start generating all the physical expressions.</p>
<p>723<br>01:18:59,000 –&gt; 01:19:08,000<br>But again, I would do this incrementally, I’m showing this for, but again, you can think of like all possible combinations of join ordering and all possible combinations of different join hour than I would use.</p>
<p>724<br>01:19:09,000 –&gt; 01:19:16,000<br>So now, say for whatever reason when I cost this, the hash join between A and B turns out to be the best, the fastest.</p>
<p>725<br>01:19:17,000 –&gt; 01:19:26,000<br>So then the cost of this now multi-expression is just the cost of accessing A, the cost of accessing B plus the cost of doing the hash join, again these are all just made up numbers.</p>
<p>726<br>01:19:27,000 –&gt; 01:19:37,000<br>So it’s the summation of all of them and now the cost is 80. So for the multi-expression AB, the best physical plan is the hash join on A and B.</p>
<p>727<br>01:19:38,000 –&gt; 01:19:45,000<br>So the cost is 80 and now I bounce up the top and do the same thing down on the other side and so forth.</p>
<p>728<br>01:19:46,000 –&gt; 01:20:00,000<br>So this is what basically a cascade is doing. Again, the devils in the details about how you actually apply the transformation rules. I’m not showing anything about priorities, I’m not showing anything about properties, but this is the high level, this is what the search looks like.</p>
<p>729<br>01:20:00,000 –&gt; 01:20:13,000<br>And then I’ll use my final cost here. And then now if I do any other traversals for maybe other physical operators or other joins, I stop the search once I see a cost that’s greater than 80 or so greater than 125.</p>
<p>730<br>01:20:14,000 –&gt; 01:20:19,000<br>All right, so let’s stop here. Any quick questions and we’ll pick up the summary left off.</p>
<p>731<br>01:20:22,000 –&gt; 01:20:23,000<br>What do we predict wrong?</p>
<p>732<br>01:20:30,000 –&gt; 01:20:41,000<br>The question is, we’ll talk about next week at activity stuff. What are my estimates are wrong? What happens?</p>
<p>733<br>01:20:42,000 –&gt; 01:20:52,000<br>Most systems, nothing. You just keep going. We’ll see ways to put hooks in the query plan to say, okay, if I’m getting wrong, go back and replant things.</p>
<p>734<br>01:20:52,000 –&gt; 01:21:01,000<br>We’ll see cases like an IBM, another systems where you get feedback from like, hey, you told me this, but it’s really this when I ran it again. So the next query comes along, you can get updated on this.</p>
<p>735<br>01:21:02,000 –&gt; 01:21:06,000<br>But in general, like all this memo state, it’s thrown away when the query is done.</p>
<p>736<br>01:21:07,000 –&gt; 01:21:16,000<br>Because why I don’t want to do this in our optimizer. But then like this thing is huge. How long should that be maintained for? Right?</p>
<p>737<br>01:21:17,000 –&gt; 01:21:30,000<br>Also, when I’m not showing in these multi-expressions, like I’m not showing what the original query is, like the sequential can cost 10 for on A, but what’s the predicate? What’s the where clause? That could be different from one with query to another. You’d have to account for that in your memo table as well.</p>
<p>738<br>01:21:31,000 –&gt; 01:21:35,000<br>So that you potentially could reuse it across different queries.</p>
<p>739<br>01:21:35,000 –&gt; 01:21:43,000<br>Okay, I’m always over ambitious of what I can try to cover in the last class.</p>
<p>740<br>01:21:44,000 –&gt; 01:21:52,000<br>Obviously, it’s one lecture. So let me just say we’ll pick up next class on, we’ll go through cascades again because you sort of rush that.</p>
<p>741<br>01:21:53,000 –&gt; 01:21:56,000<br>Then we’ll talk about randomized search for like in postgres and others.</p>
<p>742<br>01:21:58,000 –&gt; 01:22:03,000<br>I debate whether I actually teach that because, like I said, nobody actually really uses it and the postgres one is broken.</p>
<p>743<br>01:22:04,000 –&gt; 01:22:10,000<br>Last year, I put together this playlist on YouTube. These are all the talks in the various companies over the years that come talk to their query optimizers.</p>
<p>744<br>01:22:11,000 –&gt; 01:22:21,000<br>The one I cannot recommend enough is the one from Microsoft on SQL Server. Because again, in my opinion, that’s the other way hyper is going to do join ordering. This is the best one.</p>
<p>745<br>01:22:22,000 –&gt; 01:22:28,000<br>This is a really great talk. The next best one is probably from Becca from CockroachDB to talk about how she built their query optimizer, which is based on cascades.</p>
<p>746<br>01:22:28,000 –&gt; 01:22:32,000<br>They do some of the things that Microsoft doesn’t do.</p>
<p>747<br>01:22:33,000 –&gt; 01:22:43,000<br>Next class will be, finish up with cascades, finish up with random algorithms. We’ll see how Germans do un-nesting subquers and how Germans do dynamic programming through hyper graphs for picking joiner.</p>
<p>748<br>01:22:44,000 –&gt; 01:22:46,000<br>Okay? All right guys, see ya.</p>
<p>749<br>01:23:28,000 –&gt; 01:23:30,000<br>Okay.</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CMU15721 P14S202413 QueryOptimizerImplementation1CMUAdvancedDatabaseSystems</div>
      <div>http://example.com/2025/10/25/CMU15721 P14S202413-QueryOptimizerImplementation1CMUAdvancedDatabaseSystems/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/25/CMU15721%20P15S202414-QueryOptimizerImplementation2CMUAdvancedDatabaseSystems/" title="CMU15721 P15S202414 QueryOptimizerImplementation2CMUAdvancedDatabaseSystems">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CMU15721 P15S202414 QueryOptimizerImplementation2CMUAdvancedDatabaseSystems</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/25/CMU15721%20P12S202411-User-DefinedFunctionOptimizationsCMUAdvancedDatabaseSystems/" title="CMU15721 P12S202411 User DefinedFunctionOptimizationsCMUAdvancedDatabaseSystems">
                        <span class="hidden-mobile">CMU15721 P12S202411 User DefinedFunctionOptimizationsCMUAdvancedDatabaseSystems</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
