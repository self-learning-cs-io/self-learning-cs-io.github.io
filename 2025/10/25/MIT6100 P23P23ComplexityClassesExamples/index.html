

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="100:00:00,000 –&gt; 00:00:14,880All right, so let’s get started with today’s lecture. 200:00:14,880 –&gt; 00:00:20,780We’re going to look at a lot more code where we basically figure out the complexit">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT6100 P23P23ComplexityClassesExamples">
<meta property="og:url" content="http://example.com/2025/10/25/MIT6100%20P23P23ComplexityClassesExamples/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="100:00:00,000 –&gt; 00:00:14,880All right, so let’s get started with today’s lecture. 200:00:14,880 –&gt; 00:00:20,780We’re going to look at a lot more code where we basically figure out the complexit">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-25T05:09:25.358Z">
<meta property="article:modified_time" content="2025-10-25T05:11:04.559Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>MIT6100 P23P23ComplexityClassesExamples - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="MIT6100 P23P23ComplexityClassesExamples"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-25 13:09" pubdate>
          2025年10月25日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          98 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">MIT6100 P23P23ComplexityClassesExamples</h1>
            
            
              <div class="markdown-body">
                
                <p>1<br>00:00:00,000 –&gt; 00:00:14,880<br>All right, so let’s get started with today’s lecture.</p>
<p>2<br>00:00:14,880 –&gt; 00:00:20,780<br>We’re going to look at a lot more code where we basically figure out the complexity class</p>
<p>3<br>00:00:20,780 –&gt; 00:00:22,760<br>of that given code.</p>
<p>4<br>00:00:22,760 –&gt; 00:00:26,480<br>So first, let’s remember what we learned at the end of the last lecture.</p>
<p>5<br>00:00:26,480 –&gt; 00:00:33,939<br>So we introduced this theta notation as a notation to mark the order of growth of a particular</p>
<p>6<br>00:00:33,939 –&gt; 00:00:36,640<br>function or a particular piece of code, right?</p>
<p>7<br>00:00:36,640 –&gt; 00:00:42,100<br>And the theta, we preferred over big O notation because the theta allowed us to get this</p>
<p>8<br>00:00:42,100 –&gt; 00:00:47,100<br>asymptotic upper bound on the worst case runtime of our function.</p>
<p>9<br>00:00:47,100 –&gt; 00:00:50,600<br>So we wanted an asymptotic bound as opposed to an upper bound because that upper bound</p>
<p>10<br>00:00:50,600 –&gt; 00:00:53,900<br>can be anything that grows faster than our function, right?</p>
<p>11<br>00:00:53,899 –&gt; 00:00:57,960<br>So we preferred this theta as the asymptotic bound.</p>
<p>12<br>00:00:57,960 –&gt; 00:01:02,979<br>So at the end of last lecture, we basically said that given some function, the theta for</p>
<p>13<br>00:01:02,979 –&gt; 00:01:08,259<br>that function is going to be the dominant term of that function.</p>
<p>14<br>00:01:08,259 –&gt; 00:01:12,579<br>So if we have a whole bunch of terms, we focus on the one that grows the most.</p>
<p>15<br>00:01:12,579 –&gt; 00:01:18,140<br>We drop any additive constants, any multiplicative constants, and all the other terms that don’t</p>
<p>16<br>00:01:18,140 –&gt; 00:01:22,079<br>grow as fast as that one, as that biggest one, okay?</p>
<p>17<br>00:01:22,079 –&gt; 00:01:25,799<br>So we ended up with some classes of algorithms that we’re going to go over today.</p>
<p>18<br>00:01:25,799 –&gt; 00:01:29,239<br>We’re going to see a bunch of codes that fall within those classes of algorithms.</p>
<p>19<br>00:01:29,239 –&gt; 00:01:35,599<br>But before we go into that, I wanted to just quickly recap sort of the end of last lecture.</p>
<p>20<br>00:01:35,599 –&gt; 00:01:41,519<br>So we saw an example that was pretty similar to this one, if not the same.</p>
<p>21<br>00:01:41,519 –&gt; 00:01:46,759<br>So we know that given some function, we can grab the theta of that function by focusing</p>
<p>22<br>00:01:46,759 –&gt; 00:01:48,400<br>on that dominant term.</p>
<p>23<br>00:01:48,400 –&gt; 00:01:50,759<br>But how do we get at that function?</p>
<p>24<br>00:01:50,760 –&gt; 00:01:56,800<br>So given some piece of code, the idea to get at that function was to first start by looking</p>
<p>25<br>00:01:56,800 –&gt; 00:01:58,680<br>at the inputs to the function.</p>
<p>26<br>00:01:58,680 –&gt; 00:02:03,880<br>So we have three inputs in this particular case, L, L, L, L, and L2.</p>
<p>27<br>00:02:03,880 –&gt; 00:02:09,200<br>Once we figure out the inputs to this function, we go on and look at everything within the</p>
<p>28<br>00:02:09,200 –&gt; 00:02:12,200<br>code that depends on these input parameters.</p>
<p>29<br>00:02:12,200 –&gt; 00:02:17,719<br>So they could be direct, like a loop that goes over something related to the input, or</p>
<p>30<br>00:02:17,719 –&gt; 00:02:21,599<br>it could be indirect, as we’re going to see in some examples later today.</p>
<p>31<br>00:02:21,599 –&gt; 00:02:28,639<br>But we basically look at just the parts of the function that deal with this input.</p>
<p>32<br>00:02:28,639 –&gt; 00:02:36,919<br>If we want to be exact, we start by finding out the exact number of operations that we</p>
<p>33<br>00:02:36,919 –&gt; 00:02:38,919<br>do within this code.</p>
<p>34<br>00:02:38,919 –&gt; 00:02:43,280<br>That’s something that we did when we counted the number of operations given some function.</p>
<p>35<br>00:02:43,280 –&gt; 00:02:50,719<br>So we’re going to count the number of operations given this code in relation to L1, L2, and L.</p>
<p>36<br>00:02:50,719 –&gt; 00:02:56,759<br>So we’ve got this relationship that we can come up with that relates the number of operations</p>
<p>37<br>00:02:56,759 –&gt; 00:03:00,520<br>run as a function of L, L1, and L2.</p>
<p>38<br>00:03:00,520 –&gt; 00:03:08,199<br>So the one over here is constant because we just have an assignment here for some variable.</p>
<p>39<br>00:03:08,199 –&gt; 00:03:11,439<br>The next term here is not constant.</p>
<p>40<br>00:03:11,439 –&gt; 00:03:17,199<br>There are five constant things that we’re doing, assigning i to be a value in range, grabbing</p>
<p>41<br>00:03:17,199 –&gt; 00:03:19,519<br>indexing into L at i.</p>
<p>42<br>00:03:19,519 –&gt; 00:03:25,639<br>That’s two, indexing until i, L1 at i, that’s three, checking the equality that’s four, and</p>
<p>43<br>00:03:25,639 –&gt; 00:03:28,000<br>then setting an L1 to be true, that’s five.</p>
<p>44<br>00:03:28,000 –&gt; 00:03:32,519<br>So there’s five operations, but these are repeated how many times?</p>
<p>45<br>00:03:32,520 –&gt; 00:03:39,320<br>So they’re repeated length L1 times because this loop goes through length L1.</p>
<p>46<br>00:03:39,320 –&gt; 00:03:46,280<br>So this term here, this four loop here, is length L1 times five number of operations.</p>
<p>47<br>00:03:46,280 –&gt; 00:03:51,480<br>Then the one here is this assignment over here, and then this loop down at the bottom is</p>
<p>48<br>00:03:51,480 –&gt; 00:03:58,480<br>exactly the same as the loop up at the top, except that now this bottom loop repeats length</p>
<p>49<br>00:03:58,480 –&gt; 00:04:00,000<br>L2 times.</p>
<p>50<br>00:04:00,000 –&gt; 00:04:04,800<br>So as L2 gets bigger, this loop will take longer to run.</p>
<p>51<br>00:04:04,800 –&gt; 00:04:06,400<br>That’s how we think about that.</p>
<p>52<br>00:04:06,400 –&gt; 00:04:11,000<br>And then lastly, the plus two at the end of that relationship is finding the end of these</p>
<p>53<br>00:04:11,000 –&gt; 00:04:14,960<br>two variables and then doing a return.</p>
<p>54<br>00:04:14,960 –&gt; 00:04:20,040<br>So that leads us to simplify it as five times length L1 plus five times length L2 plus</p>
<p>55<br>00:04:20,040 –&gt; 00:04:25,160<br>three, and this becomes the function that we can then grab the theta of.</p>
<p>56<br>00:04:25,160 –&gt; 00:04:30,480<br>So now we just use the regular rules of theta, law of addition and law of multiplication.</p>
<p>57<br>00:04:30,480 –&gt; 00:04:35,640<br>If there’s anything to add or multiply, in this particular case, let’s say that L1 and</p>
<p>58<br>00:04:35,640 –&gt; 00:04:40,160<br>L2 are all the same length, and then we can simplify the above function to 10 length L plus</p>
<p>59<br>00:04:40,160 –&gt; 00:04:41,000<br>three.</p>
<p>60<br>00:04:41,000 –&gt; 00:04:46,480<br>And then the theta of that becomes just theta of length L. Because we dropped the three,</p>
<p>61<br>00:04:46,480 –&gt; 00:04:55,080<br>we dropped the 10 multiplying L, and then we just keep length L.</p>
<p>62<br>00:04:55,079 –&gt; 00:04:59,159<br>So this is how we get at the theta of a particular function.</p>
<p>63<br>00:04:59,159 –&gt; 00:05:01,159<br>This is when we looked at last time.</p>
<p>64<br>00:05:01,159 –&gt; 00:05:05,959<br>But as we look at more functions today, we’re going to get better at just identifying the</p>
<p>65<br>00:05:05,959 –&gt; 00:05:10,159<br>parts of the code that just deal with our inputs.</p>
<p>66<br>00:05:10,159 –&gt; 00:05:14,639<br>This in L1 equals false, this in L2 equals false, this return, this end.</p>
<p>67<br>00:05:14,639 –&gt; 00:05:17,079<br>Those are all constant things that are happening.</p>
<p>68<br>00:05:17,079 –&gt; 00:05:18,959<br>So we don’t need to focus in on those.</p>
<p>69<br>00:05:18,959 –&gt; 00:05:22,719<br>We just maybe glance at them really quickly to make sure there’s nothing funky going</p>
<p>70<br>00:05:22,720 –&gt; 00:05:25,880<br>on that’s dependent on the length of our lists.</p>
<p>71<br>00:05:25,880 –&gt; 00:05:30,320<br>But we can just basically say, well, we’ve got our inputs, we’ve got one for loop that</p>
<p>72<br>00:05:30,320 –&gt; 00:05:33,360<br>goes through the length, another for loop that goes through the length.</p>
<p>73<br>00:05:33,360 –&gt; 00:05:38,000<br>They’re in series, so we use the law of addition to say that this function is theta of length</p>
<p>74<br>00:05:38,000 –&gt; 00:05:40,000<br>L1 plus length L2.</p>
<p>75<br>00:05:40,000 –&gt; 00:05:44,720<br>So then we can quickly tell the theta of that function just by looking at the parts that</p>
<p>76<br>00:05:44,720 –&gt; 00:05:47,440<br>depend on the input.</p>
<p>77<br>00:05:47,439 –&gt; 00:05:54,319<br>So at the end of last lecture, we ended up with looking at these, sorry, deciding that</p>
<p>78<br>00:05:54,319 –&gt; 00:06:01,040<br>these are the complexity classes that we can categorize a lot of our functions in.</p>
<p>79<br>00:06:01,040 –&gt; 00:06:06,319<br>So theta of 1 is constant, theta of log n is logarithmic, here n is assuming n is the</p>
<p>80<br>00:06:06,319 –&gt; 00:06:08,279<br>input to my function.</p>
<p>81<br>00:06:08,279 –&gt; 00:06:16,079<br>Theta of n is linear, theta of n log n is log linear, theta of n, if n is my input to</p>
<p>82<br>00:06:16,079 –&gt; 00:06:21,599<br>some constant, like n squared and cubed runs in polynomial time, and then theta of some</p>
<p>83<br>00:06:21,599 –&gt; 00:06:26,839<br>constant to the n, where n is my input, is going to be exponential, like 2 to the n, 3 to</p>
<p>84<br>00:06:26,839 –&gt; 00:06:30,360<br>the n, those are all considered exponential time algorithms.</p>
<p>85<br>00:06:30,360 –&gt; 00:06:38,240<br>And when we write our algorithms, we want to be up in this maybe top four, maybe top five,</p>
<p>86<br>00:06:38,240 –&gt; 00:06:42,479<br>though polynomial is going to grow pretty quickly as our input gets big.</p>
<p>87<br>00:06:42,480 –&gt; 00:06:47,080<br>So if we can take our code and just quickly glance at it and classify it within one of</p>
<p>88<br>00:06:47,080 –&gt; 00:06:54,000<br>these algorithms, that can guide us towards deciding whether the algorithm we wrote was</p>
<p>89<br>00:06:54,000 –&gt; 00:06:55,640<br>good or bad, right?</p>
<p>90<br>00:06:55,640 –&gt; 00:06:59,680<br>If we glance at it and say, hey, this algorithm is exponential or this function that I wrote</p>
<p>91<br>00:06:59,680 –&gt; 00:07:04,319<br>is exponential, maybe we want to rethink our approach to the problem and try to get it</p>
<p>92<br>00:07:04,319 –&gt; 00:07:08,480<br>into one of the upper complexity classes.</p>
<p>93<br>00:07:08,480 –&gt; 00:07:12,140<br>So what we’re going to do the rest of this class is just go through a bunch of these</p>
<p>94<br>00:07:12,140 –&gt; 00:07:16,160<br>complexity classes and we’re going to see some codes that belong to these complexity</p>
<p>95<br>00:07:16,160 –&gt; 00:07:22,840<br>classes and hopefully give you an idea of what code looks like that fits in one of these</p>
<p>96<br>00:07:22,840 –&gt; 00:07:24,960<br>complexity classes.</p>
<p>97<br>00:07:24,960 –&gt; 00:07:28,120<br>So the first one we’ll look at is the constant complexity class.</p>
<p>98<br>00:07:28,120 –&gt; 00:07:29,640<br>It’s pretty simple.</p>
<p>99<br>00:07:29,640 –&gt; 00:07:32,759<br>It’s not really very interesting.</p>
<p>100<br>00:07:32,759 –&gt; 00:07:37,160<br>If your code belongs in this constant complexity class, that means that it does not depend</p>
<p>101<br>00:07:37,160 –&gt; 00:07:38,160<br>on the input at all.</p>
<p>102<br>00:07:38,160 –&gt; 00:07:40,600<br>It always runs in constant time.</p>
<p>103<br>00:07:40,600 –&gt; 00:07:47,880<br>So your code can have loops or it can have some sort of recursive structure, but that loop</p>
<p>104<br>00:07:47,880 –&gt; 00:07:51,720<br>or that recursive structure doesn’t depend on the input at all, right?</p>
<p>105<br>00:07:51,720 –&gt; 00:07:53,040<br>So it’s fine to have loops.</p>
<p>106<br>00:07:53,040 –&gt; 00:07:57,440<br>It’s just as long as it doesn’t depend on the input, it’s considered constant.</p>
<p>107<br>00:07:57,440 –&gt; 00:08:00,920<br>So there are some built-in operations that are constant time.</p>
<p>108<br>00:08:00,920 –&gt; 00:08:06,040<br>So if you see any of these operations like indexing into a list, a penning to a list,</p>
<p>109<br>00:08:06,040 –&gt; 00:08:11,680<br>grabbing the value associated with the dictionary, those are all constant time.</p>
<p>110<br>00:08:11,680 –&gt; 00:08:15,200<br>So if you see them in your code, you don’t need to account for them at all.</p>
<p>111<br>00:08:15,200 –&gt; 00:08:20,760<br>But we’re going to see in a few slides that there are some operations on list and dictionaries</p>
<p>112<br>00:08:20,760 –&gt; 00:08:24,160<br>that do add some non-constant complexity.</p>
<p>113<br>00:08:24,160 –&gt; 00:08:25,840<br>So you can’t just brush them off.</p>
<p>114<br>00:08:25,840 –&gt; 00:08:29,280<br>All right, let’s look at a couple examples of code.</p>
<p>115<br>00:08:29,280 –&gt; 00:08:34,600<br>So here’s a very simple function, add x,y, so x and y are my inputs.</p>
<p>116<br>00:08:34,600 –&gt; 00:08:39,639<br>There is no loop or nothing recursive, nothing that takes time here, that nothing that</p>
<p>117<br>00:08:39,639 –&gt; 00:08:41,360<br>repeats in this code.</p>
<p>118<br>00:08:41,360 –&gt; 00:08:43,800<br>So the complexity of this code is theta of 1.</p>
<p>119<br>00:08:43,800 –&gt; 00:08:45,920<br>Okay, that’s it.</p>
<p>120<br>00:08:45,920 –&gt; 00:08:46,920<br>Here’s another example.</p>
<p>121<br>00:08:46,920 –&gt; 00:08:49,200<br>This is our kilometer example.</p>
<p>122<br>00:08:49,200 –&gt; 00:08:51,920<br>Taking in miles, all it does is a multiplication.</p>
<p>123<br>00:08:51,920 –&gt; 00:08:53,440<br>Again, theta of 1.</p>
<p>124<br>00:08:53,440 –&gt; 00:08:57,879<br>There’s nothing interesting going on here, no loop, no recursive.</p>
<p>125<br>00:08:57,879 –&gt; 00:09:01,759<br>Here’s a function that does have a loop within it.</p>
<p>126<br>00:09:01,759 –&gt; 00:09:04,200<br>The first thing we look at, though, is my input.</p>
<p>127<br>00:09:04,200 –&gt; 00:09:06,000<br>What variables my input here?</p>
<p>128<br>00:09:06,000 –&gt; 00:09:07,879<br>It’s x, right?</p>
<p>129<br>00:09:07,879 –&gt; 00:09:11,759<br>So which part of my code here depends on x?</p>
<p>130<br>00:09:11,759 –&gt; 00:09:19,360<br>Well, there’s something that I’m adding here, so I’m adding x onto some number.</p>
<p>131<br>00:09:19,360 –&gt; 00:09:22,759<br>And I do have a loop, but does the loop depend on x?</p>
<p>132<br>00:09:22,759 –&gt; 00:09:28,360<br>No, it depends on some number that is just a hundred within my function.</p>
<p>133<br>00:09:28,360 –&gt; 00:09:34,680<br>If y equals x here, then this code wouldn’t be constant, right?</p>
<p>134<br>00:09:34,680 –&gt; 00:09:37,320<br>Because this loop will go through x times.</p>
<p>135<br>00:09:37,320 –&gt; 00:09:41,960<br>But here y is just a hundred, so this code is theta of 1 complexity.</p>
<p>136<br>00:09:41,960 –&gt; 00:09:46,120<br>There’s nothing here that depends on x as x grows.</p>
<p>137<br>00:09:46,120 –&gt; 00:09:50,399<br>All right, so not very interesting examples there.</p>
<p>138<br>00:09:50,399 –&gt; 00:09:58,559<br>So let’s move on to the next simplest class of functions, the linear complexity class.</p>
<p>139<br>00:09:58,559 –&gt; 00:10:06,639<br>And these functions will be usually denoted by one loop, or maybe many loops in series</p>
<p>140<br>00:10:06,639 –&gt; 00:10:08,319<br>or something like that.</p>
<p>141<br>00:10:08,319 –&gt; 00:10:12,240<br>But these loops all depend just linearly on n.</p>
<p>142<br>00:10:12,240 –&gt; 00:10:18,399<br>You could also have a recursive function that repeats that’s also linearly an n.</p>
<p>143<br>00:10:18,399 –&gt; 00:10:21,039<br>So we’re going to see an example of a recursive function in a little bit.</p>
<p>144<br>00:10:21,039 –&gt; 00:10:26,959<br>But first we’ll start out with just some functions that loop linearly with it.</p>
<p>145<br>00:10:26,959 –&gt; 00:10:32,079<br>There are some built-in operations though that are linear in time.</p>
<p>146<br>00:10:32,079 –&gt; 00:10:38,079<br>So if we ever see these operations within our code, we can’t ignore them.</p>
<p>147<br>00:10:38,079 –&gt; 00:10:43,319<br>Because they will contribute a theta of n complexity to our code.</p>
<p>148<br>00:10:43,320 –&gt; 00:10:44,840<br>So we have to account for them.</p>
<p>149<br>00:10:44,840 –&gt; 00:10:51,400<br>Like if we have some e in n within some other loop, we can’t just say this e in n is constant.</p>
<p>150<br>00:10:51,400 –&gt; 00:10:56,760<br>We’d have to use the law of multiplication or something like that to account for it.</p>
<p>151<br>00:10:56,760 –&gt; 00:11:01,000<br>So checking if an element is in a list obviously is linear because you have to look at each</p>
<p>152<br>00:11:01,000 –&gt; 00:11:06,600<br>element in the list to determine that that e is in it or not.</p>
<p>153<br>00:11:06,600 –&gt; 00:11:11,120<br>Making a copy of your list is also linear in time.</p>
<p>154<br>00:11:11,120 –&gt; 00:11:14,399<br>But though we’re making a copy of half of our list, right?</p>
<p>155<br>00:11:14,399 –&gt; 00:11:23,320<br>So the first half of our list, it’s still linear because copying 0.5 times length L is still</p>
<p>156<br>00:11:23,320 –&gt; 00:11:24,759<br>theta of length L, right?</p>
<p>157<br>00:11:24,759 –&gt; 00:11:28,600<br>That multiplicative constant on the front of our length L is 0.5.</p>
<p>158<br>00:11:28,600 –&gt; 00:11:32,679<br>So if we drop it, that’s still theta of length L.</p>
<p>159<br>00:11:32,679 –&gt; 00:11:36,360<br>Checking for equality between two lists is also constant because you have to look at each</p>
<p>160<br>00:11:36,360 –&gt; 00:11:40,879<br>element in the list, compare them to make sure that they’re the same or not.</p>
<p>161<br>00:11:40,879 –&gt; 00:11:45,519<br>Deleting an item in a list is also linear in time.</p>
<p>162<br>00:11:45,519 –&gt; 00:11:47,879<br>Sorry, this one was constant.</p>
<p>163<br>00:11:47,879 –&gt; 00:11:50,879<br>Sorry, this one was linear in time.</p>
<p>164<br>00:11:50,879 –&gt; 00:11:55,360<br>This deletion is also linear in time just because of the way lists are stored in memory.</p>
<p>165<br>00:11:55,360 –&gt; 00:12:01,480<br>So if you delete an item in the end of from your list, Python will count that as linear</p>
<p>166<br>00:12:01,480 –&gt; 00:12:03,679<br>time complexity.</p>
<p>167<br>00:12:03,679 –&gt; 00:12:05,279<br>So let’s look at some examples.</p>
<p>168<br>00:12:05,279 –&gt; 00:12:08,759<br>First we’ll just start out with just some regular functions with loops and then we’ll</p>
<p>169<br>00:12:08,759 –&gt; 00:12:11,120<br>look at one recursive function.</p>
<p>170<br>00:12:11,120 –&gt; 00:12:14,679<br>So here I’ve got multiply x by y.</p>
<p>171<br>00:12:14,679 –&gt; 00:12:23,559<br>It loops through range y and it just adds x plus x plus x y times.</p>
<p>172<br>00:12:23,559 –&gt; 00:12:25,120<br>So I’ve got two parameters here.</p>
<p>173<br>00:12:25,120 –&gt; 00:12:29,879<br>So I need to think about the complexity of this function with regards to both of them.</p>
<p>174<br>00:12:29,879 –&gt; 00:12:34,279<br>So the complexity with respect to y is theta of y, right?</p>
<p>175<br>00:12:34,279 –&gt; 00:12:37,600<br>Because I’ve got one loop, that’s a function of y.</p>
<p>176<br>00:12:37,600 –&gt; 00:12:40,080<br>So this loop will repeat however big y is.</p>
<p>177<br>00:12:40,080 –&gt; 00:12:45,159<br>So if y increases, the time this loop takes will also increase, right?</p>
<p>178<br>00:12:45,159 –&gt; 00:12:51,000<br>So the theta complexity of this function is theta of y with respect to y.</p>
<p>179<br>00:12:51,000 –&gt; 00:12:55,360<br>But what’s the complexity of this function with respect to x?</p>
<p>180<br>00:12:55,360 –&gt; 00:12:59,080<br>I have no looping structure here that’s with respect to x, right?</p>
<p>181<br>00:12:59,080 –&gt; 00:13:02,240<br>All I’m doing the x is just adding on to some number.</p>
<p>182<br>00:13:02,240 –&gt; 00:13:05,320<br>So the complexity with respect to x is just theta of 1.</p>
<p>183<br>00:13:05,320 –&gt; 00:13:09,400<br>So the overall complexity of this function is just going to be theta of y.</p>
<p>184<br>00:13:09,400 –&gt; 00:13:15,320<br>x does not contribute anything to the runtime of this.</p>
<p>185<br>00:13:15,320 –&gt; 00:13:20,400<br>All right, so this and the previous sort of loop function from the constant kind of tells</p>
<p>186<br>00:13:20,400 –&gt; 00:13:23,800<br>us that we need to be careful about what the inputs are, right?</p>
<p>187<br>00:13:23,800 –&gt; 00:13:29,760<br>When we report the complexity, we have to report it with respect to the inputs to our function.</p>
<p>188<br>00:13:29,760 –&gt; 00:13:34,760<br>We don’t always just say theta of n or theta of n squared or theta of length n, whatever</p>
<p>189<br>00:13:34,759 –&gt; 00:13:37,879<br>it is, we have to relate it to the inputs to our function.</p>
<p>190<br>00:13:37,879 –&gt; 00:13:43,840<br>And if we have more than one input, we have to be careful to account for all of the inputs</p>
<p>191<br>00:13:43,840 –&gt; 00:13:45,519<br>that contribute to the complexity.</p>
<p>192<br>00:13:45,519 –&gt; 00:13:49,080<br>All right, let’s look at another example.</p>
<p>193<br>00:13:49,080 –&gt; 00:13:53,919<br>So here’s one where you take in a string s.</p>
<p>194<br>00:13:53,919 –&gt; 00:13:57,039<br>We loop through each character in s.</p>
<p>195<br>00:13:57,039 –&gt; 00:14:01,080<br>We cast each character to an integer.</p>
<p>196<br>00:14:01,080 –&gt; 00:14:02,720<br>And then we add on to some value.</p>
<p>197<br>00:14:02,720 –&gt; 00:14:08,480<br>So we’re essentially just adding on all of the characters in s, in the string s.</p>
<p>198<br>00:14:08,480 –&gt; 00:14:13,000<br>So this has one loop that loops through all the elements in s.</p>
<p>199<br>00:14:13,000 –&gt; 00:14:17,320<br>Now, if s is a string, what’s going to make this program slower?</p>
<p>200<br>00:14:17,320 –&gt; 00:14:23,200<br>Is it that the string, so the numerical value of the string is bigger?</p>
<p>201<br>00:14:23,200 –&gt; 00:14:29,160<br>No, because if I’m looping through the string 1, 0, 0, 0, it’s going to take the same</p>
<p>202<br>00:14:29,160 –&gt; 00:14:32,680<br>amount of time as if I’m looping through the string 9, 9, 9, 9.</p>
<p>203<br>00:14:32,679 –&gt; 00:14:35,239<br>It’s the length of the string that matters.</p>
<p>204<br>00:14:35,239 –&gt; 00:14:37,199<br>So that’s what this loop is doing, right?</p>
<p>205<br>00:14:37,199 –&gt; 00:14:40,279<br>It’s taking into account the length of the string.</p>
<p>206<br>00:14:40,279 –&gt; 00:14:44,199<br>So if my string is longer, then it’s going to take longer to run.</p>
<p>207<br>00:14:44,199 –&gt; 00:14:47,959<br>So the complexity of this function is just theta of length s.</p>
<p>208<br>00:14:47,959 –&gt; 00:14:52,120<br>That’s the length of the string contributes to slowing down my function.</p>
<p>209<br>00:14:53,439 –&gt; 00:14:55,000<br>Everything else that we do is constant.</p>
<p>210<br>00:14:55,000 –&gt; 00:14:58,079<br>So the overall complexity is theta of length s.</p>
<p>211<br>00:14:58,080 –&gt; 00:15:03,280<br>Or if it’s simpler, you can just say theta of n, but then you have to say where n is</p>
<p>212<br>00:15:03,280 –&gt; 00:15:04,879<br>something like the rest.</p>
<p>213<br>00:15:07,560 –&gt; 00:15:08,840<br>All right, here’s another example.</p>
<p>214<br>00:15:08,840 –&gt; 00:15:13,480<br>This is a factorial program that does it iteratively.</p>
<p>215<br>00:15:13,480 –&gt; 00:15:23,160<br>So it’s going to use a loop to keep multiplying on i to calculate the factorial of some n.</p>
<p>216<br>00:15:23,160 –&gt; 00:15:25,240<br>So in this case, my input is n.</p>
<p>217<br>00:15:25,240 –&gt; 00:15:31,639<br>So now I’m going to look through my function to see what part of my function depends on n.</p>
<p>218<br>00:15:31,639 –&gt; 00:15:33,680<br>So here n is just a number.</p>
<p>219<br>00:15:33,680 –&gt; 00:15:37,399<br>And I’m looping through from two all the way up to n plus one.</p>
<p>220<br>00:15:37,399 –&gt; 00:15:40,440<br>So I’m going to loop through n minus one times overall.</p>
<p>221<br>00:15:43,799 –&gt; 00:15:47,799<br>Since I’m looping through n minus one times, there’s nothing else really that’s contributing</p>
<p>222<br>00:15:47,799 –&gt; 00:15:49,120<br>to the complexity.</p>
<p>223<br>00:15:49,120 –&gt; 00:15:52,279<br>So theta of n minus one is just theta of n.</p>
<p>224<br>00:15:53,279 –&gt; 00:15:56,720<br>So the complexity of this function is just theta of n.</p>
<p>225<br>00:15:59,720 –&gt; 00:16:01,679<br>Everyone, OK, so far.</p>
<p>226<br>00:16:01,679 –&gt; 00:16:06,919<br>So very simple programs that just have one loop just depends on the input linear.</p>
<p>227<br>00:16:09,039 –&gt; 00:16:14,120<br>OK, I will make a little note about the factorial because this is kind of something important.</p>
<p>228<br>00:16:14,120 –&gt; 00:16:18,919<br>It’s going to tell us kind of the difference between theory, which is what this class is mostly</p>
<p>229<br>00:16:18,919 –&gt; 00:16:22,639<br>about, or the set of lectures, and the real world.</p>
<p>230<br>00:16:22,639 –&gt; 00:16:26,959<br>So I actually ran the iterative version of factorial on the computer.</p>
<p>231<br>00:16:26,959 –&gt; 00:16:30,120<br>And you can see here, I’ve multiplied the input by two.</p>
<p>232<br>00:16:30,120 –&gt; 00:16:32,479<br>So 40, 80, 160, 320, and so on.</p>
<p>233<br>00:16:32,479 –&gt; 00:16:39,240<br>So as I’m multiplying the input by two, if I’m expecting this function to be linearly related</p>
<p>234<br>00:16:39,240 –&gt; 00:16:45,559<br>to the input, I’m expecting that the time that this function takes to run is going to be</p>
<p>235<br>00:16:45,559 –&gt; 00:16:47,719<br>approximately twice as long.</p>
<p>236<br>00:16:47,719 –&gt; 00:16:51,639<br>If the input increases by two, the time it takes for this program to run should just increase</p>
<p>237<br>00:16:51,639 –&gt; 00:16:53,679<br>by two as well.</p>
<p>238<br>00:16:53,679 –&gt; 00:16:55,199<br>And it does.</p>
<p>239<br>00:16:55,199 –&gt; 00:16:59,399<br>It does all the way up to somewhere between 640 and 1280.</p>
<p>240<br>00:17:02,639 –&gt; 00:17:07,720<br>So if we do the math, that’s approximately times two each time minus, because we’re just</p>
<p>241<br>00:17:07,720 –&gt; 00:17:09,039<br>doing times here.</p>
<p>242<br>00:17:09,039 –&gt; 00:17:15,079<br>But then, after somewhere within 640 and 1280, the time that it takes to run my</p>
<p>243<br>00:17:15,079 –&gt; 00:17:19,119<br>program no longer follows this linear pattern.</p>
<p>244<br>00:17:19,119 –&gt; 00:17:24,599<br>In fact, it starts to grow faster than linear, and from at a first glance, it looks like</p>
<p>245<br>00:17:24,599 –&gt; 00:17:28,279<br>it grows squared, polynomial.</p>
<p>246<br>00:17:28,279 –&gt; 00:17:33,839<br>So instead of, if you increase the input by two, it looks like the time it takes for</p>
<p>247<br>00:17:33,839 –&gt; 00:17:39,559<br>this program to run increases by four, after some point.</p>
<p>248<br>00:17:39,559 –&gt; 00:17:45,919<br>And that’s because, in the real world, I’ve got Python running on the machine, there’s</p>
<p>249<br>00:17:45,919 –&gt; 00:17:53,480<br>only some set number of bits that my computer can hold, right, when it stores numbers.</p>
<p>250<br>00:17:53,480 –&gt; 00:18:01,839<br>And the factorial of some number within between 640 and 1280 becomes so large that when Python</p>
<p>251<br>00:18:01,839 –&gt; 00:18:08,399<br>and the machine is trying to deal with multiplying these big numbers by these big numbers altogether,</p>
<p>252<br>00:18:08,400 –&gt; 00:18:13,400<br>it’s just taking a really long time to run, because it can’t store these big numbers as</p>
<p>253<br>00:18:13,400 –&gt; 00:18:16,960<br>efficiently as it could store these smaller numbers.</p>
<p>254<br>00:18:16,960 –&gt; 00:18:22,000<br>And so in the real world, what ends up happening is after some, you know, after I’m trying to</p>
<p>255<br>00:18:22,000 –&gt; 00:18:27,600<br>store some really large value and doing the operations with some really large values,</p>
<p>256<br>00:18:27,600 –&gt; 00:18:33,960<br>the time complexity goes down dramatically, right, and squared is a pretty big jump.</p>
<p>257<br>00:18:33,960 –&gt; 00:18:38,559<br>And so this is, kind of, shows the difference between theory and the real world, right,</p>
<p>258<br>00:18:38,559 –&gt; 00:18:44,920<br>so in the real world, we can’t store these values as efficiently as they get big.</p>
<p>259<br>00:18:44,920 –&gt; 00:18:59,160<br>Yeah, so if we use like a machine that had more bits to store values, then we’d be able</p>
<p>260<br>00:18:59,160 –&gt; 00:19:02,519<br>to be more efficient farther along, right?</p>
<p>261<br>00:19:02,519 –&gt; 00:19:06,119<br>Yeah, exactly.</p>
<p>262<br>00:19:06,119 –&gt; 00:19:10,960<br>And we could, I guess we could, if we had a language that was maybe doing some smarter things</p>
<p>263<br>00:19:10,960 –&gt; 00:19:15,559<br>and storing these big values in a much smarter way, that could also have an impact in the</p>
<p>264<br>00:19:15,559 –&gt; 00:19:18,839<br>timing as well.</p>
<p>265<br>00:19:18,839 –&gt; 00:19:23,000<br>But for the purposes of this class, we’re just interested in the theoretical, you know,</p>
<p>266<br>00:19:23,000 –&gt; 00:19:24,960<br>the theoretical happenings here, right?</p>
<p>267<br>00:19:24,960 –&gt; 00:19:30,759<br>So as the input increases by x, we expect that the time that it takes to run the program</p>
<p>268<br>00:19:30,759 –&gt; 00:19:34,640<br>will be x times as long, right, because we’re looking at values that are really, really</p>
<p>269<br>00:19:34,640 –&gt; 00:19:37,079<br>big in theory.</p>
<p>270<br>00:19:37,079 –&gt; 00:19:40,680<br>Okay, so let’s look at another example.</p>
<p>271<br>00:19:40,680 –&gt; 00:19:45,680<br>So this is a factorial function that does it recursively.</p>
<p>272<br>00:19:45,680 –&gt; 00:19:47,879<br>We’ve seen this function before.</p>
<p>273<br>00:19:47,879 –&gt; 00:19:50,279<br>We just looked at the iterative version of factorial.</p>
<p>274<br>00:19:50,279 –&gt; 00:19:53,359<br>Now we’re looking at the recursive version of factorial.</p>
<p>275<br>00:19:53,359 –&gt; 00:19:54,359<br>So what do we have?</p>
<p>276<br>00:19:54,359 –&gt; 00:20:00,599<br>We have one base case, right, that our code will eventually get down to and a recursive</p>
<p>277<br>00:20:00,599 –&gt; 00:20:06,519<br>step, which is just n times factorial and minus one.</p>
<p>278<br>00:20:06,519 –&gt; 00:20:11,159<br>So how do we do the analysis of recursive algorithm?</p>
<p>279<br>00:20:11,159 –&gt; 00:20:15,119<br>Because in this recursive algorithm, we don’t have a loop, right?</p>
<p>280<br>00:20:15,119 –&gt; 00:20:19,799<br>In the previous examples, we had a loop that we could definitively say, hey, this loop</p>
<p>281<br>00:20:19,799 –&gt; 00:20:25,599<br>will repeat this many times, so clearly increasing and will increase the lot the time it takes</p>
<p>282<br>00:20:25,599 –&gt; 00:20:27,319<br>for this loop to run.</p>
<p>283<br>00:20:27,319 –&gt; 00:20:32,359<br>So when we’re dealing with recursive functions, we think about how many times the recursive</p>
<p>284<br>00:20:32,359 –&gt; 00:20:35,079<br>function is going to be called, right?</p>
<p>285<br>00:20:35,079 –&gt; 00:20:40,359<br>Because when we call factorial, right, we have factorial of some, you know, five or whatever</p>
<p>286<br>00:20:40,359 –&gt; 00:20:41,839<br>it is.</p>
<p>287<br>00:20:41,839 –&gt; 00:20:46,839<br>And this calls factorial of four and this calls factorial of three, right?</p>
<p>288<br>00:20:46,839 –&gt; 00:20:54,879<br>And so we have this chain of function calls where we get down to the base case.</p>
<p>289<br>00:20:54,880 –&gt; 00:21:01,880<br>And once we get down to the base case, we start to kick off the step that returns the</p>
<p>290<br>00:21:01,880 –&gt; 00:21:03,800<br>result one at a time.</p>
<p>291<br>00:21:03,800 –&gt; 00:21:10,720<br>So when we’re talking about recursive functions, what we really care about is how many times</p>
<p>292<br>00:21:10,720 –&gt; 00:21:14,160<br>we call the function, okay?</p>
<p>293<br>00:21:14,160 –&gt; 00:21:17,760<br>That’s our quote unquote loop for recursive functions, right?</p>
<p>294<br>00:21:17,760 –&gt; 00:21:22,680<br>It’s just the function calling itself to ask itself to do the work.</p>
<p>295<br>00:21:22,680 –&gt; 00:21:27,039<br>And it does the work with a slightly changed parameter, right?</p>
<p>296<br>00:21:27,039 –&gt; 00:21:32,720<br>So what we need to do is think about how many times does this function call itself?</p>
<p>297<br>00:21:32,720 –&gt; 00:21:37,920<br>And on top of that, is there some sort of overhead that’s not constant?</p>
<p>298<br>00:21:37,920 –&gt; 00:21:43,000<br>In this particular case, when we call factorial recursive, we’re going to go essentially</p>
<p>299<br>00:21:43,000 –&gt; 00:21:45,960<br>theta of n times, right?</p>
<p>300<br>00:21:45,960 –&gt; 00:21:49,960<br>Because we start with n, then we do n minus 1, n minus 2, and minus 3 all the way up</p>
<p>301<br>00:21:49,960 –&gt; 00:21:51,400<br>down to zero, right?</p>
<p>302<br>00:21:51,400 –&gt; 00:21:55,960<br>So effectively, we’ve called ourselves about n times, so theta of n.</p>
<p>303<br>00:21:55,960 –&gt; 00:22:00,780<br>And the overhead for each one of those calls is constant because all I’m doing to n is</p>
<p>304<br>00:22:00,780 –&gt; 00:22:03,920<br>subtracting by 1, and that’s a constant thing, right?</p>
<p>305<br>00:22:03,920 –&gt; 00:22:08,640<br>And minus 1 is theta of 1, it’s just constant.</p>
<p>306<br>00:22:08,640 –&gt; 00:22:15,640<br>So the overall complexity of this is just theta of n, where n is just my input, okay?</p>
<p>307<br>00:22:15,640 –&gt; 00:22:21,080<br>So what we notice is that the iterative and the recursive versions of factorial are both</p>
<p>308<br>00:22:21,079 –&gt; 00:22:23,119<br>theta of n, right?</p>
<p>309<br>00:22:23,119 –&gt; 00:22:28,919<br>Which means that, generally speaking, if we were trying to decide whether to implement factorial</p>
<p>310<br>00:22:28,919 –&gt; 00:22:34,039<br>recursively or iteratively, it won’t really matter in the long run, because the worst case</p>
<p>311<br>00:22:34,039 –&gt; 00:22:37,439<br>complexity is theta of n, it’s the same for both.</p>
<p>312<br>00:22:37,439 –&gt; 00:22:40,359<br>So it would be your choice, which one to actually use.</p>
<p>313<br>00:22:40,359 –&gt; 00:22:46,559<br>All right, so then it maybe comes down to readability or other factors.</p>
<p>314<br>00:22:46,559 –&gt; 00:22:50,119<br>All right.</p>
<p>315<br>00:22:50,119 –&gt; 00:22:51,759<br>Another example, so this is compound.</p>
<p>316<br>00:22:51,759 –&gt; 00:22:56,719<br>We saw this last lecture, we actually timed it and counted how many, actually, I don’t</p>
<p>317<br>00:22:56,719 –&gt; 00:22:57,719<br>remember.</p>
<p>318<br>00:22:57,719 –&gt; 00:23:01,879<br>I don’t think we counted the number of operations, or maybe we did, but we definitely</p>
<p>319<br>00:23:01,879 –&gt; 00:23:03,559<br>timed it.</p>
<p>320<br>00:23:03,559 –&gt; 00:23:07,359<br>So this function took in three parameters.</p>
<p>321<br>00:23:07,359 –&gt; 00:23:12,639<br>So we can have to be careful, which one of these parameters or which parameters of these</p>
<p>322<br>00:23:12,639 –&gt; 00:23:15,000<br>actually contribute to my complexity?</p>
<p>323<br>00:23:15,000 –&gt; 00:23:24,759<br>So this function calculates the amount of money I have if I invest some monthly amount</p>
<p>324<br>00:23:24,759 –&gt; 00:23:28,960<br>at some monthly interest over some number of months.</p>
<p>325<br>00:23:28,960 –&gt; 00:23:34,880<br>So the loop here iterates through number of months, and then everything else seems to</p>
<p>326<br>00:23:34,880 –&gt; 00:23:35,880<br>be constant, right?</p>
<p>327<br>00:23:35,880 –&gt; 00:23:38,039<br>I have gone one loop.</p>
<p>328<br>00:23:38,039 –&gt; 00:23:40,400<br>So the inside of the loop is constant.</p>
<p>329<br>00:23:40,400 –&gt; 00:23:43,440<br>I do have to double check that, but so far so good.</p>
<p>330<br>00:23:43,519 –&gt; 00:23:45,039<br>It’s not looping anything else.</p>
<p>331<br>00:23:45,039 –&gt; 00:23:48,400<br>It’s not a function of anything else.</p>
<p>332<br>00:23:48,400 –&gt; 00:23:53,840<br>The loop itself though is theta of n months, right?</p>
<p>333<br>00:23:53,840 –&gt; 00:23:58,519<br>So the overall complexity of this function is theta of n months, or we could say theta</p>
<p>334<br>00:23:58,519 –&gt; 00:24:02,519<br>of n, where n is equal to n months.</p>
<p>335<br>00:24:02,519 –&gt; 00:24:06,480<br>None of the other parameters contribute to my complexity, and that’s exactly what we</p>
<p>336<br>00:24:06,480 –&gt; 00:24:08,519<br>saw when we ran the code, right?</p>
<p>337<br>00:24:08,519 –&gt; 00:24:13,120<br>We ran it by changing each one of the parameters, and we saw only n months contributed to a</p>
<p>338<br>00:24:13,119 –&gt; 00:24:18,679<br>slowing program.</p>
<p>339<br>00:24:18,679 –&gt; 00:24:25,319<br>If we really wanted to, we could have done this analysis in depth, right?</p>
<p>340<br>00:24:25,319 –&gt; 00:24:29,399<br>As we’ve done last lecture to actually count the full number of operations, or as we did</p>
<p>341<br>00:24:29,399 –&gt; 00:24:31,159<br>at the beginning of this lecture.</p>
<p>342<br>00:24:31,159 –&gt; 00:24:38,119<br>So total equals zero is theta of one, the loop is theta of n months multiplied by four</p>
<p>343<br>00:24:38,119 –&gt; 00:24:39,119<br>operations.</p>
<p>344<br>00:24:39,119 –&gt; 00:24:48,119<br>So I, grabbing a value in range, taking multiplication, addition, and then saving that into total, that’s</p>
<p>345<br>00:24:48,119 –&gt; 00:24:54,319<br>four, multiplied by theta of n, where n is n months, plus theta of one to do the return.</p>
<p>346<br>00:24:54,319 –&gt; 00:24:59,439<br>So that ends up being theta of one plus four and plus one, which just simplifies to theta</p>
<p>347<br>00:24:59,439 –&gt; 00:25:01,159<br>of n, where n is n months.</p>
<p>348<br>00:25:01,159 –&gt; 00:25:02,159<br>Yeah.</p>
<p>349<br>00:25:02,160 –&gt; 00:25:17,640<br>So we’re just looking at operations, right?</p>
<p>350<br>00:25:17,640 –&gt; 00:25:23,360<br>We’re doing calculations with interest and invest and multiplying it with total, right?</p>
<p>351<br>00:25:23,360 –&gt; 00:25:28,360<br>But the fact that interest is bigger, like if the interest is one dollar, or if the interest</p>
<p>352<br>00:25:28,359 –&gt; 00:25:34,199<br>is a thousand dollars, is this going to make that line of code much slower?</p>
<p>353<br>00:25:34,199 –&gt; 00:25:35,959<br>No, right?</p>
<p>354<br>00:25:35,959 –&gt; 00:25:39,279<br>Because all we’re doing is a multiplication between two numbers, right?</p>
<p>355<br>00:25:39,279 –&gt; 00:25:41,319<br>So that’s why the inside is theta of one, right?</p>
<p>356<br>00:25:41,319 –&gt; 00:25:45,959<br>But having a loop where we repeat this over and over again, is going to slow the program</p>
<p>357<br>00:25:45,959 –&gt; 00:25:46,959<br>down.</p>
<p>358<br>00:25:46,959 –&gt; 00:25:47,959<br>Yeah.</p>
<p>359<br>00:25:47,959 –&gt; 00:25:48,959<br>Okay.</p>
<p>360<br>00:25:48,959 –&gt; 00:25:54,479<br>How about this Fibonacci function?</p>
<p>361<br>00:25:54,479 –&gt; 00:25:57,240<br>So this is an iterative version of Fibonacci.</p>
<p>362<br>00:25:57,240 –&gt; 00:25:59,839<br>I don’t know if we’ve seen this before.</p>
<p>363<br>00:25:59,839 –&gt; 00:26:05,759<br>Again, we could do sort of a rough quick analysis where we just briefly glance at every</p>
<p>364<br>00:26:05,759 –&gt; 00:26:11,920<br>single line and ask ourselves whether it’s contributing theta of one or something worse</p>
<p>365<br>00:26:11,920 –&gt; 00:26:17,200<br>to our total run time analysis.</p>
<p>366<br>00:26:17,200 –&gt; 00:26:22,200<br>So we’ve got this first part here, which is just constant, state of one, right?</p>
<p>367<br>00:26:22,200 –&gt; 00:26:24,079<br>Nothing here is loopy.</p>
<p>368<br>00:26:24,079 –&gt; 00:26:26,639<br>There’s no recursive going on.</p>
<p>369<br>00:26:26,639 –&gt; 00:26:30,559<br>Nothing that depends on the input in a non-constant way.</p>
<p>370<br>00:26:30,559 –&gt; 00:26:34,599<br>In the else, we’ve got this constant, again, just assigning two parameters.</p>
<p>371<br>00:26:34,599 –&gt; 00:26:36,119<br>We’ve got a loop.</p>
<p>372<br>00:26:36,119 –&gt; 00:26:41,039<br>So now this loop is going to be non-constant.</p>
<p>373<br>00:26:41,039 –&gt; 00:26:44,679<br>The stuff inside the loop is constant, though, right?</p>
<p>374<br>00:26:44,679 –&gt; 00:26:47,759<br>So the loop itself depends on n, my input.</p>
<p>375<br>00:26:47,759 –&gt; 00:26:50,279<br>So that’s going to be theta of n.</p>
<p>376<br>00:26:50,279 –&gt; 00:26:53,199<br>But that theta of n is multiplied by theta of one.</p>
<p>377<br>00:26:53,200 –&gt; 00:26:55,480<br>The stuff inside the loop is just constant.</p>
<p>378<br>00:26:55,480 –&gt; 00:26:58,720<br>So that’s theta of n times theta of one, which is just theta of n.</p>
<p>379<br>00:26:58,720 –&gt; 00:27:01,920<br>And then the return, of course, is theta of one.</p>
<p>380<br>00:27:01,920 –&gt; 00:27:05,920<br>So we could do a calculation like this, or you could just quickly scan and say, hey,</p>
<p>381<br>00:27:05,920 –&gt; 00:27:10,279<br>I’ve just got a loop that depends on n, and that’s theta of n.</p>
<p>382<br>00:27:10,279 –&gt; 00:27:14,440<br>So the overall complexity of this, if we wanted to be detailed, is this, right?</p>
<p>383<br>00:27:14,440 –&gt; 00:27:19,240<br>Theta of one plus theta of one plus theta of n times theta of one plus theta of one.</p>
<p>384<br>00:27:19,240 –&gt; 00:27:23,920<br>But overall, that just gives us theta of n, because that loop is the only thing that</p>
<p>385<br>00:27:23,920 –&gt; 00:27:26,000<br>depends on my input.</p>
<p>386<br>00:27:26,000 –&gt; 00:27:27,000<br>OK?</p>
<p>387<br>00:27:27,000 –&gt; 00:27:29,200<br>Everyone all right so far?</p>
<p>388<br>00:27:29,200 –&gt; 00:27:31,480<br>OK.</p>
<p>389<br>00:27:31,480 –&gt; 00:27:32,000<br>Perfect.</p>
<p>390<br>00:27:32,000 –&gt; 00:27:36,839<br>So now, let’s move on to the second easiest complexity to kind of identify.</p>
<p>391<br>00:27:36,839 –&gt; 00:27:39,039<br>That’s the polynomial complexity.</p>
<p>392<br>00:27:39,039 –&gt; 00:27:45,960<br>So polynomial complexity generally deals with functions that have nested loops, right?</p>
<p>393<br>00:27:45,960 –&gt; 00:27:51,279<br>So if we have two nested loops that linearly depend on my input, that’s going to be a function</p>
<p>394<br>00:27:51,279 –&gt; 00:27:53,000<br>that’s n squared.</p>
<p>395<br>00:27:53,000 –&gt; 00:27:56,799<br>If I’ve got three nested loops that all depend on my input linearly, that’s going to be</p>
<p>396<br>00:27:56,799 –&gt; 00:27:59,120<br>n cubed, right?</p>
<p>397<br>00:27:59,120 –&gt; 00:28:02,319<br>So let’s see some examples.</p>
<p>398<br>00:28:02,319 –&gt; 00:28:06,039<br>So here I have a really simple nested loop situation.</p>
<p>399<br>00:28:06,039 –&gt; 00:28:13,680<br>I’ve got a function called g, and it’s going to take in an input n.</p>
<p>400<br>00:28:13,680 –&gt; 00:28:17,120<br>So I’m going to look for everything that depends on n.</p>
<p>401<br>00:28:17,120 –&gt; 00:28:22,680<br>Well, I’ve got a for loop here that’s going to iterate n times, that’s theta of n.</p>
<p>402<br>00:28:22,680 –&gt; 00:28:24,840<br>And I’ve got an inner for loop.</p>
<p>403<br>00:28:24,840 –&gt; 00:28:33,039<br>So for each thing in my outer for loop, I’m going to do the inner thing n times as well.</p>
<p>404<br>00:28:33,039 –&gt; 00:28:36,880<br>And then the stuff inside my inner for loop is constant.</p>
<p>405<br>00:28:36,880 –&gt; 00:28:41,560<br>So that’s theta of n, and the stuff outside of my loops are, sorry, the stuff inside my</p>
<p>406<br>00:28:41,559 –&gt; 00:28:46,159<br>inner for loop is theta of 1, and the stuff outside of any of the for loops are theta of</p>
<p>407<br>00:28:46,159 –&gt; 00:28:47,159<br>1 as well.</p>
<p>408<br>00:28:47,159 –&gt; 00:28:49,519<br>So they contribute nothing to this complexity.</p>
<p>409<br>00:28:49,519 –&gt; 00:28:55,319<br>So the only thing that I need to account for is my outer loop, which is theta of n, and</p>
<p>410<br>00:28:55,319 –&gt; 00:29:02,399<br>law of multiplication says my inner loop is going to be multiplied, it’s complexity</p>
<p>411<br>00:29:02,399 –&gt; 00:29:04,919<br>to my outer loop’s complexity.</p>
<p>412<br>00:29:04,919 –&gt; 00:29:08,519<br>So the overall complexity of this function is theta of n squared, because the number of</p>
<p>413<br>00:29:08,519 –&gt; 00:29:15,519<br>times that I’m going to do this operation is going to be n squared times.</p>
<p>414<br>00:29:15,519 –&gt; 00:29:16,519<br>Okay.</p>
<p>415<br>00:29:16,519 –&gt; 00:29:17,519<br>Perfect.</p>
<p>416<br>00:29:17,519 –&gt; 00:29:19,519<br>All right.</p>
<p>417<br>00:29:19,519 –&gt; 00:29:22,519<br>So now let’s look at some examples with lists.</p>
<p>418<br>00:29:22,519 –&gt; 00:29:23,519<br>Right.</p>
<p>419<br>00:29:23,519 –&gt; 00:29:25,519<br>We haven’t seen those yet.</p>
<p>420<br>00:29:25,519 –&gt; 00:29:27,519<br>So now we have to think about the input.</p>
<p>421<br>00:29:27,519 –&gt; 00:29:30,519<br>In this case, it’s going to be two lists.</p>
<p>422<br>00:29:30,519 –&gt; 00:29:34,519<br>And when we’re dealing with lists, one of the things that, sorry, the most common thing we’re</p>
<p>423<br>00:29:35,019 –&gt; 00:29:41,519<br>interested in is what happens to the behavior of the function as the lists get bigger.</p>
<p>424<br>00:29:41,519 –&gt; 00:29:42,519<br>Right.</p>
<p>425<br>00:29:42,519 –&gt; 00:29:49,039<br>As we saw in last lecture, the size of the elements within the list typically don’t matter,</p>
<p>426<br>00:29:49,039 –&gt; 00:29:54,039<br>but the fact that I have more elements to do stuff with does matter.</p>
<p>427<br>00:29:54,039 –&gt; 00:29:55,039<br>Right.</p>
<p>428<br>00:29:55,039 –&gt; 00:29:59,519<br>So if my list now has twice as many elements, this program, or most programs, will probably</p>
<p>429<br>00:29:59,519 –&gt; 00:30:02,440<br>be twice as slow.</p>
<p>430<br>00:30:02,440 –&gt; 00:30:08,240<br>So here’s a function called is subset, takes in two lists, L1 and L2.</p>
<p>431<br>00:30:08,240 –&gt; 00:30:13,279<br>I’ve added two little examples up here to help us figure out what this function does.</p>
<p>432<br>00:30:13,279 –&gt; 00:30:18,840<br>So it’s going to tell us whether the elements of L1 are in L2.</p>
<p>433<br>00:30:18,840 –&gt; 00:30:19,840<br>Right.</p>
<p>434<br>00:30:19,840 –&gt; 00:30:27,080<br>So in the first example here, elements in L1 are 3 and 5 and 2, and L2 does have the 3 and</p>
<p>435<br>00:30:27,080 –&gt; 00:30:30,400<br>the 5 and the 2, but it also has other stuff.</p>
<p>436<br>00:30:30,400 –&gt; 00:30:33,960<br>As totally fine, all the elements in L1 are in L2.</p>
<p>437<br>00:30:33,960 –&gt; 00:30:39,120<br>So this function will return true for those examples, those L1 and L2.</p>
<p>438<br>00:30:39,120 –&gt; 00:30:42,080<br>And then here’s an example where it will return false.</p>
<p>439<br>00:30:42,080 –&gt; 00:30:48,240<br>So the elements of L1 are 3 and 5 and 2, and L2 is missing the 3.</p>
<p>440<br>00:30:48,240 –&gt; 00:30:49,920<br>So then that one will return false, right.</p>
<p>441<br>00:30:49,920 –&gt; 00:30:53,800<br>The elements of L1 are not all in L2.</p>
<p>442<br>00:30:53,800 –&gt; 00:30:55,280<br>So it’s not a subset.</p>
<p>443<br>00:30:55,280 –&gt; 00:30:56,280<br>All right.</p>
<p>444<br>00:30:56,280 –&gt; 00:30:57,880<br>So what’s this function doing?</p>
<p>445<br>00:30:57,880 –&gt; 00:31:00,920<br>Well, it’s iterating through all the elements in L1.</p>
<p>446<br>00:31:00,920 –&gt; 00:31:04,320<br>So it’s going to first look at the 3, then the 5, and the 2.</p>
<p>447<br>00:31:04,320 –&gt; 00:31:09,480<br>It’s going to look through each element in L2 for every one of those L1 elements.</p>
<p>448<br>00:31:09,480 –&gt; 00:31:14,240<br>So it’s going to look at the 3 and the 2, the 3 and the 3, the 3 and the 5, the 3 and the 9.</p>
<p>449<br>00:31:14,240 –&gt; 00:31:18,240<br>Then it’s going to look at the 5 and the 2, the 5 and the 3, 5 and 5, 5 and 9.</p>
<p>450<br>00:31:18,240 –&gt; 00:31:18,560<br>Right.</p>
<p>451<br>00:31:18,560 –&gt; 00:31:20,840<br>It’s going to keep doing that.</p>
<p>452<br>00:31:20,839 –&gt; 00:31:28,439<br>And it’s going to keep track of this Boolean, matched, called matched.</p>
<p>453<br>00:31:28,439 –&gt; 00:31:38,359<br>And it’s going to, as long as it finds this element, E1 within my L2, it’s going to save matched to be true.</p>
<p>454<br>00:31:38,359 –&gt; 00:31:47,000<br>And it’s going to keep doing this until it keeps finding matches.</p>
<p>455<br>00:31:47,000 –&gt; 00:31:49,799<br>It’s long, sorry, until it finds a match.</p>
<p>456<br>00:31:49,799 –&gt; 00:31:55,240<br>As soon as it finds a match, it breaks because there’s no need for it to keep looking at the remaining elements of L2.</p>
<p>457<br>00:31:55,240 –&gt; 00:31:58,480<br>It already found one that matches.</p>
<p>458<br>00:31:58,480 –&gt; 00:32:04,240<br>So this code could actually be rewritten by saying kind of the inverse.</p>
<p>459<br>00:32:04,240 –&gt; 00:32:04,480<br>Right.</p>
<p>460<br>00:32:04,480 –&gt; 00:32:10,680<br>If E1 is not equal to L2, we can just immediately return false.</p>
<p>461<br>00:32:10,680 –&gt; 00:32:15,440<br>Because we’ve already found an element that, from L1, that’s not an L2.</p>
<p>462<br>00:32:15,440 –&gt; 00:32:17,600<br>So we could have rewritten this code in many different ways.</p>
<p>463<br>00:32:17,600 –&gt; 00:32:21,080<br>But the ultimate analysis will be the same.</p>
<p>464<br>00:32:21,080 –&gt; 00:32:25,080<br>So let’s look at the analysis for this function.</p>
<p>465<br>00:32:25,080 –&gt; 00:32:27,400<br>Well, we have two inputs.</p>
<p>466<br>00:32:27,400 –&gt; 00:32:35,200<br>So we have to be careful about both of these inputs, which parts of this function depend on L1 and L2?</p>
<p>467<br>00:32:35,200 –&gt; 00:32:38,000<br>Well, we’ve got an outer for loop.</p>
<p>468<br>00:32:38,000 –&gt; 00:32:45,200<br>So what happens to the complexity with regards to this loop?</p>
<p>469<br>00:32:45,200 –&gt; 00:32:50,519<br>Well, if I have more elements in L1, then this loop will go through more times.</p>
<p>470<br>00:32:50,519 –&gt; 00:32:56,200<br>So this loop will be executed length L1 times.</p>
<p>471<br>00:32:56,200 –&gt; 00:33:00,880<br>So the theta for this outer loop is going to be theta of length L1.</p>
<p>472<br>00:33:00,880 –&gt; 00:33:02,400<br>But there is an inner loop.</p>
<p>473<br>00:33:02,400 –&gt; 00:33:08,319<br>So for each element in my outer loop, I’m also going to do everything in this inner loop.</p>
<p>474<br>00:33:08,319 –&gt; 00:33:08,519<br>Right.</p>
<p>475<br>00:33:08,519 –&gt; 00:33:14,160<br>So in the worst case, I need to look through each element in L2 to find a match.</p>
<p>476<br>00:33:14,160 –&gt; 00:33:20,360<br>So the inner loop will execute at most length L2 times, again, in the worst case.</p>
<p>477<br>00:33:20,360 –&gt; 00:33:24,200<br>So the inner loop will be theta of length L2.</p>
<p>478<br>00:33:24,200 –&gt; 00:33:29,600<br>So the overall complexity, since I’ve got this nested loop situation, law of multiplication,</p>
<p>479<br>00:33:29,600 –&gt; 00:33:34,080<br>says that it’s going to be the theta of my outer loop multiplied by the theta of my inner loop.</p>
<p>480<br>00:33:34,080 –&gt; 00:33:38,759<br>So theta of length L1 times length L2.</p>
<p>481<br>00:33:38,759 –&gt; 00:33:39,120<br>OK.</p>
<p>482<br>00:33:39,120 –&gt; 00:33:40,960<br>Everyone, yeah, question?</p>
<p>483<br>00:33:40,960 –&gt; 00:33:50,440<br>If you think that you have a linear e-slip, then it would be at g.</p>
<p>484<br>00:33:50,440 –&gt; 00:33:51,960<br>Yes.</p>
<p>485<br>00:33:51,960 –&gt; 00:34:04,200<br>So here, in this if, yes, if the if had something like using an in, right, which where in is linear,</p>
<p>486<br>00:34:04,200 –&gt; 00:34:10,720<br>then yes, there would be another, like, it would be like there was another loop at the third level.</p>
<p>487<br>00:34:10,719 –&gt; 00:34:12,439<br>Yeah, so then it would be un-cubed.</p>
<p>488<br>00:34:12,439 –&gt; 00:34:19,119<br>Still polynomial, but un-cubed.</p>
<p>489<br>00:34:19,119 –&gt; 00:34:26,439<br>So if L1 and L2 are the same length, which sometimes we put on to simplify the complexity,</p>
<p>490<br>00:34:26,439 –&gt; 00:34:32,759<br>put this condition on to simplify the complexity, then we say that it’s theta of length L1 squared.</p>
<p>491<br>00:34:32,759 –&gt; 00:34:37,679<br>It’s still polynomial complexity.</p>
<p>492<br>00:34:37,679 –&gt; 00:34:38,679<br>OK.</p>
<p>493<br>00:34:38,679 –&gt; 00:34:43,079<br>Let’s look, sorry, question.</p>
<p>494<br>00:34:43,079 –&gt; 00:34:49,319<br>Yes, if there were not the same length, you have to denote it in terms of the both.</p>
<p>495<br>00:34:49,319 –&gt; 00:34:49,839<br>OK.</p>
<p>496<br>00:34:49,839 –&gt; 00:34:51,679<br>Let’s look at another example.</p>
<p>497<br>00:34:51,679 –&gt; 00:34:57,399<br>So here’s a function that grabs the intersect of two lists.</p>
<p>498<br>00:34:57,399 –&gt; 00:35:02,359<br>So again, I’ve got a little example up here, example L1 and L2.</p>
<p>499<br>00:35:02,359 –&gt; 00:35:07,039<br>So the intersect are going to be the common elements within L1 and L2, but I’m only going to,</p>
<p>500<br>00:35:07,039 –&gt; 00:35:08,880<br>yeah, I’m not going to do duplicates.</p>
<p>501<br>00:35:08,880 –&gt; 00:35:11,480<br>So I’m just going to keep the unique numbers.</p>
<p>502<br>00:35:11,480 –&gt; 00:35:16,360<br>So here I’ve got L1 and L2 contain 352 and 2359.</p>
<p>503<br>00:35:16,360 –&gt; 00:35:22,440<br>So notice the two and the three and the five both occur in both lists.</p>
<p>504<br>00:35:22,440 –&gt; 00:35:27,320<br>So the intersect of these two lists is 23 and five.</p>
<p>505<br>00:35:27,320 –&gt; 00:35:33,239<br>This example here on the right side is going to be a little bit trickier, right?</p>
<p>506<br>00:35:33,239 –&gt; 00:35:36,960<br>It’s kind of a unique edge case, but the code still works for that edge case.</p>
<p>507<br>00:35:36,960 –&gt; 00:35:42,679<br>It’s if I have L1 that has duplicates of some number and L2 that has duplicates of that same number,</p>
<p>508<br>00:35:42,679 –&gt; 00:35:47,720<br>the returned list of the intersect should just be seven, right?</p>
<p>509<br>00:35:47,720 –&gt; 00:35:49,360<br>That one number once.</p>
<p>510<br>00:35:52,360 –&gt; 00:35:55,760<br>So how does the code achieve this?</p>
<p>511<br>00:35:55,760 –&gt; 00:35:57,880<br>So you notice a nice little structure here.</p>
<p>512<br>00:35:57,880 –&gt; 00:36:00,360<br>I’ve got kind of two blocks of code, right?</p>
<p>513<br>00:36:00,360 –&gt; 00:36:06,720<br>I’ve got something here which is going to actually help us build this list of all of the</p>
<p>514<br>00:36:06,719 –&gt; 00:36:09,679<br>elements that are common within the two lists.</p>
<p>515<br>00:36:09,679 –&gt; 00:36:16,439<br>And then something down here where I’m going to call that list to keep only the unique values.</p>
<p>516<br>00:36:16,439 –&gt; 00:36:22,599<br>So up here this has a nested loop situation, just like in the previous example.</p>
<p>517<br>00:36:22,599 –&gt; 00:36:30,480<br>I have to look at all of the pairs from L1 and L2 to figure out which are common.</p>
<p>518<br>00:36:30,480 –&gt; 00:36:35,879<br>So this for loop over L1 is going to go through the three, the five, and the two.</p>
<p>519<br>00:36:35,880 –&gt; 00:36:42,360<br>And then the inner four loop through L2 is going to basically match, take a look at, does the three match the two?</p>
<p>520<br>00:36:42,360 –&gt; 00:36:44,519<br>Does the three match the three? Does the three match the five?</p>
<p>521<br>00:36:44,519 –&gt; 00:36:45,720<br>Does the three match the nine, right?</p>
<p>522<br>00:36:45,720 –&gt; 00:36:49,079<br>And then the five match the two, five match the three, and so on.</p>
<p>523<br>00:36:49,079 –&gt; 00:36:50,880<br>So that’s what those loops are doing.</p>
<p>524<br>00:36:50,880 –&gt; 00:36:56,519<br>And as soon as we find a match, we’re going to append it to this temporary list.</p>
<p>525<br>00:36:56,519 –&gt; 00:37:00,240<br>And it’s okay if we have duplicates in this list.</p>
<p>526<br>00:37:00,239 –&gt; 00:37:06,839<br>So if you look at the example on the right-hand side there with the seven duplicated many times,</p>
<p>527<br>00:37:06,839 –&gt; 00:37:11,679<br>that’s actually going to create a temporary list, right?</p>
<p>528<br>00:37:11,679 –&gt; 00:37:15,439<br>That’s going to contain nine times that seven.</p>
<p>529<br>00:37:15,439 –&gt; 00:37:19,199<br>So it’s going to look at the seven with the seven, and it’s going to say, hey, that’s a match.</p>
<p>530<br>00:37:19,199 –&gt; 00:37:20,519<br>Let me add it.</p>
<p>531<br>00:37:20,519 –&gt; 00:37:25,359<br>Then it’s going to look at the seven with the middle seven and L2, and it’s going to say, let me add that.</p>
<p>532<br>00:37:25,360 –&gt; 00:37:30,840<br>And then it’s going to look at the first seven and L1 with the last seven and L2, and it’s going to say, let me add that.</p>
<p>533<br>00:37:30,840 –&gt; 00:37:35,400<br>And then it’s going to do that same thing all over again when it looks at the middle seven and L1,</p>
<p>534<br>00:37:35,400 –&gt; 00:37:37,280<br>along with each element in L2.</p>
<p>535<br>00:37:37,280 –&gt; 00:37:40,280<br>So it’s going to add the seven three more times.</p>
<p>536<br>00:37:40,280 –&gt; 00:37:45,480<br>And then again, when it looks at the last seven and L1, along with each seven and L2.</p>
<p>537<br>00:37:45,480 –&gt; 00:37:46,480<br>So that’s totally fine.</p>
<p>538<br>00:37:46,480 –&gt; 00:37:48,720<br>That’s just what this code is doing.</p>
<p>539<br>00:37:48,719 –&gt; 00:37:56,959<br>And then the bottom part down here is going to take this temporary list that we created,</p>
<p>540<br>00:37:56,959 –&gt; 00:37:59,639<br>and it’s going to just keep the unique values within it, right?</p>
<p>541<br>00:37:59,639 –&gt; 00:38:07,399<br>So it’s going to create that unique list, and it’s going to say, if I haven’t seen this value in the unique, add it.</p>
<p>542<br>00:38:07,399 –&gt; 00:38:09,559<br>And if I have, don’t do anything.</p>
<p>543<br>00:38:09,559 –&gt; 00:38:16,359<br>So in the end, this code down here is going to take that big list here and just keep the unique values.</p>
<p>544<br>00:38:18,959 –&gt; 00:38:21,359<br>So let’s do the analysis for this.</p>
<p>545<br>00:38:21,359 –&gt; 00:38:30,639<br>So I’ve got my outer for loop and my inner for loop up in the top half of my code here that generates my temporary, long temporary list.</p>
<p>546<br>00:38:30,639 –&gt; 00:38:32,639<br>Potentially long temporary list.</p>
<p>547<br>00:38:32,639 –&gt; 00:38:37,959<br>So that we already know from the previous example is theta of length L1 times theta of length L2, right?</p>
<p>548<br>00:38:37,959 –&gt; 00:38:39,199<br>Pretty simple.</p>
<p>549<br>00:38:39,199 –&gt; 00:38:42,199<br>Now, what about this bottom half here?</p>
<p>550<br>00:38:42,199 –&gt; 00:38:45,559<br>Because we have to be careful about this bottom half.</p>
<p>551<br>00:38:45,559 –&gt; 00:38:50,199<br>This one could also contribute to the complexity, right?</p>
<p>552<br>00:38:50,199 –&gt; 00:38:56,279<br>It’s looping through a temporary variable, a list variable that we created.</p>
<p>553<br>00:38:56,279 –&gt; 00:39:03,279<br>But this list is created by doing something to L1 and L2, right?</p>
<p>554<br>00:39:03,279 –&gt; 00:39:06,279<br>By looking at elements in L1 and L2.</p>
<p>555<br>00:39:06,279 –&gt; 00:39:11,159<br>So it’s actually indirectly related to L1 and L2.</p>
<p>556<br>00:39:11,159 –&gt; 00:39:19,719<br>So we can’t just cast it aside because it could potentially contribute to the complexity of my program, right?</p>
<p>557<br>00:39:19,719 –&gt; 00:39:26,079<br>And in the worst case, I create this temporary variable that looks like this, right?</p>
<p>558<br>00:39:26,079 –&gt; 00:39:34,039<br>So in the worst possible case, my temporary variables length is going to be length L1 times length L2, right?</p>
<p>559<br>00:39:34,039 –&gt; 00:39:39,319<br>I basically added that character every time I compared a value, right?</p>
<p>560<br>00:39:39,320 –&gt; 00:39:44,960<br>So this list at worst case is length L1 times length L2 block.</p>
<p>561<br>00:39:44,960 –&gt; 00:39:54,920<br>So if I’m iterating through that list, then the complexity of that second half is also theta of length L1 times length L2 in the worst case, right?</p>
<p>562<br>00:39:54,920 –&gt; 00:40:06,920<br>So the overall complexity of the function is theta of length L1 times length L2 up here.</p>
<p>563<br>00:40:06,920 –&gt; 00:40:11,159<br>Plus theta of length L1 times length L2 down here.</p>
<p>564<br>00:40:11,159 –&gt; 00:40:17,519<br>So in this particular case, the fact that I’m iterating over temp didn’t actually increase my complexity.</p>
<p>565<br>00:40:17,519 –&gt; 00:40:25,400<br>You can imagine code where something doing something funky like this, where you indirectly reference,</p>
<p>566<br>00:40:25,400 –&gt; 00:40:29,719<br>have some loop over something related to the input, could affect the complexity.</p>
<p>567<br>00:40:29,719 –&gt; 00:40:35,960<br>So in this case, the overall complexity is still theta of length L1 times length L2.</p>
<p>568<br>00:40:35,960 –&gt; 00:40:37,159<br>Questions about this one?</p>
<p>569<br>00:40:47,519 –&gt; 00:40:48,519<br>Yeah.</p>
<p>570<br>00:40:48,519 –&gt; 00:41:01,759<br>Why do you not, like again, because you’re depending on certain number of loops, like how do you know this?</p>
<p>571<br>00:41:01,759 –&gt; 00:41:03,960<br>Like if I just say a very brief problem.</p>
<p>572<br>00:41:03,960 –&gt; 00:41:05,960<br>It varies for each problem, right?</p>
<p>573<br>00:41:05,960 –&gt; 00:41:11,159<br>But in the analysis, we’re interested in the worst case scenario, right?</p>
<p>574<br>00:41:11,159 –&gt; 00:41:15,000<br>Like the asymptotic behavior of the worst case.</p>
<p>575<br>00:41:15,000 –&gt; 00:41:21,599<br>And in the worst case, we’ve added this number length L1 times length L2 times.</p>
<p>576<br>00:41:21,599 –&gt; 00:41:25,320<br>Most of the time, of course, it’s not going to be this bad, right?</p>
<p>577<br>00:41:25,320 –&gt; 00:41:29,320<br>It’s just in this one particular case that it is this bad.</p>
<p>578<br>00:41:29,320 –&gt; 00:41:30,519<br>Oh, I see the end.</p>
<p>579<br>00:41:30,519 –&gt; 00:41:31,039<br>Yeah.</p>
<p>580<br>00:41:34,039 –&gt; 00:41:36,440<br>Okay, let’s look at one more function that’s polynomial.</p>
<p>581<br>00:41:36,440 –&gt; 00:41:37,519<br>So here’s diameter.</p>
<p>582<br>00:41:37,519 –&gt; 00:41:39,360<br>We saw this last lecture.</p>
<p>583<br>00:41:39,360 –&gt; 00:41:45,320<br>Basically, if we have a bunch of points in a 2D plane, this function tells us the distance,</p>
<p>584<br>00:41:45,320 –&gt; 00:41:48,559<br>sorry, the maximum distance between any two points, right?</p>
<p>585<br>00:41:48,559 –&gt; 00:41:52,079<br>So I drew that picture in the 2D plane.</p>
<p>586<br>00:41:52,079 –&gt; 00:41:57,960<br>So this one is going to have nested loops again.</p>
<p>587<br>00:41:57,960 –&gt; 00:42:03,280<br>So the outer loop iterates through length L times.</p>
<p>588<br>00:42:03,280 –&gt; 00:42:08,800<br>So remember, our L is just a list of two poles representing these x, y coordinates.</p>
<p>589<br>00:42:08,800 –&gt; 00:42:14,720<br>So the outer loop easily goes through length L times, but what does the inner loop go through?</p>
<p>590<br>00:42:14,720 –&gt; 00:42:19,360<br>The inner loop is actually starting at i, not zero, right?</p>
<p>591<br>00:42:19,360 –&gt; 00:42:24,680<br>If it started at zero, the inner loop would be clearly theta of length L.</p>
<p>592<br>00:42:24,680 –&gt; 00:42:25,680<br>But it’s not, right?</p>
<p>593<br>00:42:25,680 –&gt; 00:42:26,880<br>It starts at i.</p>
<p>594<br>00:42:28,160 –&gt; 00:42:33,000<br>On average, though, how many times does that inner loop go through?</p>
<p>595<br>00:42:33,000 –&gt; 00:42:38,760<br>Well, the first time it goes through that inner loop, it’s going to look at length,</p>
<p>596<br>00:42:38,760 –&gt; 00:42:41,840<br>L minus 1 elements.</p>
<p>597<br>00:42:41,840 –&gt; 00:42:46,200<br>Next time, it’s going to look at length L minus 2 elements.</p>
<p>598<br>00:42:46,200 –&gt; 00:42:50,320<br>Next time, it’s going to look at length L minus 3 elements, right?</p>
<p>599<br>00:42:50,320 –&gt; 00:42:57,440<br>Until we get to the end where it’s going to look at 1 and then zero elements.</p>
<p>600<br>00:42:57,440 –&gt; 00:43:03,160<br>So if we think about how many times that inner loop actually iterates, it’s going to be,</p>
<p>601<br>00:43:03,159 –&gt; 00:43:09,559<br>what is it, like, length L minus 1 multiplied by length L over 2?</p>
<p>602<br>00:43:09,559 –&gt; 00:43:12,079<br>Is that the function, I think, to add all these together?</p>
<p>603<br>00:43:12,079 –&gt; 00:43:13,319<br>Something like that.</p>
<p>604<br>00:43:13,319 –&gt; 00:43:18,679<br>Which is basically still something that’s a function of length L, right?</p>
<p>605<br>00:43:18,679 –&gt; 00:43:23,399<br>Like we can simplify it to be 0.5 length L, right?</p>
<p>606<br>00:43:23,399 –&gt; 00:43:30,359<br>So it’s still a function of length L, even because the coefficient in the front of that length L is 0.5, right?</p>
<p>607<br>00:43:30,360 –&gt; 00:43:36,800<br>So the overall complexity of the inner loop is still theta of length L.</p>
<p>608<br>00:43:36,800 –&gt; 00:43:37,000<br>Right?</p>
<p>609<br>00:43:37,000 –&gt; 00:43:41,240<br>Everything else within this code is constant.</p>
<p>610<br>00:43:41,240 –&gt; 00:43:50,680<br>So the overall complexity is just theta of length L squared.</p>
<p>611<br>00:43:50,680 –&gt; 00:43:52,680<br>Yeah.</p>
<p>612<br>00:43:52,680 –&gt; 00:43:53,180<br>Sorry.</p>
<p>613<br>00:43:53,180 –&gt; 00:43:54,320<br>Where did the 1.5 come?</p>
<p>614<br>00:43:54,320 –&gt; 00:44:00,519<br>Oh, it’s the formula to add, like, if you add 1 plus 2 plus 3 plus 4 plus all the way up to n,</p>
<p>615<br>00:44:00,519 –&gt; 00:44:01,840<br>like, what’s the formula to do that?</p>
<p>616<br>00:44:01,840 –&gt; 00:44:05,400<br>I think it’s like n times n plus 1 over 2, something like that.</p>
<p>617<br>00:44:05,400 –&gt; 00:44:12,080<br>So this is not exactly half, but it’s like something on the order plus, I don’t know, something, right?</p>
<p>618<br>00:44:12,080 –&gt; 00:44:15,320<br>Whatever this calculates, too.</p>
<p>619<br>00:44:15,320 –&gt; 00:44:21,640<br>But in effect, it’s like something that’s smaller than length L, but it’s still a function of length L, right?</p>
<p>620<br>00:44:21,639 –&gt; 00:44:27,759<br>And so that front coefficient on, right before length L just goes away, right?</p>
<p>621<br>00:44:27,759 –&gt; 00:44:32,519<br>Even like if it was 10, we would still cast it away.</p>
<p>622<br>00:44:32,519 –&gt; 00:44:35,679<br>In this case, it’s 0.5 or whatever it is, right?</p>
<p>623<br>00:44:35,679 –&gt; 00:44:41,119<br>So it’s still less than 1, but we still cast it away because we’re interested in the theta of this.</p>
<p>624<br>00:44:41,119 –&gt; 00:44:42,119<br>Yeah.</p>
<p>625<br>00:44:42,119 –&gt; 00:44:47,559<br>Is there any scenario with an S that’s for this week, for the week?</p>
<p>626<br>00:44:47,559 –&gt; 00:44:54,719<br>But would any e, an n squared, would the group?</p>
<p>627<br>00:44:54,719 –&gt; 00:45:00,559<br>I mean, the inner loop could just not depend on the input at all.</p>
<p>628<br>00:45:00,559 –&gt; 00:45:02,799<br>Right?</p>
<p>629<br>00:45:02,799 –&gt; 00:45:07,359<br>Like, here it’s n squared because both of the loops depend linearly on the input.</p>
<p>630<br>00:45:07,360 –&gt; 00:45:12,640<br>But if the outer loop went through range length L squared,</p>
<p>631<br>00:45:12,640 –&gt; 00:45:16,440<br>then the overall complexity would be length L cubed, in this case, right?</p>
<p>632<br>00:45:16,440 –&gt; 00:45:20,680<br>Because it’s length L squared times length L.</p>
<p>633<br>00:45:20,680 –&gt; 00:45:25,280<br>Or if one of the loops doesn’t depend on the input at all, then it contributes nothing constant,</p>
<p>634<br>00:45:25,280 –&gt; 00:45:28,320<br>and it is nothing linear, so it’s constant.</p>
<p>635<br>00:45:28,320 –&gt; 00:45:29,320<br>Yeah.</p>
<p>636<br>00:45:29,320 –&gt; 00:45:33,320<br>Okay.</p>
<p>637<br>00:45:33,320 –&gt; 00:45:40,640<br>Let’s have you think about this question for a bit.</p>
<p>638<br>00:45:40,640 –&gt; 00:45:44,840<br>So think about the input, think about parts of the function that depend on the input,</p>
<p>639<br>00:45:44,840 –&gt; 00:45:48,640<br>and then what is the complexity?</p>
<p>640<br>00:45:48,640 –&gt; 00:45:49,160<br>Okay.</p>
<p>641<br>00:45:49,160 –&gt; 00:45:56,519<br>What’s the outer loop theta of?</p>
<p>642<br>00:45:56,519 –&gt; 00:45:59,880<br>Yes.</p>
<p>643<br>00:45:59,880 –&gt; 00:46:03,960<br>Yes, numbs is a list, so the outer loop is theta of length of numbs, correct?</p>
<p>644<br>00:46:03,960 –&gt; 00:46:05,719<br>Good.</p>
<p>645<br>00:46:05,719 –&gt; 00:46:11,159<br>What’s the inner loop theta of?</p>
<p>646<br>00:46:11,159 –&gt; 00:46:11,639<br>Yeah.</p>
<p>647<br>00:46:11,639 –&gt; 00:46:12,559<br>Is that what you’re going to say?</p>
<p>648<br>00:46:12,559 –&gt; 00:46:13,079<br>Theta of 1.</p>
<p>649<br>00:46:13,079 –&gt; 00:46:13,559<br>Exactly.</p>
<p>650<br>00:46:13,559 –&gt; 00:46:16,840<br>It’s the length of digits, but digits is not my input.</p>
<p>651<br>00:46:16,840 –&gt; 00:46:18,519<br>Nums is my input.</p>
<p>652<br>00:46:18,519 –&gt; 00:46:21,880<br>So the inner loop will always just iterate through 10 times.</p>
<p>653<br>00:46:21,880 –&gt; 00:46:26,360<br>So in the eyes of the input, so the function, that’s just constant.</p>
<p>654<br>00:46:26,360 –&gt; 00:46:30,480<br>So the input is numbs, the outer loop is theta of numbs, the inner loop is theta of 1,</p>
<p>655<br>00:46:30,480 –&gt; 00:46:33,880<br>so the overall complexity is theta of length of numbs.</p>
<p>656<br>00:46:33,880 –&gt; 00:46:35,079<br>Perfect.</p>
<p>657<br>00:46:35,079 –&gt; 00:46:38,240<br>How about this one?</p>
<p>658<br>00:46:38,240 –&gt; 00:46:40,680<br>What are my inputs?</p>
<p>659<br>00:46:40,680 –&gt; 00:46:45,200<br>Do any loops depend on these inputs?</p>
<p>660<br>00:46:45,200 –&gt; 00:46:51,200<br>All right, what’s the outer loop complexity?</p>
<p>661<br>00:46:51,200 –&gt; 00:46:52,200<br>Yeah.</p>
<p>662<br>00:46:52,200 –&gt; 00:46:53,120<br>What’s the length of 1?</p>
<p>663<br>00:46:53,120 –&gt; 00:46:56,000<br>Yeah, theta of length of 1, exactly.</p>
<p>664<br>00:46:56,000 –&gt; 00:47:03,400<br>What’s the inner loop complexity?</p>
<p>665<br>00:47:03,400 –&gt; 00:47:04,960<br>Theta of length of L2, perfect.</p>
<p>666<br>00:47:04,960 –&gt; 00:47:10,880<br>And is there anything else that contributes to the complexity here?</p>
<p>667<br>00:47:10,880 –&gt; 00:47:12,679<br>What’s that?</p>
<p>668<br>00:47:12,679 –&gt; 00:47:13,519<br>The if statement.</p>
<p>669<br>00:47:13,519 –&gt; 00:47:14,039<br>Yes.</p>
<p>670<br>00:47:14,039 –&gt; 00:47:22,239<br>What about it is making you question that the complexity is not constant?</p>
<p>671<br>00:47:22,239 –&gt; 00:47:22,880<br>Exactly.</p>
<p>672<br>00:47:22,880 –&gt; 00:47:23,239<br>Yes.</p>
<p>673<br>00:47:23,239 –&gt; 00:47:23,760<br>Very nice.</p>
<p>674<br>00:47:23,760 –&gt; 00:47:26,840<br>So in, it errates through the length of L3.</p>
<p>675<br>00:47:26,840 –&gt; 00:47:31,920<br>Looking for an element in L3, e1 and L3, is not constant.</p>
<p>676<br>00:47:31,920 –&gt; 00:47:36,640<br>You have to look through the whole length of L3 to figure out where it’s there or not.</p>
<p>677<br>00:47:36,640 –&gt; 00:47:41,120<br>So this inner bit here is not constant.</p>
<p>678<br>00:47:41,120 –&gt; 00:47:43,240<br>It’s theta of length L3.</p>
<p>679<br>00:47:43,240 –&gt; 00:47:46,920<br>In fact, it’s two times length L3.</p>
<p>680<br>00:47:46,920 –&gt; 00:47:53,520<br>So the overall complexity of this function is theta of length L1 times theta of length L2 times theta of length L3.</p>
<p>681<br>00:47:53,519 –&gt; 00:47:56,360<br>Okay.</p>
<p>682<br>00:47:56,360 –&gt; 00:47:59,559<br>Cool.</p>
<p>683<br>00:47:59,559 –&gt; 00:48:01,400<br>Let’s look at the exponential complexity.</p>
<p>684<br>00:48:01,400 –&gt; 00:48:04,880<br>So this is a complexity that grows really, really quickly.</p>
<p>685<br>00:48:04,880 –&gt; 00:48:09,079<br>We never want the algorithms that we write to land within this class.</p>
<p>686<br>00:48:09,079 –&gt; 00:48:15,679<br>Unfortunately, there are just some problems in real life that we have to compute that are</p>
<p>687<br>00:48:15,679 –&gt; 00:48:18,239<br>just naturally part of this complexity class.</p>
<p>688<br>00:48:18,239 –&gt; 00:48:22,959<br>There are some techniques to deal with making these algorithms a little bit faster.</p>
<p>689<br>00:48:22,959 –&gt; 00:48:28,319<br>But inherently, there are just exponential algorithms that we just can’t do any better than</p>
<p>690<br>00:48:28,319 –&gt; 00:48:32,719<br>exponential in solving these problems.</p>
<p>691<br>00:48:32,719 –&gt; 00:48:33,719<br>All right.</p>
<p>692<br>00:48:33,719 –&gt; 00:48:38,519<br>So let’s look at Fibonacci again.</p>
<p>693<br>00:48:38,519 –&gt; 00:48:42,239<br>We looked at Fibonacci a few slides ago, iterative version.</p>
<p>694<br>00:48:42,239 –&gt; 00:48:46,159<br>And the iterative version was theta of n.</p>
<p>695<br>00:48:46,159 –&gt; 00:48:50,960<br>But if we look at the recursive version of Fibonacci, it’s not theta of n at all.</p>
<p>696<br>00:48:50,960 –&gt; 00:48:57,039<br>In fact, as you can see, it’s in this exponential set of slides, the recursive version of Fibonacci</p>
<p>697<br>00:48:57,039 –&gt; 00:49:00,039<br>is actually exponential.</p>
<p>698<br>00:49:00,039 –&gt; 00:49:03,079<br>So let’s recall what this code is doing.</p>
<p>699<br>00:49:03,079 –&gt; 00:49:05,079<br>So there’s two base cases, right?</p>
<p>700<br>00:49:05,079 –&gt; 00:49:06,920<br>Fibonacci of 0 and 1.</p>
<p>701<br>00:49:06,920 –&gt; 00:49:12,319<br>And then the recursive step is Fibonacci of n minus 1 plus Fibonacci of n minus 2.</p>
<p>702<br>00:49:12,320 –&gt; 00:49:20,519<br>So for every level that we go down, there’s going to be times two more paths that we need</p>
<p>703<br>00:49:20,519 –&gt; 00:49:24,280<br>to explore to grab the values from.</p>
<p>704<br>00:49:24,280 –&gt; 00:49:29,480<br>So for the very first n, we’ve got just one value to grab.</p>
<p>705<br>00:49:29,480 –&gt; 00:49:33,200<br>For the next n, we’ve got times two that value to grab.</p>
<p>706<br>00:49:33,200 –&gt; 00:49:39,720<br>The next level for the next n, we’ve got two times more values to grab, and so on.</p>
<p>707<br>00:49:39,719 –&gt; 00:49:46,279<br>So the fact that there are two recursive calls in this recursive step leads us to this</p>
<p>708<br>00:49:46,279 –&gt; 00:49:49,679<br>little inverted tree kind of structure, right?</p>
<p>709<br>00:49:49,679 –&gt; 00:49:55,480<br>And we even drew this when we looked at how many function calls are being run, right?</p>
<p>710<br>00:49:55,480 –&gt; 00:50:01,759<br>Remember, when we’re figuring out the complexity with a recursive function, we need to figure</p>
<p>711<br>00:50:01,759 –&gt; 00:50:06,639<br>out how many of these, how many recursive calls are we actually doing, right?</p>
<p>712<br>00:50:06,639 –&gt; 00:50:11,719<br>So because of this tree structure, every time we add a new level, we basically have two</p>
<p>713<br>00:50:11,719 –&gt; 00:50:15,199<br>completely separate paths to explore further, right?</p>
<p>714<br>00:50:15,199 –&gt; 00:50:18,839<br>And those two paths have their own two paths and so on.</p>
<p>715<br>00:50:18,839 –&gt; 00:50:23,799<br>So this leads us to this tree structure, which is actually going to lead to the total number</p>
<p>716<br>00:50:23,799 –&gt; 00:50:30,839<br>of recursive calls to be exponential, so theta of 2 to the n.</p>
<p>717<br>00:50:30,840 –&gt; 00:50:37,480<br>Now, if we looked at the actual recursive call tree, right, we looked at this, and it looked</p>
<p>718<br>00:50:37,480 –&gt; 00:50:43,800<br>something like this, right, a bunch of lectures ago, you might notice that the tree actually</p>
<p>719<br>00:50:43,800 –&gt; 00:50:46,400<br>thins out a little bit to the right, right?</p>
<p>720<br>00:50:46,400 –&gt; 00:50:50,240<br>It’s not a full tree with the leaves nicely all the way down.</p>
<p>721<br>00:50:50,240 –&gt; 00:50:56,280<br>That’s because, well, the left path calculates 5, but the right path calculates 5, no 4,</p>
<p>722<br>00:50:56,280 –&gt; 00:51:00,120<br>so n minus 1 of the left path.</p>
<p>723<br>00:51:00,119 –&gt; 00:51:01,559<br>But that’s fine.</p>
<p>724<br>00:51:01,559 –&gt; 00:51:10,920<br>It’s not that we are actually going to speed up anything by some sort of order of magnitude,</p>
<p>725<br>00:51:10,920 –&gt; 00:51:11,920<br>right?</p>
<p>726<br>00:51:11,920 –&gt; 00:51:16,359<br>Just because the tree thins out a little bit on the right hand side is not going to speed</p>
<p>727<br>00:51:16,359 –&gt; 00:51:18,480<br>up the overall complexity of this function.</p>
<p>728<br>00:51:18,480 –&gt; 00:51:24,279<br>It’s going to be theta of 2 to the n minus some theta that’s less than 2 to the n.</p>
<p>729<br>00:51:24,280 –&gt; 00:51:30,400<br>So that subtraction is not going to really decrease the overall complexity of our function,</p>
<p>730<br>00:51:30,400 –&gt; 00:51:33,200<br>so the order of this is still exponential.</p>
<p>731<br>00:51:33,200 –&gt; 00:51:35,440<br>All right.</p>
<p>732<br>00:51:35,440 –&gt; 00:51:39,080<br>Here’s another example of an exponential code.</p>
<p>733<br>00:51:39,080 –&gt; 00:51:46,080<br>So this is a function that is going to generate all the subsets of a list.</p>
<p>734<br>00:51:46,080 –&gt; 00:51:50,519<br>So again, I’ve added a little example here to help us understand what it’s doing.</p>
<p>735<br>00:51:50,519 –&gt; 00:51:55,360<br>So here I’ve got three numbers, a list with three numbers, one, two, and three.</p>
<p>736<br>00:51:55,360 –&gt; 00:52:01,400<br>And to generate subsets, what this means is that I’m going to create a new list of all</p>
<p>737<br>00:52:01,400 –&gt; 00:52:09,239<br>of the possible combinations of numbers within my original list of all the possible lengths.</p>
<p>738<br>00:52:09,239 –&gt; 00:52:10,239<br>Right?</p>
<p>739<br>00:52:10,239 –&gt; 00:52:15,199<br>So first, one subset of this list could be just the empty list, so that’s not taking any of</p>
<p>740<br>00:52:15,199 –&gt; 00:52:17,800<br>my original numbers at all.</p>
<p>741<br>00:52:17,800 –&gt; 00:52:23,440<br>The next one is a list with just one of the numbers in it, so either the one or the two</p>
<p>742<br>00:52:23,440 –&gt; 00:52:24,920<br>or the three.</p>
<p>743<br>00:52:24,920 –&gt; 00:52:32,360<br>Next subset of my list could be taking just two of the elements, so one and two, one and</p>
<p>744<br>00:52:32,360 –&gt; 00:52:34,120<br>three and two and three.</p>
<p>745<br>00:52:34,120 –&gt; 00:52:37,600<br>And then lastly, I can just grab all the elements, so one and the two and the three.</p>
<p>746<br>00:52:37,600 –&gt; 00:52:38,800<br>I don’t care about the order, right?</p>
<p>747<br>00:52:38,800 –&gt; 00:52:43,640<br>I just care that I have all of these different combinations of all of the different lengths</p>
<p>748<br>00:52:43,640 –&gt; 00:52:46,240<br>in my final list.</p>
<p>749<br>00:52:46,239 –&gt; 00:52:50,359<br>So does everyone understand the goal of this function?</p>
<p>750<br>00:52:50,359 –&gt; 00:52:52,199<br>So how do we achieve this?</p>
<p>751<br>00:52:52,199 –&gt; 00:52:56,519<br>Well, you might not be surprised, we’re going to do it recursively.</p>
<p>752<br>00:52:56,519 –&gt; 00:53:01,759<br>That’s really the only reasonable way to write this code.</p>
<p>753<br>00:53:01,759 –&gt; 00:53:06,879<br>So I’m going to go through this slide just explaining what each line does, but on the</p>
<p>754<br>00:53:06,879 –&gt; 00:53:11,959<br>next slide I’ll have a little animation that shows step by step how the function creates</p>
<p>755<br>00:53:11,959 –&gt; 00:53:14,399<br>this subset list.</p>
<p>756<br>00:53:14,400 –&gt; 00:53:18,320<br>So first thing, it’s recursive, so I’ve got my base case up there.</p>
<p>757<br>00:53:18,320 –&gt; 00:53:24,320<br>It’s if I have a list of length zero, then the subset of an empty list, right, is just</p>
<p>758<br>00:53:24,320 –&gt; 00:53:28,519<br>going to be this list with the empty thing inside it.</p>
<p>759<br>00:53:28,519 –&gt; 00:53:33,400<br>So if I have no elements, there’s only one subset that’s the empty list.</p>
<p>760<br>00:53:33,400 –&gt; 00:53:40,599<br>Then if I have more than one element inside it, I’m going to do the same idea that we saw</p>
<p>761<br>00:53:40,599 –&gt; 00:53:44,079<br>when we worked with lists back in the recursion lectures.</p>
<p>762<br>00:53:44,079 –&gt; 00:53:47,360<br>I’m going to extract one of my elements.</p>
<p>763<br>00:53:47,360 –&gt; 00:53:51,960<br>I’m going to work on the remaining list, and then I’m going to do something by taking that</p>
<p>764<br>00:53:51,960 –&gt; 00:53:55,840<br>element and tacking it back onto the result.</p>
<p>765<br>00:53:55,840 –&gt; 00:54:01,759<br>So in this particular case, the thing that I’m extracting is the last element in my list.</p>
<p>766<br>00:54:01,759 –&gt; 00:54:07,400<br>So if my list is one, two, and three, at a step here, I’m going to extract the three</p>
<p>767<br>00:54:07,400 –&gt; 00:54:09,559<br>and make it into its own list.</p>
<p>768<br>00:54:09,559 –&gt; 00:54:11,400<br>Right, so that’s what that step is doing.</p>
<p>769<br>00:54:11,400 –&gt; 00:54:15,200<br>It extracts the last element in the list.</p>
<p>770<br>00:54:15,200 –&gt; 00:54:22,720<br>Then I make a function call to generate subsets on everything except for that last element.</p>
<p>771<br>00:54:22,720 –&gt; 00:54:29,400<br>So I say, hey, function, that I’m currently writing right now.</p>
<p>772<br>00:54:29,400 –&gt; 00:54:35,720<br>If you can generate for me the subset of all the elements, right, the subset for this</p>
<p>773<br>00:54:35,720 –&gt; 00:54:39,280<br>list, then you’re going to come up with something that looks like this.</p>
<p>774<br>00:54:39,280 –&gt; 00:54:45,120<br>It’s going to be the empty list, the one, the two, and the one and the two together.</p>
<p>775<br>00:54:45,120 –&gt; 00:54:51,360<br>Right, so the subset of this list is going to be this group of elements here.</p>
<p>776<br>00:54:51,360 –&gt; 00:54:52,760<br>So that’s what this is going to do.</p>
<p>777<br>00:54:52,760 –&gt; 00:54:57,800<br>So this is, again, us trusting that the function we write will generate something that looks</p>
<p>778<br>00:54:57,800 –&gt; 00:55:00,120<br>like this.</p>
<p>779<br>00:55:00,120 –&gt; 00:55:06,480<br>If we’ve got to this point, then smaller is going to be a list that looks like this.</p>
<p>780<br>00:55:06,480 –&gt; 00:55:13,119<br>So the next part of the code is going to take that little extra thing that I had saved</p>
<p>781<br>00:55:13,119 –&gt; 00:55:14,920<br>previously.</p>
<p>782<br>00:55:14,920 –&gt; 00:55:19,760<br>It’s going to tack on that three to every element within this list.</p>
<p>783<br>00:55:19,760 –&gt; 00:55:25,099<br>So then I’m going to basically say, I’m going to take this three and make a list with</p>
<p>784<br>00:55:25,099 –&gt; 00:55:29,559<br>the three in it, a list with the one and the three in it, a list with the two and the</p>
<p>785<br>00:55:29,559 –&gt; 00:55:33,800<br>three in it, and a list with the one and the two and the three in it.</p>
<p>786<br>00:55:33,800 –&gt; 00:55:39,560<br>So I’ve just taken that three and added it to everything that resulted from this line</p>
<p>787<br>00:55:39,560 –&gt; 00:55:44,320<br>of code here, from my function calling itself.</p>
<p>788<br>00:55:44,320 –&gt; 00:55:48,800<br>And then all it does is return smaller plus new.</p>
<p>789<br>00:55:48,800 –&gt; 00:55:53,680<br>So if I add these two together, this is going to generate for me my final subset that I</p>
<p>790<br>00:55:53,680 –&gt; 00:55:54,680<br>was interested in.</p>
<p>791<br>00:55:54,680 –&gt; 00:55:55,680<br>Right?</p>
<p>792<br>00:55:55,680 –&gt; 00:55:56,680<br>I’ve got the empty thing.</p>
<p>793<br>00:55:56,680 –&gt; 00:55:58,160<br>I’ve got the one, the two, and the three by itself.</p>
<p>794<br>00:55:58,160 –&gt; 00:56:01,840<br>I’ve got the one, two, the one, three, and the two, three by itself, and then the one,</p>
<p>795<br>00:56:01,840 –&gt; 00:56:02,840<br>two, three altogether.</p>
<p>796<br>00:56:03,840 –&gt; 00:56:06,039<br>So that’s the big idea here.</p>
<p>797<br>00:56:06,039 –&gt; 00:56:10,920<br>So let’s just go through step by step recursively calling ourselves.</p>
<p>798<br>00:56:10,920 –&gt; 00:56:16,280<br>So this is me finding out the, kicking off my function call, saying, hey, generate the</p>
<p>799<br>00:56:16,280 –&gt; 00:56:19,440<br>subsets for the list one, two, three.</p>
<p>800<br>00:56:19,440 –&gt; 00:56:21,720<br>I’m going to keep the extra side.</p>
<p>801<br>00:56:21,720 –&gt; 00:56:25,240<br>I need to make another function call because I’m not at my base case.</p>
<p>802<br>00:56:25,240 –&gt; 00:56:29,480<br>So I’m going to call gen subsets on one comma two.</p>
<p>803<br>00:56:29,480 –&gt; 00:56:30,960<br>This is also not my base case.</p>
<p>804<br>00:56:30,960 –&gt; 00:56:35,559<br>So I’m going to take my last element, put it aside, and I’m going to call gen subsets</p>
<p>805<br>00:56:35,559 –&gt; 00:56:38,240<br>on just the one.</p>
<p>806<br>00:56:38,240 –&gt; 00:56:39,240<br>Still not the base case.</p>
<p>807<br>00:56:39,240 –&gt; 00:56:43,480<br>I’m going to take this extra, put it aside, and I’m going to call gen subsets on the empty</p>
<p>808<br>00:56:43,480 –&gt; 00:56:44,480<br>list.</p>
<p>809<br>00:56:44,480 –&gt; 00:56:46,039<br>And this is where I reach my base case.</p>
<p>810<br>00:56:46,039 –&gt; 00:56:48,280<br>So far, nothing has been returned at all.</p>
<p>811<br>00:56:48,280 –&gt; 00:56:51,079<br>No work has been done.</p>
<p>812<br>00:56:51,079 –&gt; 00:56:54,559<br>At my base case, Python will say, I know what this is.</p>
<p>813<br>00:56:54,559 –&gt; 00:56:57,159<br>It’s going to be the list with just the empty thing in it.</p>
<p>814<br>00:56:57,159 –&gt; 00:56:58,159<br>All right?</p>
<p>815<br>00:56:58,159 –&gt; 00:56:59,159<br>Cool.</p>
<p>816<br>00:56:59,399 –&gt; 00:57:02,599<br>That gets returned, so this function call goes away.</p>
<p>817<br>00:57:02,599 –&gt; 00:57:04,079<br>So now what is it going to do?</p>
<p>818<br>00:57:04,079 –&gt; 00:57:09,799<br>Well, it’s going to take that extra, I set aside, take the smaller list that I just</p>
<p>819<br>00:57:09,799 –&gt; 00:57:14,039<br>returned, and basically double that smaller list.</p>
<p>820<br>00:57:14,039 –&gt; 00:57:16,319<br>So this is my smaller list.</p>
<p>821<br>00:57:16,319 –&gt; 00:57:20,359<br>And then I’m going to double that by saying, I’m going to put this one to the end of</p>
<p>822<br>00:57:20,359 –&gt; 00:57:23,239<br>everything in my smaller list.</p>
<p>823<br>00:57:23,239 –&gt; 00:57:27,239<br>Maybe this is not so apparent at this step, but let’s go one more step and see what</p>
<p>824<br>00:57:27,239 –&gt; 00:57:28,279<br>happens.</p>
<p>825<br>00:57:28,280 –&gt; 00:57:30,120<br>So now this function also terminates.</p>
<p>826<br>00:57:30,120 –&gt; 00:57:36,280<br>It returns this empty list and one in it and says, all right, here, with this function</p>
<p>827<br>00:57:36,280 –&gt; 00:57:42,680<br>call, I had saved the two separately and said, I’m going to now tack on this two to the</p>
<p>828<br>00:57:42,680 –&gt; 00:57:45,480<br>end of everything that I had just returned.</p>
<p>829<br>00:57:45,480 –&gt; 00:57:47,400<br>So this is smaller.</p>
<p>830<br>00:57:47,400 –&gt; 00:57:49,360<br>This is smaller over here.</p>
<p>831<br>00:57:49,360 –&gt; 00:57:53,920<br>And all I’m going to do is take this extra thing and tack it on to the end of everything</p>
<p>832<br>00:57:53,920 –&gt; 00:57:55,400<br>that was in smaller.</p>
<p>833<br>00:57:55,400 –&gt; 00:57:57,720<br>So I’m going to tack it on to the end of this empty list.</p>
<p>834<br>00:57:57,720 –&gt; 00:58:00,920<br>So it just gives me this two and tack it on to the end of this one.</p>
<p>835<br>00:58:00,920 –&gt; 00:58:05,360<br>So it gives me the one comma two.</p>
<p>836<br>00:58:05,360 –&gt; 00:58:08,880<br>So I’ve basically doubled my list at this stage.</p>
<p>837<br>00:58:08,880 –&gt; 00:58:10,639<br>One more step.</p>
<p>838<br>00:58:10,639 –&gt; 00:58:11,840<br>This gets returned.</p>
<p>839<br>00:58:11,840 –&gt; 00:58:14,559<br>And now this is my original function call.</p>
<p>840<br>00:58:14,559 –&gt; 00:58:16,880<br>The thing that I had extracted was the three.</p>
<p>841<br>00:58:16,880 –&gt; 00:58:19,280<br>So now we’re basically at this step here.</p>
<p>842<br>00:58:19,280 –&gt; 00:58:21,000<br>I extracted the three.</p>
<p>843<br>00:58:21,000 –&gt; 00:58:27,280<br>The function just below it returned this smaller.</p>
<p>844<br>00:58:27,280 –&gt; 00:58:32,040<br>So that means that this three is going to get appended to the end of everything that</p>
<p>845<br>00:58:32,040 –&gt; 00:58:33,519<br>was in smaller.</p>
<p>846<br>00:58:33,519 –&gt; 00:58:37,000<br>So it’s going to be appended to the end of this empty list to give me just the three,</p>
<p>847<br>00:58:37,000 –&gt; 00:58:40,200<br>to the end of the one, to give me the one and the three, to the end of the two, to give</p>
<p>848<br>00:58:40,200 –&gt; 00:58:45,240<br>me the two and the three, and to the end of the one two, to give me the one two three.</p>
<p>849<br>00:58:45,240 –&gt; 00:58:47,760<br>Now this is the final answer.</p>
<p>850<br>00:58:47,760 –&gt; 00:58:53,120<br>So I basically keep what I had returned from the previous function call and concatenate</p>
<p>851<br>00:58:53,120 –&gt; 00:58:57,720<br>that with the thing that I had just created, where I tacked on my three.</p>
<p>852<br>00:58:57,720 –&gt; 00:58:59,480<br>And this is my final answer.</p>
<p>853<br>00:58:59,480 –&gt; 00:59:04,560<br>It’s just sort of out of order to what we intuitively would have written by hand.</p>
<p>854<br>00:59:04,560 –&gt; 00:59:08,960<br>But it hits on all of the elements that I wanted to have anyway.</p>
<p>855<br>00:59:08,960 –&gt; 00:59:12,560<br>So I’ve got the empty list, everything with just one element in it, everything with</p>
<p>856<br>00:59:12,560 –&gt; 00:59:16,760<br>the two elements in it, and everything with all three elements in it.</p>
<p>857<br>00:59:16,760 –&gt; 00:59:19,960<br>So let’s look at the complexity analysis of this.</p>
<p>858<br>00:59:19,960 –&gt; 00:59:22,320<br>We’ve got two things going on here.</p>
<p>859<br>00:59:22,320 –&gt; 00:59:26,880<br>One is how many of these function calls are actually being done, right?</p>
<p>860<br>00:59:26,880 –&gt; 00:59:31,680<br>Like with the inverse tree structure, how many of those function calls do we need to do</p>
<p>861<br>00:59:31,680 –&gt; 00:59:35,200<br>to get to the end of our, to our base case?</p>
<p>862<br>00:59:35,200 –&gt; 00:59:40,840<br>And on top of that, that, sorry, that will tell us how many actual elements in the list</p>
<p>863<br>00:59:40,840 –&gt; 00:59:42,120<br>we will have.</p>
<p>864<br>00:59:42,119 –&gt; 00:59:47,199<br>And on top of that, we have actually a time complexity that’s not constant, that’s to</p>
<p>865<br>00:59:47,199 –&gt; 00:59:50,559<br>copy our list.</p>
<p>866<br>00:59:50,559 –&gt; 00:59:53,039<br>So copying a list is not constant, right?</p>
<p>867<br>00:59:53,039 –&gt; 00:59:57,319<br>Because it takes some time to take all the elements in a list and make a copy of them.</p>
<p>868<br>00:59:57,319 –&gt; 01:00:02,839<br>So if we think about the time it takes to make our list at each step, right?</p>
<p>869<br>01:00:02,839 –&gt; 01:00:06,000<br>How many of these sub-elements we’re creating?</p>
<p>870<br>01:00:06,000 –&gt; 01:00:10,599<br>Well, at the very base case, we have one element.</p>
<p>871<br>01:00:10,599 –&gt; 01:00:13,719<br>At the case just above it, we had two elements.</p>
<p>872<br>01:00:13,719 –&gt; 01:00:16,280<br>At the case just above that, we had four elements.</p>
<p>873<br>01:00:16,280 –&gt; 01:00:19,280<br>At the case just above that, we had eight elements.</p>
<p>874<br>01:00:19,280 –&gt; 01:00:26,679<br>So at each step, the number of sub-lists that we were generating was basically twice as</p>
<p>875<br>01:00:26,679 –&gt; 01:00:29,199<br>much as the previous step.</p>
<p>876<br>01:00:29,199 –&gt; 01:00:34,440<br>So the overall number of subsets was on the order of two to the end.</p>
<p>877<br>01:00:34,440 –&gt; 01:00:39,440<br>But there was also a time complexity to make a copy of the list within each one of those</p>
<p>878<br>01:00:39,440 –&gt; 01:00:40,800<br>subsets.</p>
<p>879<br>01:00:40,800 –&gt; 01:00:44,760<br>So we’re multiplying the complexity it takes to make all those function calls and generate</p>
<p>880<br>01:00:44,760 –&gt; 01:00:49,280<br>all those subsets by the time it takes to make a copy of the list.</p>
<p>881<br>01:00:49,280 –&gt; 01:00:53,760<br>So the overall complexity is actually going to be theta of n times 2 to the n.</p>
<p>882<br>01:00:53,760 –&gt; 01:01:00,200<br>Because it’s a little bit harder, it’s a little bit worse than exponential, just purely for</p>
<p>883<br>01:01:00,279 –&gt; 01:01:07,199<br>the fact that we’re copying the list at each step.</p>
<p>884<br>01:01:07,199 –&gt; 01:01:08,919<br>All right.</p>
<p>885<br>01:01:08,919 –&gt; 01:01:11,439<br>So let’s move on to logarithmic complexity.</p>
<p>886<br>01:01:11,439 –&gt; 01:01:15,319<br>This one’s going to be a little bit tricky because right off the bat, we’re not going</p>
<p>887<br>01:01:15,319 –&gt; 01:01:22,039<br>to be able to see a direct relationship between the input and what loop we actually have.</p>
<p>888<br>01:01:22,039 –&gt; 01:01:25,439<br>So here I’ve got a function called digit ad.</p>
<p>889<br>01:01:25,439 –&gt; 01:01:27,239<br>It’s going to take in a number.</p>
<p>890<br>01:01:27,239 –&gt; 01:01:31,159<br>So 1, 2, 3, 4, something like that.</p>
<p>891<br>01:01:31,159 –&gt; 01:01:33,559<br>Number 1,234.</p>
<p>892<br>01:01:33,559 –&gt; 01:01:35,799<br>The code casts it to a string.</p>
<p>893<br>01:01:35,799 –&gt; 01:01:39,399<br>So it takes in a pure numerical value.</p>
<p>894<br>01:01:39,399 –&gt; 01:01:47,279<br>It makes a string out of it and then iterates through the string.</p>
<p>895<br>01:01:47,279 –&gt; 01:01:54,239<br>So the function here in terms of time complexity is theta of length s.</p>
<p>896<br>01:01:54,239 –&gt; 01:01:59,759<br>Here we’re iterating through the string backward, basically 4, then 3, then 2, then 1.</p>
<p>897<br>01:01:59,759 –&gt; 01:02:01,559<br>But what’s my input?</p>
<p>898<br>01:02:01,559 –&gt; 01:02:03,679<br>It’s n. It’s not s, right?</p>
<p>899<br>01:02:03,679 –&gt; 01:02:12,039<br>So the time complexity of this function, while it’s linear in s, s is not linear in n.</p>
<p>900<br>01:02:12,039 –&gt; 01:02:16,319<br>Because when my number is 83, my loop only iterates twice.</p>
<p>901<br>01:02:16,319 –&gt; 01:02:22,679<br>If my number as 4 digits in it, 4,271, my loop iterates 4 times.</p>
<p>902<br>01:02:22,679 –&gt; 01:02:27,319<br>So this relationship is not linear.</p>
<p>903<br>01:02:27,319 –&gt; 01:02:29,079<br>So what is it exactly?</p>
<p>904<br>01:02:29,079 –&gt; 01:02:33,239<br>Well, let’s think about what that loop is actually doing.</p>
<p>905<br>01:02:33,239 –&gt; 01:02:41,480<br>If I have a number with 4 digits in it, something in the thousands, when I iterate through the</p>
<p>906<br>01:02:41,480 –&gt; 01:02:50,359<br>number, by sort of backward, this number has a string, I’m basically taking that one and</p>
<p>907<br>01:02:50,360 –&gt; 01:02:53,280<br>keeping it in my running sum.</p>
<p>908<br>01:02:53,280 –&gt; 01:02:59,720<br>Then it’s kind of like I divided that number by 10, I grabbed the remainder when I divided</p>
<p>909<br>01:02:59,720 –&gt; 01:03:03,680<br>that number by 10, and that’s the thing that I just added.</p>
<p>910<br>01:03:03,680 –&gt; 01:03:09,160<br>The whole number left over when I divided by 10 is this bit here.</p>
<p>911<br>01:03:09,160 –&gt; 01:03:14,519<br>So now, think of it like taking this last element here, it’s like I take this number</p>
<p>912<br>01:03:14,519 –&gt; 01:03:16,400<br>and divide by 10 again.</p>
<p>913<br>01:03:16,400 –&gt; 01:03:20,760<br>I grabbed the remainder when I divide by 10 and added to my running total, and the whole</p>
<p>914<br>01:03:20,760 –&gt; 01:03:24,840<br>number I’m left over when dividing by 10 is just this.</p>
<p>915<br>01:03:24,840 –&gt; 01:03:30,480<br>One more time, I take the 2, the remainder when I divided that 42, what is 2, and the whole</p>
<p>916<br>01:03:30,480 –&gt; 01:03:33,039<br>number I was left over with is 4.</p>
<p>917<br>01:03:33,039 –&gt; 01:03:37,280<br>And then lastly, I can do that last thing again.</p>
<p>918<br>01:03:37,280 –&gt; 01:03:42,920<br>So what’s the relationship between the magnitude of n, right, this 4,000 something, or this</p>
<p>919<br>01:03:42,920 –&gt; 01:03:49,119<br>80 something, to how many times I have to loop through to get every digit in my number?</p>
<p>920<br>01:03:49,119 –&gt; 01:03:55,200<br>Well, the trick here is to think about taking my magnitude, my n, my magnitude of n, and</p>
<p>921<br>01:03:55,200 –&gt; 01:03:59,400<br>dividing it by 10 a bunch of times.</p>
<p>922<br>01:03:59,400 –&gt; 01:04:05,200<br>How many times do I divide by 10 to basically grab every single element, every single digit</p>
<p>923<br>01:04:05,200 –&gt; 01:04:06,720<br>in my n?</p>
<p>924<br>01:04:06,720 –&gt; 01:04:09,920<br>Well, length s times, right?</p>
<p>925<br>01:04:09,920 –&gt; 01:04:14,320<br>It’s kind of like taking each character one at a time, right?</p>
<p>926<br>01:04:14,320 –&gt; 01:04:18,720<br>To take each character one at a time that’s like dividing by 10 to grab the remainder, and</p>
<p>927<br>01:04:18,720 –&gt; 01:04:21,079<br>then I’ve done that length s times, right?</p>
<p>928<br>01:04:21,079 –&gt; 01:04:23,480<br>That’s what this loop is doing.</p>
<p>929<br>01:04:23,480 –&gt; 01:04:29,720<br>So the relationship between the magnitude of n, and how many times I go through the loop,</p>
<p>930<br>01:04:29,720 –&gt; 01:04:35,960<br>is this, n divided by 10, some number times, length s times is equal to 1, that means I’ve</p>
<p>931<br>01:04:35,960 –&gt; 01:04:41,760<br>finished going through this entire, this entire number, all the digits within the number.</p>
<p>932<br>01:04:41,760 –&gt; 01:04:50,360<br>So the relationship between n and length s is length s is equal to log of n.</p>
<p>933<br>01:04:50,360 –&gt; 01:04:54,720<br>And now that I have this nice relationship, well, I said that this function was linear</p>
<p>934<br>01:04:54,720 –&gt; 01:04:59,760<br>in length s, so if it’s theta of length s, it’s going to be theta of log n.</p>
<p>935<br>01:04:59,760 –&gt; 01:05:05,400<br>I just mapped those two together.</p>
<p>936<br>01:05:05,400 –&gt; 01:05:13,240<br>And now, what’s important to realize is that here there’s kind of an indirect relationship</p>
<p>937<br>01:05:13,240 –&gt; 01:05:17,320<br>between what’s actually happening in the code and my input, right?</p>
<p>938<br>01:05:17,320 –&gt; 01:05:20,039<br>It’s not as clear cut.</p>
<p>939<br>01:05:20,039 –&gt; 01:05:26,720<br>But there is some relationship which is not constant and not linear.</p>
<p>940<br>01:05:26,720 –&gt; 01:05:32,440<br>Okay.</p>
<p>941<br>01:05:32,440 –&gt; 01:05:36,679<br>So the overall complexity of this function is theta of log n, where I don’t actually care</p>
<p>942<br>01:05:36,679 –&gt; 01:05:41,440<br>about the base when I report the complexity in terms of log.</p>
<p>943<br>01:05:41,440 –&gt; 01:05:49,280<br>In this case, it’s base 10, but if it was base 2, it would be the same log n.</p>
<p>944<br>01:05:49,280 –&gt; 01:05:56,840<br>Okay, so we saw some, a bunch of examples, just one of logarithmic complexity.</p>
<p>945<br>01:05:56,840 –&gt; 01:06:02,320<br>But we’re going to see next that searching for an element in the list will also be logarithmic</p>
<p>946<br>01:06:02,320 –&gt; 01:06:03,320<br>complexity.</p>
<p>947<br>01:06:03,320 –&gt; 01:06:04,320<br>Okay.</p>
<p>948<br>01:06:04,320 –&gt; 01:06:10,880<br>Before we get to that, I’d like to just put this slide up to remind you that there are several</p>
<p>949<br>01:06:10,880 –&gt; 01:06:16,720<br>functions built in functions with lists and dictionaries that aren’t constant, right?</p>
<p>950<br>01:06:16,720 –&gt; 01:06:22,120<br>So like that example you guys did, where we used the in operator, right?</p>
<p>951<br>01:06:22,120 –&gt; 01:06:27,280<br>We had to be careful if you ever see these operations being done in the code, don’t just</p>
<p>952<br>01:06:27,280 –&gt; 01:06:28,280<br>push them aside.</p>
<p>953<br>01:06:28,280 –&gt; 01:06:32,600<br>You have to account for them within the complexity analysis.</p>
<p>954<br>01:06:32,600 –&gt; 01:06:35,080<br>Okay.</p>
<p>955<br>01:06:35,080 –&gt; 01:06:39,760<br>So next, we’re going to look at some searching algorithms.</p>
<p>956<br>01:06:39,760 –&gt; 01:06:45,160<br>These algorithms, we’re going to see a bunch of different codes that implement searching.</p>
<p>957<br>01:06:45,160 –&gt; 01:06:50,160<br>These will, again, there’ll be very similar to the ones that we actually timed last lecture.</p>
<p>958<br>01:06:50,160 –&gt; 01:06:54,640<br>So we’re going to look at searching for an element in a list.</p>
<p>959<br>01:06:54,639 –&gt; 01:07:01,400<br>We’re going to look at a bunch of different implementations of the plain brute force searching</p>
<p>960<br>01:07:01,400 –&gt; 01:07:03,079<br>element in a list, right?</p>
<p>961<br>01:07:03,079 –&gt; 01:07:07,559<br>Whether it’s sorted or unsorted, as long as you just brute force your way from the beginning</p>
<p>962<br>01:07:07,559 –&gt; 01:07:11,759<br>of the list to the end of the list, you’ll be able to find the element you’re looking for</p>
<p>963<br>01:07:11,759 –&gt; 01:07:13,960<br>or say that it’s not there.</p>
<p>964<br>01:07:13,960 –&gt; 01:07:16,480<br>So we’re going to look at some linear search functions.</p>
<p>965<br>01:07:16,480 –&gt; 01:07:21,799<br>And then we’re going to look at the bisection search, a couple bisection search implementations.</p>
<p>966<br>01:07:21,800 –&gt; 01:07:25,920<br>And that’s where we divide the list in half and discard one of the halves.</p>
<p>967<br>01:07:25,920 –&gt; 01:07:32,360<br>And those implementations, though, will need our list to be sorted, right?</p>
<p>968<br>01:07:32,360 –&gt; 01:07:36,080<br>So the brute forcing our way doesn’t really matter whether it’s sorted or not.</p>
<p>969<br>01:07:36,080 –&gt; 01:07:41,039<br>But the bisection search only gives the correct answer if the list is sorted to begin with.</p>
<p>970<br>01:07:41,039 –&gt; 01:07:42,039<br>All right.</p>
<p>971<br>01:07:42,039 –&gt; 01:07:46,560<br>So first, let’s look at linear search on an unsorted list.</p>
<p>972<br>01:07:46,560 –&gt; 01:07:51,360<br>This is code that is going to search for element E in list L.</p>
<p>973<br>01:07:51,360 –&gt; 01:07:57,480<br>It loops through the length of the list and keeps this Boolean flag in mind if it finds</p>
<p>974<br>01:07:57,480 –&gt; 01:08:00,079<br>the element we’re looking for, just sets the flag.</p>
<p>975<br>01:08:00,079 –&gt; 01:08:04,200<br>And at the end of iterating through the whole list, it tells us whether it found it or</p>
<p>976<br>01:08:04,200 –&gt; 01:08:05,640<br>not.</p>
<p>977<br>01:08:05,640 –&gt; 01:08:11,720<br>So the worst case scenario analysis says that we have to look through the entire list to determine</p>
<p>978<br>01:08:11,720 –&gt; 01:08:14,160<br>the element is there or not.</p>
<p>979<br>01:08:14,160 –&gt; 01:08:19,920<br>So the theta of this particular function is theta of length L, right?</p>
<p>980<br>01:08:19,920 –&gt; 01:08:21,600<br>There’s only one loop.</p>
<p>981<br>01:08:21,600 –&gt; 01:08:26,880<br>Depends on the length of L that nothing really special about this function.</p>
<p>982<br>01:08:26,880 –&gt; 01:08:31,359<br>Now you might notice that there’s something inefficient about this function and that once</p>
<p>983<br>01:08:31,359 –&gt; 01:08:36,000<br>it finds an element, let’s say at the beginning of the list, this function actually just sets</p>
<p>984<br>01:08:36,000 –&gt; 01:08:39,760<br>the flag and keeps going through to the end of the list.</p>
<p>985<br>01:08:39,760 –&gt; 01:08:46,199<br>So we can actually do a little bit of a speed up with this bit here and say that, hey, if</p>
<p>986<br>01:08:46,199 –&gt; 01:08:48,680<br>we find it, just return true right away.</p>
<p>987<br>01:08:48,680 –&gt; 01:08:52,200<br>We don’t need to keep going to the end of the list.</p>
<p>988<br>01:08:52,200 –&gt; 01:08:55,800<br>So what’s the analysis for this code?</p>
<p>989<br>01:08:55,800 –&gt; 01:09:00,800<br>Well, again, we’re doing worst case analysis, so in the worst case, the element is not</p>
<p>990<br>01:09:00,800 –&gt; 01:09:05,440<br>there, so we still have to search through every single element in the list beginning to</p>
<p>991<br>01:09:05,440 –&gt; 01:09:08,360<br>end to determine it’s not there.</p>
<p>992<br>01:09:08,360 –&gt; 01:09:12,960<br>So the worst case, theta analysis for this function is that we still have to go through to</p>
<p>993<br>01:09:12,960 –&gt; 01:09:17,440<br>the end of the list to determine it’s not there, so it’s still going to be, sorry, it’s</p>
<p>994<br>01:09:17,439 –&gt; 01:09:25,159<br>still going to be theta of length L, time.</p>
<p>995<br>01:09:25,159 –&gt; 01:09:31,239<br>So this is on an unsorted list, but what if we look at a sorted list?</p>
<p>996<br>01:09:31,239 –&gt; 01:09:35,199<br>So we can do a little something clever in our code.</p>
<p>997<br>01:09:35,199 –&gt; 01:09:42,079<br>If the list is sorted, we can say, we’re going to start at, let’s say it’s increasing</p>
<p>998<br>01:09:42,079 –&gt; 01:09:43,079<br>sorted, right?</p>
<p>999<br>01:09:43,079 –&gt; 01:09:47,119<br>We can start at the beginning of the list, look through each element.</p>
<p>1000<br>01:09:47,119 –&gt; 01:09:53,199<br>If we find it, return true, if we reach an element that’s bigger than the one we’re looking</p>
<p>1001<br>01:09:53,199 –&gt; 01:09:58,159<br>for, the list is sorted, so all the remaining elements in the list are also bigger than</p>
<p>1002<br>01:09:58,159 –&gt; 01:10:00,479<br>the one we’re looking for, right?</p>
<p>1003<br>01:10:00,479 –&gt; 01:10:03,920<br>And then we can just return false right away.</p>
<p>1004<br>01:10:03,920 –&gt; 01:10:08,960<br>Well we think we’re pretty clever, but the worst case analysis says that the list is,</p>
<p>1005<br>01:10:08,960 –&gt; 01:10:13,560<br>the element is not even in the list at all, so we still have to go through and look to</p>
<p>1006<br>01:10:13,560 –&gt; 01:10:18,560<br>the end of the list to figure out that that element is not there, so we still have to touch</p>
<p>1007<br>01:10:18,560 –&gt; 01:10:21,760<br>each element in the list to determine it’s not there.</p>
<p>1008<br>01:10:21,760 –&gt; 01:10:26,000<br>So the theta, worst case theta complexity analysis still says that this is theta of length</p>
<p>1009<br>01:10:26,000 –&gt; 01:10:27,000<br>L, right?</p>
<p>1010<br>01:10:27,000 –&gt; 01:10:32,000<br>Because everything else is constant.</p>
<p>1011<br>01:10:32,000 –&gt; 01:10:38,439<br>Okay, so now let’s look at bisecticers, so as far as we can tell, just doing a linear</p>
<p>1012<br>01:10:38,479 –&gt; 01:10:44,839<br>brute force search way is not going to give us anything better than theta of n.</p>
<p>1013<br>01:10:44,839 –&gt; 01:10:49,039<br>But when we looked at the timings in last lecture, we saw that this binary search, or</p>
<p>1014<br>01:10:49,039 –&gt; 01:10:54,559<br>bisection search on an element in the list, was actually much faster, right?</p>
<p>1015<br>01:10:54,559 –&gt; 01:10:59,399<br>It grew out of something faster rate than linear, but not quite constant.</p>
<p>1016<br>01:10:59,399 –&gt; 01:11:05,119<br>So let’s remember how that code looked, so we basically had a list with a bunch of elements</p>
<p>1017<br>01:11:05,119 –&gt; 01:11:09,840<br>in it, we looked at the element at the middle of the list, and we said, are you the one</p>
<p>1018<br>01:11:09,840 –&gt; 01:11:11,000<br>we’re looking for?</p>
<p>1019<br>01:11:11,000 –&gt; 01:11:13,039<br>In the worst case, it’s not, right?</p>
<p>1020<br>01:11:13,039 –&gt; 01:11:18,039<br>So then we have to ask, are you bigger or smaller than the one we’re looking for?</p>
<p>1021<br>01:11:18,039 –&gt; 01:11:22,119<br>If it’s bigger, then we know we have to look in the lower half of the list.</p>
<p>1022<br>01:11:22,119 –&gt; 01:11:25,000<br>If it’s smaller, we look in the upper half of the list.</p>
<p>1023<br>01:11:25,000 –&gt; 01:11:29,479<br>And now that we either look in the lower or the upper half, we notice we have the exact</p>
<p>1024<br>01:11:29,479 –&gt; 01:11:31,680<br>same problem to solve.</p>
<p>1025<br>01:11:31,680 –&gt; 01:11:36,440<br>So this should ring a little bell that says we should use recursion, right?</p>
<p>1026<br>01:11:36,440 –&gt; 01:11:41,480<br>As now we have the same problem to solve, an element e in a slightly smaller list, is</p>
<p>1027<br>01:11:41,480 –&gt; 01:11:43,440<br>it in that list?</p>
<p>1028<br>01:11:43,440 –&gt; 01:11:47,640<br>So that’s exactly what we’re going to implement.</p>
<p>1029<br>01:11:47,640 –&gt; 01:11:50,560<br>So visually speaking, this is what we’re going to do.</p>
<p>1030<br>01:11:50,560 –&gt; 01:11:55,320<br>We’re going to have an original list with n elements in it.</p>
<p>1031<br>01:11:55,320 –&gt; 01:11:59,000<br>We’re going to look at the halfway point, worst case, it’s not the one we’re looking for,</p>
<p>1032<br>01:11:59,000 –&gt; 01:12:03,000<br>so we’re going to decide on one of the sides to next search through.</p>
<p>1033<br>01:12:03,000 –&gt; 01:12:05,520<br>Now we have n over two elements to look through.</p>
<p>1034<br>01:12:05,520 –&gt; 01:12:09,239<br>Again, it’s not there, worst case, so we have to decide on which half to look through.</p>
<p>1035<br>01:12:09,239 –&gt; 01:12:11,720<br>Now we have n over four elements to look through.</p>
<p>1036<br>01:12:11,720 –&gt; 01:12:16,359<br>We keep doing this, we keep sort of having more and more recursive calls until we reach</p>
<p>1037<br>01:12:16,359 –&gt; 01:12:18,039<br>a base case.</p>
<p>1038<br>01:12:18,039 –&gt; 01:12:24,359<br>And the base case is that we now have a list with one element in it.</p>
<p>1039<br>01:12:24,359 –&gt; 01:12:28,239<br>Either that element is the one we’re looking for, or worst case, it’s not.</p>
<p>1040<br>01:12:28,239 –&gt; 01:12:34,679<br>And we’ve determined that the element we’re looking for is not in these n elements at all.</p>
<p>1041<br>01:12:34,679 –&gt; 01:12:41,319<br>So our base case is down here, and we started with n elements over here.</p>
<p>1042<br>01:12:41,319 –&gt; 01:12:48,599<br>So the bisection search algorithm will repeat this task of dividing the list in half, let’s</p>
<p>1043<br>01:12:48,599 –&gt; 01:12:51,800<br>say i times.</p>
<p>1044<br>01:12:51,800 –&gt; 01:12:55,239<br>So this is, quote unquote, how many iterations we would have made, right?</p>
<p>1045<br>01:12:55,239 –&gt; 01:12:57,920<br>But since this is recursion, there’s no iterations.</p>
<p>1046<br>01:12:57,920 –&gt; 01:13:04,279<br>This is how many function calls we have until we reach the base case, i function calls.</p>
<p>1047<br>01:13:04,279 –&gt; 01:13:11,239<br>So if we take our original n elements, and we divide them by two so many times that we</p>
<p>1048<br>01:13:11,239 –&gt; 01:13:16,039<br>have only one element left to search for, that’s when we found our answer.</p>
<p>1049<br>01:13:16,039 –&gt; 01:13:23,920<br>So we now have a relationship between how many elements we had, originally n elements,</p>
<p>1050<br>01:13:23,920 –&gt; 01:13:29,039<br>and how many times we had to divide our loop to get to our answer, right?</p>
<p>1051<br>01:13:29,039 –&gt; 01:13:31,279<br>How many of these levels we have, right?</p>
<p>1052<br>01:13:31,279 –&gt; 01:13:33,600<br>n divided by two to the i equals one.</p>
<p>1053<br>01:13:33,600 –&gt; 01:13:35,239<br>That’s our relationship.</p>
<p>1054<br>01:13:35,239 –&gt; 01:13:40,560<br>So in the bisection search algorithm, how many times are we calling this recursive function</p>
<p>1055<br>01:13:40,560 –&gt; 01:13:42,159<br>to get to the base case?</p>
<p>1056<br>01:13:42,159 –&gt; 01:13:43,560<br>Well, i times.</p>
<p>1057<br>01:13:43,560 –&gt; 01:13:45,840<br>So what is i in terms of n?</p>
<p>1058<br>01:13:45,840 –&gt; 01:13:50,920<br>Well, the relationship between i and n is similar to the one we had over here, right?</p>
<p>1059<br>01:13:50,920 –&gt; 01:13:52,880<br>Where we divided this number by 10 each time.</p>
<p>1060<br>01:13:52,880 –&gt; 01:13:57,039<br>Except that now we’re dividing a list of n elements by two each time.</p>
<p>1061<br>01:13:57,039 –&gt; 01:14:01,039<br>So the relationship is still logarithmic, right?</p>
<p>1062<br>01:14:01,039 –&gt; 01:14:06,279<br>It relates the number of elements I originally had, and with how many times I had to divide</p>
<p>1063<br>01:14:06,279 –&gt; 01:14:12,640<br>my list to get to one element, whether it’s the one I’m looking for or not.</p>
<p>1064<br>01:14:12,640 –&gt; 01:14:19,239<br>So the complexity of just the pure bisection search algorithm is theta of log n, where n</p>
<p>1065<br>01:14:19,239 –&gt; 01:14:21,079<br>is the length of the list, right?</p>
<p>1066<br>01:14:21,079 –&gt; 01:14:25,640<br>That’s how many subdivisions I need to do to get to one element to decide it’s not the</p>
<p>1067<br>01:14:25,640 –&gt; 01:14:28,039<br>one I’m looking for.</p>
<p>1068<br>01:14:28,039 –&gt; 01:14:32,239<br>So now we’re going to look at two different implementations of the code to do bisection</p>
<p>1069<br>01:14:32,239 –&gt; 01:14:33,239<br>search.</p>
<p>1070<br>01:14:33,239 –&gt; 01:14:35,079<br>One will be more efficient than the other.</p>
<p>1071<br>01:14:35,079 –&gt; 01:14:39,640<br>Let’s start with the one that’s simpler to write, but less efficient.</p>
<p>1072<br>01:14:39,640 –&gt; 01:14:45,359<br>So this code, you can see here, it looks for element e and list L, has two base cases</p>
<p>1073<br>01:14:45,359 –&gt; 01:14:46,359<br>up there.</p>
<p>1074<br>01:14:46,359 –&gt; 01:14:48,000<br>Those are both constant.</p>
<p>1075<br>01:14:48,000 –&gt; 01:14:50,159<br>And one recursive step here, right?</p>
<p>1076<br>01:14:50,159 –&gt; 01:14:51,800<br>So either we do this one or this one.</p>
<p>1077<br>01:14:51,800 –&gt; 01:14:56,119<br>So this one is if we decided we need to look in the lower half, and this is if we decided</p>
<p>1078<br>01:14:56,119 –&gt; 01:15:00,039<br>we need to look in the upper half for the element.</p>
<p>1079<br>01:15:00,039 –&gt; 01:15:05,039<br>So this is just pure bisection search, which on the previous slide we decided is theta</p>
<p>1080<br>01:15:05,039 –&gt; 01:15:10,159<br>of log of length of the list, theta of log n.</p>
<p>1081<br>01:15:10,159 –&gt; 01:15:16,319<br>Now that’s fine, but what do we have as a parameter here?</p>
<p>1082<br>01:15:16,319 –&gt; 01:15:19,439<br>It’s half of my list, right?</p>
<p>1083<br>01:15:19,439 –&gt; 01:15:24,219<br>So in addition to doing bisection search and just doing the algorithm, having a bunch</p>
<p>1084<br>01:15:24,219 –&gt; 01:15:29,679<br>of bisection search calls that take me to that list of one element, on top of that each</p>
<p>1085<br>01:15:29,679 –&gt; 01:15:34,759<br>time I make that bisection search call, I’m copying my list.</p>
<p>1086<br>01:15:34,759 –&gt; 01:15:37,479<br>So this is not constant.</p>
<p>1087<br>01:15:37,479 –&gt; 01:15:40,159<br>It’s theta of length L over 2, right?</p>
<p>1088<br>01:15:40,159 –&gt; 01:15:42,599<br>I grab half of my list.</p>
<p>1089<br>01:15:42,600 –&gt; 01:15:49,000<br>So the complexity of that code is theta of n times log n.</p>
<p>1090<br>01:15:49,000 –&gt; 01:15:54,640<br>Theta of log n for the bisection search bit, but theta of n tacked on to each one of those</p>
<p>1091<br>01:15:54,640 –&gt; 01:15:59,760<br>calls because I have to grab a copy of my list with each function call, right?</p>
<p>1092<br>01:15:59,760 –&gt; 01:16:02,480<br>So it’s not quite that efficient.</p>
<p>1093<br>01:16:02,480 –&gt; 01:16:07,079<br>Now let’s look at a slightly different implementation.</p>
<p>1094<br>01:16:07,079 –&gt; 01:16:11,720<br>This particular one is going to use integers to keep track of endpoints.</p>
<p>1095<br>01:16:11,720 –&gt; 01:16:16,440<br>So instead of copying my list, let me just keep track of a number for my low endpoint</p>
<p>1096<br>01:16:16,440 –&gt; 01:16:19,480<br>and a number for my high endpoint.</p>
<p>1097<br>01:16:19,480 –&gt; 01:16:23,960<br>The complexity analysis for the bisection search is going to be exactly the same because</p>
<p>1098<br>01:16:23,960 –&gt; 01:16:27,039<br>even though I’m just keeping track of these high and low endpoints, I’m still dividing</p>
<p>1099<br>01:16:27,039 –&gt; 01:16:29,760<br>the list in half with each call.</p>
<p>1100<br>01:16:29,760 –&gt; 01:16:34,199<br>But I’m doing it by keeping track of integer indices.</p>
<p>1101<br>01:16:34,199 –&gt; 01:16:37,159<br>So the size of the problem is still reduced by two at each step.</p>
<p>1102<br>01:16:37,159 –&gt; 01:16:39,039<br>I’m keeping track of these integer indices.</p>
<p>1103<br>01:16:39,039 –&gt; 01:16:41,640<br>I’m not copying the list at this point.</p>
<p>1104<br>01:16:41,640 –&gt; 01:16:47,880<br>I’m just changing an integer value from 10 to 5 or whatever it is.</p>
<p>1105<br>01:16:47,880 –&gt; 01:16:53,240<br>So the complexity analysis of the theta of the bisection search is theta of log n.</p>
<p>1106<br>01:16:53,240 –&gt; 01:16:58,560<br>The code looks a little bit messier, but overall it still does the same sort of things.</p>
<p>1107<br>01:16:58,560 –&gt; 01:17:05,320<br>It’s messier because now I want bisection search to look for an element e in list L, but</p>
<p>1108<br>01:17:05,320 –&gt; 01:17:09,760<br>I’d like my recursive call to keep track of two endpoints, right?</p>
<p>1109<br>01:17:09,760 –&gt; 01:17:16,760<br>So I’m going to create another function that I kick off down here, which looks for an</p>
<p>1110<br>01:17:16,760 –&gt; 01:17:22,760<br>element e in list L, but I’m also going to keep track of my low and high endpoints as parameter</p>
<p>1111<br>01:17:22,760 –&gt; 01:17:26,760<br>to my bisection search function.</p>
<p>1112<br>01:17:26,760 –&gt; 01:17:31,760<br>So bisection search helper here is now going to take in these four parameters.</p>
<p>1113<br>01:17:31,760 –&gt; 01:17:36,760<br>The rest of the code, no, it’s just details, but what’s important is everything is constant</p>
<p>1114<br>01:17:36,760 –&gt; 01:17:40,760<br>except for my two bisection search calls.</p>
<p>1115<br>01:17:40,760 –&gt; 01:17:48,760<br>Here, I’m changing my high, if I want to look in the lower half of the list, and here I’m changing my low,</p>
<p>1116<br>01:17:48,760 –&gt; 01:17:51,760<br>if I want to look in the upper half of the list.</p>
<p>1117<br>01:17:51,760 –&gt; 01:17:57,760<br>So those bisection search calls are still going to be theta of log n, but what’s the overhead now?</p>
<p>1118<br>01:17:57,760 –&gt; 01:17:59,760<br>The overhead is nothing, right? It’s constant.</p>
<p>1119<br>01:17:59,760 –&gt; 01:18:01,760<br>This L is the same one.</p>
<p>1120<br>01:18:01,760 –&gt; 01:18:03,760<br>I’m not making a copy of it.</p>
<p>1121<br>01:18:03,760 –&gt; 01:18:05,760<br>I’m just passing it through.</p>
<p>1122<br>01:18:05,760 –&gt; 01:18:10,760<br>E is just a number, low is just a number, and mid minus one is just a constant operation.</p>
<p>1123<br>01:18:10,760 –&gt; 01:18:12,760<br>There’s nothing being copied here.</p>
<p>1124<br>01:18:12,760 –&gt; 01:18:18,760<br>So the overall complexity of this code, while it looks a little bit pissier, is just theta of log n, right?</p>
<p>1125<br>01:18:18,760 –&gt; 01:18:23,760<br>Because the overhead is constant on each one of those function calls.</p>
<p>1126<br>01:18:23,760 –&gt; 01:18:27,760<br>So that brings us to this final question, right?</p>
<p>1127<br>01:18:27,760 –&gt; 01:18:31,760<br>Clearly, bisection search on a sorted list is faster.</p>
<p>1128<br>01:18:31,760 –&gt; 01:18:36,760<br>It’s theta of log n, then pure brute force search on a list.</p>
<p>1129<br>01:18:36,760 –&gt; 01:18:38,760<br>That could be sorted or unsorted.</p>
<p>1130<br>01:18:38,760 –&gt; 01:18:44,760<br>So the question is, when does it make sense to sort the list first?</p>
<p>1131<br>01:18:44,760 –&gt; 01:18:51,760<br>So given an unsorted list, when do you sort the list and use this fast binary search,</p>
<p>1132<br>01:18:51,760 –&gt; 01:18:55,760<br>versus just using a straight up linear search?</p>
<p>1133<br>01:18:55,760 –&gt; 01:18:59,760<br>Well, that’s when the time it takes to do the sort, right?</p>
<p>1134<br>01:18:59,760 –&gt; 01:19:08,760<br>An initial sort, plus the complexity to do binary search, is less than doing the straight up linear search.</p>
<p>1135<br>01:19:08,760 –&gt; 01:19:11,760<br>Because the list has to be sorted for this to work.</p>
<p>1136<br>01:19:11,760 –&gt; 01:19:13,760<br>Well, when is that true?</p>
<p>1137<br>01:19:13,760 –&gt; 01:19:21,760<br>Well, this implies that the time it takes to do the sort is less than theta of n.</p>
<p>1138<br>01:19:21,760 –&gt; 01:19:29,760<br>So that means, what, can you sort a list without even looking at all the elements once?</p>
<p>1139<br>01:19:29,760 –&gt; 01:19:30,760<br>No, right?</p>
<p>1140<br>01:19:30,760 –&gt; 01:19:35,760<br>Like, you have to look at all the elements once to even say that, hey, this list is already sorted.</p>
<p>1141<br>01:19:35,760 –&gt; 01:19:38,760<br>So this is actually never true.</p>
<p>1142<br>01:19:38,760 –&gt; 01:19:39,760<br>Right?</p>
<p>1143<br>01:19:39,760 –&gt; 01:19:40,760<br>So what does that mean?</p>
<p>1144<br>01:19:40,760 –&gt; 01:19:45,760<br>Does that mean we never want to do binary search on a list, unless it’s already sorted?</p>
<p>1145<br>01:19:45,760 –&gt; 01:19:46,760<br>Kind of.</p>
<p>1146<br>01:19:47,760 –&gt; 01:19:54,760<br>But in fact, you know, there are various situations when it does make sense to do the sort first, and then use binary search.</p>
<p>1147<br>01:19:54,760 –&gt; 01:20:03,760<br>And that’s the case where you, you’re given a data set, and you want to do a whole bunch of searches on that data set.</p>
<p>1148<br>01:20:03,760 –&gt; 01:20:09,760<br>So if you can take that sort, do it once, and then amortize the cost.</p>
<p>1149<br>01:20:09,760 –&gt; 01:20:14,760<br>It took you to do that sort over K different searches.</p>
<p>1150<br>01:20:14,760 –&gt; 01:20:23,760<br>Then it makes sense to pay the price to do the sort once, and then do it over, and then do the binary search over all these searches.</p>
<p>1151<br>01:20:23,760 –&gt; 01:20:27,760<br>All these, yeah, all these searches.</p>
<p>1152<br>01:20:27,760 –&gt; 01:20:32,760<br>And so as K gets really big, the time it takes for you to do the sort becomes irrelevant.</p>
<p>1153<br>01:20:32,760 –&gt; 01:20:44,760<br>Right? The theta of doing this thing on the left becomes just the theta to do the search, the search logarithmically, then it does to do the search linear.</p>
<p>1154<br>01:20:44,760 –&gt; 01:20:45,760<br>Okay.</p>
<p>1155<br>01:20:45,760 –&gt; 01:20:50,760<br>So if you’re only doing the search once, please do not sort your list, and then do a binary search.</p>
<p>1156<br>01:20:50,760 –&gt; 01:20:56,760<br>That’s going to take longer than just looking at the elements in your list straight through using brute force.</p>
<p>1157<br>01:20:56,760 –&gt; 01:21:03,760<br>But if you’re going to do a whole bunch of searches, make sense to do the sort, and then do the search.</p>
<p>1158<br>01:21:03,760 –&gt; 01:21:05,760<br>All right. That’s all I’ve got.</p>
<p>1159<br>01:21:05,760 –&gt; 01:21:11,760<br>Next lecture, we’re going to look at a bunch of different sorting algorithms, and we’ll have a quiz.</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>MIT6100 P23P23ComplexityClassesExamples</div>
      <div>http://example.com/2025/10/25/MIT6100 P23P23ComplexityClassesExamples/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/25/MIT6100%20P21P21TimingProgramsandCountingOperations/" title="MIT6100 P21P21TimingProgramsandCountingOperations">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">MIT6100 P21P21TimingProgramsandCountingOperations</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/25/MIT6100%20P22P22BigOhandTheta/" title="MIT6100 P22P22BigOhandTheta">
                        <span class="hidden-mobile">MIT6100 P22P22BigOhandTheta</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
