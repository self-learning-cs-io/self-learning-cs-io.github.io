

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="100:00:00,000 –&gt; 00:00:23,320So today marks the last lecture on the subject of sorting algorithms, or on the subject of 200:00:23,320 –&gt; 00:00:29,080complexity, and specifically we will be talki">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT6100 P24P24SortingAlgorithms">
<meta property="og:url" content="http://example.com/2025/10/25/MIT6100%20P24P24SortingAlgorithms/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="100:00:00,000 –&gt; 00:00:23,320So today marks the last lecture on the subject of sorting algorithms, or on the subject of 200:00:23,320 –&gt; 00:00:29,080complexity, and specifically we will be talki">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-25T05:09:25.359Z">
<meta property="article:modified_time" content="2025-10-25T05:11:04.559Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>MIT6100 P24P24SortingAlgorithms - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="MIT6100 P24P24SortingAlgorithms"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-25 13:09" pubdate>
          2025年10月25日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          7.7k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          65 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">MIT6100 P24P24SortingAlgorithms</h1>
            
            
              <div class="markdown-body">
                
                <p>1<br>00:00:00,000 –&gt; 00:00:23,320<br>So today marks the last lecture on the subject of sorting algorithms, or on the subject of</p>
<p>2<br>00:00:23,320 –&gt; 00:00:29,080<br>complexity, and specifically we will be talking about sorting algorithms.</p>
<p>3<br>00:00:29,079 –&gt; 00:00:33,519<br>So let’s remember where we left off at the end of last lecture.</p>
<p>4<br>00:00:33,519 –&gt; 00:00:38,960<br>We tried to look for elements within a list, and this is a really common problem in computer</p>
<p>5<br>00:00:38,960 –&gt; 00:00:44,879<br>science, where the list is basically a large data set that you might have gathered on,</p>
<p>6<br>00:00:44,879 –&gt; 00:00:51,640<br>I don’t know, biology information or physical experimental data, some big file of data,</p>
<p>7<br>00:00:51,640 –&gt; 00:00:56,280<br>and one of the most common things you might want to do on such a file is to search for something</p>
<p>8<br>00:00:56,280 –&gt; 00:01:00,520<br>within that file. Basically you’ll read it in as a list, and you’ll search for something</p>
<p>9<br>00:01:00,520 –&gt; 00:01:06,159<br>of interest within this list. So we saw two algorithms to search for an element within</p>
<p>10<br>00:01:06,159 –&gt; 00:01:13,520<br>a list. The first was just a straight-up linear search. That linear search we did on an unsorted</p>
<p>11<br>00:01:13,520 –&gt; 00:01:18,560<br>list, and we also did it on a sorted list. And what we saw was that the worst-case time</p>
<p>12<br>00:01:18,560 –&gt; 00:01:24,920<br>complexity for searching for an element within a list using linear search was theta-a-venn.</p>
<p>13<br>00:01:24,920 –&gt; 00:01:32,200<br>That’s the best that we could do. Now, we saw the binary search algorithm as an alternate</p>
<p>14<br>00:01:32,200 –&gt; 00:01:36,680<br>way to search for an element in a list, but the caveat to using the binary search algorithm</p>
<p>15<br>00:01:36,680 –&gt; 00:01:43,040<br>was that we had to have a sorted list. We can’t use this binary search algorithm on an unsorted</p>
<p>16<br>00:01:43,040 –&gt; 00:01:49,200<br>list because it will give us an incorrect answer. So assuming the list is sorted, binary</p>
<p>17<br>00:01:49,200 –&gt; 00:01:54,719<br>search does a much faster job at finding the element within a list. It does it in theta</p>
<p>18<br>00:01:54,719 –&gt; 00:02:02,400<br>of log n time, which is faster than theta-a-venn. The timing through a code that we did showed</p>
<p>19<br>00:02:02,400 –&gt; 00:02:07,920<br>this, counting the number of operations showed this, and then the theory also showed this.</p>
<p>20<br>00:02:07,920 –&gt; 00:02:15,400<br>All right. So clearly it is better to use binary search because it’s faster, but when does</p>
<p>21<br>00:02:15,400 –&gt; 00:02:21,680<br>it make sense to use binary search? So the idea is given some sort of data set, right,</p>
<p>22<br>00:02:21,680 –&gt; 00:02:28,360<br>some list of elements, we would have to first sort them in order to do binary search. So the</p>
<p>23<br>00:02:28,360 –&gt; 00:02:34,520<br>question then becomes the time that it takes for us to do a sort. Plus the time that it takes</p>
<p>24<br>00:02:34,520 –&gt; 00:02:40,480<br>for us to use binary search to look for an element within that list should be less than the time</p>
<p>25<br>00:02:40,480 –&gt; 00:02:45,480<br>that it takes for us to do linear search, right? In that case, it makes sense for us to do a sort</p>
<p>26<br>00:02:45,479 –&gt; 00:02:52,799<br>of binary search. This implies that the time it takes for us to sort is less than the subtraction,</p>
<p>27<br>00:02:52,799 –&gt; 00:03:00,759<br>so theta of n minus theta of log n. So this implies that we can sort a list in less than theta</p>
<p>28<br>00:03:00,759 –&gt; 00:03:07,120<br>of n time. That means we can sort a list without even looking at each element in the list. And</p>
<p>29<br>00:03:07,120 –&gt; 00:03:12,319<br>that’s not possible, right? We have to at least go through each element in the list one at a time</p>
<p>30<br>00:03:12,319 –&gt; 00:03:17,439<br>to determine that that list is sorted to begin with, right? So even in the best case scenario,</p>
<p>31<br>00:03:17,439 –&gt; 00:03:24,239<br>to sort a list, that’s going to be theta of n time. So clearly, this will never be true.</p>
<p>32<br>00:03:24,239 –&gt; 00:03:31,079<br>So then the question becomes why do we bother doing binary search in the first place? Well,</p>
<p>33<br>00:03:31,079 –&gt; 00:03:37,319<br>that’s because oftentimes if you download a data set or you know, you want to do some search</p>
<p>34<br>00:03:37,319 –&gt; 00:03:43,719<br>on some list or some data set that you get. Most of the time, you’re not going to want to do it</p>
<p>35<br>00:03:43,719 –&gt; 00:03:50,400<br>just once. You’re going to want to sort that list one time and then do a whole bunch of searches</p>
<p>36<br>00:03:50,400 –&gt; 00:03:56,319<br>for a whole bunch of different things within that list. So if we can somehow amortize the cost of</p>
<p>37<br>00:03:56,319 –&gt; 00:04:05,079<br>doing one sort over K different searches, as K gets really, really big, it makes sense to do</p>
<p>38<br>00:04:05,080 –&gt; 00:04:12,480<br>binary search on the sorted list rather than just to look through using linear search K different times,</p>
<p>39<br>00:04:12,480 –&gt; 00:04:18,759<br>right? So then that time to do the sort only once kind of gets absorbed and goes to zero as the number,</p>
<p>40<br>00:04:18,759 –&gt; 00:04:26,280<br>the K number of searches goes to some really big number. So clearly, we’ve shown that if you want to do</p>
<p>41<br>00:04:26,280 –&gt; 00:04:34,120<br>many searches on a data set, it makes sense to do the sort only once. All right, so now we’re going to look</p>
<p>42<br>00:04:34,120 –&gt; 00:04:40,120<br>at a bunch of different sorting algorithms. We’re going to start with some really bad ones and then we’re going to work our way up to</p>
<p>43<br>00:04:40,120 –&gt; 00:04:49,120<br>what is considered one of the best sorting algorithms, the best that we can do. So let’s begin by showing a really, really bad sorting algorithm</p>
<p>44<br>00:04:49,120 –&gt; 00:04:58,120<br>and there are actually competitions where people can come up with really bad sorting algorithms that kind of sort lists in a really weird way</p>
<p>45<br>00:04:58,120 –&gt; 00:05:07,120<br>while being really bad still making forward progress. And this is one of them. So this one is called bogus sort coming from the bogus sort,</p>
<p>46<br>00:05:07,120 –&gt; 00:05:15,120<br>also called random sort or monkey sort. So the idea here, and I’m going to use these cards as we look at these different sorting algorithms,</p>
<p>47<br>00:05:15,120 –&gt; 00:05:27,120<br>the idea of bogus sort is that we’re going to use randomness to help us sort the list. So if we wanted to sort a list or a deck of cards,</p>
<p>48<br>00:05:27,120 –&gt; 00:05:35,120<br>for example, the idea of bogus sort is that we’re going to take all our cards, we’re going to throw them up in the air, we’re going to pick them up as they land,</p>
<p>49<br>00:05:35,120 –&gt; 00:05:42,120<br>and we’re going to check to see if they’re sorted. If they are, we’re done. If they’re not, we’re going to repeat the process. We’re going to throw them up in the air,</p>
<p>50<br>00:05:42,120 –&gt; 00:05:52,120<br>let them fall where they may, and then we’re going to check if they’re sorted. Okay. So the code would look something like this. It takes in a list L,</p>
<p>51<br>00:05:52,120 –&gt; 00:06:05,120<br>and it says, while the list is not sorted, we’re going to call this shuffle function from the random library. And the shuffle function just re-shuffles or rearranges the elements in the list at random.</p>
<p>52<br>00:06:05,120 –&gt; 00:06:18,120<br>So let me show you how that looks like. So here’s the sorted function.</p>
<p>53<br>00:06:18,120 –&gt; 00:06:36,120<br>I’m going to run it. So it starts out with this list of obviously elements not in order, and it took about 0.2 seconds to just randomly keep re-shuffling the elements of that list to give me for them to become in sorted order.</p>
<p>54<br>00:06:36,120 –&gt; 00:06:52,120<br>So it did about 30,000 shuffles, and if I run it again, it will take a completely different amount of time each time it’s run. Right. So now it was really fast, but if I keep running it, you know, one time I ran it last night, it took about 2 seconds. So you can see it’s just random.</p>
<p>55<br>00:06:52,120 –&gt; 00:07:03,120<br>So what’s the complexity of this function? Clearly it’s not going to be very good. At best. So in the best case scenario, let’s say my input list is already sorted.</p>
<p>56<br>00:07:03,120 –&gt; 00:07:14,120<br>So in the best case scenario, the theta would be just theta of n, where n is the length of the list, because we have to look at each element once to make sure that it’s in its rightful place.</p>
<p>57<br>00:07:14,120 –&gt; 00:07:28,120<br>But in the worst case scenario, the theta complexity of this is unbounded, so infinity. Because at worst case, we’re going to be super unlucky, and we’re just never going to get the elements in a sorted order.</p>
<p>58<br>00:07:28,120 –&gt; 00:07:45,120<br>So in the case, not a very good sorting algorithm. If you go to the Wikipedia page for this, it’ll give you a whole bunch of other examples of algorithms similar in this in this spirit of, you know, being bad, but making forward progress towards an answer.</p>
<p>59<br>00:07:45,120 –&gt; 00:07:57,120<br>So we’re going to look at a different sorting algorithm called bubble sort, and it’s one of the most popular sorting algorithms, not because it’s good, but because people really like to make fun of it.</p>
<p>60<br>00:07:57,120 –&gt; 00:08:11,120<br>So it’s best to understand it. So the idea of bubble sort is that we’re going to start with a originally un-sorted list, and like I said, I’m going to use this as an example.</p>
<p>61<br>00:08:11,120 –&gt; 00:08:25,120<br>And we’re going to try to compare consecutive elements, one at a time. And as we do so, we’re effectively going to bubble up the largest element towards the end of the list.</p>
<p>62<br>00:08:25,120 –&gt; 00:08:41,120<br>So we’re going to start our first pass on this clearly un-sorted list, and we’re going to compare the first two elements. If the element at index i is smaller than the element at index i minus one, then I’m going to do a swap.</p>
<p>63<br>00:08:41,120 –&gt; 00:08:51,120<br>So here they were, so I did a swap. Then I’m going to compare the next set of elements. So these two are already sorted. These two are not, so I’m going to swap them. These two are not.</p>
<p>64<br>00:08:51,120 –&gt; 00:08:59,120<br>I’m going to swap them. These two are not. I’m going to swap them. They’re not. I’m going to swap them. And these two are not. And I’m going to swap them.</p>
<p>65<br>00:08:59,120 –&gt; 00:09:03,120<br>I’ll just do it over because that table got in the way.</p>
<p>66<br>00:09:03,120 –&gt; 00:09:15,120<br>So after I finished my first pass, this number, 11, effectively bubbled up from wherever it was towards the end of the list, the place where it belongs basically, right?</p>
<p>67<br>00:09:15,120 –&gt; 00:09:31,120<br>It belongs at the end of the list because it’s the biggest number. Since I’ve done at least one swap on that previous run, I’m going to go through again. Because in the process of doing a swap, I might have disarranged something that was already sort of in order.</p>
<p>68<br>00:09:31,120 –&gt; 00:09:45,120<br>So now I’m going to start all over again. I’m going to say, are these two in sorted order? They are. Are these two? No, so I swap. Are these two? No, so I swap. Are these two? No, so I swap. I swap. And I swap.</p>
<p>69<br>00:09:45,120 –&gt; 00:10:06,120<br>And now after two passes, I have effectively bubbled up the next biggest number. Next time through, I’m going to have to go again because I did one swap last time.</p>
<p>70<br>00:10:06,159 –&gt; 00:10:15,620<br>So again, I’m going to compare these two, I need to swap them, these two, I need to swap them, these two, I need to swap them, swap them, swap them. And these are in order and these are in order.</p>
<p>71<br>00:10:15,620 –&gt; 00:10:30,620<br>Again, 5 and the 4 needs to swap. 5 and the 1 needs to swap. 5 and the 0 needs to swap. 5 and the 2 needs to swap. These are in order. These are in order. 4 and the 1 needs to swap. These 2 need to swap. These need to swap, ordered, ordered, ordered.</p>
<p>72<br>00:10:30,620 –&gt; 00:10:32,620<br>Next, these two need a swap.</p>
<p>73<br>00:10:32,620 –&gt; 00:10:33,620<br>These are OK.</p>
<p>74<br>00:10:33,620 –&gt; 00:10:35,620<br>These are OK and so on.</p>
<p>75<br>00:10:35,620 –&gt; 00:10:41,320<br>And now that I’ve not, I’m going to do one final check.</p>
<p>76<br>00:10:41,320 –&gt; 00:10:43,220<br>These are all in order, right?</p>
<p>77<br>00:10:43,220 –&gt; 00:10:45,779<br>So now that I haven’t done any more swaps,</p>
<p>78<br>00:10:45,779 –&gt; 00:10:49,820<br>I can say that this list is now in sorted order.</p>
<p>79<br>00:10:49,820 –&gt; 00:10:53,860<br>So with each pass, I’m bubbling up the biggest element</p>
<p>80<br>00:10:53,860 –&gt; 00:10:55,379<br>towards the end of the list.</p>
<p>81<br>00:10:55,379 –&gt; 00:11:01,980<br>So at the end of end passes, the top, the last, and elements</p>
<p>82<br>00:11:01,980 –&gt; 00:11:05,220<br>will be in sorted order.</p>
<p>83<br>00:11:05,220 –&gt; 00:11:08,340<br>So the code looks something like this.</p>
<p>84<br>00:11:08,340 –&gt; 00:11:13,740<br>I’ve got a Boolean flag here that keeps track of whether or not</p>
<p>85<br>00:11:13,740 –&gt; 00:11:15,539<br>I have done a swap.</p>
<p>86<br>00:11:15,539 –&gt; 00:11:19,419<br>If I’ve done a swap, then I know I need to go through and double</p>
<p>87<br>00:11:19,419 –&gt; 00:11:22,700<br>check that everything is still in order</p>
<p>88<br>00:11:22,700 –&gt; 00:11:26,020<br>by comparing index i and i minus 1.</p>
<p>89<br>00:11:26,020 –&gt; 00:11:31,140<br>So to do that, we’ve got a for loop that goes through from 1</p>
<p>90<br>00:11:31,140 –&gt; 00:11:32,940<br>all the way up to the end of the list</p>
<p>91<br>00:11:32,940 –&gt; 00:11:36,300<br>because I’m going to compare element and index i with i minus 1.</p>
<p>92<br>00:11:36,300 –&gt; 00:11:39,500<br>If I started at 0, we’d get an index out of bounds error.</p>
<p>93<br>00:11:39,500 –&gt; 00:11:41,379<br>So that’s why I start with 1 over there.</p>
<p>94<br>00:11:41,379 –&gt; 00:11:43,860<br>And then the inside of the for loop just checks</p>
<p>95<br>00:11:43,860 –&gt; 00:11:48,300<br>if the element at, I guess, j, I use j and j and j and j minus 1</p>
<p>96<br>00:11:48,300 –&gt; 00:11:49,580<br>are in the right order.</p>
<p>97<br>00:11:49,580 –&gt; 00:11:50,660<br>Now, obviously, they are.</p>
<p>98<br>00:11:50,659 –&gt; 00:11:53,899<br>But when I first started this demo, they were not.</p>
<p>99<br>00:11:53,899 –&gt; 00:11:58,100<br>So as long as this j minus 1 and j are not in order,</p>
<p>100<br>00:11:58,100 –&gt; 00:11:59,059<br>do a swap.</p>
<p>101<br>00:11:59,059 –&gt; 00:12:04,139<br>So here, I just use this tuple trick here</p>
<p>102<br>00:12:04,139 –&gt; 00:12:08,500<br>to do the swap of element j minus 1 and j.</p>
<p>103<br>00:12:08,500 –&gt; 00:12:13,339<br>And I also reset the Boolean flag that I did the swap to true.</p>
<p>104<br>00:12:13,339 –&gt; 00:12:17,699<br>And this goes through until I don’t do any more swaps.</p>
<p>105<br>00:12:17,700 –&gt; 00:12:22,740<br>And then the code will not go through the while loop anymore.</p>
<p>106<br>00:12:22,740 –&gt; 00:12:25,660<br>So let’s print how this actually looks</p>
<p>107<br>00:12:25,660 –&gt; 00:12:28,900<br>like when we run it on our list.</p>
<p>108<br>00:12:28,900 –&gt; 00:12:34,300<br>So here, I have my original list.</p>
<p>109<br>00:12:34,300 –&gt; 00:12:39,020<br>Each set here, delineated by this line break,</p>
<p>110<br>00:12:39,020 –&gt; 00:12:44,580<br>represents one loop of my while loop.</p>
<p>111<br>00:12:44,580 –&gt; 00:12:47,379<br>So this thing here.</p>
<p>112<br>00:12:47,379 –&gt; 00:12:49,740<br>One iteration of my while loop.</p>
<p>113<br>00:12:49,740 –&gt; 00:12:57,019<br>And each line within here represents one iteration of my for loop.</p>
<p>114<br>00:12:57,019 –&gt; 00:13:01,259<br>So what we can see is that as we’re comparing the four</p>
<p>115<br>00:13:01,259 –&gt; 00:13:04,980<br>and the eight, the eight bubbles up was step over,</p>
<p>116<br>00:13:04,980 –&gt; 00:13:08,980<br>then we compare the eight and the six,</p>
<p>117<br>00:13:08,980 –&gt; 00:13:12,659<br>the eight bubbles itself over and so on and so on until it</p>
<p>118<br>00:13:12,659 –&gt; 00:13:13,700<br>encounters the 11.</p>
<p>119<br>00:13:13,700 –&gt; 00:13:17,179<br>And then the 11 starts to bubble itself up all the way to the end.</p>
<p>120<br>00:13:17,179 –&gt; 00:13:19,939<br>So at the end of the first while loop pass,</p>
<p>121<br>00:13:19,939 –&gt; 00:13:23,459<br>my 11 is in its rightful spot at the top of the list,</p>
<p>122<br>00:13:23,459 –&gt; 00:13:25,259<br>at the end of the list.</p>
<p>123<br>00:13:25,259 –&gt; 00:13:27,579<br>Next time through the while loop, I’m effectively</p>
<p>124<br>00:13:27,579 –&gt; 00:13:29,419<br>bubbling up the eight to the end.</p>
<p>125<br>00:13:29,419 –&gt; 00:13:31,939<br>So over here, next time through the while loop,</p>
<p>126<br>00:13:31,939 –&gt; 00:13:33,939<br>the six bubbles to the end, next time</p>
<p>127<br>00:13:33,939 –&gt; 00:13:36,579<br>the five bubbles through the end, then the four,</p>
<p>128<br>00:13:36,579 –&gt; 00:13:39,299<br>then the two, then the one, and then the zero.</p>
<p>129<br>00:13:39,299 –&gt; 00:13:40,299<br>OK.</p>
<p>130<br>00:13:44,539 –&gt; 00:13:45,779<br>All right.</p>
<p>131<br>00:13:45,779 –&gt; 00:13:47,620<br>So what’s the, yeah, question?</p>
<p>132<br>00:13:47,620 –&gt; 00:13:50,019<br>There’s no other question, because it’s</p>
<p>133<br>00:13:50,019 –&gt; 00:13:52,620<br>in any way to need the brackets.</p>
<p>134<br>00:13:52,620 –&gt; 00:13:54,019<br>Oh, we don’t need the brackets.</p>
<p>135<br>00:13:57,259 –&gt; 00:13:59,139<br>I mean, you can put them in.</p>
<p>136<br>00:13:59,139 –&gt; 00:13:59,979<br>It won’t harm.</p>
<p>137<br>00:13:59,979 –&gt; 00:14:02,219<br>But if you don’t put them, it’s OK.</p>
<p>138<br>00:14:02,219 –&gt; 00:14:06,099<br>Python knows that it’s doing an assignment one by one.</p>
<p>139<br>00:14:06,099 –&gt; 00:14:09,139<br>So this one to that one and that one to that one.</p>
<p>140<br>00:14:09,139 –&gt; 00:14:10,139<br>OK.</p>
<p>141<br>00:14:12,740 –&gt; 00:14:12,939<br>OK.</p>
<p>142<br>00:14:12,939 –&gt; 00:14:15,860<br>So let’s look at the worst case complexity analysis.</p>
<p>143<br>00:14:15,860 –&gt; 00:14:20,139<br>So the easy one we can already know is this inner four loop.</p>
<p>144<br>00:14:20,139 –&gt; 00:14:22,539<br>This one goes through from one to the length of the list.</p>
<p>145<br>00:14:22,539 –&gt; 00:14:25,939<br>So that’s state of length list.</p>
<p>146<br>00:14:25,939 –&gt; 00:14:27,980<br>We have another complexity, though,</p>
<p>147<br>00:14:27,980 –&gt; 00:14:30,100<br>because in the worst case scenario,</p>
<p>148<br>00:14:30,100 –&gt; 00:14:33,019<br>our list is completely backward.</p>
<p>149<br>00:14:33,019 –&gt; 00:14:38,460<br>And so this while loop up here will repeat length L times,</p>
<p>150<br>00:14:38,460 –&gt; 00:14:41,900<br>because we’re going to bubble up every single one of the elements</p>
<p>151<br>00:14:41,900 –&gt; 00:14:44,220<br>all the way through to the end of the list.</p>
<p>152<br>00:14:44,220 –&gt; 00:14:46,620<br>So the complexity of that while loop</p>
<p>153<br>00:14:46,620 –&gt; 00:14:48,660<br>will be theta of length L as well.</p>
<p>154<br>00:14:48,660 –&gt; 00:14:50,420<br>Because thinking about the worst case</p>
<p>155<br>00:14:50,420 –&gt; 00:14:53,180<br>is when our biggest element is here,</p>
<p>156<br>00:14:53,180 –&gt; 00:14:56,500<br>second biggest element is here, and so on.</p>
<p>157<br>00:14:56,500 –&gt; 00:14:57,820<br>OK.</p>
<p>158<br>00:14:57,820 –&gt; 00:14:58,740<br>All right.</p>
<p>159<br>00:14:58,740 –&gt; 00:15:00,660<br>So the worst case complexity of this function</p>
<p>160<br>00:15:00,660 –&gt; 00:15:03,700<br>is theta of length L squared, right?</p>
<p>161<br>00:15:03,700 –&gt; 00:15:06,340<br>Or theta of N squared, where N is the length of the list,</p>
<p>162<br>00:15:06,340 –&gt; 00:15:09,420<br>just to be less verbose.</p>
<p>163<br>00:15:09,420 –&gt; 00:15:10,740<br>OK.</p>
<p>164<br>00:15:10,740 –&gt; 00:15:13,139<br>Clearly not a great sorting algorithm.</p>
<p>165<br>00:15:13,139 –&gt; 00:15:15,340<br>It’s pretty inefficient in some of the things it’s doing.</p>
<p>166<br>00:15:15,340 –&gt; 00:15:19,460<br>I once it’s reached sorted some of the stuff up here,</p>
<p>167<br>00:15:19,460 –&gt; 00:15:21,580<br>it keeps comparing them through to the end.</p>
<p>168<br>00:15:21,580 –&gt; 00:15:24,780<br>So it just always goes through to the length of the list.</p>
<p>169<br>00:15:24,780 –&gt; 00:15:28,780<br>We can look at another sorting algorithm</p>
<p>170<br>00:15:28,780 –&gt; 00:15:32,420<br>called SelectionSort, which is sort of like bubble sort.</p>
<p>171<br>00:15:32,420 –&gt; 00:15:36,139<br>But it does things in a little bit of a smarter way.</p>
<p>172<br>00:15:36,139 –&gt; 00:15:38,939<br>So let me start again with an unsorted list.</p>
<p>173<br>00:15:41,939 –&gt; 00:15:47,819<br>And let’s see how SelectionSort will do this.</p>
<p>174<br>00:15:47,819 –&gt; 00:15:48,819<br>OK.</p>
<p>175<br>00:15:48,819 –&gt; 00:15:51,980<br>Let’s put it there.</p>
<p>176<br>00:15:51,980 –&gt; 00:15:52,860<br>OK.</p>
<p>177<br>00:15:52,860 –&gt; 00:15:58,299<br>So the idea of SelectionSort is that with each pass,</p>
<p>178<br>00:15:58,299 –&gt; 00:16:02,059<br>we’re going to decide which one of these elements</p>
<p>179<br>00:16:02,059 –&gt; 00:16:04,379<br>belongs at some index.</p>
<p>180<br>00:16:04,379 –&gt; 00:16:08,259<br>So with my first pass, I’ll decide which element belongs</p>
<p>181<br>00:16:08,259 –&gt; 00:16:09,779<br>at index 0.</p>
<p>182<br>00:16:09,779 –&gt; 00:16:12,700<br>With my second pass, I’ll decide which element belongs</p>
<p>183<br>00:16:12,700 –&gt; 00:16:15,580<br>at index 1, with my third which element belongs</p>
<p>184<br>00:16:15,580 –&gt; 00:16:18,659<br>at index 2, and so on.</p>
<p>185<br>00:16:18,659 –&gt; 00:16:21,179<br>So the way we’re going to do that is by saying,</p>
<p>186<br>00:16:21,179 –&gt; 00:16:22,860<br>all right, I’m going to take this element.</p>
<p>187<br>00:16:22,860 –&gt; 00:16:24,100<br>It’s the first one in the list.</p>
<p>188<br>00:16:24,100 –&gt; 00:16:26,259<br>It’s the one currently at index 0.</p>
<p>189<br>00:16:26,259 –&gt; 00:16:29,580<br>And I’m going to compare it with every single element</p>
<p>190<br>00:16:29,580 –&gt; 00:16:31,779<br>from the rest of the list.</p>
<p>191<br>00:16:31,779 –&gt; 00:16:34,980<br>And as I find an element that’s smaller than the one currently</p>
<p>192<br>00:16:34,980 –&gt; 00:16:36,740<br>there, I’m going to swap them.</p>
<p>193<br>00:16:36,740 –&gt; 00:16:38,699<br>Because I know that smaller one obviously</p>
<p>194<br>00:16:38,699 –&gt; 00:16:40,459<br>belongs at index 0.</p>
<p>195<br>00:16:40,459 –&gt; 00:16:42,059<br>So I’m going to compare the five with the eight.</p>
<p>196<br>00:16:42,059 –&gt; 00:16:44,059<br>I’m going to say, well, the five is smaller than the eight.</p>
<p>197<br>00:16:44,059 –&gt; 00:16:46,699<br>So it currently belongs at index 0.</p>
<p>198<br>00:16:46,699 –&gt; 00:16:48,659<br>I compare the five with the one.</p>
<p>199<br>00:16:48,659 –&gt; 00:16:49,659<br>The one is smaller.</p>
<p>200<br>00:16:49,659 –&gt; 00:16:52,539<br>So I’m going to do a swap and say the one belongs here.</p>
<p>201<br>00:16:52,539 –&gt; 00:16:57,019<br>Five with the 11, the one belongs here.</p>
<p>202<br>00:16:57,019 –&gt; 00:16:58,620<br>One with the six, the one belongs.</p>
<p>203<br>00:16:58,620 –&gt; 00:17:00,339<br>One with the two, the one still there.</p>
<p>204<br>00:17:00,340 –&gt; 00:17:03,060<br>One with the zero, well, zero smaller than one.</p>
<p>205<br>00:17:03,060 –&gt; 00:17:04,380<br>So let me swap it.</p>
<p>206<br>00:17:04,380 –&gt; 00:17:06,660<br>Zero with the four, we’re done.</p>
<p>207<br>00:17:06,660 –&gt; 00:17:08,700<br>So now, at the end of the first pass,</p>
<p>208<br>00:17:08,700 –&gt; 00:17:11,579<br>I’ve decided that the zero is the smallest out of everybody</p>
<p>209<br>00:17:11,579 –&gt; 00:17:12,180<br>here.</p>
<p>210<br>00:17:12,180 –&gt; 00:17:14,860<br>So it belongs at index 0.</p>
<p>211<br>00:17:14,860 –&gt; 00:17:19,140<br>Next time, my second pass, I’m not going to worry about this one.</p>
<p>212<br>00:17:19,140 –&gt; 00:17:20,380<br>I know it’s already the smallest.</p>
<p>213<br>00:17:20,380 –&gt; 00:17:24,700<br>So I’m going to determine which element belongs at index 1.</p>
<p>214<br>00:17:24,700 –&gt; 00:17:26,539<br>So the eight is the first one there.</p>
<p>215<br>00:17:26,539 –&gt; 00:17:27,980<br>It’s the one currently at index 1.</p>
<p>216<br>00:17:27,980 –&gt; 00:17:30,779<br>So I’m going to start with it being the one that belongs there.</p>
<p>217<br>00:17:30,779 –&gt; 00:17:34,299<br>And I’m going to successively compare it with everybody else.</p>
<p>218<br>00:17:34,299 –&gt; 00:17:36,819<br>So the eight with the five, the five clearly</p>
<p>219<br>00:17:36,819 –&gt; 00:17:38,259<br>is smaller than the eight.</p>
<p>220<br>00:17:38,259 –&gt; 00:17:40,180<br>Five with the 11, the five is smaller.</p>
<p>221<br>00:17:40,180 –&gt; 00:17:41,779<br>Five with the six, the five is smaller.</p>
<p>222<br>00:17:41,779 –&gt; 00:17:45,019<br>Five with the two needs a swap because the two is smaller.</p>
<p>223<br>00:17:45,019 –&gt; 00:17:46,059<br>Two with the one.</p>
<p>224<br>00:17:46,059 –&gt; 00:17:47,220<br>Again, we swap.</p>
<p>225<br>00:17:47,220 –&gt; 00:17:48,620<br>The one is smaller.</p>
<p>226<br>00:17:48,620 –&gt; 00:17:51,420<br>And then one with the four, done.</p>
<p>227<br>00:17:51,420 –&gt; 00:17:53,140<br>So at the end of the second pass,</p>
<p>228<br>00:17:53,140 –&gt; 00:17:56,220<br>I’ve decided that the one belongs at the next index.</p>
<p>229<br>00:17:56,220 –&gt; 00:17:59,620<br>So now these two elements are in their correct place.</p>
<p>230<br>00:17:59,620 –&gt; 00:18:01,700<br>They’re in sorted order.</p>
<p>231<br>00:18:01,700 –&gt; 00:18:04,860<br>OK, third pass, we’re going to decide which element belongs</p>
<p>232<br>00:18:04,860 –&gt; 00:18:07,420<br>at the next index, the index 2.</p>
<p>233<br>00:18:07,420 –&gt; 00:18:09,180<br>So eight with the 11 is OK.</p>
<p>234<br>00:18:09,180 –&gt; 00:18:11,220<br>Eight with the six, we need to swap.</p>
<p>235<br>00:18:11,220 –&gt; 00:18:13,500<br>Six with the five, we need to swap.</p>
<p>236<br>00:18:13,500 –&gt; 00:18:15,500<br>Five with the two, we need to swap.</p>
<p>237<br>00:18:15,500 –&gt; 00:18:18,579<br>Two with the four, everything’s OK.</p>
<p>238<br>00:18:18,579 –&gt; 00:18:19,539<br>Three passes.</p>
<p>239<br>00:18:19,539 –&gt; 00:18:21,579<br>The first three elements are in sorted order.</p>
<p>240<br>00:18:21,579 –&gt; 00:18:24,940<br>Now we just need to figure out between these leftovers,</p>
<p>241<br>00:18:24,940 –&gt; 00:18:28,019<br>which one belongs at the next level.</p>
<p>242<br>00:18:28,019 –&gt; 00:18:30,340<br>So eight with the 11, we do a swap.</p>
<p>243<br>00:18:30,340 –&gt; 00:18:32,980<br>Eight with the six, we do the swap.</p>
<p>244<br>00:18:32,980 –&gt; 00:18:35,059<br>Six with the five, we bring the five here.</p>
<p>245<br>00:18:35,059 –&gt; 00:18:36,740<br>Five with the four, we bring it here.</p>
<p>246<br>00:18:40,019 –&gt; 00:18:43,380<br>Again, 11 with the eight, we swap these.</p>
<p>247<br>00:18:43,380 –&gt; 00:18:44,980<br>Eight with the six, we swap these.</p>
<p>248<br>00:18:44,980 –&gt; 00:18:47,420<br>Six with the five, we swap them.</p>
<p>249<br>00:18:47,420 –&gt; 00:18:49,779<br>So as you can see, as I’m making my way</p>
<p>250<br>00:18:49,779 –&gt; 00:18:52,740<br>through to figure out which belongs at the next index,</p>
<p>251<br>00:18:52,740 –&gt; 00:18:57,380<br>I have fewer elements to decide between which belongs</p>
<p>252<br>00:18:57,380 –&gt; 00:18:59,259<br>at the next index.</p>
<p>253<br>00:18:59,259 –&gt; 00:19:03,500<br>So here, the 11 needs to swap.</p>
<p>254<br>00:19:03,500 –&gt; 00:19:05,220<br>Eight with the six needs to swap.</p>
<p>255<br>00:19:05,220 –&gt; 00:19:07,099<br>And then lastly, like that.</p>
<p>256<br>00:19:09,579 –&gt; 00:19:14,620<br>So slightly more efficient in that we’re not comparing</p>
<p>257<br>00:19:14,620 –&gt; 00:19:17,859<br>a bunch of pairs all the time all the way through</p>
<p>258<br>00:19:17,859 –&gt; 00:19:19,019<br>to the length of the list.</p>
<p>259<br>00:19:19,019 –&gt; 00:19:20,940<br>So the code looks like this.</p>
<p>260<br>00:19:20,940 –&gt; 00:19:25,220<br>I’ve got one for loop that goes through the length of the list.</p>
<p>261<br>00:19:25,220 –&gt; 00:19:29,460<br>And one inner for loop that only starts at i</p>
<p>262<br>00:19:29,460 –&gt; 00:19:31,980<br>and goes through to the end of the list.</p>
<p>263<br>00:19:31,980 –&gt; 00:19:34,340<br>So unlike bubble sort, which started at one</p>
<p>264<br>00:19:34,340 –&gt; 00:19:36,700<br>and went through to the end of the list all the time,</p>
<p>265<br>00:19:36,700 –&gt; 00:19:39,900<br>here I’m starting at i and going through to the end of the list.</p>
<p>266<br>00:19:39,900 –&gt; 00:19:44,019<br>Because in selection sort, with each pass,</p>
<p>267<br>00:19:44,019 –&gt; 00:19:47,700<br>I’ve decided which element belongs at a specific index.</p>
<p>268<br>00:19:47,700 –&gt; 00:19:50,140<br>So I no longer need to worry about comparing</p>
<p>269<br>00:19:50,140 –&gt; 00:19:52,819<br>that element with everybody else.</p>
<p>270<br>00:19:52,819 –&gt; 00:19:56,059<br>So when we were like that, we had decided</p>
<p>271<br>00:19:56,059 –&gt; 00:19:57,700<br>these were in sorted order.</p>
<p>272<br>00:19:57,700 –&gt; 00:20:00,620<br>I only needed to compare these three amongst themselves</p>
<p>273<br>00:20:00,620 –&gt; 00:20:03,340<br>to decide which one fit at the next spot.</p>
<p>274<br>00:20:03,340 –&gt; 00:20:06,620<br>Everybody else was already sorted.</p>
<p>275<br>00:20:06,620 –&gt; 00:20:08,860<br>So what’s the complexity analysis of this?</p>
<p>276<br>00:20:08,860 –&gt; 00:20:11,380<br>This is going to be feel very similar to diameter</p>
<p>277<br>00:20:11,380 –&gt; 00:20:13,819<br>from last lecture, because diameter also</p>
<p>278<br>00:20:13,819 –&gt; 00:20:16,140<br>had this funky thing where we started from i</p>
<p>279<br>00:20:16,140 –&gt; 00:20:19,380<br>and went through to the length of the list.</p>
<p>280<br>00:20:19,380 –&gt; 00:20:22,620<br>Well, it’s going to be theta of length L squared again.</p>
<p>281<br>00:20:22,620 –&gt; 00:20:25,900<br>So there’s two ways to think about this.</p>
<p>282<br>00:20:25,900 –&gt; 00:20:29,740<br>The first one is to look at each loop individually.</p>
<p>283<br>00:20:29,740 –&gt; 00:20:34,140<br>Clearly, the outer loop goes through theta of length L.</p>
<p>284<br>00:20:34,140 –&gt; 00:20:35,220<br>No question about that.</p>
<p>285<br>00:20:35,220 –&gt; 00:20:37,700<br>That just goes through range of length L.</p>
<p>286<br>00:20:37,700 –&gt; 00:20:39,620<br>The inner loop is a little bit trickier,</p>
<p>287<br>00:20:39,620 –&gt; 00:20:43,140<br>because it doesn’t always go from some fixed number</p>
<p>288<br>00:20:43,140 –&gt; 00:20:45,420<br>to the length of the list.</p>
<p>289<br>00:20:45,420 –&gt; 00:20:50,340<br>But what we can think about is on average.</p>
<p>290<br>00:20:50,340 –&gt; 00:20:52,660<br>The first time, when we were trying</p>
<p>291<br>00:20:52,660 –&gt; 00:20:54,100<br>to figure out the element that belongs</p>
<p>292<br>00:20:54,100 –&gt; 00:20:58,300<br>at the first index, or index 0, we went through to the length</p>
<p>293<br>00:20:58,300 –&gt; 00:20:58,860<br>of the list.</p>
<p>294<br>00:20:58,860 –&gt; 00:21:00,740<br>We had to compare with everybody else.</p>
<p>295<br>00:21:00,740 –&gt; 00:21:03,900<br>The next time, we have to compare with lengthless minus 1,</p>
<p>296<br>00:21:03,900 –&gt; 00:21:05,740<br>then lengthless minus 2.</p>
<p>297<br>00:21:05,740 –&gt; 00:21:09,300<br>And then at the end, we only had one item to compare.</p>
<p>298<br>00:21:09,300 –&gt; 00:21:12,700<br>So on average, that inner loop goes through length</p>
<p>299<br>00:21:12,700 –&gt; 00:21:14,380<br>L over 2 times.</p>
<p>300<br>00:21:14,380 –&gt; 00:21:16,380<br>On average, we have to look through about half</p>
<p>301<br>00:21:16,380 –&gt; 00:21:23,019<br>of the elements in the list to do the comparison.</p>
<p>302<br>00:21:23,019 –&gt; 00:21:28,140<br>So if the inner loop here on average is theta of length L</p>
<p>303<br>00:21:28,140 –&gt; 00:21:33,620<br>is length L over 2, then the theta of length L over 2</p>
<p>304<br>00:21:33,620 –&gt; 00:21:39,700<br>is theta of length L. There’s just the 0.5 in front of that.</p>
<p>305<br>00:21:39,700 –&gt; 00:21:41,980<br>So that’s the first way to think about the complexity</p>
<p>306<br>00:21:41,980 –&gt; 00:21:43,539<br>and analysis of this.</p>
<p>307<br>00:21:43,539 –&gt; 00:21:49,539<br>The other way is to ask yourself, well, what part of this code</p>
<p>308<br>00:21:49,539 –&gt; 00:21:51,700<br>is doing the repetitions?</p>
<p>309<br>00:21:51,700 –&gt; 00:21:53,579<br>Like if we were to think about what</p>
<p>310<br>00:21:53,579 –&gt; 00:21:57,860<br>we’re counting in terms of units, which part of this code repeats?</p>
<p>311<br>00:21:57,860 –&gt; 00:22:01,180<br>Well, the stuff inside the inner four loop repeats.</p>
<p>312<br>00:22:01,180 –&gt; 00:22:05,140<br>So you’re going to do a whole bunch of comparisons.</p>
<p>313<br>00:22:05,140 –&gt; 00:22:09,299<br>So how many actual comparisons will you do?</p>
<p>314<br>00:22:09,299 –&gt; 00:22:14,539<br>Well, the very first time, like from the outer first pass</p>
<p>315<br>00:22:14,539 –&gt; 00:22:16,059<br>through to the end of the list, you’re</p>
<p>316<br>00:22:16,059 –&gt; 00:22:19,379<br>going to do approximately length L comparisons.</p>
<p>317<br>00:22:19,379 –&gt; 00:22:22,339<br>The next time, you’re going to do length L minus 1 comparisons.</p>
<p>318<br>00:22:22,339 –&gt; 00:22:24,259<br>Then length L minus 2 comparisons.</p>
<p>319<br>00:22:24,259 –&gt; 00:22:27,899<br>And so on and so on down to only 1 comparison.</p>
<p>320<br>00:22:27,899 –&gt; 00:22:30,940<br>So if we do that sum 1 plus 2 plus 3 plus all the way up</p>
<p>321<br>00:22:30,940 –&gt; 00:22:35,619<br>to length L, that formula becomes length L times length L</p>
<p>322<br>00:22:35,619 –&gt; 00:22:36,779<br>plus 1 over 2.</p>
<p>323<br>00:22:36,779 –&gt; 00:22:41,019<br>So that becomes length L squared over 2 plus length L over 2.</p>
<p>324<br>00:22:41,019 –&gt; 00:22:45,779<br>And that becomes theta of length L squared.</p>
<p>325<br>00:22:45,779 –&gt; 00:22:49,779<br>So just a couple ways to think about the analysis of this.</p>
<p>326<br>00:22:49,779 –&gt; 00:22:51,740<br>And this is a pretty common thing you’ll see.</p>
<p>327<br>00:22:51,740 –&gt; 00:22:54,339<br>But just because we start at I, doesn’t mean</p>
<p>328<br>00:22:54,339 –&gt; 00:22:59,859<br>that it decreases the complexity of this function dramatically.</p>
<p>329<br>00:22:59,859 –&gt; 00:23:01,579<br>It doesn’t decrease it by some order.</p>
<p>330<br>00:23:01,579 –&gt; 00:23:04,019<br>It just decreases it by half.</p>
<p>331<br>00:23:04,019 –&gt; 00:23:13,539<br>So it’s still theta of length L. OK.</p>
<p>332<br>00:23:13,539 –&gt; 00:23:17,539<br>So we can actually do a little variation on this.</p>
<p>333<br>00:23:17,539 –&gt; 00:23:21,339<br>Because you might have noticed it was a little inefficient</p>
<p>334<br>00:23:21,339 –&gt; 00:23:24,539<br>to do the swap every time I noticed another element that’s</p>
<p>335<br>00:23:24,539 –&gt; 00:23:26,539<br>smaller.</p>
<p>336<br>00:23:26,539 –&gt; 00:23:29,220<br>I didn’t have to do the switch.</p>
<p>337<br>00:23:29,220 –&gt; 00:23:32,220<br>All I had to do was kind of just keep track</p>
<p>338<br>00:23:32,220 –&gt; 00:23:34,980<br>through a variable of the smallest number</p>
<p>339<br>00:23:34,980 –&gt; 00:23:36,620<br>that I have seen so far.</p>
<p>340<br>00:23:36,620 –&gt; 00:23:39,339<br>And only do the switch at the end when I’ve</p>
<p>341<br>00:23:39,339 –&gt; 00:23:42,299<br>determined that that’s the smallest number.</p>
<p>342<br>00:23:42,299 –&gt; 00:23:44,900<br>So the variation, basically, if this is my list, says,</p>
<p>343<br>00:23:44,900 –&gt; 00:23:47,180<br>hey, I’m going to look at this element that</p>
<p>344<br>00:23:47,180 –&gt; 00:23:49,740<br>belongs in this very first slot.</p>
<p>345<br>00:23:49,740 –&gt; 00:23:50,940<br>8 is the first one.</p>
<p>346<br>00:23:50,940 –&gt; 00:23:53,779<br>Then I’m going to look through the elements all the way up</p>
<p>347<br>00:23:53,779 –&gt; 00:23:56,339<br>to the end of the list and keep track of the smallest one.</p>
<p>348<br>00:23:56,339 –&gt; 00:23:58,740<br>The 4, the 1 is currently smallest.</p>
<p>349<br>00:23:58,740 –&gt; 00:24:01,059<br>6 is not, 5 is not, 9 is not.</p>
<p>350<br>00:24:01,059 –&gt; 00:24:03,379<br>2 is not the 0 smaller than the 1.</p>
<p>351<br>00:24:03,379 –&gt; 00:24:06,740<br>So if I see the 0 smallest, then I swap it.</p>
<p>352<br>00:24:06,740 –&gt; 00:24:09,179<br>So I only do one swap at the end.</p>
<p>353<br>00:24:09,179 –&gt; 00:24:10,700<br>Next time through, I’m going to decide</p>
<p>354<br>00:24:10,700 –&gt; 00:24:12,339<br>which element belongs at this index.</p>
<p>355<br>00:24:12,339 –&gt; 00:24:14,179<br>The 1 is the smallest I see.</p>
<p>356<br>00:24:14,179 –&gt; 00:24:16,700<br>So I do the swap only at the end.</p>
<p>357<br>00:24:16,700 –&gt; 00:24:18,659<br>Then I decide which element belongs here.</p>
<p>358<br>00:24:18,659 –&gt; 00:24:20,700<br>The 2 is smallest out of everybody left.</p>
<p>359<br>00:24:20,700 –&gt; 00:24:22,099<br>The 2 goes there.</p>
<p>360<br>00:24:22,099 –&gt; 00:24:24,500<br>So I’m doing all these comparisons,</p>
<p>361<br>00:24:24,500 –&gt; 00:24:27,980<br>but I only do the swap at the end.</p>
<p>362<br>00:24:27,980 –&gt; 00:24:30,740<br>When I’ve decided, hey, this is the smallest element,</p>
<p>363<br>00:24:30,740 –&gt; 00:24:34,259<br>let me just swap it with the one that’s currently there.</p>
<p>364<br>00:24:34,259 –&gt; 00:24:36,059<br>So it’s just going to go through to the end of that.</p>
<p>365<br>00:24:40,579 –&gt; 00:24:44,620<br>So I wrote that variation here.</p>
<p>366<br>00:24:44,620 –&gt; 00:24:50,819<br>So this is selection sort just as we saw it.</p>
<p>367<br>00:24:50,819 –&gt; 00:24:55,339<br>So we can see here that the first pass with the outer loop,</p>
<p>368<br>00:24:55,339 –&gt; 00:25:00,180<br>we have length L comparisons to make,</p>
<p>369<br>00:25:00,180 –&gt; 00:25:03,420<br>because we’re always comparing these two, right?</p>
<p>370<br>00:25:03,420 –&gt; 00:25:05,180<br>Then the one that’s currently at this index,</p>
<p>371<br>00:25:05,180 –&gt; 00:25:08,340<br>and the next one index over, the one that’s currently</p>
<p>372<br>00:25:08,340 –&gt; 00:25:11,500<br>at this index, and one index over, and so on.</p>
<p>373<br>00:25:11,500 –&gt; 00:25:14,700<br>So the first pass, I’ve done length L, sorry,</p>
<p>374<br>00:25:14,700 –&gt; 00:25:16,700<br>length L comparisons.</p>
<p>375<br>00:25:16,700 –&gt; 00:25:20,500<br>The next pass, I’ve done length L minus 1 comparisons,</p>
<p>376<br>00:25:20,500 –&gt; 00:25:22,380<br>because I don’t need to look at the 0 anymore.</p>
<p>377<br>00:25:22,380 –&gt; 00:25:24,380<br>I already know that’s in the right place.</p>
<p>378<br>00:25:24,380 –&gt; 00:25:27,500<br>Then after that, I do length L minus 2 comparisons,</p>
<p>379<br>00:25:27,500 –&gt; 00:25:29,259<br>then length L minus 3 comparisons.</p>
<p>380<br>00:25:29,259 –&gt; 00:25:32,619<br>So you can see, as we’re making progress</p>
<p>381<br>00:25:32,619 –&gt; 00:25:36,019<br>through our outer loop, we have fewer and fewer comparisons</p>
<p>382<br>00:25:36,019 –&gt; 00:25:36,740<br>to do.</p>
<p>383<br>00:25:36,740 –&gt; 00:25:39,819<br>So you might think that this is much better,</p>
<p>384<br>00:25:39,819 –&gt; 00:25:43,579<br>but the theta complexity analysis says it’s not.</p>
<p>385<br>00:25:43,579 –&gt; 00:25:45,660<br>So that’s the original selection sort,</p>
<p>386<br>00:25:45,660 –&gt; 00:25:48,460<br>and the variation on selection sort.</p>
<p>387<br>00:25:50,940 –&gt; 00:25:55,299<br>Looks a little more complicated, but it’s not doing a swap.</p>
<p>388<br>00:25:55,299 –&gt; 00:25:59,140<br>So it’s only doing a swap down here, as you can see.</p>
<p>389<br>00:25:59,140 –&gt; 00:26:02,740<br>It’s doing it after it finishes this inner for loop.</p>
<p>390<br>00:26:02,740 –&gt; 00:26:07,020<br>And all this inner for loop is doing is checking,</p>
<p>391<br>00:26:07,020 –&gt; 00:26:09,220<br>is doing the comparisons, and keeping</p>
<p>392<br>00:26:09,220 –&gt; 00:26:12,940<br>track of the smallest number it sees in this variable</p>
<p>393<br>00:26:12,940 –&gt; 00:26:14,820<br>called smallest.</p>
<p>394<br>00:26:14,820 –&gt; 00:26:18,020<br>And the index associated with that smallest variable</p>
<p>395<br>00:26:18,020 –&gt; 00:26:19,300<br>in smallest j.</p>
<p>396<br>00:26:21,660 –&gt; 00:26:24,420<br>Now, if we look at the analysis for this,</p>
<p>397<br>00:26:24,420 –&gt; 00:26:28,380<br>well, we still have an outer for loop that goes through length L.</p>
<p>398<br>00:26:28,380 –&gt; 00:26:32,980<br>We still have an inner for loop that goes from I to length L.</p>
<p>399<br>00:26:32,980 –&gt; 00:26:36,460<br>All it’s doing is eliminating this line here.</p>
<p>400<br>00:26:36,460 –&gt; 00:26:39,420<br>It does it only once at the end, but it’s still</p>
<p>401<br>00:26:39,420 –&gt; 00:26:41,260<br>doing all these comparisons.</p>
<p>402<br>00:26:41,260 –&gt; 00:26:44,060<br>It still has to look through all of these elements,</p>
<p>403<br>00:26:44,060 –&gt; 00:26:46,500<br>one pair by pair, to do the comparison.</p>
<p>404<br>00:26:46,500 –&gt; 00:26:49,220<br>So actually, this slight speed up</p>
<p>405<br>00:26:49,220 –&gt; 00:26:52,940<br>doesn’t have a big impact on my theta complexity.</p>
<p>406<br>00:26:52,940 –&gt; 00:26:55,860<br>It’s still going to be theta of length L squared.</p>
<p>407<br>00:26:59,180 –&gt; 00:27:04,220<br>Any questions so far on these sorting algorithms?</p>
<p>408<br>00:27:10,460 –&gt; 00:27:14,700<br>So clearly, we’re not really doing a very good job</p>
<p>409<br>00:27:14,700 –&gt; 00:27:21,180<br>about thinking of a unique way to do the sorting, right?</p>
<p>410<br>00:27:21,180 –&gt; 00:27:24,100<br>Because all of these different variations</p>
<p>411<br>00:27:24,100 –&gt; 00:27:26,820<br>where we’re doing slight speed ups here and there</p>
<p>412<br>00:27:26,819 –&gt; 00:27:29,259<br>aren’t doing a drastic enough job</p>
<p>413<br>00:27:29,259 –&gt; 00:27:33,139<br>to bring us a whole complexity class lower.</p>
<p>414<br>00:27:33,139 –&gt; 00:27:37,139<br>So we have to think about the problem in a completely different way.</p>
<p>415<br>00:27:37,139 –&gt; 00:27:41,619<br>So the iterative approach is not working out for us,</p>
<p>416<br>00:27:41,619 –&gt; 00:27:45,299<br>where we basically have a loop that does something</p>
<p>417<br>00:27:45,299 –&gt; 00:27:48,019<br>and another loop that does some sort of comparison.</p>
<p>418<br>00:27:48,019 –&gt; 00:27:53,819<br>That’s not going to get us a whole complexity class speed up.</p>
<p>419<br>00:27:53,819 –&gt; 00:27:55,579<br>So instead, what we’re going to do</p>
<p>420<br>00:27:55,579 –&gt; 00:28:01,299<br>is approach the problem from sort of inspired</p>
<p>421<br>00:28:01,299 –&gt; 00:28:04,819<br>by section search or binary search.</p>
<p>422<br>00:28:04,819 –&gt; 00:28:08,700<br>In bi-section search, we weren’t looking at each element</p>
<p>423<br>00:28:08,700 –&gt; 00:28:09,659<br>one at a time.</p>
<p>424<br>00:28:09,659 –&gt; 00:28:14,779<br>We were taking our list and dividing it in half.</p>
<p>425<br>00:28:14,779 –&gt; 00:28:17,700<br>So we can try to do a similar approach here,</p>
<p>426<br>00:28:17,700 –&gt; 00:28:20,419<br>and that’s what this merge sort algorithm does.</p>
<p>427<br>00:28:20,419 –&gt; 00:28:23,220<br>It’s going to take an original list,</p>
<p>428<br>00:28:23,220 –&gt; 00:28:28,420<br>and it’s going to divide this list in half with each step.</p>
<p>429<br>00:28:28,420 –&gt; 00:28:31,460<br>And it’s going to do this recursively.</p>
<p>430<br>00:28:31,460 –&gt; 00:28:33,220<br>It’s going to be a dividing conquer algorithm.</p>
<p>431<br>00:28:33,220 –&gt; 00:28:36,620<br>So it’s going to recursively divide this list in half each step.</p>
<p>432<br>00:28:36,620 –&gt; 00:28:42,539<br>And then it’s going to merge sorted lists in a really smart way,</p>
<p>433<br>00:28:42,539 –&gt; 00:28:46,299<br>such that it’ll give us the speed up that we’re interested in.</p>
<p>434<br>00:28:46,299 –&gt; 00:28:49,180<br>So let me explain to you how we’re going to merge it.</p>
<p>435<br>00:28:49,180 –&gt; 00:28:54,860<br>And then we’ll see how we can write up this whole algorithm.</p>
<p>436<br>00:28:54,860 –&gt; 00:28:59,980<br>So let’s say that we have, let’s do this.</p>
<p>437<br>00:28:59,980 –&gt; 00:29:09,140<br>Let’s say that we’ve done some sort of division of lists.</p>
<p>438<br>00:29:09,140 –&gt; 00:29:11,340<br>And let’s say that we’ve written this algorithm,</p>
<p>439<br>00:29:11,340 –&gt; 00:29:14,500<br>and it works really nicely in such a way</p>
<p>440<br>00:29:14,500 –&gt; 00:29:21,539<br>that it gives us two sorted lists.</p>
<p>441<br>00:29:21,539 –&gt; 00:29:26,539<br>So if somehow my algorithm, where I had one full list</p>
<p>442<br>00:29:26,539 –&gt; 00:29:30,859<br>of all of these eight elements here divided itself,</p>
<p>443<br>00:29:30,859 –&gt; 00:29:35,099<br>and when it came back together, it gave me two sublists</p>
<p>444<br>00:29:35,099 –&gt; 00:29:37,099<br>that themselves are sorted.</p>
<p>445<br>00:29:37,099 –&gt; 00:29:41,819<br>So this is a sorted list, and this is a sorted list by itself.</p>
<p>446<br>00:29:41,819 –&gt; 00:29:47,700<br>Then there’s this really smart and merge step that we can do.</p>
<p>447<br>00:29:47,700 –&gt; 00:29:51,579<br>So we can recognize that if this list is sorted by itself,</p>
<p>448<br>00:29:51,579 –&gt; 00:29:56,179<br>and this list is sorted by itself, to determine the element</p>
<p>449<br>00:29:56,179 –&gt; 00:29:58,899<br>that is the smallest between both of these lists,</p>
<p>450<br>00:29:58,899 –&gt; 00:30:02,539<br>all we have to do is look at the first element of each list,</p>
<p>451<br>00:30:02,539 –&gt; 00:30:03,939<br>each sublist, right?</p>
<p>452<br>00:30:03,939 –&gt; 00:30:05,579<br>This is the smallest out of these guys.</p>
<p>453<br>00:30:05,579 –&gt; 00:30:06,859<br>This is the smallest out of these guys.</p>
<p>454<br>00:30:06,859 –&gt; 00:30:08,819<br>So if I just compare the zero and the four,</p>
<p>455<br>00:30:08,819 –&gt; 00:30:13,859<br>I know the zero will be smallest out of everything.</p>
<p>456<br>00:30:13,859 –&gt; 00:30:16,419<br>Then I’m left with this list.</p>
<p>457<br>00:30:16,419 –&gt; 00:30:17,179<br>It’s still sorted.</p>
<p>458<br>00:30:17,179 –&gt; 00:30:18,819<br>This list is still sorted.</p>
<p>459<br>00:30:18,819 –&gt; 00:30:21,700<br>I look at the first element of each of these lists.</p>
<p>460<br>00:30:21,700 –&gt; 00:30:23,179<br>Which one of these is the smallest?</p>
<p>461<br>00:30:23,179 –&gt; 00:30:25,259<br>Well, the one is smaller than the four.</p>
<p>462<br>00:30:25,259 –&gt; 00:30:28,659<br>So I’m going to take this one and say this one comes next.</p>
<p>463<br>00:30:28,659 –&gt; 00:30:31,379<br>So we’re using the property that these two lists themselves</p>
<p>464<br>00:30:31,379 –&gt; 00:30:32,419<br>are sorted.</p>
<p>465<br>00:30:32,419 –&gt; 00:30:36,339<br>So all I need to do is compare the first element of each list.</p>
<p>466<br>00:30:36,339 –&gt; 00:30:37,859<br>Then I compare the two and the four.</p>
<p>467<br>00:30:37,859 –&gt; 00:30:39,819<br>I say the two is smaller than the four.</p>
<p>468<br>00:30:39,819 –&gt; 00:30:41,939<br>The six and the four, the four goes next.</p>
<p>469<br>00:30:41,939 –&gt; 00:30:45,539<br>The six and the five, the five goes here, six and the eight.</p>
<p>470<br>00:30:45,539 –&gt; 00:30:47,779<br>Six goes here, eight and the 11.</p>
<p>471<br>00:30:47,779 –&gt; 00:30:51,219<br>Well, they’re already in sorted order, so we’re done.</p>
<p>472<br>00:30:51,219 –&gt; 00:30:55,099<br>So that really smart merge step touched every element</p>
<p>473<br>00:30:55,099 –&gt; 00:30:59,619<br>only once to bring it into my master sorted list.</p>
<p>474<br>00:30:59,619 –&gt; 00:31:01,579<br>I didn’t have to do multiple passes.</p>
<p>475<br>00:31:01,579 –&gt; 00:31:05,459<br>I just had to look at the first element of each list.</p>
<p>476<br>00:31:05,460 –&gt; 00:31:09,420<br>So if we can somehow get to this point</p>
<p>477<br>00:31:09,420 –&gt; 00:31:12,380<br>where we have these two sublists that are sorted,</p>
<p>478<br>00:31:12,380 –&gt; 00:31:14,740<br>I can just do a little merge by looking</p>
<p>479<br>00:31:14,740 –&gt; 00:31:17,940<br>at the first element in each of these sorted lists.</p>
<p>480<br>00:31:17,940 –&gt; 00:31:21,460<br>And that basically gives me a theta of n complexity</p>
<p>481<br>00:31:21,460 –&gt; 00:31:24,620<br>to do the merge from two smaller sorted lists</p>
<p>482<br>00:31:24,620 –&gt; 00:31:28,100<br>into one big sorted list.</p>
<p>483<br>00:31:28,100 –&gt; 00:31:30,340<br>So here’s the idea of this merge sorted algorithm.</p>
<p>484<br>00:31:30,340 –&gt; 00:31:33,539<br>We’re going to take an original big unsorted list</p>
<p>485<br>00:31:33,539 –&gt; 00:31:36,259<br>containing n elements.</p>
<p>486<br>00:31:36,259 –&gt; 00:31:37,379<br>It’s unsorted.</p>
<p>487<br>00:31:37,379 –&gt; 00:31:39,500<br>We’re going to divide it in half.</p>
<p>488<br>00:31:39,500 –&gt; 00:31:42,420<br>Of course, these two halves, there’s no order to them,</p>
<p>489<br>00:31:42,420 –&gt; 00:31:45,139<br>so they are potentially very unsorted.</p>
<p>490<br>00:31:45,139 –&gt; 00:31:46,740<br>We’re going to take each one of those halves</p>
<p>491<br>00:31:46,740 –&gt; 00:31:50,619<br>and divide them as well in half, more unsorted sublists.</p>
<p>492<br>00:31:50,619 –&gt; 00:31:54,500<br>Now I’ve got four unsorted sublists of smaller lengths.</p>
<p>493<br>00:31:54,500 –&gt; 00:31:57,420<br>Then I’m going to keep dividing them in half.</p>
<p>494<br>00:31:57,420 –&gt; 00:32:01,180<br>I have now maybe just two elements in each of these unsorted</p>
<p>495<br>00:32:01,180 –&gt; 00:32:02,019<br>lists.</p>
<p>496<br>00:32:02,019 –&gt; 00:32:03,860<br>There’s no guarantee that they’re sorted.</p>
<p>497<br>00:32:03,860 –&gt; 00:32:05,860<br>And then I divided in half once more</p>
<p>498<br>00:32:05,860 –&gt; 00:32:11,100<br>to have a list with one element in each,</p>
<p>499<br>00:32:11,100 –&gt; 00:32:12,100<br>a list with one element.</p>
<p>500<br>00:32:12,100 –&gt; 00:32:13,700<br>Maybe some of these will be empty.</p>
<p>501<br>00:32:16,340 –&gt; 00:32:18,340<br>So then if I can get to this point</p>
<p>502<br>00:32:18,340 –&gt; 00:32:21,900<br>where I just have lists containing one element in each list,</p>
<p>503<br>00:32:21,900 –&gt; 00:32:24,259<br>those lists themselves are sorted, right?</p>
<p>504<br>00:32:24,259 –&gt; 00:32:27,100<br>An element with just a one in it, a list with just a one in it,</p>
<p>505<br>00:32:27,100 –&gt; 00:32:29,660<br>is sorted.</p>
<p>506<br>00:32:29,660 –&gt; 00:32:32,380<br>So then I can begin a merge step, which says,</p>
<p>507<br>00:32:32,380 –&gt; 00:32:36,620<br>hey, these two here, that were originally unsorted,</p>
<p>508<br>00:32:36,620 –&gt; 00:32:39,540<br>let’s just merge the pairs back up.</p>
<p>509<br>00:32:39,540 –&gt; 00:32:44,180<br>And we’ll do that smart merge way.</p>
<p>510<br>00:32:44,180 –&gt; 00:32:47,620<br>So these two will merge back in to give me</p>
<p>511<br>00:32:47,620 –&gt; 00:32:52,460<br>all of these eight sorted lists of length two.</p>
<p>512<br>00:32:52,460 –&gt; 00:32:55,580<br>And then we’re going to merge these pairs back up,</p>
<p>513<br>00:32:55,580 –&gt; 00:32:59,420<br>again using that smart merge way</p>
<p>514<br>00:32:59,420 –&gt; 00:33:03,380<br>to give me four sorted lists.</p>
<p>515<br>00:33:03,380 –&gt; 00:33:07,140<br>And then we’re going to merge these pairs of sorted lists</p>
<p>516<br>00:33:07,140 –&gt; 00:33:09,860<br>to give me bigger sorted lists.</p>
<p>517<br>00:33:09,860 –&gt; 00:33:12,500<br>And finally, we’re going to merge these two sorted lists</p>
<p>518<br>00:33:12,500 –&gt; 00:33:16,940<br>to give me my final master sorted list.</p>
<p>519<br>00:33:16,940 –&gt; 00:33:22,100<br>So let’s do the process of doing the sort.</p>
<p>520<br>00:33:22,100 –&gt; 00:33:23,660<br>Step out of time.</p>
<p>521<br>00:33:23,660 –&gt; 00:33:30,500<br>So we’re going to take our original list, like this.</p>
<p>522<br>00:33:30,500 –&gt; 00:33:34,100<br>I’m actually going to try to do this.</p>
<p>523<br>00:33:34,100 –&gt; 00:33:36,300<br>I’m going to need some room to move them down.</p>
<p>524<br>00:33:36,300 –&gt; 00:33:39,540<br>So this is my original unsorted list.</p>
<p>525<br>00:33:39,540 –&gt; 00:33:41,420<br>Yeah, let’s put this here.</p>
<p>526<br>00:33:41,420 –&gt; 00:33:44,300<br>Something like that.</p>
<p>527<br>00:33:44,300 –&gt; 00:33:46,140<br>So what’s the process going to be?</p>
<p>528<br>00:33:46,140 –&gt; 00:33:50,100<br>Step one is to divide them in half.</p>
<p>529<br>00:33:50,099 –&gt; 00:33:54,539<br>Step two, divide each of these in half.</p>
<p>530<br>00:33:54,539 –&gt; 00:33:57,619<br>Step three, divide each of them in half.</p>
<p>531<br>00:33:57,619 –&gt; 00:34:01,779<br>So now I’ve got a bunch of lists with only one element in it.</p>
<p>532<br>00:34:01,779 –&gt; 00:34:04,059<br>Now I need to merge them back up.</p>
<p>533<br>00:34:04,059 –&gt; 00:34:07,179<br>So merging these two together to give me a list with two</p>
<p>534<br>00:34:07,179 –&gt; 00:34:09,779<br>elements says I’m just going to compare them.</p>
<p>535<br>00:34:09,779 –&gt; 00:34:11,299<br>The one that’s smaller goes first.</p>
<p>536<br>00:34:11,299 –&gt; 00:34:13,779<br>The one that’s bigger goes second.</p>
<p>537<br>00:34:13,779 –&gt; 00:34:15,860<br>Again, these ones compare them.</p>
<p>538<br>00:34:15,860 –&gt; 00:34:17,139<br>The one that’s smaller goes first.</p>
<p>539<br>00:34:17,139 –&gt; 00:34:18,980<br>The one that’s bigger goes second.</p>
<p>540<br>00:34:18,980 –&gt; 00:34:21,340<br>Again, compare them.</p>
<p>541<br>00:34:21,340 –&gt; 00:34:23,059<br>Again, compare them.</p>
<p>542<br>00:34:23,059 –&gt; 00:34:27,619<br>So now I’ve done one merge where I have four lists that</p>
<p>543<br>00:34:27,619 –&gt; 00:34:31,099<br>are sorted by themselves.</p>
<p>544<br>00:34:31,099 –&gt; 00:34:33,860<br>So now I’m going to merge these two together and these two</p>
<p>545<br>00:34:33,860 –&gt; 00:34:35,980<br>together.</p>
<p>546<br>00:34:35,980 –&gt; 00:34:38,500<br>So I’m only looking at the first element of each.</p>
<p>547<br>00:34:38,500 –&gt; 00:34:40,019<br>So I compare the zero and the two.</p>
<p>548<br>00:34:40,019 –&gt; 00:34:43,380<br>And I know the zero is smaller than the two.</p>
<p>549<br>00:34:43,380 –&gt; 00:34:46,340<br>Then the two and the eight, the two is smaller.</p>
<p>550<br>00:34:46,340 –&gt; 00:34:49,100<br>Then the eight and the 11 and then the 11.</p>
<p>551<br>00:34:49,100 –&gt; 00:34:53,420<br>So now this list is now sorted by itself.</p>
<p>552<br>00:34:53,420 –&gt; 00:34:54,500<br>Same process here.</p>
<p>553<br>00:34:54,500 –&gt; 00:34:56,980<br>Compare only the first element of each list.</p>
<p>554<br>00:34:56,980 –&gt; 00:34:58,460<br>The one comes first.</p>
<p>555<br>00:34:58,460 –&gt; 00:35:00,300<br>Then the four comes next.</p>
<p>556<br>00:35:00,300 –&gt; 00:35:02,100<br>Then the five comes next.</p>
<p>557<br>00:35:02,100 –&gt; 00:35:04,380<br>And then the six.</p>
<p>558<br>00:35:04,380 –&gt; 00:35:08,100<br>So now I’ve reached the exact same spot I was at when I was</p>
<p>559<br>00:35:08,100 –&gt; 00:35:09,620<br>talking about the merge step, right?</p>
<p>560<br>00:35:09,620 –&gt; 00:35:13,220<br>When I showed you that we could get to that spot.</p>
<p>561<br>00:35:13,220 –&gt; 00:35:16,180<br>So I’ve got these two lists that are themselves sorted</p>
<p>562<br>00:35:16,179 –&gt; 00:35:16,679<br>to merge.</p>
<p>563<br>00:35:16,679 –&gt; 00:35:19,299<br>So all I need to do is look at the first element in each list.</p>
<p>564<br>00:35:19,299 –&gt; 00:35:21,579<br>So there’s my zero goes first.</p>
<p>565<br>00:35:21,579 –&gt; 00:35:23,659<br>One compared with the two, the one goes next.</p>
<p>566<br>00:35:23,659 –&gt; 00:35:25,859<br>Two compared with the four, the two goes next.</p>
<p>567<br>00:35:25,859 –&gt; 00:35:28,019<br>Four compared with the eight, the four goes next.</p>
<p>568<br>00:35:28,019 –&gt; 00:35:30,179<br>Five compared with the eight, the five goes next.</p>
<p>569<br>00:35:30,179 –&gt; 00:35:32,859<br>Six compared with the eight, the six goes next.</p>
<p>570<br>00:35:32,859 –&gt; 00:35:35,619<br>And I’ve removed all the elements in this list.</p>
<p>571<br>00:35:35,619 –&gt; 00:35:38,099<br>So I know I just need to grab whatever’s left in here</p>
<p>572<br>00:35:38,099 –&gt; 00:35:40,339<br>and whatever order it’s there because everything’s already</p>
<p>573<br>00:35:40,339 –&gt; 00:35:42,419<br>sorted.</p>
<p>574<br>00:35:42,419 –&gt; 00:35:43,779<br>OK.</p>
<p>575<br>00:35:43,780 –&gt; 00:35:47,740<br>So that’s the entire merge sort algorithm.</p>
<p>576<br>00:35:47,740 –&gt; 00:35:50,500<br>Now if I do this demo, this is actually</p>
<p>577<br>00:35:50,500 –&gt; 00:35:53,700<br>going to show you the exact steps that the recursive algorithm</p>
<p>578<br>00:35:53,700 –&gt; 00:35:54,740<br>is doing.</p>
<p>579<br>00:35:54,740 –&gt; 00:35:56,820<br>And it’s not going to be sort of in the same order</p>
<p>580<br>00:35:56,820 –&gt; 00:35:57,580<br>that I showed you.</p>
<p>581<br>00:35:57,580 –&gt; 00:36:02,100<br>It’s not going to be dividing this in half and then dividing</p>
<p>582<br>00:36:02,100 –&gt; 00:36:03,660<br>in half and so on.</p>
<p>583<br>00:36:03,660 –&gt; 00:36:07,060<br>Because when we’re doing the recursion,</p>
<p>584<br>00:36:07,060 –&gt; 00:36:12,540<br>first we’re going to figure out how to sort a left sublist.</p>
<p>585<br>00:36:12,539 –&gt; 00:36:15,259<br>So if I have my original unsorted list here,</p>
<p>586<br>00:36:15,259 –&gt; 00:36:18,980<br>we’re going to figure out how to sort a left sublist first.</p>
<p>587<br>00:36:18,980 –&gt; 00:36:21,980<br>That’s a recursive step that we haven’t reached the base</p>
<p>588<br>00:36:21,980 –&gt; 00:36:22,980<br>case for yet.</p>
<p>589<br>00:36:22,980 –&gt; 00:36:24,619<br>We still have to sort this list.</p>
<p>590<br>00:36:24,619 –&gt; 00:36:29,179<br>So we’re going to try to sort the left sublist of this one.</p>
<p>591<br>00:36:29,179 –&gt; 00:36:31,420<br>And then we’re going to try to sort the left sublist of this one.</p>
<p>592<br>00:36:31,420 –&gt; 00:36:35,179<br>So we’re going to do something that feels really similar</p>
<p>593<br>00:36:35,179 –&gt; 00:36:38,300<br>to the Fibonacci sequence.</p>
<p>594<br>00:36:38,300 –&gt; 00:36:39,539<br>Yes, Fibonacci.</p>
<p>595<br>00:36:39,539 –&gt; 00:36:42,139<br>Fibonacci of n is Fibonacci of n minus 1.</p>
<p>596<br>00:36:42,139 –&gt; 00:36:44,779<br>Plus Fibonacci of n minus 2.</p>
<p>597<br>00:36:44,779 –&gt; 00:36:46,819<br>In that particular case, when we were</p>
<p>598<br>00:36:46,819 –&gt; 00:36:50,259<br>trying to find Fibonacci of 6 or something like that,</p>
<p>599<br>00:36:50,259 –&gt; 00:36:54,259<br>we were going and exploring the left side</p>
<p>600<br>00:36:54,259 –&gt; 00:36:57,779<br>until we reached a base case.</p>
<p>601<br>00:36:57,779 –&gt; 00:36:59,699<br>And only once we reached a base case</p>
<p>602<br>00:36:59,699 –&gt; 00:37:02,699<br>could we pop up and do the other half.</p>
<p>603<br>00:37:02,699 –&gt; 00:37:05,699<br>And so this algorithm is going to feel very similar to that.</p>
<p>604<br>00:37:05,699 –&gt; 00:37:07,619<br>So here’s our my original list.</p>
<p>605<br>00:37:07,619 –&gt; 00:37:09,659<br>I’m splitting the left hand side to try</p>
<p>606<br>00:37:09,659 –&gt; 00:37:15,299<br>to figure out how to merge all the way to the left lists.</p>
<p>607<br>00:37:15,299 –&gt; 00:37:16,940<br>So the 8 and the 4 will be compared,</p>
<p>608<br>00:37:16,940 –&gt; 00:37:19,219<br>and the 4 goes before the 8.</p>
<p>609<br>00:37:19,219 –&gt; 00:37:23,739<br>And then I’m going to merge the 1 and the 6 by themselves.</p>
<p>610<br>00:37:23,739 –&gt; 00:37:26,299<br>Those are already sorted, as we know.</p>
<p>611<br>00:37:26,299 –&gt; 00:37:28,779<br>Then we’re going to merge the 4 and the 8 back</p>
<p>612<br>00:37:28,779 –&gt; 00:37:31,420<br>with the 1 and the 6 using that merge step.</p>
<p>613<br>00:37:31,420 –&gt; 00:37:35,579<br>And then we’re going to do the same thing to that right hand side,</p>
<p>614<br>00:37:35,579 –&gt; 00:37:36,980<br>one at a time.</p>
<p>615<br>00:37:36,980 –&gt; 00:37:42,019<br>We’ll do another example where we go step by step through.</p>
<p>616<br>00:37:42,019 –&gt; 00:37:44,699<br>And now we’ve got our two 4 elements together.</p>
<p>617<br>00:37:44,699 –&gt; 00:37:46,619<br>So now we’re just doing our final merge step</p>
<p>618<br>00:37:46,619 –&gt; 00:37:52,940<br>where we decide which one belongs next.</p>
<p>619<br>00:37:52,940 –&gt; 00:37:56,420<br>So let’s look at the merge code.</p>
<p>620<br>00:37:56,420 –&gt; 00:37:58,420<br>And this is not yet.</p>
<p>621<br>00:37:58,420 –&gt; 00:37:59,179<br>So sorry.</p>
<p>622<br>00:37:59,179 –&gt; 00:38:01,500<br>Let’s look at the merge step once more.</p>
<p>623<br>00:38:01,500 –&gt; 00:38:04,820<br>So if I have two lists that I’m trying to merge,</p>
<p>624<br>00:38:04,820 –&gt; 00:38:08,059<br>the idea was that you look at the first element of each.</p>
<p>625<br>00:38:08,059 –&gt; 00:38:11,460<br>So first, the 1 and the 2 compared means the 1 is smaller.</p>
<p>626<br>00:38:11,460 –&gt; 00:38:13,420<br>So it goes into my result.</p>
<p>627<br>00:38:13,420 –&gt; 00:38:15,140<br>The 5 and the 2 gets compared.</p>
<p>628<br>00:38:15,140 –&gt; 00:38:16,580<br>The 2 is smaller.</p>
<p>629<br>00:38:16,580 –&gt; 00:38:18,780<br>So the 2 goes into the result.</p>
<p>630<br>00:38:18,780 –&gt; 00:38:20,580<br>The 5 and the 3 gets compared.</p>
<p>631<br>00:38:20,580 –&gt; 00:38:21,660<br>The 3 is smaller.</p>
<p>632<br>00:38:21,660 –&gt; 00:38:23,500<br>So the 3 goes in the result.</p>
<p>633<br>00:38:23,500 –&gt; 00:38:24,700<br>And so on and so on.</p>
<p>634<br>00:38:24,700 –&gt; 00:38:26,820<br>So we keep doing this process where we just</p>
<p>635<br>00:38:26,820 –&gt; 00:38:29,220<br>keep looking at the first element.</p>
<p>636<br>00:38:29,220 –&gt; 00:38:33,740<br>Until we have one of the lists become empty.</p>
<p>637<br>00:38:33,739 –&gt; 00:38:35,019<br>So this is my left sublist.</p>
<p>638<br>00:38:35,019 –&gt; 00:38:36,939<br>This is my right sublist.</p>
<p>639<br>00:38:36,939 –&gt; 00:38:38,979<br>When one of these lists becomes empty,</p>
<p>640<br>00:38:38,979 –&gt; 00:38:42,779<br>I no longer need to compare 18 with nothing.</p>
<p>641<br>00:38:42,779 –&gt; 00:38:45,139<br>All I need to do is grab all these elements</p>
<p>642<br>00:38:45,139 –&gt; 00:38:48,939<br>and stick them through at the end.</p>
<p>643<br>00:38:48,939 –&gt; 00:38:52,139<br>So let’s look at the code for just the merge step.</p>
<p>644<br>00:38:52,139 –&gt; 00:38:55,339<br>We don’t need to look at the code for the full algorithm yet.</p>
<p>645<br>00:38:55,339 –&gt; 00:38:59,659<br>But the merge step code is just the part that takes us</p>
<p>646<br>00:38:59,659 –&gt; 00:39:04,819<br>from two sorted lists into one bigger sorted list.</p>
<p>647<br>00:39:04,819 –&gt; 00:39:09,779<br>So it does that step in one.</p>
<p>648<br>00:39:09,779 –&gt; 00:39:12,460<br>This is where the main event happens.</p>
<p>649<br>00:39:12,460 –&gt; 00:39:15,420<br>So this is just going to use indices</p>
<p>650<br>00:39:15,420 –&gt; 00:39:19,699<br>to compare which element we need to grab next.</p>
<p>651<br>00:39:19,699 –&gt; 00:39:26,059<br>So if I have something like this, like that,</p>
<p>652<br>00:39:26,059 –&gt; 00:39:29,339<br>then I’m not actually going to make a copy of a list</p>
<p>653<br>00:39:30,059 –&gt; 00:39:33,059<br>or do any sort of funky stuff with list copying</p>
<p>654<br>00:39:33,059 –&gt; 00:39:35,220<br>because that’ll increase the complexity.</p>
<p>655<br>00:39:35,220 –&gt; 00:39:39,860<br>But we are going to do that trick where we use an integer index</p>
<p>656<br>00:39:39,860 –&gt; 00:39:45,140<br>to decide which element we’re going to grab next.</p>
<p>657<br>00:39:45,140 –&gt; 00:39:47,620<br>So that’s what this i and j is for.</p>
<p>658<br>00:39:47,620 –&gt; 00:39:53,340<br>We’ve got i is going to be the index from my left sublist.</p>
<p>659<br>00:39:53,340 –&gt; 00:39:57,140<br>And j will be the index for my right sublist.</p>
<p>660<br>00:39:57,139 –&gt; 00:39:59,420<br>And all it does is it says while I still</p>
<p>661<br>00:39:59,420 –&gt; 00:40:01,779<br>have elements in both of these lists,</p>
<p>662<br>00:40:01,779 –&gt; 00:40:05,059<br>just take the pointer and say which one of the elements</p>
<p>663<br>00:40:05,059 –&gt; 00:40:07,699<br>at these two pointers i and j are smaller.</p>
<p>664<br>00:40:07,699 –&gt; 00:40:09,259<br>So if the zero is smaller, I’m going</p>
<p>665<br>00:40:09,259 –&gt; 00:40:12,940<br>to create a new list here that’s going to have the zero in it.</p>
<p>666<br>00:40:12,940 –&gt; 00:40:15,980<br>I’m not actually taking this element and moving it here.</p>
<p>667<br>00:40:15,980 –&gt; 00:40:19,659<br>All I will do next is say the pointer that tells me which element</p>
<p>668<br>00:40:19,659 –&gt; 00:40:22,460<br>I should be looking at next moves over one.</p>
<p>669<br>00:40:22,460 –&gt; 00:40:24,819<br>So this list remains unchanged.</p>
<p>670<br>00:40:24,820 –&gt; 00:40:27,539<br>Then I’m going to compare the two with the one that one</p>
<p>671<br>00:40:27,539 –&gt; 00:40:28,059<br>comes next.</p>
<p>672<br>00:40:28,059 –&gt; 00:40:31,019<br>So I’m going to take the one and put it in my list here.</p>
<p>673<br>00:40:31,019 –&gt; 00:40:34,460<br>And this pointer moves here to the next element.</p>
<p>674<br>00:40:34,460 –&gt; 00:40:37,460<br>So now while this list stays as is,</p>
<p>675<br>00:40:37,460 –&gt; 00:40:39,660<br>I’m looking at the element at this pointer</p>
<p>676<br>00:40:39,660 –&gt; 00:40:41,620<br>and comparing it with the element at this pointer.</p>
<p>677<br>00:40:41,620 –&gt; 00:40:45,059<br>So then the two comes next and this pointer increments by one.</p>
<p>678<br>00:40:48,300 –&gt; 00:40:49,500<br>So that’s what that code does.</p>
<p>679<br>00:40:49,500 –&gt; 00:40:53,019<br>These two while loops just deal with the case</p>
<p>680<br>00:40:53,019 –&gt; 00:40:57,820<br>when we have one list that has finished inserting its elements.</p>
<p>681<br>00:40:57,820 –&gt; 00:41:00,860<br>So like in this particular case here, when my right sublist</p>
<p>682<br>00:41:00,860 –&gt; 00:41:03,139<br>became empty, we’ve already put on all the elements</p>
<p>683<br>00:41:03,139 –&gt; 00:41:05,420<br>in it into our master list.</p>
<p>684<br>00:41:05,420 –&gt; 00:41:08,460<br>Then all we need to do is take everything that’s left over</p>
<p>685<br>00:41:08,460 –&gt; 00:41:10,619<br>and copy them into my master list.</p>
<p>686<br>00:41:10,619 –&gt; 00:41:13,659<br>And that’s what these two while loops are doing.</p>
<p>687<br>00:41:16,659 –&gt; 00:41:18,940<br>So the complexity of this merge store,</p>
<p>688<br>00:41:18,940 –&gt; 00:41:22,940<br>so that’s just what it’s doing.</p>
<p>689<br>00:41:23,099 –&gt; 00:41:25,579<br>So it’s just doing one pass.</p>
<p>690<br>00:41:25,579 –&gt; 00:41:27,179<br>It’s not doing multiple passes.</p>
<p>691<br>00:41:27,179 –&gt; 00:41:29,380<br>So we just look at each element once.</p>
<p>692<br>00:41:29,380 –&gt; 00:41:32,980<br>So the complexity of this merge sort, not the sort,</p>
<p>693<br>00:41:32,980 –&gt; 00:41:37,260<br>just the merge step is theta of length of the list.</p>
<p>694<br>00:41:37,260 –&gt; 00:41:41,460<br>Because we’re just looking at all of these elements once.</p>
<p>695<br>00:41:41,460 –&gt; 00:41:44,139<br>Now what about the actual algorithm?</p>
<p>696<br>00:41:44,139 –&gt; 00:41:48,619<br>So here I’ve got the merge function down here.</p>
<p>697<br>00:41:48,619 –&gt; 00:41:50,980<br>It’s going to take a left list and a right list.</p>
<p>698<br>00:41:50,980 –&gt; 00:41:53,019<br>And it’s going to do that step that we just did</p>
<p>699<br>00:41:53,019 –&gt; 00:41:55,659<br>where you look at the smallest element in each.</p>
<p>700<br>00:41:55,659 –&gt; 00:41:56,659<br>What about the rest of it?</p>
<p>701<br>00:41:56,659 –&gt; 00:42:00,179<br>Well, the rest of it is just recursion.</p>
<p>702<br>00:42:00,179 –&gt; 00:42:02,579<br>My base case is when I have a list that’s empty</p>
<p>703<br>00:42:02,579 –&gt; 00:42:04,740<br>or a list with one element in it.</p>
<p>704<br>00:42:04,740 –&gt; 00:42:06,380<br>Then I just grab that list.</p>
<p>705<br>00:42:06,380 –&gt; 00:42:08,260<br>That’s my merge.</p>
<p>706<br>00:42:11,260 –&gt; 00:42:13,579<br>And else what we’re going to do is we’re</p>
<p>707<br>00:42:13,579 –&gt; 00:42:16,780<br>going to do the step where we divide the list in half.</p>
<p>708<br>00:42:16,780 –&gt; 00:42:19,980<br>So we’re doing integer division from the length of the list</p>
<p>709<br>00:42:19,980 –&gt; 00:42:23,780<br>because we don’t want the middle to be 7.5, for example.</p>
<p>710<br>00:42:23,780 –&gt; 00:42:26,500<br>So we’re going to grab some integer index.</p>
<p>711<br>00:42:26,500 –&gt; 00:42:29,940<br>And then we’re going to say I’m going to, again,</p>
<p>712<br>00:42:29,940 –&gt; 00:42:31,940<br>there’s a lot of faith involved in recursion.</p>
<p>713<br>00:42:31,940 –&gt; 00:42:34,780<br>I’m going to say the left sublist.</p>
<p>714<br>00:42:34,780 –&gt; 00:42:40,019<br>So this one here, if my algorithm somehow works correctly,</p>
<p>715<br>00:42:40,019 –&gt; 00:42:42,300<br>will now be a sorted list.</p>
<p>716<br>00:42:43,220 –&gt; 00:42:48,460<br>And then my right over here, right equals this thing here,</p>
<p>717<br>00:42:48,460 –&gt; 00:42:50,820<br>will also somehow be a sorted list.</p>
<p>718<br>00:42:50,820 –&gt; 00:42:53,620<br>So this is me putting faith in my algorithm</p>
<p>719<br>00:42:53,620 –&gt; 00:42:56,060<br>that I can get a sorted list, right?</p>
<p>720<br>00:42:56,060 –&gt; 00:42:58,260<br>From the index 0 all the way up to the midpoint</p>
<p>721<br>00:42:58,260 –&gt; 00:43:01,100<br>and the midpoint all the way up to the end of the list.</p>
<p>722<br>00:43:01,100 –&gt; 00:43:04,460<br>So if somehow I can get a left sublist that’s sorted by itself</p>
<p>723<br>00:43:04,460 –&gt; 00:43:06,860<br>and a right sublist that’s sorted by itself,</p>
<p>724<br>00:43:06,860 –&gt; 00:43:09,300<br>all I need to do to get this sorted list</p>
<p>725<br>00:43:09,300 –&gt; 00:43:10,300<br>is to merge them.</p>
<p>726<br>00:43:10,300 –&gt; 00:43:13,300<br>So that’s what the merge function is to.</p>
<p>727<br>00:43:13,300 –&gt; 00:43:18,300<br>Okay, so let’s step through.</p>
<p>728<br>00:43:18,300 –&gt; 00:43:21,300<br>So I’ve got my original list here.</p>
<p>729<br>00:43:21,300 –&gt; 00:43:24,300<br>And this is where we’re going to be thinking about</p>
<p>730<br>00:43:24,300 –&gt; 00:43:27,300<br>how we kind of step through Fibonacci.</p>
<p>731<br>00:43:27,300 –&gt; 00:43:29,300<br>Here’s my original list.</p>
<p>732<br>00:43:29,300 –&gt; 00:43:34,300<br>The first step is to figure out the left part.</p>
<p>733<br>00:43:34,300 –&gt; 00:43:36,300<br>So we’re going to do this here.</p>
<p>734<br>00:43:36,300 –&gt; 00:43:39,300<br>I need to figure out the left part.</p>
<p>735<br>00:43:39,300 –&gt; 00:43:41,300<br>So we’re going to divide it in half.</p>
<p>736<br>00:43:41,300 –&gt; 00:43:45,300<br>And it says I need to figure out the sorted version of 8 4 1 6.</p>
<p>737<br>00:43:45,300 –&gt; 00:43:47,300<br>But it’s not my base case.</p>
<p>738<br>00:43:47,300 –&gt; 00:43:50,300<br>So I need to figure out the sorted version of the left part of that.</p>
<p>739<br>00:43:50,300 –&gt; 00:43:51,300<br>The 8 4.</p>
<p>740<br>00:43:51,300 –&gt; 00:43:53,300<br>Again, it’s not my base case.</p>
<p>741<br>00:43:53,300 –&gt; 00:43:55,300<br>So I need to figure out the sorted version of the left,</p>
<p>742<br>00:43:55,300 –&gt; 00:43:56,300<br>just the 8.</p>
<p>743<br>00:43:56,300 –&gt; 00:43:58,300<br>It’s single by itself.</p>
<p>744<br>00:43:58,300 –&gt; 00:44:00,300<br>So that’s just going to be the 8.</p>
<p>745<br>00:44:00,300 –&gt; 00:44:02,300<br>Then we can figure out the right half of it.</p>
<p>746<br>00:44:02,300 –&gt; 00:44:05,300<br>It’s 4 by itself and we merge them.</p>
<p>747<br>00:44:05,300 –&gt; 00:44:08,300<br>Then we can figure out the right half of this one here.</p>
<p>748<br>00:44:08,300 –&gt; 00:44:09,300<br>8 4 1 6.</p>
<p>749<br>00:44:09,300 –&gt; 00:44:13,300<br>So we need to figure out what’s the sorted version of 1 6.</p>
<p>750<br>00:44:13,300 –&gt; 00:44:15,300<br>Well, as humans, we know it’s already sorted.</p>
<p>751<br>00:44:15,300 –&gt; 00:44:17,300<br>But the algorithm goes through.</p>
<p>752<br>00:44:17,300 –&gt; 00:44:18,300<br>Looks at the left side.</p>
<p>753<br>00:44:18,300 –&gt; 00:44:19,300<br>Looks at the right side.</p>
<p>754<br>00:44:19,300 –&gt; 00:44:20,300<br>Merges them up.</p>
<p>755<br>00:44:20,300 –&gt; 00:44:24,300<br>Now we merge the 4 8 1 6 according to the Lume merge step</p>
<p>756<br>00:44:24,300 –&gt; 00:44:26,300<br>to give us 1 4 6 8.</p>
<p>757<br>00:44:26,300 –&gt; 00:44:32,300<br>And at this point, we’ve finished just the left half of 8 4 1 6 5 9 2 0.</p>
<p>758<br>00:44:32,300 –&gt; 00:44:34,300<br>And now we need to do the right half.</p>
<p>759<br>00:44:34,300 –&gt; 00:44:41,300<br>So we do the whole process all over again by taking that 5 9 2 0 looking only at the left piece.</p>
<p>760<br>00:44:41,300 –&gt; 00:44:43,300<br>Then the left piece of that.</p>
<p>761<br>00:44:43,300 –&gt; 00:44:47,300<br>Then the right piece of that base case merging them back up.</p>
<p>762<br>00:44:47,300 –&gt; 00:44:49,300<br>The right step.</p>
<p>763<br>00:44:49,300 –&gt; 00:44:51,300<br>The left part of that right step.</p>
<p>764<br>00:44:51,300 –&gt; 00:44:55,300<br>The right part of that right step merging them back up.</p>
<p>765<br>00:44:55,300 –&gt; 00:44:58,300<br>So then we do the merge step of 5 9 and 0 2.</p>
<p>766<br>00:44:58,300 –&gt; 00:45:01,300<br>And then the merge step of these two lists.</p>
<p>767<br>00:45:01,300 –&gt; 00:45:04,300<br>1 4 6 8 and 0 2 5 9.</p>
<p>768<br>00:45:04,300 –&gt; 00:45:09,300<br>So you can see it has a similar feel to exploring one side of the branch first,</p>
<p>769<br>00:45:09,300 –&gt; 00:45:11,300<br>just like with Fibonacci for the exact same reason.</p>
<p>770<br>00:45:11,300 –&gt; 00:45:14,300<br>Because we’ve got a function called that’s recursive.</p>
<p>771<br>00:45:14,300 –&gt; 00:45:18,300<br>We can’t complete it until we’ve explored all the way down to the bottom.</p>
<p>772<br>00:45:18,300 –&gt; 00:45:24,300<br>So the overall complexity of this is going to be the merge step itself is theta of n.</p>
<p>773<br>00:45:24,300 –&gt; 00:45:26,300<br>Like we just talked about.</p>
<p>774<br>00:45:26,300 –&gt; 00:45:28,300<br>But how many levels do we have?</p>
<p>775<br>00:45:28,300 –&gt; 00:45:35,300<br>That is how many times do we take our original list and subdivide it until we get to our base case?</p>
<p>776<br>00:45:35,300 –&gt; 00:45:41,300<br>And the number of times is according to this function very much like when we did by section search.</p>
<p>777<br>00:45:41,300 –&gt; 00:45:44,300<br>We’re going to take an original n elements in my list.</p>
<p>778<br>00:45:44,300 –&gt; 00:45:50,300<br>And I’m going to keep dividing this n elements by 2 in a bunch of sub lists i times.</p>
<p>779<br>00:45:50,300 –&gt; 00:45:56,300<br>So i times is how many times we’re going to subdivide this list until we get to a base case.</p>
<p>780<br>00:45:56,300 –&gt; 00:46:01,300<br>So what is i in terms of n? Well i is equal to log of n.</p>
<p>781<br>00:46:01,300 –&gt; 00:46:05,300<br>So at each merge step.</p>
<p>782<br>00:46:05,300 –&gt; 00:46:08,300<br>Sorry. So at each sub level, I’ve got a merge step.</p>
<p>783<br>00:46:08,300 –&gt; 00:46:16,300<br>So I’ve got theta of log of n levels multiplied by theta of n for my merge step.</p>
<p>784<br>00:46:16,300 –&gt; 00:46:24,300<br>So the overall complexity of this function is theta of n log n, where n is the length of the list.</p>
<p>785<br>00:46:24,300 –&gt; 00:46:31,300<br>Okay. So it turns out that theta of n log n is actually the fastest we can have a sort b.</p>
<p>786<br>00:46:31,300 –&gt; 00:46:35,300<br>You cannot do a sorting algorithm that’s faster than that.</p>
<p>787<br>00:46:35,300 –&gt; 00:46:38,300<br>You can do little tricks here and there based on your data.</p>
<p>788<br>00:46:38,300 –&gt; 00:46:46,300<br>Maybe you don’t divide the list exactly in half. Maybe you divide it and you find some sort of pivot point that’s a little bit smarter about the data.</p>
<p>789<br>00:46:46,300 –&gt; 00:46:56,300<br>But in general, the complexity of this function of the sorting algorithm is always going to be the fastest it’s going to be as theta of n log n.</p>
<p>790<br>00:46:56,300 –&gt; 00:46:57,300<br>Okay.</p>
<p>791<br>00:46:57,300 –&gt; 00:46:59,300<br>All right.</p>
<p>792<br>00:46:59,300 –&gt; 00:47:06,300<br>We’ve seen a bunch of different algorithms here to help us design programs.</p>
<p>793<br>00:47:06,300 –&gt; 00:47:11,300<br>So the reason why we do this complexity analysis is to guide the design of a program.</p>
<p>794<br>00:47:11,300 –&gt; 00:47:19,300<br>So if you already have a bunch of nested for loops in the program that you’re trying to consider writing, you’ll already know it’s going to be pretty inefficient and slow.</p>
<p>795<br>00:47:19,300 –&gt; 00:47:23,300<br>So you might want to rethink the design to begin.</p>
<p>796<br>00:47:23,300 –&gt; 00:47:24,300<br>Okay.</p>
<p>797<br>00:47:24,300 –&gt; 00:47:25,300<br>All right.</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>MIT6100 P24P24SortingAlgorithms</div>
      <div>http://example.com/2025/10/25/MIT6100 P24P24SortingAlgorithms/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/25/MIT6100%20P2P02StringsInputOutputandBranching/" title="MIT6100 P2P02StringsInputOutputandBranching">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">MIT6100 P2P02StringsInputOutputandBranching</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/25/MIT6100%20P25P25Plotting/" title="MIT6100 P25P25Plotting">
                        <span class="hidden-mobile">MIT6100 P25P25Plotting</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
