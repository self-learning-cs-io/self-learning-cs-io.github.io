

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="100:00:00,000 –&gt; 00:00:07,000Okay, so the topic for today is threats and RPC, 200:00:07,000 –&gt; 00:00:11,000sort of second lecture in 1624. 300:00:11,000 –&gt; 00:00:15,000And we’re going to most">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT6824 P2Lecture2RPCandThreads">
<meta property="og:url" content="http://example.com/2025/10/25/MIT6824%20P2Lecture2RPCandThreads/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="100:00:00,000 –&gt; 00:00:07,000Okay, so the topic for today is threats and RPC, 200:00:07,000 –&gt; 00:00:11,000sort of second lecture in 1624. 300:00:11,000 –&gt; 00:00:15,000And we’re going to most">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-25T05:03:39.806Z">
<meta property="article:modified_time" content="2025-10-25T05:03:39.806Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>MIT6824 P2Lecture2RPCandThreads - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="MIT6824 P2Lecture2RPCandThreads"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-25 13:03" pubdate>
          2025年10月25日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          7k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          59 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">MIT6824 P2Lecture2RPCandThreads</h1>
            
            
              <div class="markdown-body">
                
                <p>1<br>00:00:00,000 –&gt; 00:00:07,000<br>Okay, so the topic for today is threats and RPC,</p>
<p>2<br>00:00:07,000 –&gt; 00:00:11,000<br>sort of second lecture in 1624.</p>
<p>3<br>00:00:11,000 –&gt; 00:00:15,000<br>And we’re going to mostly look at threats and RPC in the context of GO,</p>
<p>4<br>00:00:15,000 –&gt; 00:00:18,000<br>the programming language that we’re using in the labs.</p>
<p>5<br>00:00:18,000 –&gt; 00:00:22,000<br>And in fact, most of this lecture is really tailored to work,</p>
<p>6<br>00:00:22,000 –&gt; 00:00:27,000<br>helping you do GO programming for the labs.</p>
<p>7<br>00:00:28,000 –&gt; 00:00:33,000<br>So all you’ve done hopefully the tutorial and the crawler exercise,</p>
<p>8<br>00:00:33,000 –&gt; 00:00:37,000<br>which we’ll discuss in quite a bit of detail later in the lecture.</p>
<p>9<br>00:00:37,000 –&gt; 00:00:45,000<br>But before jumping into the details, let me do a little bit more of cold calling to break the ice and let get people to ask questions.</p>
<p>10<br>00:00:45,000 –&gt; 00:00:50,000<br>So maybe you can answer the question, you know, where are you and how do you enjoy the tutorial?</p>
<p>11<br>00:00:50,000 –&gt; 00:00:53,000<br>What is your first impression of GO?</p>
<p>12<br>00:00:54,000 –&gt; 00:00:59,000<br>Maybe all how about even Zeldin?</p>
<p>13<br>00:00:59,000 –&gt; 00:01:07,000<br>Hi folks, I’m Batman. I’m in Newton, which is on the outskirts of Greater Boston.</p>
<p>14<br>00:01:07,000 –&gt; 00:01:13,000<br>Turtle was interesting. It was my first exposure to, you know, a non object oriented language.</p>
<p>15<br>00:01:13,000 –&gt; 00:01:19,000<br>So it’s kind of a change, a change in framework that was interesting to adapt to.</p>
<p>16<br>00:01:19,000 –&gt; 00:01:22,000<br>How about Brendan?</p>
<p>17<br>00:01:28,000 –&gt; 00:01:30,000<br>Brendan, are you there?</p>
<p>18<br>00:01:30,000 –&gt; 00:01:32,000<br>Yeah, sorry, I was just finding the mute buttons.</p>
<p>19<br>00:01:32,000 –&gt; 00:01:34,000<br>Sorry, what was the question I just joined?</p>
<p>20<br>00:01:34,000 –&gt; 00:01:37,000<br>Oh, where are you in there? What is your first impression of GO?</p>
<p>21<br>00:01:37,000 –&gt; 00:01:41,000<br>Yeah, it’s, I had used GO before for an internship,</p>
<p>22<br>00:01:41,000 –&gt; 00:01:44,000<br>but it was my first time actually dealing with the concurrency stuff.</p>
<p>23<br>00:01:44,000 –&gt; 00:01:46,000<br>I was like really working with GO routines.</p>
<p>24<br>00:01:46,000 –&gt; 00:01:50,000<br>So kind of initially it was like tricky to think through like,</p>
<p>25<br>00:01:50,000 –&gt; 00:01:54,000<br>like as soon as the main thread ends, all the GO routines are ended.</p>
<p>26<br>00:01:54,000 –&gt; 00:01:57,000<br>So kind of working through those early kind of conceptual issues,</p>
<p>27<br>00:01:57,000 –&gt; 00:02:00,000<br>but it’s interesting to kind of think through.</p>
<p>28<br>00:02:00,000 –&gt; 00:02:03,000<br>How about the Connor crispy?</p>
<p>29<br>00:02:03,000 –&gt; 00:02:13,000<br>Connor, are you there?</p>
<p>30<br>00:02:13,000 –&gt; 00:02:19,000<br>Yeah, try somebody else.</p>
<p>31<br>00:02:19,000 –&gt; 00:02:27,000<br>Dory Shen.</p>
<p>32<br>00:02:27,000 –&gt; 00:02:33,000<br>Hi, I’m in Cambridge right now, and I found GO to be really pretty interesting.</p>
<p>33<br>00:02:33,000 –&gt; 00:02:36,000<br>I thought through like the first part of the tutorial,</p>
<p>34<br>00:02:36,000 –&gt; 00:02:39,000<br>I like learning about the four loops and the ways they do for loops.</p>
<p>35<br>00:02:39,000 –&gt; 00:02:43,000<br>I thought that was pretty interesting and like the way it’s kind of structured.</p>
<p>36<br>00:02:43,000 –&gt; 00:02:47,000<br>I think the, I like the threads.</p>
<p>37<br>00:02:47,000 –&gt; 00:02:52,000<br>I found to be a little bit like more difficult about like when it ended and like when.</p>
<p>38<br>00:02:52,000 –&gt; 00:02:57,000<br>Like sometimes like the function went and before all the routines like end is so that was like.</p>
<p>39<br>00:02:57,000 –&gt; 00:03:00,000<br>Interesting to think about and like I learned more about that.</p>
<p>40<br>00:03:00,000 –&gt; 00:03:02,000<br>So it’s pretty cool. I liked it.</p>
<p>41<br>00:03:02,000 –&gt; 00:03:07,000<br>Well, I hope all of you are going to have a very positive experience with GO.</p>
<p>42<br>00:03:07,000 –&gt; 00:03:10,000<br>In the semester.</p>
<p>43<br>00:03:10,000 –&gt; 00:03:15,000<br>And so let me say a little bit like, you know, why go.</p>
<p>44<br>00:03:15,000 –&gt; 00:03:21,000<br>In principle, you know, there are a lot of programming languages that you could have used there for doing distributed programming and goes absolutely not the only one.</p>
<p>45<br>00:03:21,000 –&gt; 00:03:26,000<br>But some reasons why we, why we chose go in a to four.</p>
<p>46<br>00:03:26,000 –&gt; 00:03:30,000<br>You know, first of all, it has good support.</p>
<p>47<br>00:03:30,000 –&gt; 00:03:35,000<br>For threats and our PC.</p>
<p>48<br>00:03:35,000 –&gt; 00:03:38,000<br>And those two are very important for distributed programming.</p>
<p>49<br>00:03:38,000 –&gt; 00:03:43,000<br>So it makes sense to, you know, and those is a good match for that.</p>
<p>50<br>00:03:43,000 –&gt; 00:03:46,000<br>Second reason that we like it a lot is, you know, that has a garbage collector.</p>
<p>51<br>00:03:46,000 –&gt; 00:03:53,000<br>And if you do shared memory style parallelism where multiple threats share a structure were variable.</p>
<p>52<br>00:03:53,000 –&gt; 00:03:59,000<br>Then having a garb collector is nice because then the threats don’t have to decide who’s the last.</p>
<p>53<br>00:03:59,000 –&gt; 00:04:07,000<br>A threat that actually has a reference to this memory and shoot therefore, dialocated the guards collector just takes care of all those problems.</p>
<p>54<br>00:04:07,000 –&gt; 00:04:09,000<br>So that’s convenient.</p>
<p>55<br>00:04:09,000 –&gt; 00:04:14,000<br>It’s tight safe.</p>
<p>56<br>00:04:14,000 –&gt; 00:04:17,000<br>It is simple.</p>
<p>57<br>00:04:17,000 –&gt; 00:04:20,000<br>It’s a reasonable simple programming language quite easy to learn.</p>
<p>58<br>00:04:20,000 –&gt; 00:04:25,000<br>And in fact, you know, that years, hopefully you got that experience with doing the go tutorial that they want you to go to tutorial.</p>
<p>59<br>00:04:25,000 –&gt; 00:04:28,000<br>You mostly got most of go.</p>
<p>60<br>00:04:28,000 –&gt; 00:04:31,000<br>And then finally, it actually has a compiler.</p>
<p>61<br>00:04:31,000 –&gt; 00:04:33,000<br>So it’s compiled.</p>
<p>62<br>00:04:33,000 –&gt; 00:04:39,000<br>Like Python or, you know, actually, the combined producer is actually your code.</p>
<p>63<br>00:04:39,000 –&gt; 00:04:43,000<br>And so the rent I’m overhead is not as large.</p>
<p>64<br>00:04:43,000 –&gt; 00:04:49,000<br>I guess sort of the final reason why we are for eight to four is in the ego is actually I enjoy writing.</p>
<p>65<br>00:04:49,000 –&gt; 00:04:55,000<br>Go programs. And so that may be also an important reason.</p>
<p>66<br>00:04:55,000 –&gt; 00:05:00,000<br>So what I’m going to do is I’m going to talk a little bit about threats in general or a machine general.</p>
<p>67<br>00:05:00,000 –&gt; 00:05:06,000<br>And you know, talk a little bit about different aspects of programming with threats.</p>
<p>68<br>00:05:06,000 –&gt; 00:05:08,000<br>Some of that is pretty tutorial.</p>
<p>69<br>00:05:08,000 –&gt; 00:05:12,000<br>So if you have seen this before, you know, my apologies.</p>
<p>70<br>00:05:12,000 –&gt; 00:05:14,000<br>I’m going to go reasonable quickly through it.</p>
<p>71<br>00:05:14,000 –&gt; 00:05:18,000<br>It’s definitely not a comprehensive introduction to good programming.</p>
<p>72<br>00:05:18,000 –&gt; 00:05:23,000<br>But just hopefully enough to remind you what the issues are and what you should look at for.</p>
<p>73<br>00:05:23,000 –&gt; 00:05:27,000<br>And we’ll hopefully spend some time quite a bit of time on the crawler.</p>
<p>74<br>00:05:27,000 –&gt; 00:05:28,000<br>So sort of see the solution.</p>
<p>75<br>00:05:28,000 –&gt; 00:05:31,000<br>I will share you the solution that are two solutions.</p>
<p>76<br>00:05:31,000 –&gt; 00:05:34,000<br>One using channels and one’s using new Texas.</p>
<p>77<br>00:05:34,000 –&gt; 00:05:36,000<br>And I will go through both of them.</p>
<p>78<br>00:05:36,000 –&gt; 00:05:45,000<br>Any questions so far before I dive in.</p>
<p>79<br>00:05:45,000 –&gt; 00:05:50,000<br>Okay, let me get started with threats.</p>
<p>80<br>00:05:50,000 –&gt; 00:05:59,000<br>So Fred is basically shorthand of the Fred of execution.</p>
<p>81<br>00:05:59,000 –&gt; 00:06:17,000<br>And so the way to think about it is that like when you do go run, no, the go will create a process, you know, on your operating system.</p>
<p>82<br>00:06:17,000 –&gt; 00:06:21,000<br>And in the site of a process is going to go runtime system.</p>
<p>83<br>00:06:21,000 –&gt; 00:06:25,000<br>And when go start, it actually has one Fred of execution, the main Fred.</p>
<p>84<br>00:06:25,000 –&gt; 00:06:28,000<br>And then you can do a primitive to create new threats.</p>
<p>85<br>00:06:28,000 –&gt; 00:06:29,000<br>And so you can think about this.</p>
<p>86<br>00:06:29,000 –&gt; 00:06:31,000<br>Those are many, many threats and execution.</p>
<p>87<br>00:06:31,000 –&gt; 00:06:33,000<br>You know, running parallel.</p>
<p>88<br>00:06:33,000 –&gt; 00:06:38,000<br>And you can think about a single Fred is basically sort of a sequential program running.</p>
<p>89<br>00:06:38,000 –&gt; 00:06:43,000<br>So the program has a program counter has his own stack.</p>
<p>90<br>00:06:43,000 –&gt; 00:06:48,000<br>It has his own set of registers.</p>
<p>91<br>00:06:48,000 –&gt; 00:06:51,000<br>And so this is a page like a sequential program.</p>
<p>92<br>00:06:51,000 –&gt; 00:06:55,000<br>And execute the structure one and execute two then structure three and four.</p>
<p>93<br>00:06:55,000 –&gt; 00:06:58,000<br>And they make a procedure call, allocate memory on the stack.</p>
<p>94<br>00:06:58,000 –&gt; 00:07:01,000<br>Return for own a procedure call, recursive call.</p>
<p>95<br>00:07:01,000 –&gt; 00:07:04,000<br>Also if you’re standing to the point where I tell you about programming.</p>
<p>96<br>00:07:04,000 –&gt; 00:07:09,000<br>It’s just like happens as a sequential Fred basically.</p>
<p>97<br>00:07:09,000 –&gt; 00:07:16,000<br>The interesting thing is that, you know, the threads may actually share memory with other friends.</p>
<p>98<br>00:07:16,000 –&gt; 00:07:23,000<br>So since all the threads are running in the same address space, the same operating system address space.</p>
<p>99<br>00:07:23,000 –&gt; 00:07:25,000<br>Or the same process address space.</p>
<p>100<br>00:07:25,000 –&gt; 00:07:27,000<br>They can actually share a memory.</p>
<p>101<br>00:07:27,000 –&gt; 00:07:31,000<br>So one Fred can write through location, say, you know, 10.</p>
<p>102<br>00:07:31,000 –&gt; 00:07:34,000<br>And then another Fred can actually read that location 10.</p>
<p>103<br>00:07:34,000 –&gt; 00:07:39,000<br>And so that way they can actually communicate information.</p>
<p>104<br>00:07:39,000 –&gt; 00:07:49,000<br>One way to think about Fred, two is to sort of think about it as sort of an abstraction, you know, supported by the runtime and the runtime as a number of operations on a threat.</p>
<p>105<br>00:07:49,000 –&gt; 00:07:56,000<br>So one operation, you know, we’ve seen many times, if you’ve seen how many times is to actually start a threat, but create a threat.</p>
<p>106<br>00:07:56,000 –&gt; 00:08:01,000<br>You know, this is the goal, synthet, you know, to go keyword.</p>
<p>107<br>00:08:01,000 –&gt; 00:08:03,000<br>Fred can exit.</p>
<p>108<br>00:08:03,000 –&gt; 00:08:12,000<br>And generally this just means the exit actions would be implicit like when the Fred returns from this.</p>
<p>109<br>00:08:12,000 –&gt; 00:08:20,000<br>If you create a function using go the go keyword and you know, you return out of the function and implicitly the Fred X me exits.</p>
<p>110<br>00:08:20,000 –&gt; 00:08:28,000<br>The go runtime also has a couple other sort of under the hoots operations, if you will, one, it can actually stop a threat.</p>
<p>111<br>00:08:28,000 –&gt; 00:08:33,000<br>And so, you know, the Fred, the Fred writes to a channel and there’s no reader on the channel yet.</p>
<p>112<br>00:08:33,000 –&gt; 00:08:36,000<br>Then the Fred might get blocked.</p>
<p>113<br>00:08:36,000 –&gt; 00:08:43,000<br>And so the go runtime sort of stops the Fred, you know, puts his site so that it connects with running other Fred on the processor.</p>
<p>114<br>00:08:43,000 –&gt; 00:08:46,000<br>And then maybe later on resumes that Fred.</p>
<p>115<br>00:08:46,000 –&gt; 00:08:51,000<br>So they’re in sort of a third, you know, final primitive that actually is through zoom for us.</p>
<p>116<br>00:08:51,000 –&gt; 00:08:57,000<br>And really what it means to stop and zoom a Fred is basically taking the state of the Fred like a program counter, the step corner in the red.</p>
<p>117<br>00:08:57,000 –&gt; 00:09:02,000<br>So that’s what it doesn’t site run it other, you know, Fred on the processor.</p>
<p>118<br>00:09:02,000 –&gt; 00:09:09,000<br>And then at some point, you know, decide to resume the processor, which means basically loading the program counter to step pointer and the register is back into the processor.</p>
<p>119<br>00:09:09,000 –&gt; 00:09:20,000<br>So that’s sort of a very mechanical few of the Fred is.</p>
<p>120<br>00:09:20,000 –&gt; 00:09:28,000<br>And then we have for it’s in the first place, that seems like an important point to discuss.</p>
<p>121<br>00:09:28,000 –&gt; 00:09:34,000<br>But there’s in some ways, and the only thing that Fred do is make your life more complicated as a programmer.</p>
<p>122<br>00:09:34,000 –&gt; 00:09:38,000<br>Like writing to country code is actually just easier than writing parallel code.</p>
<p>123<br>00:09:38,000 –&gt; 00:09:49,000<br>And the main reason to have it, and the main reason we care a lot about everything in six, eight, and four years through express and concurrency.</p>
<p>124<br>00:09:49,000 –&gt; 00:09:55,000<br>And sort of three different, you know, sort of two, we’re two or three different types of concurrency that we actually care about.</p>
<p>125<br>00:09:55,000 –&gt; 00:10:01,000<br>So you think about our, you know, process, we got that runtime with our Fred’s running.</p>
<p>126<br>00:10:01,000 –&gt; 00:10:09,000<br>You know, one type of concurrency that we care a lot about is Ioc concurrency.</p>
<p>127<br>00:10:09,000 –&gt; 00:10:17,000<br>One of these threads, you know, that is running here, you know, might actually make a network call connecting to some other machine on the network.</p>
<p>128<br>00:10:17,000 –&gt; 00:10:21,000<br>You know, to implement a distributed application like that produce.</p>
<p>129<br>00:10:21,000 –&gt; 00:10:26,000<br>And you know, as it makes that call, you know, it’s going to be blocked, you know, waiting for response.</p>
<p>130<br>00:10:26,000 –&gt; 00:10:32,000<br>And while it’s blocked and they’re waiting for response, every new nice to actually run some other threats.</p>
<p>131<br>00:10:32,000 –&gt; 00:10:38,000<br>But we’re not, we’re not, we’re not, we want to issue multiple requests to multiple machines.</p>
<p>132<br>00:10:38,000 –&gt; 00:10:49,000<br>Sort of roughly parallel, you know, we could just do that with fire rock long go routine and fire not the code team, not a go routine that all kind of sent and make connections to other remote machines.</p>
<p>133<br>00:10:49,000 –&gt; 00:10:51,000<br>That’s one reason I’ll be care a lot about it.</p>
<p>134<br>00:10:51,000 –&gt; 00:11:03,000<br>Ioc concurrency. The second reason I would care about it is, you know, allow for multi core parallelism.</p>
<p>135<br>00:11:03,000 –&gt; 00:11:09,000<br>So we have multiple course in our, you know, computer or processor.</p>
<p>136<br>00:11:09,000 –&gt; 00:11:17,000<br>Then we can have one threat running on the one go routine running on one core and another Fred or another go routine running on another core.</p>
<p>137<br>00:11:17,000 –&gt; 00:11:20,000<br>And then we can start with the straightening parallel.</p>
<p>138<br>00:11:20,000 –&gt; 00:11:27,000<br>And as an example, we implement a like a key value service, then we could process, maybe request for different keys in the key value service.</p>
<p>139<br>00:11:27,000 –&gt; 00:11:32,000<br>We use on different course completely parallel, you know, increasing our throughput.</p>
<p>140<br>00:11:32,000 –&gt; 00:11:38,000<br>So those are the sort of two main reasons that we care a lot about concurrency by threats.</p>
<p>141<br>00:11:38,000 –&gt; 00:11:44,000<br>So we have a little bit of convenience.</p>
<p>142<br>00:11:44,000 –&gt; 00:11:53,000<br>There’s going to be a number of cases in the lab, for example, where we want to have something happen periodically, maybe every second or every two and a milliseconds.</p>
<p>143<br>00:11:53,000 –&gt; 00:11:56,000<br>And we can just launch a threat that are going to routine for that.</p>
<p>144<br>00:11:56,000 –&gt; 00:12:01,000<br>You just sleep for two and a milliseconds. You know, does what it needs to do. And then it goes back to sleep for two and a milliseconds.</p>
<p>145<br>00:12:01,000 –&gt; 00:12:13,000<br>And so it’s convenient to sort of have these sort of background activities that we can be done periodically and you can express that using threats. Of course, you can express them in other ways, but threats are actually convenient.</p>
<p>146<br>00:12:13,000 –&gt; 00:12:20,000<br>And all the question that comes up often and I think came up in some of the lecture questions today, like how many threats you create.</p>
<p>147<br>00:12:20,000 –&gt; 00:12:26,000<br>And I think the go design us the way they want you to think about it is that you should create as many threats as you need.</p>
<p>148<br>00:12:26,000 –&gt; 00:12:31,000<br>They’re definitely not free when they tie up some memory, because we have to have a stack.</p>
<p>149<br>00:12:31,000 –&gt; 00:12:37,000<br>There’s a performance overhead starting them, but they should think about them as very lightweight.</p>
<p>150<br>00:12:37,000 –&gt; 00:12:44,000<br>And so you should be encouraging or your encourage to create the threats as you go.</p>
<p>151<br>00:12:44,000 –&gt; 00:12:55,000<br>And the questions about sort of this basic reason would like to have threats.</p>
<p>152<br>00:12:55,000 –&gt; 00:13:03,000<br>Okay, let me then, you know, as I mentioned earlier, threats actually have challenges.</p>
<p>153<br>00:13:03,000 –&gt; 00:13:08,000<br>Programming with threats as challenges. So let me talk a little bit about the challenges.</p>
<p>154<br>00:13:08,000 –&gt; 00:13:17,000<br>I’m not going to go in great amount of depth here. I assume that you know, there’s a thing that will make sense and that will become more clear if we look at some of the examples.</p>
<p>155<br>00:13:17,000 –&gt; 00:13:31,000<br>And probably the main reason that you know, for that section, you are challenging is that you can have race conditions.</p>
<p>156<br>00:13:31,000 –&gt; 00:13:40,000<br>And just like a basic example of race condition, let’s say you have two threats, you know, your T1, used to you.</p>
<p>157<br>00:13:40,000 –&gt; 00:13:46,000<br>And they share a variable and let’s say the initial value zero.</p>
<p>158<br>00:13:46,000 –&gt; 00:13:53,000<br>And they both execute, you know, both threats, executed statement before, you know, as, you know, the increment end by one.</p>
<p>159<br>00:13:53,000 –&gt; 00:13:58,000<br>Of course, you might think that statement is an atomic operation or something that is indivisible, but it isn’t.</p>
<p>160<br>00:13:58,000 –&gt; 00:14:04,000<br>Right. You know, the growth statement that is compiled, you know, to whatever instructions the process is executing.</p>
<p>161<br>00:14:04,000 –&gt; 00:14:19,000<br>And so we cannot assume that it’s an atomic instruction. And in fact, you know, it’s, it consists of basically like a load, you know, to which store is the end, the content of ending to a register, then increment the register and then we’re stored a registry back into memory.</p>
<p>162<br>00:14:19,000 –&gt; 00:14:34,000<br>And so if you’re very unlucky, you know, the two threats basically try to anchor both execute this pickle instruction, then we can have a very important sequence of events where like both threats, you know, form the load instruction.</p>
<p>163<br>00:14:34,000 –&gt; 00:14:42,000<br>You know, the variable in, you know, the register, let’s say, R0, you know, you’re also an R0.</p>
<p>164<br>00:14:42,000 –&gt; 00:14:47,000<br>Now, the increment it’s our hero becomes one.</p>
<p>165<br>00:14:47,000 –&gt; 00:14:57,000<br>One and then write it back now to the store instruction that actually results, you know, stores results back into the variable memory.</p>
<p>166<br>00:14:57,000 –&gt; 00:15:11,000<br>And so it just happens at this particular in this scenario where this happens to look truly concurrently. Now, what does the value end after these two threat that open increment?</p>
<p>167<br>00:15:11,000 –&gt; 00:15:22,000<br>Which is one. Yeah, it’s one. And what is the, what is the value supposed to be or what we expected to be?</p>
<p>168<br>00:15:22,000 –&gt; 00:15:29,000<br>Two. Yeah, expected to be two, right? And so one is definitely not equal to two. And there’s a bar.</p>
<p>169<br>00:15:29,000 –&gt; 00:15:44,000<br>And so, and this is like, you know, the sort of the heart of race conditions, which is not, you know, if an unsports an unfortunate sequence of events where threats share state, the updates actually might not be reflective correctly.</p>
<p>170<br>00:15:44,000 –&gt; 00:15:53,000<br>And of course, most of the time this will work out fine because you have to be in this sort of very sort of this very specific case before it shows up.</p>
<p>171<br>00:15:53,000 –&gt; 00:16:10,000<br>So, for example, I think one one of you reported like, I didn’t have my locks or my race, you know, my, my, my locks in order in my program just work fine. And not as actually the issue with race conditions that typically just work fine, but sometimes it goes wrong.</p>
<p>172<br>00:16:10,000 –&gt; 00:16:14,000<br>So the two ways to address race conditions.</p>
<p>173<br>00:16:14,000 –&gt; 00:16:18,000<br>And the first way is to avoid sharing.</p>
<p>174<br>00:16:18,000 –&gt; 00:16:21,000<br>Don’t share variables.</p>
<p>175<br>00:16:21,000 –&gt; 00:16:29,000<br>And this is one style programming that, you know, go encourages about using channels, you know, channels, you just communicate the values, but you don’t really direct and share memory.</p>
<p>176<br>00:16:29,000 –&gt; 00:16:39,000<br>So that’s one way you’re doing it. No, no, so avoid sharing is one big approach. The other approach is actually to use locks.</p>
<p>177<br>00:16:39,000 –&gt; 00:16:46,000<br>And then you can do making the making sequence of instructions in the atomic operation. And we’ll talk a lot more about that in a second.</p>
<p>178<br>00:16:46,000 –&gt; 00:16:53,000<br>One of the things that I want to point out that is really cool about what the usual tool is go actually have a race detector.</p>
<p>179<br>00:16:53,000 –&gt; 00:17:08,000<br>And most of the labs that you were doing will encourage you to basically run go using the dash race flag. And that will actually not catch every possible race, but it definitely extremely good job of actually indentifying the races.</p>
<p>180<br>00:17:08,000 –&gt; 00:17:13,000<br>So you should, but default run go with the race detector enabled.</p>
<p>181<br>00:17:13,000 –&gt; 00:17:20,000<br>Okay, so that’s one challenge for threats. The second challenge for threats is actually coordination.</p>
<p>182<br>00:17:20,000 –&gt; 00:17:27,000<br>So it’s often the case that one has to, you know, one fret must wait on another fret for something is accomplished.</p>
<p>183<br>00:17:27,000 –&gt; 00:17:38,000<br>And there’s a number of the go exercises in the tutorial and I had that kind of for and there’s two ways, you know, go actually two primitives for dealing with that one again channels.</p>
<p>184<br>00:17:38,000 –&gt; 00:17:54,000<br>You know, channels basically allow you to communicate and to coordinate at the same time, or, you know, talk a little bit later about, you know, condition variables.</p>
<p>185<br>00:17:54,000 –&gt; 00:18:00,000<br>And both can be useful. I’ll talk a little bit more about that. And then finally, sort of final challenge.</p>
<p>186<br>00:18:00,000 –&gt; 00:18:06,000<br>Big sort of conceptual channel is you can get that lock.</p>
<p>187<br>00:18:06,000 –&gt; 00:18:17,000<br>So they’ve one friend waits in like T1 ways on T2 and T2 waits in T1, you know, before example, release a lock before some other sequencing you can basically sort of what they call death being race.</p>
<p>188<br>00:18:17,000 –&gt; 00:18:23,000<br>And then you can get a number of things that you can do for both or reading in the other and as well nothing makes for progress.</p>
<p>189<br>00:18:23,000 –&gt; 00:18:32,000<br>Attribute your way of getting, you know, say, that lock in ago would be like you have a single fret. No other threads at all.</p>
<p>190<br>00:18:32,000 –&gt; 00:18:36,000<br>And you’re right to channel.</p>
<p>191<br>00:18:36,000 –&gt; 00:18:41,000<br>And that will block that one thread until somebody else, you know, reach some other friends reach from the channel.</p>
<p>192<br>00:18:41,000 –&gt; 00:18:45,000<br>And then you know, you know, you know, you can get a number of other friends at all, you know, that will be all in a death lock.</p>
<p>193<br>00:18:45,000 –&gt; 00:18:49,000<br>This is like the simplest possible, that lock possible.</p>
<p>194<br>00:18:49,000 –&gt; 00:18:57,000<br>And you know, go actually will catch this case and will run a reason run, I may are saying like no frets can run, you know, you have a deadlock.</p>
<p>195<br>00:18:57,000 –&gt; 00:19:01,000<br>But there could be more complicated that watching, we’re involved in multiple frets.</p>
<p>196<br>00:19:01,000 –&gt; 00:19:08,000<br>As you’re going through the labs and dismissal you, I’m sure you were running to some.</p>
<p>197<br>00:19:08,000 –&gt; 00:19:18,000<br>I’m a little bit of a step back here and think about, you know, go for, you know, these challenges.</p>
<p>198<br>00:19:18,000 –&gt; 00:19:20,000<br>That I just talked about.</p>
<p>199<br>00:19:20,000 –&gt; 00:19:29,000<br>Roughly speaking, go as sort of two plans to handle these concurrency challenges.</p>
<p>200<br>00:19:29,000 –&gt; 00:19:35,000<br>And one plan is, you know, these we around channels.</p>
<p>201<br>00:19:35,000 –&gt; 00:19:40,000<br>And there’s another plan, they just we around locks.</p>
<p>202<br>00:19:40,000 –&gt; 00:19:50,000<br>In condition variables.</p>
<p>203<br>00:19:50,000 –&gt; 00:20:00,000<br>And the way I think about it, you know, so people are quite dogmatic about this and think one plans better than the other plan.</p>
<p>204<br>00:20:00,000 –&gt; 00:20:05,000<br>And the general approach here is like I do want to plan that it’s most suitable for the case that I’m looking at.</p>
<p>205<br>00:20:05,000 –&gt; 00:20:11,000<br>Or that I’m running into and generally, you know, I’ve no sharing.</p>
<p>206<br>00:20:11,000 –&gt; 00:20:16,000<br>And basically I need two threats that basically to communicate, but I don’t really share any memory.</p>
<p>207<br>00:20:16,000 –&gt; 00:20:19,000<br>I tend to use the channels.</p>
<p>208<br>00:20:19,000 –&gt; 00:20:27,000<br>And there are two threats that can do share memory because it’s convenient to share memory, for example, I write a key value servers and I want to share the key value table.</p>
<p>209<br>00:20:27,000 –&gt; 00:20:39,000<br>Then I use locks and condition variables.</p>
<p>210<br>00:20:39,000 –&gt; 00:20:49,000<br>And you know, my general approach is not so the media medic and you know, take whatever approach, you know, that actually is most convenient for the problem at hand.</p>
<p>211<br>00:20:49,000 –&gt; 00:20:58,000<br>The tutorial just pretty good job of actually teaching me about channels, mentioned locks, doesn’t seem much about condition variables.</p>
<p>212<br>00:20:58,000 –&gt; 00:21:06,000<br>So I think it’s worthwhile to talk a little bit about condition variables to make sure that you’re aware that they exist.</p>
<p>213<br>00:21:06,000 –&gt; 00:21:11,000<br>And I’m going to do that using a tiny little example to sort of illustrate the issues.</p>
<p>214<br>00:21:11,000 –&gt; 00:21:19,000<br>The tiny little example is we have a, you know, sort of a little bit inspired to a little bit inspired by the labs.</p>
<p>215<br>00:21:19,000 –&gt; 00:21:27,000<br>And I have a threat to you one and T1 needs to collect a number of votes for all remote machines.</p>
<p>216<br>00:21:27,000 –&gt; 00:21:34,000<br>And for example, it needs to decide that it has a majority so that actually proceeds to commit some value.</p>
<p>217<br>00:21:34,000 –&gt; 00:21:40,000<br>And you’ll see that later in like this shows up in the raft lab of one of the sub primitives that you need.</p>
<p>218<br>00:21:40,000 –&gt; 00:21:47,000<br>And so to do that, you know, the T1 will fork, you know, other threats, you know, say to you to.</p>
<p>219<br>00:21:47,000 –&gt; 00:21:53,000<br>And T2 amazingly does something expensive like, you know, talk to some remote machines to actually get its vote.</p>
<p>220<br>00:21:53,000 –&gt; 00:22:04,000<br>And then you know report back, you know, that vote to T1 and T1 basically needs to collect all the votes, head them up and then assume that the majority, you know, declare sort of victory.</p>
<p>221<br>00:22:04,000 –&gt; 00:22:11,000<br>So there’s a pretty straightforward simple program, but because you’re a little bit of a likes me to illustrate your couple of issues.</p>
<p>222<br>00:22:11,000 –&gt; 00:22:16,000<br>So we’re going to switch to the screen.</p>
<p>223<br>00:22:16,000 –&gt; 00:22:22,000<br>Can everybody see this?</p>
<p>224<br>00:22:22,000 –&gt; 00:22:30,000<br>So here I have a very simple implementation of this program, the vote thing.</p>
<p>225<br>00:22:30,000 –&gt; 00:22:43,000<br>And again, it’s a little bit of a totally example, but just hopefully gets the points across the two variables shared here, count and then I just count to count to number votes, finished, you know, count for when we’re done.</p>
<p>226<br>00:22:43,000 –&gt; 00:22:53,000<br>So, you know, there’s a loop, you know, going for 10 creating a go creating of, you know, launching and.</p>
<p>227<br>00:22:53,000 –&gt; 00:23:03,000<br>An anonymous function and then an anonymous function, you know, concurrently, you know, calls this function request votes, request vote, basically, you know, assimilates doing a long.</p>
<p>228<br>00:23:03,000 –&gt; 00:23:18,000<br>And then the answer of operation on some remote and seeing the way it assimilates it is by just going to sleep, it’s like, walks a little while, then returns and then, you know, returns, voted yes, then the count goes up and the count of fact that actually we had one more.</p>
<p>229<br>00:23:18,000 –&gt; 00:23:21,000<br>Fred voting and then we’re done.</p>
<p>230<br>00:23:21,000 –&gt; 00:23:32,000<br>So that’s the four of 10 threads, you know, the each of you request vote and report the result and then at the end we’ll check if the count is smaller than the wife, you know, we know that we failed.</p>
<p>231<br>00:23:32,000 –&gt; 00:23:43,000<br>We lost the election and we have votes equal larger than five, you know, will basically one the election, so this is sort of the simple, very simple program.</p>
<p>232<br>00:23:43,000 –&gt; 00:23:46,000<br>This is all makes sense.</p>
<p>233<br>00:23:46,000 –&gt; 00:23:53,000<br>Let me run it just for the kicks.</p>
<p>234<br>00:23:54,000 –&gt; 00:23:59,000<br>You know, we’re running a couple times, sometimes we lose, sometimes win, you know, makes sense.</p>
<p>235<br>00:23:59,000 –&gt; 00:24:04,000<br>And so this program looks, you know, working.</p>
<p>236<br>00:24:04,000 –&gt; 00:24:10,000<br>And correct, is it actually correct.</p>
<p>237<br>00:24:10,000 –&gt; 00:24:13,000<br>Sorry, was the question whether this program is actually correct.</p>
<p>238<br>00:24:13,000 –&gt; 00:24:16,000<br>Yeah, it seems to produce results.</p>
<p>239<br>00:24:16,000 –&gt; 00:24:21,000<br>I think there’s a race condition, isn’t there?</p>
<p>240<br>00:24:21,000 –&gt; 00:24:25,000<br>Like you have all of these different threads incrementing the count and finished variables.</p>
<p>241<br>00:24:25,000 –&gt; 00:24:26,000<br>Yeah.</p>
<p>242<br>00:24:26,000 –&gt; 00:24:32,000<br>And it’s also.</p>
<p>243<br>00:24:32,000 –&gt; 00:24:36,000<br>It’s not clear to me that finished necessarily always reaches 10.</p>
<p>244<br>00:24:36,000 –&gt; 00:24:39,000<br>Is it possible that it doesn’t.</p>
<p>245<br>00:24:39,000 –&gt; 00:24:44,000<br>Let me let me take these one one by one and just go for your first point, which is either one or one or was after.</p>
<p>246<br>00:24:44,000 –&gt; 00:24:52,000<br>You know, clear this has a visitor again, the fact that we have two variables a year correct.</p>
<p>247<br>00:24:52,000 –&gt; 00:24:55,000<br>You know, count of finished, they’re accessed by different go routines.</p>
<p>248<br>00:24:55,000 –&gt; 00:24:57,000<br>So this is a merely a red flag.</p>
<p>249<br>00:24:57,000 –&gt; 00:24:59,000<br>Could you see a problem here?</p>
<p>250<br>00:24:59,000 –&gt; 00:25:05,000<br>Like as soon as you have a variable that has access to or modified and by two different go routines, you know, there’s a kind of be a problem.</p>
<p>251<br>00:25:05,000 –&gt; 00:25:10,000<br>And so you know, interesting to run the race detector and see if it actually catches it.</p>
<p>252<br>00:25:10,000 –&gt; 00:25:18,000<br>And as you expect it, you know, the go the race detector, it tells you exactly, you know, there is indeed to get some problems here that this program.</p>
<p>253<br>00:25:18,000 –&gt; 00:25:23,000<br>And you know, list the line number, you know, or things actually can go wrong.</p>
<p>254<br>00:25:23,000 –&gt; 00:25:28,000<br>So that gives you actually pretty good clue that something is not up to snuff this program.</p>
<p>255<br>00:25:28,000 –&gt; 00:25:37,000<br>And so we’re going to like repair it in small steps and, you know, that will hopefully shed some more light on competitive programming.</p>
<p>256<br>00:25:37,000 –&gt; 00:25:41,000<br>So let me use my second solution to this program.</p>
<p>257<br>00:25:41,000 –&gt; 00:25:53,000<br>And in this case, I’ll talk about channels a little bit later because I wanted to illustrate the locks and condition variables first, because the less emphasis in the tutorial.</p>
<p>258<br>00:25:53,000 –&gt; 00:25:58,000<br>So you know, simple solution, you know, the correct here introduce a lock.</p>
<p>259<br>00:25:58,000 –&gt; 00:26:02,000<br>The lock is completely independent of the variables.</p>
<p>260<br>00:26:02,000 –&gt; 00:26:08,000<br>And you follow some convention, which says like, well, this lock knew protects counter finish.</p>
<p>261<br>00:26:08,000 –&gt; 00:26:14,000<br>And so whenever, you know, you access in counter finish, you have to wrap that into the lock and then unlock statement.</p>
<p>262<br>00:26:14,000 –&gt; 00:26:19,000<br>And so here we see two like this is their go function could run separately.</p>
<p>263<br>00:26:19,000 –&gt; 00:26:25,000<br>And after you know the request code, it’s about to update the vote and finish. So we take a lock out.</p>
<p>264<br>00:26:25,000 –&gt; 00:26:30,000<br>And then go has this nice feature called the defer statement.</p>
<p>265<br>00:26:30,000 –&gt; 00:26:41,000<br>If you exit the basic block, you know, will run the function that is declared by the bird or that is after the key word deferred.</p>
<p>266<br>00:26:41,000 –&gt; 00:26:47,000<br>And this means like we execute, we leave to go function here will automatically unlock.</p>
<p>267<br>00:26:47,000 –&gt; 00:26:50,000<br>This is convenient because then you want to forget to unlock.</p>
<p>268<br>00:26:50,000 –&gt; 00:26:55,000<br>And so it’s nice to do that right at point where you do the lock. And so you can write immediately defer in lock.</p>
<p>269<br>00:26:55,000 –&gt; 00:27:03,000<br>And then you have to worry about the multiple exit paths out of the go routine or out of function that you forget to unlock.</p>
<p>270<br>00:27:03,000 –&gt; 00:27:12,000<br>So, you know, basically in a critical section where we hold the lock, we update voting count and then of course the function returns and locks automatically.</p>
<p>271<br>00:27:12,000 –&gt; 00:27:21,000<br>And similarly at the, at the end, you know, we got a, every time we access, you know, counter finish.</p>
<p>272<br>00:27:21,000 –&gt; 00:27:27,000<br>Since they share it, you know, we need to surround it with locks and then you’re a simple way of doing it.</p>
<p>273<br>00:27:27,000 –&gt; 00:27:31,000<br>We could have written deeper unlock in your two in the body, but I would be fine.</p>
<p>274<br>00:27:31,000 –&gt; 00:27:34,000<br>So we can actually run this program.</p>
<p>275<br>00:27:34,000 –&gt; 00:27:36,000<br>Let’s see.</p>
<p>276<br>00:27:36,000 –&gt; 00:27:44,000<br>And so we run it, you know, the racing tech seems to be happy. So hopefully we’ll have a better program.</p>
<p>277<br>00:27:44,000 –&gt; 00:27:47,000<br>So I just have a question here about scoping.</p>
<p>278<br>00:27:47,000 –&gt; 00:27:48,000<br>Yeah.</p>
<p>279<br>00:27:48,000 –&gt; 00:27:55,000<br>So it seems that when we have the anonymous function, then we have this new and we have the count and we have the finished and it seems that the anonymous function has access to.</p>
<p>280<br>00:27:55,000 –&gt; 00:27:59,000<br>Yeah, that we’re defined outside of the function. So how do we open rules work?</p>
<p>281<br>00:27:59,000 –&gt; 00:28:07,000<br>Yeah, I’m going to be any fun with an anonymous function and any variable that’s, you know, used inside of the function is not declared inside of the function.</p>
<p>282<br>00:28:07,000 –&gt; 00:28:12,000<br>Basically, it was all points to variables outside of the out of scope.</p>
<p>283<br>00:28:12,000 –&gt; 00:28:15,000<br>So statically scope.</p>
<p>284<br>00:28:15,000 –&gt; 00:28:20,000<br>What about the scope of the, like the mutex.</p>
<p>285<br>00:28:20,000 –&gt; 00:28:28,000<br>How many times you have to declare that or, and what’s the scope of it, I guess, the scope of the first statement is this block, one basic block.</p>
<p>286<br>00:28:28,000 –&gt; 00:28:36,000<br>So, no, I mean, like when you actually declare like the mutex data structure, I guess.</p>
<p>287<br>00:28:36,000 –&gt; 00:28:38,000<br>It’s like any other variable.</p>
<p>288<br>00:28:38,000 –&gt; 00:28:41,000<br>That’s the same scope as finished or count.</p>
<p>289<br>00:28:41,000 –&gt; 00:28:46,000<br>So it applies to any variable declared in the rest of the.</p>
<p>290<br>00:28:46,000 –&gt; 00:28:54,000<br>Yeah, the way to think about it is that the new text is not directly associated with any variable. It’s just a lock, you know, it’s like a name.</p>
<p>291<br>00:28:54,000 –&gt; 00:29:02,000<br>And it’s up to you as a programmer to just say like what that lock protects.</p>
<p>292<br>00:29:02,000 –&gt; 00:29:05,000<br>There are two independent concepts.</p>
<p>293<br>00:29:05,000 –&gt; 00:29:12,000<br>What happens, what happens if you use I in the go retie that wouldn’t work right you need to pass that end.</p>
<p>294<br>00:29:12,000 –&gt; 00:29:22,000<br>Yeah, so what I like that’s a good question and the number of you asked that for email to so what are what happens to like if we use I here, and I want you to do something with it like whatever.</p>
<p>295<br>00:29:22,000 –&gt; 00:29:32,000<br>Count is I, this is a good plan or not.</p>
<p>296<br>00:29:32,000 –&gt; 00:29:36,000<br>What value of I will be using when this friend actually happens to run.</p>
<p>297<br>00:29:36,000 –&gt; 00:29:42,000<br>If it starts to function and we’ll run at some point, what value of I will be using.</p>
<p>298<br>00:29:42,000 –&gt; 00:29:48,000<br>Whatever I happens to be at the time, which is being changed by the for loop outside.</p>
<p>299<br>00:29:48,000 –&gt; 00:29:58,000<br>Yeah, right. So you know, so this is not so great because it’s probably not what we intended. We probably intended the eye that we whatever for that’s illegal loop iteration.</p>
<p>300<br>00:29:58,000 –&gt; 00:30:10,000<br>So how do we want to if we have to solve that how we do you could add it as a parameter to the non function and pass it in so it gets evaluated when you create the go over team.</p>
<p>301<br>00:30:10,000 –&gt; 00:30:22,000<br>So we do the right this and then pass it actually in right the net up point what happens then at the point we actually create the go routine I is being captured and then passed in.</p>
<p>302<br>00:30:22,000 –&gt; 00:30:24,000<br>Right then.</p>
<p>303<br>00:30:24,000 –&gt; 00:30:27,000<br>Pass.</p>
<p>304<br>00:30:27,000 –&gt; 00:30:42,000<br>How are the local variables allocated like if if captain finished our like local variables wouldn’t they like be destroyed after the main function exits or like if this wasn’t main but like another function what it’s like that hitting function exit before the.</p>
<p>305<br>00:30:42,000 –&gt; 00:30:45,000<br>Yeah, the principal allocated in stack.</p>
<p>306<br>00:30:45,000 –&gt; 00:30:53,000<br>And you know the blue and the other functions that just memory addresses references to them. So it’s indeed the case is main returns.</p>
<p>307<br>00:30:53,000 –&gt; 00:30:57,000<br>Then these you know, these stack allocated variables are gone.</p>
<p>308<br>00:30:57,000 –&gt; 00:31:06,000<br>Typically what you will see is that in a goal program you would allocate them in you know on the heat using new like if you make a new struct or whatever.</p>
<p>309<br>00:31:06,000 –&gt; 00:31:09,000<br>So would you get a segmentation fault then or.</p>
<p>310<br>00:31:09,000 –&gt; 00:31:12,000<br>Okay.</p>
<p>311<br>00:31:12,000 –&gt; 00:31:25,000<br>I have a question I actually remember this is the correct like way to do it or not but instead of passing it in would it be possible to as the first line in the for loop do I colon equals I.</p>
<p>312<br>00:31:25,000 –&gt; 00:31:37,000<br>And then you’re like you have a I don’t know how the scoping works within the like block of the for loop because I think that should create a new variable I that the go routine can access that isn’t being updated again.</p>
<p>313<br>00:31:37,000 –&gt; 00:31:39,000<br>So you can do that.</p>
<p>314<br>00:31:39,000 –&gt; 00:31:43,000<br>That can help instead of passing it in it kind of makes it look ugly to me.</p>
<p>315<br>00:31:43,000 –&gt; 00:31:50,000<br>Okay, well I like to passing in but that’s another way of doing it all shows an example later.</p>
<p>316<br>00:31:50,000 –&gt; 00:31:58,000<br>So to do some or somebody asked actually you know do we get a second station felt we’re not really going to get a second station fault I should take that back.</p>
<p>317<br>00:31:58,000 –&gt; 00:32:01,000<br>Because basically one Fred will hold still hold a reference.</p>
<p>318<br>00:32:01,000 –&gt; 00:32:05,000<br>And so the garbage collector will not delete the object yet.</p>
<p>319<br>00:32:05,000 –&gt; 00:32:13,000<br>Right only when the last Fred actually only when no Fred holds a reference you know the will the garbage collector delete the object.</p>
<p>320<br>00:32:13,000 –&gt; 00:32:21,000<br>And this is one of the cool things about having garbage collected language and shared memory programming you don’t have to worry about that scenario.</p>
<p>321<br>00:32:21,000 –&gt; 00:32:23,000<br>Okay.</p>
<p>322<br>00:32:23,000 –&gt; 00:32:26,000<br>Yeah.</p>
<p>323<br>00:32:26,000 –&gt; 00:32:38,000<br>Like what could this code like the block because like if we if like the go routines like the first four loop will exit and then the second one will like.</p>
<p>324<br>00:32:38,000 –&gt; 00:32:41,000<br>Yeah, no, never mind.</p>
<p>325<br>00:32:41,000 –&gt; 00:32:45,000<br>There are definitely some issues that are not ideal yet. So let me just talk about them.</p>
<p>326<br>00:32:45,000 –&gt; 00:32:48,000<br>One of them is that like this particular loop.</p>
<p>327<br>00:32:48,000 –&gt; 00:32:54,000<br>It’s a little bit annoying right like this this this four loop is there’s nothing else than waiting until count reaches five for finished.</p>
<p>328<br>00:32:54,000 –&gt; 00:33:01,000<br>And the way it does it is by just spinning right so there’s locks locks it looks at the valley quickly locks it and spins around again.</p>
<p>329<br>00:33:01,000 –&gt; 00:33:04,000<br>So basically since it’s spinning on the processor doing really nothing.</p>
<p>330<br>00:33:04,000 –&gt; 00:33:11,000<br>It’d be nice to express that in a little bit better way so that like basically the go can sort of give up the core again so that another Fred can run.</p>
<p>331<br>00:33:11,000 –&gt; 00:33:19,000<br>And so the way you can do that is usually condition variables and so this is my the next implementation.</p>
<p>332<br>00:33:19,000 –&gt; 00:33:36,000<br>Or actually I show you one other application one way to do it out of is a little bit not you know not so nice is a example and but so much suggested this is actually sleep for a little while so instead of like giving up the spinning like crazy just sleep one period of sleep for period and then come back.</p>
<p>333<br>00:33:36,000 –&gt; 00:33:46,000<br>So that’s a lot of the solution will work but the downside of it is that you know how long long should you sleep right you really would like to be the case that I assume for example this guy reaches five.</p>
<p>334<br>00:33:46,000 –&gt; 00:33:51,000<br>Then you know you wake you could wake up the this particular you know the main threat.</p>
<p>335<br>00:33:51,000 –&gt; 00:33:58,000<br>And so I was jumping ahead a little bit but so that’s what condition variables are four.</p>
<p>336<br>00:33:58,000 –&gt; 00:34:02,000<br>And you’re solution with condition variables.</p>
<p>337<br>00:34:02,000 –&gt; 00:34:13,000<br>So we allocated the new condition to years condition variables allocated it’s associated with this particular lock we’ll see in a second why this is important.</p>
<p>338<br>00:34:13,000 –&gt; 00:34:17,000<br>And you know basically the main Fred what it does now.</p>
<p>339<br>00:34:17,000 –&gt; 00:34:25,000<br>So it’s the lock because it needs to grab the lock to look at talented finish otherwise that could erase conditions and then.</p>
<p>340<br>00:34:25,000 –&gt; 00:34:30,000<br>And the condition still not true and just calls weight on this condition variable.</p>
<p>341<br>00:34:30,000 –&gt; 00:34:45,000<br>And what that does is actually done automatically goes to sleep as well as releasing the lock that is associated with the condition variable you know since you know me really associated the condition variable can’t wait basically in locks.</p>
<p>342<br>00:34:45,000 –&gt; 00:34:50,000<br>And goes to sleep in an atomic operation.</p>
<p>343<br>00:34:50,000 –&gt; 00:34:55,000<br>And when it returns you know from come weight it will actually hold the lock again.</p>
<p>344<br>00:34:55,000 –&gt; 00:35:00,000<br>So the color most no sooner than if come weight returns will actually help the lock again.</p>
<p>345<br>00:35:00,000 –&gt; 00:35:05,000<br>And so it’s safe again to look at talent and finish and then call weight again.</p>
<p>346<br>00:35:05,000 –&gt; 00:35:09,000<br>Okay. So basically you know this Fred will go to sleep.</p>
<p>347<br>00:35:09,000 –&gt; 00:35:13,000<br>And then the go routines that you know are collecting the votes.</p>
<p>348<br>00:35:13,000 –&gt; 00:35:21,000<br>You know the same code as before my lock and then lock or defer during lock and then when you’re done you know updating count to finish.</p>
<p>349<br>00:35:21,000 –&gt; 00:35:25,000<br>There are two primitives on the condition variable one is signal and one is broadcast.</p>
<p>350<br>00:35:25,000 –&gt; 00:35:30,000<br>And broadcast basically signal wakes up one waiter and broadcast weights of all waiters.</p>
<p>351<br>00:35:30,000 –&gt; 00:35:35,000<br>You know there’s only one waiter here so we could have used either one of them.</p>
<p>352<br>00:35:35,000 –&gt; 00:35:40,000<br>And so basically one of reaches you know five you know at some point or 10.</p>
<p>353<br>00:35:40,000 –&gt; 00:35:49,000<br>Then you know the so every time finishes and command it you know the main Fred will be working up and check the condition and then keep up.</p>
<p>354<br>00:35:49,000 –&gt; 00:35:51,000<br>Okay.</p>
<p>355<br>00:35:51,000 –&gt; 00:35:58,000<br>And so this is convenient sort of you can think about condition variables as a coordination primitive you know between two different threats.</p>
<p>356<br>00:35:58,000 –&gt; 00:36:11,000<br>And then when you’re actually using walks you know for the protect your share state.</p>
<p>357<br>00:36:11,000 –&gt; 00:36:18,000<br>So here’s the same implementation of this program using channels.</p>
<p>358<br>00:36:18,000 –&gt; 00:36:23,000<br>And more or less work to the same way except we’re of course no walks.</p>
<p>359<br>00:36:23,000 –&gt; 00:36:31,000<br>The main Fred creates a channel passes the goal routine that on his function that’s being created as a separate Fred.</p>
<p>360<br>00:36:31,000 –&gt; 00:36:34,000<br>You’re right basically the request vote to the channel.</p>
<p>361<br>00:36:34,000 –&gt; 00:36:38,000<br>And then the main Fred basically blocks here correct when it starts reading from the channel.</p>
<p>362<br>00:36:38,000 –&gt; 00:36:42,000<br>Ones that actually get something with something is written to the channel will in block.</p>
<p>363<br>00:36:42,000 –&gt; 00:36:49,000<br>You know look at the value and it’s true and add up and auto and always in commence finish.</p>
<p>364<br>00:36:49,000 –&gt; 00:36:59,000<br>And what’s going on here correct is we don’t need locks because count and finish are not shared there’s only one thread that actually updates count and finish and that’s the main Fred.</p>
<p>365<br>00:36:59,000 –&gt; 00:37:02,000<br>Okay.</p>
<p>366<br>00:37:02,000 –&gt; 00:37:04,000<br>The.</p>
<p>367<br>00:37:04,000 –&gt; 00:37:14,000<br>And this is going to the name the the the sort of request that threats you know all basically just write to this channel they write concurrently perhaps the channel.</p>
<p>368<br>00:37:14,000 –&gt; 00:37:22,000<br>But the channels are one of the things that go to that Fred safe so multiple threats connected right to the channel.</p>
<p>369<br>00:37:22,000 –&gt; 00:37:25,000<br>Any questions about this.</p>
<p>370<br>00:37:25,000 –&gt; 00:37:28,000<br>About this solution.</p>
<p>371<br>00:37:28,000 –&gt; 00:37:33,000<br>What was the thing about like having a buffer for the channel.</p>
<p>372<br>00:37:33,000 –&gt; 00:37:43,000<br>Yeah so normally when you’re writing to the channel and nobody’s reading from the channel or no Fred is reading from the channel then the center will need to be blocked.</p>
<p>373<br>00:37:43,000 –&gt; 00:37:53,000<br>You can specify that the channel has a buffer of a of 10 or 20 and that allows the channel to have multiple values.</p>
<p>374<br>00:37:53,000 –&gt; 00:38:04,000<br>In 8 to 4 labs I’ve never used buffered channels and one of two three times I did it and I regret it so in general I don’t use it.</p>
<p>375<br>00:38:04,000 –&gt; 00:38:08,000<br>But this is a rationing important point.</p>
<p>376<br>00:38:08,000 –&gt; 00:38:12,000<br>This program is actually still not very good.</p>
<p>377<br>00:38:12,000 –&gt; 00:38:15,000<br>So for example when.</p>
<p>378<br>00:38:15,000 –&gt; 00:38:22,000<br>It doesn’t matter in practice in this particular example but it’s not in some of the labs to goodbye to you.</p>
<p>379<br>00:38:22,000 –&gt; 00:38:28,000<br>As soon as it reaches count five what will happen.</p>
<p>380<br>00:38:28,000 –&gt; 00:38:30,000<br>It’s not listening for.</p>
<p>381<br>00:38:30,000 –&gt; 00:38:31,000<br>Yeah.</p>
<p>382<br>00:38:31,000 –&gt; 00:38:34,000<br>This is the channel so any other threats are just going to be blocked.</p>
<p>383<br>00:38:34,000 –&gt; 00:38:42,000<br>Yeah so basically it means like if the first five threats voted yes then the next five threats will be blocked in this channel correct.</p>
<p>384<br>00:38:42,000 –&gt; 00:38:45,000<br>So they’ll be hanging around.</p>
<p>385<br>00:38:45,000 –&gt; 00:38:55,000<br>And in this case it won’t be a problem because most of you guys are most mature if the main Fred exit and actually cleans up all the other threats too.</p>
<p>386<br>00:38:55,000 –&gt; 00:38:58,000<br>But for example if this will be a long running service.</p>
<p>387<br>00:38:58,000 –&gt; 00:39:00,000<br>This would be not good.</p>
<p>388<br>00:39:00,000 –&gt; 00:39:05,000<br>Basically we’re leaking threats here you know they’re sitting blocked on the site doing nothing in that channel.</p>
<p>389<br>00:39:05,000 –&gt; 00:39:10,000<br>And so that’s quite egregious and this is something to watch out for.</p>
<p>390<br>00:39:10,000 –&gt; 00:39:15,000<br>And this showed up in the crawler I think for many people in the.</p>
<p>391<br>00:39:15,000 –&gt; 00:39:21,000<br>And the flip side of this is that is the main Fred and just early before any of the request folks are done.</p>
<p>392<br>00:39:21,000 –&gt; 00:39:23,000<br>And then you also have a problem.</p>
<p>393<br>00:39:23,000 –&gt; 00:39:29,000<br>And so there’s this management of threats that actually is often a tricky issue.</p>
<p>394<br>00:39:29,000 –&gt; 00:39:34,000<br>Is there a way to kill the thread without exiting from me.</p>
<p>395<br>00:39:34,000 –&gt; 00:39:40,000<br>While you can send it a variable or a value on some channel saying like please exit.</p>
<p>396<br>00:39:40,000 –&gt; 00:39:48,000<br>And you have to coordinate it yourself.</p>
<p>397<br>00:39:48,000 –&gt; 00:39:54,000<br>When I go back to one of the things that actually is cool about.</p>
<p>398<br>00:39:54,000 –&gt; 00:39:59,000<br>Condition variables is that.</p>
<p>399<br>00:39:59,000 –&gt; 00:40:02,000<br>In principle you might think the same issue exists here.</p>
<p>400<br>00:40:02,000 –&gt; 00:40:06,000<br>We’re like this Fred actually runs.</p>
<p>401<br>00:40:06,000 –&gt; 00:40:09,000<br>And this Fred.</p>
<p>402<br>00:40:09,000 –&gt; 00:40:11,000<br>And might get blocked.</p>
<p>403<br>00:40:11,000 –&gt; 00:40:17,000<br>For example, if you know reached you know five you know this main Fred will proceed doing it’s thing.</p>
<p>404<br>00:40:17,000 –&gt; 00:40:21,000<br>While the other guys are still maybe actually sitting in here.</p>
<p>405<br>00:40:21,000 –&gt; 00:40:25,000<br>The notice these in this case they won’t be blocked.</p>
<p>406<br>00:40:25,000 –&gt; 00:40:27,000<br>Because you know well, grab the lock.</p>
<p>407<br>00:40:27,000 –&gt; 00:40:32,000<br>Then you know does it thing does a broadcast in the broadcast is actually not a blocking operation.</p>
<p>408<br>00:40:32,000 –&gt; 00:40:35,000<br>And then you know writing to a channel that is a blocking operation.</p>
<p>409<br>00:40:35,000 –&gt; 00:40:39,000<br>If nobody is listening the con broadcast is not a blocking operation.</p>
<p>410<br>00:40:39,000 –&gt; 00:40:43,000<br>And so this actually works out in this particular program by itself.</p>
<p>411<br>00:40:43,000 –&gt; 00:40:50,000<br>Okay.</p>
<p>412<br>00:40:50,000 –&gt; 00:40:51,000<br>Okay good.</p>
<p>413<br>00:40:51,000 –&gt; 00:41:01,000<br>Any further questions about you know these two examples just to.</p>
<p>414<br>00:41:01,000 –&gt; 00:41:06,000<br>And then let’s talk about the crawler.</p>
<p>415<br>00:41:06,000 –&gt; 00:41:15,000<br>So the crawler is a little sort of more realistic example of return programming.</p>
<p>416<br>00:41:15,000 –&gt; 00:41:18,000<br>Yeah, just to remind you.</p>
<p>417<br>00:41:18,000 –&gt; 00:41:25,000<br>You know, basically the idea is that you know you start out with a URL for some web page.</p>
<p>418<br>00:41:25,000 –&gt; 00:41:29,000<br>And then you just need to fetch the fetch the web page that might have more URLs.</p>
<p>419<br>00:41:29,000 –&gt; 00:41:36,000<br>And you basically proceed, you know then fetching those web pages, you know looking at those URLs and keep going.</p>
<p>420<br>00:41:36,000 –&gt; 00:41:41,000<br>And the idea is to crawl basically the whole internet for all the web pages that are exist.</p>
<p>421<br>00:41:41,000 –&gt; 00:41:46,000<br>And of course, you know some URLs might point back to a message that you’re ready to visit it.</p>
<p>422<br>00:41:46,000 –&gt; 00:41:52,000<br>And so goal is to actually not visit the same web page twice.</p>
<p>423<br>00:41:52,000 –&gt; 00:41:56,000<br>And so to go with the exercises a couple of goals that you want to achieve.</p>
<p>424<br>00:41:56,000 –&gt; 00:42:03,000<br>One is I own concurrency.</p>
<p>425<br>00:42:03,000 –&gt; 00:42:06,000<br>The fetch operation is a link take a long time.</p>
<p>426<br>00:42:06,000 –&gt; 00:42:10,000<br>You know maybe it’s a web page that sits on the other side of the world.</p>
<p>427<br>00:42:10,000 –&gt; 00:42:12,000<br>You’re maybe go over slow networks.</p>
<p>428<br>00:42:12,000 –&gt; 00:42:19,000<br>And while you’re sort of one for this or fetching that page, you know you would like to be able to fetch other other other pages.</p>
<p>429<br>00:42:19,000 –&gt; 00:42:30,000<br>Another goal is this correctness goal or you know, form school namely, you know, fetch one that you do around once.</p>
<p>430<br>00:42:30,000 –&gt; 00:42:42,000<br>And you know, normally you’d love to like to exploit multiple course. You know if you have multiple course, you can work in parallel.</p>
<p>431<br>00:42:42,000 –&gt; 00:42:55,000<br>Okay. So what I like to do before actually talking about the current solution first, let me show you a simple serial solution.</p>
<p>432<br>00:42:55,000 –&gt; 00:43:05,000<br>So that we, you know, we have something to talk about as a baseline.</p>
<p>433<br>00:43:05,000 –&gt; 00:43:19,000<br>So, so I have three solutions in here.</p>
<p>434<br>00:43:19,000 –&gt; 00:43:20,000<br>Run them.</p>
<p>435<br>00:43:20,000 –&gt; 00:43:26,000<br>Run.</p>
<p>436<br>00:43:26,000 –&gt; 00:43:41,000<br>And then you see that the more or less they produce the same results, you know, two found one missing two found the only differences that the order of the output is slightly different once in a while.</p>
<p>437<br>00:43:41,000 –&gt; 00:43:44,000<br>Of course, it has to do with concurrency.</p>
<p>438<br>00:43:44,000 –&gt; 00:43:48,000<br>Okay. So the main function.</p>
<p>439<br>00:43:48,000 –&gt; 00:43:55,000<br>So we have a course in serial with the starting URL, the feature and then an empty map.</p>
<p>440<br>00:43:55,000 –&gt; 00:44:02,000<br>And then serial solution is basically sort of standard sequential recursive solution.</p>
<p>441<br>00:44:02,000 –&gt; 00:44:06,000<br>We first check if we already visited the URL that’s passed into us.</p>
<p>442<br>00:44:06,000 –&gt; 00:44:13,000<br>If we did, now we’re trying to immediately otherwise market as visit will fix the URL that gives us a bunch of you URLs.</p>
<p>443<br>00:44:13,000 –&gt; 00:44:20,000<br>And then we look for all the URLs and call basically serial again. Right. And this is your sequential solution. That’s what I expected.</p>
<p>444<br>00:44:20,000 –&gt; 00:44:25,000<br>And you know, your goal was to basically read a current version of this.</p>
<p>445<br>00:44:25,000 –&gt; 00:44:31,000<br>And so what I like to do is actually to make the class a little bit interactive.</p>
<p>446<br>00:44:31,000 –&gt; 00:44:42,000<br>I want to go switch over to breakout rooms. And what we’re going to do is basically put four to five of you in a single breakout room for about 10 minutes.</p>
<p>447<br>00:44:42,000 –&gt; 00:44:46,000<br>And what I would like you to do is share your solution with each other and discuss it.</p>
<p>448<br>00:44:46,000 –&gt; 00:44:52,000<br>So maybe the best way to go about it is that one of you, you know, you get into the room.</p>
<p>449<br>00:44:52,000 –&gt; 00:44:56,000<br>One of the person in the room, you know, basically stream shares their solution.</p>
<p>450<br>00:44:56,000 –&gt; 00:45:03,000<br>And discuss it as you know one of the issues that he or she ran into and other people can comment or share other solutions.</p>
<p>451<br>00:45:03,000 –&gt; 00:45:07,000<br>And just to get into discussion of meets and other students in the class.</p>
<p>452<br>00:45:07,000 –&gt; 00:45:10,000<br>Any questions about that.</p>
<p>453<br>00:45:12,000 –&gt; 00:45:14,000<br>Thank you.</p>
<p>454<br>00:45:14,000 –&gt; 00:45:18,000<br>We go back to share my screen again.</p>
<p>455<br>00:45:18,000 –&gt; 00:45:21,000<br>Can I already see my screen again?</p>
<p>456<br>00:45:21,000 –&gt; 00:45:23,000<br>Yeah, plus good.</p>
<p>457<br>00:45:23,000 –&gt; 00:45:29,000<br>Good. Thank you.</p>
<p>458<br>00:45:29,000 –&gt; 00:45:33,000<br>Okay. So hopefully that was interesting.</p>
<p>459<br>00:45:33,000 –&gt; 00:45:38,000<br>And let me talk about the solutions that I have.</p>
<p>460<br>00:45:38,000 –&gt; 00:45:41,000<br>And I think that’s a good question.</p>
<p>461<br>00:45:41,000 –&gt; 00:45:43,000<br>They’re posted on the schedule page.</p>
<p>462<br>00:45:43,000 –&gt; 00:45:45,000<br>If you haven’t.</p>
<p>463<br>00:45:45,000 –&gt; 00:45:48,000<br>You can look concurrently with me if you want to.</p>
<p>464<br>00:45:48,000 –&gt; 00:45:57,000<br>There should, you know, let me walk through the new text version first and then I’ll walk through the channel one.</p>
<p>465<br>00:45:57,000 –&gt; 00:45:58,000<br>Second.</p>
<p>466<br>00:45:58,000 –&gt; 00:46:00,000<br>So here’s the.</p>
<p>467<br>00:46:00,000 –&gt; 00:46:11,000<br>The new text one, the new text one, the collarsher struct, you know, with the has both the map and the new text and the map needs to be protected by new text because it’s going to be concurrent access to the map.</p>
<p>468<br>00:46:11,000 –&gt; 00:46:14,000<br>So map by itself is not free at save.</p>
<p>469<br>00:46:14,000 –&gt; 00:46:17,000<br>It’s up to the programmer to actually make the map front save.</p>
<p>470<br>00:46:17,000 –&gt; 00:46:24,000<br>And the content, new text one works sort of similar to the serial one, except whenever there’s a shared state, basically takes a walk out.</p>
<p>471<br>00:46:24,000 –&gt; 00:46:25,000<br>So we’ll take the lock.</p>
<p>472<br>00:46:25,000 –&gt; 00:46:27,000<br>Now, we look at the URL.</p>
<p>473<br>00:46:27,000 –&gt; 00:46:28,000<br>It’s been touched.</p>
<p>474<br>00:46:28,000 –&gt; 00:46:31,000<br>If it hasn’t been touched with market has now been fetched.</p>
<p>475<br>00:46:31,000 –&gt; 00:46:34,000<br>Well, hasn’t been fetched and we unlock.</p>
<p>476<br>00:46:34,000 –&gt; 00:46:38,000<br>And we kept this already value to decide whether we should return or not.</p>
<p>477<br>00:46:38,000 –&gt; 00:46:40,000<br>And then.</p>
<p>478<br>00:46:40,000 –&gt; 00:46:46,000<br>You know, we read this go routine starts fetching a page that gets a bunch of URLs back.</p>
<p>479<br>00:46:46,000 –&gt; 00:46:50,000<br>And then for every URL back.</p>
<p>480<br>00:46:50,000 –&gt; 00:47:01,000<br>It creates a new go routine here on this side passes in the URL, but that go routine is supposed to fetch and crawl.</p>
<p>481<br>00:47:01,000 –&gt; 00:47:04,000<br>The only sort of other interesting thing here.</p>
<p>482<br>00:47:04,000 –&gt; 00:47:07,000<br>Is that it uses something called weight group.</p>
<p>483<br>00:47:07,000 –&gt; 00:47:14,000<br>And wave group is a very convenient primitive to sort of keep track how many fret you still have active and when you can terminate.</p>
<p>484<br>00:47:14,000 –&gt; 00:47:20,000<br>And then you can sort of a big issue in this particular assignment that if you terminator too early, then you didn’t crawl the web pages.</p>
<p>485<br>00:47:20,000 –&gt; 00:47:23,000<br>And so you need to keep track, whether you’re.</p>
<p>486<br>00:47:23,000 –&gt; 00:47:31,000<br>Whether there’s still outstanding web pages to be crawled, sync weight group is very easily basically every time you call a fret you call.</p>
<p>487<br>00:47:31,000 –&gt; 00:47:35,000<br>And then when the threat terminates.</p>
<p>488<br>00:47:35,000 –&gt; 00:47:37,000<br>You call done.</p>
<p>489<br>00:47:37,000 –&gt; 00:47:40,000<br>And you could conveniently do that in the deferral statement.</p>
<p>490<br>00:47:40,000 –&gt; 00:47:49,000<br>And then the main fret that is waiting for real, the threats determinant just calls weight and weight will return until every fret that was started for every every add one.</p>
<p>491<br>00:47:49,000 –&gt; 00:47:51,000<br>If all those threats actually have me.</p>
<p>492<br>00:47:51,000 –&gt; 00:47:53,000<br>I did it.</p>
<p>493<br>00:47:53,000 –&gt; 00:48:00,000<br>And so that’s the new text version.</p>
<p>494<br>00:48:00,000 –&gt; 00:48:07,000<br>And you can think about sync weight sort of being internally implemented using condition variable.</p>
<p>495<br>00:48:07,000 –&gt; 00:48:13,000<br>Okay, let’s look at the channel version.</p>
<p>496<br>00:48:13,000 –&gt; 00:48:23,000<br>And so here’s the channel versions basically sort of or or can it organize as the map reduce lab where there’s a coordinator and workers.</p>
<p>497<br>00:48:23,000 –&gt; 00:48:29,000<br>And so we start off, you know, we start off creating a coordinator threat.</p>
<p>498<br>00:48:29,000 –&gt; 00:48:32,000<br>And the way we do that actually is we make a channel.</p>
<p>499<br>00:48:32,000 –&gt; 00:48:35,000<br>And then we pass the channel into the coordinator.</p>
<p>500<br>00:48:35,000 –&gt; 00:48:39,000<br>The coordinator first has to start with a URL, the beginning URLs.</p>
<p>501<br>00:48:39,000 –&gt; 00:48:42,000<br>We need to supply that on the channel. That’s the most convenient thing to do.</p>
<p>502<br>00:48:42,000 –&gt; 00:48:44,000<br>As we’ll see in a second.</p>
<p>503<br>00:48:44,000 –&gt; 00:48:50,000<br>But you know, through send it on the channel, we basically have to create a go team because otherwise, you know, we deadlock here.</p>
<p>504<br>00:48:50,000 –&gt; 00:48:52,000<br>We, and this is a typical feeling record.</p>
<p>505<br>00:48:52,000 –&gt; 00:48:55,000<br>The goal is to just send that value on the channel.</p>
<p>506<br>00:48:55,000 –&gt; 00:48:58,000<br>So let’s look at the coordinator.</p>
<p>507<br>00:48:58,000 –&gt; 00:49:00,000<br>Here’s the coordinator.</p>
<p>508<br>00:49:00,000 –&gt; 00:49:05,000<br>It doesn’t use any locks at all because the data structures that.</p>
<p>509<br>00:49:05,000 –&gt; 00:49:16,000<br>There’s no data structures actually being shared like fetched, you know, the map that actually keeps track of which URLs has been fetched is actually only access within the coordinator.</p>
<p>510<br>00:49:16,000 –&gt; 00:49:27,000<br>So the coordinator got a, you know, when we called it initially, we got a, it has a one URL checks the fetch map and then for every URL.</p>
<p>511<br>00:49:27,000 –&gt; 00:49:33,000<br>And then it goes basically, you know, cycles through reach the channel using a range statement.</p>
<p>512<br>00:49:33,000 –&gt; 00:49:39,000<br>And basically what this does is it just keeps reading the channel and it just grabs the next value, picks the next value, grabs the next value.</p>
<p>513<br>00:49:39,000 –&gt; 00:49:41,000<br>So basically, it grabs the URL.</p>
<p>514<br>00:49:41,000 –&gt; 00:49:45,000<br>We know there’s one in it because you know, we put it on when we created it.</p>
<p>515<br>00:49:45,000 –&gt; 00:49:51,000<br>And then for that URL, we sort of roughly do the same thing as the.</p>
<p>516<br>00:49:51,000 –&gt; 00:49:54,000<br>Concerned as the new touch one.</p>
<p>517<br>00:49:54,000 –&gt; 00:49:58,000<br>You know, we see if the URL is already been fetched.</p>
<p>518<br>00:49:58,000 –&gt; 00:50:07,000<br>It hasn’t been fetched then we’re done. Otherwise, we’ll create a grow worker to actually fetch that URL.</p>
<p>519<br>00:50:07,000 –&gt; 00:50:11,000<br>And we keep track of how many outstanding workers we have.</p>
<p>520<br>00:50:11,000 –&gt; 00:50:15,000<br>So N is counting normal workers and only what N zero.</p>
<p>521<br>00:50:15,000 –&gt; 00:50:24,000<br>Do we terminate the coordinator to make sure that basically we have fetched all the web pages that we should post to be fetching.</p>
<p>522<br>00:50:24,000 –&gt; 00:50:31,000<br>Let’s you go to worker worker basically calls fetch. You know, this course now happens completely in parallel with any other workers.</p>
<p>523<br>00:50:31,000 –&gt; 00:50:38,000<br>If it actually fetches some URL from that web page, basically writes all those URLs to the channel.</p>
<p>524<br>00:50:38,000 –&gt; 00:50:43,000<br>And so the coordinator will get all those channels through dream statement.</p>
<p>525<br>00:50:43,000 –&gt; 00:50:54,000<br>And then when it’s done, you know, writing all the URL through the channel, then the coordinator or the worker exits and that will, you know, at some point.</p>
<p>526<br>00:50:54,000 –&gt; 00:50:59,000<br>Decrease, you know, and then at the end.</p>
<p>527<br>00:50:59,000 –&gt; 00:51:01,000<br>And that’s it basically.</p>
<p>528<br>00:51:01,000 –&gt; 00:51:02,000<br>Okay.</p>
<p>529<br>00:51:02,000 –&gt; 00:51:13,000<br>So there was a detour solutions. Any questions about these.</p>
<p>530<br>00:51:13,000 –&gt; 00:51:16,000<br>Is it all clear?</p>
<p>531<br>00:51:16,000 –&gt; 00:51:19,000<br>There’s a question in chat.</p>
<p>532<br>00:51:19,000 –&gt; 00:51:33,000<br>Let me get my chat list back up.</p>
<p>533<br>00:51:33,000 –&gt; 00:51:41,000<br>Okay. So the question is when C H has a value in it, when all other threads be idle.</p>
<p>534<br>00:51:41,000 –&gt; 00:51:49,000<br>And then the case that the, since this is not a buffer channel, but you know, those are going to be only one requesting the channel at the time.</p>
<p>535<br>00:51:49,000 –&gt; 00:51:55,000<br>And so all the threads, you know, will be appending to the channel one by one.</p>
<p>536<br>00:51:55,000 –&gt; 00:52:01,000<br>But doesn’t that make the program sequential because no two threads are running in parallel except the main thread and one.</p>
<p>537<br>00:52:01,000 –&gt; 00:52:05,000<br>Well, the fetish will still happen in parallel.</p>
<p>538<br>00:52:05,000 –&gt; 00:52:10,000<br>And those are presumably the expensive operation, right? Those go out across the Internet.</p>
<p>539<br>00:52:10,000 –&gt; 00:52:14,000<br>Thank you.</p>
<p>540<br>00:52:14,000 –&gt; 00:52:19,000<br>Okay. Let me switch back to my other screen.</p>
<p>541<br>00:52:19,000 –&gt; 00:52:28,000<br>Talk a little bit about RPC, since that’s the other thing tool that you need for the labs.</p>
<p>542<br>00:52:28,000 –&gt; 00:52:39,000<br>I’m not going to say you’re talking about it, but just RPC stands for remote procedure call.</p>
<p>543<br>00:52:39,000 –&gt; 00:52:56,000<br>And basically the goal, you know, the goal of an RPC system, like the one that go has is the bank sort of RPCs behave roughly similar to procedure calls, you know, local procedure calls that you execute on the stack.</p>
<p>544<br>00:52:56,000 –&gt; 00:53:08,000<br>Right. And so the goal is that, for example, if you have a client in RPC terminal, the college typically called the client and the colleagues call the server.</p>
<p>545<br>00:53:08,000 –&gt; 00:53:19,000<br>And they say you have a function and you know, FN, you know, we’re calling with X and Y. And then at the server, there’s the implementation of this function.</p>
<p>546<br>00:53:19,000 –&gt; 00:53:23,000<br>And so as a function and whatever X, you know, from a Y end.</p>
<p>547<br>00:53:23,000 –&gt; 00:53:31,000<br>And you know, the returns, you know, whatever does some computation and maybe use this returns.</p>
<p>548<br>00:53:31,000 –&gt; 00:53:34,000<br>X plus Y.</p>
<p>549<br>00:53:34,000 –&gt; 00:53:56,000<br>So what we like sort of like to have happened, or like the model that we would like this sort of ourselves to think about is that when the client calls this function, FN, the RPC system will make sure that there’s an corresponding notification happening on the server site passes the arguments X and Y, you know, to the server code runs on the server.</p>
<p>550<br>00:53:56,000 –&gt; 00:54:15,000<br>And then you know, returns are resolved, you know, say you see, and that result is them communicating back to the client and, you know, and then FN will resume will return and the client will return will resume with, you know, the X plus Y in the value of X plus Y and Z.</p>
<p>551<br>00:54:15,000 –&gt; 00:54:20,000<br>And it looks like, you know, even though the programs are running on different computers, you know, they’re not sort of a hard binary here.</p>
<p>552<br>00:54:20,000 –&gt; 00:54:25,000<br>And looks like, you know, they make a sort of regular procedure calls.</p>
<p>553<br>00:54:25,000 –&gt; 00:54:38,000<br>And we’ll see in a second that actually we can make a lot of similarities or it’s possible to make them behave very similar, but I’ll see there’s also sort of a fundamental difference and I’d actually ask them to really do a distributed computing.</p>
<p>554<br>00:54:38,000 –&gt; 00:54:43,000<br>But before getting there, let me first sort of sketch out how you can make this work.</p>
<p>555<br>00:54:43,000 –&gt; 00:54:50,000<br>And this is sort of roughly, you know, let go dust too. So the way you know, the thing about it is that when the client.</p>
<p>556<br>00:54:50,000 –&gt; 00:54:52,000<br>So near our program.</p>
<p>557<br>00:54:52,000 –&gt; 00:54:57,000<br>And when the client calls the function FN with X and Y in it.</p>
<p>558<br>00:54:57,000 –&gt; 00:55:01,000<br>What it does is actually calls something that’s called the stuff.</p>
<p>559<br>00:55:01,000 –&gt; 00:55:11,000<br>And the stuff is basically local function, you know, front FN and with the two arguments, we declare the X and Y. And basically what the stuff does.</p>
<p>560<br>00:55:11,000 –&gt; 00:55:14,000<br>You think this is a stop procedure.</p>
<p>561<br>00:55:14,000 –&gt; 00:55:18,000<br>But the stuff procedure basically does it and built a message.</p>
<p>562<br>00:55:18,000 –&gt; 00:55:28,000<br>You know, saying, you know, which function needs to be called, you know, the arguments of the function, you know, the types of the phone of those arguments, the values of these arguments, etc, etc.</p>
<p>563<br>00:55:28,000 –&gt; 00:55:39,000<br>And then what the stuff does actually, it sends it over to network to or for responding stuff to server.</p>
<p>564<br>00:55:39,000 –&gt; 00:55:49,000<br>So the server receives this message and basically takes this message and they are Marshall or Marshall.</p>
<p>565<br>00:55:49,000 –&gt; 00:55:59,000<br>The term that’s being used to basically convert values from sort of to by the race and from by the race back to values.</p>
<p>566<br>00:55:59,000 –&gt; 00:56:04,000<br>And then calls, you know, this function FN at the server.</p>
<p>567<br>00:56:04,000 –&gt; 00:56:10,000<br>And X, you know, in blah, blah, blah.</p>
<p>568<br>00:56:10,000 –&gt; 00:56:15,000<br>And then the stuff basically calls the function, the function returns back into the stuff.</p>
<p>569<br>00:56:15,000 –&gt; 00:56:21,000<br>The stuff, Marshalls, you know, the response value, like the Z, maybe X plus Y.</p>
<p>570<br>00:56:21,000 –&gt; 00:56:27,000<br>And since the back, you know, to the climb stuff and the climb stuff is still waiting.</p>
<p>571<br>00:56:27,000 –&gt; 00:56:31,000<br>So basically the climb stuff, the way that actually works, it sends out the request and then waits for the response.</p>
<p>572<br>00:56:31,000 –&gt; 00:56:38,000<br>And so when the response comes back in, you know, in Marshalls.</p>
<p>573<br>00:56:38,000 –&gt; 00:56:41,000<br>And then you know returns the value to the clients.</p>
<p>574<br>00:56:41,000 –&gt; 00:56:51,000<br>So basically these two stops sort of make a remote procedure call looked like a regular procedure call, you know, for almost you can’t help.</p>
<p>575<br>00:56:51,000 –&gt; 00:56:53,000<br>And the key.</p>
<p>576<br>00:56:53,000 –&gt; 00:56:57,000<br>And these stops are generally automatically generated.</p>
<p>577<br>00:56:57,000 –&gt; 00:57:02,000<br>So the compiler, in case of the group of pilots that actually generate the stops for you.</p>
<p>578<br>00:57:02,000 –&gt; 00:57:07,000<br>And then you do the marshalling and the marshalling arguments for you.</p>
<p>579<br>00:57:07,000 –&gt; 00:57:10,000<br>And that’s how it goes.</p>
<p>580<br>00:57:10,000 –&gt; 00:57:17,000<br>So the so when you’re doing it from the server to the client, there’s also another stop again.</p>
<p>581<br>00:57:17,000 –&gt; 00:57:20,000<br>You basically return back to that first stop.</p>
<p>582<br>00:57:20,000 –&gt; 00:57:25,000<br>So this stuff makes a procedure call to make you calls to proceed to FN.</p>
<p>583<br>00:57:25,000 –&gt; 00:57:28,000<br>That procedure returns great into the stuff because the stop called it.</p>
<p>584<br>00:57:28,000 –&gt; 00:57:30,000<br>Oh, it’s a same stop that it goes in.</p>
<p>585<br>00:57:30,000 –&gt; 00:57:33,000<br>Exactly.</p>
<p>586<br>00:57:33,000 –&gt; 00:57:35,000<br>Got it.</p>
<p>587<br>00:57:35,000 –&gt; 00:57:36,000<br>Okay.</p>
<p>588<br>00:57:36,000 –&gt; 00:57:43,000<br>Okay. So let me show you sort of how this plays out inside of go.</p>
<p>589<br>00:57:43,000 –&gt; 00:57:50,000<br>And by showing you a very simple key value server.</p>
<p>590<br>00:57:50,000 –&gt; 00:57:56,000<br>And you will see, you know, it doesn’t look exactly in our procedure calls, but it’s pretty close.</p>
<p>591<br>00:57:56,000 –&gt; 00:58:05,000<br>So the typical thing is that you actually declare typical convention sort of in go is that you declare.</p>
<p>592<br>00:58:05,000 –&gt; 00:58:07,000<br>The arguments are structs.</p>
<p>593<br>00:58:07,000 –&gt; 00:58:12,000<br>And so we’re going to implement two procedures to remote procedures one is put and one is get.</p>
<p>594<br>00:58:12,000 –&gt; 00:58:16,000<br>And put is basically put our access the arguments to the puts and put replies to the response.</p>
<p>595<br>00:58:16,000 –&gt; 00:58:24,000<br>Similarly, there’s a get our ex with the request one, the arguments through the request get procedure and a reply.</p>
<p>596<br>00:58:24,000 –&gt; 00:58:27,000<br>And let me first look at the server. So years are two functions.</p>
<p>597<br>00:58:27,000 –&gt; 00:58:33,000<br>You know, actually, the two function of we’re going to be calling on the server.</p>
<p>598<br>00:58:33,000 –&gt; 00:58:36,000<br>I’ll skip down for now for a second.</p>
<p>599<br>00:58:36,000 –&gt; 00:58:41,000<br>Maybe actually.</p>
<p>600<br>00:58:41,000 –&gt; 00:58:45,000<br>So let me talk about it a little bit. So this is the client site.</p>
<p>601<br>00:58:45,000 –&gt; 00:58:51,000<br>So the client calls a function get and what inside of get, you know, you.</p>
<p>602<br>00:58:51,000 –&gt; 00:58:56,000<br>And then the client calls the client to connect to the server and see the second what that means.</p>
<p>603<br>00:58:56,000 –&gt; 00:59:01,000<br>It fills in the arguments that allocates a response and then calls to this procedure client calls call.</p>
<p>604<br>00:59:01,000 –&gt; 00:59:08,000<br>You can think about this as a generic stuff that basically takes the method that needs to be called on server and the arguments and the reply.</p>
<p>605<br>00:59:08,000 –&gt; 00:59:14,000<br>And so call always has three arguments, the method, the argument and the response.</p>
<p>606<br>00:59:14,000 –&gt; 00:59:23,000<br>Call internally, we’ll send, mark shoulder arguments send the message to the server over the connection and wait for the response.</p>
<p>607<br>00:59:23,000 –&gt; 00:59:28,000<br>The reply when the reply comes in the reply struck will be filled in by the call stub.</p>
<p>608<br>00:59:28,000 –&gt; 00:59:33,000<br>And then when that’s done, then return after the call call.</p>
<p>609<br>00:59:33,000 –&gt; 00:59:37,000<br>And basically put loads exactly the same way.</p>
<p>610<br>00:59:37,000 –&gt; 00:59:39,000<br>And then the server site.</p>
<p>611<br>00:59:39,000 –&gt; 00:59:41,000<br>And let’s see how that is implemented.</p>
<p>612<br>00:59:41,000 –&gt; 00:59:47,000<br>The server has a key value map. This is nothing else than regular go map.</p>
<p>613<br>00:59:47,000 –&gt; 00:59:56,000<br>And let me see if needed key values truck.</p>
<p>614<br>00:59:56,000 –&gt; 00:59:59,000<br>And declare that somewhere.</p>
<p>615<br>00:59:59,000 –&gt; 01:00:01,000<br>Oh, sorry, it was right about that.</p>
<p>616<br>01:00:01,000 –&gt; 01:00:06,000<br>And then there’s a truck called KV that actually has a new text and a map in it.</p>
<p>617<br>01:00:06,000 –&gt; 01:00:11,000<br>And the map is like where we’re going to do the Putin get operations off.</p>
<p>618<br>01:00:11,000 –&gt; 01:00:16,000<br>And there’s a reliable pre-hemble that you need to sort of write to sort of set up a server.</p>
<p>619<br>01:00:16,000 –&gt; 01:00:19,000<br>But here it is.</p>
<p>620<br>01:00:19,000 –&gt; 01:00:23,000<br>You basically allocate a new server object.</p>
<p>621<br>01:00:23,000 –&gt; 01:00:26,000<br>And then this is the key operation.</p>
<p>622<br>01:00:26,000 –&gt; 01:00:35,000<br>And then we will register basically all the methods that are implemented on the key fee struct with the RPC server.</p>
<p>623<br>01:00:35,000 –&gt; 01:00:42,000<br>With one twist, the method only the capital main.</p>
<p>624<br>01:00:42,000 –&gt; 01:00:46,000<br>Only the methods with the capital will actually be reported.</p>
<p>625<br>01:00:46,000 –&gt; 01:00:52,000<br>And so basically go uses capital means to indicate public, you know, methods and.</p>
<p>626<br>01:00:52,000 –&gt; 01:00:57,000<br>And method with a small, you know, small caps is in private method.</p>
<p>627<br>01:00:57,000 –&gt; 01:01:02,000<br>So only, you know, basically RPC register exports only capitalized methods.</p>
<p>628<br>01:01:02,000 –&gt; 01:01:05,000<br>So example here’s a method below here’s our get method.</p>
<p>629<br>01:01:05,000 –&gt; 01:01:07,000<br>It has a capital letter.</p>
<p>630<br>01:01:07,000 –&gt; 01:01:14,000<br>And by calling register that method is now callable by applying for the connection to the server.</p>
<p>631<br>01:01:14,000 –&gt; 01:01:19,000<br>And so the server internally, you know, basically creates a TCP connection.</p>
<p>632<br>01:01:19,000 –&gt; 01:01:30,000<br>And wage zone TCP connection to get a request for a new connection request for a TCP connection and then calls RPC serve calm to serve that TCP connection.</p>
<p>633<br>01:01:30,000 –&gt; 01:01:34,000<br>And basically every message that comes in over that, you know, connection.</p>
<p>634<br>01:01:34,000 –&gt; 01:01:43,000<br>It will automatically find the right methods, you know, that is associated with the message and call that method with the unmarked arguments and unmarked reply.</p>
<p>635<br>01:01:43,000 –&gt; 01:01:51,000<br>So for example, if the client calls get, you know, connects to it, double call, it makes this connection into existence.</p>
<p>636<br>01:01:51,000 –&gt; 01:01:57,000<br>And then if the client calls call with the get, then this get function will be run.</p>
<p>637<br>01:01:57,000 –&gt; 01:02:04,000<br>And as you can see in the get function, first thing the does is that it takes a lockout because multiple clients could be calling the server.</p>
<p>638<br>01:02:04,000 –&gt; 01:02:10,000<br>And so there will be multiple goal routines running at the same time, perhaps invoking get and put.</p>
<p>639<br>01:02:10,000 –&gt; 01:02:22,000<br>And so they will manipulating the map concurrently. And so we need to make sure that, you know, those that is done in an atomic way, consider therefore use locks.</p>
<p>640<br>01:02:22,000 –&gt; 01:02:30,000<br>So the get function looks up the key into the map looks the key, what’s the key in the map and returns basically the value.</p>
<p>641<br>01:02:30,000 –&gt; 01:02:39,000<br>If there’s no entry in the map, it will return error, no key, otherwise will return the appropriate value. And that’s it.</p>
<p>642<br>01:02:39,000 –&gt; 01:02:53,000<br>And so on the server site, when this get function returns, it will marshal its response sends response back to decline decline will site of it will unmark shall it and return it to the caller.</p>
<p>643<br>01:02:53,000 –&gt; 01:03:09,000<br>Okay, so that makes sense. So that’s sort of a good simple key value server in action.</p>
<p>644<br>01:03:09,000 –&gt; 01:03:32,000<br>And I want to make one more point, which is an important point. And that in the end, what’s important to think about is what are the C’s man fix are than the failures.</p>
<p>645<br>01:03:32,000 –&gt; 01:03:38,000<br>So there are different types of semantics possible, something is called at least once.</p>
<p>646<br>01:03:38,000 –&gt; 01:03:47,000<br>And this all has to do with what does decline do if the server fails. So let’s say decline sends the request to serve a crash.</p>
<p>647<br>01:03:47,000 –&gt; 01:03:56,000<br>And of course, now at some point decline will time out and just doesn’t know what the operation actually happened or not happened.</p>
<p>648<br>01:03:56,000 –&gt; 01:04:07,000<br>At least once RPC semantics means that the client will automatically retry and will keep going until it has executed at least once.</p>
<p>649<br>01:04:07,000 –&gt; 01:04:18,000<br>The downside of course of at least once is that you know the same operation might be executed multiple times. So example, if you do a put, you know, the put might be actually executed multiple times and at least once RPC system.</p>
<p>650<br>01:04:18,000 –&gt; 01:04:28,000<br>That’s not appropriate for many applications. So another type of semantics that’s common in RPC systems is at most once.</p>
<p>651<br>01:04:28,000 –&gt; 01:04:37,000<br>So the corresponding server request actually executed either zero times once but no more than once.</p>
<p>652<br>01:04:37,000 –&gt; 01:04:44,000<br>And the way you know that is typically implemented is by filtering duplicates and you will actually doing that in.</p>
<p>653<br>01:04:44,000 –&gt; 01:04:47,000<br>Later labs.</p>
<p>654<br>01:04:47,000 –&gt; 01:05:02,000<br>Could be the case that actually both requests actually come through maybe the network was like a temporary or petitioned and the server actually gets both requests on the server has to arrange that detects a recent request and doesn’t execute it twice.</p>
<p>655<br>01:05:02,000 –&gt; 01:05:17,000<br>Ideally, you might actually want exactly once because that’s actually what the normal procedure code would be to write like if you call a procedure in your server in a normal sequential program that actually executes exactly once it’s never possible to be at least once or close ones.</p>
<p>656<br>01:05:17,000 –&gt; 01:05:20,000<br>This turns out to be actually very hard to rage.</p>
<p>657<br>01:05:20,000 –&gt; 01:05:31,000<br>This requires you know, you basically have to maintain state on this and sort of tend to be expensive and in fact practice very few RPC systems are exactly once.</p>
<p>658<br>01:05:31,000 –&gt; 01:05:39,000<br>Although in the labs, you’re going to build actually one in lab 3, you’re going to actually build an RPC system that’s basically exactly once.</p>
<p>659<br>01:05:39,000 –&gt; 01:05:41,000<br>Okay.</p>
<p>660<br>01:05:41,000 –&gt; 01:05:53,000<br>So practice goes RPC system is as much as most ones so you do a call and you do to call across a TCP channel, the TCP channel will make sure that there are no duplicates.</p>
<p>661<br>01:05:53,000 –&gt; 01:06:02,000<br>And so and RPC system will either execute once or none and all and then in the case and return an error.</p>
<p>662<br>01:06:02,000 –&gt; 01:06:10,000<br>And then of course the application may retry, but now it’s the application responsibility to deal with the problems with duplication and failed messages.</p>
<p>663<br>01:06:10,000 –&gt; 01:06:21,000<br>Okay, so here’s the sort of the key point correct the fact that the failures basically makes your RPCs not identical to procedure calls.</p>
<p>664<br>01:06:21,000 –&gt; 01:06:35,000<br>So you know that the goal is to make them look as similar as possible. They’re actually not identical and really the thing that exposes that differences is the failures of the surface crashing.</p>
<p>665<br>01:06:35,000 –&gt; 01:06:47,000<br>Any quick questions about this quick intro for RPC.</p>
<p>666<br>01:06:47,000 –&gt; 01:06:59,000<br>So if not, then I want to stop the lecture here so that people that need to go or students need to go to the next class, they can go to the next class. I’ll be hanging around. So if there’s any more questions, I’ll be happy to.</p>
<p>667<br>01:06:59,000 –&gt; 01:07:03,000<br>To enter that and stick around for a little while.</p>
<p>668<br>01:07:03,000 –&gt; 01:07:07,000<br>And meantime, enjoy lap one and good luck with it.</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>MIT6824 P2Lecture2RPCandThreads</div>
      <div>http://example.com/2025/10/25/MIT6824 P2Lecture2RPCandThreads/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/25/MIT6824%20P3Lecture3GFS/" title="MIT6824 P3Lecture3GFS">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">MIT6824 P3Lecture3GFS</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/25/MIT6824%20P21Lecture20-Blockstack/" title="MIT6824 P21Lecture20 Blockstack">
                        <span class="hidden-mobile">MIT6824 P21Lecture20 Blockstack</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
