

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="100:00:00,000 –&gt; 00:00:08,000Another popular collision resolution method is known as linear probing. 200:00:08,000 –&gt; 00:00:13,000There’s many different versions of hashing that are based on thi">
<meta property="og:type" content="article">
<meta property="og:title" content="PrincetonAlgorithms P54Part112 05_linear Probing">
<meta property="og:url" content="http://example.com/2025/10/25/PrincetonAlgorithms%20P54Part112-05_linear-probing/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="100:00:00,000 –&gt; 00:00:08,000Another popular collision resolution method is known as linear probing. 200:00:08,000 –&gt; 00:00:13,000There’s many different versions of hashing that are based on thi">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-25T05:03:39.829Z">
<meta property="article:modified_time" content="2025-10-25T05:03:39.830Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>PrincetonAlgorithms P54Part112 05_linear Probing - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="PrincetonAlgorithms P54Part112 05_linear Probing"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-25 13:03" pubdate>
          2025年10月25日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          1.2k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          10 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">PrincetonAlgorithms P54Part112 05_linear Probing</h1>
            
            
              <div class="markdown-body">
                
                <p>1<br>00:00:00,000 –&gt; 00:00:08,000<br>Another popular collision resolution method is known as linear probing.</p>
<p>2<br>00:00:08,000 –&gt; 00:00:13,000<br>There’s many different versions of hashing that are based on this idea.</p>
<p>3<br>00:00:13,000 –&gt; 00:00:17,000<br>With linear probing, it’s called open addressing.</p>
<p>4<br>00:00:17,000 –&gt; 00:00:22,000<br>It’s also around the same time in the 50s.</p>
<p>5<br>00:00:22,000 –&gt; 00:00:29,000<br>The idea is to just use an array instead of using space for the length in a linked list.</p>
<p>6<br>00:00:29,000 –&gt; 00:00:33,000<br>Use that same space and just allocate an array.</p>
<p>7<br>00:00:33,000 –&gt; 00:00:40,000<br>In this case, the size of the array is going to have to be bigger than the number of keys that we expect.</p>
<p>8<br>00:00:40,000 –&gt; 00:00:53,000<br>We use empty slots in the array to essentially terminate the length of the list that we have to search through when we’re doing a insertion.</p>
<p>9<br>00:00:53,000 –&gt; 00:00:56,000<br>Let’s look at a demo of how it looks.</p>
<p>10<br>00:00:56,000 –&gt; 00:00:59,000<br>To hash again, we do the same thing.</p>
<p>11<br>00:00:59,000 –&gt; 00:01:02,000<br>We just map the key to an index.</p>
<p>12<br>00:01:02,000 –&gt; 00:01:07,000<br>In linear probing, to its cert, what we do is we put it in position i.</p>
<p>13<br>00:01:07,000 –&gt; 00:01:16,000<br>If that’s free, if not, we just look at i plus one and i plus two and wrap around to the beginning if we reach the end.</p>
<p>14<br>00:01:16,000 –&gt; 00:01:19,000<br>That’s also very simple to implement.</p>
<p>15<br>00:01:19,000 –&gt; 00:01:24,000<br>It works well as long as the size of the array is significantly bigger than the number of keys.</p>
<p>16<br>00:01:24,000 –&gt; 00:01:28,000<br>Let’s look at an demo.</p>
<p>17<br>00:01:28,000 –&gt; 00:01:31,000<br>Start with an empty table and insert s.</p>
<p>18<br>00:01:31,000 –&gt; 00:01:34,000<br>It’s hash value is six. Six is empty.</p>
<p>19<br>00:01:34,000 –&gt; 00:01:35,000<br>We put it there.</p>
<p>20<br>00:01:35,000 –&gt; 00:01:39,000<br>Now we look at e. Hash of e is ten.</p>
<p>21<br>00:01:39,000 –&gt; 00:01:42,000<br>We look at ten. It’s empty. We put e there.</p>
<p>22<br>00:01:42,000 –&gt; 00:01:45,000<br>At the beginning, we’re going to be fine.</p>
<p>23<br>00:01:45,000 –&gt; 00:01:49,000<br>A is four. Empty. Put it there.</p>
<p>24<br>00:01:49,000 –&gt; 00:01:54,000<br>R is fourteen. Empty. Put it there.</p>
<p>25<br>00:01:54,000 –&gt; 00:02:00,000<br>We’re just essentially using the hash function as an array index.</p>
<p>26<br>00:02:00,000 –&gt; 00:02:05,000<br>C is five. That’s empty. And we put it there.</p>
<p>27<br>00:02:05,000 –&gt; 00:02:09,000<br>H now. The hash value of h is four.</p>
<p>28<br>00:02:09,000 –&gt; 00:02:12,000<br>Now we look at four and that’s occupied.</p>
<p>29<br>00:02:12,000 –&gt; 00:02:14,000<br>We can’t put the h there.</p>
<p>30<br>00:02:14,000 –&gt; 00:02:17,000<br>Then linear probing says just look at the next position.</p>
<p>31<br>00:02:17,000 –&gt; 00:02:21,000<br>Look at five. That’s still not empty.</p>
<p>32<br>00:02:21,000 –&gt; 00:02:26,000<br>We look at six. We keep going until we find an empty place and then we put h there.</p>
<p>33<br>00:02:26,000 –&gt; 00:02:29,000<br>When we search, we’re going to have to do the same thing.</p>
<p>34<br>00:02:29,000 –&gt; 00:02:33,000<br>We’re going to have to look at all those positions to look at h.</p>
<p>35<br>00:02:33,000 –&gt; 00:02:40,000<br>A group of four key contiguous keys in a table space there is called a cluster.</p>
<p>36<br>00:02:40,000 –&gt; 00:02:44,000<br>Clearly we want to keep those clusters small.</p>
<p>37<br>00:02:44,000 –&gt; 00:02:48,000<br>We do that by just not putting too many keys into the table.</p>
<p>38<br>00:02:48,000 –&gt; 00:02:54,000<br>So x hashes to fifteen. That’s empty. So we put it there.</p>
<p>39<br>00:02:54,000 –&gt; 00:03:00,000<br>Em hashes to one. That’s empty. And we put it there.</p>
<p>40<br>00:03:00,000 –&gt; 00:03:03,000<br>P hashes to fourteen.</p>
<p>41<br>00:03:03,000 –&gt; 00:03:06,000<br>Fourteen occupied.</p>
<p>42<br>00:03:06,000 –&gt; 00:03:08,000<br>Fifteen is also occupied.</p>
<p>43<br>00:03:08,000 –&gt; 00:03:11,000<br>Now we run off the end of the table and look at zero.</p>
<p>44<br>00:03:11,000 –&gt; 00:03:15,000<br>And that’s empty. So we put it there.</p>
<p>45<br>00:03:15,000 –&gt; 00:03:19,000<br>L hashes to six. Six is occupied.</p>
<p>46<br>00:03:19,000 –&gt; 00:03:26,000<br>We look at seven. Seven is occupied. We look at eight. And we put it there.</p>
<p>47<br>00:03:26,000 –&gt; 00:03:32,000<br>And so that’s an example of inserting keys into a hash table.</p>
<p>48<br>00:03:32,000 –&gt; 00:03:35,000<br>And now for search we just do the same thing.</p>
<p>49<br>00:03:35,000 –&gt; 00:03:40,000<br>We use the hash function to search for e.</p>
<p>50<br>00:03:40,000 –&gt; 00:03:44,000<br>E’s hash value is ten. So we look in ten and there it is.</p>
<p>51<br>00:03:44,000 –&gt; 00:03:47,000<br>So that’s a search it.</p>
<p>52<br>00:03:47,000 –&gt; 00:03:52,000<br>If we’re going to search for say L, L’s hash value is six.</p>
<p>53<br>00:03:52,000 –&gt; 00:03:55,000<br>So it’s not there.</p>
<p>54<br>00:03:55,000 –&gt; 00:04:00,000<br>So in order to look at every place in the table where L could be,</p>
<p>55<br>00:04:00,000 –&gt; 00:04:06,000<br>we have to keep looking until we find an empty table position or we find L itself.</p>
<p>56<br>00:04:06,000 –&gt; 00:04:10,000<br>So now we look at seven. L’s not there. We look at eight. L is there.</p>
<p>57<br>00:04:10,000 –&gt; 00:04:13,000<br>That’s a search it.</p>
<p>58<br>00:04:13,000 –&gt; 00:04:19,000<br>If we have a value that’s not in the table like K, well, we’ll hash.</p>
<p>59<br>00:04:19,000 –&gt; 00:04:27,000<br>And is it in position five? No. Six, no. Seven, no. Eight, no.</p>
<p>60<br>00:04:27,000 –&gt; 00:04:32,000<br>And we find an empty position. At that point we can conclude that K is not in the table.</p>
<p>61<br>00:04:32,000 –&gt; 00:04:37,000<br>Because if K were in the table, it would be somewhere between its hash point five</p>
<p>62<br>00:04:37,000 –&gt; 00:04:42,000<br>and that empty position nine. That’s a search missing and we return null.</p>
<p>63<br>00:04:42,000 –&gt; 00:04:47,000<br>So that’s a short demo of linear probing hashing.</p>
<p>64<br>00:04:47,000 –&gt; 00:04:52,000<br>So here’s a summary of linear probing hashing.</p>
<p>65<br>00:04:52,000 –&gt; 00:05:02,000<br>To get started, we map a key to an integer between zero and m minus one where m is the size of our array where we’re storing the keys.</p>
<p>66<br>00:05:02,000 –&gt; 00:05:11,000<br>To insert, we put the key value pair, use parallel arrays, the key and one array and a value and array with the same index.</p>
<p>67<br>00:05:11,000 –&gt; 00:05:20,000<br>And we put the entry at table index a if it’s free. If not, you try i plus one i plus two until getting to an empty position.</p>
<p>68<br>00:05:20,000 –&gt; 00:05:31,000<br>And for search, you do the same thing. You hash to the table position and you look there and to the right to find the key and you stop when you find an empty table position.</p>
<p>69<br>00:05:31,000 –&gt; 00:05:34,000<br>Find the key or find an empty table position.</p>
<p>70<br>00:05:34,000 –&gt; 00:05:51,000<br>Now, it’s essential that the array size is greater than the number of key value pairs and for linear probing hashing really the implementation needs to include arrays resizing whenever the hash table gets too full.</p>
<p>71<br>00:05:51,000 –&gt; 00:05:59,000<br>Usually as we’ll see, it’s a good idea to make sure that it stays at least half empty.</p>
<p>72<br>00:05:59,000 –&gt; 00:06:08,000<br>Here’s the implementation and it’s quite straightforward given the demo that we talked about. Use the same hash function.</p>
<p>73<br>00:06:08,000 –&gt; 00:06:18,000<br>We use parallel arrays for the value and the keys and we have to use ugly cast because we can have a raise of generics.</p>
<p>74<br>00:06:18,000 –&gt; 00:06:30,000<br>Then let’s do the search. So we just have a for loop, starring at hash of key and going until we get to a position that’s null.</p>
<p>75<br>00:06:30,000 –&gt; 00:06:37,000<br>As long as it’s not null, we stay in the loop and increment i mod m. So that’s when I gets to the end.</p>
<p>76<br>00:06:37,000 –&gt; 00:06:49,000<br>I said position m minus one, then it goes next increment goes back to zero to the left end of the table and we just test for all the non null keys.</p>
<p>77<br>00:06:49,000 –&gt; 00:06:58,000<br>If it’s equal and if it is, go ahead and return the associated value. And if you get to an empty position, then I return null.</p>
<p>78<br>00:06:58,000 –&gt; 00:07:11,000<br>And the implementation of put is similar. Find a position if it’s that’s equal and then reset the key and the value.</p>
<p>79<br>00:07:11,000 –&gt; 00:07:17,000<br>If the key is there, it just resets the value. If he’s not there, it puts a new entry in.</p>
<p>80<br>00:07:17,000 –&gt; 00:07:30,000<br>So again, that’s a fairly little code to implement a fast symbol table and insert search and insert. But it’s only going to be fast if the table size is set appropriately.</p>
<p>81<br>00:07:30,000 –&gt; 00:07:42,000<br>In ancient times, memory was at quite a premium and so people were very concerned in making sure that the hash table never got too empty.</p>
<p>82<br>00:07:42,000 –&gt; 00:07:50,000<br>Remember in the first computers, each bit was a physical thing, a magnetic core that somebody had to string a wire through.</p>
<p>83<br>00:07:50,000 –&gt; 00:08:05,000<br>So the bits were really expensive and people wanted to make sure that they were making best use in the memory. And just leaving empty positions around in a hash table or using links in a link list did not seem like an appropriate use of space.</p>
<p>84<br>00:08:05,000 –&gt; 00:08:18,000<br>So there was quite a bit of effort devoted to figuring it out how full we could get the hash table in linear probing and how close it could get to being full without sacrificing performance.</p>
<p>85<br>00:08:18,000 –&gt; 00:08:28,000<br>And one way to think about what goes on is to just watch what happens when a hash table fills up.</p>
<p>86<br>00:08:28,000 –&gt; 00:08:46,000<br>So here we’re just as it goes up, we’re showing each key getting inserted and the number of probes of the table that are needed for the insertion. So J has to the same position at A and it had to look for a while.</p>
<p>87<br>00:08:46,000 –&gt; 00:08:56,000<br>And one thing to notice as the table gets full is that first of all you have these clusters of these chains building.</p>
<p>88<br>00:08:56,000 –&gt; 00:09:15,000<br>So what’s clear about that is that it means that the new hash is likely to hash into a big cluster. And not only that, once you have a big cluster and you hash into the middle of it, you’ve got a good chance that that cluster is going to get longer or worse that it’s even going to merge.</p>
<p>89<br>00:09:15,000 –&gt; 00:09:28,000<br>And so that’s the situation as the table fills up. You get long clusters and they’re likely to get longer in the math bears that out.</p>
<p>90<br>00:09:28,000 –&gt; 00:09:41,000<br>Now this was studied in detail by Knuth in the 1960s and actually this problem Knuth says was really the origin of analysis of algorithms.</p>
<p>91<br>00:09:41,000 –&gt; 00:09:53,000<br>Mathematicians were trying hard to understand this problem and were ready to give up and he realized that you could use classical balls and bins type probabilistic analysis.</p>
<p>92<br>00:09:53,000 –&gt; 00:10:10,000<br>Not an easy analysis, but we actually could make and precise accurate statements about the performance of this algorithm. And those statements could be born out in practice because the hash functions approximate random, the math assumes random.</p>
<p>93<br>00:10:10,000 –&gt; 00:10:23,000<br>And the formulas predict what actually happened in practice. The way Knuth formulated the problem is a so called parking problem. So what happens here to one way street and you’re looking for a parking place.</p>
<p>94<br>00:10:23,000 –&gt; 00:10:36,000<br>And it’s the ideas you start looking for parking place at a particular time say, okay, now we need a parking place. And what you’re doing is linear probing hashing.</p>
<p>95<br>00:10:36,000 –&gt; 00:10:52,000<br>If the current space is taken, you try the next space and the one after and so forth. And the question is, if every car starts looking for a place at a random time that models the hash function, then how far do they have to go?</p>
<p>96<br>00:10:52,000 –&gt; 00:11:14,000<br>Look for a place. That’s Knuth’s parking problem. And he was able to show and we’ll talk just a little bit about this that if there’s only half of the parking spaces are occupied, then on average, half the people find it after one place and the other half have to look one extra.</p>
<p>97<br>00:11:14,000 –&gt; 00:11:31,000<br>So that’s the kind of performance that we want. But as it gets full, the displacement gets up to square root of pi m over 8, which is obviously much higher than we want. We don’t want our searches to take that long.</p>
<p>98<br>00:11:31,000 –&gt; 00:11:43,000<br>And that actually the analysis is an amazing function that goes back to the famous Ramanujan and other classical results from a common tutorial analysis.</p>
<p>99<br>00:11:43,000 –&gt; 00:12:04,000<br>What Knuth’s theorem says is that under the uniform hashing assumption, the number of probes in the linear hash table of size m that is alpha percent full. So the number of keys is a fraction of m is for a search miss half one plus one over alpha.</p>
<p>100<br>00:12:04,000 –&gt; 00:12:21,000<br>One minus alpha squared one minus alpha for the hit one minus alpha squared for the insert. Now as alpha gets close to one, you can see these things are going to grow. And particularly the search miss is going to grow quite a bit.</p>
<p>101<br>00:12:21,000 –&gt; 00:12:48,000<br>If it’s nine tenths full one over one minus alpha squared is one over a hundred. So it means it’s going to be 50 probes for a search miss if it’s nine tenths full. And that’s independent of n and m. Whereas if it’s half full, then we get the nice numbers of only three halves for a hit and only five halves for a miss.</p>
<p>102<br>00:12:48,000 –&gt; 00:13:08,000<br>And again, these formulas are a nice approximate formulas. But Knuth once he figured this out in 1963 tells the story is at that time he decided to write his famous series of books on algorithms.</p>
<p>103<br>00:13:08,000 –&gt; 00:13:19,000<br>And now there’s four volumes out and more planned. And this is where all computer scientists go for detailed information on the performance of algorithms.</p>
<p>104<br>00:13:19,000 –&gt; 00:13:36,000<br>So in summary, you can’t have m to large. What we want to use is in nowadays is array resizing to make sure that the array is always about half time half full.</p>
<p>105<br>00:13:36,000 –&gt; 00:13:47,000<br>And if we can keep the array about half full, then we get constant time performance for search hit and search miss and linear probing is very attractive in this case.</p>
<p>106<br>00:13:47,000 –&gt; 00:14:05,000<br>There’s other things that we can do algorithmically to bring down the search time a little bit like using another hash function rather than looking at the next entry use another hash function to determine the stride that we’re going to use. And that brings it down somewhat and allows us to keep the tables more full.</p>
<p>107<br>00:14:05,000 –&gt; 00:14:25,000<br>But the bottom line is that now we have two methods that under the uniform hashing assumption can give us constant time search search hit insert and delete for symbol table implementations where we don’t need ordering and we’ve got a reasonable hash function.</p>
<p>108<br>00:14:25,000 –&gt; 00:14:32,000<br>So that’s a summary of linear probing our second hash collision avoidance strategy.</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>PrincetonAlgorithms P54Part112 05_linear Probing</div>
      <div>http://example.com/2025/10/25/PrincetonAlgorithms P54Part112-05_linear-probing/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/25/PrincetonAlgorithms%20P50Part111-05_interval-search-trees/" title="PrincetonAlgorithms P50Part111 05_interval Search Trees">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">PrincetonAlgorithms P50Part111 05_interval Search Trees</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/25/PrincetonAlgorithms%20P48Part111-03_line-segment-intersection/" title="PrincetonAlgorithms P48Part111 03_line Segment Intersection">
                        <span class="hidden-mobile">PrincetonAlgorithms P48Part111 03_line Segment Intersection</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
