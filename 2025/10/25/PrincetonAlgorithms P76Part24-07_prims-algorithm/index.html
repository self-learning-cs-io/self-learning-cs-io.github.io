

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="100:00:00,000 –&gt; 00:00:10,380Next we’ll look at another classic algorithm for computing the MST called Prims algorithm. 200:00:10,380 –&gt; 00:00:18,120It’s also an extremely simple algorithm to st">
<meta property="og:type" content="article">
<meta property="og:title" content="PrincetonAlgorithms P76Part24 07_prims Algorithm">
<meta property="og:url" content="http://example.com/2025/10/25/PrincetonAlgorithms%20P76Part24-07_prims-algorithm/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="100:00:00,000 –&gt; 00:00:10,380Next we’ll look at another classic algorithm for computing the MST called Prims algorithm. 200:00:10,380 –&gt; 00:00:18,120It’s also an extremely simple algorithm to st">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-25T05:03:39.836Z">
<meta property="article:modified_time" content="2025-10-25T05:03:39.836Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>PrincetonAlgorithms P76Part24 07_prims Algorithm - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="PrincetonAlgorithms P76Part24 07_prims Algorithm"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-25 13:03" pubdate>
          2025年10月25日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          3.6k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          31 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">PrincetonAlgorithms P76Part24 07_prims Algorithm</h1>
            
            
              <div class="markdown-body">
                
                <p>1<br>00:00:00,000 –&gt; 00:00:10,380<br>Next we’ll look at another classic algorithm for computing the MST called Prims algorithm.</p>
<p>2<br>00:00:10,380 –&gt; 00:00:18,120<br>It’s also an extremely simple algorithm to state what we’re going to do now is start with</p>
<p>3<br>00:00:18,120 –&gt; 00:00:24,900<br>Vertex 0 and we’re going to grow the tree one edge at a time always keeping it connected.</p>
<p>4<br>00:00:24,899 –&gt; 00:00:31,339<br>The way we’re going to do that is add to the tree the minimum weight edge that has exactly</p>
<p>5<br>00:00:31,339 –&gt; 00:00:34,379<br>one endpoint in the tree computed so far.</p>
<p>6<br>00:00:34,379 –&gt; 00:00:39,219<br>And we’ll keep doing that until we’ve grown the whole V-1 edge tree.</p>
<p>7<br>00:00:39,219 –&gt; 00:00:42,820<br>Let’s look at a demo to see how that works.</p>
<p>8<br>00:00:42,820 –&gt; 00:00:47,939<br>So we start with Vertex 0 and we’re supposed to add the min-weight edge that’s connected to</p>
<p>9<br>00:00:47,939 –&gt; 00:00:48,939<br>0.</p>
<p>10<br>00:00:48,939 –&gt; 00:00:53,460<br>So that’s 0, 7.</p>
<p>11<br>00:00:53,460 –&gt; 00:00:57,380<br>Out of all the edges connected to 0 that’s the one of minimum weight.</p>
<p>12<br>00:00:57,380 –&gt; 00:01:03,140<br>So now we have one edge two vertices on the tree and so now we want to add the min-weight</p>
<p>13<br>00:01:03,140 –&gt; 00:01:05,819<br>edge that connects to the tree.</p>
<p>14<br>00:01:05,819 –&gt; 00:01:11,859<br>In this case that’s 7-1 out of all the edges that connect to the tree, 1-7 is the shortest</p>
<p>15<br>00:01:11,859 –&gt; 00:01:13,780<br>one so that’s the one that we add.</p>
<p>16<br>00:01:13,780 –&gt; 00:01:17,540<br>So now we have two edges on the tree.</p>
<p>17<br>00:01:17,540 –&gt; 00:01:23,300<br>Now the min-weight edge that connects to the tree is 0, 2.</p>
<p>18<br>00:01:23,300 –&gt; 00:01:25,300<br>So we add that one.</p>
<p>19<br>00:01:25,300 –&gt; 00:01:29,020<br>So now we have three edges four vertices on the tree.</p>
<p>20<br>00:01:29,020 –&gt; 00:01:34,580<br>Closest edge, closest vertex to the tree or the smallest edge coming out of the tree is</p>
<p>21<br>00:01:34,580 –&gt; 00:01:35,580<br>two-three.</p>
<p>22<br>00:01:35,580 –&gt; 00:01:37,620<br>So we add that one.</p>
<p>23<br>00:01:37,620 –&gt; 00:01:39,820<br>So now we have three more vertices to go.</p>
<p>24<br>00:01:39,820 –&gt; 00:01:43,620<br>And you can see that the next one that’s going to come is five.</p>
<p>25<br>00:01:43,620 –&gt; 00:01:47,620<br>It’s closer to the tree than four or six.</p>
<p>26<br>00:01:47,620 –&gt; 00:01:49,340<br>So we do that.</p>
<p>27<br>00:01:49,340 –&gt; 00:01:50,340<br>Add five.</p>
<p>28<br>00:01:50,340 –&gt; 00:01:52,980<br>Now there’s two more.</p>
<p>29<br>00:01:52,980 –&gt; 00:02:00,420<br>And so out of all those edges, the closest one to the tree is four-five.</p>
<p>30<br>00:02:00,420 –&gt; 00:02:03,620<br>It’s a little shorter than four-seven and zero-four.</p>
<p>31<br>00:02:03,620 –&gt; 00:02:05,900<br>So that’s the one that gets added.</p>
<p>32<br>00:02:05,900 –&gt; 00:02:10,180<br>And then finally six gets added to the tree by the shortest edge that connects it to</p>
<p>33<br>00:02:10,180 –&gt; 00:02:12,819<br>the tree which is six-two.</p>
<p>34<br>00:02:12,819 –&gt; 00:02:16,459<br>So start with vertex zero.</p>
<p>35<br>00:02:16,459 –&gt; 00:02:18,699<br>Add an edge at a time to the tree.</p>
<p>36<br>00:02:18,699 –&gt; 00:02:23,659<br>It’s the shortest edge that goes from a tree vertex to a non-tree vertex.</p>
<p>37<br>00:02:23,659 –&gt; 00:02:25,419<br>That’s prims algorithm.</p>
<p>38<br>00:02:25,419 –&gt; 00:02:30,979<br>Now let’s look at prims algorithm running on the same huge graph that we went for cross-gross</p>
<p>39<br>00:02:30,979 –&gt; 00:02:32,299<br>scales.</p>
<p>40<br>00:02:32,299 –&gt; 00:02:39,419<br>This also is a fascinating dynamic process.</p>
<p>41<br>00:02:39,419 –&gt; 00:02:46,219<br>Actually the new edge is close to the last edge added but every once in a while it gets</p>
<p>42<br>00:02:46,219 –&gt; 00:02:47,219<br>stuck.</p>
<p>43<br>00:02:47,219 –&gt; 00:02:52,259<br>And so jumps to a new place to add edges to the MST.</p>
<p>44<br>00:02:52,259 –&gt; 00:02:55,779<br>This algorithm is a little bit easier to follow.</p>
<p>45<br>00:02:55,779 –&gt; 00:03:03,459<br>But it’s a very interesting dynamic process.</p>
<p>46<br>00:03:03,459 –&gt; 00:03:08,099<br>You can see that when it’s easy, it just sticks where it was.</p>
<p>47<br>00:03:08,099 –&gt; 00:03:13,500<br>When it runs into some long edges, it gets stuck and tries somewhere else.</p>
<p>48<br>00:03:13,500 –&gt; 00:03:18,659<br>Always adding to the tree the shortest edge that connects a non-tree vertex to a tree</p>
<p>49<br>00:03:18,659 –&gt; 00:03:21,259<br>vertex.</p>
<p>50<br>00:03:21,259 –&gt; 00:03:27,780<br>And you can see the last few things to be added where the vertices in the upper left corner.</p>
<p>51<br>00:03:27,780 –&gt; 00:03:31,780<br>That’s a visualization of prims algorithm, completely different character but it comes</p>
<p>52<br>00:03:31,780 –&gt; 00:03:38,780<br>out to the same tree as cross-grossalism as long as the edge weights are distinct.</p>
<p>53<br>00:03:38,780 –&gt; 00:03:42,979<br>So we need to prove prims algorithm correct.</p>
<p>54<br>00:03:42,979 –&gt; 00:03:53,340<br>And this one has been rediscovered a few times depending on how you cast the data structure</p>
<p>55<br>00:03:53,340 –&gt; 00:03:56,259<br>for implementing, finding the minimum.</p>
<p>56<br>00:03:56,259 –&gt; 00:04:02,419<br>But the basic algorithm has been known since at least 1930 and it’s a proof that it</p>
<p>57<br>00:04:02,419 –&gt; 00:04:09,379<br>computes the MST again comes because it’s a special case of the greedy MST algorithm.</p>
<p>58<br>00:04:09,379 –&gt; 00:04:18,339<br>So let’s suppose that E is the men-want weight edge connecting a vertex on the tree to a vertex</p>
<p>59<br>00:04:18,339 –&gt; 00:04:20,300<br>not on the tree.</p>
<p>60<br>00:04:20,300 –&gt; 00:04:28,020<br>Well you take as you cut the tree vertices, there’s no black crossing edge from the tree</p>
<p>61<br>00:04:28,020 –&gt; 00:04:30,300<br>vertices to non-tree vertex.</p>
<p>62<br>00:04:30,300 –&gt; 00:04:33,900<br>That’s the definition, it’s not on the tree.</p>
<p>63<br>00:04:33,900 –&gt; 00:04:40,220<br>And there’s no crossing edge of low weight because that’s the minimum one that’s we picked</p>
<p>64<br>00:04:40,220 –&gt; 00:04:41,220<br>by design.</p>
<p>65<br>00:04:41,220 –&gt; 00:04:46,220<br>So it’s a special case of the greedy algorithm where you take as the cut the set of vertices</p>
<p>66<br>00:04:46,220 –&gt; 00:04:47,819<br>currently on the tree.</p>
<p>67<br>00:04:47,819 –&gt; 00:04:50,019<br>That’s prims algorithm.</p>
<p>68<br>00:04:50,019 –&gt; 00:04:54,019<br>Now how are we going to implement prims algorithm?</p>
<p>69<br>00:04:54,019 –&gt; 00:04:59,219<br>How are we going to find the minimum weight edge with exactly one point in T?</p>
<p>70<br>00:04:59,219 –&gt; 00:05:06,219<br>Well one thing that we could do is just try all the edges and maybe some early implementations</p>
<p>71<br>00:05:06,219 –&gt; 00:05:08,620<br>that would do that.</p>
<p>72<br>00:05:08,620 –&gt; 00:05:13,579<br>But what we’re going to do is use a modern data structure, a priority queue.</p>
<p>73<br>00:05:13,579 –&gt; 00:05:20,539<br>So we’re going to keep the edges on a priority queue, have exactly one end point in T and</p>
<p>74<br>00:05:20,539 –&gt; 00:05:24,339<br>then we can just pick out the minimum weight one.</p>
<p>75<br>00:05:24,339 –&gt; 00:05:27,699<br>That’s the so-called lazy implementation of prims algorithm.</p>
<p>76<br>00:05:27,699 –&gt; 00:05:32,139<br>We’ll look at another one called the eager implementation afterwards.</p>
<p>77<br>00:05:32,139 –&gt; 00:05:36,939<br>So what we need to do is find the minimum weight edge with exactly one end point in the</p>
<p>78<br>00:05:36,939 –&gt; 00:05:37,939<br>tree.</p>
<p>79<br>00:05:38,019 –&gt; 00:05:43,899<br>So the solution is to make a priority queue of the edges that have at least one end point</p>
<p>80<br>00:05:43,899 –&gt; 00:05:45,459<br>in the tree.</p>
<p>81<br>00:05:45,459 –&gt; 00:05:50,980<br>And then we’re using as priority the keys the edge and the priorities the weight of the</p>
<p>82<br>00:05:50,980 –&gt; 00:05:52,620<br>edge.</p>
<p>83<br>00:05:52,620 –&gt; 00:06:00,379<br>And so we’re going to use delete min to find the next edge to add to the tree.</p>
<p>84<br>00:06:00,379 –&gt; 00:06:08,219<br>And then we have to update the priority queue when we consider that edge.</p>
<p>85<br>00:06:08,219 –&gt; 00:06:13,819<br>Now there’s going to be some edges on the priority queue that are obsolete and we’ve already</p>
<p>86<br>00:06:13,819 –&gt; 00:06:16,259<br>found better ways to connect them.</p>
<p>87<br>00:06:16,259 –&gt; 00:06:22,980<br>So we’ll just disregard an edge that has both end points in the tree.</p>
<p>88<br>00:06:22,980 –&gt; 00:06:27,139<br>We’ve already found a way to connect them.</p>
<p>89<br>00:06:27,139 –&gt; 00:06:32,459<br>We don’t need that edge for the minimum spanning tree.</p>
<p>90<br>00:06:32,459 –&gt; 00:06:34,860<br>That’s why it’s called a lazy implementation.</p>
<p>91<br>00:06:34,860 –&gt; 00:06:39,899<br>We allow stuff to be on the priority queue that we know is obsolete.</p>
<p>92<br>00:06:39,899 –&gt; 00:06:44,579<br>And then when we pull it off the queue we test whether it belongs in the tree or not.</p>
<p>93<br>00:06:44,579 –&gt; 00:06:50,979<br>But then the key step in the algorithm is to assume what do you do when you get a new</p>
<p>94<br>00:06:50,979 –&gt; 00:06:54,500<br>vertex for the minimum spanning tree in a new edge.</p>
<p>95<br>00:06:54,500 –&gt; 00:06:58,420<br>So that means that one of the vertices is on the tree.</p>
<p>96<br>00:06:58,420 –&gt; 00:07:01,540<br>Let’s say that’s v and the other one is not on the tree.</p>
<p>97<br>00:07:01,540 –&gt; 00:07:03,180<br>That means w.</p>
<p>98<br>00:07:03,180 –&gt; 00:07:06,819<br>And so what we want to do is add w to the tree.</p>
<p>99<br>00:07:06,819 –&gt; 00:07:12,899<br>But then we also want to add to the priority queue any edge that’s incident to w.</p>
<p>100<br>00:07:12,899 –&gt; 00:07:17,660<br>So that’s got the possibility as long as this other end point is not in the tree.</p>
<p>101<br>00:07:17,660 –&gt; 00:07:24,380<br>So those edges have the possibility of being minimum spanning tree edges in the future</p>
<p>102<br>00:07:24,380 –&gt; 00:07:30,900<br>unless some better way to connect their incident vertex to the tree is found before they come</p>
<p>103<br>00:07:30,900 –&gt; 00:07:32,500<br>off the queue.</p>
<p>104<br>00:07:32,500 –&gt; 00:07:36,580<br>That’s the algorithm, the lazy solution of prims algorithm.</p>
<p>105<br>00:07:36,580 –&gt; 00:07:38,820<br>So let’s take a demo of that.</p>
<p>106<br>00:07:38,820 –&gt; 00:07:43,300<br>So what we’re going to do is start with a vertex and really grow the tree.</p>
<p>107<br>00:07:43,300 –&gt; 00:07:47,580<br>Add to the T the min-weight edge with exactly one endpoint in the tree.</p>
<p>108<br>00:07:47,579 –&gt; 00:07:49,419<br>That’s prims algorithm.</p>
<p>109<br>00:07:49,419 –&gt; 00:07:55,139<br>But now we’re going to show the data structure of the priority queue that allows us to do this</p>
<p>110<br>00:07:55,139 –&gt; 00:08:00,579<br>by keeping all the edges that we know about the connect that possibly could be that edge</p>
<p>111<br>00:08:00,579 –&gt; 00:08:02,860<br>on a priority queue.</p>
<p>112<br>00:08:02,860 –&gt; 00:08:06,659<br>So let’s look at what happens for our sample graph.</p>
<p>113<br>00:08:06,659 –&gt; 00:08:08,139<br>So we start it vertex zero.</p>
<p>114<br>00:08:08,139 –&gt; 00:08:09,779<br>That’s fine.</p>
<p>115<br>00:08:09,779 –&gt; 00:08:16,219<br>Now we’re going to add that to the tree, vertex zero to the tree.</p>
<p>116<br>00:08:16,220 –&gt; 00:08:21,580<br>We’re going to put on the priority queue all the edges that are incident to zero.</p>
<p>117<br>00:08:21,580 –&gt; 00:08:27,260<br>And just for the demo, we’ll just show the edges sorted by weight with the understanding</p>
<p>118<br>00:08:27,260 –&gt; 00:08:32,060<br>that we have a heap data structure or something under there to give us the smallest one.</p>
<p>119<br>00:08:32,060 –&gt; 00:08:36,220<br>But for the demo, it’s easiest to see them sorted by weight.</p>
<p>120<br>00:08:36,220 –&gt; 00:08:37,220<br>Okay.</p>
<p>121<br>00:08:37,220 –&gt; 00:08:43,899<br>So then to greenly grow the tree, we have to pick zero seven off the priority queue.</p>
<p>122<br>00:08:43,899 –&gt; 00:08:49,419<br>So we’ll show that one on the MST.</p>
<p>123<br>00:08:49,419 –&gt; 00:08:57,419<br>And then the vertex that’s not on the tree at that point is seven.</p>
<p>124<br>00:08:57,419 –&gt; 00:09:01,059<br>So we’re going to add seven to the tree.</p>
<p>125<br>00:09:01,059 –&gt; 00:09:04,259<br>So first we add zero seven to be an MST edge.</p>
<p>126<br>00:09:04,259 –&gt; 00:09:09,939<br>And then we add to the priority queue all the edges that are incident to seven.</p>
<p>127<br>00:09:09,940 –&gt; 00:09:17,780<br>That all the edges incident to seven that point to places the vertices that are not on the tree</p>
<p>128<br>00:09:17,780 –&gt; 00:09:19,620<br>that are connected to vertices that are not on the tree.</p>
<p>129<br>00:09:19,620 –&gt; 00:09:23,940<br>So we don’t put zero seven back on because zero is already on the tree.</p>
<p>130<br>00:09:23,940 –&gt; 00:09:32,540<br>So we put all those on the priority queue and again keep them sorted by weight.</p>
<p>131<br>00:09:32,540 –&gt; 00:09:36,100<br>So now let’s continue.</p>
<p>132<br>00:09:36,100 –&gt; 00:09:38,180<br>So smallest thing is one seven.</p>
<p>133<br>00:09:38,180 –&gt; 00:09:46,820<br>That’s the smallest edge from a tree edge to a non-tree edge.</p>
<p>134<br>00:09:46,820 –&gt; 00:09:52,180<br>And so that’s the delete one seven from the priority queue and add it to the MST.</p>
<p>135<br>00:09:52,180 –&gt; 00:09:54,019<br>So we do that.</p>
<p>136<br>00:09:54,019 –&gt; 00:09:55,740<br>And now that takes us to one.</p>
<p>137<br>00:09:55,740 –&gt; 00:10:05,259<br>And so now we have to add to the priority queue all the edges that connect one to non-tree edges.</p>
<p>138<br>00:10:05,259 –&gt; 00:10:09,460<br>So that’s what the asteris are, the new edges on the priority queue.</p>
<p>139<br>00:10:09,460 –&gt; 00:10:12,700<br>And again we keep them sorted by weight.</p>
<p>140<br>00:10:12,700 –&gt; 00:10:19,460<br>So now what we want on the priority queue is a subset of the,</p>
<p>141<br>00:10:19,460 –&gt; 00:10:24,379<br>I want to be sure that every edge that connects a tree edge to a non-tree edge is on the priority queue.</p>
<p>142<br>00:10:24,379 –&gt; 00:10:29,259<br>We might have a few others as well and we’ll see that in a second.</p>
<p>143<br>00:10:29,259 –&gt; 00:10:30,899<br>So now zero twos is the smallest.</p>
<p>144<br>00:10:30,899 –&gt; 00:10:35,220<br>So we take zero two and add it to the MST.</p>
<p>145<br>00:10:35,220 –&gt; 00:10:44,899<br>So notice now that once we add two to the MST, this edge between one and two becomes obsolete.</p>
<p>146<br>00:10:44,899 –&gt; 00:10:47,379<br>It’s never going to be added to the MST.</p>
<p>147<br>00:10:47,379 –&gt; 00:10:50,860<br>At the time that we put one on we thought maybe that was a good way to get to two.</p>
<p>148<br>00:10:50,860 –&gt; 00:10:53,379<br>But now we know there’s a better way to get the two.</p>
<p>149<br>00:10:53,379 –&gt; 00:10:56,620<br>So that edge becomes obsolete.</p>
<p>150<br>00:10:56,620 –&gt; 00:11:01,139<br>And the lazy implementation just leaves that edge on the priority queue.</p>
<p>151<br>00:11:01,139 –&gt; 00:11:02,379<br>So now let’s continue.</p>
<p>152<br>00:11:05,580 –&gt; 00:11:11,779<br>So we added two to the zero two to the MST.</p>
<p>153<br>00:11:11,779 –&gt; 00:11:15,740<br>And we have to add everybody incident to two.</p>
<p>154<br>00:11:15,740 –&gt; 00:11:20,019<br>That is not on the tree to the priority queue.</p>
<p>155<br>00:11:20,019 –&gt; 00:11:22,620<br>So in this case it’s two, three and six, two.</p>
<p>156<br>00:11:22,620 –&gt; 00:11:26,940<br>We don’t have to add one, two and two, seven because they go to three edges.</p>
<p>157<br>00:11:26,940 –&gt; 00:11:28,220<br>We don’t add them back on.</p>
<p>158<br>00:11:30,179 –&gt; 00:11:33,220<br>Okay, so now the smallest is two, three.</p>
<p>159<br>00:11:33,220 –&gt; 00:11:41,019<br>So take that, add it to the MST and add all the edges incident to three to non-tree vertices.</p>
<p>160<br>00:11:41,019 –&gt; 00:11:44,139<br>In this case it’s just three, six.</p>
<p>161<br>00:11:44,139 –&gt; 00:11:45,620<br>And that’s a long one.</p>
<p>162<br>00:11:45,620 –&gt; 00:11:50,259<br>So now the next edge for the MST is five, seven.</p>
<p>163<br>00:11:50,259 –&gt; 00:11:53,819<br>Take that off the priority queue, put on the MST.</p>
<p>164<br>00:11:53,819 –&gt; 00:12:01,019<br>And so now all edges incident to five that go to non-tree vertices.</p>
<p>165<br>00:12:01,019 –&gt; 00:12:03,100<br>So it’s just five, four, add that one.</p>
<p>166<br>00:12:04,580 –&gt; 00:12:10,019<br>So now the next edge that will come off the priority queue is one, three.</p>
<p>167<br>00:12:10,019 –&gt; 00:12:11,419<br>But that’s an obsolete edge.</p>
<p>168<br>00:12:11,419 –&gt; 00:12:17,299<br>We already have one, three connected in the MST because we were lazy.</p>
<p>169<br>00:12:17,299 –&gt; 00:12:19,620<br>We left that one on the priority queue.</p>
<p>170<br>00:12:19,620 –&gt; 00:12:25,980<br>So now we just pull it off and discard it because it connects two tree vertices.</p>
<p>171<br>00:12:25,980 –&gt; 00:12:31,620<br>And same with one five, that connects two tree vertices where we already have a better way to connect them.</p>
<p>172<br>00:12:31,620 –&gt; 00:12:34,060<br>Two, seven connects two tree vertices.</p>
<p>173<br>00:12:34,060 –&gt; 00:12:36,379<br>And finally we get to four, five.</p>
<p>174<br>00:12:36,379 –&gt; 00:12:41,139<br>Four, five now gets deleted from the priority queue and added to the MST.</p>
<p>175<br>00:12:42,139 –&gt; 00:12:46,940<br>Everybody connected to four, that’s just six and that’s a long one goes on.</p>
<p>176<br>00:12:46,940 –&gt; 00:12:51,100<br>Now we have some obsolete edges when we get to that one two.</p>
<p>177<br>00:12:51,100 –&gt; 00:12:55,860<br>And then four, seven is obsolete and zero, four is obsolete.</p>
<p>178<br>00:12:55,860 –&gt; 00:13:00,580<br>And finally the last edge to get added to the MST is six two.</p>
<p>179<br>00:13:00,580 –&gt; 00:13:06,660<br>And after deleting six two from the priority queue and adding the MST,</p>
<p>180<br>00:13:06,660 –&gt; 00:13:09,460<br>we have computed the MST.</p>
<p>181<br>00:13:09,460 –&gt; 00:13:12,420<br>We have the minus one edges on v vertices.</p>
<p>182<br>00:13:12,419 –&gt; 00:13:18,299<br>And that’s implementation of the lazy version of Prims algorithm.</p>
<p>183<br>00:13:18,299 –&gt; 00:13:24,699<br>And it’s just a version of Prims algorithm what we showed was the underlying data structure,</p>
<p>184<br>00:13:24,699 –&gt; 00:13:34,179<br>the priority queue, that ensures that we always get the shortest edge connecting a tree vertex to a non-tree vertex.</p>
<p>185<br>00:13:34,179 –&gt; 00:13:37,379<br>So let’s look at the code for Prims algorithm.</p>
<p>186<br>00:13:37,379 –&gt; 00:13:50,139<br>Again, the data structures that we build up in part one of this course give us a very compact implementation of this MST algorithm.</p>
<p>187<br>00:13:50,139 –&gt; 00:13:55,139<br>So we’re going to need three instance variables.</p>
<p>188<br>00:13:55,139 –&gt; 00:14:04,139<br>One is a existence array, vertex indexed array of bullions that for each vertex,</p>
<p>189<br>00:14:04,139 –&gt; 00:14:07,699<br>we’ll tell us whether or not it’s on the MST.</p>
<p>190<br>00:14:07,699 –&gt; 00:14:18,500<br>Then we have the list of edges on the MST that is going to be returned to the client after the MST is computed for iterable.</p>
<p>191<br>00:14:18,500 –&gt; 00:14:26,059<br>And then we’ll have the priority queue of edges that connect tree vertices with non-tree vertices.</p>
<p>192<br>00:14:26,059 –&gt; 00:14:30,179<br>As a superset of the edges, it connect tree vertices and non-tree vertices.</p>
<p>193<br>00:14:30,179 –&gt; 00:14:39,459<br>So given a graph, we’ll build the priority queue, we’ll initialize all the data structures.</p>
<p>194<br>00:14:39,459 –&gt; 00:14:48,779<br>And then we’ll show what the visit routine does.</p>
<p>195<br>00:14:48,779 –&gt; 00:14:53,779<br>That’s the one that processes each vertex when it gets added to the tree.</p>
<p>196<br>00:14:53,779 –&gt; 00:14:56,259<br>We’ll look at that in the next slide.</p>
<p>197<br>00:14:56,259 –&gt; 00:15:05,779<br>So the main loop is while the priority queue is not empty, we pull off the minimum edge from the priority queue.</p>
<p>198<br>00:15:05,779 –&gt; 00:15:09,100<br>We get its constituent vertices.</p>
<p>199<br>00:15:09,100 –&gt; 00:15:12,819<br>If they’re both marked, then we just ignore it.</p>
<p>200<br>00:15:12,819 –&gt; 00:15:15,860<br>They’re already on the MST.</p>
<p>201<br>00:15:15,860 –&gt; 00:15:24,819<br>Otherwise, we put the edge on the MST in whichever vertex was not on the tree.</p>
<p>202<br>00:15:24,820 –&gt; 00:15:27,220<br>We visit and put on the tree.</p>
<p>203<br>00:15:27,220 –&gt; 00:15:36,620<br>And the visit routine is the one that puts the vertex on the tree and puts all its incident edges onto the priority queue.</p>
<p>204<br>00:15:36,620 –&gt; 00:15:44,820<br>So to visit a vertex, we set its entry, corresponding entry in the marked array to be true.</p>
<p>205<br>00:15:44,820 –&gt; 00:15:47,620<br>So it’s added to the tree.</p>
<p>206<br>00:15:47,620 –&gt; 00:15:59,179<br>And then for every edge that’s adjacent to that, we’re going to, if its other edge is not marked, we’re going to put it on the priority queue.</p>
<p>207<br>00:15:59,179 –&gt; 00:16:04,860<br>So if it’s an edge that goes from a tree vertex to a non-tree vertex, we’ll put it on the priority queue.</p>
<p>208<br>00:16:04,860 –&gt; 00:16:14,500<br>And then we have the client query method to get the MST once the MST is built.</p>
<p>209<br>00:16:14,500 –&gt; 00:16:24,899<br>Again, the data structures that we’ve used give a very compact and complete implementation of Prims algorithm.</p>
<p>210<br>00:16:24,899 –&gt; 00:16:27,179<br>What’s the running time of the algorithm?</p>
<p>211<br>00:16:27,179 –&gt; 00:16:34,580<br>Well, it’s correct because it implements Prims algorithm as we showed.</p>
<p>212<br>00:16:34,580 –&gt; 00:16:36,700<br>It’s an instance of the greedy algorithm.</p>
<p>213<br>00:16:36,700 –&gt; 00:16:44,860<br>And it’s easy to see that the running time is always going to be proportional to E log E in the worst case.</p>
<p>214<br>00:16:44,860 –&gt; 00:16:54,540<br>And that’s because you could put all the edges on the priority queue.</p>
<p>215<br>00:16:54,540 –&gt; 00:16:59,180<br>So every edge might, might have to month the priority queue.</p>
<p>216<br>00:16:59,180 –&gt; 00:17:06,660<br>So that’s E times and then the cost would be proportional to E for inserting and deleting every edge off the path.</p>
<p>217<br>00:17:06,660 –&gt; 00:17:09,100<br>So the priority queue.</p>
<p>218<br>00:17:09,100 –&gt; 00:17:17,060<br>So E log E is a fine running time.</p>
<p>219<br>00:17:17,060 –&gt; 00:17:26,660<br>The extra space proportional to E is, you know, might be considered annoying or elegant or inefficient.</p>
<p>220<br>00:17:26,660 –&gt; 00:17:33,940<br>So there’s a more efficient version of Prims algorithm where we clear off that dead weight on the priority queue.</p>
<p>221<br>00:17:33,940 –&gt; 00:17:39,660<br>And that’s the eager implementation of Prims algorithm that we’ll look at next.</p>
<p>222<br>00:17:39,660 –&gt; 00:17:47,220<br>In practice, the lazy implementation works pretty well, but the eager implementation is also a very elegant and efficient algorithm.</p>
<p>223<br>00:17:47,220 –&gt; 00:17:50,299<br>And it’s worth learning both.</p>
<p>224<br>00:17:50,299 –&gt; 00:17:57,380<br>So for the eager solution, what we’re going to do is the priority queue is going to have vertices.</p>
<p>225<br>00:17:57,380 –&gt; 00:18:02,340<br>And it’s going to have at most one entry per vertex.</p>
<p>226<br>00:18:02,339 –&gt; 00:18:09,779<br>And so those are the vertices that are not on the tree, but are connected by an edge to the tree.</p>
<p>227<br>00:18:09,779 –&gt; 00:18:18,539<br>And the priority of a given vertex is going to be the weight of the shortest edge connecting that vertex to the tree.</p>
<p>228<br>00:18:18,539 –&gt; 00:18:24,459<br>So if we look at this little example here,</p>
<p>229<br>00:18:24,460 –&gt; 00:18:29,340<br>where we’ve built the tree for 0, 7 and 1,</p>
<p>230<br>00:18:29,340 –&gt; 00:18:39,860<br>then the black entries in this are the edges that are on the MST.</p>
<p>231<br>00:18:39,860 –&gt; 00:18:42,940<br>So that’s 0, 7 and 1, 7.</p>
<p>232<br>00:18:42,940 –&gt; 00:18:53,819<br>And the red ones are the ones that are on the priority queue because they’re connected by an edge to some vertex that’s on the tree.</p>
<p>233<br>00:18:53,819 –&gt; 00:19:03,659<br>And for each one of them, there’s a particular edge that’s the shortest that connects that vertex to the tree.</p>
<p>234<br>00:19:03,659 –&gt; 00:19:08,619<br>And so that’s the key for the priority queue.</p>
<p>235<br>00:19:08,619 –&gt; 00:19:15,339<br>So that’s what we’re going to want for at any time during the execution of the algorithm.</p>
<p>236<br>00:19:15,339 –&gt; 00:19:19,379<br>We’re going to want the vertices that are connected to the tree by one vertex.</p>
<p>237<br>00:19:19,380 –&gt; 00:19:24,060<br>And we’re going to know the shortest edge connecting that vertex to the tree.</p>
<p>238<br>00:19:24,060 –&gt; 00:19:29,180<br>So then the algorithm is, again, delete the minimum vertex.</p>
<p>239<br>00:19:29,180 –&gt; 00:19:32,020<br>And it’s got an associated edge that connects it to the tree.</p>
<p>240<br>00:19:32,020 –&gt; 00:19:34,460<br>And we put that one on the tree.</p>
<p>241<br>00:19:34,460 –&gt; 00:19:38,460<br>And then we have to update the priority queue.</p>
<p>242<br>00:19:38,460 –&gt; 00:19:41,220<br>So what do we have to update the priority queue?</p>
<p>243<br>00:19:41,220 –&gt; 00:19:44,260<br>So we have this vertex that’s not on the tree.</p>
<p>244<br>00:19:44,259 –&gt; 00:19:49,339<br>We consider all the edges that are incident to that vertex.</p>
<p>245<br>00:19:49,339 –&gt; 00:19:53,420<br>If they point to a tree vertex, then we’re going to ignore it.</p>
<p>246<br>00:19:53,420 –&gt; 00:19:55,460<br>There’s no problem.</p>
<p>247<br>00:19:55,460 –&gt; 00:20:01,660<br>If it’s not already on the priority queue, we’re going to put that new vertex on the priority queue.</p>
<p>248<br>00:20:01,660 –&gt; 00:20:06,740<br>And then the other thing is, if the vertex is on the priority queue,</p>
<p>249<br>00:20:06,740 –&gt; 00:20:09,579<br>and we just found a shorter way to get to it,</p>
<p>250<br>00:20:09,579 –&gt; 00:20:15,619<br>then we’re going to have to decrease the priority of that vertex.</p>
<p>251<br>00:20:15,619 –&gt; 00:20:19,740<br>So let’s look at how that works in a demo.</p>
<p>252<br>00:20:19,740 –&gt; 00:20:23,699<br>So again, it’s just an implementation of prim’s algorithm.</p>
<p>253<br>00:20:23,699 –&gt; 00:20:28,500<br>It’s just how do we get the min-weight edge that connects to the tree.</p>
<p>254<br>00:20:28,500 –&gt; 00:20:31,699<br>And this is a more efficient way to do it.</p>
<p>255<br>00:20:31,699 –&gt; 00:20:34,500<br>So again, we start out with our graph.</p>
<p>256<br>00:20:34,500 –&gt; 00:20:36,980<br>Start at zero.</p>
<p>257<br>00:20:36,980 –&gt; 00:20:38,899<br>And let’s get going.</p>
<p>258<br>00:20:38,900 –&gt; 00:20:43,980<br>So now the priority queue has vertices.</p>
<p>259<br>00:20:43,980 –&gt; 00:20:48,740<br>And so there’s four vertices that are just one edge away from the tree.</p>
<p>260<br>00:20:48,740 –&gt; 00:20:55,220<br>And we keep them on the priority queue in order of their distance to the tree.</p>
<p>261<br>00:20:55,220 –&gt; 00:21:00,019<br>And we also keep the edge two vertex index arrays.</p>
<p>262<br>00:21:00,019 –&gt; 00:21:06,380<br>One is the edge that takes us to the tree, and the other is the length of that edge.</p>
<p>263<br>00:21:06,380 –&gt; 00:21:12,020<br>And again, we’ll keep them sorted on the priority queue just to make the demo easier to follow.</p>
<p>264<br>00:21:12,020 –&gt; 00:21:16,220<br>So the next vertex to go to the tree is seven.</p>
<p>265<br>00:21:16,220 –&gt; 00:21:22,300<br>The next edge to get added to the tree is edge two of seven.</p>
<p>266<br>00:21:22,300 –&gt; 00:21:25,980<br>And then we go from there.</p>
<p>267<br>00:21:25,980 –&gt; 00:21:27,340<br>So that’s the smallest one.</p>
<p>268<br>00:21:27,340 –&gt; 00:21:29,620<br>We take that for the tree.</p>
<p>269<br>00:21:29,620 –&gt; 00:21:32,340<br>And now we have to update the priority queue.</p>
<p>270<br>00:21:32,340 –&gt; 00:21:34,540<br>So how do we update the priority queue?</p>
<p>271<br>00:21:34,539 –&gt; 00:21:39,339<br>Well, we have to look at everybody incident to seven.</p>
<p>272<br>00:21:39,339 –&gt; 00:21:45,740<br>And so let’s look at, for example, seven two.</p>
<p>273<br>00:21:45,740 –&gt; 00:21:51,819<br>We don’t need to put seven two on the priority queue since we already have a better way to connect two to the tree.</p>
<p>274<br>00:21:51,819 –&gt; 00:21:52,740<br>That’s two zero.</p>
<p>275<br>00:21:52,740 –&gt; 00:21:55,019<br>So we don’t have to change anything.</p>
<p>276<br>00:21:55,019 –&gt; 00:21:58,259<br>Same with seven four.</p>
<p>277<br>00:21:58,259 –&gt; 00:22:03,139<br>And about seven five and seven one, one and five are not on the priority queue.</p>
<p>278<br>00:22:03,140 –&gt; 00:22:12,740<br>So we have to put them on the priority queue and then save the edges and length that get them to seven, which will get them to the tree.</p>
<p>279<br>00:22:12,740 –&gt; 00:22:16,540<br>So now on our priority queue, we have our current tree.</p>
<p>280<br>00:22:16,540 –&gt; 00:22:25,220<br>And we have all vertices that were within one edge of the tree and the edge that gets them to the tree and their length.</p>
<p>281<br>00:22:25,220 –&gt; 00:22:28,460<br>So we’re ready for another step of the algorithm.</p>
<p>282<br>00:22:28,460 –&gt; 00:22:36,980<br>So now one seven is the smallest thing in the priority queue.</p>
<p>283<br>00:22:36,980 –&gt; 00:22:41,740<br>And so we put that on the MST.</p>
<p>284<br>00:22:41,740 –&gt; 00:22:46,700<br>And now we look at everybody connected to one.</p>
<p>285<br>00:22:46,700 –&gt; 00:22:53,259<br>And again, once one seven, we can throw it because it’s on a tree.</p>
<p>286<br>00:22:53,259 –&gt; 00:22:57,380<br>One five, we don’t need because we have a shorter way to get to the tree.</p>
<p>287<br>00:22:57,380 –&gt; 00:22:58,860<br>But we haven’t seen three yet.</p>
<p>288<br>00:22:58,860 –&gt; 00:23:05,820<br>So we add vertex three to the priority queue and say we get to the tree by one, one three distance point two nine.</p>
<p>289<br>00:23:05,820 –&gt; 00:23:14,300<br>Every all the vertices within one edge of the tree and the edge and the length of the shortest edge that gets to the tree from that vertex.</p>
<p>290<br>00:23:14,300 –&gt; 00:23:17,860<br>That’s what we’re maintaining at every step.</p>
<p>291<br>00:23:17,860 –&gt; 00:23:22,860<br>Okay, so next vertex to come to the tree is two.</p>
<p>292<br>00:23:22,859 –&gt; 00:23:29,859<br>And so we put that on the tree and now we look at everybody that connected the two.</p>
<p>293<br>00:23:29,859 –&gt; 00:23:34,859<br>So now we have our first example of decreased key.</p>
<p>294<br>00:23:34,859 –&gt; 00:23:38,859<br>But let’s check them all.</p>
<p>295<br>00:23:38,859 –&gt; 00:23:42,859<br>So two zero, two seven and two one.</p>
<p>296<br>00:23:42,859 –&gt; 00:23:47,859<br>Take us two vertices that are already on the tree.</p>
<p>297<br>00:23:47,859 –&gt; 00:23:51,859<br>So it’s two three and two six.</p>
<p>298<br>00:23:51,859 –&gt; 00:23:59,859<br>So what we need to do for three, we have thought that the best way to get to the tree from three was to go to one.</p>
<p>299<br>00:23:59,859 –&gt; 00:24:05,859<br>But adding this new edge two means we now know a better way to get from three to the tree.</p>
<p>300<br>00:24:05,859 –&gt; 00:24:10,859<br>So we have to update the priority, update the edge two and the priority.</p>
<p>301<br>00:24:10,859 –&gt; 00:24:13,859<br>We have to decrease the key of the priority.</p>
<p>302<br>00:24:13,859 –&gt; 00:24:18,859<br>So that’s an operation that we’re going to need from our priority queue.</p>
<p>303<br>00:24:18,859 –&gt; 00:24:23,859<br>And it’s something that has to be factored into our priority queue implementation.</p>
<p>304<br>00:24:23,859 –&gt; 00:24:26,859<br>And the same thing for six.</p>
<p>305<br>00:24:26,859 –&gt; 00:24:31,859<br>We thought we had a good way to get to the tree from zero, but two brings six closer to the tree.</p>
<p>306<br>00:24:31,859 –&gt; 00:24:37,859<br>So we have to update that information and say now the best way to get from six to the tree is six two.</p>
<p>307<br>00:24:37,859 –&gt; 00:24:40,859<br>And that it’s linked. We have to decrease the key.</p>
<p>308<br>00:24:40,859 –&gt; 00:24:48,859<br>And this definitely involves some reshuffling in the priority queue in our implementation is going to take that into account.</p>
<p>309<br>00:24:48,859 –&gt; 00:24:52,859<br>So with those changes, now we have the following situation.</p>
<p>310<br>00:24:52,859 –&gt; 00:24:58,859<br>And we’ve got four edges on the tree.</p>
<p>311<br>00:24:58,859 –&gt; 00:25:02,859<br>Three edges on the tree. Now we’re going to add the fourth, which is two three.</p>
<p>312<br>00:25:02,859 –&gt; 00:25:05,859<br>That’s the smallest thing on the priority queue.</p>
<p>313<br>00:25:05,859 –&gt; 00:25:08,859<br>So we had two three to the MST.</p>
<p>314<br>00:25:08,859 –&gt; 00:25:13,859<br>And now we have to go to the things connected to three.</p>
<p>315<br>00:25:13,859 –&gt; 00:25:17,859<br>And well, there’s nothing to add since we already have a better way to six.</p>
<p>316<br>00:25:17,859 –&gt; 00:25:20,859<br>So next one that gets added is five seven.</p>
<p>317<br>00:25:20,859 –&gt; 00:25:22,859<br>And check.</p>
<p>318<br>00:25:22,859 –&gt; 00:25:26,859<br>So edges from five seven.</p>
<p>319<br>00:25:26,859 –&gt; 00:25:30,859<br>So we have to add two.</p>
<p>320<br>00:25:30,859 –&gt; 00:25:42,859<br>We, from five, we’re going to decrease the key of four from point three eight to point five.</p>
<p>321<br>00:25:42,859 –&gt; 00:25:48,859<br>Because the best way to get from four to the tree is no longer four zero.</p>
<p>322<br>00:25:48,859 –&gt; 00:25:50,859<br>It’s four five.</p>
<p>323<br>00:25:50,859 –&gt; 00:25:56,859<br>So again, decrease the key and discard the longer edge to the tree.</p>
<p>324<br>00:25:56,859 –&gt; 00:25:59,859<br>And in fact, that’s the next edge that we pick.</p>
<p>325<br>00:25:59,859 –&gt; 00:26:06,859<br>And we don’t bother putting four six on because we already have a better way to get from six to the tree.</p>
<p>326<br>00:26:06,859 –&gt; 00:26:09,859<br>And then the last edge that we had is six two.</p>
<p>327<br>00:26:09,859 –&gt; 00:26:17,859<br>So again, it’s the eager version of Prams algorithm is an implementation that always connects to the tree.</p>
<p>328<br>00:26:17,859 –&gt; 00:26:20,859<br>The vertex that’s closest to the tree.</p>
<p>329<br>00:26:20,859 –&gt; 00:26:33,859<br>But we use a more efficient data structure to do it that can only have one at most one entry per vertex, as opposed to one entry per edge.</p>
<p>330<br>00:26:33,859 –&gt; 00:26:36,859<br>So that’s the eager version of Prams algorithm.</p>
<p>331<br>00:26:36,859 –&gt; 00:26:44,859<br>Okay, rather than focus on the code for the eager version, which is quite similar to the code for the lazy version,</p>
<p>332<br>00:26:44,859 –&gt; 00:26:51,859<br>we’re going to talk briefly about the key data structure that we need to implement this.</p>
<p>333<br>00:26:51,859 –&gt; 00:26:58,859<br>And it’s an implementation of the priority queue that allows us to decrease keys.</p>
<p>334<br>00:26:58,859 –&gt; 00:27:10,859<br>And so this is an advanced version of the priority queue that we talked about in part one of the course, but it’s necessary for algorithms like this.</p>
<p>335<br>00:27:10,859 –&gt; 00:27:26,859<br>So what we’re going to do is the problem is that we have keys that the priority queue algorithm doesn’t really needs to know when we change values of keys.</p>
<p>336<br>00:27:26,859 –&gt; 00:27:30,859<br>And so we have to do that through the API.</p>
<p>337<br>00:27:30,859 –&gt; 00:27:40,859<br>And so what we’re going to do is allow the client to change the key by specifying the index and the new key.</p>
<p>338<br>00:27:40,859 –&gt; 00:27:48,859<br>And then the implementation will take care of changing the value and updating its data structures to reflect the change values.</p>
<p>339<br>00:27:48,859 –&gt; 00:27:56,859<br>You can’t have the client changing values without informing the implementation, the priority queue implementation.</p>
<p>340<br>00:27:56,859 –&gt; 00:28:00,859<br>That’s the basic challenge for this data structure.</p>
<p>341<br>00:28:00,859 –&gt; 00:28:24,859<br>So since we are working with vertex indexed arrays and graphs and the priority queue implementation might do the same, we’ll just associate an index kind of past that idea on to the priority queue to make it allow it to implement these operations efficiently.</p>
<p>342<br>00:28:24,859 –&gt; 00:28:34,859<br>So the constructor gets to know how many indices or how many keys there are going to be at most ever in the priority queue.</p>
<p>343<br>00:28:34,859 –&gt; 00:28:42,859<br>And so it can make use of that to implement efficient data structures for the operations.</p>
<p>344<br>00:28:42,859 –&gt; 00:28:54,859<br>And so in search, just associates a key with a given index. Decrease key allows to decrease the key associated with a given index.</p>
<p>345<br>00:28:54,859 –&gt; 00:29:02,859<br>We can check whether that’s a bug should be intk is an index on the priority queue.</p>
<p>346<br>00:29:02,859 –&gt; 00:29:10,859<br>We can remove a minimal key and give its associated index and check whether it’s empty and get the size.</p>
<p>347<br>00:29:10,859 –&gt; 00:29:23,859<br>It’s pretty much a topic for part one of the course, but we’ll give just one slide here to show how these indices kind of help things go around.</p>
<p>348<br>00:29:23,859 –&gt; 00:29:30,859<br>We’re basically going to use the same code, the heat based implementation of minpq.</p>
<p>349<br>00:29:30,859 –&gt; 00:29:38,859<br>We’ll keep parallel arrays that allow us to access quickly all the information that we need.</p>
<p>350<br>00:29:38,859 –&gt; 00:29:49,859<br>So things on the queue are accessed by index. And so we’ll keep the values in keys. So that’s where the keys are.</p>
<p>351<br>00:29:49,859 –&gt; 00:29:57,859<br>So pq of i will give the index of the key that’s in heap position i and qpi is the heap position of the key with index i.</p>
<p>352<br>00:29:57,859 –&gt; 00:30:18,859<br>So that is the information that you need when the client changes of value, you need to get to the, you have to actually first of all change the value, but then you may need to adjust the heap to reflect the changed value.</p>
<p>353<br>00:30:18,859 –&gt; 00:30:27,859<br>So instead of a swim with an index, we use the, we get the heap position of the given index and so forth.</p>
<p>354<br>00:30:27,859 –&gt; 00:30:47,859<br>So if you look in the book, you’ll see the code for index priority queue and it’s definitely a confusing, confusing topic for a lecture, but it’s important to realize that it’s possible to implement this decreased key operation in log rune time without ever having to search through everything for anything.</p>
<p>355<br>00:30:47,859 –&gt; 00:31:05,859<br>Using the idea of indexing. So with that change, we get for all the operations, we get time proportional to log v and what do we have to do for the eager version of prims algorithm.</p>
<p>356<br>00:31:05,859 –&gt; 00:31:16,859<br>We have to, might have to insert every vertex once and delete min every vertex one and we might do as many as e decrease key operations.</p>
<p>357<br>00:31:16,859 –&gt; 00:31:30,859<br>So that gives us a total running time of e log v, but the main thing is that the amount of space for the priority queue is only v not e and that can make a difference for a huge graph.</p>
<p>358<br>00:31:30,859 –&gt; 00:31:48,859<br>So there are modifications that you can make to this to give a more efficient running time. For example, one easy thing to do is to use since the operation we’re performing most often is the decrease key.</p>
<p>359<br>00:31:48,859 –&gt; 00:32:05,859<br>If we use a multi-way heap, like say a four-way heap or in general a d-way heap, then that reduces the cost of that operation and it slightly increases the cost for insert and delete min, but there’s not many of those.</p>
<p>360<br>00:32:05,859 –&gt; 00:32:17,859<br>So we can get the running time to log base e over v of v and that if you do the math for various types of graphs, that’s going to be faster.</p>
<p>361<br>00:32:17,859 –&gt; 00:32:35,859<br>And in fact, a data structure called the Fibonacci heap was invented in the 80s that actually gets the running time down to e plus v log v, although that data structure is too complicated to actually use in practice.</p>
<p>362<br>00:32:35,859 –&gt; 00:32:55,859<br>If you have a dense graph, then you wouldn’t even use a heap, you just use an array and find the minimum by going through everything since every vertex has lots of connected vertices. So we didn’t consider that one because the huge graphs that we find in practice are sparse and binary heap is going to be much faster.</p>
<p>363<br>00:32:55,859 –&gt; 00:33:07,859<br>And if you really have a performance critical situation, it’s worthwhile to do a four-way heap. That’s the basic bottom line in the running time of Prem’s algorithm.</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>PrincetonAlgorithms P76Part24 07_prims Algorithm</div>
      <div>http://example.com/2025/10/25/PrincetonAlgorithms P76Part24-07_prims-algorithm/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/25/PrincetonAlgorithms%20P77Part24-08_mst-context/" title="PrincetonAlgorithms P77Part24 08_mst Context">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">PrincetonAlgorithms P77Part24 08_mst Context</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/25/PrincetonAlgorithms%20P75Part24-06_kruskals-algorithm/" title="PrincetonAlgorithms P75Part24 06_kruskals Algorithm">
                        <span class="hidden-mobile">PrincetonAlgorithms P75Part24 06_kruskals Algorithm</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
