

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="100:00:00,000 –&gt; 00:00:09,560To put all our algorithms into context and better understand them, what we’ll do now is go 200:00:09,560 –&gt; 00:00:17,519through some basic properties of shortest pat">
<meta property="og:type" content="article">
<meta property="og:title" content="PrincetonAlgorithms P79Part25 03_shortest Path Properties">
<meta property="og:url" content="http://example.com/2025/10/25/PrincetonAlgorithms%20P79Part25-03_shortest-path-properties/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="100:00:00,000 –&gt; 00:00:09,560To put all our algorithms into context and better understand them, what we’ll do now is go 200:00:09,560 –&gt; 00:00:17,519through some basic properties of shortest pat">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-25T05:03:39.837Z">
<meta property="article:modified_time" content="2025-10-25T05:03:39.837Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>PrincetonAlgorithms P79Part25 03_shortest Path Properties - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="PrincetonAlgorithms P79Part25 03_shortest Path Properties"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-25 13:03" pubdate>
          2025年10月25日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          1.7k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          15 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">PrincetonAlgorithms P79Part25 03_shortest Path Properties</h1>
            
            
              <div class="markdown-body">
                
                <p>1<br>00:00:00,000 –&gt; 00:00:09,560<br>To put all our algorithms into context and better understand them, what we’ll do now is go</p>
<p>2<br>00:00:09,560 –&gt; 00:00:17,519<br>through some basic properties of shortest paths in educated, directed graphs.</p>
<p>3<br>00:00:17,519 –&gt; 00:00:21,080<br>So what kind of data structures are going to need first of all?</p>
<p>4<br>00:00:21,080 –&gt; 00:00:26,879<br>Our goal is to find the shortest path from S to every other vertex.</p>
<p>5<br>00:00:26,879 –&gt; 00:00:34,320<br>So the first observation is that there’s going to be a shortest path’s tree solution.</p>
<p>6<br>00:00:34,320 –&gt; 00:00:38,879<br>Well, if no two paths have the same length, that certainly is going to be such a solution.</p>
<p>7<br>00:00:38,879 –&gt; 00:00:43,640<br>And there’s a number of ways to convince yourself that there’s going to be a tree.</p>
<p>8<br>00:00:43,640 –&gt; 00:00:48,039<br>If you’ve got two paths to the same vertex, you can delete the last edge and one of them</p>
<p>9<br>00:00:48,039 –&gt; 00:00:51,879<br>and keep going until all this left is a tree, for example.</p>
<p>10<br>00:00:51,879 –&gt; 00:00:55,320<br>So what we want to do is compute a tree.</p>
<p>11<br>00:00:55,320 –&gt; 00:01:02,640<br>Now we’ve done that in several algorithms before and a reasonable way to represent the shortest</p>
<p>12<br>00:01:02,640 –&gt; 00:01:08,519<br>path’s tree is to use two vertex indexed arrays.</p>
<p>13<br>00:01:08,519 –&gt; 00:01:15,400<br>The first one is for every vertex, compute the length of the shortest path from S to that</p>
<p>14<br>00:01:15,400 –&gt; 00:01:16,719<br>vertex.</p>
<p>15<br>00:01:16,719 –&gt; 00:01:21,439<br>So in this case, we have this shortest path’s tree and we’ll keep the length of the shortest</p>
<p>16<br>00:01:21,439 –&gt; 00:01:26,519<br>path from the source 0 to each vertex.</p>
<p>17<br>00:01:26,519 –&gt; 00:01:34,759<br>So 0 to the length of that shortest path is 0.26, 027, it’s 0.60 and like that.</p>
<p>18<br>00:01:34,759 –&gt; 00:01:42,879<br>So because you go from 0 to 2.36 and from 2 to 7.34, you get 0.60 and so forth.</p>
<p>19<br>00:01:42,879 –&gt; 00:01:48,799<br>And then the other thing, as we’ve done before, is use a parent-link representation where</p>
<p>20<br>00:01:48,799 –&gt; 00:01:54,200<br>edge 2v is going to be the last edge that takes us to v.</p>
<p>21<br>00:01:54,200 –&gt; 00:01:59,599<br>And by following back through that array, we can get the path as we’ve done several times</p>
<p>22<br>00:01:59,599 –&gt; 00:02:00,759<br>before.</p>
<p>23<br>00:02:00,759 –&gt; 00:02:06,560<br>If we want the path from 0 to 6, we go to edge 2, 6 and says, well, the last thing we do</p>
<p>24<br>00:02:06,560 –&gt; 00:02:08,240<br>is 3 to 6.</p>
<p>25<br>00:02:08,240 –&gt; 00:02:11,359<br>Then we go to 3 and say, the way we get to 3 is from 7.</p>
<p>26<br>00:02:11,359 –&gt; 00:02:12,359<br>We go to 7.</p>
<p>27<br>00:02:12,359 –&gt; 00:02:15,000<br>Say, the way we get to 7 is from 2.</p>
<p>28<br>00:02:15,000 –&gt; 00:02:17,919<br>We go to 2 and say, that’s the way we get to 0.</p>
<p>29<br>00:02:17,919 –&gt; 00:02:24,159<br>If we put all those things on a stack, then we can return them as an interval to the client</p>
<p>30<br>00:02:24,159 –&gt; 00:02:28,759<br>and that gives the edges on the shortest path.</p>
<p>31<br>00:02:28,759 –&gt; 00:02:35,199<br>So that’s the data structures that we’re going to use for shortest paths.</p>
<p>32<br>00:02:35,199 –&gt; 00:02:39,399<br>This is actually the code that does what I just said.</p>
<p>33<br>00:02:39,399 –&gt; 00:02:41,239<br>The client query, give me the distance.</p>
<p>34<br>00:02:41,240 –&gt; 00:02:49,760<br>It just returns, uses v to index into the instance array and returns the distance.</p>
<p>35<br>00:02:49,760 –&gt; 00:02:54,560<br>And if the client asks for the path, then we make a stack.</p>
<p>36<br>00:02:54,560 –&gt; 00:02:59,360<br>And then we use a variable e, which is a directed edge.</p>
<p>37<br>00:02:59,360 –&gt; 00:03:00,840<br>And we start at edge 2v.</p>
<p>38<br>00:03:00,840 –&gt; 00:03:06,160<br>And as long as it’s not null, we push it onto the path.</p>
<p>39<br>00:03:06,159 –&gt; 00:03:12,800<br>And then go to the edge 2 entry for the vertex that we came from.</p>
<p>40<br>00:03:12,800 –&gt; 00:03:18,519<br>And that gives the vertex that we came from to get to that vertex and keep going until</p>
<p>41<br>00:03:18,519 –&gt; 00:03:22,439<br>we run out of vertices, which happens at the source.</p>
<p>42<br>00:03:22,439 –&gt; 00:03:27,759<br>And then return the path, and that’s an interval that gives the client the path.</p>
<p>43<br>00:03:27,759 –&gt; 00:03:30,240<br>So that’s the implementation of the two query methods.</p>
<p>44<br>00:03:30,240 –&gt; 00:03:37,840<br>So now what we’re going to want to talk about for the rest of the lecture is the algorithms</p>
<p>45<br>00:03:37,840 –&gt; 00:03:40,920<br>that build these data structures.</p>
<p>46<br>00:03:40,920 –&gt; 00:03:47,640<br>Now all of the algorithms that we look at are based on a concept called relaxation, edge</p>
<p>47<br>00:03:47,640 –&gt; 00:03:49,320<br>relaxation.</p>
<p>48<br>00:03:49,320 –&gt; 00:03:53,240<br>So now we call that our data structures.</p>
<p>49<br>00:03:53,240 –&gt; 00:03:57,480<br>So we’re going to talk about relaxing an edge from v to w.</p>
<p>50<br>00:03:57,479 –&gt; 00:04:01,159<br>And we have an example here from v to w.</p>
<p>51<br>00:04:01,159 –&gt; 00:04:09,679<br>And at the point that we’re going to relax this edge will have our data structures in process</p>
<p>52<br>00:04:09,679 –&gt; 00:04:14,000<br>and this too, we haven’t seen all edges.</p>
<p>53<br>00:04:14,000 –&gt; 00:04:19,399<br>We haven’t seen all paths in the intermediate part of some algorithm.</p>
<p>54<br>00:04:19,399 –&gt; 00:04:27,000<br>But we’ll try to make sure that this 2v for every vertex is the length of the shortest</p>
<p>55<br>00:04:27,000 –&gt; 00:04:29,720<br>known path to that vertex.</p>
<p>56<br>00:04:29,720 –&gt; 00:04:32,120<br>And that’s going to be the same for w.</p>
<p>57<br>00:04:32,120 –&gt; 00:04:38,680<br>So these are all the edges that are in edge 2 that we know paths from s to some vertex.</p>
<p>58<br>00:04:38,680 –&gt; 00:04:43,920<br>So this 2v and this 2v will contain a shortest known path.</p>
<p>59<br>00:04:43,920 –&gt; 00:04:52,560<br>Now if we, and also edge 2w, edge 2w is the last edge in the shortest known path from s</p>
<p>60<br>00:04:52,560 –&gt; 00:04:53,560<br>to w.</p>
<p>61<br>00:04:53,560 –&gt; 00:04:56,360<br>And the same way the edge 2v, of course.</p>
<p>62<br>00:04:56,360 –&gt; 00:05:01,520<br>Now so to relax along the edge from v to w, essentially that means let’s update the</p>
<p>63<br>00:05:01,520 –&gt; 00:05:05,280<br>data structures to take that edge to an into account.</p>
<p>64<br>00:05:05,280 –&gt; 00:05:10,879<br>And what happens in this case is that the edge gives a better way to get to w.</p>
<p>65<br>00:05:10,879 –&gt; 00:05:13,319<br>So that’s what relaxing is.</p>
<p>66<br>00:05:13,319 –&gt; 00:05:18,520<br>That edge gives us a new shortest path so we want to include it in the data structures.</p>
<p>67<br>00:05:18,520 –&gt; 00:05:26,280<br>So since it has a shorter path, we have to update both this 2w and edge 2w.</p>
<p>68<br>00:05:26,279 –&gt; 00:05:28,959<br>That is we have a new way to get to w.</p>
<p>69<br>00:05:28,959 –&gt; 00:05:33,399<br>So we have to throw away that old edge that came to w.</p>
<p>70<br>00:05:33,399 –&gt; 00:05:39,879<br>And we have a new shorter distance instead of 7.2 that came that old way.</p>
<p>71<br>00:05:39,879 –&gt; 00:05:43,519<br>We have 4.4 that gets us a new way.</p>
<p>72<br>00:05:43,519 –&gt; 00:05:47,719<br>So edge relaxation is a very natural operation.</p>
<p>73<br>00:05:47,719 –&gt; 00:05:52,039<br>When we consider a new edge, does it give a new shortest path to that vertex or not?</p>
<p>74<br>00:05:52,040 –&gt; 00:05:53,840<br>If it doesn’t, we ignore it.</p>
<p>75<br>00:05:53,840 –&gt; 00:05:58,960<br>If it does, we update the data structures to include that edge and forget about the old</p>
<p>76<br>00:05:58,960 –&gt; 00:06:01,840<br>edge that took us to that vertex.</p>
<p>77<br>00:06:01,840 –&gt; 00:06:03,800<br>That’s edge relaxation.</p>
<p>78<br>00:06:03,800 –&gt; 00:06:09,680<br>And this is easy implementation of edge relaxation in code.</p>
<p>79<br>00:06:09,680 –&gt; 00:06:15,080<br>So to relax an edge, we pull out it’s from in two vertices in v and w according to our</p>
<p>80<br>00:06:15,080 –&gt; 00:06:16,800<br>standard idiom.</p>
<p>81<br>00:06:16,800 –&gt; 00:06:25,560<br>And then we just see if the distance to w that was the shortest path before is bigger</p>
<p>82<br>00:06:25,560 –&gt; 00:06:33,199<br>than the distance to v plus the weight of the edge that would take us from v to w.</p>
<p>83<br>00:06:33,199 –&gt; 00:06:35,759<br>If it’s bigger, that means we found a new path.</p>
<p>84<br>00:06:35,759 –&gt; 00:06:38,280<br>If it’s less than or equal, we ignore it.</p>
<p>85<br>00:06:38,280 –&gt; 00:06:43,240<br>And if we found a new path, we have to update the distance to w to be the new distance,</p>
<p>86<br>00:06:43,240 –&gt; 00:06:45,639<br>distance to v plus follow vw.</p>
<p>87<br>00:06:45,639 –&gt; 00:06:51,560<br>And then we have to update edge to w and throw away the old version and say that our new</p>
<p>88<br>00:06:51,560 –&gt; 00:06:56,920<br>edge from v to w is the best path to w as far as we know.</p>
<p>89<br>00:06:56,920 –&gt; 00:07:00,639<br>So that’s easy code for edge relaxation.</p>
<p>90<br>00:07:00,639 –&gt; 00:07:08,960<br>Now we’re going to use edge relaxation in a really fundamental way to compute shortest</p>
<p>91<br>00:07:08,960 –&gt; 00:07:11,360<br>paths.</p>
<p>92<br>00:07:11,360 –&gt; 00:07:18,600<br>But there’s one other important idea, which is called optimality conditions.</p>
<p>93<br>00:07:18,600 –&gt; 00:07:24,080<br>And this is a way to know that we have shortest paths.</p>
<p>94<br>00:07:24,080 –&gt; 00:07:26,560<br>We have computed all the shortest paths.</p>
<p>95<br>00:07:26,560 –&gt; 00:07:34,960<br>So the shortest path optimality conditions are embodied in this proposition.</p>
<p>96<br>00:07:34,959 –&gt; 00:07:38,079<br>We have an edge weighted diagram.</p>
<p>97<br>00:07:38,079 –&gt; 00:07:41,319<br>And we have the distu array.</p>
<p>98<br>00:07:41,319 –&gt; 00:07:43,000<br>Let’s just talk about the distances.</p>
<p>99<br>00:07:43,000 –&gt; 00:07:45,799<br>And the paths go with the distances.</p>
<p>100<br>00:07:45,799 –&gt; 00:07:54,120<br>But the key point is that the distu array represents shortest path distances from the given</p>
<p>101<br>00:07:54,120 –&gt; 00:07:59,120<br>source s, if and only if these two conditions hold.</p>
<p>102<br>00:07:59,120 –&gt; 00:08:04,519<br>So the first thing is if it’s the length for every vertex, distu v is the length of</p>
<p>103<br>00:08:04,519 –&gt; 00:08:07,959<br>some path from s to the vertex.</p>
<p>104<br>00:08:07,959 –&gt; 00:08:11,399<br>And our algorithms will always ensure that.</p>
<p>105<br>00:08:11,399 –&gt; 00:08:20,519<br>And then the second thing is for every edge vw, we have this condition that the distu</p>
<p>106<br>00:08:20,519 –&gt; 00:08:29,199<br>w that we have stored is less than or equal to distu v plus the weight of the edge from v</p>
<p>107<br>00:08:29,199 –&gt; 00:08:30,199<br>to w.</p>
<p>108<br>00:08:30,199 –&gt; 00:08:33,639<br>That’s the shortest path optimality conditions.</p>
<p>109<br>00:08:33,639 –&gt; 00:08:40,199<br>If they’re equal, so sometimes they’ll be equal, for example, if vw is the last edge on</p>
<p>110<br>00:08:40,199 –&gt; 00:08:42,120<br>the shortest path.</p>
<p>111<br>00:08:42,120 –&gt; 00:08:44,799<br>And sometimes they’ll be greater, but it’ll never be smaller.</p>
<p>112<br>00:08:44,799 –&gt; 00:08:48,759<br>They’ll never be a way to get to w that we haven’t found.</p>
<p>113<br>00:08:48,759 –&gt; 00:08:52,600<br>That’s the shortest path optimality conditions.</p>
<p>114<br>00:08:52,600 –&gt; 00:08:59,000<br>And again, just a quick proof, although the best way to understand proofs is to read them</p>
<p>115<br>00:08:59,000 –&gt; 00:09:05,399<br>slowly, not listen to them spoken quickly, but I’ll quickly outline them.</p>
<p>116<br>00:09:05,399 –&gt; 00:09:10,480<br>So here’s the necessary suppose that.</p>
<p>117<br>00:09:10,480 –&gt; 00:09:15,519<br>So we want to prove that if this is true, then we have shortest path.</p>
<p>118<br>00:09:15,519 –&gt; 00:09:19,079<br>So do that, we assume the contrary.</p>
<p>119<br>00:09:19,079 –&gt; 00:09:25,360<br>Suppose that the distance to w is bigger than the distance to v plus e dot weight for some</p>
<p>120<br>00:09:25,360 –&gt; 00:09:26,360<br>edge.</p>
<p>121<br>00:09:26,360 –&gt; 00:09:34,159<br>Then that path is going to give a path to w that’s shorter than distance w, because v is</p>
<p>122<br>00:09:34,159 –&gt; 00:09:36,360<br>a path on the weight shorter.</p>
<p>123<br>00:09:36,360 –&gt; 00:09:40,279<br>And that is a contradiction to the idea that you have shortest path.</p>
<p>124<br>00:09:40,279 –&gt; 00:09:48,639<br>So there can’t be any such edge where that condition holds.</p>
<p>125<br>00:09:48,639 –&gt; 00:09:50,679<br>So that’s necessary.</p>
<p>126<br>00:09:50,679 –&gt; 00:09:58,120<br>And then sufficient, suppose that we have a shortest path from s to w.</p>
<p>127<br>00:09:58,120 –&gt; 00:10:05,319<br>Then we’re assuming these conditions all hold.</p>
<p>128<br>00:10:05,320 –&gt; 00:10:12,280<br>And for every edge on the path, this has to all hold.</p>
<p>129<br>00:10:12,280 –&gt; 00:10:16,320<br>So it starts at the end.</p>
<p>130<br>00:10:16,320 –&gt; 00:10:21,760<br>So the distance, the last edge goes from vk minus 1 to vk.</p>
<p>131<br>00:10:21,760 –&gt; 00:10:27,440<br>So distance to vk is less than or equal to the distance to vk minus 1 plus the weight</p>
<p>132<br>00:10:27,440 –&gt; 00:10:29,560<br>of the kth edge.</p>
<p>133<br>00:10:29,559 –&gt; 00:10:37,619<br>And so just continuing down that way, then from the source to the first edge, so source</p>
<p>134<br>00:10:37,619 –&gt; 00:10:43,679<br>plus the weight of the first edge is greater than or equal distance to the first vertex after</p>
<p>135<br>00:10:43,679 –&gt; 00:10:45,079<br>the source.</p>
<p>136<br>00:10:45,079 –&gt; 00:10:47,119<br>And all those conditions have to hold.</p>
<p>137<br>00:10:47,119 –&gt; 00:10:56,119<br>And then what we can do is just add up all those weights and simplify it.</p>
<p>138<br>00:10:56,120 –&gt; 00:11:05,879<br>And then that shows that the distance to w is equal to the length of the shortest path.</p>
<p>139<br>00:11:05,879 –&gt; 00:11:10,279<br>And so it’s got to be the weight of the shortest path because it’s the weight of some path</p>
<p>140<br>00:11:10,279 –&gt; 00:11:11,279<br>and it’s got that weight.</p>
<p>141<br>00:11:11,279 –&gt; 00:11:14,200<br>It’s got to be the weight of the shortest path.</p>
<p>142<br>00:11:14,200 –&gt; 00:11:17,759<br>So if those conditions hold, we have shortest path.</p>
<p>143<br>00:11:17,759 –&gt; 00:11:24,519<br>So the point of this proof, it’s a slightly complicated proof, but it’s not too bad.</p>
<p>144<br>00:11:24,519 –&gt; 00:11:32,659<br>It’s quite natural is that all we have to know to check that we have computed shortest</p>
<p>145<br>00:11:32,659 –&gt; 00:11:36,039<br>paths is that these optimality conditions hold.</p>
<p>146<br>00:11:36,039 –&gt; 00:11:42,600<br>To prove that an algorithm can put shortest paths, we just have to prove that it ends up</p>
<p>147<br>00:11:42,600 –&gt; 00:11:45,039<br>with the optimality conditions in force.</p>
<p>148<br>00:11:45,039 –&gt; 00:11:46,600<br>And that’s what we’ll be doing.</p>
<p>149<br>00:11:46,600 –&gt; 00:11:52,559<br>And the optimality condition really is just saying there’s no edge there that we missed.</p>
<p>150<br>00:11:53,559 –&gt; 00:12:03,559<br>OK, so with that idea, in fact, there’s a very simple, easy to state generic algorithm</p>
<p>151<br>00:12:03,559 –&gt; 00:12:06,559<br>that is going to compute shortest paths.</p>
<p>152<br>00:12:06,559 –&gt; 00:12:08,559<br>And it’s very simple.</p>
<p>153<br>00:12:08,559 –&gt; 00:12:14,559<br>We start with the distance to the source being zero on the distance to every other vertex infinity.</p>
<p>154<br>00:12:14,559 –&gt; 00:12:21,559<br>And all we do is repeat until the optimality conditions are satisfied, relax any edge.</p>
<p>155<br>00:12:21,559 –&gt; 00:12:26,559<br>Just go ahead and relax edges until the optimality conditions are satisfied.</p>
<p>156<br>00:12:26,559 –&gt; 00:12:30,559<br>So that’s a very general algorithm.</p>
<p>157<br>00:12:30,559 –&gt; 00:12:37,559<br>We don’t say how to decide which edge to relax or how to know the optimality conditions are satisfied.</p>
<p>158<br>00:12:37,559 –&gt; 00:12:43,559<br>But still, it’s quite an amazingly simple generic algorithm.</p>
<p>159<br>00:12:43,559 –&gt; 00:12:48,559<br>So how do we know, how can we show that it computes the SPT?</p>
<p>160<br>00:12:48,559 –&gt; 00:12:50,559<br>Well, it’s pretty simple.</p>
<p>161<br>00:12:50,559 –&gt; 00:12:57,559<br>Throughout the algorithm, we’re making sure that, because the way that we do relax edges,</p>
<p>162<br>00:12:57,559 –&gt; 00:13:02,559<br>the distance to V is the length of a simple path from S to V.</p>
<p>163<br>00:13:02,559 –&gt; 00:13:05,559<br>And the edge to V is the last edge on that path.</p>
<p>164<br>00:13:05,559 –&gt; 00:13:11,559<br>That’s what relaxation does for any vertex that we touch.</p>
<p>165<br>00:13:12,559 –&gt; 00:13:19,559<br>And not only that, every relaxation that succeeds decreases the distances.</p>
<p>166<br>00:13:19,559 –&gt; 00:13:24,559<br>And we’ve assumed that there’s a way to get to every vertex.</p>
<p>167<br>00:13:24,559 –&gt; 00:13:31,559<br>And there’s only a finite number of paths, so it can decrease at most a finite number of times.</p>
<p>168<br>00:13:31,559 –&gt; 00:13:38,559<br>So the algorithm’s going to terminate as simple as that.</p>
<p>169<br>00:13:38,559 –&gt; 00:13:49,559<br>Again, this is a little bit of a mind-blowing concept, but we’ll leave that for more careful study.</p>
<p>170<br>00:13:49,559 –&gt; 00:13:54,559<br>And just for now, realize that all we have to do is relax along edges.</p>
<p>171<br>00:13:54,559 –&gt; 00:14:03,559<br>And what we’re going to do now is look at different ways of figuring out how to choose which edge to relax.</p>
<p>172<br>00:14:03,559 –&gt; 00:14:11,559<br>The first algorithm that we’ll look at is a classic algorithm known as Dijkstra’s algorithm, one of the most famous of all algorithms.</p>
<p>173<br>00:14:11,559 –&gt; 00:14:16,559<br>And that is effective when the weights are non-negative.</p>
<p>174<br>00:14:16,559 –&gt; 00:14:23,559<br>Then we’ll look at an algorithm that works even with negative weights as long as there aren’t any directed cycles.</p>
<p>175<br>00:14:23,559 –&gt; 00:14:38,559<br>Then we’ll look at an even older algorithm than Dijkstra’s the Bellman Ford algorithm that can solve the shortest path problem in graphs with negative weights as long as there’s no negative cycles.</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>PrincetonAlgorithms P79Part25 03_shortest Path Properties</div>
      <div>http://example.com/2025/10/25/PrincetonAlgorithms P79Part25-03_shortest-path-properties/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/25/PrincetonAlgorithms%20P7Part13-02_analysis-of-algorithms-introduction/" title="PrincetonAlgorithms P7Part13 02_analysis Of Algorithms Introduction">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">PrincetonAlgorithms P7Part13 02_analysis Of Algorithms Introduction</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/25/PrincetonAlgorithms%20P80Part25-04_dijkstras-algorithm/" title="PrincetonAlgorithms P80Part25 04_dijkstras Algorithm">
                        <span class="hidden-mobile">PrincetonAlgorithms P80Part25 04_dijkstras Algorithm</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
