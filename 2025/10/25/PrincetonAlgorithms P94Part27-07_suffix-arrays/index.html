

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="100:00:00,000 –&gt; 00:00:08,000Finally, we’re going to look at suffix arrays and string processing using this data structure 200:00:08,000 –&gt; 00:00:15,000that has really played a very important ro">
<meta property="og:type" content="article">
<meta property="og:title" content="PrincetonAlgorithms P94Part27 07_suffix Arrays">
<meta property="og:url" content="http://example.com/2025/10/25/PrincetonAlgorithms%20P94Part27-07_suffix-arrays/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="100:00:00,000 –&gt; 00:00:08,000Finally, we’re going to look at suffix arrays and string processing using this data structure 200:00:08,000 –&gt; 00:00:15,000that has really played a very important ro">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-25T05:03:39.841Z">
<meta property="article:modified_time" content="2025-10-25T05:03:39.841Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>PrincetonAlgorithms P94Part27 07_suffix Arrays - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="PrincetonAlgorithms P94Part27 07_suffix Arrays"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-25 13:03" pubdate>
          2025年10月25日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          1.2k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          10 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">PrincetonAlgorithms P94Part27 07_suffix Arrays</h1>
            
            
              <div class="markdown-body">
                
                <p>1<br>00:00:00,000 –&gt; 00:00:08,000<br>Finally, we’re going to look at suffix arrays and string processing using this data structure</p>
<p>2<br>00:00:08,000 –&gt; 00:00:15,000<br>that has really played a very important role in string processing applications that would</p>
<p>3<br>00:00:15,000 –&gt; 00:00:21,699<br>not otherwise be possible. To get a feeling for the idea, we’re going to look at a really</p>
<p>4<br>00:00:21,699 –&gt; 00:00:28,080<br>old idea that you’re actually familiar with called keyword and context search. And the idea</p>
<p>5<br>00:00:28,079 –&gt; 00:00:35,079<br>is that you’re given a text, a huge text. And what you want to do is pre-process it to</p>
<p>6<br>00:00:35,079 –&gt; 00:00:41,560<br>enable a fast substring search. That is, you want a client to be able to give a query</p>
<p>7<br>00:00:41,560 –&gt; 00:00:50,679<br>string. And then you want to give all occurrences of that query string in context. So if you look</p>
<p>8<br>00:00:50,679 –&gt; 00:00:56,519<br>for the word search, it’ll give all the occurrences of where the word search occurs in context.</p>
<p>9<br>00:00:56,520 –&gt; 00:01:05,520<br>And that’s a very common operation of one. You’re certainly familiar with it from web searching</p>
<p>10<br>00:01:05,520 –&gt; 00:01:12,520<br>in your browser. And there’s many other applications. This is a pretty old idea that dates back to</p>
<p>11<br>00:01:12,520 –&gt; 00:01:21,520<br>the late 50s, early 60s. People have always wanted to do this. And there’s an easy way to look at it</p>
<p>12<br>00:01:21,519 –&gt; 00:01:30,519<br>called suffix sorting. The idea is you take your input string and then form the suffixes.</p>
<p>13<br>00:01:30,519 –&gt; 00:01:36,519<br>Remember what I talked about at the beginning with Java’s string data type. You can get this</p>
<p>14<br>00:01:36,519 –&gt; 00:01:43,519<br>done in linear time because each suffix is basically a pointer back into the input string.</p>
<p>15<br>00:01:43,519 –&gt; 00:01:52,519<br>So the suffix, remember, the I suffix, just start a character I and take the rest of the string.</p>
<p>16<br>00:01:52,519 –&gt; 00:02:04,519<br>So what this does is it gives sort keys that contain kind of the pieces of the string itself in context.</p>
<p>17<br>00:02:04,519 –&gt; 00:02:12,519<br>And all we do is just run a sort on that suffix. And what that sort does is it brings, if you do a search,</p>
<p>18<br>00:02:12,520 –&gt; 00:02:21,520<br>it brings the things that you’re searching for close together. And once you’ve done that suffix sort,</p>
<p>19<br>00:02:21,520 –&gt; 00:02:33,520<br>you can use the binary search to find all occurrences of the string that are there. That’s the basic idea of a keyword in context searching.</p>
<p>20<br>00:02:33,520 –&gt; 00:02:44,520<br>You suffix sort the text, then do binary search to find the query that you’re looking for. And then you can scan for the binary search and up.</p>
<p>21<br>00:02:44,520 –&gt; 00:02:57,520<br>And so this is all the places where other word search occurs in the text of tale of two cities. And then you can use this index to print out the context whatever’s needed.</p>
<p>22<br>00:02:57,520 –&gt; 00:03:06,520<br>It’s a fine and effective way for solving this important practical problem.</p>
<p>23<br>00:03:06,520 –&gt; 00:03:15,520<br>And that’s interesting, but I want to talk about another really important problem that has had hugely important applications.</p>
<p>24<br>00:03:15,520 –&gt; 00:03:23,520<br>And this is the longest repeated substring problem. So you’re given a string of characters, find the longest repeated substring.</p>
<p>25<br>00:03:23,520 –&gt; 00:03:33,520<br>In this case, this is genomic data. And there’s the example of the longest repeated substring.</p>
<p>26<br>00:03:33,520 –&gt; 00:03:43,520<br>And now in scientific data, the long repeated substring is often something that scientists are looking for.</p>
<p>27<br>00:03:43,520 –&gt; 00:04:01,520<br>And so these strings are huge. It might be billions of these characters. So it’s really important not only to know that you can find long substrings efficiently, but also that you can do it for huge, huge strings.</p>
<p>28<br>00:04:01,520 –&gt; 00:04:16,519<br>Another example is crypt analysis where a long repeat in a file that’s supposed to be encrypted random file indicates that somebody did something wrong and might be the key to breaking the code.</p>
<p>29<br>00:04:16,519 –&gt; 00:04:29,519<br>Another example is data compression. When you’ve got a file that’s got a lot of repeated stuff in it, you might want to do this operation to take advantage of these long repeats.</p>
<p>30<br>00:04:29,519 –&gt; 00:04:50,519<br>And that keep multiple copies of them. Here’s another example. This is for studying or visualizing repetitions in music. In this example, every time there’s a repeat of the notes, then there’s an art drawn to visualize the repeat.</p>
<p>31<br>00:04:50,519 –&gt; 00:05:04,519<br>And it’s the darkest thick if the number of repeats is long and it’s high if the repeats are far away. In this tells is an interesting way to analyze that repetitions in music.</p>
<p>32<br>00:05:04,519 –&gt; 00:05:12,519<br>So how are we going to solve this problem? It’s very simple to state problem. Given the sequence of end characters, find the longest repeated substring.</p>
<p>33<br>00:05:12,519 –&gt; 00:05:25,519<br>As with many problems, there’s an easy brute force algorithm that at least gives us an idea of what the computation is like, but it’s not going to be useful for huge strings.</p>
<p>34<br>00:05:25,519 –&gt; 00:05:36,519<br>And that’s you try all possibilities, all pairs of indices, i and j, and then just compute the longest common prefix for each pair.</p>
<p>35<br>00:05:36,519 –&gt; 00:05:53,519<br>The problem with that is that if n is the length of the string, you’ve got n squared over two pairs. And for every one of those pairs, you might have to match them up to length d.</p>
<p>36<br>00:05:53,519 –&gt; 00:06:06,519<br>It’s definitely quadratic time, more than quadratic time in the length of the string. And can’t be using that for, you know, not going to be able to use that for strings that are billions of characters long.</p>
<p>37<br>00:06:06,519 –&gt; 00:06:17,519<br>Another way to look at one way to solve the longest repeated substring is to use a suffix sort. In fact, just what we talked about before.</p>
<p>38<br>00:06:17,519 –&gt; 00:06:28,519<br>So we take our input string, reform the suffixes, and then sort the suffixes, and that brings the long repeated substrings together.</p>
<p>39<br>00:06:28,519 –&gt; 00:06:40,519<br>So that’s a quite elegant and efficient solution to this problem. Just build the suffix array. That’s a linear time process. Do the sort.</p>
<p>40<br>00:06:40,519 –&gt; 00:06:53,519<br>We just saw we can do that with n log n character compare, and then go through and find repeated substrings.</p>
<p>41<br>00:06:53,519 –&gt; 00:07:03,519<br>So it’s just one pass through to check for JSON substrings to see which one is the longest.</p>
<p>42<br>00:07:03,519 –&gt; 00:07:23,519<br>And this is very easy to code up. Here’s the Java code for computing the longest repeated substring. We get the length of our string out. We build our suffix array. Remember, that’s linear time and space because of Java string implementation allows us to do substring at constant time.</p>
<p>43<br>00:07:23,519 –&gt; 00:07:37,519<br>Then we go ahead and sort the suffixes and then find the least common prefix between the JSON suffixes and sorted order. Just keep track of the max.</p>
<p>44<br>00:07:37,519 –&gt; 00:07:55,519<br>So that’s the longest repeated substring. And so for example, this sentence about such a funny, sporty game, you just did jockey, hooky, hooky lad is the longest repeated substring in the text of Melville’s Moby Dick.</p>
<p>45<br>00:07:55,519 –&gt; 00:08:06,519<br>And we run that one to prove that we’ve got a linear arithmetic algorithm because there’s a lot of characters in that and you’re not going to find this without a good algorithm.</p>
<p>46<br>00:08:06,519 –&gt; 00:08:27,519<br>And this is just a humorous approach to what we’ve talked about today. If you have five scientists that are looking for long substring in a genome, they might encounter this problem with a billion nucleotides.</p>
<p>47<br>00:08:27,519 –&gt; 00:08:43,519<br>And there are plenty of scientists that are not aware of important algorithms, like the ones we’re talking about. And the one that uses the good algorithm is definitely more likely to find a cure for cancer.</p>
<p>48<br>00:08:43,519 –&gt; 00:09:00,519<br>There is a flaw even in this that computer scientists discovered as they got into every more complex algorithms for problems like this. And that is if the longest repeated substring is long, there’s a problem.</p>
<p>49<br>00:09:00,519 –&gt; 00:09:17,519<br>So this is just some experiments for finding the longest repeated substring in various files from just a program to the text of Moby Dick or a chromosome with 7.1 million characters.</p>
<p>50<br>00:09:17,519 –&gt; 00:09:36,519<br>And using the brute force method, you get stuck in too slow, very soon. But using a suffix sort, you can get these jobs done even for huge files like the first 10 million digits of pi.</p>
<p>51<br>00:09:36,519 –&gt; 00:09:50,519<br>By the way, if there was a really long repeated substring in the first, in the digits of pi, that would be news. Maybe it would help us understand more about this number.</p>
<p>52<br>00:09:50,519 –&gt; 00:10:03,519<br>So lots of people write programs of this sort. But the big problem is if you have a really long repeated substring, then suffix sort’s not going to work.</p>
<p>53<br>00:10:03,519 –&gt; 00:10:15,519<br>Our fast algorithm doesn’t complete. So what’s going on? In the explanation is really simple.</p>
<p>54<br>00:10:15,519 –&gt; 00:10:31,519<br>For example, you have two copies of something. When you form the suffix array, what happens is if you have the longest repeat, but you also have every version of that repeat appears.</p>
<p>55<br>00:10:31,519 –&gt; 00:10:53,519<br>So if you have to look for those when checking for the longest repeated substring, so if D is the length of the longest match, then just to check for the longest common prefix, you got to do at least one plus two plus three plus four up to D character compares, which means it’s going to be quadratic.</p>
<p>56<br>00:10:53,519 –&gt; 00:11:05,519<br>So if you have a long repeated substring, then just to check for checking for the longest common prefix of adjacent elements in this algorithm, it’s also a problem for the sort.</p>
<p>57<br>00:11:05,519 –&gt; 00:11:22,519<br>So if you have very long repeats, we still don’t have an algorithm. So the question is that was confronting computer scientists in the late 80s, early 90s is how can we get this done? What’s the best algorithm for this problem?</p>
<p>58<br>00:11:22,519 –&gt; 00:11:40,519<br>And there was a great algorithm called the Mambra Myers algorithm. I’ll talk about in just a minute that got the job done in linear rhythmic time. And actually there’s a clever old algorithm that uses a data structure called suffix trees.</p>
<p>59<br>00:11:40,519 –&gt; 00:11:59,519<br>But it was really the Mambra Myers algorithm that got people excited about this area. And so I want to describe that briefly. Actually, these two computer scientists, one of them went on to become chief scientist of an internet company.</p>
<p>60<br>00:11:59,519 –&gt; 00:12:15,519<br>The other one went on to become chief scientist of a company that won the race in sequencing the genome. In both cases, good algorithms for processing long strings are very important. And this is a great algorithm.</p>
<p>61<br>00:12:15,519 –&gt; 00:12:24,519<br>Now it’s a little too complex to give all the details in a lecture, but I can give a pretty good idea of how it works.</p>
<p>62<br>00:12:24,519 –&gt; 00:12:38,519<br>So the overview is that it’s kind of like an MSD sort, but what it manages to do is double the number of characters that it looks at in each pass through the array.</p>
<p>63<br>00:12:38,519 –&gt; 00:12:56,519<br>And the idea is that since you’re doubling the number of characters that you look at each time, it finishes in a log n time. That’s the size of the suffix array. If you double until you get to n, it’s log n.</p>
<p>64<br>00:12:56,519 –&gt; 00:13:14,519<br>And it turns out what’s really ingenious about the algorithm is that you can do it, do each phase in linear time. So this is an example of how it works. So it’s going to do a suffix sort. And then I’ll talk about the least kind of prefix as well.</p>
<p>65<br>00:13:14,519 –&gt; 00:13:26,519<br>So sort of the first character, well, we just use key, key index counting or something like that. So we know how to do that in linear time.</p>
<p>66<br>00:13:26,519 –&gt; 00:13:34,519<br>And then the idea is given that it’s sorted on the first character, we can sort of easily sort of the first two. Well, again, we could use key index counting.</p>
<p>67<br>00:13:34,519 –&gt; 00:13:48,519<br>So now what we can do is double the number of characters that we involve each time. So the next phase of the Mayr-Miers algorithm now gets it sorted on four characters.</p>
<p>68<br>00:13:48,519 –&gt; 00:14:01,519<br>And of course, as we more characters, we have sorted on at the leading part, the smaller the subfiles in the trading and the trailing part. So that’s certainly a feature.</p>
<p>69<br>00:14:01,519 –&gt; 00:14:11,519<br>And then in this case, after we get to eight characters, then all our subfiles are of size one and we’re done with the sort.</p>
<p>70<br>00:14:11,519 –&gt; 00:14:31,519<br>Now the key to the algorithm is the idea that once it’s going, it uses what’s called an index sort, which essentially means that it can do compares in constant time in the middle of the algorithm.</p>
<p>71<br>00:14:31,519 –&gt; 00:14:44,519<br>And let’s just take a look at how that works. So let’s look at trying to compare string zero with string nine.</p>
<p>72<br>00:14:44,519 –&gt; 00:14:51,519<br>And we know that we’ve already got the thing sorted on four characters and we want to sort it on eight.</p>
<p>73<br>00:14:51,519 –&gt; 00:14:58,519<br>So zero and nine are equal on the first four characters are in the same subfiles. So we’re going to get us sorted on the others.</p>
<p>74<br>00:14:58,519 –&gt; 00:15:11,519<br>But the thing is if we add four to our given indices, so we’re at zero and we add four that gets us to four and we’re at nine and we add four that gets us to 13.</p>
<p>75<br>00:15:11,519 –&gt; 00:15:26,519<br>We already know that the thing is sorted on those characters and we know that 13 appears before four in this sorted list that’s already sorted.</p>
<p>76<br>00:15:26,519 –&gt; 00:15:35,519<br>And we can keep track of that by using an inverse array, which says for every index where it appears in the sorted order.</p>
<p>77<br>00:15:35,519 –&gt; 00:15:43,519<br>So this says that 13 appears at position six and four appears at position seven. That is 13 appears before four.</p>
<p>78<br>00:15:43,519 –&gt; 00:15:56,519<br>So when we’re trying to compare this string here, that’s the zero suffix with the nice suffix.</p>
<p>79<br>00:15:56,519 –&gt; 00:16:07,519<br>So we can go in and again add four to get four, add four to get 13, go into the index array and see which one’s less and the one that appears first is going to be less.</p>
<p>80<br>00:16:07,519 –&gt; 00:16:10,519<br>So that’s a constant time comparison.</p>
<p>81<br>00:16:10,519 –&gt; 00:16:19,519<br>13 is less than or equal four because the inverse of 13 is less than inverse four, which means that suffix is of nine.</p>
<p>82<br>00:16:19,519 –&gt; 00:16:28,519<br>If you take eight characters out of nine and eight characters out of zero, it’s less. It’s a really simple and of course easy to implement operation.</p>
<p>83<br>00:16:28,519 –&gt; 00:16:34,519<br>So maintaining the inverse, I can get constant time string compare.</p>
<p>84<br>00:16:34,519 –&gt; 00:16:39,519<br>So what does that imply for the whole suffix sort?</p>
<p>85<br>00:16:40,519 –&gt; 00:16:52,519<br>Well, with a constant time compare, then I can get, at a minimum, I can get an analog and sort just by using quicksword or merge sort.</p>
<p>86<br>00:16:52,519 –&gt; 00:17:00,519<br>And then I get much faster than quadratic performance no matter what the strings are. That’s a big key to the success of this algorithm.</p>
<p>87<br>00:17:00,519 –&gt; 00:17:12,519<br>And actually, if you use version of the three way quicksword, it’s been proven that it even gets down to linear time for the sort, no matter what the input is.</p>
<p>88<br>00:17:12,519 –&gt; 00:17:28,519<br>That’s one thing. And then the other thing is when you need to do the longest comma prefix to look for the longest match after the array sort of, you can also do this constant time for string compare and get the job done.</p>
<p>89<br>00:17:29,519 –&gt; 00:17:43,519<br>So this is really an ingenious algorithm that can get suffix sorting done very fast, even in the presence of a huge repeat.</p>
<p>90<br>00:17:43,519 –&gt; 00:17:53,519<br>And I think really underscores the importance of careful algorithmic thinking in addressing new computational challenges.</p>
<p>91<br>00:17:53,519 –&gt; 00:18:04,519<br>So string sorting just to summarize is a really interesting area of inquiry. For one thing, we can develop linear time sorts for many, many applications.</p>
<p>92<br>00:18:04,519 –&gt; 00:18:12,519<br>We thought we were doing well when we had analog and sorts, but actually we can do much better for many applications.</p>
<p>93<br>00:18:12,519 –&gt; 00:18:27,519<br>In fact, we can even get to sub linear where we don’t even have to examine all the data in today’s world when we have huge amounts of data to be able to get it sort of without even looking at it all is really quite a miracle.</p>
<p>94<br>00:18:28,519 –&gt; 00:18:36,519<br>Three way string quicksort, you can’t do better than that in terms of the number of characters that you have to examine.</p>
<p>95<br>00:18:36,519 –&gt; 00:18:41,519<br>And there’s a lot of deep mathematical analysis behind that result.</p>
<p>96<br>00:18:41,519 –&gt; 00:18:55,519<br>But I think the other lesson to learn is that algorithms like three way string quicksort and in member mayors should show that we really have a lot to learn still in string processing.</p>
<p>97<br>00:18:56,519 –&gt; 00:19:05,519<br>And they’re not really random. In fact, a lot of times we’re looking for non-randomness and we might want to use specialized algorithms.</p>
<p>98<br>00:19:05,519 –&gt; 00:19:15,519<br>So string process, this is our introduction to string processing. We’re going to look at many other string processing examples in the coming lectures.</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>PrincetonAlgorithms P94Part27 07_suffix Arrays</div>
      <div>http://example.com/2025/10/25/PrincetonAlgorithms P94Part27-07_suffix-arrays/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/25/PrincetonAlgorithms%20P92Part27-05_msd-radix-sort/" title="PrincetonAlgorithms P92Part27 05_msd Radix Sort">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">PrincetonAlgorithms P92Part27 05_msd Radix Sort</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/25/PrincetonAlgorithms%20P95Part28-03_r-way-tries/" title="PrincetonAlgorithms P95Part28 03_r Way Tries">
                        <span class="hidden-mobile">PrincetonAlgorithms P95Part28 03_r Way Tries</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
