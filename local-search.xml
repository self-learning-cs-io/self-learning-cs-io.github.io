<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>深入理解计算机系统 013-Thread-Level Parallelism</title>
    <link href="/2025/10/12/15213-013/"/>
    <url>/2025/10/12/15213-013/</url>
    
    <content type="html"><![CDATA[<p>2025年10月02日 08:54<br>发言人   00:00<br>Well, hello, everyone. Interesting how far fewer seats are filled than at the beginning of the course. So of course, we’re in the final stretch of this course. You’re working on the last web and the material that we’re covering, both this lecture and next lecture, and not on the exam. And you don’t need them for your web. So at some level, you could just tune out and skip it all. And if your only purpose in taking this course is to pass it or to get some grade in it, and that’s it, well, go ahead and tune out.<br>大家好。有趣的是，座位比课程开始时少了多少。当然，我们正处于这门课程的最后阶段。你正在处理最后一个网站和我们要覆盖的材料，包括这堂课和下一堂课，而不是考试。你的网站不需要它们。因此，在某种程度上，你可以直接退出并跳过所有内容。如果你修这门课的唯一目的是通过它或在其中取得一些成绩，那就去吧，退出来。</p><p>发言人   00:38<br>But on the other hand, the material we’re talking about is very relevant to where computers are today and where they’re going in the future. And so if you think about the longer term and whatever your investment is in the computer industry and computer technology is, then I think you’ll find these very worthwhile. But so think of this more as the stuff icing on the cake you’ve learned, the hard stuff you’ve done, the grinding part, and now you get to think beyond the sort of narrow confines of the coarse material and think bigger. But that’s really the way you should be viewing this lecture. In the last lecture, which we’ll be on Thursday. So today, what we’re going to talk about is parallelism. And the issue is that that, wow.<br>但另一方面，我们正在谈论的内容与计算机今天的状况以及未来的发展方向非常相关。因此，如果你从更长远的角度考虑，无论你在计算机行业和计算机技术方面的投资是什么，我认为你会发现这些投资非常值得。但是，请将其更多地看作是你所学到的锦上添花、你所做的困难的事情、研磨的部分，现在你可以超越粗糙材料的狭窄范围，思考更大的东西。但这确实是你应该看待这个讲座的方式。在上一次演讲中，我们将在星期四进行。所以今天，我们要讨论的是并行性。问题是，哇。</p><p>发言人   01:33<br>PowerPoint is a product made by a certain company in Seattle that’s not always reliable. The issue is, as you know, nowadays when you buy a computer, you don’t get just 1, a CPU on the processor chip. You have at least two on a typical laptop. Even my phone has 2 cores in it, as well as 4 graphic processing units and a typical the next generation of ipad will be a 6 core processor. These have become not just the sort of specialized domain of. High end machines, but actually there all the time. And actually, we’ll talk some next time.<br>PowerPoint是西雅图一家公司生产的产品，但并不总是可靠的。问题是，正如你所知，如今当你购买电脑时，你不会只得到一个处理器芯片上的CPU。你在一台典型的笔记本电脑上至少有两个。甚至我的手机也有2个内核，以及4个图形处理单元，典型的下一代ipad将是6核处理器。这些已经不仅仅是专门的领域。高端机器，但实际上一直都在那里。实际上，我们下次再谈。</p><p>发言人   02:21<br>Why is it that instead of having one fast computer, you get two medium size, medium performance processors on a chip or more? And that’s actually a really interesting technology issue that I’ll talk about next time, but it’s the way it is.<br>为什么不用一台快速的计算机，而是在一块芯片上得到两个中等大小、中等性能的处理器或更多？这实际上是一个非常有趣的技术问题，我下次会谈论，但就是这样。</p><p>发言人   02:37<br>So you can think of it when you write a program and it runs as a single thread, then you’re basically not making use of the computing resources that you have available to you. So the natural thing is, well, could we make our programs run faster by doing multiple threads? So you’ve already learned, or you’re in the process of applying multithreaded programming as a way to.<br>因此，当你编写一个程序并且它作为单个线程运行时，你可以想到它，那么你基本上没有利用你现有的计算资源。所以自然的事情是，我们可以通过多线程来让我们的程序运行得更快吗？所以你已经学过了，或者你正在应用多线程编程作为一种方法。</p><p>发言人   03:10<br>Deal with concurrency of external events. There’s multiple clients who want to make use of a server, and instead of serving one and then another and then another, if you can handle them all, it’s sort of an external use of concurrency. But what we’ll talk about today is more an internal use.<br>处理外部事件的并发性。有多个客户端想要使用一个服务器，而不是服务一个，然后另一个，如果你能处理所有这些客户端，这是一种并发的外部使用。但今天我们将讨论的更多是内部使用。</p><p>发言人   03:29<br>Can I make use of multiple threads running on multiple cores to make a program run, a single program run faster? And the message behind that is yes. But and what I mean is it is truly possible. And people spend a lot of time making programs run faster by using multiple threads, but it’s harder than you’d think it should be, and it’s fraught with, as you’ve already experienced, programming bugs. But also, it’s just really darn hard to get the kind of performance out of a multi-core processor that you would think it would be available. So we’ll talk about some of that, and then we’ll finish it up a little bit understanding of how how when you’re writing concurrent programs, you want to think about the state of memory and how that’s a challenge for multi-core processors, or in fact, any concurrent concurrent system.<br>我可以利用在多个内核上运行的多个线程来使程序运行，单个程序运行得更快吗？这背后的信息是肯定的。但是，我的意思是，这确实是可能的。人们花了很多时间通过使用多个线程使程序运行得更快，但这比你想象的要困难，而且充满了编程错误，正如你已经经历过的那样。但是，要获得你认为可用的多核处理器的性能确实非常困难。所以我们将讨论其中的一些，然后我们将完成一点，了解当您编写并发程序时，您如何考虑内存状态，以及这对多核处理器或任何并发系统的挑战。</p><p>发言人   04:32<br>There’s actually two sources of concurrency on a modern processor, multiple cores, which is you have actually multiple Cpu’s on a single chip. But there’s also something called hyperthreading, which is, in my experience, less useful. But let me go through this. So this is what a typical modern processor looks like.<br>在现代处理器上实际上有两个并发源，多核，也就是在单个芯片上实际上有多个Cpu。但是还有一种叫做超线程的东西，根据我的经验，它不太有用。但让我经历一下。这就是典型的现代处理器的样子。</p><p>发言人   04:55<br>Processor chip is that there’s actually on a single chip, there’s multiple independent Cpu’s and each of them has some part of the CA hierarchy, which is private to that particular core. And then there is another part of the CA hierarchy that’s shared across cores. And then they all have a common interface to main memory. So if these cores are running and this is what happens a lot is they’re running programs that are completely independent, have nothing to do with each other, then they more or less just exist and run, and they’re happy as can be. They state are caching parts of their own state, and sometimes this cash will get polluted by the junk from other programs in terms of performance, but it won’t matter with functionality.<br>处理器芯片实际上是在一个芯片上，有多个独立的Cpu，每个Cpu都有一部分CA层次结构，这是特定核心的私有部分。然后是CA层次结构的另一个部分，它在核心之间共享。然后它们都有一个公共的主存储器接口。因此，如果这些核心正在运行，并且经常发生的情况是它们运行完全独立的程序，彼此之间没有任何关系，那么它们或多或少只是存在和运行，并且它们很快乐。他们的状态正在缓存自己的状态的一部分，有时这个现金会在性能方面被其他程序的垃圾污染，但这与功能无关。</p><p>发言人   05:52<br>The trick when you’re trying to do multicore programming as a parallel computing thing, somehow getting all these cores working on. Different parts of a single problem in a way that makes it so that you get the performance out of it. They don’t spend all their time basically arguing with each other about who has access to what. And also they’re not stepping over each other and messing up each other’s state.<br>当你试图将多核编程作为并行计算时，以某种方式让所有这些核心工作时的技巧。一个问题的不同部分，以某种方式使其发挥出最佳性能。他们不会把所有的时间都花在基本上互相争论谁有权访问什么。而且他们不会踩到对方身上，也不会搞乱对方的状态。</p><p>发言人   06:22<br>So hyperthreading is a little bit more into the deep works of how a processor operates. You’ll recall from the lecture on performance, or what’s chapter 5 of the book, that a modern microprocessor looks absolutely nothing like the model that you get by looking at assembly code instructions. The model of assembly code is you execute one instruction, then you execute the next one, then you execute the next one. Modern processes don’t do that at all. They haven’t done it for well, they haven’t done it that way for 30 years and since 1995. So since 20 years, they do it in a totally different way, which is sometimes referred to as out of order processing.<br>因此，超线程技术更深入地研究了处理器的运行方式。你会从关于性能的讲座中回忆起来，或者说是书的第五章，现代的微处理器看起来绝对不像你通过查看汇编代码指令得到的模型。汇编代码的模型是你执行一条指令，然后执行下一个指令，然后执行下一个指令。现代工艺根本不这样做。他们做得不是很好，他们已经有30年没有这样做过了，从1995年开始。因此，20年来，他们以完全不同的方式进行处理，有时被称为 “订单处理”。</p><p>发言人   07:10<br>And so just real quickly, the basic idea is on the processor chip, there’s multiple functional units that are capable of doing different types of operation. There’s ones for integer arithmetic, there’s ones for floating point arithmetic, and so forth. And then there’s separate blocks interface to the memory, actually to the cache memories. And they’re both loading, meaning reading from the memory and storing, writing out to memory. But these units sort of operate independently. And what happens is there’s a block of logic, which is actually an enormous, huge block of logic in an x 86 processor that reads the instructions out of the instruction stream, rips them apart into little pieces, keeps track of data dependencies and control dependencies, and then schedules all the various operations in your program on these different functional units.<br>因此，很快地，基本思想是在处理器芯片上，有多个功能单元能够执行不同类型的操作。有整数运算的，有浮点运算的，等等。然后有单独的块接口到内存，实际上是到缓存内存。它们都在加载，即从内存读取和存储，并向内存写入。但这些单位有点独立运作。发生的事情是有一个逻辑块，它实际上是x86处理器中的一个巨大的逻辑块，它从指令流中读取指令，将它们分解成小块，跟踪数据依赖关系和控制依赖关系。然后在这些不同的功能单元上安排程序中的所有各种操作。</p><p>发言人   08:08<br>So we talked some about that in the context of how can you write a program that will sort of maximize how much is going on down here by writing your code in particular ways?<br>因此，我们在讨论如何编写一个程序的背景下，通过以特定的方式编写代码来最大化这里发生的事情？</p><p>发言人   08:23<br>So all this is an introduction to say this is how you have to understand what hyperthreading is so in a single execution mode, there’s basically one instruction decoder, and it has its own set of state here, its own program counter, its own queue of operations that it’s already decoded and haven’t completed yet. It has its own set of registers. They’re actually not registers like you’d expect, they’re highly virtualized registers, but all this state is there to help to service the execution of one thread of execution.<br>所以所有这些都是一个介绍，说明这是你必须理解超线程的方式，因此在单个执行模式中，基本上只有一个指令解码器，并且在这里有自己的状态集，自己的程序计数器，它自己的操作队列，它已经解码并且还没有完成。它有自己的寄存器组。它们实际上并不是您所期望的寄存器，它们是高度虚拟化的寄存器，但所有这些状态都是为了帮助服务一个执行线程的执行而存在的。</p><p>发言人   09:03<br>With hyperthreading. Basically what you do is the idea of it is to say 90% of all programs don’t really make use of all these functional units, especially if you’re blocking on a load because there’s a miss in a cache, then all these arithmetic units are sitting there without any useful work to do, and so why don’t we just double up or quadruple up or K times up the state associated with the decoding and control parts of the program so that you can have multiple threads running and sharing these functional units among each other they operating really independently? Their states are not intertwined, but they’re sort of making more use of the available hardware for performing functions. And so that’s called hyperthreading. That’s an Intel term you also sometimes hear called SMT, simultaneous multithreading. And in my experience, and we’ll see here the numbers, it doesn’t really make that big a difference. It turns out to be, in the large picture of things, a relatively inexpensive feature for them to throw onto processors, and so they do it, and so nowadays, at least with an x 86 processor, usually have two way hyperthreading in them.<br>超线程。基本上你所做的想法是说90% 的程序并没有真正利用所有这些功能单元，特别是如果你因为缓存中存在错过而阻塞负载，那么所有这些算术单元都坐在那里，没有任何有用的工作要做。那么，为什么我们不将与程序的解码和控制部件相关的状态增加一倍、四倍或K倍，以便您可以运行多个线程并在彼此之间共享这些功能单元，它们真正独立运行？它们的状态并不是交织在一起的，但它们在某种程度上更多地利用可用的硬件来执行功能。这被称为超线程。这是一个英特尔术语，你有时也会听到，叫做SMT，同时多线程。根据我的经验，我们将在这里看到数字，这并没有太大的区别。事实证明，从大局上看，这是一个相对廉价的功能，可以投入到处理器上，所以他们就这样做了，所以现在至少在x86处理器上，通常会有双向超线程。</p><p>发言人   10:34<br>So given that, if you look at our shark machines, which are a little bit old, they’re sort of 2010 era machine, but they were high end machines in their day, and so they still actually are more powerful than what you’d buy as, say, a desktop and way more powerful than as a laptop that you’d get today. So they’re actually pretty decent machines, actually.<br>考虑到这一点，如果你看看我们的鲨鱼机器，它们有点老了，它们有点像2010时代的机器，但它们在当时是高端机器，所以它们实际上仍然比你买的更强大，比如，一款台式机，比你今天得到的笔记本电脑更强大。所以它们实际上是相当不错的机器。</p><p>发言人   10:56<br>We’ll talk next time about why computers aren’t a lot faster than they were five years ago. That’s actually an interesting technology thing. They’re server class machines, so they have multiple cores and they have eight of them, which is a lot. You can buy 10 core machines, x 86 machines on a single chip, but I don’t think you can get more yet. So these were fairly advanced machine in their day, and they also have two way hyperthreading, so in theory.<br>我们下次会讨论为什么计算机没有比五年前快很多。这实际上是一件有趣的技术事情。它们是服务器级机器，所以它们有多个核心，它们有八个核心，这是很多的。你可以在一个芯片上购买10个核心机器，x86机器，但我认为你还不能再买到更多了。所以这些在他们当时相当先进的机器，并且它们也有双向超线程，所以在理论上。</p><p>发言人   11:37<br>You should be able to get 16 independent threads running, sort of 16 way parallelism potentially out of a program.<br>你应该能够运行16个独立的线程，潜在地从程序中并行16种方式。</p><p>发言人   11:45<br>If you can keep everything working and keep bad things from happening. So let’s give a really trivial application that should be very simple to make, run in parallel. And that says, imagine we want to sum up the numbers between 0 and n -1, which is, by the way, a really stupid thing to do because there’s a very simple closed form formula for it, which is good in the sense that will let us check our work. But it’s a completely stupid application. But it just shows you this idea. And so what we’re just going to do is block off if we have nway parallelism, we’re just going to split our range of numbers, n wayss and just have a single threads, sum up one 10th of the numbers. And then they’ll collectively sum together the results in some way or another. So this is about as easy a parallel program as you could imagine.<br>如果你能保持一切正常，防止不好的事情发生。所以让我们给出一个非常简单的应用程序，应该非常容易制作，并行运行。也就是说，想象一下我们想把0和n -1之间的数字相加，顺便说一下，这是一件非常愚蠢的事情，因为它有一个非常简单的封闭形式公式，这在感知上是很好的，可以让我们检查我们的工作。但这是一个完全愚蠢的应用程序。但它只是向你展示了这个想法。所以我们要做的就是阻止，如果我们有nway并行，我们只是将我们的数字范围分开，n种方式，只有一个线程，将数字的十分之一相加。然后他们会以某种方式集体将结果汇总在一起。所以这是一个你能想象到的简单的并行程序。</p><p>发言人   12:48<br>So let’s do 1 version, which is said, well, gee, I understand how to use threads pthreads, and I know about these things called semaphores or mutual exclusion. So what I’ll do is just I’ll have one place in memory where I’m collecting the sum over all n values. And for a thread to be able to add to that, it will lock it. It will get a mutual exclusive access to it, increment it, and then unlock it. And we’ll just let all the threads go. He your skelter locking and unlocking this, these within a single thread.<br>所以让我们做一个版本，也就是说，好吧，我明白如何使用threads，而且我知道这些叫做信号量或互斥的东西。所以我要做的就是在内存中有一个地方收集所有n个值的总和。对于一个线程来说，如果要添加它，它将会锁定它。它将获得对它的相互独占访问权限，增加它，然后解锁它。我们就让所有的线索都结束了。你的乱七八糟的锁定和解锁，这些都在一个线程内。</p><p>发言人   13:28<br>Things have to occur in the sequential order of that thread, but across threads, whether write A or write B occurs first is completely arbitrary, and whether writing of B occurs. These two actions are before is also arbitrary. So what it means is you can take two different threads and you can interweave their events in any way, but you should be able to pull out of that interweaving the sequential order of either of both of the two threads. So when you do that, you end up, you can enumerate an example like this, all the possibilities. You can say, well, look, it first is either going to be write A or write a, let’s pick, write A, so now the next event will be either a read of B or write of B, and then if I do write a write read B, then I’ve completed this thread. And so now the only possibility is to write, to be, and read A and so forth.<br>事情必须按照线程的顺序发生，但在线程之间，写A还是写B首先发生是完全任意的，写B是否发生是完全任意的。这两个行动之前也是任意的。所以这意味着你可以采用两个不同的线程，并且可以以任何方式交织它们的事件，但你应该能够从交织中拉出两个线程中任何一个的顺序。所以当你这样做时，你最终可以列举像这样的例子，所有的可能性。你可以说，看，首先要么写A，要么写a，让我们选择写A，所以现在下一个事件将是读B或写B，然后如果我写了读B，那么我已经完成了这个线程。因此，现在唯一的可能性是写作、成为和阅读等等。</p><p>发言人   14:43<br>You work out all the possible things. You get six different event orderings. And then what will be printed is, well, first of all, whether you print B before A will depend on the relative ordering of those two threads. So that’s showing I’m showing the B value in blue and the value in red. Sorry, a value in red. And you’ll get these different possibilities.<br>你计算出所有可能的事情。你会得到六个不同的事件订单。然后要打印的是，首先，您是否在A之前打印B将取决于这两个线程的相对顺序。这表明我用蓝色显示B值，用红色显示值。抱歉，红色的值。你会得到这些不同的可能性。</p><p>发言人   15:11<br>These are all the six possible outputs of this program, but you’ll see that there are two other outputs 1 could imagine that won’t arise. One is to print 101, in other words, to have them both print the original values of these two variables. And that’s impossible because I have to have done at least one right before I can reach either of these two print statements, right? So it’s not possible for these to still be in their original values when I hit these print statements. And whichever order I hit these two. So those two are possible. So that’s the idea of sequential consistency, that there’s some very large number, but of possible outputs of a program. But in any case, they can’t violate the ordering implied by the individual threads.<br>这些是这个程序的所有六个可能的输出，但是你会看到还有另外两个不会出现的输出。一种是打印101，换句话说，让它们都打印这两个变量的原始值。这是不可能的，因为我必须至少做一个正确的事情才能得到这两个打印语句中的任何一个，对吗？所以当我点击这些打印语句时，这些语句不可能仍然处于原始值。无论我击中这两个顺序是什么。所以这两个是可能的。这就是顺序一致性的想法，即有一些非常大的数字，但是程序的可能输出。但在任何情况下，它们都不能违反单个线程所隐含的顺序。</p><p>发言人   16:18<br>So you’d say OK du, that seems like a pretty obvious thing. But actually, if you think from a hardware perspective, it’s not that trivial to make that happen. So let me just. Show you a scenario of multi-core hardware that would violate sequential consistency.<br>所以你会说 “OK du”，这似乎是一件很明显的事情。但实际上，如果你从硬件的角度考虑，实现这一点并不是那么简单。那就让我来吧。向您展示一个会违反顺序一致性的多核硬件场景。</p><p>发言人   16:39<br>Assume that each of our threads has its own private cache. And so if I execute this statement, what I’ll do is I will grab a copy of A from the main memory and bring it into my cache. And I will assign this new value to it. And similarly, thread two will grab a copy of it of B and update that. And now if I do my 2 print statements, if thread 2 picks up the value from the memory, not knowing that thread one has a modified copy of that value, then it would naturally print 1. And similarly, if thread one picked up a copy of B from main memory, it would print 100. So we’d see exactly this unallowable execution.<br>假设我们的每个线程都有自己的私有缓存。因此，如果我执行此语句，我将从主内存中获取一份副本，并将其带入我的缓存中。我将为它分配这个新值。同样，线程二将获取B的副本并更新它。现在，如果我执行2个打印语句，如果线程2从内存中获取值，而不知道线程1具有该值的修改副本，那么它将自然地打印1。类似地，如果线程1从主内存中获取B的副本，它将打印100。所以我们会确切地看到这种不允许的执行。</p><p>发言人   17:35<br>And the reason is because each of these threads have their own private copies of these shared variables, and they’re not properly synchronized. But you could see in a hardware scenario, it would be easy to build this hardware and make that mistake.<br>原因是因为每个线程都有这些共享变量的私有副本，并且它们没有正确同步。但是你可以看到在硬件场景中，构建这个硬件并犯那个错误是很容易的。</p><p>发言人   17:51<br>So how does it work in a multi-core processor? Well, they have a trick. They call it Snoopy caches. And it’s a little bit like the reader’s writers synchronization that you’re working on for your proxies that you want to make it so that if everyone’s just reading some shared value, they should be able to get copies into their own caches to optimize the performance of it. But if one of them wants to write to it, it needs to get an exclusive copy of it and lock out any other thread from accessing that either to read it or to write it from long enough to make the update.<br>那么它在多核处理器中是如何工作的呢？他们有一个诡计。他们称之为史努比缓存。这有点像读者的写入器同步，你正在为代理服务器工作，你想让它变得这样，如果每个人都只是阅读一些共享价值，他们应该能够将副本存储到自己的缓存中，以优化其性能。但是如果其中一个想要写入它，它需要获取它的独占副本，并锁定任何其他线程访问它，以便读取或写入足够长的时间以进行更新。</p><p>发言人   18:39<br>They have a protocol where they tag, actually. And these tags are at the level of cache lines typically. So the tag cache line in main memory with its state and the typical state would be invalid. It’s shared or it’s exclusive. So shared means there can be copies of it, but they can only be read only copies, and meaning that it’s exclusively available to a single thread. So this is built into, then, the hardware of a multi-core processor.<br>他们有一个协议，实际上可以标记。这些标记通常处于缓存行级别。因此，主内存中的标记缓存行及其状态和典型状态将无效。它是共享的还是独家的。所以共享意味着可以有它的副本，但它们只能是只读副本，这意味着它仅可用于单个线程。因此，这被内置到多核处理器的硬件中。</p><p>发言人   19:19<br>So what will happen then is in order to do a write to a thread, one will acquire an exclusive copy of this element, and that actually tagging happens down here at the main memory and in the cache both. And similarly, if thread two wants A to write to be, it must get an exclusive copy of that. And then when the read occurs, what happens is actually this cache miss will send out a signal on a bus, a shared communication medium, saying, I want to read A, and instead of the main memory responding to it, actually, well, that result will be supplied by the other cache. And it will convert the state of this element to being a shared element.<br>那么接下来会发生的是，为了对一个线程进行写入，一个人将获得这个元素的独占副本，并且实际上在主内存和缓存中都进行标记。类似地，如果线程二想要一个写出来，它必须获得一个独占副本。当读取发生时，实际上这个缓存未命中会在共享通信介质总线上发送一个信号，说，我想读取一个，而不是主存储器响应它，实际上，这个结果将由另一个缓存提供。它会将此元素的状态转换为共享元素。</p><p>发言人   20:18<br>Locally, but you’ll see that the main memory element isn’t updated yet. It goes through the whole write back protocol you’ve already seen. And sometimes it will update that those different implementations.<br>本地，但您会看到主内存元素尚未更新。它经历了你已经看到的整个回写协议。有时它会更新那些不同的实现。</p><p>发言人   20:29<br>But this is why it’s called a Snoopy cache is that basically Thread two is peeking into or getting access to information that’s available in thread one’s cache. And so now thread two will correctly get a copy of A that’s in this shared state. And the same goes with B, it will snoop over and thread 2, 1 will get a readable copy. These are now all marked as shared state, and so if. Either of them wanted to write. They’d have to now basically get exclusive access to it. And that would have to then disable the copy. The other in the other locations.<br>但这就是为什么它被称为史努比缓存的原因，基本上是线程二正在窥视或获取线程一缓存中可用的信息。现在，线程二将正确获取处于共享状态的的副本。对于B也是如此，它将窥探并线程2，1将获得一个可读的副本。这些现在都被标记为共享状态，所以如果。他们两个都想写作。他们现在基本上必须获得它的独家访问权。然后必须禁用副本。另一个在其他地方。</p><p>发言人   21:15<br>You can imagine this protocol being non-trivial, actually, to get right and to implement.<br>你可以想象这个协议并非易事，实际上，要正确实施。</p><p>发言人   21:20<br>And it gets way more complicated than this with all the variations on it. But it’s become the norm in multi-core hardware design. But it’s actually part of the factor that limits the core count on a processor, because just the hardware involved in keeping the consistency across the caches is non-trivial. It has to work very fast. We’re talking at the cash rate access speeds, so there’s not a lot of time involved in there. So actually implementing this stuff, making it run, making it scale across, say, 8 cores, 10 cores, 16 cores is not a trivial thing. But that goes on in the background. And so for most systems nowadays, you can assume that there’s some memory consistency model that you can program too, that’s supported by the hardware of the system and this serial Liz ability that’s referred to as sort of the easiest to understand, there’s others that are a little bit more nuanced.<br>而且由于它的各种变化，它会变得比这复杂得多。但它已经成为多核硬件设计的常态。但它实际上是限制处理器内核数的因素之一，因为仅保持缓存之间的一致性所涉及的硬件是不平凡的。它必须工作得非常快。我们正在以现金速率访问速度进行讨论，因此不会花费太多时间。因此，实际实施这些东西，使其运行，使其在例如8核、10核、16核之间扩展并不是一件小事。但这是在背景中发生的。因此，对于当今的大多数系统，您可以假设有一些内存一致性模型可以编程，这得到了系统硬件的支持，这种串行能力被称为最容易理解的，还有其他一些更加微妙的模型。</p><p>发言人   22:29<br>I guess that fell off the bottom here. That doesn’t seem right.<br>我想这是从底部掉下来的。这似乎不太对。</p><p>发言人   22:41<br>Nope, that’s it. Just to wrap that up, then it gives you a flavor of. And you can see that getting programs to run fast through multithreading is not not easy. You often have to rewrite your application. You have to think about the algorithm. You have to worry about debugging it. As you’ve already discovered, both the shell lab and the proxy lab, the concurrency where you can’t predict the order of events, makes it much more difficult to debug code.<br>不，就是这样。只是为了包装它，然后它会给你一个味道。你可以看到，通过多线程让程序快速运行并不容易。你经常需要重写你的申请。你必须考虑算法。你必须担心调试它。正如您已经发现的那样，无论是shell实验室还是代理实验室，由于并发无法预测事件的顺序，因此调试代码变得更加困难。</p><p>发言人   23:16<br>So all these factors come in, and you have to have some understanding of the underlying mechanisms that are used and what their performance implications are.<br>因此，所有这些因素都要考虑在内，你必须对所使用的基础机制以及它们对性能的影响有一些了解。</p><p>发言人   23:27<br>So in particular, let me just observe here that if I’m like doing synchronization across threads, like you saw that original one where they were fighting over this global variable p sum or whatever it was called, you can imagine the caches in this battle with each other to try and get exclusive access to this single memory value. Because each one is running as fast as it possibly can, but each one requires getting exclusive copy writing to it and releasing it. So the locking mechanism is flying back and forth between these caches. And it’s really not very fast. That the kind of thing is, why? And also, as an application programmer, you’re making calls. Semaphore call bounces you up into the OS kernel, which is a cost involved. So this thing has all the bad, all the things that make programs not run the way you really like them to.<br>所以特别地，让我在这里观察一下，如果我喜欢跨线程进行同步，就像你看到的那样，他们在争夺这个全局变量p sum或任何它被称为的东西，你可以想象在这场战斗中，缓存彼此试图获得对这个单一内存价值的独占访问。因为每个都尽可能快地运行，但每个都需要获取独家副本并发布。因此锁定机制在这些缓存之间来回飞行。而且速度真的不是很快。这种事情是为什么呢？而且，作为一名应用程序员，你也在打电话。信号量调用将您反弹到操作系统内核中，这涉及到成本。所以这个东西有很多不好的东西，所有让程序不能按你真正喜欢的方式运行的东西。</p><p>发言人   24:43<br>So that’s one of the challenges in parallel programming is how do you actually make use of the parallelism that’s there without getting bogged down by the cost of the various mechanisms of control? So anyways, this is part of what you have to appreciate and understand as a programmer is how these things work at a level deep enough that you’ll have some sense of what makes programs run faster or slower, where the mistakes go on.<br>因此，并行编程面临的挑战之一是如何真正利用并行机制，而不被各种控制机制的成本所困扰？因此，无论如何，作为一个程序员，你必须欣赏和理解的一部分是这些事情如何在足够深入的层面上工作，你将对什么使程序运行得更快或更慢有一些感知，哪里出错了。</p><p>发言人   25:13<br>So that’s just a little flavor of a much bigger topic. So that’s it for today.<br>所以这只是一个更大话题的一小部分。今天就到这里。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深入理解计算机系统 012-Cache Memories</title>
    <link href="/2025/10/12/15213-012/"/>
    <url>/2025/10/12/15213-012/</url>
    
    <content type="html"><![CDATA[<p>2025年10月02日 08:53<br>发言人   00:00<br>Good afternoon everyone. Welcome to 2&#x2F;13, good to see you. Just a reminder that your attack lab is due tonight at 1159 PM. You have one Grace Day for this lab and CA lab will go out at right about the same time. Now it’s going to be a little tight for CA Lab is it’ll be due next Thursday, so you might want to get started on that soon.<br>大家下午好。欢迎来到2&#x2F;13，很高兴见到你。只是提醒一下，你的攻击实验室定于今晚1159下午。你有一个实验室的宽限期，CA实验室将在大约相同的时间离开。现在CA实验室的情况会有点紧张，下个星期四就要交了，所以你可能想很快开始做这件事。</p><p>发言人   00:33<br>Last lecture, we learned about the memory hierarchy and the idea of caching. Today, we’re going to look at a very important kind of CA, which are called cache memories. And they’re very important to you as the programmer because they can have such a big impact on the performance of your program. So if you know about the existence of these cache memories and you know how they work as a programmer, you’ll be able to take advantage of that in your programs.<br>上一节课，我们学习了内存层次结构和缓存的概念。今天，我们将了解一种非常重要的缓存存储器，称为缓存存储器。它们对程序员来说非常重要，因为它们会对程序的性能产生很大的影响。因此，如果你知道这些缓存存储器的存在，并且你知道它们作为程序员是如何工作的，你就可以在你的程序中利用它们。</p><p>发言人   01:08<br>So last time we looked at the memory hierarchy, it’s a collection of storage devices with smaller cost air is, and faster devices at the top and. Slower, cheaper, and much larger devices at the bottom. And then at each level in this hierarchy A, the device at level K serves as a cache, holds a subset of the blocks that are contained in the device at the lower level at level k plus one.<br>所以上次我们看内存层次结构时，它是一系列成本较小的存储设备的集合，顶部是更快的设备。较慢、更便宜、更大的设备在底部。然后在此层次结构A的每个级别上，位于级别K的设备用作缓存，保存位于级别k加一的较低级别设备中包含的块的子集。</p><p>发言人   01:52<br>Now recall the general idea of caching. So we have a memory. It’s an array of bytes, and we break it up arbitrarily into a collection of blocks. This memory is larger, slower, and cheaper, and it’s much larger than a cache, which is smaller, faster, and more expensive, which holds a subset of the blocks that are contained in the main memory. And then blocks are copied back and forth between the cache and the memory in these block size transfer units.<br>现在回想一下缓存的一般想法。所以我们有了记忆。它是一个字节数组，我们将它任意分解为块的集合。这种内存更大、更慢、更便宜，并且比缓存大得多，后者更小、更快、更昂贵，后者保存了主内存中包含的一部分块。然后块在这些块大小传输单元中的缓存和内存之间来回复制。</p><p>发言人   02:29<br>So for example, if our program requests a word that’s contained in block number 4. It asks the cache to return the word that’s contained in block 4. The cache looks, and at the blocks, the subset of the blocks that it’s stored discovers that block 4 is not there. So it asks the main memory to send it block 4, which it does. And then when that block arrives at the cache, the cache stores it, potentially overriding some existing block.<br>因此，例如，如果我们的程序请求包含在第4块中的单词。它要求缓存返回块4中包含的单词。缓存查看并查看块，它存储的块的子集发现块4不存在。所以它要求主内存发送块4，它会这样做。然后，当该块到达缓存时，缓存会存储它，可能会覆盖一些现有的块。</p><p>发言人   03:05<br>Similarly, if our program asks for a data word that’s contained within block 10, the cache look sees that it doesn’t have that block. So it requests that block for memory, which copies it into the cache, which overwrites an existing block. Now, subsequently, if our program references a. Word that’s contained in block 10, for example. Then the cache. Then we have a hit, and the cache can return that block immediately without going through the expensive operation of contacting memory and fetching that block from memory.<br>同样，如果我们的程序要求一个包含在第10块中的数据字，缓存会发现它没有那个块。因此它请求该块内存，该内存将其复制到缓存中，从而覆盖现有块。现在，如果我们的程序引用了a。例如，包含在第10块中的单词。然后是缓存。那么我们有一个命中，缓存可以立即返回该块，而无需进行联系内存和从内存中获取该块的昂贵操作。</p><p>发言人   03:50<br>Now there’s a very important class of caches, these so called cache memories, which are contained in the CPU chip itself and are managed completely by hardware. And they’re implemented using fast SRAM memories. And the idea for this cache, which is right next to the register file, is to hold frequently access blocks or blocks from main memory that are accessed frequently. So hopefully, because of the principle of locality, most of our requests for data will actually be served out of this cache memory in a few cycles, rather than rather than from this slow main memory.<br>现在有一类非常重要的缓存，这些所谓的缓存存储器，它们包含在CPU芯片本身中，完全由硬件管理。并且它们是使用快速内存存储器实现的。这个缓存的想法就在寄存器文件旁边，用于保存频繁访问的块或来自主内存的频繁访问的块。所以希望，由于局部性的原则，我们对数据的大多数请求实际上将在几个周期内从这个缓存内存中提供，而不是从这个缓慢的主内存中提供。</p><p>发言人   04:40<br>Now, cache memories are managed completely in hardware. So this means that the heart, there has to be hardware logic that knows how to look for blocks in the cache and determine whether or not a particular block is contained there. Cache memories have to be organized in a very kind of strict, simple way so that if the lookup logic can be pretty simple.<br>现在，缓存内存完全在硬件中管理。因此，这意味着心脏必须有硬件逻辑，知道如何在缓存中查找块并确定是否包含特定块。缓存存储器必须以一种非常严格、简单的方式组织，这样如果查找逻辑可以非常简单。</p><p>发言人   05:07<br>All cache memories are organized in the following way. You can think of that. You can think of the cache as an array of s equals 2 to the s sets. Each set consists of e to the two e lines. Where each line consists of a block of b equal equals 2 to the b bytes of.<br>所有缓存存储器按以下方式组织。你可以想到这一点。您可以将缓存视为s等于2的s集合的数组。每组由两个e行组成。其中每一行由一个块b组成，等于2的b字节。</p><p>发言人   05:39<br>A valid bit. Which indicates whether these data bits are actually the bits in the data block are actually meaningful? It’s possible they could just be random bits. When you first turn on the machine, there’s nothing in the cache, but those bits will have values. They’ll either be ones or zeros, but they won’t actually correspond to data. So the valid bit tells us if these, if these b bytes actually mean anything. And then there’s some additional bits called the tag bits, which will help us search for blocks, which I’ll show you in a minute.<br>有效的位。这表明这些数据位是否实际上是数据块中的位实际上有意义？它们可能只是随机位。当你第一次打开机器时，缓存中没有任何东西，但那些位会有值。它们要么是1，要么是0，但它们实际上并不对应于数据。因此，有效位告诉我们这些，如果这些b字节实际上意味着什么。然后还有一些额外的位称为标记位，这将帮助我们搜索块，我稍后会向您展示。</p><p>发言人   06:17<br>Now, when we talk about our cache size, we’re referring to the number of data bytes that are contained in blocks. And so each cache has, there’s s sets, there’s e, e blocks per set, and there’s b bytes per block. So the total cache size c is s times z times b now. So there’s a lot of terms to sort of keep straight. And it’s very easy to get to confuse the difference between lines and blocks and lines and sets. So we’ll go through some examples, and hopefully these will start to make more sense.<br>现在，当我们谈论缓存大小时，我们指的是块中包含的数据字节数。因此每个缓存都有，有s个集合，每个集合有e，e个块，每个块有b个字节。所以总缓存大小c现在是s次z次b。所以有很多术语来保持直截了当。而且很容易混淆线和块、线和集合之间的区别。所以我们将通过一些例子，希望这些例子能开始产生更多的感知。</p><p>发言人   07:03<br>Now let’s look at in general. How the cache hardware implements a read, so accesses our program, executes an instruction that references some word in memory. The CPU sends that address to the cache and S, and it asks the cache to return the word.<br>现在让我们来看看总体情况。缓存硬件如何实现读取，因此访问我们的程序，执行引用内存中某个字的指令。CPU将该地址发送到缓存和S，并要求缓存返回单词。</p><p>发言人   07:33<br>The word at that address? And so the cache takes that address. This would be a 64 b address in the case of x 86, 64. And it divides the address into a number of regions, which are determined by the organization of the cache. They’re determined by those parameters s sets s, the number of sets e, the number of lines per set, and b, the size of each data block. So the order bits there are low order bits, which determine the offset in the block that that word starts at. The next S bits are treated as an unsigned integer, which serves as an index into the array of sets.<br>那个地址的词？因此缓存会获取该地址。在x86 64的情况下，这将是一个64 b的地址。它将地址划分为许多区域，这些区域由缓存的组织确定。它们由这些参数集合s、集合的数量e、每个集合的行数以及每个数据块的大小b决定。所以那里的顺序位是低阶位，它们决定了该单词开始的块中的偏移量。接下来的S位被视为无符号整数，用作集合数组的索引。</p><p>发言人   08:31<br>Remember, we just of these think of this cache as an array of sets. The set index bits provide the index into this array of sets, and then all of the remaining bits, all of the remaining t bits, constitute what we call a tag, which will help us when we do our search. So the cache logic takes this address, and it first extracts the set index and uses that as an index into this array to identify the set that if this block is in the set. I’m sorry if the word, if the block that contains the data word at this address is in the cache, it’s going to be in the set denoted by the set index. So first, it identifies which index to look in.<br>请记住，我们只是将这个缓存视为集合数组。集合索引位提供了这个集合数组的索引，然后所有剩余的位，所有剩余的t位，构成了我们所说的标记，这将在我们搜索时有所帮助。因此，缓存逻辑获取此地址，首先提取集合索引，并将其作为此数组的索引，以标识此块是否在集合中的集合。对不起，如果这个词，如果包含这个地址的数据字的块在缓存中，它将在由集合索引表示的集合中。所以首先，它确定要查看的索引。</p><p>发言人   09:36<br>And then it checks the tag. It checks all of the lines in that set to see if there’s any of those lines have a matching tag, a tag that matches t, the tag bits in the address. And it checks to see if the valid bit is turned on. So if those two conditions hold, if there’s a line anywhere in the set where the valid bit is one and there’s a matching tag, then we have a hit. Then the block that we’re looking for is contained in this set.<br>然后它检查标签。它会检查该集合中的所有行，以查看是否有任何一行具有匹配的标签，一个与地址中的标签位t匹配的标签。它会检查有效的位是否打开。因此，如果这两个条件成立，如果在集合中的任意位置有一行，其中有效位为1，并且有一个匹配的标签，那么我们就有一个命中。那么我们要寻找的区块包含在这个集合中。</p><p>发言人   10:17<br>Once we determine that we’ve identified the block, then the cache uses the low order B bits to determine where the data we’re interested in begins within that block.<br>一旦我们确定已经识别出了该块，缓存就会使用低位B位来确定我们感兴趣的数据在该块中从哪里开始。</p><p>发言人   10:33<br>All right, let’s look at a more specific example for the simplest kind of cache, which is when e equals one, when there’s only one line per set. So e equal 1, 1 line per set, this kind of cache is called a direct map cache. So here we have S sets. Each set consists of a single line.<br>好的，让我们来看一个更具体的例子，关于最简单的缓存类型，也就是当e等于一时，每套缓存只有一行。所以e等于每套1，1行，这种缓存称为直接地图缓存。所以在这里，我们有S个集合。每组由一条线组成。</p><p>发言人   10:57<br>And now suppose our program references a data item and a particular address. The CPU sends that address to the CA, the cache takes that address, breaks it up into into these three fields. For this particular address, the block offset is 4, and the set index is one. And then there’s some tag bits, which we’ll just denote with with the color pink. So the cache extracts the set index, which is one, and then it uses that as as the index into the set.<br>现在假设我们的程序引用了一个数据项和一个特定的地址。CPU将该地址发送给CA，缓存获取该地址，将其分解为这三个字段。对于这个特定的地址，块偏移量是4，而集合索引是1。然后还有一些标记位，我们将用粉红色表示。所以缓存提取集合索引，即1，然后将其作为集合中的索引。</p><p>发言人   11:42<br>And then it just ignores all the other, the sets. If the block we’re looking for is in the cache, it’s going to be in this in set number one. Then it does the comparison of the tag bits and the valid bits and assume that it valid bits on and that it matches. Then it looks at the block offset, which is 4. Which tells it that the 4 B n, suppose that that’s what the instruction was referencing. The 4 B in begins at offset 4. So now the cache takes this in and it sends it back to the to the CPU, which puts it in the register.<br>然后它忽略了所有其他的集合。如果我们要寻找的块在缓存中，它将在集合1中。然后它对标记位和有效位进行比较，并假设其有效位并且匹配。然后它查看块偏移，即4。这告诉它4 B n，假设这就是指令所引用的。中的4 B从偏移量4开始。所以现在缓存接收这个内容并将其发送回CPU，CPU将其放入寄存器中。</p><p>发言人   12:30<br>If the tag doesn’t match, then the old line. If the tag doesn’t match, then there’s a miss. And in that case, the cache has to fetch the block, the corresponding block from memory, and then overwrite this block in the line. And then it, it can get the word out of the block and send it back to the processor.<br>如果标签不匹配，则使用旧行。如果标签不匹配，则存在未匹配。在这种情况下，缓存必须从内存中获取块，相应的块，然后在行中覆盖此块。然后它可以从块中获取单词并将其发送回处理器。</p><p>发言人   12:58<br>Let me ask you a question just to see, kind of check to see if you’re following along with this. So if there’s a miss and the cache has to request the block from memory, fetch it from memory, and then overwrite the block and the current line, does it also have to change the tag bits, or do those stay the same? So do the tag bits that were in this line get overwritten with a different value? Or is it the same, same, different, same, different? Now, why would it be different? We haven’t changed, yes.<br>让我问你一个问题，只是为了看看，看看你是否遵循了这个。因此，如果发生未命中，缓存必须从内存中请求块，从内存中获取它，然后覆盖块和当前行，它是否也必须更改标记位，或者这些位保持不变？这一行中的标记位会被不同的值覆盖吗？还是相同，相同，不同，相同，不同？现在，为什么会有所不同？我们没有改变，是的。</p><p>发言人   13:56<br>I’m oh. It almost certainly has different data, but does it have a different address? What you missed because the tag didn’t?<br>我是哦。它几乎肯定有不同的数据，但是它有不同的地址吗？你错过了什么，因为标签没有？</p><p>发言人   14:14<br>Exactly, it missed because the tag, it missed because the tag didn’t match. If the valid bit was false and the tag matched, then that would also be a miss. Oh, then you wouldn’t. Okay, that’s right. Good, good, good, great.<br>确切地说，它错过了，因为标签不匹配。如果有效位为假且标记匹配，则也将是未命中。哦，那你就不会。好的，没错。很好，很好，很好。</p><p>发言人   14:40<br>A, let me do a really simple, specific example of how direct-mapped she works. I want you to understand in real detail how this would work. But I also want to make a point. The weakness of direct map caches and why you would want to have more than one line per set.<br>让我做一个非常简单、具体的例子，说明她是如何直接映射的。我希望你能真正详细地了解这将如何工作。但我也想提出一个观点。直接地图缓存的弱点以及为什么你希望每个集合有多条线。</p><p>发言人   15:06<br>Okay, so this is a really simple we have our memory system consists of 16 B. So it’s not a very useful system with 4 b addresses, and it’s broken up into blocks of 2 B each. Our cache consists of four sets with one block per set. Now our 4 b addresses, because b equals 2, 2 to the one, we only need one block offset bit. There’s only 2 B in a block. The byte we’re looking for is either at 0 or one. Because we have four sets, two set index bits, and then the remaining bits are always tag bits. So in this case, there’s just one tag bit.<br>好的，这是一个非常简单的，我们的记忆系统由16个B组成。因此，它不是一个具有4 b地址的非常有用的系统，它被分成每个2 B的块。我们的缓存由四个集组成，每个集有一个块。现在我们的4个b地址，因为b等于2，2的1，我们只需要一个块偏移位。一个街区只有2个B。我们要寻找的字节不是0就是一。因为我们有四个集合，两个集合索引位，然后剩余的位总是标记位。所以在这种情况下，只有一个标记位。</p><p>发言人   15:59<br>Alright, now let’s suppose that our program executes instructions that reference the following memory addresses 0, 1, 7, 8, and 0. And these references are reads that they’re reading 1 B per read.<br>好的，现在假设我们的程序执行的指令引用了以下内存地址0、1、7、8和0。这些参考文献是阅读材料，它们每次读取1 B。</p><p>发言人   16:20<br>Like I said, this is a really simple system. So let’s look at what happens now. We start out, initially, our cache is empty. Valid bits are all set to 0. And now the cache receives a request for the byte that’s at address 0. So it extracts the set index bits, which in this case are 0, 0. So it’s going to look and set zero for. And in this case, since valid is 0, it’s a miss. So it fetches that block from memory, sticks the block. So this is using array notation for memory. So this is the bytes that extend from offset zero to offset one inclusive. In memory. The tag bit is 0, and the valid bit is one.<br>就像我说的，这是一个非常简单的系统。那么让我们看看现在发生了什么。我们开始时，最初，我们的缓存是空的。有效位都设置为0。现在缓存收到对地址0的字节的请求。所以它提取设置的索引位，在这种情况下为0，0。所以它会寻找并设置零。在这种情况下，由于valid为0，所以它是一个未命中。所以它从内存中获取那个块，然后粘在这个块上。所以这是对内存使用数组表示法。所以这是从offset 0到offset 1扩展的字节。在记忆中。标签位是0，有效位是1。</p><p>发言人   17:27<br>Now, the next address that comes by is for address one, well, that’s a hit, right, because that block, the block that contains the byte at address one, is already in the cache tag, and the tags match, so we’re good. That’s a hit.<br>现在，下一个出现的地址是地址一，嗯，这是一个命中，因为那个块，包含地址一的字节的块，已经在缓存标签中了，标签匹配，所以我们很好。这很成功。</p><p>发言人   17:48<br>Now we get address 7, so the cache extracts the set index bits, which in this case are 1, 1, or 4, or three rather looks in set three, there’s no valid bit, so that’s a miss, and it loads the data from memory that spans bytes 6 and 7. In this case, the tag bit is 0, so that we record that in our metadata.<br>现在我们得到了地址7，因此缓存提取了设置的索引位，在这种情况下是1、1或4，或者在设置三中查找三个，没有有效的位，所以这是一个错过，它从跨度为6字节和7字节的内存中加载数据。在这种情况下，标签位为0，因此我们将其记录在元数据中。</p><p>发言人   18:24<br>The next reference that comes by is 8. Now 8 has a set index of 0 0 0, but that’s currently occupied by block 0 1. And we can tell that address 8 has a tag of one and the existing. The earlier address, address 0, has a tag of 0. So that’s a miss. So now we have to go fetch the block containing byte number 8 into memory. So now we have bytes 8 and 9 in our new tag bit.<br>接下来的引用是8。现在8的设置索引为0 0，但目前被块0 1占用。我们可以分辨出地址8的标签是1，而现有的标签是1。之前的地址，地址0，其标签为0。所以这是一个小姐。所以现在我们必须将包含字节数8的块提取到内存中。现在我们的新标签位中有字节8和字节9。</p><p>发言人   19:07<br>Okay, now the next instruction is for byte 0, and we had that in our cache and we just replaced it. So it’s another miss. So that’s unfortunate. And the only reason we missed it, it’s because we’ve got just one line per set. So we were forced to overwrite.<br>好的，现在下一条指令是针对字节0的，我们已经把它放在缓存中，然后我们就替换了它。所以这是另一个小姐。所以这是不幸的。我们错过它的唯一原因是因为我们每套只有一行。所以我们被迫覆盖。</p><p>发言人   19:37<br>That that block containing bytes block 0 1 when we missed on block 8 9. So this, and you see there’s plenty of room in our cache. We’ve still got, we’ve got 2, two lines that we haven’t even accessed. So our cache is plenty big. But just because of the low associativity of our cache and the sort of the pattern, the access pattern that we were presented with, we’ve got a miss that really was kind of unnecessary. Oh, yeah, sorry.<br>当我们错过了第8块9时，那个包含了第0 1块字节的块。所以这一点，你会发现我们的缓存中有足够的空间。我们还有，我们还有2，2行我们甚至还没有访问过。所以我们的缓存很大。但仅仅因为我们的缓存的低相关性和模式的类型，我们所呈现的访问模式，我们有一个实际上是不必要的遗漏。哦，是的，对不起。</p><p>发言人   20:30<br>So when we referenced, when we referenced 7, it’s actually it’s at offset one in that block 6, 7. Since our blocks are 2 B, they’ll always start on an even multiple.<br>所以当我们引用时，当我们引用7时，它实际上是在那个块6、7中的偏移量1。由于我们的区块是2 b，它们总是从偶数倍数开始。</p><p>发言人   20:53<br>Any other questions? Okay, so this, so this sort of is the reason why you have caches have higher associativities, higher values of e, so let’s look at, and so for values of e, greater, for values of e greater greater than one, we refer to them as e way set associative caches. So here e equals two, so it’s a two way associative.<br>还有什么问题吗？好的，所以这就是为什么缓存具有更高的关联性，更高的e值的原因，所以让我们来看看，对于e的值，更大的e，我们将它们称为e方式集关联缓存。这里e等于2，所以它是双向联想的。</p><p>发言人   21:31<br>So let’s suppose we have a two way associative cache. We have our array of sets, and now each set contains two lines instead of one line. And suppose we’re presented with an address with the following form. We’re looking for a word that begins at an offset of four inside our block. At within set number one. So the cache extracts that set index. So this is set 0, this is set one, this is set two, throws away all the other sets.<br>那么让我们假设我们有一个双向关联缓存。我们有了集合数组，现在每个集合包含两行而不是一行。假设我们看到一个具有以下形式的地址。我们正在寻找一个在我们的区块内以四个偏移量开头的单词。在设定的第一个范围内。所以缓存提取了设置索引。所以这个设置为0，这个设置为1，这个设置为2，把所有其他的设置都扔掉。</p><p>发言人   22:23<br>And now in parallel, it searches. It searches the tags. It searches for a matching tag in both of these lines and a valid bit. So if we get a matching tag and a valid bit true, then we’ve got A, then we’ve got a hit. Now, yes, yes.<br>现在，它同时进行搜索。它搜索标签。它在这两行中搜索匹配的标记和一个有效的位。因此，如果我们获得了匹配的标签和一个有效的位为真，那么我们就得到了一个，那么我们就得到了一个成功。现在，是的，是的。</p><p>发言人   22:58<br>Oh, it’s a very good question. There’s hardware logic that does that compare. And that’s the reason as the number, as the associativity goes up, that logic gets more and more expensive.<br>哦，这是一个非常好的问题。有硬件逻辑可以进行比较。这就是原因，随着关联性的增加，逻辑变得越来越昂贵。</p><p>发言人   23:12<br>It’s like, like you’re kind of doing some kind of tree search. And so that actually is the limit. That’s why I mean, because in general, if you take this to the limit, there’s just one set with. We call that a fully associative cache. So there’s just one set. And now a block can go anywhere. There’s no constraints now in where you place a block, but because of the complexity of that fully associative search, those are very rare. We do see, we’ll see fully associative caches, but they’re software caches. So in software, so the complexity of the hardware sort of doesn’t. It’s not worth the complexity of the hardware for the penalty of having a lower associativity.<br>这就像你在做某种树搜索。所以这实际上就是极限。这就是我的意思，因为一般来说，如果你把它带到极限，只有一组。我们称之为完全关联缓存。所以只有一组。现在一个街区可以去任何地方。现在在放置块的位置上没有任何限制，但由于完全关联搜索的复杂性，这种情况非常罕见。我们会看到完全关联的缓存，但它们是软件缓存。所以在软件方面，所以硬件的复杂性不是这样。不值得硬件的复杂性来换取较低的关联性的惩罚。</p><p>发言人   24:14<br>But there are some systems later on when we study virtual memory. In a virtual memory system, the DRAM serves as a cache for data stored on the disk. And as we saw last time, the penalty for a miss if you have a cache on DRAM and you miss and you have to go to disk, the penalty is huge for that. And so because of that, it’s worthwhile having very complex searches, search algorithms, in particular, in a virtual memory system.<br>但是当我们研究虚拟内存时，还有一些系统。在虚拟内存系统中，DRAM充当存储在磁盘上的数据的缓存。正如我们上次看到的，如果您在DRAM上有缓存，并且您必须转到磁盘，则未命中的罚款是巨大的。正因为如此，非常复杂的搜索和搜索算法是值得的，特别是在虚拟内存系统中。</p><p>发言人   24:47<br>The DRAM is implements a fully associative cache where blocks from disk can go anywhere. We’ll get into that later when we look in virtual memory. But you’re right. You’ll see in real systems nowadays that the number goes up because feature sizes are going down and designers can afford to implement more expensive hardware.<br>DRAM实现了一个完全关联的缓存，磁盘中的块可以被缓存到任何地方。我们稍后在查看虚拟内存时会深入探讨这个问题。但你是对的。你会发现，在当今的实际系统中，由于特征尺寸越来越小，设计人员可以负担得起实现更昂贵的硬件，因此这个数字会上升。</p><p>发言人   25:08<br>The largest associ tivity on Intel systems that I know of is 16 way associative L 3 caches, and then the other is a right way associative. So that’s sort of the order of magnitude. That’s state of the art right now. So then once we’ve identified a match, we use the set offset bits. In this case, we are accessing a short in four. Is the offset within the block of this, the 2 B short, in which then we can return to the processor?<br>我所知道的在英特尔系统上最大的关联是16路关联L 3缓存，然后另一个是正确的关联。这就是数量级。这是目前的艺术水平。因此，一旦我们确定了匹配项，我们就使用设置的偏移位。在这种情况下，我们将访问一个短在四个。这个块内的偏移量，2 b短，然后我们可以返回处理器吗？</p><p>发言人   25:41<br>So let’s do that same simulation that we did before, but this time with a two way associative cache. Now, memory system is the same, but now instead of one set, we have two sets. And I mean I’m sorry, instead of four sets, we have two sets. So the cache, this is the same sized cache, but we’re just going to organize it differently instead of one way, instead of a direct map cache with four lines containing four lines, 1 line per set, we’re going to implement a two way associative CA, where we have two sets with two lines per set. So in each case, there’s just there’s 4 total lines question.<br>所以让我们进行之前的相同模拟，但这次使用的是双向关联缓存。现在，记忆系统是相同的，但现在我们有了两个集合，而不是一个集合。我的意思是，对不起，我们有两套，而不是四套。所以缓存，这是大小相同的缓存，但我们将以不同的方式组织它，而不是一种方式，而不是直接使用四行包含四行的直接地图缓存，每行每行，我们将实现一个双向关联CA，其中我们有两个集合，每个集合有两条线。所以在每种情况下，只有总共4行的问题。</p><p>发言人   26:31<br>Oh, so that comes in with the request somehow. And I actually don’t know the details of that. I guess it could ask for just there could just be a default size. Maybe it’s always, it’s always a 64 B word and then the processor extracts the current bits. Don’t know the details of that, but it either comes in on the request or there’s standard, there’s a standard size that the processor then parses out. We’ll just assume that the cash knows what size to return, yes?<br>哦，所以这是以某种方式与请求一起出现的。实际上我不知道其中的细节。我想它可能会要求一个默认大小。也许它总是，它总是一个64 b的字，然后处理器提取当前的位。不知道细节，但它要么根据请求提供，要么是标准的，处理器会解析出标准大小。我们假设现金知道返回的大小，对吧？</p><p>发言人   27:10<br>How do you decide which block to replace? That’s a really good question. So there’s a lot of different algorithms. The most common algorithm or a common algorithm is least recently used. So by locality, you want to, you want to keep blocks in the cache that are being used a lot. And so if a block isn’t referenced for a long time by the principle of locality, by sort of the inverse locality principle, it’s likely not to be addressed, referenced in the near future. So that’s one algorithm that you just keep track of. And I’m not showing there needs to be additional bits in the line to sort keep sort of virtual timestamps. But that’s sort of the general way you do it.<br>你如何决定替换哪个区块？这是一个非常好的问题。所以有很多不同的算法。最常用的算法或常用算法最近最少使用。因此，根据位置，您希望将经常使用的块保留在缓存中。因此，如果一个区块在很长一段时间内没有被局部性原则所引用，或者被逆局部性原则所引用，那么在不久的将来，它很可能不会被解决。所以这是你只需要跟踪的一种算法。并且我没有展示需要行中有额外的位来排序并保持虚拟时间戳。但这是你通常的做法。</p><p>发言人   27:59<br>Try to keep the things that are the blocks that are being accessed the most frequently, most recently.<br>尽量保留最频繁、最近访问的内容块。</p><p>发言人   28:10<br>Okay, the question is, what determines the block size? That’s determined by the design of the memory system. So that’s a fixed parameter of the memory system. So when the Intel designers decided to put cache memories on their processors, they decided that the block size would be 64 B. Sorry. So the block size, the block size comes first. Then you determine how big you want your cash to be, and you determine the associativity. And then once you’ve determined the associativity and you know how big your cache is, then that determines the number of sets. So basically all of those.<br>好的，问题是，什么决定了块的大小？这是由记忆系统的设计决定的。所以这是记忆系统的固定参数。因此，当英特尔设计师决定在他们的处理器上放置缓存存储器时，他们决定块大小为64 b。对不起。所以区块大小，区块大小是第一位的。然后你决定你希望你的现金有多大，你决定了关联性。一旦你确定了关联性，并且知道了你的缓存有多大，那么就决定了集合的数量。基本上所有这些。</p><p>发言人   29:11<br>The. And the capacity, the number of lines. Per set is sort of a fixed high level parameter design parameter. The size of the cache is a high level design parameter. And then the number of sets then is induced from that, yes?<br>这个。以及容量，线路数量。每个集合是一种固定的高水平参数设计参数。高速缓存的大小是一个高级设计参数。然后集合的数量是由此归纳的，对吗？</p><p>发言人   29:43<br>Yeah, that’s the replacement policy. So the question is, when there’s multiple lines in a set, how does it determine which to overwrite? And that was the previous question. Maybe I should have repeated it. So you try to pick a line that was least recently used, so lines, lines that haven’t been accessed recently are good candidates for replacement because of the sort of inverse locality principle, right? That they haven’t been inverse referenced recently, chances are they won’t be referenced again.<br>是的，这就是替换政策。所以问题是，当一个集合中有多行时，它如何确定要覆盖哪一行？这是之前的问题。也许我应该重复一遍。因此，您尝试选择最近最少使用的行，因此最近没有访问的行是替换的良好候选，因为存在反向局部性原则，对吗？最近没有被反向引用，它们很可能不会被再次引用。</p><p>发言人   30:21<br>Oh yeah, there’s additional bits that I’m not showing here that you have to. So, so when you replace a line in the set, if that data has changed, then it has to be written back to memory. And that’s another bit I haven’t shown yet.<br>哦，是的，还有一些额外的部分我不在这里展示，你必须这样做。因此，当替换集合中的行时，如果数据已更改，则必须将其写回内存。这是我还没有展示的另一点。</p><p>发言人   30:46<br>So yeah. So this is a. Really, this is a really tricky parameter. And it’s a high level of system parameter that goes on for years. So the idea you want to have blocks in order to exploit spatial locality. Think about it, if you’re going to go to the trouble, if you have a miss in cash and you’re going to go to the trouble of going all the way to memory to get some data, you want to amortize the cost of fetching that data by fetching more than 1 B. That’s the motivation for block, because by the principle of locality, spatial locality in particular, if you reference a word inside of a block, chances are you’re going to reference a nearby word, which will also be an E block. So blocks, The whole purpose of blocks is to exploit spatial locality.<br>所以是的。所以这是a。真的，这是一个非常棘手的参数。这是一个持续多年的高水平系统参数。所以你想要有块来利用空间局部性的想法。想想看，如果你要麻烦了，如果你错过了现金，你要麻烦地去内存获取一些数据，你想通过获取超过1 b来分摊获取这些数据的成本。这就是块的动机，因为根据局部性原则，特别是空间局部性，如果你在一个块中引用一个词，你很可能会引用一个附近的词，这也将是一个E块。所以块，块的整个目的是利用空间局部性。</p><p>发言人   31:45<br>Now, if you make your block too small, then you don’t amortize, you don’t get the same amortization, you maybe get one, you bring the block in, so there’s a reference, you get a miss, you bring the block in, there’s another reference nearby, you get a hit because the block’s in memory, but then the next reference is in a different block because your block sizes are too small. So you kind of want to make blocks big as big as possible, but without slowing the system down. So if you made your block size too big, it would just take too long to bring that block in Plus now your blocks are taking up bits in your cache memory. So now there’s no room for other blocks.<br>现在，如果你让你的区块太小，那么你就不会摊销，你不会得到相同的摊销，你可能会得到一个，你把区块带进来，所以有一个参考，你会错过，你把区块带进来，附近还有另一个参考。你会得到点击，因为块在内存中，但是下一个引用在不同的块中，因为你的块大小太小了。因此，您有点希望使块尽可能大，但不能减慢系统的速度。因此，如果您的块大小太大，那么将该块加入所需的时间太长，现在您的块正在占用缓存中的位。所以现在没有其他街区的空间了。</p><p>发言人   32:30<br>So it’s a really tricky design problem, right? If we were taking an architecture class, then we would sort of dive into how architects make those design decisions, but in general that it’s kind of a balancing act, right? Were there any other questions, yes?<br>所以这是一个非常棘手的设计问题，对吧？如果我们上了建筑学课程，那么我们会深入了解建筑师如何做出设计决策，但总的来说，这有点是一种平衡，对吧？还有其他问题吗，是的？</p><p>发言人   32:58<br>Oh, the question is, every time there’s a myth, do you have to select a victim line and overwrite it? Yeah, I don’t know of any caches that don’t do that. Now, we’ll see when we look at rights, we’ll see there’s an option of whether we’re only looking at reads right now, But with writes, that question does come up. If you wait in a couple of slides, we’ll go over. We’ll go over that. Any other questions?<br>哦，问题是，每次有一个神话，你必须选择一个受害者行并覆盖它吗？是的，我不知道有任何缓存不这样做。现在，当我们看权利时，我们会看到有一个选项，即我们现在是否只看阅读，但对于写作，这个问题确实会出现。如果您在几张幻灯片中等待，我们将会过去。我们会讨论一下。还有什么问题吗？</p><p>发言人   33:31<br>OK, so let’s look at this two way associative cache. Now there’s one block offset bit. We only have two sets, so we only need one set index. And then the remaining 2 b are tagged.<br>好的，让我们来看看这个双向关联缓存。现在有一个块偏移位。我们只有两个集合，所以我们只需要一个集合索引。然后剩余的2 b被标记。</p><p>发言人   33:45<br>So let’s go through our trace. So address 0 has a set is in set zero right here, that’s a miss, so we load that into memory. The reference to address one that’s in set zero. And that’s a hit because that byte is in, is in our block. The reference to 7 is a miss that’s in set one. So we load that. And we were just picking randomly pick one of these to overwrite because the cache is empty. The next reference is to address number 8, which is in set 0.<br>让我们回顾一下我们的踪迹。因此，地址0有一个集合在这里的集合0中，这是一个未命中，因此我们将其加载到内存中。在设置0中的地址的引用。这是一个命中，因为那个字节在，在我们的块中。对7的引用是在设置1中的失误。所以我们加载它。我们只是随机选择其中一个来覆盖，因为缓存是空的。下一个参考地址是8，它在集合0中。</p><p>发言人   34:28<br>Now, here’s the difference between the direct map cache and this two way set associative cache. When we reference address 8, that block, the corresponding block has to go into set zero because of this zero set index bit. But we’ve got room now because we are sets have room for two lines instead of one. So when we load that in, if we have an available empty slot, we’ll put it there. We won’t overwrite anything. We’ll always try to overwrite empty, empty lines.<br>现在，这是直接地图缓存和这种双向集合关联缓存之间的区别。当我们引用地址8时，相应的块必须进入设置0，因为这个设置0的索引位。但是我们现在有空间了，因为我们的设置有两条线而不是一条线的空间。所以当我们加载它时，如果我们有一个可用的空插槽，我们会把它放在那里。我们不会覆盖任何东西。我们总是会尝试覆盖空的行。</p><p>发言人   35:04<br>So now we’ve got in this set, we’ve got block 0 1 and block 8, 9. So when we get our reference block to address zero, whereas before with the when we had a conflict miss in the direct map cache, now we can satisfy that request. It hits in memory and the cache can satisfy it from the cache instead of going to memory.<br>所以现在我们有这个集合，我们有第0 1个区块和第8、9个区块。因此，当我们将参考块的地址设置为零时，而在之前，当我们在直接映射缓存中发生冲突时，现在我们可以满足该请求。它会进入内存，缓存可以从缓存中满足它，而不是进入内存。</p><p>发言人   35:29<br>That makes sense? Okay, now what about rights? So there’s multiple copies of the data we’re subsetting. As we move up the hierarchy, we’re creating subsets of of the data in the caches. So what do we do? If we do a write to a word within a block that’s currently in the cache, we have two options.<br>这就是感知？好的，那么权利呢？所以我们正在创建子集的数据有多个副本。随着层次结构的向上移动，我们正在创建缓存中数据的子集。那么我们该怎么办？如果我们对当前缓存中的块中的单词进行写入，我们有两个选择。</p><p>发言人   36:07<br>We can write that block immediately to memory. We’ve got a block that’s like this big, and we’re updating a little chunk of it. So we can either do the update and then flush it to memory immediately so that memory always mirrors the contents of memory, always mirror the contents of the cache. But that’s expensive, right? I mean, memory accesses are expensive.<br>我们可以立即将该块写入内存。我们有一个这么大的区块，我们正在更新其中的一小部分。因此，我们可以进行更新，然后立即将其刷新到内存中，以便内存始终镜像内存的内容，始终镜像缓存的内容。但那很贵，对吧？我的意思是，内存访问是昂贵的。</p><p>发言人   36:36<br>So the other option is what’s called write back. So in this case, when we write to a block in the cache, we don’t flush it to memory until we elect that particular line as a victim that’s going to be overwritten. And only then, only then when we’re just, we sort of defer the writing to memory until the last possible minute. We defer it until just before the cache would overwrite that that data block. So that’s called right back. And for write back, you need to have an extra bit in the line that indicates whether that block’s been written to.<br>所以另一个选择是所谓的回写。因此，在这种情况下，当我们写入缓存中的块时，我们不会将其刷新到内存中，直到我们选择该特定行作为将被覆盖的受害者。只有这样，只有当我们公正的时候，我们才会把写作推迟到记忆的最后一分钟。我们将其推迟到缓存将覆盖该数据块之前。这被称为 “右后”。而对于写回，行中需要有一个额外的位，指示该块是否已写入。</p><p>发言人   37:15<br>So the algorithm is when the cache identifies a particular line to overwrite, it checks the dirty bit on that line. If it’s set, then it writes that data back to disk. If the data, if that block hasn’t been written, there’s no need to write it back it. It has the same value as the copy of the block on disk.<br>因此，算法是当缓存标识要覆盖的特定行时，它会检查该行上的脏位。如果设置了，那么它会将数据写回磁盘。如果数据，如果那个块没有被写入，就不需要把它写回去了。它与磁盘上的块副本具有相同的值。</p><p>发言人   37:43<br>OK, now, so that’s a right hit. Now, what happens if we have a right miss? So we’re doing a write to memory, and the word that we’re writing is not contained in any block that’s in our cache. So we have two options, we can do what’s called write allocate, so we can treat it if there’s a miss, we can do sort of the symmetric thing that we did with a hit, which was create a new, a new line, possibly overriding an existing line, and then, right? So we could, so we could create that cache ent that cache line, fetch it from memory, and then do the right. So this is sort of symmetric to reads, So every right, if it misses when the write finishes, that block will be in the cache. And if we do a subsequent read, we’d get a hit. So that’s the reason you might want to do that.<br>好的，现在，这是一个正确的打击。现在，如果我们有正确的失误会发生什么？所以我们正在对内存进行写入，并且我们正在编写的单词不包含在我们缓存中的任何块中。所以我们有两个选项，我们可以做所谓的写入分配，这样如果有未命中，我们可以对待它，我们可以做一些对称的事情，就像我们在命中一样，创建一个新行，可能覆盖现有行，然后，对吗？所以我们可以创建那个缓存线，从内存中获取它，然后执行正确的操作。所以这对读取有点对称，所以如果在写入完成时错过了，那个块将在缓存中。如果我们进行后续的阅读，我们会得到一个打击。这就是你可能想要这样做的原因。</p><p>发言人   38:42<br>The other option is just don’t loate an entry in the cache. Don’t allocate a new line, just write the data directly to memory. You don’t really need to understand the distinction between these two things.<br>另一种选择是不要在缓存中存储条目。不要分配新行，只需将数据直接写入内存。你真的不需要理解这两件事之间的区别。</p><p>发言人   38:59<br>Different caches use different policies for your own mental model. A good model to use is just to assume right back, right allocate. So just assume that we won’t copy the data to disk. If there’s a hit, we won’t write it back to disk until the last possible minute. And every time there’s a right myth, we’ll create a new entry in the cache. I think that’s sort of the simplest model, and it’s a reasonable model that you can use regardless of the particular CA implementation.<br>不同的缓存针对您自己的心理模型使用不同的策略。一个好的模型就是假设正确的回报，正确的分配。所以只要假设我们不会将数据复制到磁盘上。如果发生命中，我们直到最后一分钟才会将其写回磁盘。每当出现正确的神话时，我们都会在缓存中创建一个新条目。我认为这是最简单的模型，而且这是一个合理的模型，无论特定的CA实现如何，您都可以使用。</p><p>发言人   39:36<br>Now, in a real system, so far, we’ve only looked at, we’ve only assumed that there’s a single cache, but in real systems. There’s multiple caches. So modern Core i7 Haswell architecture from Intel. Contains multiple processor cores, so 4 is a typical number for like desktop systems, 8, 8 to 12 is typical for server class systems. These processor cores can each execute their own independent instruction stream in parallel, and each processor core contains general purpose registers, which that’s level 0 in the cache. And then two different kinds of L 1 caches, the data CA, the L 1 D cache, and the i-cache, which is the instruction cache. And these are fairly small, 32K bytes. They’re 8 way associative, and they can be accessed in a very small number of cycles.<br>现在，在一个真实的系统中，到目前为止，我们只看到了，我们只假设有一个单一的缓存，但在真实的系统中。有多个缓存。因此，现代核心i7具有来自英特尔的良好架构。包含多个处理器内核，因此4是台式机系统的典型数字，8、8到12是服务器级系统的典型数字。这些处理器内核可以并行执行它们自己的独立指令流，每个处理器内核包含通用寄存器，即缓存中的0级寄存器。然后是两种不同类型的L 1缓存，即数据CA、L 1 D缓存和i缓存，后者是指令缓存。这些都是相当小的，32k字节。它们是8路关联的，并且可以在非常少的周期内访问它们。</p><p>发言人   40:49<br>The next level of the hierarchy is is an L 2 cache, which is still fairly small, 256 kB, same associativity. And it has a slightly longer access time. And it’s unified in the sense that the L 2 cache contains both data and instructions. So that’s all within a single core on the chip and then also on the chip, but external to all the cores and shared by all the cores is an L 3 unified cache, which is 8 MB and 16 way associative with an access time that’s like 40 to 75 cycles. So if there’s a miss in L 1, then the L 1 sends a request to L 2 to try to find the data in L 2. Since L 2 is a little bigger, maybe the data hasn’t been flushed out of L 2 yet. If L 2 can’t find it, it sends a request to L 3 to see if it can find the data in L 3. If L 3 can’t find it, then it gives up and it goes off chip to memory.<br>层次结构的下一个级别是一个L2缓存，它仍然相当小，256 kB，相同的结合性。并且它的访问时间稍长。并且L 2缓存包含数据和指令的感知是统一的。所以这一切都在芯片上的一个核心内，然后也在芯片上，但是在所有核心的外部并由所有核心共享的是一个L 3统一缓存，它是8 MB和16方式相关联的访问时间，大约是40到75个周期。因此，如果在L 1中存在未命中，则L 1向L 2发送请求以尝试查找L 2中的数据。由于L 2稍微大一些，也许数据还没有从L 2中清除出去。如果L 2找不到，它会向L 3发送请求，以查看是否能在L 3中找到数据。如果L 3找不到它，那么它会放弃，从芯片转到内存。</p><p>发言人   42:02<br>Yes, question? Yes, name memories. Is it’s the DRAM built of DRAM chips? It’s in a separate, separate set of chips on the motherboard connected by those that IO bridge and the various buses that we talked about last time.<br>是的，有问题吗？是的，回忆的名字。这是由DRAM芯片构建的DRAM吗？它位于主板上单独的一组芯片中，由我们上次谈到的IO桥和各种总线连接。</p><p>发言人   42:31<br>And for all of these different caches, the block size is 64 B. Now, there’s a number of different ways to think about the performance of caches. My most common way is using a metric called the miss rate. So this is the fraction of references that miss. And it’s one minus the hit rate. So typical for caches to work, the miss rate has to be pretty low. And fortunately, because of locality, these miss rates are low.<br>对于所有这些不同的缓存，块大小为64 B。现在，有许多不同的方式来考虑缓存的性能。我最常用的方法是使用一种叫做缺失率的指标。所以这是错过的参考文献的分数。这是一个减去命中率。缓存工作如此典型，缺失率必须相当低。幸运的是，由于当地的原因，这些误差率很低。</p><p>发言人   43:16<br>Another metric is the hit time. So if we do have a hit in the cache, how long does it actually take to sort of look up, do the lookup to determine that there was a hit, and then return the value? So for L 1 in an Intel system, this is four clock cycles, 10 clock cycles for L 2, and then there’s an additional cost. So you always have to pay the hit time. The hit time is the best you can do, but if you have a miss, then you pay the hit time because you have to do the search and eventually you’re going to have to return the word back to the requester. But then you have this additional cost, which is going to the memory to fetch the data.<br>另一个指标是命中时间。所以，如果我们在缓存中确实有一个命中，实际上需要多长时间来查找，进行查找以确定有一个命中，然后返回值？因此，在英特尔系统中，对于L 1，这是四个时钟周期，对于L 2，则需要10个时钟周期，然后需要额外的费用。所以你总是需要支付命中时间。命中时间是你能做到的最好的，但是如果你错过了，那么你需要支付命中时间，因为你必须进行搜索，最终你将不得不将单词返回给请求者。但是这样你就有了额外的费用，这笔费用将用于内存获取数据。</p><p>发言人   44:06<br>That miss penalty, that’s so called miss penalty is on the order of hundreds of cycles for main memory. But at other levels of the hierarchy, it can be huge. So the miss penalty, if you have a cache in main memory that’s caching blocks that are stored on disk, the missed penalty is enormous. So it’s kind of interesting, if you think about it, that the performance of these systems is very sensitive to the miss rate, much more sensitive than you would think. And in fact, 99% hit rate is twice as good as a 97% hit rate, yes.<br>那个失误惩罚，即所谓的失误惩罚，对于主存储器来说，约数百个周期。但在其他层次结构中，它可能是巨大的。所以未命中的惩罚，如果你在主内存中有一个缓存存储在磁盘上的块，错过的惩罚是巨大的。所以有趣的是，如果你仔细想想，这些系统的性能对误操作率非常敏感，比你想象的敏感得多。事实上，99% 的命中率是97% 命中率的两倍，是的。</p><p>发言人   45:01<br>Incorporated the agency?<br>注册机构？</p><p>发言人   45:09<br>Yeah, so the question is, does the hit time include the time tag to access the tag? Yes, the hit time is the time it takes to search to determine if that item is is in the cash and then return it.<br>是的，所以问题是，点击时间是否包括访问标签的时间标签？是的，命中时间是搜索以确定该项目是否在现金中并返回所需的时间。</p><p>发言人   45:42<br>Yeah, so the. Miss penalty is the time it takes for the cache to fetch the data from memory. So that’s all the latency going across the buses. The time it takes the memory to respond to the request, the time it takes the data to flow back over the buses back to the cache. So the time for a miss is going to be the hit time plus the miss penalty. That clear?<br>是的，所以。错过惩罚是缓存从内存中提取数据所需的时间。这就是总线上的所有延迟。内存响应请求所需的时间，数据通过总线流回缓存所需的时间。因此，未命中的时间将是命中时间加上未命中罚款。清楚吗？</p><p>发言人   46:12<br>So I mean, imagine, suppose there’s a hit time of one cycle and a miss penalty of 100 cycles. Those are reasonable numbers. So the average access time, if you have 97% hits, it’s the hit time plus the percentage of misses times the miss penalty. So that’s four cycles for the average access time. But if we just increase the hit rate by 2%, the average access time drops by 50%, a factor of 2.<br>所以我的意思是，想象一下，假设命中时间为一个周期，未命中罚款为100个周期。这些是合理的数字。所以平均访问时间，如果你有97% 的点击，它是点击时间加上未命中百分比乘以未命中惩罚。这就是平均访问时间的四个周期。但如果我们只是将命中率提高2%，平均访问时间会下降50%，是2倍。</p><p>发言人   46:50<br>All right, so why is this stuff important? Why should you care about it?<br>好的，那么为什么这些东西很重要呢？你为什么要关心它？</p><p>发言人   46:56<br>So caches, as we’ve seen, are these, they’re automatic, they’re all built in hardware, there’s no part of the. Sort of the visible instruction set, letsgo manipulate caches and your some machine coding programs. So it all happens behind the scenes automatically in hardware. But if you know about the existence of caches and you have this general idea of how you can work, how they work, then you can write code that’s cache friendly in the sense that your code will have a higher, higher miss rate than code that isn’t cache friendly.<br>正如我们所看到的，缓存是自动的，它们都是内置在硬件中的，没有任何部分。类似于可见的指令集，letsgo操纵缓存和你的一些机器编码程序。所以这一切都会在硬件上自动在幕后发生。但是，如果您了解缓存的存在，并且您对如何工作有了大致的了解，那么您可以编写缓存友好的代码，感知您的代码将比非缓存友好的代码有更高、更高的误码率。</p><p>发言人   47:40<br>So the idea is to you want to focus on making the common case go fast. Don’t spend your time on code, that sort of code that doesn’t get execute very much. So look at the most commonly called functions and then within those functions, look at the inner loops of those functions, because it’s the inner loops that are executing the most. So you can, as a first approximation, can just, if you have nested loops, you can ignore stuff that’s going on in the outer loops and just focus on the code in the inner loop. Now, what you want to do is try to minimize the misses in the inner loop.<br>所以这个想法是你想专注于让普通案例快速发展。不要把时间花在代码上，那种不会得到很多执行的代码。因此，请查看最常见的函数，然后在这些函数中，查看这些函数的内循环，因为执行最多的是内循环。因此，作为第一次近似，如果您有嵌套循环，您可以忽略外层循环中发生的内容，而只专注于内层循环中的代码。现在，你想做的是尽量减少内循环中的失误。</p><p>发言人   48:19<br>So repeated references to a variable is variables are good, especially if those are local variables. So remember, if you declare a local variable in C, the compiler can put that in a register. If you’re referencing global variables, maybe not, the compiler doesn’t know what’s going on, so it can’t put, it can’t put the reference to that variable in AC in a register. So repeated references to local variables stored on the stack are good because those will get turned into register accesses. You’ll never go to memory.<br>所以重复引用一个变量是好的，特别是如果那些是局部变量。所以请记住，如果您在C中声明一个局部变量，编译器可以将其放入寄存器中。如果你引用全局变量，也许不是，编译器不知道发生了什么，所以它不能把对该变量的引用放在寄存器的交流中。因此，对存储在堆栈上的局部变量的重复引用是很好的，因为这些变量将被转换为寄存器访问。你永远不会想起。</p><p>发言人   48:58<br>Also, stride 1 accesses to arrays are good, and they’re good because of the existence of these blocks. So the only way you’d know that stride 1 references are good is if you knew that caches have these 64 B blocks.<br>此外，对数组的步幅1访问是好的，而且它们之所以是好的，是因为这些块的存在。所以你知道步幅1引用是否有效的唯一方法是，如果你知道缓存有这些64 B的块。</p><p>发言人   49:15<br>So, and stride 1 reference will have half the miss rate as a stride 2 reference. Because if you’re doing stride 1 references, the first reference to a word in a block will miss, but then subsequent references will hit. And you’ll hit, if you’re doing a stride, one reference, you’re going to hit every, every word in that block. If you’re doing stri 2 references, you’re only going to hit every other word. You’ll get sort of half. So you’ll miss at twice the rate. So? So basically, the point I want to make to you is that our understanding of caches allow us to sort of quantify this qualitative notion of locality that we developed the last time.<br>因此，步幅1的参考将具有一半的未成功率作为步幅2的参考。因为如果你正在进行步幅1的引用，对块中某个单词的第一个引用将会丢失，但随后的引用将会命中。如果你步幅大，你会碰到一个参考，你会碰到那个块中的每一个单词。如果你正在进行2个单词的引用，你只会命中每一个单词。你会得到一半。所以你会以两倍的价格错过。所以呢？所以基本上，我想要告诉你的是，我们对缓存的理解使我们能够量化我们上次开发的这种定性的局部性概念。</p><p>发言人   50:09<br>The last time we looked at, we said, if it’s doing stride 1 references, that’s good. If we’re accessing the same variable over and over, that’s good. But if we understand caches, now we can quantify it in terms of miss rate.<br>上次我们看的时候，我们说，如果它是步幅1参考，那就很好。如果我们一遍又一遍地访问同一个变量，那很好。但如果我们了解缓存，现在我们可以用缺失率来量化它。</p><p>发言人   50:29<br>All right, so let’s finish up the rest of the class. We’re going to look at the performance impact of caches on your code and why you need to know about these things and the impact that they can have. So there’s a very interesting function that’s actually plotted on the cover of your textbook. Now we call the memory mountain. I learned about this from a graduate student here at Carnegie Mellon back in the 90s who developed this notion named Tom Stricker.<br>好的，那我们把剩下的课结束吧。我们将了解缓存对代码性能的影响，以及为什么需要了解这些事情以及它们可能产生的影响。所以有一个非常有趣的功能实际上绘制在你的教科书的封面上。现在我们称之为记忆山。我是从卡耐基梅隆大学的一位研究生那里了解到这个问题的，他在90年代提出了这个名为Tom Stricker的概念。</p><p>发言人   51:03<br>And what it is, it’s a the memory mountain plots, a measure called read throughput or read bandwidth, which is the number of bytes read from memory. So if you have a loop and you’re scanning over a vector, you have a vector of, say, double words, and you’re reading those elements from a vector one after the other, the read throughput is the number of megabytes per second that you can, that you can perform that task at. And the memory mountain plots read throughput as a function of the temporal and spatial locality in that loop. So in a sense, it’s looking at a wide range of locality options or characteristics in a program, and it’s plotting the performance of that memory system on that across that range is a 200 dimen a function. So in some ways, the memory mountain is kind of a fingerprint, right?<br>它是一个内存山图，一种称为读取吞吐量或读取带宽的度量，即从内存读取的字节数。因此，如果您有一个循环并且正在扫描一个向量，那么您有一个双单词向量，并且您从一个向量一个接一个地读取这些元素，读取吞吐量是您每秒可以读取的兆字节数，你可以执行这项任务。而记忆山地图读取吞吐量作为循环中时间和空间局部性的函数。因此，在一个感知中，它查看程序中广泛的局部性选项或特征，并绘制该内存系统在该范围内的性能是一个200 dimen的函数。所以在某些方面，记忆山有点像一种指纹，对吧？</p><p>发言人   52:03<br>Every system has its own unique memory mountain that we can measure by writing a simple program. The idea here is that to construct the memory mountain, we write a program called Test.<br>每个系统都有自己独特的内存山，我们可以通过编写简单的程序来测量。这里的想法是，为了构建记忆山，我们编写一个名为Test的程序。</p><p>发言人   52:39<br>Oh shoot?<br>哦，射击？</p><p>发言人   52:55<br>For some reason, it’s not. Okay? All right? So when we build a memory mountain, we’re given a vector that consists of a collection of double words. And then we write a loop that reads those words, that reads some number of words in this case.<br>出于某种原因，它不是。好吗？一切正常吗？因此，当我们构建一个记忆山时，我们会得到一个由双单词集合组成的向量。然后我们编写一个循环来读取这些单词，在这种情况下会读取一些单词。</p><p>发言人   53:46<br>There we go, so it it reads LMS number of elements. So we’ve got each of these double word elements with a stri of stride. So if we have a stride of one. I know that was kind of redundant.<br>我们去那里，所以它读取LMS元素数量。所以我们得到了这些双词元素，每个元素都有一个stride的stri。所以，如果我们有一个步伐。我知道那有点多余。</p><p>发言人   54:07<br>Owl, we have a stride of one. Then we’ll have our loops. We’ll sort of loop through and read these elements until we’ve read elements, number of those elements, and then we’ll do it again. And then that warms up the cache. Then we do it again and do exactly the same thing. So if we’re doing this with a stride of 2, then we would be reading, we would read this word zero or LM 2, LM 4, and so on. Then so all we’re doing, we’re just for a wide range of strides in a wide range of of sizes.<br>猫头鹰，我们步幅只有一大步。然后我们就有了我们的循环。我们会依次循环并读取这些元素，直到我们读取完元素和这些元素的数量，然后我们会再次执行此操作。然后就会温暖储藏处。然后我们再做一次，做同样的事情。如果我们以2的步幅进行此操作，那么我们将阅读，我们将阅读这个单词0或LM 2，LM 4，依此类推。那么我们所做的一切，只是为了在各种尺寸上取得广泛的进步。</p><p>发言人   54:57<br>We’re scanning over this vector and just recording how long it takes to do that read and then convert. We convert that into megabytes per second.<br>我们正在扫描这个向量，只是记录读取和转换所需的时间。我们将其转换为每秒兆字节。</p><p>发言人   55:08<br>And in order to, I just wanted to show you this we need, we’re not going to go into detail about this, but this is actually how I generated the cover on the book in order use to exploit the parallelism inside the Intel processor. Like you learned about last week, there’s a lot of parallel functional units in order to exploit those I. Did 4 by 4 loop unrolling. So I’m actually doing sort of four scans in parallel. But the general idea is just what I’ve showed you here. And this 4 by 4 loop unrolling is just an optimization, but I wanted to show it to you because it actually, it’s the exact same principles you learned about last week.<br>为了向您展示我们需要的这个，我们不打算详细说明，但这实际上是我生成书封面的方式，以便利用英特尔处理器内部的并行性。就像你上周学到的，有很多并行的功能单元来利用这些I。做了4乘4的循环展开。所以我实际上正在并行进行四次扫描。但总体思路就是我在这里给你展示的。这个4乘4的循环展开只是一个优化，但我想向你展示一下，因为它实际上与你上周学到的原理完全相同。</p><p>发言人   55:57<br>Professor Bryant talked about code optimization. So what we do is we call this test function with these various ranges of LMS and stride, and then we measure the performance and we get this beautiful picture, this beautiful function. To me, it’s beautiful, I don’t know, does it look beautiful to you?<br>Bryant教授谈到了代码优化。所以我们做的是用这些不同的LMS和stride范围来调用这个测试函数，然后我们测量性能，我们得到这个美丽的图片，这个美丽的函数。对我来说，它很漂亮，我不知道，你觉得它漂亮吗？</p><p>发言人   56:25<br>So on our z axis is plotting read throughput in megabytes per second, ranging from 2000 MB per second up to 16000 MB per second.<br>因此，在我们的z轴上绘制读取吞吐量，以每秒兆字节为单位，范围从每秒2000个MB到每秒16000个MB。</p><p>发言人   56:46<br>This axis is measuring is stride. So going from stride 1 up to stride 12. And this axis is so as we increase stride, we’re decreasing the spatial locality, right? And this axis is the size axis. So we’re going from, I think, 16K up to 128 MB. So this is the number of elements we’re going to read each pass through. So as we increase the size, we’re sort of decreasing the impact of temporal locality. As we increase the size, there’s fewer and fewer caches in our hierarchy can hold all that data. And so we’ve got spatial locality decreasing in this direction and temporal locality decreasing in this direction.<br>这个轴测量的是步幅。从步幅1到步幅12。这个轴是这样的，当我们增加步幅时，我们就减少了空间局部性，对吗？这个轴就是尺寸轴。所以我们从16k到128 MB。这是我们每次通过读取的元素数量。因此，随着大小的增加，我们在某种程度上减少了时间局部性的影响。随着大小的增加，我们层次结构中可保存所有数据的缓存越来越少。因此，我们的空间局部性在这个方向上减小，时间局部性在这个方向上减小。</p><p>发言人   57:58<br>So as a programmer, what you want to do, you want to be up here, Good spatial locality, good temporal locality, because you can get like 14 GB per second measured read-through put. You don’t want to be down here, which is only about 100 MB per second, where you’re reading out of memory. So the difference between reading all of your data from memory and or reading it from some part of the caches, it is huge. It’s enormous. So because you’re 213 students, you’ll be up here and all the students that didn’t take 213, they’ll be down here and actually had. I’ve actually had people, several people write back to tell me about their experiences, internships, and jobs after they left CMU where they were given some code that was down here and they recognized the locality issues and they got it better up here, at least better.<br>所以作为一名程序员，你想要做的事情，你想要在这里，良好的空间局部性，良好的时间局部性，因为你可以获得每秒14个GB的读取量。你不希望待在这里，这里每秒只有大约100个MB，你正在从内存中读取。因此，从内存中读取所有数据和从缓存的某些部分读取数据之间的差异是巨大的。这是巨大的。因为你们是213名学生，所以你们会在这里，而所有没有参加213的学生，他们会在这里并且实际上已经参加了。我实际上遇到过一些人，有几个人在离开CMU后写信告诉我他们的经历、实习和工作，在那里他们得到了一些在这里的代码，他们认识到当地的问题，他们在这里做得更好，至少更好。</p><p>发言人   59:07<br>This picture, this so itca AED memory mountain has all kinds of interesting features. First of all, there’s these, what I call ridges of temporal locality, where these ridges, you see these ridge lines, if you think of this as like a mountain, you see this ridge line and you see this ridgeline, and here’s another ridgeline, and then here’s another one. These correspond to different levels in the hierarchy.<br>这张照片，这个itca AED记忆山有各种有趣的特征。首先，有这些我称之为时间局部性的山脊，在这些山脊中，你看到这些山脊线，如果你把它想象成一座山，你会看到这条山脊线，你会看到这条山脊线，这里是另一条山脊线，然后这里是另一条山脊线。这些对应于层次结构中的不同级别。</p><p>发言人   59:29<br>So this top ridgeline is where you’re reading directly out of L 1, and it should be perfectly flat, and it’s so fast that we’re getting like measurement jitter, performance jitter. And this little drop off here is a measurement artifact. It shouldn’t be there. It should be flat and go all the way to the wall back here. And then here, this ridge line is where we’re accessing L 2.<br>这个顶部山脊线是你直接从L 1中读取的地方，它应该是完全平坦的，而且它太快了，以至于我们得到了测量抖动，性能抖动。这里的这个小下降是测量伪影。它不应该在那里。它应该是平坦的，一直走到这里后面的墙壁。然后在这里，这条脊线是我们访问L 2的地方。</p><p>发言人   01:00:02<br>This is what we’re accessing L 3. And here’s what we’re accessing mostly from memory. So you have these ridges of temporal locality, and then you have these slopes of decreasing spatial locality. So you see the slope here. So as we’re moving from the top of the slope down to the bottom, we’re decreasing our spatial locality. So we’re getting less benefit for these blocks that we’re bringing in. So you can see we’re getting less benefit out of the cost that we went through of importing, of fetching these blocks.<br>这就是我们正在访问的L 3。这就是我们主要从内存访问的内容。所以你有这些时间局部性的脊，然后你有这些空间局部性递减的斜率。所以你可以看到这里的坡度。所以当我们从斜坡的顶部向下移动到底部时，我们正在减少我们的空间局部性。所以我们带来的这些区块的收益越来越少。所以你可以看到，我们从导入和获取这些块的成本中获得的收益越来越少。</p><p>发言人   01:00:41<br>And once the stride hits the block size, now every reference is hitting a different block, and then it flattens out. Then you’re getting no benefit from spatial locality. And similar here is this slope is where we’re reading from L 3, and it flattens out. They always flatten out at the at the block size, which is stride.<br>一旦步幅达到了块的大小，现在每个参考都会碰到不同的块，然后它就会变平。那么你就得不到空间局部性的好处。类似于这里的斜率是我们从L 3读取的地方，它变平了。它们总是以块大小 (即步幅) 扁平化。</p><p>发言人   01:01:12<br>These are double words. So it’s stride of 8, it is 64 B. So once you exceed a stride of 8, then you’re no longer, you’re missing every time in a different block. And there’s this interesting thing.<br>这些是双重词汇。所以步幅为8，是64 B。所以一旦你超过了8步，你就不再是，你每次都在不同的街区错过了。还有个有趣的事情。</p><p>发言人   01:01:28<br>This one puzzled me for a while. You might be wondering like, how come like over here, as we increase the size, we can sort of, we’re sort of getting the sort of, as we increase the size, we’re doing most of our references out of caches that are lower in the cache hierarchy.<br>这让我困惑了一段时间。你可能会想，为什么这里会出现这样的情况，当我们增加大小时，我们可以得到一种，当我们增加大小时，我们正在从缓存层次结构中较低的缓存中进行大部分引用。</p><p>发言人   01:01:51<br>But except when we’re doing stride 1 references, you can see all the way up to right at the end, right before it exceeds the size of L 3, it’s flat. And it’s running at the L 2 rate. So here’s the L 1 rate, and then it drops off. And then it’s running at a constant L 2 rate until the data no longer fits in L 3. And so I think what’s going on here is that the hardware, the L 2 cache hardware is recognizing, or maybe it’s an L 1, but some logic in the cache system is recognizing the stride one reference pattern because it sees all the addresses. It’s recognizing that stride 1 pattern, and then it’s aggressively prefetching from L 3 into L 2 so that those, so it’s fetching ahead of time, it’s anticipating, it’s saying, look I’ve gotten five stride one references in a row.<br>但除非我们在进行步幅1的参考，否则你可以在最后看到从右边一直到右边，在它超过L 3的大小之前，它是平坦的。它以L 2的速率运行。这是L 1速率，然后它会下降。然后它以恒定的L 2速率运行，直到数据不再适合L 3。因此，我认为这里发生的事情是硬件，L 2缓存硬件正在识别，或者可能是L 1，但缓存系统中的一些逻辑正在识别步幅一个参考模式，因为它可以看到所有地址。它识别出了步幅1的模式，然后积极地从L 3预取到L 2，以便提前获取，它在预测，它在说，看我连续收到了五个步幅1的引用。</p><p>发言人   01:02:59<br>I’m going to go grab a whole bunch of blocks and load them all up because by the principle of spatial locality, those blocks, those blocks are going to be referenced in the near future. So this was really neat, and this only happened within the last couple years. So the Intel engineers are always hard at work and maybe by the time, the time we do the next, the next edition of the Memory Mountain, those systems will recognize stride 2 and other stride patterns too. But from this data, it appears that it’s only recognizing stride 1.<br>我打算抓取一堆区块并将它们全部加载，因为根据空间局部性的原则，这些区块将在不久的将来被引用。所以这真的很整洁，而且这只是在最近几年才发生的。因此，英特尔工程师们总是在努力工作，也许当我们做下一个，下一版的记忆山时，这些系统也将识别步幅2和其他步幅模式。但从这些数据来看，它似乎只识别了步幅1。</p><p>发言人   01:03:40<br>So, you? We can improve the spatial and temporal locality of our programs in several different ways.<br>所以，你呢？我们可以通过几种不同的方式改善我们程序的空间和时间局部性。</p><p>发言人   01:03:51<br>One way to improve the spatial locality is to rearrange loops. And I’ll use a matrix multiplication as an example. So here’s sort of a simple matrix multiplication. Code where we’re multiplier A times b and adding it, we’re taking what’s in of the IJF element of c, and then to that, we’re adding the sum, the inner product of rho I of A and the row j, a, column j of b, and then so we’re going through, and for each ij in this matrix C, we’re computing an inner product and then creating that sum. So we can actually, it turns out there’s a lot of different ways to do matrix multiply, and we can permute these loops in any of six different possible permutations. So this is a permutation where it’s I followed by j followed by k, but five other possibilities are feasible, and so we can actually analyze those different permutations and predict which one will have the best performance.<br>改善空间局部性的一种方法是重新排列循环。我会用一个矩阵乘法作为例子。所以这是一个简单的矩阵乘法。代码中，我们将乘数A乘以b并将其相加，我们将c的IJF元素中的内容相加，然后再将其相加，即A的rho I的内积与b的j行、a的j列的总和，然后，我们将经历，对于这个矩阵C中的每个ij，我们正在计算一个内积，然后创建总和。所以我们实际上可以，事实证明有很多不同的方法来进行矩阵乘法，我们可以将这些循环排列在六种不同的可能排列中。所以这是一个排列，后面是I，后面是j，后面是k，但还有其他五种可能性是可行的，因此我们可以实际分析这些不同的排列并预测哪一种性能最好。</p><p>发言人   01:05:14<br>So what we’ll do is we’ll look at the inner loop. And we’ll look at the access pattern of the inner loops and the access pattern on arrays CA and b? Okay, so let’s look at the ijk implementation that I just showed you. So as always, we focus on the inner loop. And if you notice, this inner loop is doing a row wise access of column A and a column wise A I’m sorry, a row wise A of array A and column wise A of a row B, so row y of a column y of b, we don’t really care about c because it’s not in the inner loop. So just ignore that.<br>所以我们要做的是看看内部循环。我们将查看内部循环的访问模式以及数组CA和b上的访问模式？好的，那么让我们来看看我刚刚向您展示的ijk实现。因此，一如既往，我们专注于内环。如果您注意到，这个内部循环正在按行访问列a和列A，对不起，按行访问数组a和列访问行B，因此按行访问列y，按行访问列b，我们并不真正关心c，因为它不在内部循环中。所以忽略这一点。</p><p>发言人   01:06:05<br>So given our assumption that we can hold, in this case, we’re assuming that we can hold 4, 4 of these integer elements in one block, so the row wise A, which has good spatial locality, will miss 1 every four accesses. The very first reference will miss, and then the next three will hit, and then the next reference after that will hit a new block. So one out of four references to A will miss access pattern for B is column wise, every reference to B will miss, so the average number of misses per loop iteration is 1.25.<br>因此，鉴于我们的假设，在这种情况下，我们假设我们可以在一个块中容纳4，4个这些整数元素，因此具有良好空间局部性的行，每四次访问将丢失1个。第一个引用将丢失，然后接下来的三个引用将命中，之后的下一个引用将命中一个新的块。因此，对A的四个引用中有一个会错过B的访问模式，每个引用面向企业都会错过，因此每个循环迭代的平均错过次数是1.25。</p><p>发言人   01:06:51<br>The jik version is exactly the same pattern. Kj is a little different here. We’re doing rho y a of b and a rho y axis of c, so that’s good, right? So now we’ve got stride. 1 axis is on both B and C, and the reference to A is outside of the loop, so we don’t care about it. So both B and C will miss one quarter of the time. So the total average number of misses per loop iteration will be 0.5.<br>jik版本是完全相同的模式。Kj在这里有点不同。我们正在进行b的rho y a和c的rho y轴，所以这很好，对吧？所以现在我们有了步幅。1个轴同时在B和C上，并且对A的引用在循环之外，因此我们不关心它。所以B和C都会错过四分之一的时间。因此，每次循环迭代的平均失误总数将为0.5。</p><p>发言人   01:07:29<br>That’s pretty good, and I Kj has the same similar behavior. Now jki is sort of the exact opposite jki does column wise access of A and column wise access of C, so we know that’s a stinker, right? And qualitatively, we know it’s bad. And we can compute that it’ll miss 1 time per loop iteration. So that’ll be total of 2 misses per iteration, kji has the same bad pattern.<br>这相当不错，而且I Kj也有类似的行为。现在，jki与按列访问A和按列访问C的jki完全相反，所以我们知道这很臭，对吧？从质量上来说，我们知道它是不好的。我们可以计算出每个循环迭代将错过1次。因此，每次迭代总共有2次失误，kji具有相同的不良模式。</p><p>发言人   01:08:03<br>So if we look at all these permutations, you can see that ijk and JK myth 1.25 have 1.25 misses, kij has 0.5 misses, and jki has two misses. So clearly, it looks like kij and its brethren are the best option.<br>因此，如果我们查看所有这些排列，你可以看到ijk和JK神话1.25有1.25的失误，kij有0.5的失误，而jki有两个失误。很明显，kij和它的弟兄们看起来是最好的选择。</p><p>发言人   01:08:25<br>The only difference is that kij has this additional store. So there might be a question of, is that going to slow things down? Well, it turns out in systems in storage systems, rights are much easier to deal with than reads, can you think about why that might be true? So writes, you have a lot more flexibility than you do with reads.<br>唯一的区别是kij有这个额外的商店。所以可能会有一个问题，这是否会减缓速度？嗯，事实证明在存储系统中，权限比读取更容易处理，你能想到为什么这是真的吗？所以写，你比读有更多的灵活性。</p><p>发言人   01:08:57<br>I mean, yes? Yeah, so you have options. You can write back. You can defer writing until the value that you’ve written is actually used. But when you read an item, you’re stuck. You can’t do anything until you get that data. So it turns out that rights don’t really, that this additional store doesn’t really hurt us.<br>我是说，是吗？是的，所以你有选择。你可以回信。你可以推迟写入，直到你所写的值被实际使用。但是当你读一个项目时，你就被卡住了。在获得这些数据之前，你什么也做不了。所以事实证明，权利并没有，这个额外的商店并没有真正伤害我们。</p><p>发言人   01:09:22<br>And so when we measure these on a modern system, you can see that the Kate kij, which has the fewest number of misses, has you see we’re getting like 1 miss. What we’re plotting here is cycles per interloop iteration. So each iteration is taking about one cycle, which is really good. This ijk pattern, which was kind of the intermediate 1, 2 misses, that’s sort of in between, and the jki, which has two misses per iteration, is the worst. So what’s interesting is we could actually, just by doing a little bit of analysis, simple analysis, we could actually predict what this graph would look like in the in last 10 minutes of the class, we’re going to look at how to improve temporal locality.<br>因此，当我们在现代系统上测量这些时，你可以看到，Kate kij的失误次数最少，你可以看到我们得到了1次失误。我们在这里绘制的是每个interloop迭代的周期。所以每次迭代大约需要一个周期，这真的很好。这个ijk模式，有点像中间的1、2次失误，介于两者之间，而jki，每次迭代有两次失误，是最糟糕的。所以有趣的是，我们实际上可以通过做一点分析，简单的分析，预测这张图在课程的最后10分钟内会是什么样子，我们将看看如何改善时间局部性。</p><p>发言人   01:10:16<br>So what we did when we rearranged our loops in the matrix multiplication, what we were doing was in improving our spatial locality. But we didn’t really do anything to improve the temporal locality. To improve temporal locality, you have to use a technique called blocking. And this is important to understand because you’re going to need it in your cache lab for one thing. But it’s also a very general technique. Anytime you need, anytime you’re having issues with temporal locality.<br>所以当我们在矩阵乘法中重新排列循环时，我们所做的是改善我们的空间局部性。但我们并没有真正做任何事情来改善时间局部性。为了改善时间局部性，你必须使用一种叫做阻塞的技术。这一点很重要，因为你需要在你的缓存实验室中使用它。但这也是一种非常通用的技术。任何时候你需要，任何时候你遇到时间局部性问题。</p><p>发言人   01:10:46<br>Okay, so. We’re not going to go into too much detail of this code. But what I did, I rewrote the matrix multiply so that it operates, you know, a two dimensions onal matrix. You can really just think of it as a contiguous array of bytes. So I just rewrote this code to operate on a contiguous array, one dimensional array. And then I’m doing the indexing explicitly here. So here, c I times n plus j, this is an n by n matrix. What I’m doing is I’m accessing I’m computing where the I throw starts, and then I’m going to the j column of that row and then accessing that element.<br>好的，所以。我们不会对这段代码进行太多的详细介绍。但是我所做的是，我重写了矩阵乘法，使其运行，你知道，一个二维矩阵。你可以把它想象成一个连续的字节数组。所以我只是重写了这段代码来操作一个连续的一维数组。然后我在这里明确地进行索引。所以这里，c I乘以n加j，这是一个n乘n的矩阵。我正在做的是访问我正在计算I抛出开始的位置，然后我要去那一行的j列，然后访问那个元素。</p><p>发言人   01:11:32<br>But it’s the same idea as before. So let’s look at the miss rate for this. Just our, this is our original unblocked matrix multiply. So what we’re doing is we’re computing C 0, 0, and we’re doing that by taking an inner product of row 0 and column 0, whos So if you look at, we’re assuming that the.<br>但这和以前的想法一样。让我们来看看这个的缺失率。只是我们的，这是我们最初的畅通矩阵乘法。所以我们正在计算C 0，0，并且我们通过取行0和列0的内积来进行计算，所以如果你看，我们假设。</p><p>发言人   01:12:01<br>The cache blocks hold 8 doubles and that the matrix elements are doubles. Then we’re going to miss one eighth of the time. So in the first iteration. We’re going to miss the first iteration does n of these things. And since n over 8 at the time, we’re missing one block for every 8 references. Each for the first iteration, we’re going to miss n over 8. And since there’s n for each element for each block I’m sorry. Oh, so this is the number of blocks and the number of misses. And then we have n elements so that the total number of misses is 9 over n divided by 8 misses for the first iteration.<br>缓存块容纳8个双精度，而矩阵元素是双精度的。那么我们将错过八分之一的时间。所以在第一次迭代中。我们将错过第一次迭代完成其中的n件事情。由于当时n超过8，我们每8个引用就会缺失一个块。每次第一次迭代，我们将错过8个以上的n个。由于每个块的每个元素都有n，我很抱歉。哦，这是块的数量和未命中的数量。然后我们有n个元素，因此在第一次迭代中，未命中的总数是9除以8次未命中。</p><p>发言人   01:12:59<br>The second iteration will have the same number of misses Because of our assumptions about the size of this array. So these rows are way too big to fit in the cache. So we never get any, we don’t get any temporal locality. Okay? So the total number of misses is 9 n over eight times the number of elements that we’re updating, which is n squared. So our total misses is 9 over eight times n cubed.<br>第二次迭代将有相同的失误数，因为我们对这个数组的大小进行了假设。所以这些行太大，无法放入缓存中。所以我们从来没有得到任何，我们没有得到任何时间局部性。好吗？因此，未命中的总数是9 n，超过我们正在更新的元素数量的8倍，这是n的平方。所以我们的总失误是9乘以8乘以n立方。</p><p>发言人   01:13:30<br>Now let’s rewrite the code to use blocking. And so you can look at this code later, but it’s much simpler just to look at it pictorially. So what we’re doing, instead of updating one element at a time, we’re updating a sub-block AB by b sub-block And we’re doing that just totally analogously to when our original case where b equal one, this, b by b sub block in c, is computed by taking an inner product of the sub blocks of a set of sub-blocks in A with a set of sub blocks in b, and for each one of those, we’re doing a little mini matrix multiplication. So we’re, we’re taking this sub block times this sub block plus the second sub block of a times the second sub-block of b plus the third sub block of a times the third sub block of b, and so on. So we’re doing the same inner product operation, but instead of on scalars, we’re doing it with these little tiny matrices.<br>现在让我们重写代码以使用阻塞。所以你可以稍后再查看这段代码，但只需要以图形方式查看就简单多了。所以我们正在做的不是一次更新一个元素，而是更新一个子块AB乘b的子块，我们这样做完全类似于我们最初的情况，其中b等于c中的一个子块，通过将a中的一组子块的子块与b中的一组子块的内积进行计算，对于其中的每一个，我们进行了一个小的迷你矩阵乘法。所以，我们将这个子块乘以这个子块加上第二个a的子块，乘以b的第二个子块，再加上a的第三个子块，再乘以b的第三个子块，依此类推。所以我们正在做相同的内积操作，但不是针对标量，而是使用这些小小的矩阵。</p><p>发言人   01:14:50<br>Alright, so let’s look at what happens to the miss rate when we do this. So there’s n over b blocks. In any row or column. Since there’s b squared items in each block, b times b, there’s b squared over 8 misses for each block, okay? So, and then since there’s n over b blocks in each matrix, and there’s two matrices, there’s 2 n over b times b squared over 8 misses for this first iteration. So that works out to be NB divided by 4. And the second iteration has the same miss rate. So the total number of misses is the number of misses for each iteration times.<br>好的，那么让我们来看看当我们这样做时，缺失率会发生什么变化。所以在b个区块上有n个。在任何行或列中。由于每个块中有b平方的项目，b乘以b，因此每个块的b平方超过8次失误，好吗？所以，由于每个矩阵中有n个超过b个块，并且有两个矩阵，因此第一次迭代有2个n乘以b的平方，超过8次失误。因此，这可以被计算为NB除以4。第二次迭代具有相同的缺失率。因此，总失误次数是每次迭代的失误次数。</p><p>发言人   01:16:03<br>The number of elements in C that we’re updating, which is n over b squared. So that all works out too. It still, it’s n cubed divided by 4 b.<br>我们正在更新的C中的元素数量，即n的平方。这样一切也能奏效。它仍然是n的立方除以4 b。</p><p>发言人   01:16:17<br>So in our first case with no blocking, although the number of misses is asymptotically the same, but there’s pretty this big difference in the constant factor. So for no blocking, it’s nine over eight. For blocking, it’s one over four b, where now we can just sort of drive that down by increasing the block size. So this gives us some control. But still, we can’t make the blocks too big because we need to fit three blocks in cash at any one point in time. So the reason this is a dramatic difference. This is that by doing the blocking, we’re sort of exploiting.<br>所以在我们的第一种情况下，没有阻塞，虽然未命中的次数渐进相同，但在常数因子上有相当大的差异。所以为了没有阻碍，它是九比八。对于阻塞，它是一到四b，现在我们可以通过增加块大小来降低它。这给了我们一些控制权。但是，我们仍然不能把积木变得太大，因为我们需要在任何一个时间点现金三个积木。所以这是一个戏剧性的差异的原因。这就是通过阻塞，我们在某种程度上进行利用。</p><p>发言人   01:17:05<br>Once we load a block into memory, we’re sort of reusing its items over and over again. So we’re exploiting more temporal locality. And matrix multiplication has this implicit locality. The computation is order n cubed, but the size of the data is n squared, So we must be reusing some data items.<br>一旦我们将一个块加载到内存中，我们就会一遍又一遍地重用它的项目。所以我们正在利用更多的时间局部性。而矩阵乘法具有这种隐含的局部性。计算的顺序是n次立方，但数据的大小是n的平方，因此我们必须重用一些数据项。</p><p>发言人   01:17:29<br>The problem with our scalar approach is that we, when we were reusing them, they weren’t in the cache. All right, so the point that I wanted to make with you is that cache memories, although they’re sort of built in automatic hardware storage devices, and you can’t really control them if you know about them, you can take advantage of your knowledge and exploit them and make your code run faster. And the way you do this is, like I said, focus on inner loops. Do is try to do accesses that are stride 1 and to maximize spatial locality and try to maximize temporal locality by reusing local variables, which can then be put into registers.<br>我们的标量方法的问题在于，当我们重用它们时，它们不在缓存中。好的，我想和你说的一点是缓存内存，尽管它们有点内置于自动硬件存储设备中，如果你了解它们，你就无法真正控制它们，但你可以利用你的知识和利用它们，让你的代码运行得更快。你这样做的方法是，就像我说的，专注于内部循环。做的是尝试进行步幅为1的访问并最大化空间局部性，并尝试通过重用局部变量来最大化时间局部性，然后可以将其放入寄存器中。</p><p>发言人   01:18:26<br>Okay, so that’s it for today. Good luck with your attack lab if you haven’t finished it, and don’t forget to get started on Cash lab this weekend.<br>好的，今天就到这里。祝你的攻击实验室好运，如果你还没有完成它，不要忘记本周末开始现金实验室。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深入理解计算机系统 011-The Memory Hierarchy</title>
    <link href="/2025/10/12/15213-011/"/>
    <url>/2025/10/12/15213-011/</url>
    
    <content type="html"><![CDATA[<p>2025年10月02日 08:52<br>发言人   00:01<br>Good afternoon, everybody. Welcome, good to see you. Hope you all have started your attack labs. Everybody started. Be a good time to start, I think. Anyway, I hope you’re enjoying it. That’s a new one this semester. That’s I think, really, really interesting and modern and current.<br>大家下午好。欢迎，很高兴见到你。希望你们都已经开始了你们的攻击实验室。每个人都开始了。我想这可能是一个开始的好时机。无论如何，我希望你喜欢它。这是这学期的新课时。我认为那是非常有趣、现代和现代的。</p><p>发言人   00:26<br>Okay, today we’re going to, today we’re going to talk about something called the memory hierarchy. Now, so far in the class, we’ve thought of memory when we’re looking at our assembly language programs, we’ve thought of memory as a an array of bytes, just a big array of bytes that we can access with an index called an address. But in actuality, the memory system is a very complex hierarchy of devices that provides this abstraction of this large linear array. And so today, we’re going to look at how memory hierarchies are built, why they’re built the way they are. And what we’ll see is that this sort of beautiful confluence properties of storage devices and the properties of programs come together to create this.<br>好的，今天我们要，今天我们要谈论一种叫做记忆层次结构的东西。到目前为止，在课堂上，当我们查看汇编语言程序时，我们已经想到了内存，我们已经把内存看作是一个字节数组，只是一个我们可以通过称为地址的索引访问的一个大的字节数组。但实际上，存储系统是一个非常复杂的设备层次结构，它提供了这种大型线性阵列的抽象。所以今天，我们将看看内存层次结构是如何建立的，为什么它们是这样建立的。我们将看到的是，存储设备的这种美丽的融合特性和程序的特性结合在一起，创造了这一点。</p><p>发言人   01:24<br>This beautiful design called the memory hierarchy. So we’re going to quickly kind of do a high level tour of storage technologies and trends. We’re not going to go into a whole lot of detail. The point in looking at these the properties of these technologies is that there are some fundamental properties that determine their performance and their speed, determine limits on their performance and speed. And so I want you to have just some high level idea of what those properties are. And then we’ll look at a property of programs called locality of reference. And we’ll see how that locality, the properties of storage devices come together to suggest this design of memory systems as a hierarchy.<br>这个美丽的设计被称为记忆层次结构。因此，我们将快速地对存储技术和趋势进行高层次的介绍。我们不会详细讲解。研究这些技术的属性的重点是，有一些基本属性决定了它们的性能和速度，决定了它们的性能和速度限制。所以我希望你对这些属性有一些高层次的想法。然后我们将研究程序的一个属性，称为引用局部性。我们将看到存储设备的局部性和属性如何结合在一起，建议将存储系统的设计作为层次结构。</p><p>发言人   02:17<br>So we’ll look at memories first. Now, the workhorse memory is called a random access memory, or Ram. It’s traditionally packaged up as a chip, and then you put multiple chips together to form your main memory, and there’s a basic storage unit called a cell where each cell stores 1 b.<br>所以我们先看看记忆。现在，主要内存被称为随机访问存储器，或Ram。它传统上打包为芯片，然后将多个芯片放在一起形成主存储器，有一个称为单元的基本存储单元，每个单元存储1 b。</p><p>发言人   02:38<br>There’s comes in two varieties, There’s SRAM and DRAM, and they’re distinguished by the way that those cells are implemented. An SRAM? Requires it’s more complex than DRAM, It requires like 4 to 6 transistors per bit, whereas DRAM only requires one transistor. So you’ll see that Srams are going to be more expensive, lots more expensive because they’re more complex.<br>有两种类型，分别是SRAM和DRAM，它们的区别在于这些细胞的实现方式。一个SRAM？要求它比DRAM更复杂，每比特需要4到6个晶体管，而DRAM只需要一个晶体管。所以你会发现Srams会更昂贵，因为它们更复杂。</p><p>发言人   03:13<br>Each cell is more complex, but they’re also much faster, like 10 order of magnitude faster than Drams. And they have, there’s some other properties too, like SRAM constantly. A DRAM constantly needs to be refreshed. If you don’t hit it with A with a voltage, it loses a charge DRAM while it needs to be plugged in and have an electric charge, it doesn’t need to be refreshed. SRAM is a lot more reliable than DRAM, so there’s less need for error detection and correction. And so because of this difference, the Srams are costlier, smaller, and faster than Drams.<br>每个细胞都更复杂，但它们也更快，比Drams快10个数量级。他们有，还有一些其他的属性，比如不断地SRAM。DRAM需要不断刷新。如果你没有用电压击中它，它会在需要插入并充电时失去电荷，不需要刷新。SRAM比DRAM可靠得多，因此对错误检测和纠正的需求更少。因此，由于这种差异，Srams比Drams更昂贵，更小，更快。</p><p>发言人   04:01<br>We find Srams being used in these small, fast memories on ship called cache memories, and we’re going to learn all about those on Thursday. And then DRAM is the workhorse used in main memories and the frame buffers associated with graphics.<br>我们发现Srams被用于船上这些小而快速的存储器，称为缓存存储器，我们将在星期四学习所有这些存储器。然后DRAM是在主内存和与图形相关的帧缓冲区中使用的主力。</p><p>发言人   04:22<br>Graphics cards Now DRAM and SRAM are volatile in the sense that if if they’re powered off, they lose all the information. So this is why when you turn your computer off, you lose everything in your memory and you to when you turn it back on, you have to sort of reload everything from your disk. But there’s another kind of memory called the non-volatile memory, which retains its information when it’s powered off. And there’s a whole bunch of these things, so icall the read only memories. So the generic name for these non volatile memories, read only memories of Roms, and there’s a whole bunch of different kinds sort of going back in time, the original read only memories were Roms and they can only be programmed once when the chip was produced. And then over time, gradually over a period of like 20 or 30 years, there were improvements in the way that Roms could be programmed, how they were erased, so they could be re-programmed, What we have today, the modern form of read only memory is called flash memory, which provides the capability of.<br>图形卡现在DRAM和SRAM是不稳定的，感知如果它们被关闭，它们会丢失所有信息。因此，这就是为什么当您关闭计算机时，您会丢失内存中的所有内容，并且当您重新打开计算机时，您必须从磁盘中重新加载所有内容。但是还有另一种存储器，称为非易失性存储器，在断电时保留其信息。有一大堆这样的东西，所以只有只读记忆。因此，这些非挥发性存储器的通用名称是只读存储器的只读存储器，并且有很多不同种类的时光倒流，最初的只读存储器是只读存储器，它们只能在芯片生产时被编程一次。然后随着时间的推移，在大约20到30年的时间里，存储器的编程方式有所改进，它们如何被擦除，因此可以被重新编程，我们今天所拥有的现代形式的只读存储器被称为闪存。这提供了能力。</p><p>发言人   05:38<br>Easing, you can erase just chunks of the flash memory called blocks. And then the downside is that these things wear out after about 100000 erasures. So you can erase and reprogram 100000 times then, and then it’s you’re bricked.<br>轻松，您可以仅擦除称为块的闪存块。缺点是这些东西在大约100000次擦除后会磨损。所以你可以擦除并重新编程100000次，然后你就被砖砌了。</p><p>发言人   05:59<br>Now these non volatile memories show up in so called the firmware, which is software that’s that’s programmed into a Rom and you see those the BIOS of computer. So when you power on your computer, the very first instructions that execute are stored in a Rom. If you’re wondered like where do those things come from? So they’re stored in a Rom and then there’s a boot process where gradually more and more information is and instructions are loaded into memory.<br>现在，这些非易失性存储器出现在所谓的固件中，固件是一种被编程到Rom中的软件，你可以看到这些计算机的BIOS。因此，当您打开计算机的电源时，执行的第一个指令存储在Rom中。如果你想知道这些东西是从哪里来的？所以它们存储在Rom中，然后有一个引导过程，逐渐越来越多的信息和指令被加载到内存中。</p><p>发言人   06:33<br>IO IO devices have little computers in them call controllers. These controllers consist of instructions and data that are stored in Roms, and you see them all over the place in these solid state disks that to the system look like a rotating Dis, but they’re built of flash memories. And these are, you see these in thumb drives, smartphones, tablets, and laptops. And they’re even starting to show up in servers now.<br>IO IO设备中的小型计算机称为控制器。这些控制器由存储在存储器中的指令和数据组成，您可以在这些固态磁盘中看到它们遍布各地，对系统来说看起来像旋转磁盘，但它们是由闪存构建的。你可以在拇指驱动器、智能手机、平板电脑和笔记本电脑中看到这些。它们现在甚至开始出现在服务器中。</p><p>发言人   07:14<br>So the memories are connected to the CPU using wires that are collectively called buses. So data flows across the wires back and forth from the we have the CPU chip, and it consists of register file. These are the general purpose registers, rax, RDI, and so on. And there’s an arithmetic logic unit that reads and writes data from the register files and then manipulates that data in some way by doing some kind of arithmetic operation or some logical operation.<br>因此存储器使用统称为 “总线” 的电线连接到CPU。因此，数据从我们拥有的CPU芯片来回流经电线，并且它由注册文件组成。这些是通用寄存器，rax，RDI等。还有一个算术逻辑单元，它从寄存器文件中读取和写入数据，然后通过进行某种算术运算或逻辑运算以某种方式操作该数据。</p><p>发言人   07:53<br>And if instructions need to access memory, so you’re doing a move, a move instruction that reads or writes to memory, then that’s handled by a bus interface, which is connected to a, what we’ll call a system bus. And then that’s connected to an IO bridge. And this is another collection of chips. Intel calls this what I’m calling the IO bridge. They call the chipset, but it’s a collection of chips separate from the CPU chip, and then the IO bridge is connected to another bus called the memory bus, which connects the main memory, this is kind of an abstraction.<br>如果指令需要访问内存，那么你正在执行移动指令，读取或写入内存，然后由总线接口处理，该接口连接到我们称之为系统总线的总线。然后它连接到一个IO桥。这是另一个芯片集合。英特尔称之为我所称的IO桥。他们称之为芯片组，但它是与CPU芯片分开的芯片集合，然后IO桥连接到另一个称为内存总线的总线，该总线连接主存储器，这是一种抽象。</p><p>发言人   08:40<br>I don’t want you to take this too literally, but it gives you the idea of how information flows in the system. Modern modern systems use proprietary bus designs, and they’re very arcane and increasingly complex, so we’re just going to use a fairly simple abstraction for these buses.<br>我不希望你把这个看得太重，但它让你了解信息如何在系统中流动。现代系统使用专有的总线设计，它们非常神秘且越来越复杂，因此我们只对这些总线使用相当简单的抽象。</p><p>发言人   09:04<br>Now suppose you do a load operation like move C 8 B at address into Rax. So we call that a load because we’re loading from the point of view of the CPU, we’re loading data into the CPU, but we’re loading data from memory into the CPU. So when the CPU executes a move instruction like this, it first places the address of A on the memory bus. And then the main memory senses that address, and it reads the contents, the 8 B at address A, so it retrieves the word 8 B word from address A and places it back on the bus. Those bits travel through the IO bridge to the bus interface. And then the CPU reads the word X from the data word X from the bus, and then copies it into register Rax.<br>现在假设您执行一个加载操作，例如将地址为c8b的地址移动到Rax中。所以我们称之为加载，因为我们是从CPU的角度加载的，我们是将数据加载到CPU中，但我们是将数据从内存加载到CPU中。因此，当CPU执行这样的move指令时，它首先将a的地址放在内存总线上。然后主存储器感知该地址，并读取内容，即地址A的8 B，因此它从地址A中检索单词8 B并将其放回总线上。这些位通过IO桥传输到总线接口。然后，CPU从总线上的数据字X中读取字X，然后将其复制到寄存器Rax中。</p><p>发言人   10:08<br>So now writing is similar again. So here we’re doing a move instruction, move Q from rax into address A and main memory. So the CPU starts as before by placing the address A on the bus, main memory reads that address, and then it waits for the data to arrive on the bus. So the CPU then places the contents of Rax on the bus, and those contents travel across to main memory, which then reads that word from the bus and stores that address A, so the point of all this is that operations that occur reads and writes of registers because the register file is very close to the Alu, These happen on the order of a few cycles.<br>所以现在写作又相似了。在这里，我们正在执行一个移动指令，将Q从rax移动到地址a和主内存。所以CPU像以前一样通过将地址A放在总线上开始，主内存读取该地址，然后等待数据到达总线上。因此，CPU然后将Rax的内容放在总线上，这些内容经过主内存，然后主内存从总线读取该单词并存储该地址，所以所有这些的重点是寄存器的读写操作，因为寄存器文件非常接近Alu，这些操作发生在几个周期的顺序上。</p><p>发言人   11:04<br>The register is very close to the Alu, so those operations happen very quickly, whereas memories actually, this is a set of chips that are very far away, relatively speaking from the CPU, and there’s a lot going on when if you have to read or write memory you have to do multiple operations on the bus. Data has to travel, propagate across that bus, all the stuff takes time. So memory operations, reads and writes are typically maybe 50 nanoseconds, 100 nanoseconds, whereas operations that occur between registers are sub nanosecond. So you’re talking about one to two orders of magnitude difference if you have to go off chip to retrieve something from memory. So that’s the first sort of big takeaway item about memory systems.<br>寄存器与Alu非常接近，因此这些操作发生得非常快，而内存实际上是一组非常远的芯片，相对于CPU来说，如果你需要读或写内存，就必须在总线上进行多个操作，这有很多事情需要处理。数据必须通过公共汽车传播，所有这些都需要时间。所以内存操作，读取和写入通常是50纳秒，100纳秒，而在寄存器之间发生的操作是亚纳秒。所以你说的是一到两个数量级的差异，如果你必须离开芯片从内存中检索某些东西。所以这是关于记忆系统的第一个重要要点。</p><p>发言人   12:05<br>Now, another popular storage technology is rotating discs. And I don’t know if you’ve ever torn one apart, they’re kind of interesting. There’s a series of platters. Each platter is coated with a magnetic material, and then bits, ones, and zeros are encoded in that, in that magnetic material. And then there’s this arm that can, it’s hinged right here, and then it floats over the platter, so it floats on a thin layer of air over the platter, read, write head at the very end that can sense the changes in the magnetic field that encode the bits. So these platters are spinning around like counterclockwise like this, and this arm can go back and forth. So there’s a lot of mechanical gear so that this is all mechanical, So the mechanical nature of a rotating disc means it’s going to be slower than Drams and Srams, and there’s also electronics, like it’s like a little computer in firmware that actually controls the operation of this drive, controls how this arm goes back and forth, and controls how the data is read off of the read write head.<br>现在，另一种流行的存储技术是旋转光盘。我不知道你是否曾经撕开过一个，它们有点有趣。有一系列的拼盘。每个盘片都涂有磁性材料，然后将位、一和零编码在磁性材料中。然后是这个手臂，它在这里铰接，然后它漂浮在盘片上，所以它漂浮在盘片上的一层薄薄的空气上，在最后读取，写磁头可以感知编码比特的磁场的变化。所以这些盘片像这样逆时针旋转，这个手臂可以来回旋转。所以有很多机械齿轮，所以这都是机械的，所以旋转盘的机械性质意味着它会比Drams和Srams慢，还有电子设备，就像固件中的一个小电脑，实际上控制着这个驱动器的操作。控制该臂来回传送的方式，并控制从读写头读取数据的方式。</p><p>发言人   13:26<br>So just in a little more detail, we can think of these discs consists of platters, each platter has two surfaces, a top and a bottom. And then each surface consists of these concentric rings called tracks, and then each track it consists of. Sectors which contain the data. So typically 512. Bits I’m sorry by it. And then these tracks are separated by gaps. These gaps like right here, that don’t contain data. Now platters are aligned on top of each other on this spindle. And so tracks that are aligned on the different surfaces, such as this track here, the collection of those tracks form what we call a cylinder because it has a cylindrical shape.<br>所以稍微详细一点，我们可以认为这些光盘是由盘片组成的，每个盘片有两个表面，一个顶部和一个底部。然后每个表面都由这些称为轨道的同心环组成，然后每个轨道都由它组成。包含数据的部门。所以通常是512。我很抱歉。然后这些轨道被间隙分开。这些差距就像这里，不包含数据。现在，在此主轴上，盘片彼此对齐。所以在不同表面上对齐的轨迹，例如这里的这个轨迹，这些轨迹的集合形成了我们所谓的圆柱体，因为它具有圆柱体的形状。</p><p>发言人   14:34<br>Now, the capacity of disks is the number of bits that can be stored. Vendors of all disk vendors use, they quote the capacity in gigabytes. But where a gigabyte is 10 to the ninth bytes instead of two to the 20th like you would expect. So I’m not sure why they do this, but it allows by quoting their capacity in gigabytes in 10 to the ninth bytes. It’s a bigger number, so it looks better. It looks like there’s more information. It’s a little, I don’t really know why they do it, but I think that’s why it is. And so it’s one of those little bit annoying things that we just have to just know about and get used to.<br>现在，磁盘的容量就是可以存储的位数。所有磁盘供应商都使用的容量 (以千兆字节为单位)。但是一个千兆字节是10的第九个字节，而不是你所期望的两个到20的字节。所以我不确定他们为什么这样做，但它允许在10到第九个字节中以千兆字节引用他们的容量。这是一个更大的数字，所以看起来更好。看起来还有更多的信息。有点，我真的不知道他们为什么这样做，但我认为这就是原因。所以这是我们只需要知道并习惯的那些有点烦人的事情之一。</p><p>发言人   15:29<br>Now, the capacity is determined by two independent technology factors, 1 is the recording density. So that’s how many bits can you pack into a single sector or. Or at least a portion of a track. And then the track density, which is sort of how close can you put those tracks together? And then the product of those two is what’s called the aerial density. And that determines the overall capacity of the disk. So the aerial capacity, the more bits you can squeeze onto that surface.<br>现在，容量由两个独立的技术因素决定，1是记录密度。这就是你可以将多少位打包到一个扇区中。或者至少是轨道的一部分。然后是轨道密度，也就是你能把这些轨道放在一起的距离有多近？这两者的乘积就是所谓的空中密度。这决定了磁盘的总容量。所以天线容量，你可以挤在表面上的比特越多。</p><p>发言人   16:13<br>In the old days, when aerial densities were fairly low, each track on the surface would have the same number of sectors. So there was a constant number of sectors per track. So now what happens as you as your tracks go from near the hole by the spindle, as they go, as they move outward, if you have the same number of sectors with the same?<br>在过去，当空中密度相当低时，表面上的每个轨道将具有相同数量的扇区。因此，每个轨道的扇区数量恒定不变。那么现在，如果你有相同数量的扇区，当你的轨道从主轴附近的洞口移动时，当它们向外移动时，会发生什么呢？</p><p>发言人   16:44<br>Bit density, the gaps between sectors are going to get bigger and bigger as you go out and you’re going to be wasting more and more of your of your space. So when aerial densities were fairly low, this was OK. But after a while, it just became not okay to waste that much room.<br>位密度，随着您的外出，扇区之间的间隙将越来越大，您将浪费越来越多的空间。所以当空中密度相当低时，这是可以的。但过了一段时间，浪费那么多空间就变得不合适了。</p><p>发言人   17:02<br>So what modern systems do is they partition the tracks into these so called recording zones, where each recording zones, such as this right here, each recording zone has a conson number of sectors. So each track in a recording zone has the same number of sectors. And of course, as you move outward, if you move outward in the recording zone, you’re going to have bigger and bigger gaps. But then you start a new recording zone that will have more sectors per track. And then within that, so you can see in this outer, in this outer zone, you have more sectors than you do on this inner zone. So that’s a way to kind of deal with sort of that growth in the gaps to keep it from getting too large.<br>所以现代系统所做的是将轨道划分成这些所谓的记录区域，每个记录区域，比如这里，每个记录区域都有一个康森数目的扇区。因此，记录区域中的每个轨道具有相同数量的扇区。当然，当你向外移动时，如果你在记录区域向外移动，你将会有越来越大的间隙。然后你开始一个新的录制区域，每个轨道将有更多的扇区。然后在这个内部，你可以看到在这个外部区域，你拥有的扇区比你在这个内部区域拥有的要多。所以这是一种处理差距增长的方法，以防止差距变得太大。</p><p>发言人   17:58<br>And so because we don’t really have the number of sectors per track is in constant, we’ll use an average, the average sectors per track across all recording zones when we do sort of our capacity estimates.<br>因为我们并没有每个轨道的扇区数量是恒定的，所以当我们进行容量估计时，我们将使用平均值，即所有记录区域中每条轨道的平均扇区。</p><p>发言人   18:14<br>Okay? So as you can imagine, the formula for computing the disk capacity is fairly straightforward. It’s the number of bytes per sector, the average number of sectors per track times, the average number of tracks per surface times the number of surfaces per platter, times the number of platters per disk.<br>好吗？所以你可以想象，计算磁盘容量的公式相当简单。它是每个扇区的字节数、每个磁道的平均扇区数、每个表面的平均磁道数、每个盘片的表面数、每个磁盘的盘片数。</p><p>发言人   18:36<br>Now let’s look at how disks work. So these surfaces are spinning at a fixed rotational rate. Now, a typical rate, maybe 7200 Rpms, is a fairly common rotational rate. So the disc is spinning around, you can see this. Som pretty proud of that. So it’s spinning around counterclockwise, and then the arm moves radially, here we go. The arm moves radially and it can go over any of the tracks, okay? All right, that’s enough.<br>现在让我们看看磁盘是如何工作的。所以这些表面以固定的旋转速率旋转。现在，一个典型的速率，可能是7200 Rpms，是一个相当常见的旋转速率。所以圆盘在旋转，你可以看到这个。我为此感到非常自豪。所以它在逆时针旋转，然后手臂径向移动，我们开始。手臂径向移动，可以越过任何轨道，好吗？好的，够了。</p><p>发言人   19:23<br>Now, when you have multiple platters, each one of these, each one of there’s actually multiple arms and there’s a read right head on each surface. So if the platter has, if each side of the platter is coated with this magnetic material, then you have a read write head on each side. And then these are all connected and they kind of move together. Now, originally, these read write heads would be they were rigid because the track densities weren’t that high. So they could just sort of like, and even though the tracks didn’t align perfectly, they could just sort of, they could, the read-write heads could still cover the tracks fixed with these fixed arms. But nowadays the densities are so high that they actually, the controller can actually move the read write heads a little bit so that it matches up with all of the tracks on all of the surfaces.<br>现在，当你有多个盘片时，每个盘片实际上都有多个臂，每个表面上都有一个读取右磁头。因此，如果盘片的每一侧都涂有这种磁性材料，那么每一侧都有一个读写磁头。然后这些都是相互联系的，并且它们有点一起移动。现在，最初，这些读写头会是刚性的，因为磁道密度不是那么高。因此，即使轨道没有完美对齐，他们也可以，读写头仍然可以覆盖用这些固定臂固定的轨道。但现在的密度是如此之高，以至于控制器实际上可以稍微移动读写头，使其与所有表面上的所有轨迹匹配。</p><p>发言人   20:31<br>Okay, so let’s look at how this works, how we read data. So we have. This is our arm. And the tip of the arrow is the read write head. And it’s positioned. And the platter is rotating counterclockwise, and it’s positioned just ready to read the blue sector. So as the blue sector spins underneath the read right head, it sends those bits and sends them up to the controller, which passes them back up to the CPU. And now the CPU is requested that the disk, it’s requested the data from the red sector. So we have to take the controller, takes that read write head, moves it back to reds track, and then waits for it to spin around.<br>好的，让我们看看这是如何工作的，我们如何读取数据。所以我们有。这是我们的手臂。箭头的尖端是读写头。它的位置。并且盘片逆时针旋转，它的位置刚刚准备好读取蓝色扇区。因此，当蓝色扇区在读取右侧的磁头下方旋转时，它将这些位发送并将它们发送到控制器，再将它们传递回CPU。现在，CPU被请求了磁盘，它被请求了来自红色扇区的数据。所以我们必须拿控制器，拿那个读写头，把它移回红色轨道，然后等待它旋转。</p><p>发言人   21:26<br>To the read, write head. And then it reads that red sector. So when we first, so there’s really three components going on here that determine how long it takes to read one of these sectors. When we moved the head, that’s called the Sq. When we waited for the red track to sort of rotate around, that’s called the rotational latency. So however long it takes, on average, it’ll be half of the half of the time it takes for the entire to circle all the way around. And then there’s the data transfer, which is sort of how long it takes for that track to pass under the read write hood.<br>读、写的头。然后它显示了那个红色区域。所以当我们第一次时，这里实际上有三个组成部分决定了读取其中一个扇区所需的时间。当我们移动头部时，那就是所谓的平方。当我们等待红色轨迹旋转时，这被称为旋转延迟。因此，无论花费多长时间，平均而言，整个循环所需的时间只有一半。然后是数据传输，也就是读取写入路径所需的时间。</p><p>发言人   22:17<br>Now, the reason it’s important to know this is that these three components, you add them together, and that’s your average time it takes to access data. That time is dominated by the seek time. So seek times are measured in milliseconds. So we’re moving this head, there’s a servo that has to fire up, and there’s actual mechanical motion that takes time, and it’s on the order of 3 to 9 milliseconds. And this has been true for decades, so this value is not changing. There’s a sort of fundamental mechanical limits that make it very difficult to decrease this value.<br>现在，知道这一点很重要的原因是，这三个组件，你把它们加在一起，这就是你访问数据所需的平均时间。时间被寻道时间所支配。所以寻道时间以毫秒为单位测量。所以我们正在移动这个头，有一个必须启动的伺服装置，还有实际的机械运动需要时间，大约是3到9毫秒。这几十年来一直如此，所以这个值不会改变。有一种基本的机械限制，使得降低这个值非常困难。</p><p>发言人   23:05<br>Now, the rotational latency. The time that it takes to spin around will, we’ll call that the T average rotation. And then the time it takes to read the bits, we’ll call T average transfer T average, which is this CQ time, rotational latency, and transfer time.<br>现在，旋转延迟。旋转所需的时间，我们称之为T平均旋转。然后是读取比特所需的时间，我们称之为T平均传输T平均，也就是这个CQ时间、旋转延迟和传输时间。</p><p>发言人   23:31<br>And now if we just take some typical numbers and plug those in, you see that our seek time is on the order of milliseconds. The rotational rate is also on the order of milliseconds. So there’s also mechanical limits and how fast you can, you can spin these around, access time and the transfer time. It’s very small. So it’s orders of magnitude smaller because you just have to read a few the bits that are in one sector. So if you look, you can see that the total access time is dominated by Sq and rotational latency. So you a good rule of thumb just for sort of estimating how long it takes to read from a disk is just take twice the sequence, the seek time, and you’ll be pretty close. And basically transfer time is you get that for free.<br>现在，如果我们只取一些典型的数字并插入这些数字，您会发现我们的寻道时间大约是毫秒级。旋转速率也在毫秒级。因此，还有机械限制，以及您可以旋转这些旋转速度、访问时间和传输时间。它非常小。所以它要小几个数量级，因为你只需要读取一个扇区中的几个位。因此，如果您查看，您可以看到总访问时间由平方和旋转延迟主导。因此，估计从磁盘读取所需时间的一个好的经验法则就是只需要两倍的序列，寻道时间，你就会非常接近。基本上，转移时间是你免费获得的。</p><p>发言人   24:28<br>Now, here’s the important thing to know about disks. We SRAM access times about 4 nanoseconds to get a double word. DRAM is about 60 nanoseconds. So DRAM is an order of magnitude slower than SRAM, but disk is 40000 times slower than SRAM, so that’s 4000 orders of magnitude difference. That’s huge, it’s 250 times orders of magnitude slower than Drams, so. There’s a big gap between DRAM and SRAM, and there’s an even bigger gap between disk and other memory types.<br>现在，这是关于磁盘需要了解的重要事情。我们大约需要4纳秒的访问时间才能得到一个双字。DRAM大约是60纳秒。所以DRAM比SRAM慢一个数量级，但磁盘比SRAM慢40000倍，所以这是4000个数量级的差异。这是巨大的，它比Drams慢250倍。DRAM和SRAM之间有很大的差距，磁盘和其他内存类型之间还有更大的差距。</p><p>发言人   25:18<br>Now, modern disks present a much simpler view. So than this, this track cylinder sector geometry. So modern disk controllers actually present to the CPU. They present the disk as a sequence of logical blocks where each block is a multiple of a sector size. So in the simplest case, a block is just think of a logical block is one sector, and then blocks are numbered starting at 0, and they just go all the way up to some large number. And then the Dis controller keeps the mapping, maintains the mapping between logical blocks and the actual physical sectors.<br>现在，现代磁盘提供了一个更简单的视图。比这更重要的是，这个轨道圆柱体扇区的几何形状。所以现代磁盘控制器实际上存在于CPU中。它们将磁盘呈现为逻辑块的序列，其中每个块是扇区大小的倍数。所以在最简单的情况下，一个区块只是把逻辑区块想象成一个扇区，然后区块从0开始编号，然后它们一直编号到某个很大的数字。然后，Dis控制器保持映射，维护逻辑块和实际物理扇区之间的映射。</p><p>发言人   26:05<br>As in the old saying is most interesting ideas in computer science involve some form of indirection. So this is a level of indirection that provides this mapping between logical blocks and physical blocks. So it allows disk controllers to take some cylinders and reserve them as spare cylinders that aren’t mapped any logical blocks. And then if one of the sectors goes bad in a cylinder, the disc controller can can copy the data over to a spare cylinder and then just keep going. And so this is why your formatted capacity is less than sort of if you counted the number of actual cylinders on the disk, you formatted capacity is less than the maximum capacity because some of those cylinders are being reserved for failures. Now, devices like disks are connected to the CPU and the memory via the IO bridge over another kind of bus called an IO bus.<br>正如老话所说，计算机科学中最有趣的思想涉及某种间接形式。所以这是一个间接级别，提供逻辑块和物理块之间的映射。因此，它允许磁盘控制器将一些柱面保留为不映射任何逻辑块的备用柱面。然后，如果其中一个扇区在圆柱体中发生故障，磁盘控制器可以将数据复制到备用圆柱体中，然后继续运行。因此，这就是为什么您格式化的容量小于磁盘上实际柱体的数量的原因，如果您计算磁盘上实际柱体的数量，您格式化的容量小于最大容量，因为其中一些柱体是为故障保留的。现在，像磁盘这样的设备通过IO桥通过另一种称为IO总线的总线连接到CPU和内存。</p><p>发言人   27:14<br>What I’m showing you, what I’m showing you now is actually not representative of modern systems. It’s representative what was called the PCI bus about five years ago. Modern buses now are the PCI bus is a broadcast bus, meaning it’s just a single set of wires. So if any device changes the values on those wires, every device on that bus can see those values. That’s called the broadcast bus. And it’s the simplest kind of way to hook things together.<br>我现在向你展示的东西实际上并不代表现代系统。它代表了大约五年前所谓的PCI总线。现代的公共汽车现在是PCI总线，是一种广播总线，这意味着它只是一组电线。因此，如果任何设备更改了这些线路上的值，该总线上的每个设备都可以看到这些值。这就是所谓的广播巴士。这是把事情联系在一起的最简单的方式。</p><p>发言人   27:49<br>Modern systems use a bus structure called PCI Express, which although it has the word PCI and it’s completely different, it’s point to point devices are connected by a set of point to point connections arbitrated by some kind of a switch. And we won’t go into it. It’s the same idea. It’s a much more efficient design, it’s much faster, but it provides the same capability. Mainly it just attaches, it allows you to attach all of your devices to your to your CPU.<br>现代系统使用一种称为PCI Express的总线结构，尽管它有单词PCI并且完全不同，但它的点到点设备是通过一组由某种开关仲裁的点到点连接连接来连接的。我们不会去研究它。这是同样的想法。这是一个更高效的设计，更快，但它提供了相同的功能。主要是它只是附加，它允许您将所有设备连接到CPU。</p><p>发言人   28:24<br>So just think of this bus as this sort of a single set of wires where each wire carries a bit and every device attached to it can see all the values of all the wires. And so there are some devices that are just built directly into the motherboard and they attach to the bus. Disks are just plugged directly into and sockets on the motherboard and your graphics adapter, the USB controller, and then the system presents an interface so you can plug mouse things like mouse, mice, and keyboards into the USB controller. And then there’s expansion slots that allow you that are connect to the wires in the bus that allow you to add other devices, like maybe network if you want to put a network adapter in there.<br>因此，只需将此总线视为一组电线，每根电线都携带一个位，连接到它的每个设备都可以看到所有电线的所有值。因此，有一些设备直接内置在主板上，并连接到总线上。磁盘只需直接插入主板上的插槽和图形适配器，USB控制器，然后系统提供一个接口，以便您可以将鼠标，鼠标和键盘等鼠标插入USB控制器。然后有扩展插槽，允许您连接到总线中的电线，允许您添加其他设备，例如网络，如果您想在其中放置网络适配器。</p><p>发言人   29:16<br>Now, what happens when we want to read a disk sector? Well, the CPU initiates this read by writing a triple. So it writes three different values. It writes a command like say, read, it writes a logical block number. So I want to read a logical block number, and I want to place the contents of that logical block at a certain address in memory. Okay? So it’s a command logical block number and a memory address. The disk controller reads whatever sector corresponds to that logical block. So we’ll assume that logical blocks there consist of one sector, and then it does this interesting thing, it copies, it takes control of the bus, and it copies the data.<br>现在，当我们想要读取磁盘扇区时会发生什么？嗯，CPU通过写入三元组来启动此读取。所以它写入三个不同的值。它写一个命令，比如读，它写一个逻辑块编号。所以我想读取一个逻辑块编号，并将该逻辑块的内容放置在内存中的某个地址。好吗？所以它是一个命令逻辑块编号和一个内存地址。磁盘控制器读取与该逻辑块对应的任何扇区。所以我们假设逻辑块由一个扇区组成，然后它做这个有趣的事情，它复制，它控制总线，然后它复制数据。</p><p>发言人   30:04<br>This is the Dis controller now copies the data across the IO bus, through the IO bridge, and directly to main memory without ever notifying the CPU. So the CPU is completely. Oblivious to the fact that this transfer is going on.<br>这是Dis控制器，现在可以通过IO总线、IO桥直接将数据复制到主内存，而无需通知CPU。所以CPU是完全的。无视这种转移正在进行的事实。</p><p>发言人   30:24<br>And once it’s transferred the data to main memory, then it notifies the CPU using this mechanism called an interrupt. So it actually asserts a Pin on the actual CPU chip itself, so changes the value of that pin from 0 to 1. And that triggers an interrupt, which notifies the CPU that that sector has been copied.<br>一旦它将数据传输到主存，它就会使用这种称为中断的机制通知CPU。因此，它实际上在实际的CPU芯片上设置了一个引脚，因此将该引脚的值从0更改为1。这会触发一个中断，通知CPU该扇区已被复制。</p><p>发言人   30:52<br>So then the CPU, there’s some program somewhere waiting for that data to be read into memory. Now the CPU can execute that program and deal with that memory. So what this mechanism allows, and the reason they do this is because discs are just so god-awful.<br>因此，CPU在某处有一些程序等待数据读入内存。现在CPU可以执行该程序并处理该内存。所以这种机制允许什么，他们这样做的原因是因为光盘太可怕了。</p><p>发言人   31:15<br>Within 10 milliseconds, a system could be executing millions and millions of instructions. The CPU could be executing millions and millions of instructions. It would be a terrible waste if the CPU waited for that data to come off the disk. So what it does is it issues this request to the disk controller. And then while that really slow, laborious process is going on, the CPU can be executing other instructions and doing other useful work. So this is really essential to sort of getting reasonable performance and from keeping this really slow disk system from slowing the system down.<br>在10毫秒内，一个系统可能会执行数百万条指令。CPU可能正在执行数百万条指令。如果CPU等待数据从磁盘中出来，那将是一种可怕的浪费。所以它的作用是向磁盘控制器发出这个请求。然后，当那个非常缓慢、费力的过程正在进行时，CPU可以执行其他指令并做其他有用的工作。因此，这对于获得合理的性能和防止这个非常缓慢的磁盘系统降低系统速度非常重要。</p><p>发言人   31:57<br>Now there’s. Interesting high kind of disk called a solid state disk, which is kind of halfway between rotating discs and DRAM memories, and a solid state disk to the CPU. It looks exactly like a rotating disk. It has the same socket plug. It has the same physical interface that has the same packaging. It looks like a rotating disk. But instead of having all these mechanical parts, it’s actually built entirely out of flash memory and firmware that acts the controller. So inside of a solid state disk, there’s a firmware, a set of firmware called the flash translation layer, which serves the purpose as the same purpose as the disk controller does in a rotating disk.<br>现在有了。有趣的高级磁盘称为固态磁盘，它介于旋转磁盘和动态内存以及CPU的固态磁盘之间。它看起来就像一个旋转的圆盘。它具有相同的插座插头。它具有具有相同打包的相同物理接口。它看起来像一个旋转的圆盘。但它并没有所有这些机械部件，实际上它完全由闪存和固件构建，作为控制器的作用。因此，在固态磁盘内部，有一个固件，一组称为闪存翻译层的固件，其用途与旋转磁盘中的磁盘控制器相同。</p><p>发言人   32:56<br>And then the memory itself, the read data can be read and written from the flash memory in units of pages, which, depending on the technology, can be 512K bytes to 4 Kbytes. And then a sequence of pages forms a block.<br>然后是存储器本身，读取的数据可以以页面为单位从闪存中读写，根据技术的不同，页面可以是512k字节到4 k字节。然后一系列页面形成一个块。</p><p>发言人   33:17<br>Now, these blocks are different from the logical blocks that the CPU does. So it’s kind of an unfortunate overlap of terms. But the? Trick is, I guess the limitation is that data is written in units of pages, but a page can only be written after the entire block has been erased. So that seems kind of weird, but that’s the way it works. So what that means is if you want to write, if you want to write to a page, you have to find a block somewhere that’s been erased. You have to copy all of the other pages in your target block over to that new block, and then you can do the right. So you can see that writes now become fairly complex operation reads.<br>现在，这些块不同于CPU的逻辑块。所以这是一种不幸的术语重叠。但是这个？技巧是，我想限制在于数据以页面为单位写入，但是只有在整个块被擦除后才能写入页面。这看起来有点奇怪，但这就是它的工作方式。所以这意味着，如果你想写，如果你想写入一个页面，你必须在某个地方找到一个被擦除的块。你必须将目标块中的所有其他页面复制到该新块中，然后你才能执行正确的操作。因此，您可以看到写入现在变得相当复杂的操作读取。</p><p>发言人   34:15<br>You can read anything and then like all flash. So it’s kind of inefficient, right? Because you’re writing one page. But to do that, you have to sort of copy all the other pages in that block, and you have to erase the whole. And then when you finish, then you erase this block so it can be used for other rights.<br>你可以阅读任何东西，然后就像所有的闪光灯一样。所以有点低效，对吧？因为你正在写one page。但是要做到这一点，你必须复制该块中的所有其他页面，并且必须清除整个页面。然后当您完成时，您将清除此块，以便它可以用于其他权限。</p><p>发言人   34:37<br>So eventually, after 100000 repeated rites, these wear out. Now, the flash translation layers in modern systems do all kinds of fancy proprietary algorithms to sort of extend the life. They use caching and various tricks to extend the life of these SSD. So in practice, it’s not really a problem, which I’ll show you in a second.<br>所以最终，在100000次重复的仪式之后，这些磨损了。现在，现代系统中的闪存翻译层采用各种花哨的专有算法来延长寿命。他们使用缓存和各种技巧来延长这些固态硬盘的寿命。所以在实践中，这并不是一个真正的问题，我一会儿就会给你展示。</p><p>发言人   35:02<br>So the performance characteristics of Ssds. Now you can think of a typical hard drive you might be able to get you. I mean, when I measure them, when I measure my drives, maybe 40, 50 MB per second, that would be a typical rate. These Ssd’s are 10 times faster than that. So for sequential reads, you can get about 550 MB.<br>因此，Ssds的性能特点。现在你可以想象一个典型的硬盘驱动器，你可能能够得到它。我的意思是，当我测量它们时，当我测量我的驱动器时，可能是每秒40、50个MB，这将是一个典型的速率。这些Ssd的速度比那个快10倍。因此，对于顺序读取，您可以获得大约550个MB。</p><p>发言人   35:28<br>Sequential writes are a little bit slower. Random access, whether you’re reading or writing, is a little bit slower than sequential access. And as we’ll see, this is fairly common in memory systems. It’s almost always better to do things sequentially than to jump around. And random writes are slower because erasing takes about a millisecond. So now we’re back up to that, that millisecond range, which is slow. And as I mentioned, if you modify one page, you have to all the other pages in that block have to be copied.<br>顺序写入有点慢。随机访问，无论您是阅读还是写作，都比顺序访问慢一点。正如我们将看到的，这在内存系统中相当普遍。按顺序做事几乎总是比跳来跳去好。而随机写入速度较慢，因为擦除大约需要一毫秒。所以现在我们回到了毫秒范围，速度很慢。正如我所提到的，如果你修改了one page，你必须复制该块中的所有其他页面。</p><p>发言人   36:10<br>Now, earlier Ssd’s had a huge gap between random writes and. Sequential reads. But because of sort of improvements in the flash translation layer, these aren’t really that that difference reading and writing, writing is slower, but they’re doing all kinds of interesting, amazing things to get these numbers fairly close. So when we have a model of Ssd’s, we really don’t need to distinguish any more of that between reads and writes.<br>现在，早期的Ssd在随机写入和之间存在巨大的差距。顺序读取。但是由于闪存翻译层的改进，这些并不是读写的区别，写作比较慢，但他们正在做各种有趣的、令人惊奇的事情，以使这些数字相当接近。因此，当我们有了一个Ssd模型时，我们真的不需要再区分读和写。</p><p>发言人   36:47<br>Okay, so Ssds, because they have no moving parts, they’re faster, they take less power, they’re more rugged, which is why they’re good for thumb drives and ipods and things like that. But they have this potential to wear out, which could be a problem in practice. It’s not, for example Intel guarantees that you can do 128 PB of rights before your SSD is no longer good. So that’s a lot of data to write. I mean, think about how many years it would take to write that much data. And as of 2015, as of now, they’re a lot more expensive per byte than rotating discs. So rotating disks are much bigger, but they’re slower. Ssd’s are smaller and they’re faster.<br>好的，所以Ssds，因为它们没有运动部件，速度更快，功耗更低，更加坚固，这就是为什么它们适合使用拇指驱动器和ipod之类的东西。但它们有可能被磨损，这在实践中可能是一个问题。这不是，例如，英特尔保证您可以在固态硬盘不再有效之前执行128 PB的权利。所以这是很多数据要写。我的意思是，想想写那么多数据需要多少年。截至2015年，截至目前，它们每个字节比旋转磁盘贵得多。因此，旋转磁盘要大得多，但速度较慢。Ssd更小，更快。</p><p>发言人   37:41<br>Now take, if you look at the performance characteristics of these different storage devices relative to CPU, over time, you get this really interesting graph. Now, this graph shows on the Y AIS a time in nanoseconds in a log scale. Each one of these, each change in units from 1000 to 10000 represents an order of magnitude difference in axis time on the X axis. I’ve plotted time going from 1985 to 2015, and then I’ve plotted the sort of the access time or the cycle time of the access time of these devices, disk SSD DRAM and SRAM, and the cycle time of processors. So let’s look at on the bottom, we have the cycle time of processors over time. And what you see is it’s going down at this sort of exponential rate from 1985 to 2003. There’s a doubling basically every 18 months or two years in clock frequency and a resulting halving of the cycle time over this 18 month or two year period.<br>现在，如果你观察这些不同存储设备相对于CPU的性能特征，随着时间的推移，你会得到这个非常有趣的图表。现在，这个图表显示了Y AIS上的时间，以对数刻度为纳秒。每个单位从1000到10000的变化代表了x轴上时间轴上的一个数量级差异。我绘制了从1985年到2015年的时间，然后绘制了这些设备的访问时间或访问时间的周期时间，磁盘固态硬盘DRAM和SRAM，以及处理器的周期时间。让我们看一下底部，我们有处理器随时间的循环时间。你所看到的是，从1985年到2003年，它以指数级的速度下降。基本上每18个月或两年时钟频率就会翻一番，从而在这18个月或两年的时间内将循环时间减半。</p><p>发言人   39:12<br>What manufacturers did until 2003 to make their processors faster was they would just double the clock frequency. They decrease the feature size of the chips that they were making, and that would allow them to put things closer together. That and then. Increase the clock frequency by a proportional amount.<br>制造商直到2003年之前为了让他们的处理器更快所做的就是将时钟频率加倍。他们缩小了他们正在制造的芯片的特征尺寸，这将使他们能够将东西更紧密地结合在一起。然后。按比例增加时钟频率。</p><p>发言人   39:39<br>Now, this all ended 2003 was an interesting year in computer history. Because of this, there’s this sort of unfortunate property that the power that you consume is proportional to your frequency. So the more power, I mean, the higher the frequency, the more power you consume.<br>现在，这一切都结束了2003年，这是计算机历史上有趣的一年。因此，有一种不幸的特性，即你消耗的功率与你的频率成正比。所以功率越大，我的意思是，频率越高，消耗的功率就越多。</p><p>发言人   39:58<br>By 2003, the processor that Intel was getting ready to ship was going to burn about 800 W of power. Think about 800 W light bulbs inside your laptop. And I actually saw an early prototype of one of these devices and the heat sink to absorb the power from the chip was about this big, it was about 4 square inches. It was a giant thing just sitting on the motherboard.<br>到2003年，英特尔准备出货的处理器将消耗约800瓦的功率。想想你的笔记本电脑里有800瓦的灯泡。我实际上看到了这些设备之一的早期原型，用于吸收芯片功率的散热器大约是这么大，大约4平方英寸。这是一个巨大的东西，只是坐在主板上。</p><p>发言人   40:32<br>So that’s what we say is that processor design hit the Powerwall in 2003, they can no longer just continue to increase clock frequencies to get faster, to make faster computers. And so what they had to do after 2003 instead of increasing the clock frequency, instead of doubling the clock frequency, they put more processor cores onto the chips. So now they subdivided a CPU chip into individual processor cores. Each one could execute its own instructions. And by running in parallel, you could do more effective work. So the effective cycle time could continue to go down.<br>所以我们说的是，处理器设计在2003年进入了Powerwall，它们不能再继续增加时钟频率来变得更快，制造更快的计算机。因此，2003年之后他们必须做的不是提高时钟频率，而是将更多的处理器内核放入芯片中，而不是将时钟频率加倍。所以现在他们将CPU芯片细分成单独的处理器内核。每个人都可以执行自己的指令。通过并行运行，你可以做更有效的工作。因此，有效周期时间可能会继续缩短。</p><p>发言人   41:21<br>So what I plotted here on the bottom is the effective cycle time. So basically, the cycle time divided by the number of cores. So here in 2005, the first systems used 2 cores. So now you can run two independent threads or two independent programs, and currently it’s about 4 cores, server class systems, you can get 8 cores, there’s even some 12 core chips.<br>所以我在底部绘制的是有效循环时间。基本上，循环时间除以内核数量。所以在2005年，第一批系统使用了2个核心。所以现在你可以运行两个独立的线程或两个独立的程序，目前大约有4个核心，服务器级系统，你可以得到8个核心，甚至还有一些12个核心的芯片。</p><p>发言人   41:47<br>So in the future, what’s going to happen is that the clock frequencies are going to stay fairly constant. So you can, you can see the cycle times. They actually increased a little bit here. And then they’re slowly going down, but it’s generally flat. And so the only way to really get more performance going forward is to increase the number of independent cores, and that’s just.<br>所以在未来，时钟频率将保持相当恒定。所以你可以看到循环时间。他们实际上在这里增加了一点。然后它们慢慢地下降，但总体上是平的。因此，真正获得更高性能的唯一方法是增加独立内核的数量，而这只是。</p><p>发言人   42:15<br>The way it’s got to be now here in the black circle, the second line I’ve plotted the access time for SRAM over time. And you can see that SRAM is tracking CPU pretty good, and it’s an order of magnitude slower. It’s tracking the CPU performance pretty well.<br>现在它必须在黑色圆圈中，我已经绘制了SRAM访问时间的第二条线。你可以看到，SRAM跟踪CPU的速度相当不错，而且要慢一个数量级。它很好地跟踪了CPU的性能。</p><p>发言人   42:37<br>DRAM, you can see there’s a huge gap between the CPU and the DRAM, several orders of magnitude. And in the last few years Drams have gotten a little better, but they’ve proven surprisingly difficult to make faster. Ssds are kind of in between disks and Drams. And then disks up here, you can see at a million nanoseconds, that’s a milliseconds. So you can see disks are sort of in this, in this sort of millisecond range with access times, and they’ve gone down a little bit, but not really too much. So the point I want to make is that there’s this huge gap between DRAM SSD disk and Cpu’s. And in some cases, it’s even getting worse as time goes by. So that’s a problem, right?<br>你可以看到，CPU和DRAM之间存在几个数量级的巨大差距。在过去的几年里，Drams的性能有所改善，但事实证明，要让它们变得更快是非常困难的。Ssds介于磁盘和dams之间。然后磁盘在这里，你可以看到一百万纳秒，那是毫秒。所以你可以看到磁盘有点像这样，在这种毫秒范围内的访问时间，它们已经下降了一点，但不是太多。所以我想要说明的是，DRAM固态硬盘磁盘和Cpu之间存在巨大的差距。在某些情况下，随着时间的推移，情况甚至变得更糟。所以这是个问题，对吧？</p><p>发言人   43:33<br>How our programs all need data. Our data is stored in memory and disk. So if our computers are getting faster and our storage devices are staying relatively the same or relatively slower, then we’ve got a problem. Increases in our and computer performance will, it’ll be hard to make our programs run faster because it’ll be limited by the time it takes to access the data. So that’s sort of the fundamental problem that we have to deal with.<br>我们的程序都需要数据。我们的数据存储在内存和磁盘中。因此，如果我们的计算机变得更快，而我们的存储设备保持相对不变或相对较慢，那么我们就有问题了。在我们和计算机性能提高的情况下，很难让我们的程序运行得更快，因为它会受到访问数据所需时间的限制。这就是我们必须处理的基本问题。</p><p>发言人   44:08<br>And it turns out that the key to bridging this gap between the CPU and memory is this very basic fundamental property of programs called locality. And so this is an essential sort of fundamental, enduring property of programs, So we say that so programs have this property called locality. And what this means is that I’m sorry, just I have to read it because it’s really accurate definitions.<br>事实证明，弥合CPU和内存之间的差距的关键是程序的一种非常基本的基本属性，称为局部性。因此，这是程序的基本的、持久的属性的基本类型，因此我们说程序具有称为局部性的属性。这意味着我很抱歉，我必须阅读它，因为它的定义非常准确。</p><p>发言人   44:47<br>So programs tend to use data and instructions whose addresses are near or equal to those that they have used recently. So if a program accesses a data item, the chances are very high that it’s going to access that data item or a nearby data item sometime in the near future. That likelihood that the program is going to access that data item or a nearby at data item in the near future is this property called locality.<br>因此，程序倾向于使用地址接近或等于它们最近使用的地址的数据和指令。因此，如果一个程序访问一个数据项，它将在不久的将来访问该数据项或附近的数据项的可能性非常高。该程序在不久的将来访问该数据项或附近的数据项的可能性是这个称为 “局部性” 的属性。</p><p>发言人   45:23<br>Well, we typically distinguish two different kinds of locality. Temporal locality is the property that recently referenced items are likely to be referenced again in the near future. So if you read a variable, chances are you’re going to read that variable again. For example, suppose you’re summing into a variable inside of a loop. Each loop iteration, you’re going to access that, that variable. Spatial locality is that the tendency for items with nearby addresses that items, if we access, if we access one item, chances are high we’re going to access a nearby item. So let’s look at this little snippet of code and see if we can identify all the different kinds of locality in this code.<br>好的，我们通常区分两种不同的地点。时间局部性是最近引用的项目在不久的将来可能再次被引用的属性。所以如果你读了一个变量，很有可能你会再次读那个变量。例如，假设你在循环内求和一个变量。每次循环迭代，您都将访问那个变量。空间局部性是指具有附近地址的项目的趋势，如果我们访问某个项目，我们很有可能访问附近的项目。让我们看一下这段代码，看看我们是否可以识别这段代码中所有不同类型的位置。</p><p>发言人   46:17<br>So we have two different kinds of references. There’s data references, and then there’s instructions. So we’re reading instructions out of memory, and those instructions are referencing data.<br>所以我们有两种不同的参考文献。有数据参考，然后有说明。所以我们从内存中读取指令，而这些指令引用数据。</p><p>发言人   46:29<br>So first of all, notice that we’re referencing the elements of an array in succession. So we’re increasing I by one each time. And then so we’re incrementing each iteration through the loop, and we’re reading AI. So this is called a stride one reference pattern. The stride is how much we’re incrementing this index. So since we’re incrementing it by one, we call that a stride 1 pattern.<br>首先，请注意我们正在连续引用数组的元素。所以我们每次将I增加一个。然后，我们通过循环递增每个迭代，并阅读AI。所以这被称为步幅一参考模式。步幅是我们增加这个指数的幅度。所以，由于我们将其递增一，我们称之为步幅1模式。</p><p>发言人   46:58<br>So what kind of locality is the repeated references to AI, spatial or temporal. Spatial because we’re accessing nearby items. What about referencing this variable sum inside the loop? That’s temporal.<br>那么对AI的重复引用是什么样的地点，是空间的还是时间的。空间，因为我们正在访问附近的物品。在循环中引用这个变量的总和怎么样？这是暂时的。</p><p>发言人   47:22<br>Now, what about instructions? Ween each loop iteration? We’re executing a sequence of instructions. So what kind of locality is that? Within each loop iteration, No, that’s spatial, right? Because we’re just executing a sequence of instructions within each loop iteration. But then we cycle through the loop repeatedly. Chances, so each loop iteration, we’re going to access each of those instructions that we access the previous loop iteration. So we go up and we, we’re just going to keep executing the same assembly language instructions that implement this loop body. Now in this simple example, it’s probably one instruction, but in general, your loop can have multiple instructions.<br>那么，指令呢？是否每个循环迭代？我们正在执行一系列指令。那是一个什么样的地方？在每个循环迭代中，不，那是空间的，对吧？因为我们只是在每个循环迭代中执行一系列指令。但是随后我们反复循环循环。机会，所以每次循环迭代，我们将访问我们访问前一次循环迭代的每条指令。所以我们向上走，我们将继续执行与实现此循环体相同的汇编语言指令。现在在这个简单的例子中，它可能是一条指令，但一般来说，你的循环可以有多条指令。</p><p>发言人   48:16<br>Now, what I claim to you, and one of the main sort of points of this whole course is that as a professional programmer, it’s an essential skill that you be able to look at code and you get a qualitative sense of its locality. Because as we’ll see, good locality turns into good performance.<br>现在，我向你声称，这整个课程的主要观点之一是，作为一名专业程序员，能够查看代码并获得其局部性的定性感知是一项基本技能。因为正如我们将要看到的，好的地方变成了好的表现。</p><p>发言人   48:40<br>The way that systems are built these days. So as a programmer, it’s very important for you to be able to kind of look at code and get some qualitative sense, like that’s pretty good locality, that’s terrible locality. And what you want to do is avoid the terrible locality in your code.<br>这些天系统的构建方式。所以作为一名程序员，能够查看代码并获得一些定性感知非常重要，比如这是相当好的局部性，那是可怕的局部性。你想要做的是避免代码中的可怕局部性。</p><p>发言人   48:59<br>So let’s look at a simple example here to see what I mean by this. So what I’m doing is I’m taking an array, a two dimensional array A with m rows and n columns, and within a doubly nested loop, iterating on I and J I’m summing the elements of that array. It seems this is a very simple operation, what could go wrong, right? So it turns out if you write this code to have bad locality, it’ll run order of magnitude slower. So just look at this. If you look at this, do you think this has good locality or bad locality? I mean, let’s look at with respect to the accesses of A.<br>那么让我们来看一个简单的例子，看看我的意思是什么。所以我正在做的是获取一个数组，一个具有m行和n列的二维数组a，并在一个双重嵌套循环中迭代I和J，我正在求和该数组的元素。看起来这是一个非常简单的操作，可能会出错，对吧？所以事实证明，如果你编写这个代码具有错误的局部性，它会运行得慢几个数量级。所以看看这个。如果你看看这个，你认为这里的地点是好还是坏？我的意思是，让我们看看A的访问权限。</p><p>发言人   49:56<br>Good or bad?<br>好还是坏？</p><p>发言人   50:03<br>Well, so how is a laid out in memory, right? It’s rho y, so c uses lays out arrays, rho y, so all the elements of the first row, followed by all the elements of. The second row, followed by all the elements of the third row.<br>那么，在记忆中如何铺开呢？它是rho y，因此c使用布局数组rho y，因此第一行的所有元素，后面跟着的所有元素。第二行，后面跟着第三行的所有元素。</p><p>发言人   50:24<br>So how are we accessing this array? We’re accessing aij, and we’re varying j the fastest. So we hold I constant, and then we vary j, and then we all, so we hold I constant to access row I, and then we vary j to access all the columns in that row. So each each iter, and then we increase, and then we go back and increase I so now we’re accessing the next row. So if we were to look at the addresses of aij, the sequence of addresses that are being read, those would correspond to a stride 1 AIS. And so we’d be accessing all the elements of of a sequentially in order. So that’s really good spatial locality. That’s the best you can do.<br>那么我们如何访问这个数组呢？我们正在访问aij，并且我们以最快的速度变化j。所以我们保持I不变，然后改变j，然后我们全部，所以我们保持I不变以访问第I行，然后我们改变j以访问该行中的所有列。所以每个iter，然后我们增加，然后我们返回并增加I，现在我们正在访问下一行。因此，如果我们查看aij的地址，即正在读取的地址序列，这些地址将对应于步幅1 AIS。因此，我们将按顺序访问的所有元素。所以这是非常好的空间局部性。这是你能做的最好的了。</p><p>发言人   51:22<br>Now, what about? And then we have temporal locality on some. So that’s good. So everything about this is pretty good. So this is the good case.<br>现在，怎么样？然后我们有一些时间局部性。这很好。所以这方面的一切都相当不错。所以这是一个好的案例。</p><p>发言人   51:35<br>Now what about this, what I’ve done? I’ve taken the same program and I’ve just inverted the loops, so I have loop on J first, and then on I, and then I just have the same inner loop body. Now, what does that do to the spatial locality of our accesses? Of a terrible because it’s going? You should be offended when you see this.<br>现在怎么样，我做了什么？我已经使用了相同的程序，并且我刚刚反转了循环，所以我首先循环J，然后循环I，然后我只有相同的内部循环体。现在，这对我们访问的空间局部性有什么影响？可怕的，因为它正在发生？当你看到这个时，你应该感到生气。</p><p>发言人   52:08<br>This is awful, but it’s terrible, right? Because so now J, we’re holding j constant, and then we’re iterating through the jth element of each row. So that’s skipping, We have n elements in each row, so we’re doing a stride n access through memory. So we’re like this, and then we’re then, then we’re incrementing the column by one, and then we’re doing this again. So it’s terrible spatial locality. This is the worst spatial locality we could get.<br>这很糟糕，但也很糟糕，对吧？因为现在J，我们保存j常量，然后迭代每行的第J个元素。所以这是跳过，我们每一行有n个元素，所以我们通过内存进行跨步访问。所以我们是这样的，然后我们将列递增一，然后我们再次这样做。所以这是可怕的空间局部性。这是我们能得到的最糟糕的空间位置。</p><p>发言人   52:51<br>Now let’s look at a three dimensional array. And let me pose the following question. Can you, based on this sort of qualitative idea, this idea that you want to try to get a stride one reference pattern? So how would you permute these given this, given this inner body, aka ij, how would you permute these loop indices to give a stride one reference pattern? That’s right, k ij is right. So in general, what we want to do is we want to go going from right to left. We want those indices to be changing the fastest. So we want j, we want k, and I to be held constant on, and then we want to change j, then we want to increment I, and then for that, those values of k and I, we want to sequence through all the values of j again.<br>现在让我们来看一个三维数组。让我提出以下问题。基于这种定性的想法，你想尝试获得跨步参考模式的想法可以吗？那么，在给定这个内部身体，也就是ij的情况下，您将如何对这些循环索引进行排列，以提供一个步幅一个参考模式？这是对的，k ij是对的。一般来说，我们想要做的是从右到左前进。我们希望这些指数变化最快。所以我们希望j，我们希望k和I保持不变，然后我们想要改变j，然后我们想要增加I，为此，我们想要对j的所有值进行排序。</p><p>发言人   54:00<br>Okay, so we’ve looked at properties of of storage technologies. And there’s this sort of basic, sort of fundamental principle that cheaper storage. Bigger storage, higher capacity storage is cheaper. More expensive storage is smaller because we can’t spend enough money. There’s this gap. There’s this gap between our storage devices and the CPU that, at least in the case of disks, they’re getting bigger. And we have programs that exhibit locality. These three things, these properties, storage technologies, and properties of our programs complement each other in this beautiful way to suggest and inform the design of our storage systems. And this design is something called the memory hierarchy.<br>好的，我们已经研究了存储技术的特性。而且有一种基本的、基本的原则，就是更便宜的存储。更大的存储，更高容量的存储更便宜。更昂贵的存储空间更小，因为我们不能花足够的钱。有这个差距。我们的存储设备和CPU之间存在着差距，至少在磁盘方面，它们正在变得越来越大。我们有展示地方的节目。这三件事情，这些属性，存储技术和我们程序的属性，以这种美丽的方式相互补充，建议和指导我们的存储系统的设计。这个设计被称为记忆层次结构。</p><p>发言人   55:07<br>Here’s the idea of a memory hierarchy. You layer. Instead of a flat memory system, you now you create your memory system as a hierarchy of devices. And at the top of this hierarchy, you have your smaller, faster, and more expensive storage devices. At the very top, you have registers are, which can be accessed within one cycle, right? One instruction while that instruction is executing can access read and write into a register, so registers are at the top of the hierarchy. But because those are in custom silicon, they’re very expensive. The fabrication plants to make processors cost billions of dollars. So this is the most expensive, and because of that, it’s also the smallest.<br>这里有一个记忆层次结构的想法。你层。现在，您可以将内存系统创建为设备的层次结构，而不是平面内存系统。在这个层次结构的顶部，您有更小、更快、更昂贵的存储设备。在最顶部，您有寄存器，可以在一个周期内访问，对吗？一条指令在执行时可以读取和写入寄存器，因此寄存器位于层次结构的顶部。但由于这些是定制硅，它们非常昂贵。制造处理器的制造厂耗资数十亿美元。所以这是最贵的，也正因为如此，它也是最小的。</p><p>发言人   56:00<br>We’ve only got 16 registers at the top of the hierarchy. Now below that, put one or more SRAM memories. Remember SRAM is faster, it’s the fastest kind of memory. So we put one or more so-called caches, cache memories built out of SRAM in the processor chip itself. And then, and these caches, because they’re made out of SRAM, they’re on the order of megabytes in size. They’re much bigger than registers, but they’re megabytes, which if we look, and then beneath that is our main memory, which is built out of Drams. And those can be gigabytes, tens of gigabytes on modern systems. And then below that is our local disks.<br>我们在层次结构的顶部只有16个寄存器。现在在下面放置一个或多个SRAM记忆。请记住，SRAM更快，它是最快的内存类型。因此，我们在处理器芯片本身中放置了一个或多个所谓的缓存，即由SRAM构建的缓存内存。然后，这些缓存，因为它们是由SRAM组成的，它们的大小在兆字节量级上。它们比寄存器大得多，但它们是兆字节，如果我们看一下，下面是我们的主内存，它是用dram构建的。而这些可以是千兆字节，在现代系统上可以是数十千兆字节。下面是我们的本地磁盘。</p><p>发言人   56:54<br>And we can even have lower layers like web servers that are storing for storing stuff on Google that you can think of that as just part of our hierarchy.<br>我们甚至可以有更低层，比如网络服务器，它们在谷歌上存储东西，你可以把这看作是我们层次结构的一部分。</p><p>发言人   57:06<br>Now, here’s the key idea. In a memory hierarchy, each level in this hierarchy holds data that’s retrieved from the next lower. So cache registers hold data that’s stored in the L 1 cache. The L 1 cache holds data that’s retrieved from the L 2 cache. The L 3 cache holds data that’s restored, that’s retrieved from main memory. Main memory holds data retrieved from secondary disk, and so on.<br>现在，这是关键的想法。在内存层次结构中，此层次结构中的每个级别都保存从下一个较低级别检索的数据。所以缓存寄存器保存存储在L 1缓存中的数据。L 1缓存保存从L 2缓存检索的数据。L 3缓存保存已恢复的数据，这些数据是从主内存检索的。主内存保存从辅助磁盘等检索到的数据。</p><p>发言人   57:43<br>Now, as we’ll see, the reason memory systems are designed like this is that they when you have this kind of system. In general, you can access your data at the speed of the fastest item in the day and at the top of the hierarchy. So that’s the fastest. But with the cost of the storage at the lower part of the hierarchy. So this works all because of an idea called caching. So a cache to a.<br>现在，正如我们将看到的，记忆系统被设计成这样的原因是当你拥有这种系统时。通常，您可以以一天中最快的项目的速度和层次结构的顶部访问数据。所以这是最快的。但存储成本位于层次结构的较低部分。所以这之所以有效，完全是因为一种叫做缓存的想法。缓存到a。</p><p>发言人   58:25<br>Computer scientist is a it’s a smaller, faster storage device that acts as a staging area for the data in a larger, slower device. So just like here, you can think of your main memory is a cache for data that’s stored on disk. You read memory from disk, and then you store it in main memory. You can think of the main memory as a staging area. So once you get the data from the disk, you don’t access it again on the disk. You access it in memory, which is much faster. So this idea propagates all the way up the hierarchy.<br>计算机科学家是一种更小、更快的存储设备，充当大型、更慢的设备中数据的临时区域。就像这里一样，你可以把你的主内存想象成存储在磁盘上的数据的缓存。你从磁盘中读取内存，然后将其存储在主内存中。你可以把主存储器想象成一个临时区域。因此，一旦您从磁盘中获取数据，就不会再在磁盘上访问它。您可以在内存中访问它，这要快得多。所以这个想法一直在层次结构中传播。</p><p>发言人   59:03<br>So you can think of a cache. One way to think of a cache is imagine your backpack when you’re getting ready to come to school in the morning. So you’re in your apartment, which is kind of far away from school. So before you come into school, you take items from your house and you put them in your backpack because, and then, then you come to school and if you need those items, they’re in your backpack. If you didn’t do that every time you needed something, you’d have to walk back home and get it and walk back to school.<br>所以你可以想到一个缓存。一种思考缓存的方法是想象你的背包，当你准备早上上学的时候。所以你在你的公寓里，离学校有点远。所以在你来学校之前，你从家里拿物品放在你的背包里，因为，然后你来到学校，如果你需要这些物品，它们就在你的背包里。如果你每次需要什么东西的时候不这样做，你就必须步行回家去拿，然后步行回学校。</p><p>发言人   59:40<br>So the idea of caching is it’s a very familiar kind of simple notion, but it turns out to be quite powerful. And it shows up in all parts of of computer systems.<br>所以缓存的想法是它是一种非常熟悉的简单概念，但事实证明它非常强大。并且它出现在计算机系统的各个部分。</p><p>发言人   59:54<br>So what we say is for each level k in the hierarchy, the faster, smaller device at level k serves as a cache. For the larger, slower device at level k plus one. And remember, our levels go from, so L 0 is the highest. So the smallest, lowest level is actually the highest, the furthest up in the hierarchy. And as we increase the levels, we’re going down the hierarchy.<br>所以我们所说的是，对于层次结构中的每个级别k，级别k中更快、更小的设备充当缓存。对于级别k加一的较大、较慢的设备。请记住，我们的水平从，所以L 0是最高的。所以最小的、最低的层次实际上是层次结构中最高、最远的。随着我们增加级别，我们将沿着层次结构往下走。</p><p>发言人   01:00:24<br>Now, why do they work? So this is a really fundamental idea. They work because of locality. So because of locality, programs tend to access data that’s stored at level k more often than they access data at level k plus one. So if we access an item at level k plus one, we can move it up to level K, chances are, because of locality, we’re going to access it again. So now we’re accessing the data at level k multiple times at the rate at the speed of level k, not at the speed of level k plus one. So that’s the fundamental idea.<br>现在，他们为什么工作？所以这是一个非常基本的想法。他们工作是因为当地的原因。因此，由于局部性的原因，程序倾向于更频繁地访问存储在级别k的数据，而不是访问级别k加一的数据。因此，如果我们访问k加一级别的项目，我们可以将其移动到K级别，由于位置的原因，我们很可能会再次访问它。所以现在我们以级别k的速度多次访问数据，速度不是级别k加一。这就是基本思想。</p><p>发言人   01:01:11<br>And because we’re not accessing data at level k plus one as often, we can afford to use slower storage devices, which are cheaper. And thus, we can make them bigger and cheaper to bit. So what this does is the hierarchy creates a large pool of storage that’s roughly about the size of the lowest level that can be accessed at the speed at the highest level.<br>而且因为我们不经常在级别k加一访问数据，我们可以负担得起使用较慢的存储设备，这些设备更便宜。因此，我们可以把它们做得更大，更便宜。所以这样做的是层次结构创建了一个大型存储池，大小大约是最低级别的大小，可以以最高级别的速度访问。</p><p>发言人   01:01:45<br>All right, let’s look at how caching works in a general way. And then we’ll see on Thursday how these hardware cache memories work. But like I said, caching is a very general idea that can be applied at all levels in the hierarchy.<br>好的，让我们来看看缓存在一般情况下是如何工作的。然后我们将在周四看到这些硬件缓存存储器是如何工作的。但是就像我说的，缓存是一个非常普遍的想法，可以应用于层次结构中的所有级别。</p><p>发言人   01:02:03<br>Here we have a cache in all kinds of most caches. There’s some kind of transfer unit to go from one level to the next. At this upper level, we have what we’ll call the cache that can hold four blocks, so our memory. And then at the lower level, we have memory. And this memory is partitioned into blocks of some fixed size. That’s the way cache is near the upper part of hierarchy work.<br>在这里，我们在各种大多数缓存中都有一个缓存。有一种转移单元可以从一个级别转到下一个级别。在这个上层，我们拥有所谓的缓存，可以容纳四个块，即我们的记忆。然后在较低层次，我们有记忆。并且这个内存被划分成一些固定大小的块。这就是缓存靠近层次结构上部的工作方式。</p><p>发言人   01:02:41<br>Now, at the lower level, it’s like if you’re accessing data, say, from a web server, then the data is partitioned into files typically. But at upper levels, the data is partitioned into block. So just suppose this is main memory. And then above that we have that consists of a bunch of these blocks. So we just take the memory and partition into blocks where each block is the same number of bytes. And then data will be transferred between memory and the cache in block size transfer units. So if you need data from the memory, if the cache needs data from the memory, it’ll grab a whole block. And then at any point in time, the cache holds a subset of the blocks in main memory.<br>现在，在较低的级别上，就像如果您正在访问数据，例如从web服务器，那么数据通常会被分区为文件。但在较高的级别，数据被分区为块。所以假设这是主记忆。然后在上面我们有由一堆这些块组成的。所以我们只是将内存和分区分成几个块，每个块的字节数相同。然后数据将以块大小传输单元在内存和缓存之间传输。因此，如果您需要内存中的数据，如果缓存需要内存中的数据，它将占用整个块。然后在任何时间点，缓存都保存主内存中块的子集。</p><p>发言人   01:03:31<br>So this cache is much faster, but it’s also much slower. And because of that, and it’s much smaller. I’m sorry, it’s much faster, but it’s much more expensive because it’s faster. It’s more expensive. And because it’s more expensive, it’s smaller.<br>所以这个缓存速度要快得多，但速度也慢得多。正因为如此，它变得更小了。对不起，它更快，但是因为它更快，所以它更昂贵。它更昂贵。因为它更贵，所以更小。</p><p>发言人   01:03:56<br>Now suppose the cache wants to reference, say, that the CPU asks for data that’s contained in block 4. So it looks to see if the data is in the cache, it’s not. So the cache asks the memory to give it block 4. So that block is copied from memory into the cache, overriding the one of the existing, in this case, block 8. It’ll overwrite block 8. Now block 4 is in our cache now.<br>现在假设缓存想要引用，比如说，CPU请求的数据包含在第4块中。所以它会查看数据是否在缓存中，其实不是。所以缓存要求内存给它块4。以便将该块从内存复制到缓存中，覆盖现有的块之一，在本例中为块8。它会覆盖第8块。现在块4现在在我们的缓存中。</p><p>发言人   01:04:32<br>Now suppose the CPU for some data that’s in block 10, that gets copied up and we overwrite that block. Now the whole idea of storing it in the cache is that we’re hoping that the program that’s executing on the CPU, we’ll reuse one of those blocks we just spent all the time we went to all this trouble to copy from memory to this cache. And we know that’s slow.<br>现在假设块10中的某些数据的CPU被复制并覆盖该块。现在，将其存储在缓存中的整个想法是，我们希望在CPU上执行的程序能够重用其中的一个块，我们一直在费心地将其从内存复制到缓存中。我们知道这很慢。</p><p>发言人   01:05:02<br>So now suppose that the CPU needs some data in block B, in this case 14, okay? So it needs a memory word that’s stored that was originally stored in memory in block 14. Well, now this CA can just return, that’s what we call a hit. So the block that we access is in the cache. So that’s good. Hits are good because now we can return that block directly to the CPU. And this memory is much faster than if we had to go all the way to main memory to the DRAM. So the SRAM much faster than the DRAM. So the CPU gets that block 14 much faster than it would have if it had just gone all the way to memory.<br>现在假设CPU需要块B中的一些数据，在这种情况下是14，好吗？所以它需要一个存储在块14中的内存字。好的，现在这个CA可以返回了，这就是我们所说的打击。所以我们访问的块在缓存中。这很好。命中结果很好，因为现在我们可以直接将该块返回到CPU。这种内存比我们必须从主内存一直到DRAM要快得多。因此，SRAM比DRAM快得多。因此，CPU获取块14的速度比它刚刚完全进入内存的速度要快得多。</p><p>发言人   01:05:56<br>Sort of.<br>类似的。</p><p>发言人   01:05:59<br>The opposite of a hit is a miss. So suppose the Cpus for block 12, the cache looks for that block, can’t find it, That’s a miss. So the cache has to ask that the main memory of the DRAM for block 12, where it gets copied into the cache, and then it can return that. So that takes longer. So the CPU has to wait for that block X to be fetched from memory. And so misses are slow. So hits are good because they’re fast. Misses are bad because they’re slow.<br>命中的反面是错过。所以假设块12的CPU，缓存会寻找该块，但找不到，这是一个遗漏。所以缓存必须要求块12的DRAM的主内存复制到缓存中，然后它可以返回它。所以需要更长的时间。所以CPU必须等待从内存中获取那个块X。所以错过是缓慢的。所以点击数很好，因为它们很快。错过是不好的，因为它们很慢。</p><p>发言人   01:06:35<br>Now, we typically distinguish between several different kinds of caches. So the first kind of miss is a cold miss or a compulsory miss, which is caused because there’s just nothing in the cache. Initially, caches are empty, they have no blocks. And as we, as we fetch blocks from the lower level, from the next level and put them in the cache, the cash will slowly fill up with blocks and get, and that will increase the likelihood of hits. But when the cash is empty, we’re going to miss every time. So there’s just no way to avoid cold misses you. So this is called warming up your cache. So as you load data items into the cache initially it’s called, and as you add more items, you’re warming it up, meaning that you’re increasing the likelihood of a hit.<br>现在，我们通常区分几种不同类型的缓存。所以第一种失误是冷失误或强制性失误，这是因为缓存中没有任何东西引起的。最初，缓存是空的，它们没有块。当我们从较低的级别提取块，从下一个级别提取块并将它们放入缓存时，现金会慢慢填满块并获取，这将增加命中的可能性。但是当现金是空的时候，我们每次都会错过。所以没有办法避免感冒会让你想念。所以这叫做预热你的缓存。因此，当您将数据项加载到缓存中时，最初称为它，而当您添加更多项目时，您正在预热它，这意味着您正在增加命中的可能性。</p><p>发言人   01:07:26<br>Theres? Another sort of symmetric kind of miss, which is called a capacity miss. And these misses are due to the fact that the cache is just a certain size. In the example we looked at, we only had four blocks.<br>有吗？另一种对称类型的未命中，称为容量未命中。而这些失误是由于缓存只有一定的大小。在我们看的例子中，我们只有四个区块。</p><p>发言人   01:07:48<br>If our temporal locality involves 8 blocks, say if the loop that we’re accessing is, is accessing elements in array that consists of eight blocks, there’s just not enough room to store 8 blocks in that four block cache. So we’re going to get misses. We would need a bigger cache to be able to satisfy and store those eight blocks. And if we had a big enough cash, then we’d get good hit rate. If we could store all the blocks in our CA, then the cash could take advantage of the spatial and temporal locality within that program.<br>如果我们的时间局部性涉及8个块，比如我们正在访问的循环正在访问由8个块组成的数组中的元素，那么在这4个块缓存中就没有足够的空间来存储8个块。所以我们会错过。我们需要更大的缓存来满足和存储这八个块。如果我们有足够大的现金，那么我们就会获得良好的命中率。如果我们可以将所有块存储在我们的CA中，那么现金就可以利用该程序内的空间和时间局部性。</p><p>发言人   01:08:28<br>So in general, what we call the set of blocks at any point in time when a program is running, we call the set of blocks that are sort of being accessed over and over again, the working set. So your working set and the working set will change as you go from loop to loop, from function to function. But at any point in time in your program, when you have this idea of a working set, which is sort of the blocks that you need to have stored in your cache. And so when your working set size exceeds your cache size, then you get capacity misses.<br>因此，通常情况下，当程序运行时，我们在任何时间点称之为块集，我们将一遍又一遍地访问的块集称为工作集。因此，随着循环与函数的转换，您的工作集与工作集将发生变化。但是在程序中的任何时间点，当你有一个工作集的想法时，工作集是你需要存储在缓存中的块的一种。因此，当您的工作集大小超过高速缓存大小时，您会出现容量损失。</p><p>发言人   01:09:04<br>There’s this other kind of weird miss called a conflict miss, which has to do with the way that caches are often implemented. So the idea is that most caches, especially hardware caches, because they have to be simple. Have they limit where a block can be placed to some small set of positions in the cache?<br>还有另一种奇怪的错过，称为冲突错过，这与缓存的实现方式有关。所以这个想法是，大多数缓存，特别是硬件缓存，因为它们必须简单。他们是否限制了一个块可以放置在缓存中的一些小位置上？</p><p>发言人   01:09:32<br>So like one of the simplest models is to just take block. I can only be placed in block. I mod the cache size. So in that little cache we saw that had four blocks, we would take block I for memory, and we would stick it at block I mod 4. So block 0 would go at block 0 in our cache as would block 4, and as would block 8, block 9 would go into block 1 in the cache and that’s. When that happens, suppose, suppose we use that model. So we’re going to block I, and we’re going to put it. We can only place it in the cache at block I mod 4.<br>最简单的模型之一就是取块。我只能被放在区块中。我mod缓存大小。因此，在那个小缓存中，我们看到它有四个块，我们会将块I作为内存，并将其粘贴在块I mod 4。因此，块0将在我们的缓存中进入块0，就像块4一样，块8，块9将进入缓存中的块1，这就是。当这种情况发生时，假设我们使用那个模型。所以我们要阻止I，然后我们要放置它。我们只能将它放在块I mod 4的缓存中。</p><p>发言人   01:10:27<br>Now suppose, suppose our reference pattern involves from memory block 0, block 4, and block 8, it’s only three blocks, so we have enough room in the cache to store those three blocks. But because of the way we’ve decided to place blocks, each block will eviction. When we access block 4, it’ll go into block 0 in the cache When we access block 4 in the cache, it’ll overwrite that block, and it’ll go into block 0 in the cache. And so because of this, it’s really the access pattern conspiring with the algorithm that we’re using for placing blocks. So because of this, we have plenty of room in the cache. But because of this sort of the access pattern conspiring with the placement algorithm, we get misses every time we we’ll see how conflict verses work in detail when we study Cash is Tomorrow.<br>现在假设，假设我们的参考模式涉及到内存块0、块4和块8，它只有三个块，所以我们在缓存中有足够的空间来存储这三个块。但由于我们决定放置街区的方式，每个街区都会被驱逐。当我们访问块4时，它将进入缓存中的块0，当我们访问缓存中的块4时，它将覆盖该块，并进入缓存中的块0。正因为如此，访问模式与我们用于放置块的算法相结合。因此，我们在缓存中有足够的空间。但是由于这种与放置算法相关联的访问模式，当我们研究明天的现金时，每次我们看到冲突是如何详细工作的时候，我们都会错过。</p><p>发言人   01:11:32<br>So? So these caches exist everywhere in the memory hierarchy. And so all of them are caches of one form or another. So you can think of the registers as a type of cache.<br>所以呢？因此这些缓存存在于内存层次结构中的各个位置。所以它们都是某种形式的缓存。所以你可以把寄存器看作是一种缓存。</p><p>发言人   01:11:50<br>What are they CA 4 or 8 B words, where is it cached? It’s cached right on the CPU itself, what’s the latency? It’s instant, happens within an instruction. And then who manages the cache? Somebody has to manage the cache when there’s a request to load an item from the lower level in the hierarchy, something has to decide what to do with that, where to put it in the cache. That’s called managing the cache. Well, in this case, the compiler manages the cache When you compile your C code, the compiler figures out which register data items from memory are going to go into.<br>它们可能是4或8 B的单词，它们缓存在哪里？它缓存在CPU本身上，延迟是多少？它是瞬间的，发生在一个指令中。然后谁管理缓存？当有人请求从层次结构的较低层加载项目时，有人必须管理缓存，有些人必须决定如何处理它，将它放在缓存中的哪个位置。这称为管理缓存。好的，在这种情况下，当您编译C代码时，编译器管理缓存，编译器会计算出内存中的哪些寄存器数据项将进入。</p><p>发言人   01:12:33<br>TLB, this is something, this is a cache that’s used in virtual memory. Then there’s these hardware caches called L 1 and L 2 caches. So they store 64 B blocks on modern Intel systems, and they’re cached on the CPU chip itself in Srams that are built right into the CPU chip. And depending on whether L 1 cache on Core i7 S have a latency of four cycles and L 2 has a latency of 10 cycles. And both of these are managed by hardware. So when the CPU fetches an item from the L 1 cache, where are finds it? And if there’s a miss and a block is loaded from L 2, the hardware in the L 1 cache figures out where to put it. So all this is done without any intervention by hardware disks, contains operating systems, maintain buffer.<br>TLB，这是一种在虚拟内存中使用的缓存。然后有这些硬件缓存，称为L 1和L 2缓存。因此，它们在现代英特尔系统上存储64个B块，并将它们缓存在CPU芯片本身的Srams中，这些Srams直接内置于CPU芯片中。取决于核心i7上的L 1缓存的延迟是否为四个周期，而L 2的延迟是否为10个周期。这两个都由硬件管理。所以当CPU从L 1缓存中获取一个项目时，在哪里可以找到它？如果有未命中的情况，并且从L 2加载了一个块，则L 1缓存中的硬件会确定将其放置在哪里。所以所有这些都是在没有任何硬件磁盘干预的情况下完成的，包含操作系统，维护缓冲区。</p><p>发言人   01:13:32<br>Caches, So in this case, what’s cached is portions of files. And they’re cached in main memory. And latency to main memory, about 100 cycles or so. And these are managed by the operating system. So the operating system reserves a portion of memory to store files that you’ve loaded. So the operating system exploits locality if you read a file and then start reading referencing bytes from that file, it’ll actually be served from the file cache and it won’t go up to disk.<br>缓存，因此在这种情况下，缓存的是文件的部分。它们缓存在主内存中。和主存储器的延迟，大约100个周期左右。这些是由操作系统管理的。因此，操作系统会保留一部分内存来存储您加载的文件。因此，如果您读取一个文件，然后开始从该文件中读取引用字节，操作系统将利用局部性，它实际上将从文件缓存中提供，并且不会上传到磁盘。</p><p>发言人   01:14:13<br>Network networks maintain caches like things like NFS and Afs, maintain local caches on disk. Your browser has a cache, so when it fetches files from servers, it stores those files locally on disk. So if you reference those web pages, again, they’re served from your local disk rather than going all the way across the network. So the point is that these caches exist everywhere in the memory hierarchy, and they’re all based on the same principles. They’re just implemented in different ways.<br>网络网络维护像NFS和Afs这样的缓存，维护磁盘上的本地缓存。你的浏览器有一个缓存，所以当它从服务器获取文件时，它会将这些文件本地存储在磁盘上。因此，如果您引用这些网页，它们会从本地磁盘提供服务，而不是通过网络一直提供。所以重点是这些缓存存在于内存层次结构中的各个位置，并且它们都基于相同的原则。它们只是以不同的方式实现。</p><p>发言人   01:14:51<br>OK, so just to summarize what we’ve done today, we’ve seen that there’s a gap between the CPU and our storage devices that continues to increase. We’ve seen that well-written have this property called locality, and we’ve seen that caching. By taking, by using caching, we can build a memory hierarchy that takes advantage of locality in programs and allows us to build storage systems where we can access data at the rate of the fastest device, but at the cost and capacity of devices at the lowest level. So Thursday, we’re going to look at a very specific part of the hierarchy called cache memories.<br>好的，总结一下我们今天所做的，我们已经看到CPU和我们的存储设备之间存在着差距，并且这种差距还在继续扩大。我们已经看到，精心编写的具有称为 “位置” 的属性，并且我们已经看到了缓存。通过使用缓存，我们可以构建一个内存层次结构，利用程序中的局部性，并允许我们构建存储系统，在这个系统中，我们可以以最快的设备的速度访问数据，但以最低水平的设备的成本和容量访问数据。今天，我们将研究层次结构中一个非常具体的部分，称为缓存记忆。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深入理解计算机系统 010-Program Optimization</title>
    <link href="/2025/10/12/15213-010/"/>
    <url>/2025/10/12/15213-010/</url>
    
    <content type="html"><![CDATA[<p>发言人   00:00<br>So we’ve now gotten through all the lectures on machine code, and we’re starting to talk about, okay, now that you know this stuff, what can you do with it? And this lecture is along the lines of that. This is sort of what you are now empowered to do now that you can look at and understand machine code.<br>所以我们现在已经通过了所有关于机器代码的讲座，并且我们开始谈论，好吧，现在你知道这些东西了，你能用它做什么？这次讲座就是这样的。这就是你现在有权做的事情，你现在可以查看和理解机器码了。</p><p>发言人   00:21<br>This material is a little, actually. There’s a whole chapter of the book, chapter 5 on performance optimization. And we’re only going to do one lecture on it. And we don’t have any labs, unfortunately, that really get you to push your limits on this, which is too bad because it’s a very interesting topic. One, I think you’d find yourself well equipped for. There are typically a few small exam problems that are sort of based on some of the material here you’ll find in old exams.<br>这种材料实际上有点。这本书有一整章内容，第五章是关于性能优化的。我们只打算做一个关于它的讲座。不幸的是，我们没有任何实验室可以真正让你突破极限，这太糟糕了，因为这是一个非常有趣的话题。我认为你会发现自己准备好了。通常有一些小的考试问题，这些问题是基于你在旧考试中找到的一些材料。</p><p>发言人   00:53<br>But really the idea is, how can I make programs run fast given that I sort of know what algorithm I’m using? And I’ve perhaps gotten a program that runs, how can I make it run faster? And one of the themes of it is you can sort of do this in layers.<br>但实际上的想法是，考虑到我知道我在使用什么算法，我如何让程序运行得更快？我可能已经得到了一个可以运行的程序，我怎样才能让它运行得更快？其中一个主题是你可以分层完成。</p><p>发言人   01:15<br>First of all, do this stuff to avoid. Sort of things that make programs run slow across a wide variety of machines. And just, I would describe it as making your code more compiler friendly. And we’ll talk about what that means. And you have to have some understanding and appreciation for what compilers are good at and what they’re not good at to be able to do that. And I describe these, is the kind of things that you should just be in the habit of when you write programs, writing this code that I’ll describe as compiler friendly way. And then the next level is OK, given that I’ve sort of taking away the things that really shouldn’t have been there in the first place.<br>首先，做这些事情来避免。有一些事情会让程序在各种各样的机器上运行缓慢。而且，我会将其描述为使您的代码更加编译友好。我们将讨论这意味着什么。你必须对编译器擅长什么和不擅长什么有一些理解和欣赏，才能做到这一点。我描述这些，是你在编写程序时应该养成的习惯，编写这段我将描述为编译器友好的代码。然后下一个层次是可以的，因为我已经拿走了本来就不应该存在的东西。</p><p>发言人   02:03<br>Now, how can I make my programs run faster? And particular, how can I adapt it to the capabilities of the types of machines that this program is going to run on? And that can, again, go from ones that will generally make programs run fast across a wide variety of of machines to ones that become very specific. And very specific is a risky thing because even in the world of, say, x 86 machines, there’s quite a variety of them that are available at any given point in time. And they evolve over time as well. So you can make a program run really fast on one particular model of 1x 86 processor. But it might not that if you’re trying too hard, you’ll find your effort is sort of wasted when you move it to another.<br>现在，我怎样才能让我的程序运行得更快？特别是，我如何使它适应这个程序将要运行的机器类型的能力？这可能会从通常使程序在各种机器上快速运行的那些，发展到变得非常具体的那些。而且非常具体是一件冒险的事情，因为即使在x86机器的世界中，在任何给定的时间点都有相当多的可用机器。它们也随着时间的推移而演变。因此，您可以使程序在一个特定型号的1x86处理器上运行得非常快。但如果你太努力，当你把努力转移到另一个地方时，你可能会发现你的努力有点白费了。</p><p>发言人   02:52<br>On the other hand, these general ideas I’m going to describe actually work across quite a range of machines. So, and I’ll talk about that more as we go along. So it used to be in the bad old days that if you wanted a program to run fast, you had to write an assembly code. And that’s just plain not true anymore. And if anyone tells you it’s true, it’s because they’re full of it. It’s just not true unless, except for the exceptional case where you’re running on a very small resource constrained machine, such as a very small, underpowered, embedded system.<br>另一方面，我要描述的这些一般想法实际上适用于相当多的机器。所以，随着我们的进行，我会更多地谈论这个。所以过去在糟糕的日子里，如果你想让一个程序快速运行，你必须写一个汇编代码。这已经不是真的了。如果有人告诉你这是真的，那是因为他们充满了它。这不是真的，除非你在一个非常小的资源有限的机器上运行，比如一个非常小的、动力不足的嵌入式系统。</p><p>发言人   03:30<br>So let’s just assume that we’re going to use a compiler.<br>所以让我们假设我们将使用编译器。</p><p>发言人   03:32<br>And we’ll assume for this course, we’re going to use GCC because it’s generally available. It’s not actually the best compiler out there. Intel makes a compiler that costs money to license and stuff. It really can do some amazing things, and other compilers exist, but GCC is of a good enough compiler for most people. But there’s some features of showing things that sort of puzzle compilers that they don’t really understand. Compilers don’t really understand, for example, that the numbers you’re using when you say it’s an int might actually range over a much smaller set of values. And they have a very hard time understanding memory referencing patterns and the effect of procedure calls.<br>我们假设在本课程中，我们将使用GCC，因为它是普遍可用的。它实际上并不是最好的编译器。英特尔制造了一个编译器，需要花钱才能获得许可和其他东西。它确实可以做一些惊人的事情，并且存在其他编译器，但GCC对大多数人来说是一个足够好的编译器。但是有一些功能可以展示一些他们并不真正理解的谜题编译器。编译器并不真正理解，例如，当你说它是一个int时，你所使用的数字实际上可能只覆盖了一组更小的值。而且他们很难理解内存引用模式和过程调用的影响。</p><p>发言人   04:26<br>And so in general, what happens with the compiler is it has a whole sort of cookbook of optimization strategies and some recipes for how to try out different strategies and apply them. But in general, if it ever feels like this code is something that it doesn’t feel confident about being able to make certain transformations, then it just won’t. It will keep things sort of a more direct implementation of exactly what you describe. And we’ll show examples of that as we go. Go along.<br>总的来说，编译器的作用是，它有一整套优化策略的食谱，以及一些如何尝试不同策略并应用它们的食谱。但总的来说，如果感觉这段代码对能够进行某些转换没有信心，那么它就不会。它将使事情更直接地实现你所描述的内容。我们将展示这方面的例子。继续前进。</p><p>发言人   05:01<br>So the thing about optimizing compiler is it always has a fallback position, which is to not optimize. And sometimes that will get in trouble if you want your program to run faster and the compiler, just in its own conservative way, decides not to do that optimization. And one of the tricks that you’ll find is pretty useful now that you can read assembly code is you run the compiler, You see what optimizations it does. And if it doesn’t make something that you expect it to be able to do, you go back and figure it out. So it’s very common, by the way, to rewrite your program in the same language and sort of tune it and up to make it run faster, to make it more compiler friendly. There’s nothing wrong with that as long as you don’t then just totally obliterate the program and make it totally illegible.<br>所以优化编译器的问题是它总是有一个后备位置，那就是不优化。如果你想让你的程序运行得更快，有时候这会遇到麻烦，而编译器只是以自己保守的方式决定不进行优化。现在你可以阅读汇编代码，你会发现其中一个技巧非常有用，那就是运行编译器，看看它做了什么优化。如果它没有做出你期望它能够做的事情，你就回去想办法。因此，顺便说一句，用相同的语言重写程序并对其进行优化以使其运行更快，使其更加编译友好是非常常见的。只要你不这样做，那就没有什么错，只是完全抹掉这个程序，使它完全难以辨认。</p><p>发言人   05:57<br>So let’s just describe some sort of general optimizations. And you’ve actually seen versions of this in some of the assembly code we’ve already looked at. And I’ll use mostly sort of examples from multidimensional arrays, because those are actually fairly easy optimization type of tasks. But these apply to other types of program as well.<br>所以让我们描述一些一般的优化。而且你实际上已经在我们已经看过的一些汇编代码中看到了这个版本。我将主要使用多维数组的示例，因为这些实际上是相当简单的优化类型的任务。但这些也适用于其他类型的程序。</p><p>发言人   06:22<br>So you saw before when we described how to do array indexing and multidimensional arrays, that the old style of code was. If you had a variable size array, it was up to you, the programmer, to write the formula of how you convert row I, column J into a position in a one dimensional array. So remember, it’s just the number of columns times the row number plus the column number standard one, so that this would be pretty typical code. Then notation like this, if you wanted to set one row in array A to the values in one dimensional row B, this is the code you’d write. And the main observation is within this loop, the only variable that’s changing is j, and so from the array perspective, this computation n times I, if it gets repeated over and over again within this loop, then you’re just wasting, it’s a wasted effort. So you can do what’s called code motion, which is to pre compute the value of n times I outside of the loop, and then use it over and over again inside.<br>所以你之前在描述如何进行数组索引和多维数组时看到了旧的代码风格。如果您有一个可变大小的数组，那么由您这个程序员来编写如何将第I行，第J列转换为一维数组中的位置的公式。请记住，这只是列数乘以行号加上列号标准一，因此这将是非常典型的代码。然后像这样的符号，如果您想将数组A中的一行设置为一维行B中的值，这就是您要编写的代码。而主要观察结果在这个循环中，唯一变化的变量是j，因此从数组的角度来看，这个计算n次I，如果它在这个循环中反复重复，那么你只是在浪费，这是浪费的努力。所以你可以做所谓的代码运动，也就是在循环之外预先计算n次I的值，然后在内部一遍又一遍地使用它。</p><p>发言人   07:44<br>And compilers will generally do this when they can detect, for example, that it’s array access code has this technique, it will generally do optimizations like this, say an optimization level of one or higher to GCC. And we can see this. In fact, this is this code. And I ran it through GCC using optimization 1. And you see, as this red instruction shows, it boosted this multiplication outside of the loop. And it’s a little as if you actually, this code does even more. It turns the code into something that looks more like a pointer code, accessing array A and stepping through that element by element of the array.<br>当编译器能够检测到数组访问代码具有这种技术时，通常会这样做，它通常会进行这样的优化，例如对GCC的优化级别为1或更高。我们可以看到这一点。事实上，这就是这个代码。我使用优化1通过GCC运行它。你可以看到，正如这个红色指令所显示的，它在循环之外增强了这个乘法。这有点像实际上，这段代码做的更多。它将代码转换为看起来更像指针代码的东西，访问数组a并逐个元素地单步执行该数组。</p><p>发言人   08:40<br>Another one, and we’ve seen this already, that when GCC turns a multiplication or a division by shifting and adding an operations like that, multiplication or division by constants, we’ve seen examples of that. And a similar one would happen.<br>另一个例子，我们已经看到过了，当GCC通过移动和添加类似的操作来转换乘法或除法时，我们已经看到过这样的例子。类似的事情也会发生。</p><p>发言人   09:02<br>If we took that program I showed before and applied it to every row. So we wanted to set for array A, we wanted to set every one of its rows to the value of the one dimensional array B? Then again, if we took that code, we boosted the M times I in there. So now the inner loop is good, but you realize that this multiplication isn’t necessary either, because what we’re doing from I equals 0 to I equals 1 to I equals 2 is we’re just increasing the parameter ni I by we’re adding n to it so we can, and that’s called a reduction in strength. We’ve taken a multiplication and turned it into addition because there’s some predictable pattern of how this variable ni is going to be updated.<br>如果我们采用我之前展示的程序并将其应用于每一行。所以我们想为数组A设置，我们想将它的每一行设置为一维数组B的值？然后，如果我们拿走那个代码，我们就把里面的我提高了M倍。所以现在内部循环很好，但是你意识到这个乘法也不是必要的，因为我们从I等于0到I等于1到I等于2，我们只是增加参数ni，我们加了n，这样我们就可以了。这就是所谓的力量减弱。我们进行了一个乘法并将其转换为加法，因为对于这个变量ni的更新方式有一些可预测的模式。</p><p>发言人   09:57<br>Another example. And again, array indexing is a good example for optimizations. Imagine we had an image that we represent as a two-dimension array of pixel values. And we want to do something that’s filtering operation where we want to take the sum of the four neighbors of a given pixel north, southeast, and west, and average those together or sum them together.<br>另一个例子。再次强调，数组索引是优化的一个很好的例子。想象一下，我们有一个图像，我们将其表示为像素值的二维数组。我们想要做一些过滤操作，我们想要将给定像素的四个邻居的总和分别取为北、东南和西部，然后将它们平均在一起或相加。</p><p>发言人   10:28<br>And so the natural way you’d write this in C is to say, I want usually in images you count from the top down, you’d say this is the pixel above, this is the pixel below, this is the pixel to the left, and this is the pixel to the right. And if you do this, and just compile it straight through, unfortunately, it appears as if there’s three different multiplications by n I -1 I plus 1, and I, and if the compiler isn’t too clever, it won’t realize that these are related to each other. And it will issue three different multiply operations just to do this 1 pixel thing. Whereas if I’m a little more clever, and this is one where I manually rewrote the code, so the compiler would pick it up. I’d say, well, if so, inj is I times n plus j, and I can get the pixel above the pixel below by shifting that, offsetting that by value of n? And then it will issue the code. This will compile with the code with just one multiplier.<br>所以你用C写这个的自然方式是说，我通常想在你从上到下计数的图像中，你可以说这是上面的像素，这是下面的像素，这是左边的像素，这是右边的像素。如果你这样做，并直接编译它，不幸的是，似乎有三个不同的乘法n I -1 I加1和I，如果编译器不太聪明，它不会意识到这些是相互关联的。它将发出三个不同的乘法操作来完成这个1像素的事情。然而，如果我更聪明一点，这是我手动重写代码的地方，这样编译器就会把它捡起来。我会说，如果是这样，inj是I乘以n加上j，我可以通过移动它来获得下面像素上方的像素，并通过n的值来抵消它？然后它会发布代码。这将使用只有一个乘数的代码进行编译。</p><p>发言人   11:47<br>In general, by the way, multiply used to be a very expensive instruction. Nowadays, there’s enough hardware resources that it takes about three coul cycles, so it’s not a huge deal, but anytime you can take three multiplies and use just one instead, that’s generally a good idea question.<br>顺便说一下，通常乘法指令非常昂贵。如今，有足够的硬件资源需要大约三个周期，所以这不是一个大问题，但任何时候你可以使用三个乘法只使用一个，这通常是一个好主意。</p><p>发言人   12:09<br>So the question is, what if you’re trying to optimize for space? And there are a lot of optimizations that will make your code be bigger at the expense of in order to go faster, right? This one though I’d argue this is actually shorter code, right? Just look at the number of instructions and usually so code that used to be a bigger concern when memory was sort of back. The original IBM PC had 640 kB of memory in its maximum configuration. And that was a big deal to actually buy it that much. So know back then that was a big deal memory. But nowadays memory, the size of the program is usually a pretty small fraction of what you’re dealing with overall.<br>所以问题是，如果你试图优化空间怎么办？并且有很多优化可以让你的代码变得更大，代价是为了变得更快，对吧？我认为这实际上是更短的代码，对吧？只需看一下指令的数量，通常是代码的数量，这些代码在内存不足时曾经是一个更大的问题。最初的IBM PC在其最大配置中有640 kB的内存。实际上买那么多是一件大事。所以知道当时那是一个很重要的记忆。但是现在的内存，程序的大小通常只占你处理的整体的一小部分。</p><p>发言人   12:53<br>But it’s a valid question. Okay, so that just shows you an example. And in general, compilers are pretty good at doing those low level optimizations like that. If you write the code in a way that’s reasonable. But there’s some other ones that the compiler and even the fanciest compiler you can buy might not be able to figure it out.<br>但这是一个有效的问题。好的，这只是给你一个例子。一般来说，编译器非常擅长做那些低级优化。如果你以合理的方式编写代码。但是还有一些其他的编译器，即使是你能买到的最高档的编译器也可能无法解决。</p><p>发言人   13:17<br>So I like to illustrate this with when the first term we ever taught, 213, I was looking at some lab. Code that some of the students wrote. And I was horrified about this code. And I showed it to the Tas, and none of them figured out what was wrong. And I’ve shown it to many other highly trained C programmers, professionals, and they go, looks okay to me. So let’s figure out why I was horrified by this code.<br>所以我想用我们教的第一学期213时看的一些实验室来说明这一点。一些学生写的代码。我对这段代码感到震惊。我把它给那些学生看了，但他们都没有弄清楚哪里出了问题。我已经向许多其他训练有素的C语言程序员、专业人士展示了它，他们看起来还可以。那么让我们弄清楚为什么我被这段代码吓坏了。</p><p>发言人   13:46<br>So the idea of this code is supposed to be pretty straightforward.<br>因此，这段代码的思想应该非常简单明了。</p><p>发言人   13:49<br>There’s a string S, and I want to convert that string all the characters in to lowercase. So I’m just going to read through this string, and for each string position, test that character. And if it’s somewhere between uppercase A and uppercase Z, then I’m going to shift it to being between lowercase a and lowercase z, otherwise I won’t change it. So pretty straightforward. But if you run this, you see that if you go up to half a million characters, which might sound like a lot, but it takes 240 or so, so four minutes to run this code, and you go, well, that’s a pretty big string.<br>有一个字符串S，我想将该字符串所有字符转换为小写。所以我只是要通读这个字符串，并针对每个字符串位置测试该字符。如果它在大写字母A和大写字母Z之间，那么我要将其转换为小写字母a和小写字母z之间，否则我不会更改它。那么简单。但是如果你运行这个代码，你会发现如果你达到五十万个字符，这听起来可能很多，但需要240个左右，所以运行这个代码需要四分钟，你会发现这是一个相当大的字符串。</p><p>发言人   14:38<br>It’s really not a big string. You should be able to do lowercase conversion of a string in a lot less than 4 seconds. And you also notice this growth is non-linear, it’s quadratic, it’s growing as the square of the string light. So this is not good, and unfortunately, it’s the kind, and by the way this is one of is very easy, surprisingly easy, have programs, have some hidden performance bug that makes them run quadratic, and you run tests and you test for strings of 10000 or less.<br>这真的不是一根大绳子。你应该能够在不到4秒的时间内完成字符串的小写转换。你也会注意到这种增长是非线性的，它是二次的，它增长为灯串的平方。所以这不好，而且不幸的是，顺便说一下，这是非常简单的，令人惊讶的是，有一个程序，有一些隐藏的性能错误，使它们运行二次，你运行测试并测试10000或更少的字符串。</p><p>发言人   15:12<br>And it doesn’t look like a big deal because the runtime is insignificant, but then all of a sudden it hits a really bad case. There’s something wrong here. So what’s so bad about this program? The key is in a test like this of calling Stewy. So the way it’s determining whether it’s reached the end of the string is by calling Stern one to figure out how long the string is.<br>这看起来没什么大不了的，因为运行时是无关紧要的，但突然间它遇到了一个非常糟糕的情况。这里有些不对劲。那么这个项目有什么不好呢？关键在于像调用Stewy这样的测试。因此，确定它是否到达字符串的末尾的方法是调用斯特恩来确定字符串的长度。</p><p>发言人   15:48<br>Now, and remember, if we do the conversion of a for loop into a go to form, like you’ve seen, there’s various ways to convert it, but all of them the gets built into the loop. So the main feature of that is this call to Stirling will happen every time you go through the loop. And people overlook that fact. When you look at the different parts of a for loop, the initialization only gets executed once. But both the test and the update get incremented, get applied every time you run through the loop. So that’s getting called as many times as there are characters in the loop in the string.<br>现在，请记住，如果我们将for循环转换为go形式，就像您看到的那样，有各种方法可以将其转换，但所有方法都内置在循环中。因此，其主要特征是每次您通过循环时都会发生对斯特林的呼叫。人们忽视了这个事实。当您查看for循环的不同部分时，初始化只执行一次。但是测试和更新都会递增，每次运行循环时都会应用。因此，只要字符串中的循环中有字符，就会调用它。</p><p>发言人   16:38<br>And now how does st-line work, remember and C, the only way you know how long a string is, is to step through the whole thing and find the null character at the end. So stern land itself is a linear time operation in the string, and you’re doing that. And so you’re doing n calls to a function that takes time n, the string is getting shorter as you go, but not very fast. So basically, that’s quadratic performance. And that explains why you get that runtime.<br>现在，st-line是如何工作的，记住C，你知道一个字符串有多长的唯一方法是逐步遍历整个过程并找到结尾的空字符。所以斯特恩土地本身是字符串中的线性时间操作，而你正在这样做。所以你正在对一个需要时间的函数进行n次调用，字符串随着时间的推移变得越来越短，但不是很快。基本上，这就是二次性能。这就解释了为什么你会得到那个运行时。</p><p>发言人   17:14<br>So in particular, if I just make the following little change, I introduced a local variable called Glenn, and I precompute stir 1, because the string, the length of the string isn’t changing. I’m just changing the characters in the string. Then so the program will do the same thing, but now the runtime is so short, it doesn’t even show up. Maybe a second to do a million characters. It’s just not a big deal at all, as it should be. It’s just running through. And so that’s just an example, one of many that I’ve seen in my career, where something that seems almost insignificant turns out to be a serious performance problem.<br>因此，特别是，如果我只是进行以下小更改，我引入了一个名为Glenn的局部变量，并且我预先计算了搅拌1，因为字符串的长度不会改变。我只是在改变字符串中的字符。那么程序也会做同样的事情，但是现在运行时间太短了，甚至没有显示出来。也许一秒钟就可以写一百万个字符。这根本没什么大不了的，应该是这样。它只是通过跑步。这只是一个例子，我在职业生涯中看到的许多例子之一，一些看似几乎无关紧要的事情却变成了严重的性能问题。</p><p>发言人   18:04<br>So why couldn’t a compiler figure this out? Why couldn’t a smart compiler? Look at the original code and say? This is what the programmer wrote, but I know a better way to do it. I’ll precompute Stewie in advance.<br>那么为什么编译器不能解决这个问题呢？为什么不能有一个聪明的编译器？查看原始代码并说？这是程序员写的，但我知道更好的方法。我会提前计算好Stewie。</p><p>发言人   18:28<br>Well, there’s a couple of reasons. One is actually, if you look at the code for Sterling, you see that it’s actually modifying the string, and I mean, the code here is modifying the string and we’re calling string land on it. You’d have to be pretty careful to do the analysis, the compiler would, to figure out that even though the string is changing, the result you’re going to get from St 1 is not going to change. So that’s. One reason.<br>有几个原因。一个实际上是，如果你看一下英镑的代码，你会发现它实际上在修改字符串，我的意思是，这里的代码正在修改字符串，我们正在调用字符串。你必须非常小心地进行分析，编译器会，要弄清楚即使字符串在变化，你从St 1得到的结果也不会改变。就是这样。一个原因。</p><p>发言人   19:05<br>And the second is, well, and how? Can the be which version of Sterling is actually going to get used? You remember and see each of the files gets compiled separately and only afterwards does it all get brought together in the linking phase. And some of that even happens after the program gets started. So even though there’s a standard Stern L function, it’s not necessarily the case that that’s the one that will actually get used in the final program. So the compiler really can’t be sure of that.<br>第二个问题是，好吧，怎么做？哪个版本的英镑实际上会被使用吗？你会记得并看到每个文件都被单独编译，只有之后它们才会在链接阶段全部汇集在一起。其中一些甚至发生在程序启动后。因此，即使有一个标准的斯特恩L函数，也不一定是最终程序中实际使用的函数。编译器真的无法确定这一点。</p><p>发言人   19:42<br>In particular, imagine I provided a sort of customized sterling function like this that is keeping track of the sum of the lengths of all the strings that it’s been called on, or some other side effect like that. That program would produce a very different result than if whether or not I make the optimization. The compiler has to assume that Sterling is just a black box that does whatever it does and can’t make any assumptions about what side effects it might have and so forth. So it won’t make that optimization on any machine, even with the best compiler.<br>特别是，想象一下我提供了一种像这样的自定义英镑函数，它可以跟踪所有被调用的字符串的长度总和，或者其他类似的副作用。该程序将产生与我是否进行优化完全不同的结果。编译器必须假设英镑只是一个黑盒子，无论它做什么都不能做任何假设它可能有什么副作用等等。因此，即使使用最好的编译器，它也不会在任何机器上进行优化。</p><p>发言人   20:28<br>So that’s just an example. And you can tell that I’ve gotten kind of sensitized to this so that I spot these. But a lot of people don’t. So let’s look at this.<br>这只是一个例子。你可以看出我对这个有点敏感，所以我发现了这些。但很多人并没有。让我们来看看这个。</p><p>发言人   20:45<br>Let’s see, am I looking at now? Oh, this is another bad example, a bad coding example of imagine I want to compute for a two dimensional array A in a one dimensional array B, I want to make b sub I be the sum of all the elements in rho I of of A, so again, this is a fairly obvious kind of way to write this program that you say, well, b, I 0, and I’m going to just c, I’ll step through the row and accumulate all the values. And of course, we know now we could improve this by moving I times n out and so forth. I’m not trying to illustrate that, but what you’ll see in the program this is in the inner loop.<br>让我们看看，我现在在看吗？哦，这是另一个糟糕的例子，一个糟糕的编码例子，想象我想在一维数组B中计算二维数组a，我想使b sub I成为a的rho I中所有元素的总和，所以再次，这是一种相当明显的编写程序的方法，你说，嗯，b，I 0，而我只需要c，我将逐步遍历行并累积所有值。当然，我们现在知道我们可以通过将I乘以n等方式来改进这一点。我并不是想说明这一点，但你将在程序中看到的是内循环。</p><p>发言人   21:41<br>And we’ve looked briefly at some floating point instructions. And remember, the main feature of them is the move instructions look like the move ones you’re familiar with, except when we put floating point data in one of these Xmm registers. So the main thing you see here is it’s reading from memory, it’s adding something to it, and then it’s writing back to memory. And what that memory location corresponds to B of I, so what it means is every time through this loop, it’s having to do a memory read and a memory write of B in addition to the memory read of A, even though presumably B of I is the same value that you just updated it to in the previous execution of this loop. So why do you write it out and then read it back in, increment it, and then again, copy it back out?<br>我们简要地看了一些浮点指令。请记住，它们的主要特点是移动指令看起来像您熟悉的移动指令，除非我们将浮点数据放入这些Xmm寄存器之一。所以你在这里看到的主要是它从记忆中读取，向其中添加内容，然后写回记忆。并且该内存位置对应于I的面向企业，因此它的意思是每次通过此循环时，除了读取a的内存之外，还必须执行B的内存读取和内存写入，即使假定I的B值与您在此循环的上次执行中更新它的值相同。那么为什么你要把它写出来，然后读回来，递增，然后再复制回来？</p><p>发言人   22:43<br>Why does it have to go keep jumping back and forth between memory and registers over and over again? Well, the reason is because in C, you can’t be sure that there isn’t what’s known as aliasing, and I’m demonstrating it here.<br>为什么它必须一遍又一遍地在内存和寄存器之间来回跳跃？嗯，原因是因为在C中，你不能确定没有所谓的别名，我在这里演示它。</p><p>发言人   22:59<br>Imagine if RBIs just declared to be okay. So imagine, and you can do this in C, this is legal C code. You can make one memory data structure over and away another data structure that’s referred to as aliasing two sort of separate parts of the program are referring to the same locations in memory, and the C compiler has no way of knowing whether there’s a lot of work in optimizing compilers to detect Alyson possibilities. But in general, it has to assume Alia thing might happen. So imagine this aliasing happened. Array B corresponds then to this row of array A. Then of course, its initial value is 4, 8, 16. But if you trace to what this code will do has a sort of odd behavior that is probably not useful for anything, But it just demonstrates that what will happen is as.<br>想象一下，如果RBIs刚刚宣布正常。想象一下，你可以在C中做到这一点，这是合法的C代码。你可以将一个内存数据结构重复成另一个数据结构，称为别名，程序的两个独立部分都引用了内存中的相同位置，而C编译器无法知道在优化编译器以检测概率方面是否有很多工作。但总的来说，它必须假设事情可能会发生。所以想象一下这个别名发生了。然后，数组B对应于数组A的这一行。当然，它的初始值是4、8、16。但是，如果你追溯到这段代码将要做的事情，它会有一些奇怪的行为，可能对任何事情都没有用，但它只是表明将要发生的事情是这样的。</p><p>发言人   24:09<br>B gets updated. It’s effectively changing A, and it’s changing then what’s being read during the summation. And so this is a real possibility in C, and so the compiler, when it’s given code like this, it has to assume that these two memory locations might overlap each other. So that’s why it’s carefully writing it out and then reading it back in over and over again.<br>B得到更新。它有效地改变了A，并且它正在改变求和期间所读取的内容。因此，这在C语言中是真实存在的，因此编译器在给出这样的代码时，必须假设这两个内存位置可能相互重叠。所以这就是为什么它仔细地把它写出来，然后一遍又一遍地读回来。</p><p>发言人   24:42<br>And so if I just rewrite this code by introducing, again, a local variable and accumulating in that local variable, and then only at the end do I assign that to B sub, I then you’ll see this exact same loop all of a sudden gets a lot simpler read, quoting, point read, and add to do that. And we’ll see, in fact, the memory. It is actually one of the limiting performance limiters in a program. So this is will be significantly faster. And again, that’s something that you as a programmer would hardly think is a big deal, but the C compiler can’t do that in general, because it can’t determine in advance, what possible aliasing there can be.<br>因此，如果我只是通过再次引入一个局部变量并累积该局部变量来重写这段代码，然后只有在最后才分配该面向企业子变量，那么你会看到这个完全相同的循环突然变得简单了很多，引用，指向读取，并添加来做这件事。事实上，我们会看到记忆。它实际上是程序中限制性能的因素之一。因此，这将显著加快。再说一遍，作为一名程序员，你几乎不会认为这是一个大问题，但C编译器通常无法做到这一点，因为它无法事先确定可能存在的别名。</p><p>发言人   25:36<br>So as these two examples say, sort of get in the habit of introducing local variables and using them. And it’s your way of telling the compiler, don’t call the same function over and over again. Don’t read and write the same memory location over and over again. Hold it in a temporary one, and then it will automatically allocate a register and store it in that register and everything will be good.<br>就像这两个例子所说的，要养成引入局部变量并使用它们的习惯。这是你告诉编译器不要一遍又一遍地调用同一个函数的方式。不要一遍又一遍地读写同一个内存位置。将其保存在临时寄存器中，然后它会自动分配寄存器并将其存储在该寄存器中，一切都会很好。</p><p>发言人   26:02<br>Okay, so that’s sort of the. What we call optimization blockers, the kind of things that you as a programmer can make a difference on. And the main blockers are memory referencing, aliasing, and function calls, and sort of understanding what might happen in that function call. So now what we’re going to do is transition question. So, two great questions.<br>好的，就是这样。我们称之为优化拦截器，作为一名程序员，你可以在这些事情上做出改变。主要的阻滞剂是内存引用、别名和函数调用，以及理解该函数调用中可能发生的事情。所以现在我们要做的是过渡问题。所以，有两个很好的问题。</p><p>发言人   26:30<br>So on the, memory areas inside, there’s this declaration of. Of array of size 3 equals a plus 3. This doesn’t quite seem to be. I think C still makes a distinction between array and no, no, this is all C code. I’m sure this is valid C code because it ran.<br>因此，在里面的内存区域上，有这样的声明。大小为3的数组等于加号3。这似乎并不完全是这样。我认为C仍然区分了数组和no，no，这都是C代码。我确信这是有效的C代码，因为它运行了。</p><p>发言人   27:02<br>This is initializing, calling it an array B, remember, these are stars. These aren’t two dimensional arrays, right? So this is saying A is now think of it as a. Linear array of four elements, of 9 elements. And a plus 3 is just to go in three. So it is declaring b is not a pointer, it’s an array. But remember, with an array, you can use the name of that array as a reference to a pointer, a readable reference, not a writable reference.<br>这是初始化，称其为数组B，记住，这些是星星。这些不是二维数组，对吧？所以这就是说A现在可以把它看作a。四个元素的线性阵列，9个元素。加3就是进去三个。所以它声明b不是指针，它是一个数组。但请记住，对于数组，您可以使用该数组的名称作为对指针的引用，这是一个可读的引用，而不是可写的引用。</p><p>发言人   27:46<br>Really for this exact code, well I’ll double check it. And also like a few years before.<br>对于这个确切的代码，我会仔细检查。就像几年前一样。</p><p>发言人   28:00<br>This design of C programming language used multi related strings instead of hascosay. So the question is why does C use null terminated strings? And it does, and it might be a bad decision for multiple reasons, right?<br>这种C编程语言的设计使用多个相关字符串而不是hascosay。所以问题是为什么C使用以null结尾的字符串？确实如此，出于多种原因，这可能是一个错误的决定，对吧？</p><p>发言人   28:16<br>I think in general, think of C was somebody who had or a couple of people who had been writing a lot of assembly code and wanted to lift up that level. So they weren’t writing the same stuff over and over again, but not thinking in terms of how can I be the most abstract possible? So they were trying to provide sort of a minimum layer on top of machine level programming that would let them write code that could run from one machine to another. So in everything they do, they sort of use the most simple representation and don’t assume kind of there’s no array. Most languages would have array bounds checking, and array would be a data structure that would include its size range of values and stuff. C just doesn’t. So everything about C is sort of the minimum, and so it’s been around for 40 or something years.<br>我认为总的来说，C是一个拥有或几个一直在编写大量汇编代码并想要提升那个层次的人。所以他们没有一遍又一遍地写同样的东西，却没有思考如何成为最抽象的人？所以他们试图在机器级别编程之上提供一种最小层，让他们编写可以从一台机器运行到另一台机器的代码。所以在他们所做的一切中，他们使用最简单的表示，并不假设没有数组。大多数语言都会进行数组边界检查，而数组将是一种数据结构，包括其值和内容的大小范围。C就是没有。所以关于C的一切都是最低限度的，所以它已经存在了40年左右。</p><p>发言人   29:22<br>No Pascal does not precede C, no, that’s simply not true. Pascal was created as a language for teaching by this fellow named nicos Vert, and it was very much an instructional language. So it was really designed to help students who needed help. And C was designed by professional programmers to let them write their code and not get in their way. So they’re very different theory between the two languages, yes.<br>没有帕斯卡不先于C，不，那根本不是真的。Pascal是一种教学语言，由一个名叫nicos Vert的家伙创造的，它在很大程度上是一种教学语言。所以它真正的目的是帮助需要帮助的学生。而C是由专业程序员设计的，让他们编写自己的代码，而不会妨碍他们。所以它们是两种语言之间非常不同的理论，是的。</p><p>发言人   30:04<br>What’s that?<br>那是什么？</p><p>发言人   30:09<br>I’m sorry, oh, yes, that’s a mistake there. I’ll double check this or people could check it. I’m pretty sure this code is okay though. If not, you could certainly say double star B equals a plus 3. And that would work, right?<br>对不起，是的，那是个错误。我会仔细检查，否则人们可以检查。不过我很确定这段代码没问题。如果没有，你当然可以说双星B等于a加3。那会起作用的，对吧？</p><p>发言人   30:37<br>You think what? You think this is 28? Well I’m not going to try and hand execute it here, but you and I will check this code out and we’ll fix it if it needs to be fixed.<br>你觉得呢？你觉得这是28吗？我不会尝试在这里手动执行它，但你和我会检查此代码，如果需要修复，我们会修复它。</p><p>发言人   30:53<br>Okay, thanks for pointing it out. When you do this, the array get stack allocated as a local AR. No, that doesn’t make any difference at all in this code. No, no, where it’s allocated makes no difference at all here. So I’ll check that might have to be double star B equals a plus 3. This was a while ago that I wrote this code. I’ll double check it though. Okay, so. Anyways, that’s the sort of end of the story for simple, and they are simple optimizations. It’s just you have to get in the habit of doing it.<br>好的，谢谢你指出来。当你这样做时，数组会被分配为本地AR的堆栈。不，这在这段代码中根本没有任何区别。不，不，分配在哪里根本没有区别。所以我会检查一下，可能必须是双星B等于a加3。这段代码是我写的。不过我会仔细检查的。好的，所以。无论如何，这就是简单故事的结局，它们是简单的优化。这只是你必须养成这样做的习惯。</p><p>发言人   31:40<br>Okay, now what we’re going to do is go a little bit fancier than this. And as I said, this becomes somewhat more system dependent. And but pretty much nowadays, all processors have similar implementation. They all do what’s known as is out of order execution, except for the most primitive microcontrollers. And so this is the kind of optimization I’ll show you’ll find. This general approach will work across quite a variety of machines. So what I’m going to do is do this by a series of examples starting from some not very efficient code and making it run faster and faster. And we’ll get speed up of around 40 just in doing what we’re doing.<br>好的，现在我们要做的是比这更华丽一点。正如我所说，这变得更加依赖系统。而且几乎现在，所有处理器都有类似的实现。它们都做所谓的无顺序执行，除了最原始的微控制器。所以这就是我将向您展示的优化类型。这种通用方法将适用于相当多的机器。所以我要做的是通过一系列示例来实现这一点，从一些不是非常有效的代码开始，并使其运行得越来越快。并且我们将在做我们正在做的事情中获得大约40的速度。</p><p>发言人   32:30<br>So I’ll start by saying, well, assume I have a data structure that looks like the way Pascal implements arrays. Sorry, I have nothing against Pascal. We used to teach it back in the old days. But so a typical way you’d implemented an array in a language is you’d provide both the values that are stored in that array, and then there’d be other information associated with it, for example, what size it is. And so this is the sort of nice abstract way to do that. And you write code, Make sure that if you ever try to exceed the bounds on the array, you’d return an error signal. And so this particular function you’re seeing is when I want to retrieve an element, I pass a pointer, and then value. The pointer gets used to retrieve the value from the array, and the return value of this function is then just 0 or 1, 0 meaning failure and one meaning success.<br>所以我将开始说，假设我有一个看起来像Pascal实现数组的数据结构。抱歉，我并不反对帕斯卡。我们过去常常教它。但是，用一种语言实现数组的典型方法是提供存储在该数组中的值，然后还有其他与之相关的信息，例如，它的大小。所以这是一种很好的抽象方式。并且在编写代码时，确保如果您试图超出数组的边界，将返回错误信号。所以你看到的这个特定函数是当我想检索一个元素时，我传递一个指针，然后赋值。指针用于从数组中检索值，此函数的返回值为0或1，0表示失败，一个表示成功。</p><p>发言人   33:38<br>And I’m writing it in this way that I use a data type. I’ll call data underscore t, and that way I can compile this code using different definitions of data underscore t to get ins long floats and doubles, and we’ll see how the performance characteristics of those shift with the different data types. And the benchmark I’m going to use is a fairly simple one. It’s just to, for a, an array, one of these vector is I just want to combine all the elements of it, either compute their sum or their product. And again I’m going to use macros here, identical up and define those. So the opposite addition and the identity value is 0, or the Op is multiplication, and the identity element is one, so that I can compare addition and multiplication. So that gives us sort of 8 possibilities here, two different operations in four different data types. And so this is written in the sort of the most straightforward manner that I’m using this function called get vec element to retrieve the successive values of this array and then performing this operation on it.<br>我以这种方式编写它，我使用一种数据类型。我将调用数据下划线t，这样我就可以使用不同的数据下划线t定义来编译此代码，以获取ins长的浮点数和双精度值，我们将看到这些性能特征如何随不同的数据类型而变化。我要使用的基准相当简单。这只是一个数组，其中一个向量只是我想组合它的所有元素，要么计算它们的和，要么计算它们的乘积。我将再次在这里使用宏，将它们相同并定义。因此，相反的加法和单位值为0，或者Op是乘法，单位元素是一，这样我就可以比较加法和乘法。所以这给了我们8种可能性，四种不同的数据类型中的两种不同操作。因此，这是以最直接的方式编写的，我使用这个名为get vec element的函数来检索此数组的连续值，然后对其执行此操作。</p><p>发言人   34:59<br>So now to express performance of this, we’re going to use a metric I introduced called CPE, which stands for cycles per element.<br>所以现在为了表达这个性能，我们将使用我引入的一个指标，叫做CPE，它代表每个元素的周期。</p><p>发言人   35:13<br>And the idea is that usually when you write code that say steps through a vector, anything that has sort of some linear performance as you get bigger, you don’t really want to know for exactly, it takes this many seconds or or microseconds or nanoseconds to do an operation. You kind of want to know often more what’s its overall performance characteristics? And also, it turns out when you’re doing low level of code optimization, it’s much more useful to think in terms of clock cycles of the inner clock of the processor rather than an absolute term such as nanoseconds.<br>这个想法是，通常当你编写代码说通过向量的步骤时，随着规模的增长，任何具有某种线性性能的东西，你并不真的想知道确切的情况，需要这么多秒、微秒或纳秒才能完成一个操作。你有点想知道更多它的整体性能特征是什么？而且，事实证明，当您进行低水平的代码优化时，以处理器内部时钟的时钟周期来考虑比以纳秒为绝对术语更有用。</p><p>发言人   35:50<br>Because whether a processor is running at 2 GHz or 2.3 GHz, I don’t really, I have no control over that as a programmer. But I can control sort of at the low level how many clock cycles are being used for different parts of the computation. So that’s why it’s called cycles per element. And you can think of it as, and this shows some actual measurements, but typically a function like this, what I showed the combined will have some overhead fixed amount that’s associated with setting up the loop, doing the top level call, and all that stuff, and then some component that’s linear in the size. And so what I want to know is the slope of that linear component. And will determine, that’s what I’ll call the cycle element. You can think of the scope as the sort of incremental cost of adding one more element to the array.<br>因为无论处理器是在2 ghz还是2.3ghz下运行，我真的不知道，作为一名程序员，我无法控制这一点。但我可以在低级控制用于不同计算部分的时钟周期数。这就是为什么它被称为每个元素的循环。你可以把它想象为，这显示了一些实际的测量，但通常是这样的函数，我展示的组合将有一些固定的开销，这与设置循环、进行顶级调用以及所有这些相关，然后是一些尺寸为线性的组件。所以我想知道的是那个线性分量的斜率。并且将确定，这就是我所说的循环元素。您可以将范围视为向数组中添加一个元素的增量成本。</p><p>发言人   36:56<br>So now if I run this function I showed you, and I’m only showing mostly only show 4 results because it turns out whether it’s Intel or long or float or double is not going to actually have any effect on performance for most of the cases. So if I just run this code through a compiler and don’t do any optimizations, it takes around 20 cycles per element. And if I turn on optimization level 1, which is sort of the first serious optimization, it takes the time in half.<br>所以现在，如果我运行向你展示的这个函数，我只显示了大部分只显示4个结果，因为事实证明，在大多数情况下，它是英特尔还是long，float或double实际上对性能没有任何影响。因此，如果我只是通过编译器运行此代码而不进行任何优化，则每个元素大约需要20个周期。如果我打开优化级别1，这是第一次认真的优化，它需要一半的时间。</p><p>发言人   37:31<br>I’m down to 10 clock cycles per element just by changing the compilation. And that’s using the most unoptimized code I could think of here. And then I won’t go through it all, but using sort of the kind of things I described earlier of sort of cut away some of the redundancy in this program.<br>只需更改编译，我就可以将每个元素的时钟周期降低到10个。这使用了我能想到的最未经优化的代码。然后我不会全部讲述，但是使用我之前描述的那种东西可以减少这个程序中的一些冗余。</p><p>发言人   37:56<br>You can get it down to something a little bit simpler. And so one thing, instead of you saw before I was making a call to this get vec element. And every time it did that, it went bounds checking. And it’s kind of silly to keep bounds checking the same array over and over again. When I stepping I’m using its length as the determinant of how many elements to access. So if I’m willing to sort of forego bounds checking, what I can do is introduce a function that will just give me the actual data storage part of this vector and skip over all the other stuff. And so I can write a loop, and I introduce local variables and all the kind of things we described and accumulate in temporaries and things like that. Then the program actually gets a lot faster.<br>你可以把它简化为简单一点的东西。所以有一件事，而不是你在我打电话给这个get vec元素之前看到的。每次这样做，它都会进行边界检查。不断地对同一个数组进行边界检查是一种愚蠢的行为。当我步进时，我使用它的长度作为要访问的元素数量的决定因素。所以，如果我愿意放弃边界检查，我可以做的是引入一个函数，该函数将只给我这个向量的实际数据存储部分，并跳过所有其他内容。所以我可以写一个循环，并引入局部变量和我们描述的所有东西，并在临时变量中累积和类似的东西。那么程序实际上会变得更快。</p><p>发言人   38:48<br>Again, everything from here out is optimization level 1. And so it drops it down to a little over a CAQ cycle for integers addition or three clock cycles up to five clock cycles for double precision multiple. So that’s pretty good. Definitely improve things.<br>再说一遍，从这里开始的一切都是优化级别1。因此，它将整数加法的时钟周期降至一个稍多的CAQ周期，双精度倍数的时钟周期降至三个时钟周期，最多为五个时钟周期。所以这相当不错。肯定会改善情况。</p><p>发言人   39:09<br>But the question is, well, is that the best there is first and well, so try to understand what is it about these numbers 3, 5? And this seems to be something close to 1.25. So where are those numbers coming from? And does that indicate some fundamental limitation in my program? Well, in order to do that, you have to have some understanding of the underlying hardware. And there’s a really good course you can take.<br>但问题是，最好的是先有最好的，所以试着理解这些数字3，5的原因是什么？这似乎接近1.25。那么这些数字是从哪里来的呢？这是否表明我的程序存在一些基本限制？为了做到这一点，你必须对底层硬件有一些了解。你可以学一门非常好的课程。</p><p>发言人   39:37<br>I think it’s called ECE 741, that will tell you everything you ever could imagine wanting to know about processor design. And you actually design processors like this. But I’m assuming you’re not going to do that for a while because you have 7 prerequisites to do before that happens. So let me just give you the simple version.<br>我认为它叫做ECE 741，它会告诉你所有你能想象到的想要了解的处理器设计的东西。你实际上是这样设计处理器的。但我假设你暂时不会这样做，因为在这种情况发生之前你有7个先决条件要做。所以让我给你简单的版本。</p><p>发言人   40:02<br>And this is sort of an idea of what a processor has looked like since about 1995. So this is old stuff, but it’s actually, to really understand it, it’s so hard. It’s really the details, pretty massive, and so it’s not even taught, for example, 447 is the ECE is the computer architecture course, and they don’t really go into this kind of design here because they’re actually hard to design on your own.<br>这有点像自1995年以来处理器的样子。所以这是旧东西，但实际上，要真正理解它是如此困难。这真的是细节，相当庞大，所以甚至没有教，例如，447是计算机体系结构课程，他们在这里并没有真正进入这种设计，因为他们实际上很难自己设计。</p><p>发言人   40:32<br>But the basic idea is you think about a program is the computer just reads in an instruction, does whatever it says to do, reads in another instruction, does what that says to do, And that has nothing to do with how programs actually execute. What they’ve built up is this massive hardware infrastructure to make a program run way faster than it would if it were just doing one instruction at a time. And it employs a technique that’s called super scalar out of order execution.<br>但基本的想法是，你认为一个程序是，计算机只是读入一条指令，做它说要做的事情，读入另一条指令，做它说要做的事情，这与程序实际执行的方式无关。他们建立了这个庞大的硬件基础设施，使程序比一次只执行一条指令运行更快。并且它采用了一种称为超级标量不按顺序执行的技术。</p><p>发言人   41:06<br>And the idea is, roughly speaking, it takes your program. If you think of your program as a linear sequence of instructions, and it just sucks in as many of those as it can. And it pulls it apart to realize that certain operations don’t really depend on each other. So I can start one, even though it’s later in the program than the one I’m working on right now, because they’re independent of each other. And it’s extracting what they call instruction level parallelism, andism places where even though your program is a linear sequence of instruction buried in there is actually a sort of forest of different computations that need to be done, some of which depend on each other and some of which don’t. And then it has a bunch of hardware. And so that’s up here.<br>这个想法是，粗略地说，它需要你的程序。如果你把你的程序看作是一个线性的指令序列，并且它会尽可能多地吸收这些指令。它将它拆开，意识到某些操作实际上并不相互依赖。所以我可以开始一个，即使它在程序中的时间比我现在正在处理的要晚，因为它们彼此独立。它正在提取他们所谓的指令级并行，即使你的程序是埋藏在其中的线性指令序列，实际上还是需要完成一种不同计算的森林，其中一些相互依赖，一些不相互依赖。然后它有一堆硬件。所以就在这里。</p><p>发言人   41:54<br>This upper part shows this idea of of fetching instruction. So there’s a CA memory, a high speed local memory that is just pulling in your instructions as fast as it can. And those instructions are then feeding a big pile of hardware that will extract out of it these low level operations and figure out which ones depend on which others. And then there is a set of a functional units in this part of it that are able to perform these low level operations, to do arithmetic, floating point operations, to read data from memory, to stored data back to memory, all using a cache, which is something you’re going to learn about fairly soon. What all this cache is, but think of this as a high speed copy of some of the data memory. And so what this logic tries to do is keep forking out, spawning off operations based on your program and keeping these as busy as they can be, doing different fragments of your code, doing different instructions in a different order from before.<br>这个上部展示了获取指令的想法。所以有一个CA内存，一个高速的本地内存，它可以尽可能快地提取你的指令。然后，这些指令会提供一大堆硬件，这些硬件将从中提取这些低级操作，并找出哪些操作依赖于其他操作。然后在这部分有一组功能单元，它们能够执行这些低级操作，进行算术、浮点操作，从内存读取数据，将数据存储回内存，所有这些都使用缓存。这是你很快就会学到的东西。所有这些缓存是什么，但请将其视为一些数据内存的高速副本。因此，这个逻辑试图做的是保持分叉，产生基于你的程序的操作，并让这些操作尽可能繁忙，执行不同的代码片段，以不同的顺序执行不同的指令。</p><p>发言人   43:14<br>And it turns out you think of a register as a, the set of registers as a part of memory that get read and written. It turns out that in executing a register now just becomes the name of something that one instruction produces and some other instructions consume. It’s a destination for some, it’s a source for others. And this whole bunch of stuff here just sort of magically passes the results of one computation, the input to another computation based on register names, without ever storing them in explicit register file. There is a register file. When things kind of settle down, they get stored away.<br>而事实证明，你把一个寄存器想象成一个寄存器，一组寄存器是记忆的一部分，可以被读取和写入。事实证明，现在执行寄存器只是成为一条指令产生和其他一些指令消耗的某些事物的名称。它是一些人的目的地，也是其他人的来源。而这一大堆的东西只是神奇地将一个计算的结果传递给另一个基于寄存器名称的计算，而没有将它们存储在显式寄存器文件中。有一个注册文件。当事情有点稳定下来时，它们会被储存起来。</p><p>发言人   43:59<br>Anyways, there’s a lot of stuff going on here, but the main thing to think about is your machine has resources to do multiple operations all at the same time. If you can somehow structure your program so that those can all get used. So this is, as I mentioned, it’s called a super scalar instruct processor is one that can do more than one instruction every Cocc cycle.<br>不管怎样，这里有很多事情要做，但要考虑的主要事情是您的机器有资源同时执行多个操作。如果你能以某种方式构建你的程序，以便所有这些都可以被使用。所以，正如我所提到的，它被称为超级标量指令处理器，每个Cocc周期可以执行多个指令。</p><p>发言人   44:28<br>And actually Intel started in 93. The very first Pentium could do two instructions at once. But then a little later, they came out with one called the Pentium Pro, which is sort of the basis of all modern processors. And the lead architect, by the way, was a CMU graduate.<br>实际上，英特尔始于93年。第一个奔腾可以同时执行两条指令。但不久之后，他们推出了一款名为奔腾Pro的处理器，它是所有现代处理器的基础。顺便说一下，首席建筑师是一名CMU毕业生。</p><p>发言人   44:49<br>This out of order execution is the model that’s used nowadays. So the other thing is those functional units are more complex than you think they might be in that they have what’s called pipelining.<br>这种不按顺序执行的模式是现在使用的模式。所以另一件事是这些功能单元比你想象的要复杂，因为它们有所谓的流水线。</p><p>发言人   45:04<br>And the idea is of pipelining is imagine you can break up a computation into a series of distinct stages. A simple example is if you want to compute a times b plus c, you first do the times and then you do the plus. But it actually gets deeper than that. You can take something like multiplication and break it up into smaller steps. That can be done one after the other in a way. And then if you have a separate dedicated hardware for each of those stages, then you can do what’s called pipelining, which is when one operation moves from one stage to the next, a new operation can come in behind and start its thing.<br>流水线的想法是想象你可以将一个计算分成一系列不同的阶段。一个简单的例子是，如果你想计算A乘以b + c，你首先计算乘以，然后再计算加号。但实际上它比这更深。你可以把像乘法这样的东西分解成更小的步骤。这可以以某种方式一个接一个地完成。然后，如果每个阶段都有单独的专用硬件，那么您可以进行所谓的流水线操作，即当一个操作从一个阶段移动到下一个阶段时，一个新的操作可以进来并开始它的事情。</p><p>发言人   45:48<br>So this example shows, imagine I had a three stage pipeline multiplier, and I want to do this computation a times BA times c, and now multiply those together. So the thing to observe is that a times b and a times c don’t depend on each other in any way. So I can do them both, and I don’t have hardware to do them simultaneously, but I have them enough to do one right after the other.<br>所以这个例子展示了，假设我有一个三阶段的管道乘法器，我想做这个计算a乘以BA乘以c，现在把它们相乘在一起。所以要观察的是，a倍b和a倍c并不以任何方式相互依赖。所以我可以同时做它们，而且我没有硬件来同时做它们，但是我有足够的硬件来让它们一个接一个地做。</p><p>发言人   46:18<br>So I can feed the first computation into the first stage a times b on time step 1. And then time step 2, it will move on to stage 2. And time step 3, it will move on to.<br>所以我可以在时间步骤1上将第一个计算输入第一阶段a乘以b。然后时间步骤2，它将进入阶段2。和时间步骤3，它将继续前进。</p><p>发言人   46:34<br>Stage 3. But now I can start a times c times step 2 because this stage became available once A times B moved from stage 1 to stage 2. And so I can follow right behind, just one clock cycle behind this other operation. Now, p times one times P2 obviously depends on both of these products. So it can’t start until a times c is completed, and then it will run through the pipeline without anything else. So overall, then, we’ve done what would have normally seem to be 9 steps worth of arithmetic in a total of seven steps here because of pipelining question.<br>第三阶段。但是现在我可以开始一次c次步骤2，因为这个阶段一旦a次B从阶段1移动到阶段2就可用了。所以我可以紧跟在后面，只比另一个操作晚一个时钟周期。现在，p倍，一倍，P2显然取决于这两种产品。所以它只能在c完成一次之前启动，然后它将通过管道运行，没有其他任何东西。总的来说，由于流水线问题，我们在总共七个步骤中进行了通常看起来值得进行9个步骤的算术。</p><p>发言人   47:31<br>If you had like in this picture here, if there were different multipliers in these different places, yes, you could do those two completely independent of each other.<br>如果你像这张照片里一样，如果这些不同的地方有不同的乘数，是的，你可以完全独立地做这两个。</p><p>发言人   47:51<br>Yes, this is all in a single core of a single processor. Multicore is yet another. This is a lower level parallelism than you get through multicore, and it’s present except in the sort of lowest and lowest powered embedded processors. Some version of this exists, and most of the time your hardware is not being fully utilized. Is this one thing you’re going to learn from this? So that’s the idea of pipelining, sort of like parallelism. But it’s not that you have multiple copies of resources that you have this ability to stream operation through a single hardware resource in close succession to each other. And so Haswell, which is a little bit more recent than the shark machines, but not that much more, is one of the most recent versions of the Intel x 86 series.<br>是的，这一切都在一个处理器的单核中。多核是另一个。这是一种比通过多核获得的低级并行，除了在最低和最低功耗的嵌入式处理器中存在。这个版本存在，并且大多数时候您的硬件没有得到充分利用。这是你要从中学到的一件事吗？这就是流水线的想法，有点像并行。但是，并不是说您拥有多个资源副本，您就能够在单个硬件资源中彼此紧密连续地进行流式操作。因此，Haswell比鲨鱼机更新一点，但不多，是英特尔x86系列的最新版本之一。</p><p>发言人   48:51<br>And the functional units include there’s a lot of functional units that can do different things. When you add it all up, there’s a possibility of it doing two loads and one store, 4 integer operations, 2 floating point multiplies, one addition, and one division. They can’t all happen at the same time because there’s some shared functional units. The point is, there’s really a lot of equipment there that can do stuff.<br>功能单位包括有许多可以做不同事情的功能单位。当你把它们全部相加时，它有可能进行两次加载一次存储、4次整数运算、2次浮点乘法、一次加法和一次除法。它们不可能同时发生，因为有一些共享的功能单元。重点是，那里真的有很多设备可以做事情。</p><p>发言人   49:23<br>And also, you can measure how an instruction now has two characteristics in operation is how long does it take from beginning to end? But also how closely spaced can two operations be because of this pipelining? So you see that most of them take some number of Cox cycles to perform, but they’re also pipelines so that you can do a series of them just one cycle apart. The only different ones that aren’t is you’ll notice the division is both very slow and it’s not. Pipeline division is a very expensive operation on most machines, relatively speaking. So what I claim then is these characteristics then provide a limit on how fast our program can run.<br>而且，您可以测量一条指令在操作中现在如何具有两个特征，即从开始到结束需要多长时间？但是由于这种流水线，两个操作之间的距离能有多近？所以你会看到，它们中的大多数都需要一定数量的Cox循环来执行，但它们也是管道，这样你就可以在一个循环之间执行一系列它们。唯一不同的是你会注意到分裂非常缓慢，而且不是。相对而言，管道划分在大多数机器上是一项非常昂贵的操作。所以我认为这些特征限制了我们程序的运行速度。</p><p>发言人   50:19<br>Our original program in that I have a series of multiplications, for example, of integers here. And this shows the code for it. And I need the result of one multiplication before I can begin the next. So there’s a three clock cycle bound here. And you’ll see that, in fact, my measurements all correspond to what I’m calling the latency bound of these machines, which is just based on how much time it takes from a beginning of an operation to the end.<br>我们最初的程序中，我有一系列乘法，例如这里的整数。这显示了它的代码。我需要一个乘法的结果，然后才能开始下一个乘法。所以这里有三个时钟周期。你会发现，事实上，我的测量结果都符合我所说的这些机器的延迟界限，这只是基于从操作开始到结束所花费的时间。</p><p>发言人   50:55<br>And the reason is we consider a diagram, the computation being done by this, that it’s doing a series of multiplications. And I require the result of one multiplication before I can start the next. In general, if you look at this loop code, it has to compute ecx, the updated value of it, before it can now start the next one. And so that’s why, even though this, I have a pipeline multiplier, my program itself limits me to the sequential execution of all the multiplies. So let’s see if we can’t get beyond that bound, that latency bound.<br>原因是我们考虑一个图表，它正在进行一系列的乘法计算。我需要一个乘法的结果，然后才能开始下一个。一般来说，如果你看看这个循环代码，它必须计算ecx，它的更新值，然后才能开始下一个循环。这就是为什么即使我有一个管道乘数，我的程序本身也限制我按顺序执行所有的乘法。所以让我们看看我们是否无法超越这个界限，即延迟界限。</p><p>发言人   51:44<br>Well, there’s a fairly common technique that you might have heard of before. That’s called loop unrolling. And the idea of loop unrolling is just that you. Rather than executing one value within a loop, you execute multiple ones. And so this code shows unrolling by two. And what it says is I’m going to step through this array two elements at a time. And within each of the inner loop I’m going to combine the values from Di and Di plus 1. And I have to put in some extra code to finish off. What happens if the original ray was a odd length, but you get the idea.<br>嗯，有一种相当常见的技术，你之前可能听说过。这被称为循环展开。而循环展开的想法就是你自己。而不是在循环中执行一个值，而是执行多个值。因此这段代码显示展开为2。它说的是我将逐步通过这个数组，一次两个元素。在每个内循环中，我将合并Di和Di加1的值。我必须加入一些额外的代码来完成。如果原始光线的长度是奇数，会发生什么，但你明白了。</p><p>发言人   52:27<br>And this idea, I show this code of two, but you could imagine this applying for different values of loop unrolling. So will this help us any?<br>这个想法，我展示了这段两个代码，但你可以想象这适用于不同的循环展开值。这对我们有帮助吗？</p><p>发言人   52:38<br>Well, when I run it, I get that the integer addition got a little faster, but the other ones didn’t improve at all. So this one is going faster because basically the old code. Just the overhead of the loop indexing and incrementing was enough to be slowing me down. It’s already close to a clock cycle, so I just managed to knock that down to be at the latency bound of this particular instruction. But it didn’t improve the other ones because I still have this sequential dependency in order to get my new value of x, I have to first do one computation and then do the other before I can begin another one. But this shows me the way I could make a very, very small change and change performance fairly dramatically.<br>当我运行它的时候，我发现整数加法速度加快了一点，但其他的并没有任何改进。所以这个速度更快，因为基本上是旧代码。仅仅是循环索引和递增的开销就足以让我放慢速度。它已经接近时钟周期，所以我设法将其降低到这个特定指令的延迟范围。但它并没有改善其他的，因为我仍然有这种顺序依赖，以便获得我的新x值，我必须先进行一次计算，然后再进行另一次计算，然后才能开始另一次计算。但这向我展示了我可以做出非常非常小的改变并相当显著地改变性能的方式。</p><p>发言人   53:34<br>What if I take these parentheses and shift them to the right? Would that make any difference? And lo and behold, yes, you find that. And I’ll call that transformation unrolling.<br>如果我把这些括号向右移动怎么办？会有区别吗？瞧，是的，你找到了。我称这种转变为展开。</p><p>发言人   53:59<br>By two, computing one element at a time. I’ll talk about that in a minute, but I’ll use this lowercase A to say I’ve done an associativity transformation. And you see, all of a sudden, my time dropped in half for these three cases. So something’s going on. And so let’s see why that is. And now I’ll introduce it.<br>按两个，一次计算一个元素。我稍后会讨论这个问题，但我会使用这个小写的a来表示我已经做了一个关联性转换。你看，突然间，我在这三个案例中的时间减少了一半。所以有些事情正在发生。所以让我们看看为什么会这样。现在我来介绍一下。</p><p>发言人   54:30<br>And so if I take my picture from before and think about what those computations imply, you’ll see that right now I’ve changed the structure of the computation so that I’m pair wise, combining each element and a pair of elements of the array, and then accumulating those into the overall computation. So have actually that shifting of the parentheses fundamentally changed how I’m doing my computation? And you can see now that this critical path, which is what determines, in this case, the performance limitation, just got shorter by a factor of 2. And that’s why I’m now running twice as fast for the operations, not for integer addition, but for the other three operations.<br>因此，如果我从之前拍摄照片并思考这些计算意味着什么，你会看到现在我已经改变了计算的结构，这样我是成对的，将数组的每个元素和一对元素组合在一起，然后将它们累积到整体计算中。所以，括号的移动是否真的从根本上改变了我的计算方式？现在你可以看到，这个关键路径在这种情况下决定了性能限制，它缩短了2倍。这就是为什么我现在运行这些操作的速度是原来的两倍，不是为了整数加法，而是为了其他三个操作。</p><p>发言人   55:23<br>I’ve cut by a factor of 2 just by that shift.<br>仅仅因为这个转变，我就减少了2倍。</p><p>发言人   55:27<br>Now, there’s some good news and bad news here. The good news is if this is integer arithmetic, we know already, you know, that choose complement arithmetic is associative and commutative. So it really doesn’t matter for both multiplication and addition. So it really doesn’t matter what order I combine these elements in. I’m going to get the exact same answer no matter what. But you also saw for floating point, that’s not the case. So with floating point, that shifting these parentheses because of rounding possibilities and even potentially overflow, you might get different values results from these computations.<br>现在，这里有一些好消息和坏消息。好消息是，如果这是整数算术，我们已经知道，你知道，选择补码算术是结合和交换的。所以对于乘法和加法来说真的都不重要。所以我组合这些元素的顺序真的不重要。无论如何，我都会得到完全相同的答案。但是你也看到了浮点运算，但情况并非如此。因此，对于浮点数，由于舍入的可能性而移动这些括号，甚至可能溢出，您可能会从这些计算中得到不同的值结果。</p><p>发言人   56:11<br>But then again, if you think about, is that really going to happen? Chances are no, that it’s not really going to affect the outcome of your program, but it’s enough of a change that most C compilers or most compilers, period, will not make any changes. That changes associativity because they’re very conservative when it comes to voting point. So that’s something you as an application programmer have to know well enough.<br>但是话又说回来，如果你想想，那真的会发生吗？机会是没有的，它不会真正影响你的程序的结果，但它已经足够改变，大多数C编译器或大多数编译器，时期，不会做任何改变。这改变了结合性，因为他们在投票点方面非常保守。这是作为应用程序程序员必须充分了解的事情。</p><p>发言人   56:38<br>Is this a valid? Can I do this transformation without messing things up? And now what I’ll say is now there’s a new set of bounds. So a bound is what would appear to be sort of the best you can do based on some constraint in the program. And before, it was saying, well, the latency total time through for a given operation was abound.<br>这是有效的吗？我能在不搞砸事情的情况下进行这种转变吗？现在我要说的是，现在有一组新的界限。因此，限制似乎是基于程序中的某些约束，您可以做的最好的事情。之前，它的意思是，一个给定操作的总延迟时间很多。</p><p>发言人   57:04<br>And now I say, well, there’s an even more fundamental bound, which I’ll call the throughput bound, which is just based on I only have so much hardware out there, and I can only pump it so fast. So for example, these two, the throughput bound is one because I only have. That actually becomes limited by the requirement that I’m having to read from memory. And I have two different load units. Oh no I’m sorry. I only have one multiplier for integers and one for addition. The throughput bound for these two actually is just a half because it turns out there’s some odd part of the hardware design that has two floating point multipliers, but only one floating point adder. And we’ll see that we can actually make this multiplication code run faster than addition code.<br>现在我说，嗯，还有一个更基本的界限，我称之为吞吐量界限，这只是基于我只有那么多硬件，而且我只能非常快地输送它。例如，这两个，吞吐量限制是一个，因为我只有一个。这实际上受到我必须从记忆中读取的要求的限制。我有两个不同的负载单位。哦，不，对不起。我只有一个整数乘数和一个加法乘数。这两个的吞吐量限制实际上只有一半，因为事实证明硬件设计中有一些奇怪的部分有两个浮点乘法器，但只有一个浮点加法器。我们会看到，我们实际上可以让这个乘法代码比加法代码运行得更快。</p><p>发言人   58:07<br>And over here, again, my limit will be that I only have two load units. And I read for every element I’m computing, I have to be reading 1 element from memory. So I can’t get below that. So, but we saw this transformation now has let us break out of this latency limitation and get something closer to throughput.<br>在这里，我的限制将是我只有两个负载单位。并且我读取我正在计算的每个元素，我必须从内存中读取1个元素。所以我无法低于这个。所以，但是我们现在看到这种转变让我们突破了延迟限制，更接近吞吐量。</p><p>发言人   58:33<br>Here’s another technique that can be used to, again, sort of get more parallelism going. And I call this multiple accumulators. And the idea is, let’s imagine that we have the odd numbered elements and the even numbered elements in the array. And we can compute separate sums or products of those two sets of elements. And then the very end combine them together. So this is another form of an associativity transformation.<br>这里还有另一种技术，可以用来再次提高并行性。我称之为多个累加器。这个想法是，让我们想象一下，我们有奇数元素和偶数元素在数组中。我们可以分别计算这两组元素的总和或乘积。然后最后把它们结合在一起。所以这是结合性转换的另一种形式。</p><p>发言人   59:04<br>We’re changing the order in which we combine things together. It’s just that we’re doing it in this sort of odd even manner, or in general, every ith value, if we do it by some. By some parameter, I and it has the same issues that if it’s integer arithmetic, it’s fine. If it’s floating point, there’s a risk of changing the behavior of the program. But you’ll see that, again, we get cutting in half here and a little bit below one for integer addition. And again, we can think of it by looking at these pictures of what are what gets computed?<br>我们正在改变我们将事物组合在一起的顺序。这只是因为我们以这种奇怪的方式进行，或者一般来说，如果我们以某种方式进行，每一个都是值。通过一些参数，I和它有同样的问题，如果它是整数算术，那没问题。如果它是浮点数，则存在改变程序行为的风险。但是你会看到，对于整数加法，我们在这里切成两半，略低于一。再说一次，我们可以通过查看这些图片来思考它，这些图片是什么被计算出来的？</p><p>发言人   59:47<br>And you see what we’re doing is we’re computing the even numbers, even numbered elements being combined. Here are all the odd ones. And at the very end, we’re combining those together.<br>你可以看到我们正在做的是计算偶数，将偶数编号的元素组合在一起。这些都是奇怪的。最后，我们将它们结合在一起。</p><p>发言人   01:00:00<br>And so we can generalize this if we can unroll by a factor of k of l, and we can accumulate k results in parallel. And we can use various values of l and k for it, in general, LS to be a multiple of k, and so you run it out, and you can get for floating point multiply, you can actually get it down almost to this throughput bound of 0.5.<br>因此，如果我们能够以l的k倍展开，并且可以并行累积k个结果，我们就可以推广这一点。我们可以使用不同的l和k值，一般来说，LS是k的倍数，所以你把它运行出来，你可以得到浮点乘法，你实际上可以把它降到几乎0.5的吞吐量边界。</p><p>发言人   01:00:40<br>This is incorrect, this is integer addition, I should say. In addition, you can again, get it down to around .5 in general by sort of picking the best parameters, I can get very close to the throughput bound of this processor. So I’ve been able to take something, remember originally was 20 clock cycles, then 10, and now I’m getting it down to one or fewer clock cycles per element. So now, just as the final step is OK, is that as good as it goes?<br>这是不正确的，这是整数加法，我应该说。此外，通过选择最佳参数，您可以再次将其降低到0.5左右，这样我可以非常接近该处理器的吞吐量边界。所以我已经能够采取一些措施，记得最初是20个时钟周期，然后是10个，现在我正在将其降低到每个元素一个或更少的时钟周期。那么现在，最后一步就可以了，有这么好吗？</p><p>发言人   01:01:20<br>Actually, no, you remember when I talked about floating point, I mentioned that there’s this special set of registers that are on x 86 that were called Xmm registers on the shark machines. And now this has, well, this newer generation has something called ymm registers, which have the feature being twice as big as Xmm registers. So in particular, these registers are are. 32 B long. And there’s a new version coming out within a year or something they call a 512, where the register is 512 b. So that’s 256 B wrong. No, it 2, 5, 12, excuse me, it’s 64 B, 64 B, so it will be twice as big as these.<br>实际上，不，你还记得我谈论浮点数时，我提到过x86上有一组特殊的寄存器，在shark机器上被称为Xmm寄存器。现在有了，嗯，新一代有了一种叫做 “ymm寄存器” 的东西，它的功能是Xmm寄存器的两倍。所以特别地，这些寄存器是。32 B长。在一年内有一个新版本即将推出，他们称之为512，其中寄存器是512 b。所以那是256 B错了。不，它是2、5、12，对不起，它是64 B、64 B，所以它的大小是这些的两倍。</p><p>发言人   01:02:18<br>As I mentioned before, you can think of these as a way of operating on 32 individual characters, or I can treat them as floating point. And we saw before that nowadays the regular floating point makes use of sort of the low order 4, 8 B of these registers, but there’s also instructions called vector addition, where one instruction has the effect of doing eight floating point additions at once on float data and on double precision. Its counterpart does four of them at once on these. And that hardware is there. It’s just sitting there waiting to use, and it seldom gets fired up to really make use of it. But so that floating point multiplier that can do floating point multiplication in three clock cycles and is fully pipelined can actually do 8 voiding point multiplications in parallel and pipeline in three clock cycles. And as I mentioned, the Shark Machines has an earlier version where the numbers are half of these. So it can do for single precision or two double precision at once.<br>正如我之前提到的，您可以将它们视为一种对32个单独字符进行操作的方式，或者我可以将它们视为浮点。我们之前看到，现在常规浮点使用这些寄存器的低阶4、8 B，但也有称为向量加法的指令，其中一条指令可以同时对浮点数据和双精度进行8个浮点加法。它的对应部分在这些上面同时做了四个。而且硬件也在那里。它只是坐在那里等待使用，很少会被激发去真正利用它。但是，能够在三个时钟周期内进行浮点乘法并且完全流水线化的浮点乘法器实际上可以在三个时钟周期内并行执行8个空洞点乘法。正如我所提到的，鲨鱼机器有一个早期版本，数字是其中的一半。所以它可以同时进行单精度或两个双精度。</p><p>发言人   01:03:42<br>And if I write code uses that what I call vector code, then you can see I can drop by a vector of about four across the board here and make it run much faster. So this is really 0 6 2 5. It’s doing 16 operations per Cox cycle on that. And can’t quite hit the vector throughput bound, but in general, making this thing run much faster.<br>如果我编写代码使用我所谓的矢量代码，那么你可以看到我可以在这里下降大约四个矢量，并使它运行得更快。所以这真的是0 6 2 5。它在每个Cox周期上执行16个操作。并且不能完全达到向量吞吐量的限制，但总的来说，使这个东西运行得更快。</p><p>发言人   01:04:22<br>And so the people really worry about, and you can imagine these instructions were introduced for things like video processing, image processing, sound sort of signal processing, where performance really matters, how fast you can display an image, how fast you can rotate something, how fast you can perform graphics makes a big difference in video games are one of the big drivers. But even for sort of other operations you might do on images. And so these instructions were really designed to do it and people who write code for those kind of applications get pretty good at right encode in a way that they can do this to what’s called vector. And unfortunately, so the Intel compiler will actually automatically do some of this for you. GCC, they attempted to implement it and it didn’t work very well. So I think they discontinued it.<br>所以人们真的很担心，你可以想象这些指令被引入到视频处理、图像处理、声音信号处理等领域，其中性能真正重要的是，显示图像的速度有多快，旋转物体的速度有多快，你执行图形的速度有多快会对视频游戏产生很大的影响，这是其中一个重要的驱动因素。但即使是你可能对图像执行的其他操作。因此，这些指令确实是为了做到这一点而设计的，为这些应用程序编写代码的人在正确编码方面表现得相当出色，他们可以对所谓的向量进行编码。不幸的是，英特尔编译器实际上会自动为您完成一些任务。GCC，他们试图实现它，但它并没有很好地工作。所以我认为他们已经停产了。</p><p>发言人   01:05:17<br>It turns out there’s a web side, so this is on the web from the web page that describes how to do this programming. If you’re interested, there’s extensions to GCC that are very funky, really weird stuff, but write code that then will get compiled down to make use of these kind of instructions. And that’s how I did it and how I got these performance results.<br>结果是有一个web端，所以这是从描述如何进行编程的网页上的。如果你感兴趣的话，有一些对GCC的扩展是非常时髦、非常奇怪的东西，但是编写代码，然后编译下来利用这些指令。这就是我如何做到的，以及我如何得到这些性能结果。</p><p>发言人   01:05:47<br>Okay, so that shows you if you really want to, but that’s very machine specific. That will only work on, well, you have to, you can actually tune it. So it’s easy to compile it to go between different machines, but it’s still very specific, very specific too. GCC, in fact. So that sort of shows you, though, if you really want to push it, what you can do.<br>好的，这表明你是否真的想要，但这非常针对机器。那只会起作用，嗯，你必须这样做，你实际上可以调整它。因此，编译它以在不同的机器之间运行很容易，但它仍然非常具体，也非常具体。实际上，GCC。这样就向你展示了，如果你真的想推动它，你可以做些什么。</p><p>发言人   01:06:14<br>Now, let’s get back to one of the things I told you about how if you think of your program as a very long linear sequence of instructions, then the thing is trying to grab as many of those and pull them apart as fast as it can. But of course, you know, your program is actually typically a loop, and there aren’t many instructions in that loop. So how is it turning that into a linear sequence?<br>现在，让我们回到我告诉过你的一件事情，如果你把你的程序看作是一个非常长的线性指令序列，那么问题就是尽可能多地抓住这些指令，并尽可能快地将它们分开。但当然，你知道，你的程序实际上通常是一个循环，而且循环中的指令并不多。那么它是如何将其转化为线性序列的呢？</p><p>发言人   01:06:40<br>Well, that relies on an idea of how do you handle branches, typically program fetching ahead, grabbing instructions, and it will come to a branch instruction, a conditional jump of some sort. And there has a dilemma because in general, this branch could either I’m sorry, could either be taken, meaning it will go to the branch target, or it could do what’s called fall through, meaning the test fails. And so it just continues execution. And there’s no way a priority to know what will happen. These can often be data dependent.<br>嗯，这取决于如何处理分支的想法，通常是程序提前抓取指令，抓取指令，然后它会变成分支指令，某种条件跳转。而且有一个困境，因为通常情况下，这个分支可以要么对不起，要么被接受，这意味着它将转到分支目标，或者它可以做所谓的 “失败”，这意味着测试失败。所以它只是继续执行。而且没有办法优先知道会发生什么。这些通常可能依赖于数据。</p><p>发言人   01:07:26<br>And so the way this is handled on a modern processor is by doing what’s known as branch prediction, which is essentially just guess which way is this branch going to go? Is it going to be taken or not predict? And then you start executing along the predicted direction, but do it in a way that if you make a mistake that you haven’t caused irreparable harm to the program. And we’ll see what that means.<br>因此，在现代处理器上处理这个问题的方法是进行所谓的分支预测，这基本上只是猜测这个分支将走向何方？它会被采取还是不会预测？然后你开始沿着预测的方向执行，但要以某种方式执行，如果你犯了一个错误，你还没有对程序造成不可弥补的伤害。我们会看看这意味着什么。</p><p>发言人   01:07:53<br>So what really happens then is up here, there’s a lot of logic that’s trying to suck out instructions. And then there’s a branch unit that’s basically coming along later and saying, yeah, you’re OK, you predicted that correctly. So you can keep going or it will throw up a flag and say, oh, wait a minute, stop misp you mispredicted this branch way back 100 clock cycles ago. It’s not that long ago. Some number of clock cycles ago, you’ve got to fix it. And so the handling jumps then becomes more a case of of guessing up here and then either confirming or denying that guess down below.<br>所以真正发生的是，在这里，有很多逻辑试图吸取指令。然后有一个分支单位基本上是稍后出现并说，是的，你没事，你预测得正确。所以你可以继续前进，否则它会抛出一面旗帜并说，哦，等一下，别误了，你在100个时钟周期前错误地预测了这个分支。这不是很久以前的事了。在一些时钟周期之前，你必须修理它。因此，处理跳跃就变得更多地是在这里猜测，然后在下面确认或否认那个猜测。</p><p>发言人   01:08:44<br>So in general, then, it will predict it one way and begin executing. So imagine, for example, in a loop like I’ve shown you, that you predict that the branch will be taken, that you’ll go back to the start of the loop. Again, a pretty good guess. It’s a good guess until you hit the end of the loop, but let’s just guess that way. And so the program will just keep guessing that the branch will be taken. And by that means, by all those guesses, basically create this long linear sequence of instructions that can be pulled in and executed. And in general, some of them will be fetched and some of them will actually have done the operations that are called for in the instruction.<br>因此，一般来说，它会以一种方式预测它并开始执行。例如，想象一下，在一个像我展示给你的循环中，你预测分支将被采取，你将回到循环的开头。再一次，一个相当好的猜测。直到你到达循环的末尾，这是一个很好的猜测，但让我们这样猜测。因此，程序将继续猜测该分支将被采取。通过这种方式，通过所有猜测，基本上创建了这个可以被拉入和执行的长线性指令序列。一般来说，它们中的一些将被获取，其中一些将实际上完成了指令中调用的操作。</p><p>发言人   01:09:37<br>And then what happens is if the flag goes up to say, no, this was invalid, then what will happen is it will go back and cancel all the instructions that have been fetched and executed. And the way it does that is you’ll notice all these instructions only modification registers. And it has multiple copies of all the registers. Going back. These are the values that I’m sure of. These are sort of speculative values, a pending updates to them. And so when it comes time to cancel, it just cancels out all those pending updates and goes back to values that it’s certain of question. There’s a big block they call the register renaming unit, which is sort of multiple copies of all the registers as they get accumulated.<br>然后发生的事情是，如果标志上升说，不，这是无效的，那么它将返回并取消所有已获取和执行的指令。它的方式是你会注意到所有这些指令只是修改寄存器。并且它有所有寄存器的多个副本。回去。这些是我确定的价值观。这些都是投机性的价值，是一个悬而未决的最新进展。因此，当需要取消时，它只是取消所有挂起的最新进展，并返回到确定有问题的值。有一个大的块被称为寄存器重命名单元，它是所有寄存器累积的多个副本。</p><p>发言人   01:10:46<br>It has many more. We typically have several hundred of these sort of virtual registers to keep pending copies to the actual registers.<br>它还有更多。我们通常有数百个这样的虚拟寄存器，以保持对实际寄存器的挂起副本。</p><p>发言人   01:10:57<br>It does, it stores. Here’s the old value, here’s the first update, here’s the second update, here’s the third, and it keeps track of all the you can imagine why this is not something you learn in a one semester course to keep track of all those different things flying by and make sure that it works is a pretty tricky business, but the conceptual way, it’s a pretty simple idea that it just races off, does a lot of things based purely on speculation, and then only if it makes a mistake, it goes, oh, and it sort of rolls back to as if it only execute up to a certain point, and then it moves forward and starts going the correct way. So, and it can get away with this, it’s very interesting and tricky stuff, but you remember we talked early in the course about the difference between using conditional moves and conditional jumps to implement conditional operations. And conditional moves can take place totally within the structure of this pipeline. But a conditional jump, if it’s an unpredictable branch, the problem is it might go off executing and make do a lot of wasted work, but even worse than when it gets back and has to restart, it takes a while to sort of fill up all the buffers and the system and get the whole thing running at full steam ahead. So that kind of finishes up.<br>它有，它存储。这是旧的值，这是第一次更新，这是第二次更新，这是第三次。它会跟踪所有你能想象到的东西，为什么这不是你在一个学期的课程中学到的东西，以跟踪所有这些不同的东西，并确保它有效，这是一个相当棘手的事情，但是概念性的方式，这是一个非常简单的想法，它只是逐渐消失，做很多事情纯粹基于猜测，然后只有当它犯了错误时，它才会回到好像只执行到某个点的状态，然后它向前移动并开始朝着正确的方向前进。所以，它可以逃脱这个，这是非常有趣和棘手的东西，但是你还记得我们在课程的早期讨论了使用条件移动和条件跳转来实现条件操作之间的区别。有条件的移动完全可以在这个管道的结构内进行。但是条件跳跃，如果它是一个不可预测的分支，问题是它可能会停止执行并做很多浪费的工作，但比它回来并必须重新启动时更糟糕，需要一段时间才能填满所有缓冲区和系统，并让整个系统全速运行。这样就结束了。</p><p>发言人   01:12:34<br>And the way I describe it is, first of all, don’t do anything stupid. And stupid is probably it too strong a word. Don’t do sort of keep in mind, there’s certain things that you should, as a programmer be doing all the time, and they’re not obvious, perhaps. And then begin thinking about tuning and getting some of instruction level parallelism. And I describe it as for the machine, But as I said, pretty much all processors nowadays, it’s a class of machines. And so these general techniques will work.<br>我对此的描述是，首先，不要做任何愚蠢的事情。“愚蠢” 这个词可能太过强烈了。不要做，记住，作为一个程序员，有一些事情你应该一直在做，也许它们并不明显。然后开始考虑调优和获得一些指令级并行。我将其描述为针对机器的，但正如我所说，如今几乎所有的处理器，它是一类机器。因此，这些通用技术将起作用。</p><p>发言人   01:13:07<br>Those ideas of changing the associativity, they’ll work, whether it’s the Arm processor built into my cell phone or the x 86 processor built into your laptop, or one of the shark machines, they all have the same general implementation structures. So these techniques will work across across all of them. Okay, that’ll do us for today.<br>那些改变结合性的想法将会奏效，无论是我手机中内置的Arm处理器还是笔记本电脑中内置的x86处理器，或者是鲨鱼机器中的一个，它们都具有相同的通用实现结构。因此，这些技术将适用于所有这些技术。好的，我们今天就到这里了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深入理解计算机系统 009-Machine-Level Programming V, Advanced Topics</title>
    <link href="/2025/10/12/15213-009/"/>
    <url>/2025/10/12/15213-009/</url>
    
    <content type="html"><![CDATA[<p>发言人   00:01<br>This will be the last lecture on machine level of programming. We call it advanced topics, but think of it more as miscellaneous topics.<br>这将是最后一堂关于机器编程的讲座。我们称之为高级主题，但更多地将其视为杂项主题。</p><p>发言人   00:11<br>And I think most of you, of course, you know that your bomb webs are due tonight. So you, most of you are probably well into that or hopefully through it. And then at midnight tonight, the next web will come out, which is called Attack Lab. And there was a recitation about that yesterday. But this is a lab that’s new to the course. It’s similar to one that we used to use at this point in the course, but it’s been updated and changed in significant ways.<br>我想你们大多数人，当然，你们知道你们的炸弹网定于今晚。所以你们大多数人可能已经很熟悉了，或者希望能够度过这个过程。然后在今晚午夜，下一个网络将会出现，这个网络被称为攻击实验室。昨天有一场关于这个的背诵。但这是一个新的实验室。它类似于我们在课程中使用的那个，但它已经在重要方面进行了更新和更改。</p><p>发言人   00:43<br>We’re actually, when you have labs like we do in this course with this many students, there’s a lot of things that can go wrong. Going to keep a close eye on how things are going. But I encourage you only have a week and a half to do this next lab to get started soon. And partly by having some people start sooner, you’ll start breaking things for us that we can track down.<br>实际上，当你有像我们在这么多学生的课程中做的这样的实验室时，有很多事情可能会出错。我们将密切关注事情的进展。但我建议你只有一周半的时间进行下一个实验，以便尽快开始。部分原因是让一些人更早开始，你就会开始为我们破坏一些我们可以追踪的东西。</p><p>发言人   01:09<br>So today, what we’ll talk about is a couple. Like I said, it’s miscellaneous topics, but important topics. One is just sort, what does the memory look like when you’re running X 8664 programs? The other is a very important topic on security vulnerability called buffer overflows, and in fact, attack lab will be precisely exploiting those security vulnerabilities. And then we’ll look at unions. So far, you’ve looked at arrays and structs and how they’re organized, and I want to compare that to unions. So let’s talk about memory then, as I said at the beginning, early in the course, conceptually, a memory is just a big array of bytes and that the view of the machine level programmer, even though it’s not the actual implementation, there’s a whole part that we’ll talk about later in the course of this, is called virtual memory. This organization, this very simple organization, but the underlying implementation is this complex management of various different memory types from disk memories to solid state disks and to what’s called DRAM, which stands for dynamic Ram when you buy memory for your processor, it’s DRAM.<br>所以今天，我们要谈论的是一对。就像我说的，这是杂项话题，但很重要的话题。一个只是排序，当您运行X 8664程序时，内存是什么样子的？另一个是关于安全漏洞的非常重要的话题，称为缓冲区溢出，实际上，攻击实验室将精确地利用这些安全漏洞。然后我们再看看工会。到目前为止，您已经查看了数组和结构以及它们的组织方式，我想将其与联合进行比较。那么让我们来谈谈内存，就像我在课程开头所说的，从概念上讲，内存只是一个大的字节数组，机器级别程序员的视图，即使它不是实际的实现，有一个完整的部分我们将在稍后的课程中讨论，称为虚拟内存。这个组织，这是非常简单的组织，但底层实现是对各种不同内存类型的复杂管理，从磁盘内存到固态磁盘以及所谓的DRAM，当您为处理器购买内存时，它是DRAM，它代表动态内存。</p><p>发言人   02:38<br>So as you know, in X 8664, we’re working machines that nominally are addresses, can be up to sixty-fourth s long.<br>如你所知，在X 8664中，我们正在工作的机器名义上是地址，可以长达64秒。</p><p>发言人   02:48<br>And if you work out the numbers, remember I told you at the beginning of the course, you can estimate how big a number like 2 to the 64 is by remembering that 1020, and 1000 are very close to each other. So 2 to the 10th is roughly the same as 10 to the third. So you take 64 and you think 60. So how big is 2 to the 66 times 10? And therefore it’s six times 3, it’s like 10 to the 18th, and then you add the four to that, that two to the fourth is 16. So it’s around 16 times 10 to the 18th bytes.<br>如果你算出了数字，记得我在课程开始时告诉你的，你可以通过记住1020和1000彼此非常接近来估计像2到64这样的数字有多大。所以2的10与10的3大致相同。所以你拿64，你想60。那么2的66乘以10有多大呢？因此它是6乘3，就像10的18次方，然后你把4加在一起，那2到4就是16。所以它大约是16乘以10的18个字节。</p><p>发言人   03:32<br>So if you were to go off and look online on Amazon for DRAM chips and try to buy that much memory, you’d find you’re spending a lot of money more than you. I don’t know the numbers, but it would be a lot of memory money. And so you basically can’t do it nowadays. And so?<br>所以，如果你去亚马逊上在线寻找DRAM芯片并尝试购买那么多内存，你会发现你花的钱比你多很多。我不知道数字，但那会是很多记忆钱。所以现在你基本上做不到。所以呢？</p><p>发言人   04:03<br>Right now, the machines limit you to actually only 47 b worth of address in the address space. And so two to the 47th, again, work that out. That’s like 10 to the tweh times 256 times 10 to the 12th. So it’s 256 TB. And as you know, you can buy a disk drive now that has 8 TB. So it doesn’t seem like that much. But if you tried to buy that much DRAM again, you’d have to have a pretty big credit card.<br>现在，机器将您的地址空间限制为只有47 b的地址。所以两个47分，再一次，解决这个问题。这就像是10的tweh乘以256乘以10的12次方。所以它是256 TB。如你所知，你现在可以购买一个有8个TB的磁盘驱动器。所以看起来没那么多。但是如果你想再次购买那么多的DRAM，你必须有一个相当大的信用卡。</p><p>发言人   04:37<br>Limit And so even that’s a huge number. And modern supercomputer installations actually will have almost that much memory. But the point is that the hardware of today limits you to 47 b worth of address. But that’s not really a real limitation in terms of actual machines. And what will happen is as memory prices get cheaper and the technology gets better, they’ll slowly start adding as succeeding generations of processors come along, let you have bigger and bigger range of addresses.<br>限制，所以即使这是一个巨大的数字。而现代超级计算机的安装实际上将拥有几乎那么多的内存。但重点是今天的硬件限制了你只有47 b的地址价值。但就实际机器而言，这并不是一个真正的限制。接下来会发生的是，随着内存价格的降低和技术的进步，随着下一代处理器的出现，它们会慢慢开始增加，让你拥有越来越大的地址范围。</p><p>发言人   05:12<br>So all that is to say, that’s why. This number shows up, which is a 7 followed by 11 F’s. I can tell I need to scribble some numbers. You guys aren’t just saying numbers in the air is not working here. So let’s try.<br>也就是说，这就是原因。这个数字出现了，它是一个7后面跟着11个F。我知道我需要潦草地写一些数字。你们不只是在说空中的数字在这里不起作用。那么让我们试试。</p><p>发言人   05:53<br>Okay, so remember I said before two to the 64 is about equal to 16 times 10 to the 18th. And 2 to the 47th is 128 times 10 to the Tth. So it’s 128 TB.<br>好的，记得我之前说过，2的64大约等于16乘以10的18。而2的47次方是128乘10的第次方。所以它是128 TB。</p><p>发言人   06:29<br>So what’s the number after terabyte? You know, 10 to the 15th. How many bytes? Yes, petabytes, right? And do you know what 10 to the 18th is exa? So just as a reference, a company like Google, it probably its total storage across the whole enterprise is measured in some small number of exabytes. And it every day is getting several petabytes. I don’t know the numbers. They are, of course, secret, maybe 10 PB or more per day of new data that it’s ingesting into its system. These numbers are pretty huge, but not just totally off the charts.<br>那么TB之后的数字是多少？你知道，从10到15号。多少字节？是的，是PB，对吗？你知道10到18号是什么意思吗？因此，作为参考，像谷歌这样的公司，它可能以整个企业的总存储容量为一些少量的艾字节来衡量。它每天的数据量为几PB。我不知道数字。当然，它们是秘密的，每天可能有10 PB或更多的新数据进入其系统。这些数字相当巨大，但不仅仅是完全的图表。</p><p>发言人   07:31<br>Do you know what 10 to the 21st is. It’s called a zettabyte with two t’s. And it’s estimated if you add up all the digital content in the world, that gets created, everybody’s cell phone, camera, every video taken by anyone, anywhere, all year long is a couple of zettabytes a year.<br>你知道10到21号是多少吗？它被称为带有两个t的泽字节。据估计，如果你把世界上所有被创造出来的数字内容加起来，包括每个人的手机、相机、任何人在任何地方拍摄的每个视频，全年都是几个泽字节一年。</p><p>发言人   07:57<br>It’ll be a while before we’re really having to deal with that kind of memory. So just to give you an idea, 128 TB is the address limit on these systems. And so that’s why you have to have 7, because you remember that’s 1, 2, 3, and then there’s F, but there’s 11 of them. And this is 1, 1, 1 times 11, so that’s 44 ones, and this is three ones. And that’s where you get 47.<br>在我们真正不得不处理这种记忆之前，还需要一段时间。所以只是为了给你一个概念，这些系统的地址限制是128 TB。所以这就是为什么你必须有7个，因为你记得那是1、2、3，然后还有F，但有11个。这是1，1，1乘以11，所以这是44个，这是3个。这就是你得到47的地方。</p><p>发言人   08:38<br>And that’s the address of in Linux, that’s where they put the stack is up at the very top of the address space.<br>这就是Linux中的地址，这就是他们把堆栈放在地址空间的最顶部的地方。</p><p>发言人   08:47<br>And I should tell you, this picture is not at all to scale. It would be impossible to draw this picture to scale. For example, it shows that the stack starts way up at the top. And remember, stacks grow to smaller addresses when you’re pushing. And also we show the them upside down just to make everything confusing. The stack starts there and it grows towards lower addresses. And on a typical system, it will be limited to 8 MB. And you can tell that on a Linux system at least.<br>我应该告诉你，这张照片根本不适合缩放。把这张照片按比例画出来是不可能的。例如，它显示堆栈从顶部开始向上。请记住，当您推送时，堆栈会增长到较小的地址。而且我们把它们颠倒了，只是为了让一切都混乱。堆栈从那里开始，并向更低的地址增长。在典型的系统中，它将被限制为8个MB。你至少可以在Linux系统上看出这一点。</p><p>发言人   09:27<br>With the limit command, which? Used to be more interesting than it was is now because a lot of things are unlimited. But you see it says the stack size is limited to 81, 92 kB or kilobytes megabytes. And what that means is if you tried to access any memory via the stack pointer. That was outside of the range. Of this 8 MB range, you’d get a segmentation fault.<br>使用限制指令，哪个？过去比现在更有趣，因为很多东西都是无限的。但是你看到它说堆栈大小限制为81、92 kb或千字节兆字节。这意味着如果您尝试通过堆栈指针访问任何内存。这超出了范围。在这8个MB范围内，你会得到一个段故障。</p><p>发言人   10:11<br>And then down at the lower addresses, what comes in, what gets put into your program are the parts of the code that come out of the executable file. And so there’s a section, and we’ll talk more when we talk about linking, actually about the layout of the memory and the different regions of it. But for some obscure reason, they call where the code is sitting, the executable program, the text segment. I don’t know why that’s true, but it’s the way it is. And that’s across many machines.<br>然后在较低的地址处，进来的东西，被放入你的程序中的是来自可执行文件的代码部分。所以有一个部分，当我们谈论链接时，我们会更多地谈论，实际上是关于内存的布局和它的不同区域。但由于一些模糊的原因，他们称之为代码所在的位置，可执行程序，文本段。我不知道为什么那是真的，但事实就是这样。这跨越了许多机器。</p><p>发言人   10:43<br>And then the data is a first of all, there’ll be a section for the data that’s allocated program begins. So any global variables that you’ve declared will be in that section. And then the heap is the part of memory that is is allocated via Co Optoma It or one of its related functions. And so that varies dynamically as the program runs. It starts off with a very small allocation, and every time you call malloc. Not freeing memory. And so your memory requirements keep growing. It will keep moving up larger and larger addresses.<br>然后数据是首先，将有一个分配程序开始的数据部分。因此，您声明的任何全局变量都将在该部分中。然后，堆是通过cooptoma It或其相关函数之一分配的内存部分。因此，随着程序的运行而动态变化。它从一个非常小的分配开始，每次你调用malloc。不释放内存。因此，您的内存需求不断增长。它将继续向上移动，地址越来越大。</p><p>发言人   11:27<br>And then somewhere in the code too, and this can vary by system, is the code that gets brought in that represents the library functions, things like PDF and malloc itself, our own library code, they’re stored off on disk, and they get brought in, they get linked into your program when it first starts executing by a process known as dynamic linking, which we’ll talk about later in the course too, with the linking.<br>然后在代码的某个地方，这可能因系统而异，是被引入的代表库函数的代码，比如PDF和malloc本身，我们自己的库代码，它们存储在磁盘上，然后被引入，当你的程序第一次开始执行时，它们会通过一个称为动态链接的过程链接到你的程序中，我们将在课程的后面讨论这个链接。</p><p>发言人   11:53<br>And what you’ll find in general is that allocations will tend to be either at these very low addresses or these very high addresses as your program is running. So just as an example, here’s some code that it’s only a value is to show you different where things get located.<br>一般情况下，您会发现在程序运行时，分配往往会在这些非常低的地址或这些非常高的地址上进行。所以，作为一个例子，这里有一些代码，它只是一个值，旨在向您展示事物的不同位置。</p><p>发言人   12:16<br>And so you’ll see I allocated some fairly large arrays here. This one, they’re all cares, but this is 2 to the 24th, so 16 MB array, and this 1 is 2 to the 31st. So it’s 2 GB worth of ray.<br>所以你会看到我在这里分配了一些相当大的数组。他们都会在意这个，但是这个是2的24次方，也就是16 MB数组，而这个1是2的31次方。所以它是2 GB的射线。</p><p>发言人   12:38<br>I found that if I tried to larger ones, the program wouldn’t run. And I also do some. Here’s just a sort of global variable. And here’s a function. And then there’s a single function here with some local variable. And that will be allocated somewhere on the stack. And then there’s several calls to me, some of which are for some very small chunks of memory, and some were for some very large chunks of memory. And so we can run this program and see what addresses pop out of it.<br>我发现如果我尝试将它们变大，程序就无法运行。我也做了一些。这只是一种全局变量。这是一个函数。然后这里有一个带有一些局部变量的函数。并且将在堆栈上的某个位置分配。然后有几个电话给我，其中一些是针对一些非常小的内存块，另一些是针对一些非常大的内存块。因此，我们可以运行这个程序并查看其中弹出的地址。</p><p>发言人   13:17<br>And what you’ll see is the stack, this local variable, is somewhere up with an address in the range of the stack. And you see the 7 and a couple f’s, and then it goes to something else. And you’ll see also, interestingly enough, that code. And then looking down at the bottom, this yellow color is things get relegated to the tech segment, the main function.<br>你会看到的是堆栈，这个局部变量，位于堆栈范围内的一个地址。你看到7和几个f，然后它转到别的东西。你还会看到，有趣的是，那个代码。然后往下看底部，这个黄色的东西被降级到技术部分，这是主要功能。</p><p>发言人   13:43<br>And this function I declared called useless. And then the predefined arrays that were, in other words, globally, not declared by malloc, declared as part of the program itself, are down here in this data section. And because it’s a very large array, the huge array, you actually get some fairly large addresses. And then interestingly enough, I don’t know why it’s interesting, but for one reason or another, it happens that the smaller chunks of memory allocations are down here at addresses that are actually just a little bit above the pink section. And similarly, the really big chunks of memory I allocated are way up here. Near the stack limit. And so they’re there.<br>这个函数我声明称为无用。然后，换句话说，全局的预定义数组，不是由malloc声明的，声明为程序本身的一部分，在这个数据节中。而且因为它是一个非常大的数组，巨大的数组，你实际上会得到一些相当大的地址。然后有趣的是，我不知道为什么这很有趣，但由于某种原因，发生了这样的情况: 较小的内存分配块在这里，实际上只是略高于粉色部分。同样，我分配的真正大块内存也在这里。接近堆栈极限。所以他们在那里。</p><p>发言人   14:45<br>And in general, what’s happening is if I were to try and reference a memory address in this empty range I’d get a segmentation fault. It’s a valid address in terms of its bit properties, but it hasn’t actually been set up and allocated by the virtual memory allocator. So at any given time, the valid addresses are just those in the lower portion or the upper portion of this address ranges. In the middle is sort of no man’s land. And then what happens is you keep allocating more with malloc, and it will push the limits of what’s addressable in toward it.<br>一般来说，如果我尝试引用这个空范围内的内存地址，我会得到一个段错误。就位属性而言，它是一个有效的地址，但虚拟内存分配器尚未实际设置和分配。因此，在任何给定时间，有效地址只是此地址范围的下部或上部的地址。中间是一种无人之地。然后发生的事情是你通过malloc不断分配更多的资源，它会将可寻址的限制推向它。</p><p>发言人   15:23<br>And in principle, if you ever got too much of a memory request, these two would hit each other and malloc would return zero at that point. But it’s highly unlikely, given that you have 100 and twenty-eighth raby’s of address range here. So that, and you’ve probably seen this when you’re running, you’re looking at disassembled code with Gdb. You’re seeing some addresses that are way up here with the 7 and some f’s. Those are stack addresses. And you see these fours, a lot of zeros and some fours. Those tend to be where the code is going.<br>原则上，如果你收到了太多的内存请求，这两个内存会相互命中，malloc会在该点返回零。但这是极不可能的，因为你在这里有100和28个狂犬病毒的地址范围。所以，当你运行时，你可能已经看到了这个，你正在看使用Gdb的拆卸代码。你会看到一些地址在7和一些f的位置。这些是堆栈地址。你可以看到这些4个，很多0和一些4个。那些往往是代码要去的地方。</p><p>发言人   16:10<br>Now, why doesn’t the heat proceed in one direction? I actually don’t know. I’ll just observe that it had a strategy of putting big things here and small things here, and it probably uses slightly different management strategies for those two.<br>现在，为什么热量不向一个方向散发？我其实也不知道。我只会观察到它有一个把大事放在这里，把小事放在这里的策略，它可能对这两者使用略有不同的管理策略。</p><p>发言人   16:34<br>Okay, so that, but I think you’ll find that kind of useful to have some sense when you’re looking at when you’re running Gdb, it helps to just have some idea of what’s going on when you’re looking at these different addresses. Okay, now let’s talk about buffer overflow. And we’ll start this. You remember on the very first class, and I think we might have reviewed this part way along, we showed this example of some programs where if you do an out of bounds reference and write a value that’s out of bounds, in particular, I only have array of two elements here. But this function will take an arbitrary value of I and assign some magic number to element I of the array, and it has the possibility of. And we saw that when you do that, if I gets too big, it will first corrupt the double that’s stored as part of struct, and then when it gets bigger, it seems to not have any effect until it gets too big, and then you start corrupting memory. So the basic point is that it’s very easy in a program, AC program in particular, to a reference memory that’s not part of the sort of intent of the program.<br>好的，所以，但我认为当你在运行Gdb时，一些感知会对你有所帮助，当你在查看这些不同的地址时，了解正在发生的事情会有所帮助。好的，现在让我们谈谈缓冲区溢出。我们将开始这个。你还记得在第一个课上，我想我们可能已经回顾了这一部分，我们展示了一些程序的例子，如果你进行了越界引用并编写了一个越界的值，特别是，我这里只有两个元素的数组。但是这个函数将取任意值I，并为数组的元素I分配一些幻数，它有可能。我们看到当你这样做时，如果I变得太大，它将首先破坏作为struct一部分存储的double，然后当它变得更大时，它似乎没有任何影响，直到它变得太大，然后你开始破坏内存。所以基本的观点是，在一个程序中，特别是在交流程序中，要有一个不属于程序意图的参考存储器是非常容易的。</p><p>发言人   18:06<br>Happen in programs that aren’t properly written? That, and it becomes a security vulnerability.<br>发生在没有正确编写的程序中？这就变成了一个安全漏洞。</p><p>发言人   18:14<br>If there’s some way for an outsider two overflow, a buffer. For example, if there was some way for an outsider to give a larger value of I and ask that value be stored there, it could crash the program. And so in general, when you write in code, you try to think about, can I trust this value? A value that’s been computed by my program? And I’m sure that it’s within bounds? Or is it something that’s come from an external source and there has potentially at risk of being a vulnerability?<br>如果有一种方法可以让局外人溢出，那就是缓冲区。例如，如果外部人员有某种方法可以给出较大的I值并要求将该值存储在那里，则可能会导致程序崩溃。所以一般来说，当你写代码时，你会试着思考，我可以相信这个值吗？我的程序计算过的值？我相信它在范围内？或者它是来自外部来源并且可能存在成为漏洞的风险？</p><p>发言人   18:51<br>And so in particular, there’s a huge class of errors that have to do with overflowing buffers, where they’re trying to store a string of some type that’s been read from a message. And without knowing in advance how big that string is, it’s possible that it will be too big for the buffer that’s been allocated. And so one of the culprits is there’s a whole class of of library functions that let you store something, a string somewhere, without any kind of bounds checking, even being possible.<br>因此，尤其是有一大类错误与溢出的缓冲区有关，它们试图存储从消息中读取的某种类型的字符串。并且在事先不知道该字符串有多大的情况下，很可能对于已分配的缓冲区来说它太大了。因此，罪魁祸首之一是有一整套库函数类，让你可以在某个地方存储字符串，而无需任何边界检查，甚至是可能的。</p><p>发言人   19:31<br>So the sort of the worst 1 is one called get S, and the purpose of get S is normally it’s used to read a string from an input from a terminal input, something that somebody’s typed into a terminal. And so what it’s doing is it’s scanning this input string and looking for a character that represents the end of the line, which we write in c as backslash n, and it has the character code in hex of 0 a. And so gets this is sort of an approximate version of what the code for gets looks like. And as an argument, it’s just given a destination of where to store the result. And all it does is it reads one character at a time, looks for an endo file, meaning that the input stream is closed or an end of line. But as long as until it sees that, it just keeps adding more things to the end of this buffer. And so typically.<br>因此，最差的1被称为get S，而get S的用途通常是用于从终端输入的输入中读取字符串，这是某人在终端中键入的内容。所以它正在扫描这个输入字符串并寻找代表行尾的字符，我们用c写成反斜杠n，它的字符代码为0 a的十六进制。这有点像代码的近似版本。作为参数，它只是给出了存储结果的目的地。它所做的只是一次读取一个字符，查找endo文件，这意味着输入流已关闭或行尾。但只要在看到之前，它就会不断地在缓冲区的末尾添加更多的东西。如此典型。</p><p>发言人   20:45<br>When somebody calls gets, they’ll pass it a pointer to some buffer that they’ve allocated, but the function and it will get will just fill that buffer up, but it can potentially just keep going. There’s nothing in the function. There’s not even an argument to the function that tell the function when it has to stop, when it’s reached the limit of it. So it was written. Actually get us is if you try to compile code with get us, it will flash up a big warning that says this is really an unsafe function. You probably shouldn’t even be using it because it was written in an era in the 1970s when the early Unix distributions were coming out where people just weren’t worried about security vulnerabilities. And they just assumed that if you allocated a big enough buffer that there’s no reason why a string should be bigger than what you’ve allocated. And that’s actually true with other functions like stir, copy, you recall Ste coppi.<br>当有人调用get时，他们会传递一个指针给他们分配的某个缓冲区，但是函数和它将会填满这个缓冲区，但它可能会继续运行。这个功能里什么都没有。函数甚至没有一个参数告诉函数何时必须停止，何时达到限制。所以它被写了。实际上，如果您尝试使用get us编译代码，它将会弹出一个大警告，指出这确实是一个不安全的功能。你可能甚至不应该使用它，因为它是在1970年代编写的，当时早期的Unix发行版出现了，人们并不担心安全漏洞。他们只是假设，如果您分配了足够大的缓冲区，那么字符串就没有理由比您分配的大。这实际上适用于其他功能，如搅拌，复制，你记得Ste coppi。</p><p>发言人   21:59<br>Has two arguments, a destination and a source, and its purpose is to copy the string, the source into the destination and the way it determines the end of the string in the source is when it hits a null character and it just keeps copying one by one until it hits that. But it has no way of knowing. There’s no information there about how much, how big is the buffer allocated at the destination. And so it can easily overrun that. A similar one called stir cat, which is used to concatenate two strings, copy them to another destination.<br>有两个参数，一个是目标，一个是源，它的目的是将字符串复制到目标中，它确定源中字符串结尾的方式是当字符串命中null字符时，它会一直复制，直到命中该字符为止。但它没有办法知道。没有关于在目的地分配了多少缓冲区或有多大缓冲区的信息。因此它很容易超过那个。一个类似的叫做搅拌猫的方法，用于连接两个字符串，并将它们复制到另一个目的地。</p><p>发言人   22:39<br>And the scanner functions also have possible in the format string. You can give the percent S directive to the format string, which says read in a string and store it someplace. And it doesn’t say how long the string is limited to be, and it doesn’t say how much memory is available at the destination. So again, it can easily just write over that buffer.<br>和扫描仪功能也可以在格式字符串中使用。你可以给格式字符串指定百分比S指令，表示读取一个字符串并将其存储在某个地方。它没有说字符串的长度限制，也没有说目的地有多少内存可用。所以再次强调，它可以轻松地在缓冲区上写入。</p><p>发言人   23:07<br>So these are real vulnerabilities, and we’ll talk in a minute a little later about how you as a programmer can be a little smarter than this, but in their sort of raw form as presented, they have this vulnerability to them.<br>所以这些是真正的漏洞，我们稍后会谈到作为一名程序员如何比这更聪明一些，但在他们所呈现的原始形式中，他们有这种漏洞。</p><p>发言人   23:24<br>So let’s look at an example of what can happen there. So imagine, for example, we want to implement an echo function. So an echo function is one that you just type something in and it prints it back out. It’s a very uninteresting function, except it’s very useful to demonstrate things. So the idea is it has this little buffer, it’s only enough to hold four characters. It calls get us to read a string from the input, and then it calls put S, which simply writes back out the output.<br>让我们看一个例子，看看那里可能发生什么。想象一下，例如，我们想要实现一个echo函数。所以echo函数就是你只需要输入一些东西，然后它就会打印出来。这是一个非常无趣的功能，但它在演示方面非常有用。所以这个想法是它有一个小缓冲区，它只够容纳四个角色。它调用get来读取输入中的字符串，然后调用put S，这只是简单地写出输出。</p><p>发言人   24:10<br>And so let me just demo this not very interesting function.<br>所以让我演示一下这个不是很有趣的功能。</p><p>发言人   24:22<br>So I call it here buff demo dash Nsp, meaning it has no stack protector. We’ll see in a minute what a stack protector is. But you see, if you type a reasonably strong small string.<br>所以我在这里叫它buff demo dash Nsp，意思是它没有堆栈保护器。我们马上就会看到什么是堆栈保护器。但是你看，如果你键入一个相当强大的小字符串。</p><p>发言人   24:43<br>Let’s see I’ve got to remember it can handle more than 4. Actually, as written, it can’t handle more than three because there should be room for the null character too, our terminator.<br>让我们看看，我必须记住它可以处理4个以上的数据。实际上，正如所写，它不能处理超过三个，因为我们的终结者也应该有空字符的空间。</p><p>发言人   25:04<br>So it turns out with this particular one, if I type in a string of 24 characters, it’ll be okay.<br>所以事实证明，对于这个特定的一个，如果我输入24个字符的字符串，就没问题了。</p><p>发言人   25:23<br>But if I type in a string of 24 characters. It will hit a segmentation fault. So where do those numbers, 20 thre and 24, come in. Well, that’s something we can learn by looking at the assembly code.<br>但是如果我输入了一个24个字符的字符串。它会碰到一个段的故障。那么这些数字20 thre和24在哪里出现呢？嗯，这是我们可以通过查看汇编代码来学习的东西。</p><p>发言人   25:58<br>So here, and we’ll go through this code. So first of all, this is the code for Echo then. And you see the echo calls get S, and it calls put S. And here’s the part of the code where you can tell how much memory got allocated for the buffer and x 1, 8.<br>所以在这里，我们将浏览这段代码。首先，这是Echo的代码。你会看到echo调用get S，它调用put S。这是代码的一部分，您可以告诉缓冲区和x 1、8分配了多少内存。</p><p>发言人   26:29<br>Is what in decimal? 24, right? And you just saw that the thing actually seg faults with an input string of 24. So we’ll see that in a minute. But anyways, you can see here that it’s allocating on the stack a region of 24 B and it’s. Copying that into RGI, which is of course the argument for Get us, so Get us, is being called with a pointer to a buffer of size 24 of maximum 24. Even though you saw the original declaration was just for four. And then it calls. And then Geddes does it thing. And just one last good bit to keep in mind is we’ll get back to that.<br>十进制是什么？24对吧？你刚刚看到这个东西实际上用输入字符串24来切断故障。所以我们马上就会看到。但无论如何，你可以在这里看到它在堆栈上分配了一个24 B的区域。将其复制到RGI中，这当然是Get us的参数，所以Get us正在被调用，并使用一个指针指向一个最大24大小的缓冲区。尽管你看到最初的声明只有四个。然后它打电话。然后格迪斯做了这件事。最后一点需要记住的是，我们会回到那个问题的。</p><p>发言人   27:34<br>Oh, yes, and remember Echo? There’s a function called call echo, which is the thing that calls echo. And just to keep in mind, this red is the return address for call echo. And that’s going to be important. So what we see then is the memory layout is. Buff is normally big enough for four characters. There’s sort of 20 B of unused or wasted space here. And then the actual return address, which is the return address for back to call Echo, is stored on the stack.<br>哦，是的，还记得回声吗？有一个叫做call echo的函数，它是调用echo的东西。请记住，这个红色是呼叫回声的返回地址。这将是很重要的。所以我们看到的是内存布局。Buff通常足够容纳四个字符。这里有20 B未使用或浪费的空间。然后，实际的返回地址 (即回叫Echo的返回地址) 存储在堆栈上。</p><p>发言人   28:25<br>So when this program begins running, when Echo starts to run, we’ll find that this is the value on the stack for the return pointer. And if we type in a string of. Of here of 23 characters, you’ll see that it uses up this entire buffer. And remember, a string is terminated with a 0 0, but it’s still within the region that was allocated on the stack for that fits into the stack. And that’s why technically we overflow the buffer. But we didn’t really cause any harm because there was this extra space available. And so that’s why I could type in that string of 23 characters and it worked fine. But now if I type in. This is an example showing.<br>所以当这个程序开始运行时，当Echo开始运行时，我们会发现这是堆栈上返回指针的值。如果我们输入一个字符串。如果这里有23个字符，你会看到它使用了整个缓冲区。记住，字符串以0结尾，但它仍然在堆栈上分配的适合堆栈的区域内。这就是为什么从技术上讲我们溢出缓冲区的原因。但我们并没有真正造成任何伤害，因为有这个额外的可用空间。这就是为什么我可以输入23个字符的字符串，并且它工作得很好。但是现在如果我输入。这是一个展示的例子。</p><p>发言人   29:31<br>Actually, 25 characters. So once I go beyond the 23 characters plus the null character, you’ll see what I’m slowly starting to do is, is corrupt the byte representation of the return address? And so what happens, for example, here is that rather than trying to return back to where call echo, where it was supposed to go back to, it goes back to some other part of your code that may or may not be a valid address or might not have anything to do with the program you’re trying to run. So this example shows it. And if I typed in the 24.<br>实际上，25个字符。所以一旦我超过了23个字符加上空字符，你会看到我慢慢地开始做的是，返回地址的字节表示是否已损坏？所以发生了什么，例如，这里不是试图返回到呼叫回声应该返回到的地方，它会返回到代码的其他部分，这些部分可能是或可能不是有效的地址，或者可能与您尝试运行的程序没有任何关系。这个例子说明了这一点。如果我输入24。</p><p>发言人   30:24<br>Let’s see, before I got it to run. This thing depends on what happens, how the code happens to get compiled. Oh yeah, so. Actually, you see here, this first string I typed is actually 24 characters long plus the null pointer. So, and we’ll see why it didn’t. It should have crashed because we actually overwrite wrote the low order byte of the return address here. We typed in, this is 2500 characters, and so that’s the 1 I just showed where it really whacked the 2 B of the return address. So here we actually did overflow the buffer. And let’s try and figure out why that didn’t harm the program execution.<br>让我们看看，在我运行之前。这取决于发生了什么，代码如何被编译。哦，是的，所以。实际上，你看这里，我输入的第一个字符串实际上有24个字符加上空指针。所以，我们会看到为什么它没有。它应该已经崩溃，因为我们实际上在这里覆盖了返回地址的低位字节。我们输入了，这是2500个字符，这就是我刚刚展示的1，它确实破坏了返回地址的2 b。所以这里我们实际上确实溢出了缓冲区。让我们试着弄清楚为什么这没有损害程序的执行。</p><p>发言人   31:19<br>I see a question in this case, but is it possible there could have been, there could have been various other things, could have nothing? It hit a segmentation fault because it probably went to some weird part of the code and just started executing some random stuff and just got itself into trouble. But that’s the point is it’s not predictable exactly what will happen when you do this.<br>在这种情况下，我看到了一个问题，但是否可能存在，可能存在各种其他事情，可能什么都没有？它遇到了一个段故障，因为它可能进入了代码的某个奇怪的部分，并开始执行一些随机的东西，从而让自己陷入了麻烦。但关键是当你这样做时，无法准确预测会发生什么。</p><p>发言人   31:54<br>So this is an example of what actually happened the first time when I typed in a string that had 24 characters. And so this null byte at the index where corrupted the return address. And so it was supposed to return back to this address for 0 0 6 F 6. And instead, it will return back to the address 4 0 6 0 0, which happens to be in some other weird function that’s there.<br>所以这是一个例子，当我第一次输入一个有24个字符的字符串时实际发生了什么。因此，索引处的这个空字节损坏了返回地址。所以它应该在0 0 6 F 6返回到这个地址。相反，它将返回地址4 0 6 0 0，该地址恰好在某个其他奇怪的函数中。</p><p>发言人   32:24<br>And it just sort of landed at some place here. And it’s doing various things. But somehow it really didn’t crash the program. And that’s one of the frustrating things about this is things can go wrong in a program and they don’t always cause a crash. And so often a bug that’s working there might be doing some weird stuff that you don’t even know about. So that’s all fine if it’s just a way of crashing programs. I mean, that’s not great if it’s controlling your pacemaker or something like that. If it’s just a homework assignment, it’s not a big deal.<br>它只是降落在这里的某个地方。它正在做各种各样的事情。但不知何故，它真的没有使程序崩溃。这是令人沮丧的事情之一，在一个程序中，事情可能会出错，而且它们并不总是会导致崩溃。而且经常有一个bug在那里工作，可能会做一些你甚至不知道的奇怪事情。所以如果这只是一种使程序崩溃的方法，那也没关系。我的意思是，如果它控制着你的起搏器或类似的东西，那并不好。如果这只是一份家庭作业，那也没什么大不了的。</p><p>发言人   33:12<br>But what actually, and this is sort of only happened since attacking, became a normal activity, which has only been the last 30 years, is that it gives an opportunity for attacker or attacker to inject code into the program and execute it. And that’s what’s called a code injection attack.<br>但实际上，这种情况只是在攻击成为正常活动之后才发生的，这只是最近30年的事情，它为攻击者或攻击者提供了将代码注入程序并执行它的机会。这就是所谓的代码注入攻击。</p><p>发言人   33:38<br>And so the general scheme of it is I have this buffer that I can fill up with whatever bytes I want by feeding them to get S or whatever function is doing this copying. And what I can do then is set up and pass to it some bytes that encode an executable, a little bit of executable code you’ve seen in object dump. It’s printing out these byte code representations of instruction.<br>因此，它的一般方案是我有一个缓冲区，我可以通过供给它们以获取S或任何正在进行此复制的函数来填充我想要的任何字节。然后我可以做的是设置并传递给它一些编码可执行文件的字节，一点点可执行代码，你在对象转储中看到过。它正在打印出这些指令的字节码表示。</p><p>发言人   34:05<br>So imagine you fed some of those bytes into your string. You encode them in the string that you pass to get S, and then you might have to add some more sort of paddings, characters whose value doesn’t matter, in order to then get a number back into the position where the return pointer is supposed to be. And so what’s called that number B? It’s going to be an address. One of these ones with that represents a stack location. And value B, then, is the starting address of the buffer, which happens to be where your exploit code.<br>想象一下你将其中一些字节输入到你的字符串中。你将它们编码在传递给获取S的字符串中，然后你可能需要添加更多类型的填充，值无关紧要的字符，以便将数字放回返回指针应该所在的位置。那么那个数字B叫什么？这将是一个地址。其中一个代表堆栈位置。值B是缓冲区的起始地址，恰好是您的利用代码所在的位置。</p><p>发言人   34:50<br>Remember, this is just executable instructions we’re stored here. So now what will happen is when the program does its return. Here it was supposed to return back to wherever it got called from P?<br>记住，这只是我们存储在这里的可执行指令。所以现在会发生的是当程序返回时。在这里，它应该返回到它从P被召唤的地方？</p><p>发言人   35:13<br>This is a type O p calls q, not bar. So it’s supposed to return back to P? And the return address was stored here, but now I’ve overwritten that return address with this buffer position. So what will happen is the program counter will happily jump to this spot and start executing whatever it encounters, which are the instructions that you’ve inserted. And by that means, then you can inject code into a machine, potentially somewhere else in the internet. If you could set up a scheme like this that would feed these bytes into that machine, and it would read it in with a function like gets, and then it would try to do its return, but it would start executing your code. So that’s a classic code injection attack.<br>这是一种O p类型调用q，而不是bar。所以它应该返回到P？并且返回地址存储在这里，但是现在我已经用这个缓冲区位置覆盖了该返回地址。所以会发生的是程序计数器会很高兴地跳转到这个位置，并开始执行它遇到的任何事情，即你插入的指令。通过这种方式，你可以将代码注入机器，可能是在互联网的其他地方。如果你可以建立一个像这样的方案，将这些字节输入到那台机器中，它会使用像gets这样的函数读取它，然后它会尝试执行它的返回，但它会开始执行你的代码。所以这是一种典型的代码注入攻击。</p><p>发言人   36:11<br>And in fact, in this lab that you’re going to start, it comes out at midnight. It’s called the attack lab because you’re going to do this yourself for part of the lab. And I think you’ll find it pretty interesting. So this used to be a huge problem on programs.<br>事实上，在这个你要开始的实验中，它在午夜结束。它被称为攻击实验室，因为你将自己为实验室的一部分做这件事。我想你会发现它很有趣。所以这曾经是程序上的一个大问题。</p><p>发言人   36:37<br>Yes, on the last slide. So when you’re trying to replace red, how do you make sure that your new submitted red? Well, that’s part of the cleverness of being a hacker. You have to make sure it’s in the right spot, but that’s actually one of the easier parts because, for example, if you have to know the binary code. To be able to do this or be able to guess. So for example, in that previous 1, I could tell that it was allocating 24 B for that buffer. So if I just made sure that the length of my exploit code plus the padding is 24 B, then right after that comes to the return address. So that’s actually pretty easy to do much program.<br>是的，在最后一张幻灯片上。那么当你试图替换红色时，你如何确保你新提交的红色？好吧，这是作为一名黑客聪明的一部分。你必须确保它在正确的位置，但这实际上是更容易的部分之一，因为例如，如果你必须知道二进制代码。能够做到这一点或者能够猜测。所以例如，在之前的1中，我可以看出它为该缓冲区分配了24 b。所以如果我只是确保我的漏洞利用代码的长度加上填充是24 B，那么接下来就是返回地址。所以这实际上很容易做很多程序。</p><p>发言人   37:25<br>No, you have to have access. The reason why this works is. It works if you have enough knowledge about the operating system that’s running at the other end. For example, you know it’s Linux. You know that you can look at what GCC tends to allocate for it, or you somehow have access to information about the code itself, letsgo do this.<br>不，你必须有访问权限。这个工作的原因是。如果您对另一端运行的操作系统有足够的了解，它就会起作用。例如，你知道它是Linux。你知道你可以查看GCC倾向于为它分配什么，或者你以某种方式有权访问代码本身的信息，让我们这样做。</p><p>发言人   37:59<br>So anyways, this used to be a huge problem and it started way back in 1988, the first internet attack called the Morris Worm. And at the time, the internet was not a very big place and it basically brought down a huge fraction of the machines that were on the internet at the time. Interestingly enough, CMU did not fall victim to this attack because we’d patched already the vulnerabilities that this particular program exploited. And that was the cause that the Software Engineering Institute runs an organization called Cert, the Computer Emergency Response Team. And that team was set up in response to this attack, the Morris worm attack.<br>所以无论如何，这曾经是一个巨大的问题，它开始于1988年，第一个被称为莫里斯蠕虫的互联网攻击。当时，互联网不是一个很大的地方，它基本上导致了当时互联网上很大一部分机器的崩溃。有趣的是，CMU并没有成为这次攻击的受害者，因为我们已经修补了这个特定程序利用的漏洞。这就是软件工程研究所运营一个名为Cert的组织，即计算机应急响应团队的原因。那个团队就是为了应对莫里斯蠕虫的攻击而建立的。</p><p>发言人   38:51<br>We’ll also see an interesting example between two companies in messaging services and many others. It’s been the sort of standard attack mechanism for many years. And fortunately, nowadays, there’s a few things that make the attacking less likely to be successful. And so it’s not as huge a problem as it used to be, but still, it’s as far as some many vulnerabilities in programs.<br>我们还将看到两家消息服务公司和许多其他公司之间的有趣例子。多年来，它一直是标准的攻击机制。幸运的是，如今有一些事情使得攻击不太可能成功。因此，这不再是一个像以前那样巨大的问题，但仍然存在程序中的许多漏洞。</p><p>发言人   39:21<br>So let’s see, I won’t talk too much about this, but it used to be in the original implementation of there’s a command that most systems have now disabled that you could finger, you could request information about somebody in some remote location. It would send a message to that location, and then it would reply back. And it used gets the actual original implementation called, gets to read the input string from that was being sent to it.<br>所以让我们看看，我不会过多谈论这个，但它曾经是在最初的实现中，现在大多数系统都禁用了一个命令，你可以通过手指请求有关某个远程位置的某人的信息。它会向该位置发送消息，然后回复。它使用获取实际的原始实现，获取要发送给它的输入字符串。</p><p>发言人   39:58<br>And then there was an interesting one. You guys don’t remember messaging, instant messaging. But before it used to be that people would talk to each other on their computers by sending messages, sort of like you send text messages today.<br>然后有一个有趣的。你们不记得即时通讯了。但以前人们会在电脑上通过发送信息相互交流，有点像今天你发送短信。</p><p>发言人   40:14<br>But there is an interesting thing that there is a company still exists, but it’s a shadow, its former self called AOL, which ran the most popular internet services and had the most popular instant messaging program. And Microsoft came out with its client, its own program that you could run on your machine and communicate to other people on this messaging system. So the Microsoft code was running on your machine, but it would use the servers that were being run by AOL to manage this messaging traffic and. The funny story was. This Microsoft program would work fine. You could communicate with your friends who had different messaging clients, and it all seemed compatible.<br>但是有一件有趣的事情，那就是有一家公司仍然存在，但它只是一个影子，它以前的名字叫AOL，它运营着最受欢迎的互联网服务，并拥有最受欢迎的即时通讯程序。微软推出了它的客户端，它自己的程序，你可以在你的机器上运行，并通过这个消息系统与其他人通信。因此，Microsoft代码正在您的计算机上运行，但它将使用AOL运行的服务器来管理此消息传递流量。有趣的故事是。这个微软程序可以正常工作。您可以与拥有不同消息客户端的朋友进行通信，并且看起来都兼容。</p><p>发言人   41:11<br>Suddenly, the people that were running the Microsoft version of the software, it wouldn’t work. And then Microsoft people figured out how to patch it, and then it would work for a while, and then it wouldn’t work.<br>突然间，那些运行微软版本软件的人无法工作。然后微软的人想出了如何修补它，然后它会工作一段时间，然后它就行不通了。</p><p>发言人   41:22<br>And the way what was happening was AOL was using a bug in its own code to be able to determine who’s basically peek into the machines on the client side and do a buffer overflow attack on your code that you’re running on your machine. And then basically peek around and see, does this look like AOL code or is it some foreign code? And so it was basically able to use its own security weakness to figure out this information. And that got disclosed by a sort of funny message from somebody who called himself Phil Bucking. And it was determined that this email originated from somewhere within Microsoft. So anyways, and you can read more about it in the book around the slide fun stories.<br>而发生的事情是AOL在自己的代码中使用了一个错误，以便能够确定谁基本上是窥视客户端的机器，并对您在机器上运行的代码进行缓冲区溢出攻击。然后基本上看看，这看起来像AOL代码还是一些外国代码？因此，它基本上能够利用自己的安全弱点来找出这些信息。这个消息被一个自称Phil Bucking的人透露出来了。并且已确定此电子邮件起源于Microsoft内部的某个地方。所以无论如何，你可以在书中围绕幻灯片有趣的故事阅读更多关于它的内容。</p><p>发言人   42:24<br>So in general, in the security world, you’re supposed to distinguish between the idea of a worm and a virus, although people aren’t very good at doing that. So worm is a program that can run on its own and propagate itself from one place to the other and replicate it. A virus is like a biological virus. It doesn’t live on its own. It works by attacking a program and basically modifying that program’s behavior. So that gives you the basic idea of buffer overflows, and you’ll see it more first-hand.<br>所以一般来说，在安全领域，你应该区分蠕虫和病毒的概念，尽管人们不太擅长这样做。所以蠕虫是一种可以独立运行并从一个地方传播到另一个地方并复制它的程序。病毒就像生物病毒。它不会自己生活。它的工作原理是攻击程序并基本上修改该程序的行为。这样就给了你缓冲区溢出的基本概念，你会更直接地看到它。</p><p>发言人   42:59<br>So let’s look at techniques that machines can use to avoid, to make themselves less vulnerable to these attacks.<br>所以让我们看看机器可以用来避免的技术，使自己不那么容易受到这些攻击。</p><p>发言人   43:08<br>Well, first of all, you application or the writer on the server side can write code that’s more secure. So for example, what you’re supposed to do instead of get SI use a function called FGE s, and f gets has a property that it passes a parameter, which is the maximum number of bytes that the program should read. And if there’s more bytes than that in the input, it will just truncate the input. So you’re really supposed to use f gets and give a limit. Similarly, stir copy. There’s a version of called Stern copy where you can give a limit. And with scanf, you’re supposed to be careful about using the percent s, there’s even a terminology, you can say percent given a number that the maximum length of the string it should read.<br>首先，您的应用程序或服务器端的作者可以编写更安全的代码。所以举个例子，你应该使用一个叫做FGE s的函数来代替get SI，而f gets有一个属性，它传递一个参数，这个参数是程序应该读取的最大字节数。如果输入中的字节数多于这个字节数，它将只截断输入。所以你真的应该使用f gets并给出一个限制。同样地，搅拌复制。有一个叫做斯特恩复制的版本，你可以给出一个限制。使用scanf，你应该小心使用百分比，甚至还有一个术语，你可以说百分比给定一个数字，它应该读取的字符串的最大长度。</p><p>发言人   44:06<br>So there’s various places you can protect your code to make sure it won’t overflow buffers, unfortunately. And a lot of code has been, you’d call it hardening. People have gone through it. And it’s a lot of work because there’s a lot of places in programs where you’re copying strings from one place to another. And there are a lot of real subtleties, like when you’re converting from Unicode to bytes and so forth, you’re going back and forth between different character encodings. But for the large part, and those tools that the code developers have created to help track down these bugs. So it’s become a little bit safer out there, but there’s still vulnerabilities.<br>所以有很多地方可以保护你的代码，以确保它不会溢出缓冲区。很多代码已经被你称之为硬化。人们经历过它。这需要很多工作，因为在程序中有很多地方需要将字符串从一个地方复制到另一个地方。而且有很多真正的微妙之处，比如当你从Unicode转换成字节等等时，你就在不同的字符编码之间来回切换。但是在很大程度上，以及代码开发人员创建的用于帮助追踪这些错误的工具。所以外面变得有点安全，但仍然存在漏洞。</p><p>发言人   44:51<br>So then there’s other parts where you just try to build in safeguards into the system that would make it much harder to do a buffer overflow exploit like I showed you. And so one of them is called stack randomization, or it goes by a more general term. That’s abbreviated Aslr, which stands for address space. Layout randomization. And the idea of it is to make it so every time a program runs, the addresses change a little bit or a lot so that you can’t reliably know where things are going to be in the code. So imagine, for example, and the way it’s implemented is in the sort of run up of your program when it first starts up, but before your main routine gets called, it will just do an allocation on the stack of some random number of bytes of storage, a fair amount, like maybe a megabyte roughly of storage, where the exact number is randomly chosen. And what that means is that the dress of the stack of all the different positions of your, all the local storage on the stack will shift up and down from one run to another. And we can actually see that in this example I showed.<br>因此，还有其他部分，您只需尝试在系统中建立保护措施，这将使缓冲区溢出利用变得更加困难，就像我向您展示的那样。因此，其中一个被称为堆栈随机化，或者用一个更通用的术语来表示。它缩写为Aslr，代表地址空间。布局随机化。它的想法是让每次程序运行时，地址都会发生一点点或很多变化，这样你就无法可靠地知道代码中的内容将会在哪里。例如，想象一下，它的实现方式是在程序首次启动时启动，但在调用主例程之前，它将在堆栈上分配一些随机数量的存储字节，相当数量，大概是一兆字节的存储空间，其中确切的数字是随机选择的。这意味着，堆栈的所有不同位置的衣服，堆栈上的所有本地存储将从一个运行到另一个运行上下移动。在我展示的这个例子中，我们实际上可以看到。</p><p>发言人   46:36<br>So I have a program here. It’s not a very interesting program I’ll show you, except to demonstrate these ideas. All it’s doing is there’s some code it’s based on that 1 I already showed called locate. This one, there’s a global variable, there’s some functions, there’s something that gets allocated by malloc, and there’s something that is a local variable stored on the stack. And so what I’ll do is show addresses that are chosen, the address of this variable. Then we will be stack address of a local variable. Global will be this one that gets allocated globally.<br>所以我在这里有一个计划。除了演示这些想法之外，我将向您展示的程序不是一个非常有趣的程序。它所做的只是有一些代码，它基于我已经展示过的那个叫做locate的代码。这个有一个全局变量，有一些函数，有一些由malloc分配的东西，还有一些存储在堆栈上的局部变量。所以我要做的就是显示选择的地址，这个变量的地址。那么我们将成为本地变量的堆栈地址。全球将是全球分配的。</p><p>发言人   47:22<br>The heap is something allocated with malloc, and then this function useless, we’ll count as a code address. And now when I run it. You’ll see from one run to another that if some of these stay the same in stem of them change. So in particular, the global variable is the same 6001 2 c, and the code is the same 4 0 0 5 9 0 is the same every execution. But you’ll see this local variable.<br>堆是用malloc分配的，然后这个函数就没用了，我们就算作一个代码地址。现在当我运行它的时候。你会发现，如果其中一些在词干保持不变，它们会发生变化。特别地，全局变量是相同的6001 2 c，代码是相同的4 0 0 5 9 0每次执行都是相同的。但你会看到这个局部变量。</p><p>发言人   48:02<br>It’s a stack address. But you see that the lower half dozen or so bytes are actually changing from one run to another. One, 2, 3, 4, 5. So 5 B of thats? Well, five hex digits. I’m sorry, so that’s two to the 20th. So roughly a megabyte of variation is going on in stack addresses there. And similarly, you’ll see that the heap addresses are also varying from one to another, from one execution to the other.<br>这是一个堆栈地址。但是你可以看到下半部分大约十几个字节实际上正在从一个运行变为另一个运行。一，二，三，四，五。那么5 B呢？嗯，五个十六进制数字。对不起，这是2比20。因此，在堆栈地址中大约有一兆字节的变化正在发生。同样地，您会看到堆地址也因执行而异，从一个执行到另一个执行。</p><p>发言人   48:36<br>So malloc has built into it some amount of randomness too, in its allocation. So why is that? What’s the purpose of that?<br>所以malloc在它的分配中也加入了一些随机性。为什么呢？这样做的目的是什么？</p><p>发言人   48:48<br>As I told you, this code injection vulnerability. Relies on the fact that you can load up this buffer with some executable code, but somehow you have to know how to get to the start of that code. And so the attack is relying on the fact that it can somehow predict what the this address of the buffer is so that it can store it in the right of the string, encode it in the right part of the string, so it will show up where the return point is supposed to be, and have it jump to that location. But now with this randomization, this number is varying by quite a bit, sort of a million over a range of 1 million or so values. So there’s no way in advance, even if I have an exact copy of the code, and I even had access to the system itself and could run it, I can’t predict from one run to the next where it’s going to be. So that gives sort of thwarts this particular attack to make it using this randomization.<br>正如我告诉你的，这个代码注入漏洞。依赖于这样一个事实: 你可以用一些可执行代码加载这个缓冲区，但不知何故，你必须知道如何到达代码的开头。因此攻击依赖于它可以以某种方式预测缓冲区的地址，以便它可以将其存储在字符串的右侧，将其编码在字符串的右侧，因此它将显示返回点应该在哪里。并让它跳到那个位置。但是现在有了这种随机化，这个数字变化很大，在100万左右的范围内变化有一百万。所以即使我有代码的精确副本，即使我可以访问系统本身并可以运行它，我也无法预测它从一次运行到下一次运行的位置。因此，这在某种程度上挫败了这种特定的攻击，使其使用这种随机化。</p><p>发言人   50:06<br>Another idea that’s fairly straightforward, but it took a long time for the hardware people to implement this is, well, why is there supposed to be code on the stack in the first place? Isn’t the code supposed to be located down in the text segment where it can be especially identified as being executable?<br>另一个相当简单的想法，但是硬件人员花了很长时间才实现，那么，为什么一开始就应该在堆栈上有代码呢？难道代码不应该位于文本段下面，在那里它可以被特别识别为可执行的地方吗？</p><p>发言人   50:29<br>So in the original x 86, there is a 1 b flag for each region of memory saying, is it actually 2 1 b flags? One is, can this be written to so that you can prevent overwrites of things like string constants? And so? And then the other is, can I read it? And read means access those bytes and it was interpreted that readable and executable were the same. I can read it, I can execute it. And that was the rules in the sort of last 10 years or so, starting first with AMD and then Intel.<br>所以在原始的x86中，每个内存区域都有一个1 b的标志，它实际上是2个1 b的标志吗？一个是，是否可以将其写入以防止覆盖诸如字符串常量之类的内容？所以呢？然后另一个问题是，我可以读吗？和读意味着访问这些字节，它被解释为可读和可执行的是相同的。我可以阅读它，我可以执行它。这就是过去10年左右的规则，首先是AMD，然后是英特尔。</p><p>发言人   51:12<br>I’ve added a third bit that says, is this executable or not? Similarly to the permissions you have on a file on Unix, is it readable, writable, executable? Those are three separate permission debts that are allowed. So by simply marking the stack is not executable, it’ll also thwart this particular attack because I have to be able to execute these bytes that I’ve injected into the system.<br>我已经添加了第三个位，上面写着，这个可执行文件吗？类似于您在Unix上对文件拥有的权限，它是可读、可写或可执行的吗？这是三个允许的独立许可债务。因此，通过简单地将堆栈标记为不可执行，它也将阻止此特定攻击，因为我必须能够执行我注入系统的这些字节。</p><p>发言人   51:40<br>And then there’s a final idea, which is actually fairly effective too, which they call a canary that they built into the stack. And some of you actually encountered this code already. And looking at your bombs, because we’ve been getting some questions about it. So let me just give you an example here.<br>然后还有一个最终的想法，实际上也相当有效，他们称之为金丝雀，他们内置到堆栈中。你们中有些人已经遇到过这段代码了。并看着你们的炸弹，因为我们一直在收到一些问题。让我在这里给你一个例子。</p><p>发言人   52:09<br>And this one’s called Buff Demo Dash S because it’s been compiled with what they call a stack protector and.<br>这个叫做Buff Demo Dash，因为它是用所谓的堆栈保护器编译的。</p><p>发言人   52:20<br>This one now, it’s the same code as before. It’s just compiled a little bit differently. What you’ll find is I can give a string of length 8 and not have a problem. But if I now have 9 characters, it will dump out with this very strange exit error message. That is an indication. That it’s detected? Attempt to smash the stack. So buffer overflow is sometimes called stack smashing. So it detected somehow that even though my code was still the same old crappy code from before, a very small buffer allocation and no protection, somehow the system protected me from myself. And that’s by a relatively simple trick. That’s fairly clever, though.<br>现在这个代码和以前一样。它只是编译得有点不同。你会发现，我可以给出一个长度为8的字符串，而不会有问题。但是如果我现在有9个字符，它将转储出来，并显示这个非常奇怪的退出错误消息。这是一个指示。被检测到吗？试图打破堆栈。因此缓冲区溢出有时被称为堆栈粉碎。因此，它以某种方式检测到，即使我的代码仍然是之前的旧糟糕代码，缓冲区分配非常小，没有保护，系统还是以某种方式保护了我自己。这是通过一个相对简单的技巧实现的。不过，这相当聪明。</p><p>发言人   53:21<br>What they call a stack canary. So the term canary comes back from back in the coal mining days of old before they had very good ways of measuring things. They’d take a bird down with them in a cage. And a canary is a property that it’s very susceptible to dying if there’s methane gasps present. So these miners would be down there working, and they’d see their bird keel over and say, oh, we got a problem here, let’s get out fast. So that’s why they call it a canary in a coal mine, sometimes some kind of warning signal that something’s not right here.<br>他们称之为堆栈金丝雀。因此，“金丝雀” 一词来自过去的煤炭开采时代，那时还没有很好的测量方法。他们会把一只鸟带到笼子里。金丝雀是一种财产，如果有甲烷气体存在，它很容易死亡。所以这些矿工会在那里工作，他们会看到他们的鸟倒下说，哦，我们这里有问题了，让我们快点出去。这就是为什么他们称之为煤矿里的金丝雀，有时是某种警告信号，表明这里有东西。</p><p>发言人   54:05<br>And in general with GCC, if you invoke it with a stack protector nowadays, that’s the default. So even without you saying anything, this code will get built into it. And so let’s look at what that canary code looks like and how it does its thing. It’s really pretty clever, as I said.<br>一般来说，对于GCC，如果你现在使用堆栈保护器来调用它，那就是默认的。所以即使你不说话，这段代码也会被内置到其中。那么让我们来看看那个金丝雀代码是什么样子的，以及它是如何发挥作用的。就像我说的，这真的很聪明。</p><p>发言人   54:28<br>And some of you have already observed, this strange kind of memory reference in a register, reference in the code in your bomb labs, because it was compiled with the Stack Protect enabled, because that’s the default. And so in particular, what this code shows is it’s allocating, as before, 24 B on the stack. But now it’s getting some number. And we’ll talk in a second what that means and storing it at position 8 offset from the stack pointer and then the rest of the code, and then it zeroes it out not to worry. And then it looks like your previous code that it’s passing a pointer to the stack, the top of the stack, as the argument to get us and get S gets called, and then put S gets called. But now there’s some more code here that involves this strange looking register, and then there’s some kind of test, and then if that test fails, it will call this code that you just saw printed out, this error message.<br>你们中的一些人已经观察到，这种奇怪的内存引用在寄存器中，引用在你们炸弹实验室的代码中，因为它是在启用了堆栈保护的情况下编译的，因为这是默认的。因此，特别地，这段代码显示的是它像以前一样在堆栈上分配24 b。但现在它得到了一些数字。我们稍后会讨论这意味着什么，并将其存储在距离堆栈指针偏移的位置8处，然后将其余代码存储起来，然后将其归零，不用担心。然后它看起来像你之前的代码，它正在传递一个指向堆栈顶部的指针，作为让我们调用get S的参数，然后调用put S。但是现在这里有更多的代码涉及这个奇怪的寄存器，然后有某种测试，如果测试失败，它将调用你刚刚看到的打印出来的代码，这个错误消息。</p><p>发言人   55:46<br>So let’s see what that all means.<br>让我们看看这一切意味着什么。</p><p>发言人   55:48<br>What that means is that at offset 8 from the stack pointer, it’s putting in 8 B of value that it’s retrieving from a special register. So FS is a reference to a type of register that was created for the original 8086 and is now completely obsolete, but it’s still there for backward compatibility mode. But what it is, and actually I’ve looked and I’ve never fully been able to find the documentation on it, it’s able to read from a part of memory, a set of values that you can’t otherwise get to. And so that’s the canary’s getting somehow. It’s grabbing 8 B from somewhere, storing it as the canary value. And then if you give like a 7 character input, so you would affect the canary. So what happens when it returns from? The two calls from Get S and put S before it exits.<br>这意味着在堆栈指针的偏移量8处，它放入了从特殊寄存器检索的8 B的值。所以FS是对一种为原始8086创建的寄存器类型的引用，现在已经完全过时了，但它仍然存在，用于向后兼容模式。但它是什么，实际上我已经看过了，我从来没有完全能够找到关于它的文档，它能够从内存的一部分读取一组你无法以其他方式获得的值。所以这就是金丝雀不知怎么的。它正在从某个地方抓取8 B，将其存储为金丝雀值。然后，如果你输入了7个字符，那么你就会影响金丝雀。那么当它从返回时会发生什么？在退出之前，从Get S和put S发出的两个调用。</p><p>发言人   57:01<br>What it’s trying to detect is, has anything, has this buffer somehow overflowed and potentially at risk of corrupting some other part of the stack?<br>它试图检测的是，有什么东西，这个缓冲区是否以某种方式溢出并可能有破坏堆栈其他部分的风险？</p><p>发言人   57:13<br>So basically what it does is it retrieves back from the stack what is the current value of this canary. And it’s comparing it to what it should be by retrieving that back from this special region. And if they’re equal, it says fine. But if they’re not equal, it’s detecting that it’s got corrupted. So just like the canary in the coal mine, if these bytes get corrupted in any form, it’s an indication that something went wrong. Now, that example shows that if I have a seven character string, then I’m not going to corrupt the canary. But you notice I just got away with an eight character string. So let me just see what’s going on here.<br>基本上，它的作用是从堆栈中检索这个金丝雀的当前值。它正在通过从这个特殊的地区取回它来比较它应该是什么。如果他们相等，那就说好。但如果它们不相等，它检测到它已经损坏了。就像煤矿里的金丝雀一样，如果这些字节以任何形式损坏，则表明出了问题。现在，这个例子表明，如果我有七个字符的字符串，那么我不会破坏金丝雀。但是你注意到我刚刚逃脱了一个八个字符的字符串。所以让我看看这里发生了什么。</p><p>发言人   58:14<br>Great.<br>太好了。</p><p>发言人   58:34<br>I want a character string, right? Oh, wait, wait, wait.<br>我想要一个字符串，对吧？哦，等等，等等。</p><p>发言人   58:47<br>Sorry, I don’t have the code in front of me, so I have to look at it.<br>抱歉，我面前没有代码，所以我必须看看它。</p><p>发言人   58:56<br>So anyways, here’s where subtracting 24 from the stack pointer. And then the next instruction is retrieving the canary value. So let’s figure out what the canary is. Right now we are at.<br>无论如何，这是从堆栈指针中减去24的地方。然后，下一指令正在检索金丝雀值。让我们弄清楚金丝雀是什么。现在我们在。</p><p>发言人   59:19<br>Seven 2 F, so we’re at the first instruction here.<br>七个2个F，所以我们在这里的第一个指令。</p><p>发言人   59:30<br>Let’s do another step.<br>让我们再迈出一步。</p><p>发言人   59:44<br>So this is the canary. And you’ll see actually, from one room to another, you get a different value of it. So it’s purposefully put in there in a way that it’s unpredictable. The one thing you’ll notice is that the low order byte is zeros. And so apparently they knew that it’s so common to have sort of off by one bugs with strings where you don’t allocate enough space for the no terminator that they said, well, rather than having a canary that will detect that bite being corrupted, we’ll just sort of give that bite away. And so that’s why it’s letting me type in eight characters and it’s overriding this low order bite of the canary later on. But that’s not going to affect anything.<br>这就是那只金丝雀。你会发现，从一个房间到另一个房间，你会得到不同的价值。所以它被有目的地以一种不可预测的方式放入其中。你会注意到的一件事是，低位字节是零。所以显然他们知道，有一个带有字符串的虫子，你没有为没有终结者分配足够的空间是很常见的，他们说，与其有一个金丝雀会检测到被破坏的叮咬，我们只是把那一口咬掉。所以这就是为什么它让我输入八个字符，并且稍后覆盖了这种低级的金丝雀咬合。但这不会影响任何事情。</p><p>发言人   01:00:57<br>But let’s give it 9 characters, 10 character string, a 9 character string.<br>但让我们给它9个字符，10个字符的字符串，一个9个字符的字符串。</p><p>发言人   01:01:59<br>More well I’m not finding it where I thought it would be. Anyways. This well. Crop this stack. But what I was showing you, the main idea is the canary is some value that gets pulled out and it will vary from one time to the next. And it’s letting you get away with eight characters plus the null terminator, but anything more and it will detect that corruption.<br>更好的是，我没有在我想象的地方找到它。无论如何。这很好。裁剪这个堆栈。但是我向您展示的主要思想是，金丝雀是一些被拉出的价值，它会随着时间的推移而变化。它让你逃脱八个字符加上空终止符，但更多的是它会检测到损坏。</p><p>发言人   01:02:42<br>Okay, so now we’ve seen three different protection. Well, 4. One is write better code. But there’s three protections that are done by the system that have nothing to do with your code. One is 2. Randomize the stack position so it’s harder to figure out where the start addresses are. The second is to make the stack so it’s not executable. So you can’t put code on that. And then the third is to use a stack canary or other mechanisms to detect a potential buffer overflow at the source.<br>好的，现在我们已经看到了三种不同的保护措施。好吧，4。一是写更好的代码。但是系统有三种保护措施，与您的代码无关。一个是2。随机化堆栈位置，这样就很难确定起始地址在哪里。第二个是使堆栈不能执行。所以你不能在上面放代码。第三种方法是使用堆栈金丝雀或其他机制在源处检测潜在的缓冲区溢出。</p><p>发言人   01:03:20<br>So now there’s another attack that was developed in response to some of these. That is still often successful. It’s called return oriented programming. And for your attack web, you’re going to be doing these attacks too. That’s why the attack web is different than the old web. The old web just did code injection exploits, now you’re doing both code injection and return oriented programming. So the idea of this is if you’re a hacker, you’re frustrated because of these three techniques, stack randomization, non-executable stack, and canaries. Well, I can’t fix the canary problem that actually the canary is a pretty secure. Technique I’ve never seen anyone able to bypass a step canary, but the other two, you can do it using this technique.<br>所以现在有另一种攻击是针对其中一些而开发的。这仍然经常成功。这叫做面向返回编程。对于您的攻击网站，您也将进行这些攻击。这就是为什么攻击网与旧网不同的原因。旧的web只是进行了代码注入漏洞利用，现在您正在进行代码注入和面向返回编程。所以这个想法是，如果你是一名黑客，你会因为这三种技术而感到沮丧，即堆栈随机化、不可执行的堆栈和金丝雀。好吧，我无法解决金丝雀问题，实际上金丝雀是相当安全的。技术我从未见过有人能够绕过一步金丝雀，但其他两个，你可以使用这种技术来做到这一点。</p><p>发言人   01:04:20<br>And the strategy is so we don’t know where the stack is, but we could still, but we know where the code is because you saw in that example, the code my layout randomization was shifting the stack positions and the heat positions, but it wasn’t changing either global variables or or the code itself.<br>策略是，我们不知道堆栈在哪里，但我们仍然可以，但我们知道代码在哪里，因为你在那个例子中看到，代码的布局随机化正在改变堆栈位置和加热位置，但它并没有改变全局变量或代码本身。</p><p>发言人   01:04:45<br>So what if I can find some code that sort of already there in the existing part of the program and use that instead of my own code that I’ve injected? And of course, in general, you’re not going to find exactly lying there the exact program you want to execute that will cause whatever harm you intend to do, because that’s not usually compiled into most programs. But if I could sort of string together little segments of code and somehow put together a series of little sequences of code, maybe I can get something useful done. And so that’s the idea of this return oriented programming. And the idea of it is to find what are known as gadgets. And a gadget is a sequence of bytes that represent part of the executable program where the last byte, this is x 86 talking here, has hex value c 3, which is how the Ret instruction, the return instruction is encoded in x 8, 6, both I 3, 2 and x 8664.<br>那么，如果我能在程序的现有部分中找到一些已经存在的代码，并使用它来代替我自己注入的代码，那会怎样呢？当然，一般来说，你不会找到你想要执行的确切程序，这会造成你想要做的任何伤害，因为这通常不会编译到大多数程序中。但是如果我能把一小段代码串在一起，以某种方式把一系列小代码序列放在一起，也许我能完成一些有用的事情。这就是这种面向返回编程的思想。它的想法是找到被称为小工具的东西。小工具是一个字节序列，代表可执行程序的一部分，其中最后一个字节，这里是x86，具有十六进制值c 3，这就是Ret指令，返回指令如何编码为x8，6，I 3，2和x8664。</p><p>发言人   01:06:02<br>So as an example, the easy case is where there’s some function and it implements some operation that I might find useful as an attacker to be able to do. So for example, this function is computing a times b plus c, and if I look at just the last two instructions from there, one of them is a Lea, which is performing addition and the other is doing a return. So I can think of this, this little 5 B chunk, as a way, if I could get some data in registers, RDI, and RDX, then I could compute their sum and stick it in rax.<br>因此，作为一个例子，最简单的情况是，有一些功能并且它实现了一些操作，我可能会发现攻击者能够做这些操作很有用。因此，例如，这个函数正在计算a乘以b加上c，如果我只看那里的最后两条指令，其中一条是Lea，它正在执行加法，而另一条正在执行返回。所以我可以想到这个小的5 B块，作为一种方式，如果我能在寄存器、RDI和RDX中获取一些数据，那么我就可以计算它们的总和并将其粘贴在rax中。</p><p>发言人   01:06:48<br>So imagine taking your program you’re trying to execute and breaking it up into these good old fragments. And you want to somehow find a little block of code somewhere to implement each of these fragments. And then the interesting part is because each end in C 3, this return has this. Well, let me get to that in a minute. So that’s sort of the obvious way that you pull out.<br>所以想象一下，把你试图执行的程序分解成这些好的旧片段。你想以某种方式找到一小块代码来实现这些片段。然后有趣的部分是因为每个结尾都在c3中，这个返回值都有这个。好的，让我马上讲。所以这就是你拔出的明显方式。</p><p>发言人   01:07:12<br>This is an addition which you’d expect because that was in the original C code. But here’s an example of a gadget that has nothing to do with the original C code. It just happens to match the byte pattern of of some existing code. So this function seems to not do anything too terribly useful from a hacker’s point of view.<br>这是你所期望的一个加法，因为它是在原始的C代码中。但是这里有一个与原始C代码无关的小工具的示例。它只是碰巧与某些现有代码的字节模式匹配。所以从黑客的角度来看，这个功能似乎没有做任何太有用的事情。</p><p>发言人   01:07:40<br>But if you look at this particular byte sequence that happens to encode the instruction, move Q Rix to RDI, and C 3 encodes Rept. So, and you can see if this is at address 4D 9, that’s 4D 4 db, 4 DC, so it address 4 DC If you could start executing here, first do a move, and then it would do a return. So I’m sort of taking advantage of the fact in x 86, it’s this byte oriented instruction sequence. And if I sort of go off the aligned instructions, I can often find useful things to do. So that’s what’s called a gadget.<br>但是如果您查看这个恰好编码指令的特定字节序列，将qrix移动到RDI，然后c3编码Rept。所以，你可以看到这是否在地址4 d 9，那是4 d 4 db，4 DC，所以它地址4 DC，如果你可以从这里开始执行，首先做一个移动，然后它会做一个返回。所以我在利用x86中面向字节的指令序列的事实。如果我偏离了对齐的指示，我经常能找到有用的事情去做。这就是所谓的小工具。</p><p>发言人   01:08:30<br>And you might ask, well, what’s so special about having them end in a return? Well, imagine I could fill up my buffer instead of with executable code, I could fill it up with a series of gadget addresses. So each gadget then is some series of bytes where the final byte is C 3. And I’ll actually this I’ll position this at. Some place where you’re actually going to do the initial return instruction from before. If I can somehow get the program to return, execute a rep, right now, what it will do is return, we’ll pick an address off of the stack, pop an address, and begin executing. So that will start this code executing and it will hit the C 3, the Re instruction at the end, which will again take an address, pop it off the stack and executing. So we’ll start executing the second gadget.<br>你可能会问，让它们以回报结束有什么特别之处？好的，想象一下我可以用一系列小工具地址来填充我的缓冲区而不是可执行代码。所以每个小工具都是一些字节序列，其中最后一个字节是c3。我会把这个定位在这里。在某个地方，你实际上要执行之前的初始返回指令。如果我能以某种方式让程序返回，执行一个rep，现在，它将做的是返回，我们将从堆栈中选择一个地址，弹出一个地址，然后开始执行。这样就会开始执行这段代码，并会在最后执行C 3，即Re指令，这将再次获得一个地址，将其从堆栈中弹出并执行。所以我们将开始执行第二个小工具。</p><p>发言人   01:09:36<br>And so you’ll see what will happen is we’re effectively concatenating these pieces of code together where it’s using a rat to get from one part the end of one gadget to the start of the next.<br>所以你会看到会发生的事情是我们将这些代码有效地连接在一起，它使用老鼠从一个小工具的末尾到下一个小工具的开头。</p><p>发言人   01:09:49<br>And so that’s why it’s called return oriented programming. It’s a way instead of sequencing programs using a program counter like you normally do, you’re sequencing programs using the sort of peculiar behavior of this particular x 86, how returns work in that program. And remember, there’s enough x 86 out there that if I can find a way to attack them I’m in a pretty good place. It’s also possible to attack other processors this way too. It’s just particularly nice on x 86. So that’s the idea of return oriented programming.<br>这就是为什么它被称为面向返回编程。这是一种方法，而不是像通常那样使用程序计数器对程序进行排序，而是使用这个特定x86的特殊行为对程序进行排序，返回如何在该程序中工作。请记住，那里有足够的x86，如果我能找到攻击它们的方法，我就处于一个相当不错的位置。也可以用这种方式攻击其他处理器。它在x86上特别好。这就是面向返回编程的思想。</p><p>发言人   01:10:29<br>And you’ll do this yourself. You’ll find gadgets, string them together to do different things in the attack wheel. But I’ll point out that this still. Doesn’t. This stack canary idea is still successful at detecting buffer overflows fairly effectively.<br>你可以自己做。你会发现一些小工具，把它们串在一起，在攻击轮中做不同的事情。但我会指出这一点。不是。这个堆栈金丝雀的想法在相当有效地检测缓冲区溢出方面仍然成功。</p><p>发言人   01:10:56<br>So in your attack lab, for example, we’ve carefully compiled the code to make it vulnerable to these attacks. Otherwise, it would be a lot harder to We like if you could do this, you could probably go into the dark world and be very successful. But so we’re actually sort of exposing the vulnerability. But in the first part of the lab, you’re using code injection attack. So we’ve had to disable stack randomization and also make the stack executable. So we had to sort of. Return oriented programming, we re-enable that so that the stack is not executable. It keeps jumping around randomly, but we’ve turned off the stack canaries, so you’ll be able to overflow the buffer and put in your gadget addresses and build up attacks that way.<br>例如，在您的攻击实验室中，我们仔细编译了代码，使其容易受到这些攻击的攻击。否则，如果你能做到这一点，我们就会更难，你可能会进入黑暗世界并取得非常成功。但是，我们实际上是在暴露这个漏洞。但是在实验的第一部分，你正在使用代码注入攻击。所以我们不得不禁用堆栈随机化，并使堆栈可执行。所以我们不得不有点。返回导向编程，我们重新启用它，使堆栈不可执行。它一直在随机跳跃，但我们已经关闭了堆栈金丝雀，因此您将能够溢出缓冲区并放入您的小工具地址并以这种方式建立攻击。</p><p>发言人   01:12:02<br>So I think you’ll find by actually doing it, you’ll learn a lot more than you can by just hearing about it.<br>所以我认为你会发现，通过实际操作，你会学到比仅仅听到它更多的东西。</p><p>发言人   01:12:09<br>Oh, you might ask, why do we teach you this stuff, right? Are are we supposed to teach you to be good and not evil? Well, there’s a couple of reasons. One is you’re going to learn a lot about machine program execution, how stacks work, and how byte instructions are encoded and stuff like that. You’ll use the tools gdb, object dump and all those, even more than you did with the Bam web. So you’ll learn a lot. The other is we assume that you will work for forces of good to be a good person, you also know have to know what the bad people do. So part of it is too become more effective as a force for good.<br>你可能会问，为什么我们要教你这些东西，对吧？我们应该教你善良而不是邪恶吗？有几个原因。一是你将学到很多关于机器程序执行、堆栈如何工作、字节指令如何编码等方面的知识。您将使用gdb、对象转储等工具，甚至比使用Bam web还要多。所以你会学到很多东西。另一种是我们假设你会为善的力量努力成为一个好人，你也知道必须知道坏人会做什么。因此，它的一部分也变得更加有效，成为一种良好的力量。</p><p>发言人   01:12:56<br>Okay, so the final thing to talk about today is unions And the observation about a union in C is the declaration of it looks a lot like a struct where there’s these different fields and they’re named and they can have different types and they can be pointers to unions and all that stuff, but they’re actually totally different. What they do, you recall with a struct, what happens is it allocates enough memory for all the fields to coexist and potentially adding padding bytes for what a union does is it only allocates enough storage for the maximum field in it, and it assumes that you’re only going to be using one of the possible fields, and it will literally store these fields, get stored on top of each other, so that if you try to use multiple fields, you can mess things up, and it’s not for that purpose of doing multiple values is it for the purpose of, for example, if I know I’m only going to use one of these, or it’s another also a way to create essentially an alias that will let you reference memory in different ways.<br>好的，今天要讨论的最后一件事是联合，关于联合在C中的观察是它的声明看起来很像一个结构，其中有这些不同的字段，它们被命名，它们可以有不同的类型，它们可以是指向联合和所有这些东西的指针。但它们实际上完全不同。他们的所作所为，你记得有一个结构，它会为所有字段共存分配足够的内存，并可能为联合的作用添加填充字节，它只为其中的最大字段分配足够的存储，并且它假设您只会使用其中一个可能的字段，并且它将字面上存储这些字段，并将它们存储在彼此的顶部，因此如果您尝试使用多个字段，可能会弄乱事情，并且它不是为了做多个值，而是为了，例如，如果我知道我只打算使用其中一个，或者它也是另一种创建别名的方法，让你以不同的方式引用内存。</p><p>发言人   01:14:11<br>So for example, in your data lab you are using. You were manipulating the bit level representations of floating point numbers. And in our code, that would then convert that to an actual float. We used a union where the union is either to view this field of 4 B as an unsigned or as a float. And so I can. Convert from an unsigned to its float representation by just storing the unsigned value in this union and retrieving it as if it were float.<br>例如，在您的数据实验室中，您正在使用。你正在操作浮点数的位级表示。在我们的代码中，这将把它转换为实际的浮点数。我们使用了一个联合，其中联合要么将4 b的这个字段视为无符号字段，要么将其视为浮点数。所以我可以。通过仅将无符号值存储在此联合中并将其视为浮点数来将无符号值转换为浮点数表示。</p><p>发言人   01:14:54<br>And this is a fundamentally different operation than casting. Because you recall, when you take an unsigned value and you cast it to a float, you actually change the bit. You change it into the floating point number. That’s the closest a match to this particular number. It would be the equivalent of the function you implemented underscore u 2 f, but this one actually doesn’t change bits. It just changes the numeric value changes quite a bit. So it’s a useful technique to do that, to be able to override the type system and get to bit representations.<br>这是一种与铸造根本不同的操作。因为你记得，当你取一个无符号值并将其强制转换为浮点数时，实际上是改变了位。你把它变成浮点数。这是最接近这个特定数字的匹配项。它将与您实现的下划线u 2 f函数等效，但这个实际上不会更改位。它只是改变了数值变化相当大。所以这是一种有用的技术，能够覆盖类型系统并获得位表示。</p><p>发言人   01:15:33<br>And this actually turns out to be one of the places, too, where byte ordering will show up in programs if you’re not careful.<br>这实际上也是一个地方，如果你不小心，程序中会出现字节排序。</p><p>发言人   01:15:42<br>So in particular, with this union, I can view a block of 8 B as either eight characters, 4 shorts, 2”, or 1 long, and on a 64 b machine, like is shown here, where long is 64 b, you’ll see that you’re able to look at things as either as the individual bytes making it up or some longer aggregation of those bytes. And you’ll actually find that depending on what machine you run it on, you’ll get different results because of the byte ordering of the different machines. So this goes through it.<br>因此，特别是通过这个联合，我可以将一个8 B的块视为八个字符，4短，2 “或1长，在64 b的机器上，如图所示，其中长是64 b，你会发现你可以将事物看作是组成它的单个字节或这些字节的一些更长的聚合。你会发现，根据你在哪台机器上运行它，你会得到不同的结果，因为不同机器的字节顺序不同。所以这贯穿了它。</p><p>发言人   01:16:24<br>What happens when you run on different machines? But you’ll notice in particular that on an I 32 machine, a 32 b machine. It’s coming off in this byte pattern, F3, f 2, F1, f 0, And on a sun back when they existed, you’d get the opposite because of the byte ordering. And now on an x 8 64, where a long is 64 b, you get 8 B. And you can also determine from this, if you look carefully, that it’s in, it’s a little Indian order because this is the least significant byte as f 0, which is the first byte f 0. So it’s also a way to get to the low level bytes.<br>当你在不同的机器上运行时会发生什么？但你会特别注意到，在i32机器上，32 b机器上。它在这个字节模式中出现，F3，f2，F1，f0，当它们存在时，你会得到相反的结果，因为字节排序。现在在一个x8 64上，其中一个long是64 b，你得到8 B。如果你仔细看，你也可以从中确定它是在，它是一个小印度顺序，因为这是最不重要的字节，如f0，它是第一个字节f0。所以这也是一种到达低级字节的方法。</p><p>发言人   01:17:21<br>But when you use this kind of thing, you’re sort of intentionally telling the C compiler, Trust me, I know what I’m doing. You don’t have to protect me from myself. And so if you’re not careful, you can write code where because of a byte ordering problem or something like that won’t run properly on some machines.<br>但是当你使用这种东西时，你有点故意告诉C编译器，相信我，我知道我在做什么。你不必保护我自己。因此，如果你不小心，你可以编写代码，因为字节排序问题或类似的事情在某些机器上无法正常运行。</p><p>发言人   01:17:42<br>So just to summarize, then we’ve looked then at, we’ve looked then at the three compound types in C, the ways you can aggregate smaller types into larger ones. You can make an array of identical elements index by a number, the position. And that usually turns into some kind of scaled computation to get to the particular place we’ve seen structures where it’s a fixed number of fields, but the fields can be of different type and they’re referenced by their names, and that usually turns into some type of displacement off of the original position. And then a union, it’s just a way of sort of piling up in one place of a number of different fields. And so all it does is allocate the maximum number of bytes for that and doesn’t create enough space for them all to be there at the same time. Okay, that’s it for today then.<br>因此，总的来说，我们已经看过了，我们已经看过了C中的三种复合类型，即可以将较小的类型聚合成大的类型的方式。你可以让一个相同元素的数组按数字、位置进行索引。这通常会变成某种比例计算，以达到我们看到的结构的特定位置，其中字段的数量是固定的，但这些字段可以是不同类型的，并且它们通过其名称引用，这通常会变成原始位置的某种位移。然后是一个联盟，它只是一种将许多不同领域堆积在一个地方的方式。因此，它所做的只是为此分配最大字节数，而不会创建足够的空间让它们同时存在。好的，今天就到这里。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深入理解计算机系统 008-Machine-Level Programming IV, Data</title>
    <link href="/2025/10/12/15213-008/"/>
    <url>/2025/10/12/15213-008/</url>
    
    <content type="html"><![CDATA[<p>发言人   00:00<br>Okay? So continuing on with the saga of machine level programming, we’re in number four of our series of this. And I think that the total will be 5. So we’re almost through, and I’ve realized this is a lot of material for the course. It’s essentially a third of the course if you think about, well, no, not that much, but it’s a lot of the course and part that we consider very central to it. A lot of this involves, since we’re talking about a particular machine, the Intel X 86, 64 machines, a lot of it’s kind of low level, nitty gritty stuff. But part of what we hope you also are understanding is some of the general principles involved, too. And you’ll find if you move from this machine to another machine.<br>好吗？所以继续机器级别编程的传奇，我们在这个系列的第四个。我认为总数将是5。所以我们几乎完成了，我意识到这门课程需要很多材料。这基本上是课程的三分之一，如果你想一想，嗯，不，不是那么多，但这是我们认为非常核心的很多课程和部分。很多都涉及，因为我们谈论的是特定的机器，即英特尔x86、64机器，其中很多都是低级的、细节丰富的东西。但我们希望您也能理解其中的一些一般原则。如果你从这台机器移动到另一台机器，你会发现。</p><p>发言人   00:53<br>Sort of learning your first assembly language is your hardest one. Learning successive ones a lot easier. So today we’re going to talk about data representations. We so far, all the programs we’ve looked at have been either. Just manipulating integers or long integers and pointers. So that’s all what we’d call scalar data, Data that is not in any aggregated form.<br>在某种程度上，学习第一种汇编语言是最难的。学习连续的要容易得多。所以今天我们要谈论数据表示。到目前为止，我们看过的所有节目都是。只是操作整数或长整数和指针。这就是我们所说的标量数据，即不以任何聚合形式存在的数据。</p><p>发言人   01:20<br>Today, we’ll look at places where data gets collected into you, put together multiple data elements, and then see there’s really two ways to do that. One is with arrays, where you can create many copies or many copies of an identical data type. You can have an array of ints, an array of pointers. A second is where you have struct. So you create a small collection of values that can be of different data types, and each one you access by its name or a tag, and it turns out those definitions can be recursive. So you can have arrays of structs and structs with arrays and Nest to an arbitrary degree. And what we’ll see is both how it’s represented in the machine memory and also then what the code looks like that will manipulate these different data structures.<br>今天，我们将看看数据被收集到你的地方，将多个数据元素放在一起，然后看看有两种方法可以做到这一点。一种是使用数组，您可以创建多个副本或多个相同数据类型的副本。你可以有一个int数组，一个指针数组。第二步是你有结构的地方。因此，您创建了一个小的值集合，这些值可以是不同的数据类型，并且每个值都可以通过其名称或标记进行访问，结果发现这些定义可以是递归的。因此，您可以拥有结构数组和带有数组的结构，并以任意程度嵌套。我们将看到的是它在机器内存中的表示方式，以及操纵这些不同数据结构的代码的样子。</p><p>发言人   02:17<br>And the main thing to see is that. At the machine code level, there’s no notion of an array that you’d have at a high level, except to think of it as a collection of bytes that you can are in contiguous part of storage. And same with a struct. It’s just allocated as a collection of bytes. And it’s the job of the C compiler, then, to generate the appropriate code to allocate that memory to.<br>最重要的是看到这一点。在机器代码级别上，除了将其视为可以位于存储的连续部分的字节集合外，在高层次上没有数组的概念。结构也是如此。它只是分配为字节集合。然后，这是C编译器的工作，生成适当的代码来分配该内存。</p><p>发言人   02:50<br>Get the right value When you refer to some element of a struct or an array. But the good news is, this is such a common type of requirement for a programming language that the machine gives you sort of instructions that you’ll see. Now they make perfect sense. They’re exactly designed for this particular class of applications. So we’ll talk about rays first and then structures or structures. And I’ll also mention we do a I’ll give you a glimpse of floating point today too, because it’s worth knowing how floating point arithmetic is implemented as well on a machine.<br>当您引用结构或数组的某些元素时，请获取正确的值。但好消息是，这是编程语言的常见要求，机器会给你一些你会看到的指令。现在他们做出完美的感知。它们正是为这类特定应用而设计的。所以我们先讨论光线，然后是结构或结构。我还会提到我们做了一个，今天我也会给你一个浮点数的一瞥，因为了解如何在机器上实现浮点算术是值得的。</p><p>发言人   03:32<br>So the basic idea of array allocation is fairly straightforward If you have an array with n elements, then that’s represented by enough bytes in memory all in 1 span to hold that much data. So if the underlying data type, say it’s an int or a care, is a single a data type. So to have a array of 12 cares takes 12 B and int takes 4 B. So have an array of 5 ints takes 20 B, you get the idea. You just multiply the size, the underlying data type, by the number of elements. And that’s how big the array has to be in terms of bytes. And we’ve already seen then in the care is 1 B, and it is 4. A double or a long would be 8 B, and so it be a pointer, all different amounts of storage.<br>因此，数组分配的基本思想相当简单，如果你有一个具有n个元素的数组，那么这将由内存中足够的字节在1个跨度中表示，以容纳这么多的数据。因此，如果基础数据类型 (例如它是一个int或一个关心) 是一个单一的数据类型。因此，拥有一个由12个关心组成的数组需要12个B，而int需要4个B。所以有一个5个整数的数组需要20个B，你明白了。你只需要将大小、基础数据类型乘以元素数量即可。这就是数组的字节大小。我们已经看到，在护理中是1 B，它是4。double或long将是8 B，因此它是一个指针，所有不同的存储量。</p><p>发言人   04:33<br>And you see in this diagram, we use, the x denotes the starting address of the beginning of this region of memory. So we can use address computation to compute offsets. By adding numbers to X to get the address of particular elements of this array. And that’s exactly what the code does. So in general, then, if you imagine an array A has some underlying type T, what the elements of the array are, and some number of elements in that array in the declaration l? We will, that declaration actually does two things. One is it allocates enough bytes of storage to hold the entire array. And the second, from a programming language perspective, the identifier of the array A can in some ways be treated like a pointer that you can do pointer arithmetic off of it.<br>你可以看到在这个图表中，我们使用，x表示这个内存区域开始的起始地址。所以我们可以使用地址计算来计算偏移量。通过将数字添加到X以获取此数组中特定元素的地址。而这正是代码所做的。所以，一般来说，如果你想象一个数组A有一些底层类型T，数组的元素是什么，以及在声明中数组中的一些元素数量l？我们会，这个声明实际上做两件事情。一种是分配足够的存储字节以容纳整个阵列。第二，从编程语言的角度来看，数组的标识符在某种程度上可以被视为一个指针，你可以从中进行指针算术。</p><p>发言人   05:37<br>And that’s one of the features of C that is was fairly unique to see when it was created and is still unique to this day, this idea of the sort of interchangeability of pointers and arrays, array identifiable.<br>这是C的特性之一，在创建时是相当独特的，直到今天仍然是独一无二的，这种指针和数组可互换的思想，数组可识别。</p><p>发言人   05:54<br>So for example, I can use an array notation to say val of 4, element 4 of this array. And it’s a five element array. So that would just be this final element. But I can also just refer to Val and its underlying data type is as an star. So pointer to ints and its value would be x, it’s just a pointer. A pointer is, remember, an address, and it’s just the address at the beginning of the array. And I can do pointer arithmetic val, which, as you know in C, and this is a little confusing, we’ll go back and forth.<br>因此，例如，我可以使用数组表示法来表示此数组的元素4的val。它是一个五元素数组。所以这只是最后一个元素。但我也可以只引用Val，其基础数据类型为星号。所以指向int的指针及其值将是x，它只是一个指针。请记住，指针是一个地址，它只是数组开头的地址。我可以做指针算术val，正如你在C中所知道的那样，这有点令人困惑，我们将来回讨论。</p><p>发言人   06:36<br>Because in C, when you do pointer arithmetic, like you say, p plus plus for a pointer, let me just give you an example. So if you had something like K star p as a declaration, and you said p is equal to some string s, and then you say p plus plus, so you’re incrementing that pointer. In this case, you’re incrementing it by one because the underlying data type is. Is a care? But if you said something like in star I’ll call it IP.<br>因为在C中，当你进行指针算术时，就像你说的那样，p加号代表指针，让我给你一个例子。所以，如果你有一个像K star p这样的声明，你说p等于一些字符串s，然后你说p加号，所以你增加了那个指针。在这种情况下，您将其递增一，因为基础数据类型是。这是一种关心？但是如果你说了像星星这样的东西，我会称之为IP。</p><p>发言人   07:23<br>I different pen.<br>我不同的笔。</p><p>发言人   07:36<br>And I said, you know IP plus plus, then IP would get IP plus. What does anyone know? 4, yes. So it’s a confusion in C, this, remember, is the same as saying IP plus equals 1. But what you’re actually doing is incrementing the number of the value of p by 4, because you want a pointer When you jump from one place to another, you want it to increment by enough bytes to point to the next integer, in this case for IP. And so similarly, val plus 1 denotes this value x plus 4, because it’s the address of the next integer in the array.<br>我说，你知道IP加加，那么IP就会得到IP加。有人知道什么？4，是的。所以这是C中的一个混淆，记住，这与说IP加等于1是一样的。但是你实际要做的是将p的值的个数增加4，因为当你从一个地方跳到另一个地方时，你想要一个指针，你想要它增加足够的字节以指向下一个整数，在这种情况下是IP。同样，val加1表示这个值x加4，因为它是数组中下一个整数的地址。</p><p>发言人   08:41<br>By the way, the one thing different between an array and a pointer is I can’t say val plus plus, I can’t change the value of val. It’s fixed by the declaration, whereas a pointer, I can increment it, I can change it in various ways. And similarly, ampersand val of two says, give me the address of the second element of the array. So that would be at x plus 8. And this is, again, one of the fundamental properties of c that.<br>顺便说一下，数组和指针之间的一个不同之处是我不能说val加，我不能改变val的值。它由声明修复，而指针，我可以递增它，我可以以各种方式更改它。同样，两个与号符的val表示，给我数组第二个元素的地址。所以这将是x加8。这也是c的基本属性之一。</p><p>发言人   09:24<br>Basically in C, if you take a pointer.<br>基本上在C中，如果你拿一个指针。</p><p>发言人   09:39<br>That’s weird?<br>这很奇怪？</p><p>发言人   09:44<br>This is an I, not very well written. These are equivalent statements. There are just two notations for the same thing. So on the upper part, it says IP plus two, meaning actually 8 to IP, and then dereference set. It’s the same as finding the second element of array, an imaginary array where IP indicates the beginning of the array. So that’s a very fundamental principle of C, that, again, this whole idea of point arithmetic is fairly unique to see question.<br>这是一个I，写得不是很好。这些是等价的语句。同一事物只有两种符号。因此，在上部，它说IP加2，实际上意味着8到IP，然后取消引用设置。这与查找数组的第二个元素相同，这是一个虚构的数组，其中IP指示数组的开头。所以这是C的一个非常基本的原则，再次强调，点算术的整个思想在问题中是相当独特的。</p><p>发言人   10:26<br>Pardon, yes. The compiler will happily let you use negative values for array indices, and it will give you a potentially undefined value. But there’s nothing in C that prevents you from giving out of bounds either. Numbers that are too big for an array or too small for an array. There’s no bounds checking in.<br>对不起，是的。编译器会很高兴让你对数组索引使用负值，它会给你一个可能未定义的值。但是C中也没有任何东西阻止你越界。对于数组来说太大或太小的数字。没有边界检查。</p><p>发言人   10:59<br>So the question is becoming, what about negative indices? And the answer is very simple, because in other words, in general, something like IP plus x, maybe, can you see this? Should I turn on? Kind of bright is really equivalent to IP plus 4x. So this is the notation. And it’s really hard to read, isn’t it? And the right hand side is a computation.<br>那么问题就变成了，负指数怎么办？答案非常简单，因为换句话说，一般来说，像IP加x这样的东西，也许，你能看到这个吗？我应该打开吗？有点亮真的相当于IP加4x。所以这是符号。而且它真的很难读懂，不是吗？右侧是一个计算。</p><p>发言人   11:49<br>In C, you write it using, you don’t have to give scaling factors for your data types, otherwise it would drive you out of your mind, but you secretly underneath, when the compiler generates the code, we’ll see examples of this. It’s scaling everything. So now the question that is being asked is, what if x is a negative number? Well, the rule still applies, it’s just the final result will be less than IP instead of greater than IP, but it’s totally valid C, and there’s actually times you will use it in this term, I can promise you yes question.<br>在C中，你使用编写它，你不必为你的数据类型提供缩放因子，否则它会让你离开你的头脑，但是你秘密地在下面，当编译器生成代码时，我们会看到这样的例子。它正在扩展一切。现在被问到的问题是，如果x是负数怎么办？好吧，规则仍然适用，只是最终结果将小于IP而不是大于IP，但它是完全有效的C，实际上有时你会在这个术语中使用它，我可以向你保证是问题。</p><p>发言人   12:33<br>No, you can’t write two plus IP, try it. I’m pretty sure you can’t do that with point arithmetic. If somebody wants to type in some code and do it, I don’t think you can do that, but if you did, it would have to figure it out. The parser knows the data types of its two arguments. So yeah, you could probably do it. I’ve never seen this. You could do it, but the compiler would know that one of the arguments is a pointer and therefore scale the other.<br>不，你不能写2加IP，试试吧。我很确定你不能用点算术做到这一点。如果有人想输入一些代码并执行它，我认为你做不到，但如果你做到了，它必须自己解决。解析器知道它的两个参数的数据类型。所以，是的，你可能可以做到。我从未见过这个。你可以这样做，但编译器会知道其中一个参数是指针，因此会缩放另一个参数。</p><p>发言人   13:02<br>What you can’t do is add two pointers, you can take the difference of two pointers, this is obscure. I’m not even going to tell you about this, we’ll get up in K and R, but you can do arithmetic. But you can, for addition, it can only be one pointer and one, and then the other has to be a regular integer value, and it will scale it appropriately. So I believe you can do it. It’s just somebody will smack you on the back of the hand if you actually write code it that way, but not the compiler. In particular?<br>你不能做的是添加两个指针，你可以取两个指针的差异，这是模糊的。我甚至不会告诉你这个，我们会得到K和R，但你可以做算术。但是你可以，另外，它只能是一个指针和一个，另一个必须是常规整数值，它会适当地缩放它。所以我相信你能做到。如果你真的这样写代码，只是有人会打你的手背，而不是编译器。特别是？</p><p>发言人   13:39<br>If you go beyond the bounds of an array, you’ll get whatever is beyond the bounds of that array. And it might be an invalid, or it might not even be a valid address. And you get a segmentation fault. But more typically, you’ll get some. Whatever happens to be there, that’s not so bad when you read it. But you can also potentially write it, as we saw before, and corrupt data that’s already in the memory. So here’s, again, the same statement I was making before that IP val, plus I just get scaled. The value computed would be the starting address plus four times whatever I is.<br>如果你超出了一个数组的界限，你将得到超出该数组界限的任何东西。它可能是无效的，或者甚至可能不是有效的地址。你会得到一个段错误。但更典型的是，你会得到一些。不管那里发生了什么，当你读到它的时候并不是那么糟糕。但是你也有可能像我们之前看到的那样编写它，并破坏已经在内存中的数据。所以这又是我在那个IP val之前做的同样的声明，而且我只是被缩放了。计算的值将是起始地址加上I的四倍。</p><p>发言人   14:25<br>Look, so that’s all. See, everything I said before is basic C of stuff. Now let start looking at it, the actual machine code involved. And so I made up this example here where I declare.<br>看，这就是全部。看，我之前说的一切都是基本的东西。现在让我们开始研究它，涉及到实际的机器码。所以我在这里做了这个例子，我声明。</p><p>发言人   14:44<br>Three arrays, each with 5 nths, and I go through what is considered sort of good form when you’re building up data that instead of having arbitrary constants sprinkled, three year program, often called magic numbers, that you instead use a pound define, and you give it some meaningful name and some documentation, usually at the top of a file or in a Doh file. And then the type D is a very handy way if you’re going to create complex data structures, I highly recommend you sort of break that into type depths because the declaration notation and C gets fairly obscure fairly quickly, but all this is saying is the data type I’m going to call a zip did is defined to be 5, an array of 5 ints. And now whenever I say zip did something I’m just popping down. I’m saying this is an array of 5 ins, and so I created three of them with the appropriate zip codes for the schools represented here, and now I’m just making up for sake of presentation actual addresses, these in general, you don’t have any control over that. And I made it up so that they all happen to be in contiguous part of memory. And again, there’s no fundamental reason that should be true, so you can never trust what particular address anything is ever going to be allocated at, but you are certain that each of these blocks will be a contiguous collection of 20 B.<br>三个数组，每个数组有5个n，当你构建数据而不是任意常量散布时，我经历了一种被认为是好的形式，三年的程序，通常被称为幻数，你使用磅定义，并给它一些有意义的名称和一些文档，通常位于文件的顶部或多个文件中。如果您要创建复杂的数据结构，那么类型D是一种非常方便的方法，我强烈建议您将其分解为类型深度，因为声明符号和C很快就会变得相当模糊。但这一切都表明，我要称之为zip的数据类型被定义为5，一个由5个整数组成的数组。现在，每当我说zip做了什么，我就会突然跳下来。我是说这是一个由5个元素组成的数组，所以我创建了其中的三个，并为这里所代表的学校提供了适当的邮政编码，现在我只是为了展示实际的地址而弥补，这些地址通常是你无法控制的。我编了这个，使它们恰好都在记忆的连续部分。再说一次，没有根本的原因是正确的，所以你永远不能相信任何东西将被分配到哪个特定的地址，但你可以肯定这些块中的每一个都是20 b的连续集合。</p><p>发言人   16:24<br>So here’s some example code then to say I want to retrieve for one of these arrays, I want to retrieve element whose index is digit. And this gets turned into the following code. So remember the first argument, which will be a pointer now. RDI and the second it will be will be passed in register Rs. And what I want to get out of this is an int. And so you see that here’s where that scaled addressing, this is exactly what it was designed for and why, why they went to the trouble of adding this sort of fancy address modes to x 86? Because this is such a common thanks.<br>这里有一些示例代码，说明我想检索其中一个数组，我想检索索引为数字的元素。这将转换为以下代码。所以记住第一个参数，现在它将是一个指针。RDI和第二个将在寄存器Rs中传递。我想要从这里得到的是一个整数。所以你可以看到这就是缩放寻址的地方，这正是它的设计目的，为什么他们费心将这种花哨的地址模式添加到x86？因为这是一种常见的感谢。</p><p>发言人   17:14<br>So remember, what this says is take RDI and add to it what you get by multiplying RSI by 4. So you scale that, and of course, that’s exactly the computation we want to do if we compare it to this is what we’re trying to get computed it’s exactly.<br>所以请记住，这说的是将RDI乘以4，然后将得到的RSI相加。所以你可以扩展它，当然，这正是我们想要做的计算，如果我们将其与我们试图得到的计算进行比较，这就是我们想要得到的计算。</p><p>发言人   17:38<br>It’s exactly this computation here. And that gives us an address. And then we’re reading from that address, and we’re going to copy it in EA. Remember, this is an int, so it will be in the E version, the lower 4 B of register rax. And that’s all the code it takes to implement this particular operation. Yes, so RDI is the base address.<br>这就是这里的计算。这给了我们一个地址。然后我们从那个地址读取数据，我们将把它复制到EA中。请记住，这是一个int，因此它将在E版本中，即寄存器rax的下部4 b。这就是实现这个特定操作所需的所有代码。是的，所以RDI是基址。</p><p>发言人   18:06<br>We multiply by 4 and p plus RR SI on the right side. Yeah, this is a typo, thank you, thanks for pointing that out. I’ll make a note of that. Right, so this slide is incorrect, and I’ll fix that. So this should be RDI plus 4 RSI, right? Thanks for noting that. Let me make it.<br>我们乘以4，右边的p加上RR SI。是的，这是一个错字，谢谢，谢谢你指出这一点。我会把它记下来的。对，所以这张幻灯片不正确，我会修正的。所以这应该是RDI加4 RSI，对吧？谢谢你注意到这一点。让我来。</p><p>发言人   18:38<br>Okay? And so now let’s just look at another. Just some code. In particular, what if I wanted to go through one of these arrays and for every element of the array add 1 to it? So increment single element by one? Well, first of all, you can see that we’re setting up a loop and it uses the jump to middle business, where the initial part is to jump to the test. And all the testing involves we’re using Rax is for I here, and we’re incrementing it and comparing it at various places.<br>好吗？所以现在让我们来看看另一个。只是一些代码。特别是，如果我想遍历其中一个数组，并且对于该数组的每个元素添加1，该怎么办？那么，单个元素递增一个？首先，您可以看到我们正在设置一个循环，它使用跳转到中间业务，其中初始部分是跳转到测试。所有测试都涉及我们在这里使用Rax，我们将其递增并在不同的地方进行比较。</p><p>发言人   19:30<br>Here’s the line of code that does all the real work. Again, taking the i-th element, which I is in Rax, scaling it by four, adding it to the base of the array, and that gives us an address. And now remember, you can have an arithmetic instruction where the second operand, the destination, is a memory reference. And what this actually requires is to first read the original value from the memory, do the addition, and then store the result back in memory. So this one instruction is exactly doing this plus operation on this stored data in the array.<br>这是做所有实际工作的代码行。再次，获取第i个元素，即我在Rax中的第I个元素，将其缩放四，将其添加到数组的底部，这就给了我们一个地址。现在记住，你可以有一个算术指令，其中第二个操作数，目标，是一个内存引用。这实际上需要的是首先从内存中读取原始值，进行加法，然后将结果存储回内存中。所以这一条指令正在对数组中存储的数据进行这个加法操作。</p><p>发言人   20:24<br>By the way, I should mention the whole idea of pointer arithmetic. And C was C was really people who had programmed in assembly code for most of their lives thinking about how could I make this look like a high level language, but keep all the flexibility, all the tricks I learned to play an assembly code in a programming language? Because it was designed, it was originally designed to implement an operating system, the Unix operating system. And historically operating systems were written directly in assembly code and these people kernighan and Richie and Dennis Richie realize that the way to do this is to sort of build point arithmetic into a programming language. So anyways, the reason I’m saying this is you see a pretty close correspondence here between instructions in machine code and constructs in a program in the C programming language, And that whole plus operator and plus equals is sort of something you see variations of assembly weight code.<br>顺便提一下，我应该提到指针算术的整个概念。而C实际上是那些在大部分时间里都在用汇编代码编程的人，他们思考着如何让这看起来像一种高级语言，但保留了我在编程语言中学习汇编代码的所有灵活性和技巧？因为它的设计初衷是为了实现一个操作系统，即Unix操作系统。历史上，操作系统是直接用汇编代码编写的，这些人kernighan、Richie和Dennis Richie意识到做到这一点的方法是在编程语言中构建点算术。无论如何，我这么说的原因是，你可以在这里看到机器码中的指令和C语言程序中的构造之间的非常接近的对应关系，而且整个加号运算符和加号等于是你可以看到汇编重量代码的变化。</p><p>发言人   21:37<br>Okay? So that’s a sort of single dimension array. And I’d like to just. Change things up a little bit by having us look at what the real difference is between arrays and pointers in a programming language in C? And so I have a couple of these examples that I’ll bring out one by one. But the idea of this is you see the declaration on the left is something called a one and something called a two. So call those a sub n, and now what I want to know for each of these is, doesn’t compile, is this a valid statement in C?<br>好吗？所以这是一种单维数组。我只是想这样做。通过让我们看看在C语言编程语言中数组和指针之间的真正区别，可以稍微改变一下事情。所以我有几个这样的例子，我会一个接一个地提出来。但是这个想法是你看到左边的声明是称为一的东西，被称为二的东西。因此，将这些称为子n，现在我想知道的是，每个都不编译，这是C中的有效语句吗？</p><p>发言人   22:29<br>Second, would this potentially give me a null pointer reference? Because I’m referencing a pointer for which I haven’t actually allocated space for the that that pointer is indicating, I haven’t initialized the pointer to a valid memory reference. And then finally, if I were to use the size of operator on that particular. Value with that, including for the case where there’s a star in front of it.<br>其次，这会给我一个空指针引用吗？因为我正在引用一个指针，而我还没有为该指针分配空间，所以我还没有将该指针初始化为有效的内存引用。最后，如果我要在那个特定上使用运算符的大小。价值，包括在它前面有一颗星星的情况下。</p><p>发言人   23:12<br>And part of this is to understand the difference, then, between an array and a pointer. The main reason, the main factor is an array. When you declare an array in C, you’re both, you’re actually allocating space. Space is being allocated somewhere for it, and you’re creating allowed to now use the array name in pointer arithmetic. Whereas when you just declare a pointer, all you’re allocating is the space for the pointer itself and not for anything that it’s you’re pointing too.<br>其中一部分是理解数组和指针之间的区别。主要原因，主要因素是数组。当你在C中声明一个数组时，你们都是，实际上是在分配空间。空间正在分配给它的某个地方，您正在创建允许现在在指针算术中使用数组名称。而当你只是声明一个指针时，你所分配的只是指针本身的空间，而不是指针指向的任何东西。</p><p>发言人   23:55<br>Just you’ve probably figured out that these both compile. Let me get my cheat sheet, Andy, but what would be the size of a 1 here? If I ran the size of operator on it.<br>只是你可能已经发现它们都可以编译。让我拿我的备忘单，Andy，但是这里1的大小是多少？如果我在上面运行了操作员的大小。</p><p>发言人   24:26<br>Let’s do the easier one. What’s the size of a 2? 8, because it’s a pointer. What’s the size of a A’s? An array of 3 ints 12, right?<br>让我们做更容易的那一个。2的大小是多少？8，因为它是一个指针。a的大小是多少？一个3个12的数组，对吧？</p><p>发言人   24:50<br>And those aren’t. No, oops.<br>而那些不是。不，哎呀。</p><p>发言人   24:58<br>And now if I said star A one or star a two, those would both compile.<br>现在，如果我说了star A 1或star a 2，它们都会编译。</p><p>发言人   25:14<br>Could either of them possibly give you a dereference?<br>他们中的任何一个可能给你一个引用吗？</p><p>发言人   25:27<br>Oh yes, the pointer itself is null, but. I haven’t dereferenced it yet. It’s a null pointer, but it’s not a potentially bad reference. It’s not a runtime. I won’t create a runtime error if I just say a two in my code, so you’re step ahead of me, basically. So you kind of answered the second question, though, this one could give you a null pointer error if you try to dereference a pointer that hasn’t been initialized, it doesn’t point to anything, whereas this one is fine.<br>哦，是的，指针本身是空的，但是。我还没有取消引用。它是一个空指针，但它不是一个潜在的错误引用。它不是运行时。如果我在代码中只是说a 2，我不会创建运行时错误，所以你基本上领先于我一步。所以你有点回答了第二个问题，但是，如果你尝试取消引用一个没有初始化的指针，它可能会给你一个空指针错误，它没有指向任何东西，而这个没问题。</p><p>发言人   26:04<br>And now what’s the size of a one of of star A 1, 4, and what about star A 2, 4? Yeah, because they’re both pointers to ints. So one way to think about that as a picture a one. It’s like we’ve been showing here. It’s an array of four ints. And when I declare a one I’m allocating also the program is allocating 12 B of storage that’s able to hold that. A 2, on the other hand, is just a pointer. Which I’ll show there, and so it’s 8 B long, but it doesn’t point to anything. So that’s what I meant, that if you tried to say star a two, you’d potentially have a null pointer dereference there.<br>现在一颗1，4星的大小是多少，而一颗2，4星的大小是多少？是的，因为它们都是指向整数的指针。因此，有一种方式可以将其视为一张图片。就像我们一直在这里展示一样。它是一个由四个整数组成的数组。当我声明一个我正在分配的存储时，程序也分配了12 B的存储空间来容纳它。另一方面，2只是一个指针。我会在那里展示它，所以它有8 B长，但它没有指向任何东西。所以这就是我的意思，如果你试图说star a 2，你可能会在那里有一个空指针取消引用。</p><p>发言人   27:11<br>And so that’s why this is 8, and this is Wolff. So those were the warm up one. So let’s make it a little more interesting.<br>所以这就是为什么这是8，这是沃尔夫。所以那些是热身的。让我们把它变得更有趣一些。</p><p>发言人   27:29<br>These aren’t in the slides, you’ll notice, but I’ll update the slides to include these later. But I think the point that if you find this confusing, it’s a sign that you really, really, really need to understand what a pointer is and what an array is, and how they’re the same and how they’re different because it. It’s a core part of programming in C that will lead to endless hours of confusion if you don’t really have this wired down pretty strongly. So let me just give you a preview of what’s self interestings about. This is I’m going to give you some numbers, and then we’re going to have to explain how those numbers come around.<br>这些不在幻灯片中，您会注意到，但我稍后会更新幻灯片以包括这些内容。但我认为，如果你发现这令人困惑，那就是一个迹象，你真的需要理解指针和数组是什么，以及它们是如何相同的，以及它们是如何不同的。它是用C编程的核心部分，如果你没有非常强烈地对此进行连接，它将导致无尽的混乱。那么让我给你一个关于自我兴趣的预览。这就是我要给你一些数字，然后我们将不得不解释这些数字是如何产生的。</p><p>发言人   28:34<br>Okay? So let’s try and understand what’s happening here. And you see that all of these declarations involve some combination of pointer and array. And the question is, is it pointer to an array? Is it an array of pointers? And the answer to those will depend on the particular syntax.<br>好吗？让我们试着了解这里发生了什么。你会发现所有这些声明都涉及指针和数组的某种组合。问题是，它是指向数组的指针吗？它是一个指针数组吗？这些问题的答案将取决于特定的语法。</p><p>发言人   29:00<br>So of course, the first one is one you’ve already seen before. And so, you know that compiles, and it’s not null, and you can dereference it, and it’s not null. But if you tried to say star, star a one, that’s not valid, it won’t even compile because you’re trying to here take the data type of star A is int, and then you’re trying to take a dereference an int. So that won’t compile, and therefore you can’t even test it.<br>当然，第一个是你之前已经见过的。所以，你知道编译时，它不是空的，你可以取消引用它，它也不是空的。但是如果你试图说star，star a one，这是无效的，它甚至不会编译，因为你在这里尝试采用star的数据类型是int，然后你试图取消引用一个int。这样就无法编译，因此你甚至无法测试它。</p><p>发言人   29:35<br>Okay, the question is, for these other three, you can see that. Somehow one is, well, let’s look at the bottom two first. So the one on the bottom says that, and this is part of, and there’s actually a really great section in Carnegie Richie that I highly encourage you how to read pointers, how to read declarations and see. And the basic rule is you start from the inside and you work your way outwards. So that declaration of a three says that. With that parentheses, it says a three is a.<br>好的，问题是，对于其他三个，你可以看到。不知何故，一个是，好吧，让我们先看看底部的两个。所以底部的那个说，这是其中的一部分，实际上在Carnegie Richie中有一个非常棒的部分，我强烈鼓励你如何阅读指针，如何阅读声明并查看。基本规则是你从内部开始，然后向外工作。所以三号的宣告是这样说的。用那个括号，它说3是a。</p><p>发言人   30:27<br>What is a three?<br>什么是三？</p><p>发言人   30:35<br>A 3 is a pointer that two parentheses around it, what does it point to, It points to an array of three ints. So we can diagram a 3 then.<br>3是一个指针，周围有两个括号，它指向什么，它指向一个由三个整数组成的数组。所以我们可以绘制一个3。</p><p>发言人   30:57<br>To be? Something like this?<br>要成为？像这样的东西？</p><p>发言人   31:14<br>Is a, like I said, read it from the inside out. A 3 is a pointer.<br>就像我说的，从里面读出来。3是指针。</p><p>发言人   31:23<br>And what does it point to, it points to an array of three elements. And what type of elements are they there ins? So you’re sort of reading outward and picking up pizzas from the right and from the left as you do this. And so when you know that this all makes sense, that these numbers, the size of a 3 itself is 8. But since it points to an array of three ints, the size of star A 3 is 12. And then star star A 3 would indicate this particular element of the array. And so it size is 4. So these all compile. But which of them could cause a null pointer dereferences which of the last two?<br>它指向什么，它指向一个由三个元素组成的数组。它们是什么类型的元素？这样你就可以向外阅读，从右边和左边拿起披萨。所以当你知道这一切都是感知的时候，这些数字，3本身的大小就是8。但是由于它指向一个3个整数的数组，所以星号A 3的大小是12。然后星号为3表示数组的这个特定元素。所以它的大小是4。所以这些都编译。但是它们中哪一个会导致空指针取消引用，最后两个中哪一个？</p><p>发言人   32:19<br>Guess you can flip coins, yes? Well I’m only looking at I’m trying to fill in a three right now. So a 3 is fine. But if I said star a 3, could that have a null pointer problem, yes. Why, because when I declare a three here, all I’m declaring is this particular. I’m only allocating enough storage for that pointer. I haven’t allocated the space for an array. I haven’t initialized a 3 to actually point an array, so it could be a null pointer, it could be an arbitrary junk, but the chances of it actually pointing to an array of three ins is highly unlikely. So this would be potentially bad. And therefore, double star is doubly bad, right?<br>猜猜你可以抛硬币，对吧？好吧，我现在只看我正在尝试填写三。所以3号很好。但是如果我说了星号a 3，那可能有空指针问题吗，是的。为什么？因为当我在这里声明三个时，我所声明的只是这个特定的。我只为那个指针分配了足够的存储空间。我还没有为数组分配空间。我还没有将3初始化为指向一个数组，所以它可能是一个空指针，也可能是一个任意的垃圾，但它实际上指向一个由三个数组组成的数组的可能性极小。所以这可能是不好的。因此，双星是双倍糟糕的，对吗？</p><p>发言人   33:17<br>So now let’s look at a four. So a 4. To understand that, you actually have to look at the. Charts in C, the precedent chart, which if you’re like me, your book falls open to that precedent. ISS chart the different operators and what levels they are. And one thing you’ll see is that level one of precedents, the highest precedents, includes square brackets, and level 2 includes star. In other words, bracket is higher precedence since star. So this particular statement here, the binding is actually like this. It says that a four is an array of three elements. And those elements are pointers. And they point to ints.<br>现在让我们来看看四个。所以是4。要理解这一点，你实际上必须看看。C中的图表，先例图表，如果你和我一样，你的书就会遵循先例。ISS绘制不同操作员及其级别的图表。你会看到的一件事是，第一级先例，最高的先例，包括方括号，第二级包括星星。换句话说，括号自星号以来具有更高的优先级。所以这里的这个特定语句，绑定实际上是这样的。它说四个是三个元素的数组。这些元素就是指针。他们指向整数。</p><p>发言人   34:32<br>So a 4. Is an array? Can you see this? But each of those elements. Is pointing to an int somewhere hopefully? And so let’s see if that matches the numbers we got. So the size of a 4 is 24 because it’s eight times 3. If I were to dereference a 4, it would just indicate this particular.<br>所以是4。是数组吗？你能看到这个吗？但是这些元素中的每一个。希望指向某个int吗？所以让我们看看这是否与我们得到的数字匹配。所以4的大小是24，因为它是8乘以3。如果我要取消引用4，它只会表明这个特定的。</p><p>发言人   35:15<br>Pointer A 4 is an array of pointers. Get an element out of that array. What I’ll get is a pointer. And so a four is a pointer, and so it’s also 8. But if I now do a second d reference, then I’ll get an int and it size is 4, okay?<br>指针A 4是指针数组。从该数组中获取一个元素。我会得到一个指针。因此，4是一个指针，因此它也是8。但是如果我现在做第二个d引用，那么我会得到一个int，它的大小是4，好吗？</p><p>发言人   35:46<br>These all compile. So could I have a could start a four then cause problems as far as a null pointer or bad pointer? No, that’s right. No is the correct answer. No is yes, because a four is an array. You’ve defined an array, and arrays get allocated by their declaration as a three element array. On the other hand, this could give you a null pointer because I haven’t initialized the array to anything. So for example, if it were initialized to all zeros, it would just be three null pointers in that array.<br>这些都在编译。所以我可以有一个可以开始四个，然后导致问题，就像空指针或坏指针一样？不，没错。不是正确答案。No就是yes，因为4是一个数组。您已经定义了一个数组，数组通过声明被分配为三元素数组。另一方面，这可能会给你一个空指针，因为我还没有将数组初始化成任何东西。例如，如果它被初始化为全零，则该数组中将只有三个空指针。</p><p>发言人   36:43<br>So this is sort of the stuff, the nitty gritty of C question, yes? How does it know that the size it 12 like I thought I see they didn’t really know how many things are in the question is. The compil what I’ll answer your question by saying, remember the compiler knows a lot. In particular I’ve declared this to be an array of three pointers. I’m compiling for a machine where pointers are 8 B. And so the compiler knows that SB 24 B in general, when you’re referencing in C, no, the machine doesn’t have built into it and doesn’t do bounds checking for you, but that’s in the runtime execution. But in see if I. When I declare something, it’s it has to be known at that point when the declaration occurs.<br>这就是C问题的基本细节，对吧？它怎么知道它的尺寸是12，就像我想我看到的那样，他们真的不知道问题中有多少东西。我回答你的问题时会说，请记住编译器知道很多。特别是我已经声明了这是一个由三个指针组成的数组。我正在为指针为8 B的机器进行编译。因此编译器通常知道SB 24 B，当你在C中引用时，不，机器没有内置到它里面，也不会为你做边界检查，但那是在运行时执行中。但是看看我是否。当我声明某事时，它必须在声明发生时被知道。</p><p>发言人   37:57<br>Empty bracket. Yeah, I think empty bracket is just another name for a pointer. Usually it’s just given his arguments, there’s some restrictions on it. But when you use the empty bracket notation and C, it’s equivalent to doing a pointer declaration. You’re not allocating any space for it here, but saying they want, right? Agreed, we have to be allocated a necessary on that.<br>空括号。是的，我认为空括号只是指针的另一个名称。通常只是给出他的论点，有一些限制。但是当你使用空括号符号和C时，它等效于进行指针声明。你并没有在这里分配任何空间，而是说他们想要，对吗？同意了，我们必须得到必要的分配。</p><p>发言人   38:24<br>Yes, right here, It really means when you declare an array and you give a number the size of that array, it really allocates that memories question eval.<br>是的，就在这里，它实际上意味着当你声明一个数组并给出一个数组大小的数字时，它确实分配了记忆问题eval。</p><p>发言人   38:36<br>And yes, oh, yes. And that’s the final one. You will notice numbers for a two and a four are the same. And the reason is it’s the same thing. And that, again, goes by the president’s rules of C, that A two first binds this way and then this way. And so a two and a four are synonymous just with west parentheses. So that was a bit of an aside. But as you can see, I think this is the kind of thing that will really probe your understanding.<br>是的，哦，是的。这是最后一个。你会注意到2和4的数字是一样的。原因是一样的。而且，再次遵循总统的规则C，即两个第一绑定的方式是这种方式，然后是这种方式。因此，2和4与西括号同义。所以这有点旁白。但是正如你所看到的，我认为这是一种真正能够探测你的理解的东西。</p><p>发言人   39:15<br>And now as a beginning C programmer, where you don’t have a very good sense, the underlying representation of a program, it’s really hard to figure these things out. But now that you know what it means to compile code, and you can actually look at compiled code, that’ll sort of clear up a lot of what’s really going on in a program. So let’s now generalize from one dimension to 2, just to make life a little more interesting. And again, it’s an important principle to understand that when you want to declare a multidimensional array and see you do it by a sequence of brackets with the bounds for each one. And the reason for that is actually there.<br>现在作为一个初级的C程序员，如果你没有一个非常好的感知，一个程序的底层表示，很难弄清楚这些事情。但是现在你知道了编译代码意味着什么，并且你可以实际查看编译后的代码，这将澄清程序中实际发生的很多事情。现在让我们从一维推广到二维，只是为了让生活更有趣一些。再次强调，当你想声明一个多维数组并查看时，理解这一点是一个重要的原则，你可以通过一系列括号来完成它，每个括号都有边界。原因其实就在那里。</p><p>发言人   40:10<br>We’ll see that it has to do with this notation that we just went through. So if I say int.<br>我们将看到它与我们刚刚经历的这个符号有关。所以如果我说int。</p><p>发言人   40:34<br>It turns out that I can read it like this. That a is an array of three elements. And each of those elements is in itself an array of five elements of type int. And we’ll get back to that. But that kind of explains everything thing I’m about to tell you in this picture. So in particular, if I declare an array with r rows and c columns, and you think of it mathematically as sort of a Ma two dimensional matrix. What it really does is it says, see as on the.<br>原来我可以这样读它。a是一个由三个元素组成的数组。每个元素本身都是一个由五个int类型元素组成的数组。我们会回到那个问题的。但这也解释了我在这张照片中要告诉你的一切。特别是，如果我声明一个包含r行和c列的数组，你可以把它数学上看作是一个马某某的二维矩阵。它真正做的是它所说的，就像在上面一样。</p><p>发言人   41:27<br>Yeah I’m sorry c actually ends up being the inner element. It says, first of all, I want row 0 will be an ray of c int. Being the number of columns I’ll put, so all the elements of row 0 will come first. All the elements of rho 1 come next, and so forth up to the end of it all. And so the total allocation will be 4, the data size times the number of rows times the number of columns. But the reason why they’re in that order, which is called rho major order, because if we thought of it these terms, we go through the first row, and then the second row. And the third row is precisely because.<br>是的，对不起，c实际上最终成为了内部元素。它说，首先，我希望第0行是一条c int的射线。作为我要放置的列数，因此第0行的所有元素都将排在第一位。rho 1的所有元素接下来都会出现，以此类推，直到最后。因此，总分配将为4，即数据大小乘以行数乘以列数。但是它们为什么按那个顺序排列的原因，称为rho主要顺序，因为如果我们想到这些术语，我们会遍历第一行，然后是第二行。而第三排恰恰是因为。</p><p>发言人   42:17<br>Of this? Notation, let me write it down like this. Hint of a. Well, let me just use the one I’ve said. We can write this out as a is a ray. A three element array.<br>关于这个？符号，让我这样写下来。a的暗示。好吧，让我用一下我说过的那个。我们可以把它写成a是射线。一个三个元素的数组。</p><p>发言人   42:45<br>What’s your battery on a microphone?<br>你的麦克风电池是什么？</p><p>发言人   42:53<br>Over half. It’s two thirds.<br>超过一半。是三分之二。</p><p>发言人   43:00<br>I’ll just put it over here. Okay, so A is a three element array, or generalizing to this picture, a is an array of R element. This is the first element, this is the second element, and this is the earth element. But what kind of elements are those? Each. Here is an array. Of 5 ins?<br>我就把它放在这里。好的，所以A是一个三元素数组，或者概括到这张图片，a是一个R元素的数组。这是第一个元素，这是第二个元素，这是地球元素。但是这些是什么元素？每个人。这是一个数组。在5个？</p><p>发言人   43:39<br>So within array A here, each sub-par of A then is an array of cints. And so that’s why logically, the way these are organized actually comes from this declaration notation directly. And we’ll see examples of that, for example.<br>因此，在这里的数组A中，then的每个子par都是一个cints数组。这就是为什么从逻辑上讲，这些组织的方式实际上直接来自于这个声明符号。我们会看到这样的例子。</p><p>发言人   44:07<br>Wanted to extend my zip digit idea and introduce an array of four of these. I could declare it this way. And again with remember, I used a type dev to declare zip did. But if I were to expand this out, it would be as if I was declaring this array Pgh to be 4 rows and 5 columns. But what it really is, it is an array of 4 elements, 1, 2, 3, 4, each of which is an array of 5”. So think of that nesting. When you read declarations, you start from the name of the element and you work your way outward through these brackets and stars in some order.<br>我想扩展我的zip数字想法并介绍一个由四个组成的数组。我可以这样宣布。并且再次记住，我使用了类型dev来声明zip done。但是如果我要扩展它，就好像我要将这个数组Pgh声明为4行5列一样。但它实际上是一个由4个元素组成的数组，1、2、3、4，每个元素都是一个由5 “组成的数组。所以想想那个嵌套。当您阅读声明时，您从元素的名称开始，然后按照某些顺序通过这些括号和星星来向外工作。</p><p>发言人   45:04<br>And so in particular, if I want to reference a particular element of an array, the general rule is wrong here, oh. The general rule is this one. If I want to reference, I don’t really. Oh I’m building up to. It. So yes, this shows that A of I can actually just do the reference A of I don’t have to give A of I of J in C, and what that denotes is one of these are rows of the array, and each of which is an array of c elements of type int.<br>因此，特别是，如果我想引用数组的特定元素，一般规则在这里是错误的。一般的规则就是这个。如果我想参考，我真的不知道。哦，我正在建设。它。是的，这表明I的A实际上可以引用A，而不必在C中给出J的I，这表示其中一个是数组的行，每个行都是int类型的c元素数组。</p><p>发言人   45:58<br>And so imagine that in general, we have k bytes for data type T, the underlying data type, in this case of t is and k equals 4. But in general, the starting address then of rho I would be gotten by multiplying the number of columns by k, and then multiplying that by the row number.<br>因此，想象一下，通常情况下，我们有k个字节用于数据类型T，这是底层数据类型，在这种情况下，t是并且k等于4。但一般来说，rho I的起始地址将通过将列数乘以k得到，然后再乘以行号得到。</p><p>发言人   46:26<br>And now within the array, I want to reference array element a sub ij. Then it comes out to this computation. You take the starting address. You scale the row number by the number of columns, add to it which column you want, and then multiply that all by k, So the way to see that is here, I can get to row number I by just scaling I by the number of columns times the size of the elements are 4. And now I want to get to the j element of this sub array here. And I can do that by scaling j by 4 and adding it to the beginning of this subarray. And now I can just collect the force together and then pull it outside here. That’s what gives you this formula.<br>现在在数组中，我想引用数组元素的一个子ij。然后它出来进行这个计算。你拿起始地址。您可以按列数缩放行号，将所需的列相加，然后将其全部乘以k，因此查看方法在这里，我可以通过按列数乘以元素大小为4来获得行号I。现在我想在这里找到这个子数组的j元素。我可以通过将j缩放为4并将其添加到此子数组的开头来实现这一点。现在我可以把力量集中在一起，然后把它拉出来。这就是你得到这个公式的原因。</p><p>发言人   47:23<br>So again, the point of this is that this all kind of is a natural outcome of the declaration. And it’s easy to think of it in terms of this storage model here of how the actual array is allocated.<br>所以，再次强调，这一切都是宣言的自然结果。而且很容易想到这里的存储模型，即实际阵列的分配方式。</p><p>发言人   47:45<br>Okay, now a different style of declaration is imagine I create three of these arrays. And now I want to create an array that contain. Points to these. So this is a different data structure you’ll observe from before. What uni-v now is an array of three pointers, and each of those pointers points to one of these arrays of five ints.<br>好的，现在一种不同风格的声明是想象我创建了三个这样的数组。现在我想创建一个包含的数组。指向这些。所以这是一个与之前不同的数据结构。现在的uni-v是一个由三个指针组成的数组，每个指针都指向这些五个整数数组之一。</p><p>发言人   48:27<br>And their underlying data type, by the way, of these elements are stars. And C does not differentiate When you want to declare array like this. You just say it’s an int star. You don’t say how many elements are the underlying array is. So you’ll see by these pictures that these are different data structures. So now let’s go through what the assembly code looks like to reference these two data structures.<br>顺便说一下，这些元素的基础数据类型是星形。当你想要像这样声明数组时，和C没有区别。你只是说它是一颗整型星。你不会说底层数组有多少个元素。所以你会从这些图片中看到这些是不同的数据结构。现在让我们来看看引用这两个数据结构的汇编代码是什么样子的。</p><p>发言人   49:04<br>We didn’t. Did we do the? I’m sorry, I would have thought I’d have assembly code. I think there might be a missing slide here, we’ll see. So imagine I wanted to reference.<br>我们没有。我们做了吗？对不起，我本以为我有汇编代码。我认为这里可能缺少幻灯片，我们会看到的。想象一下我想参考一下。</p><p>发言人   49:28<br>I’m sorry I’m confused why there is no.<br>对不起，我很困惑为什么没有。</p><p>发言人   49:50<br>There should have been. I’m sorry, this is I’m pausing here because I think I’m meant to have a slide that would show. What the code looks like, and I don’t. Okay, well, we’re going to have to wing it.<br>应该有。对不起，我在这里停顿一下，因为我想我应该有一张幻灯片来展示。代码是什么样子的，而我不是。好的，我们将不得不对它进行翼飞。</p><p>发言人   50:12<br>So if you wanted to an assembly code, then reference an element of an array like this, a multidimensional array. What you’ll see is that the code kind of builds up a computation like this. And typically, in the compiled code, the value of k is kind of a constant value. And if it’s aray that’s been declared with a constant bounds, then the value of c will also be a constant. And so a piece of code for this and that slide got omitted by extant. We’ll basically take this value and use some combination of the memory referencing and shifting and Lea instruction and so forth to implement this computation and then do a dereference.<br>所以，如果你想要一个汇编代码，那么引用一个像这样的数组的元素，一个多维数组。您将看到的是代码有点像这样构建计算。通常，在编译代码中，k的值是一种常量值。如果它是aray，它被声明为具有常量边界，那么c的值也将是一个常量。因此，这张幻灯片和那张幻灯片的一段代码被现有人省略了。我们基本上会取这个值，并使用内存引用、移位和Lea指令等的组合来实现这个计算，然后进行取消引用。</p><p>发言人   51:07<br>So let’s look at this second example. And there is code for this. And it’s actually a little bit more complex because this is going through two levels of indirection. So you’ll see that to get the. Digit a particular digit from a particular one of these universities, then? It has to, first of all figure out do this dereference is get a pointer to the beginning of the array. And that’s what this reference is doing here.<br>让我们来看看第二个例子。这方面有代码。这实际上有点复杂，因为这要经过两个间接层。所以你会看到得到。从这些大学中的一个特定的数字中选择一个特定的数字，然后呢？它必须首先弄清楚这个取消引用是获取一个指向数组开头的指针。这就是这个参考文献在这里做的事情。</p><p>发言人   51:53<br>First of all, what it’s doing is shifting RSA left by two, which is equivalent to scaling the digit by 4 because it’s getting ready to take that digit parameter and scale it appropriately. And then takes that number and it adds to it.<br>首先，它所做的是将RSA左移二，这相当于将数字缩放4，因为它准备接受该数字参数并适当缩放。然后将这个数字相加。</p><p>发言人   52:20<br>The value I get by reading from the array Univ, but using the index, scaling it by 8 to actually do a memory reference. So remember this instruction then, and it looks a little weird, is actually doing a memory reference here of this three element array of called Univ. So it’s reading from memory and doing an array index directly here by scaling. And now getting from that a pointer, adding to that the scaled value of the digit. And so that gives me a pointer now, as this notation shows. To. The particular element I want. And now it does a dereference. So that’s a pretty tough example to get as one of your first array ones.<br>我通过从数组Univ读取获得的值，但使用索引将其缩放8以实际进行内存引用。所以记住这个指令，看起来有点奇怪，实际上是在这里对这个三个元素数组的内存进行引用，叫做Univ。所以它从内存中读取，并通过缩放直接在这里进行数组索引。现在从中得到一个指针，再加上数字的缩放值。现在这给了我一个指针，正如这个符号所示。到。我想要的特定元素。现在它进行了一个取消引用。所以这是一个相当难的例子，作为你的第一个数组之一。</p><p>发言人   53:26<br>And as I said, I apologize for missing reference to a particular element of this array is done entirely by computing scaling indices in appropriate ways to take the array and scale the first index by 20. Because each row is 20 elements, it’s five times 4. And you want to scale the digit by 4 to select the particular element within that array. And so all this address computation takes place. And then there’s a single memory reference. Whereas in this data structure, you have to go through two memory references.<br>正如我所说，我很抱歉，缺少对此数组中特定元素的引用完全是通过以适当的方式计算缩放索引来获取数组并将第一个索引缩放20来完成的。因为每行有20个元素，所以它是4的五倍。并且您想将数字缩放4以选择该数组中的特定元素。因此，所有这些地址计算都发生了。然后有一个单一的记忆参考。而在这个数据结构中，你必须经过两个内存引用。</p><p>发言人   54:09<br>First of all, you have to index and get the appropriate element here, but that’s just a pointer now, and then we add an offset to that pointer to get the appropriate element in this array here. And then we read from that. So that’s what this notation means is that I’m doing two memory references here and just one there.<br>首先，你必须在这里索引并获取适当的元素，但现在这只是一个指针，然后我们向该指针添加一个偏移量以在这个数组中获取适当的元素。然后我们从中读到。所以这个符号的意思是，我在这里进行了两个内存引用，在那里只进行了一个。</p><p>发言人   54:30<br>And it’s a little bit curious because if you look at the C code, it looks the same, but the underlying data types are different, and so the references are different.<br>这有点奇怪，因为如果你看C代码，它看起来是一样的，但是底层的数据类型不同，因此引用也不同。</p><p>发言人   54:44<br>Okay, so let’s look at some other variations on this code. And these all will sort of follow up from these general principles I’ve described. So first of all, let’s introduce an array 2 by 2. I’m sorry, a 16 by 16 array of ints. And it used to be in C, if you wanted to do multidimensional arrays where the size of the array was not fixed at compile time, you basically had to implement your own version of that computation I showed before of scaling the row number by the number of columns and adding to it J, so this is sort of classic C I’ve written it as a macro here, but you can see it, it’s just doing the row major scaling directly.<br>好的，让我们看看这段代码的其他变体。这些都将遵循我所描述的这些一般原则。首先，让我们介绍一个2乘2的数组。抱歉，这是一个16乘16的整数数组。并且它曾经是在C中，如果你想做多维数组，其中数组的大小在编译时不是固定的，你基本上必须实现你自己的计算版本，我在按列数缩放行号并添加J之前展示了这个计算，所以这是经典的，我在这里将其编写为宏，但你可以看到它，它只是直接进行行主缩放。</p><p>发言人   55:37<br>Here is address arithmetic now since a more recent generation of the C compiler, what they call C 99, it was introduced in 1999. You can actually passes a parameter, an array, where the number of elements in the array is also a parameter that’s being passed to the function. And similarly, you can declare an array to be of n elements as long as n has been computed before it hits an array declaration. And the compiler will do the right thing. It will allocate the proper number of elements.<br>这是地址算术，自从最近的一代C编译器以来，他们称之为c99，它是在1999年引入的。你实际上可以传递一个参数，一个数组，其中数组中的元素数量也是一个被传递给函数的参数。同样，只要在数组声明之前计算过n个元素，就可以将数组声明为n个元素。编译器会做正确的事情。它将分配适当数量的元素。</p><p>发言人   56:25<br>So let’s just look at some of these code examples.<br>让我们来看看其中的一些代码示例。</p><p>发言人   56:37<br>Again, what we’ll see here, and this will show you an example of the kind of address computation that takes place with a two dimensional array. In this case, I know c is 16 and k is 4. So if I want to get element, I sub j ij out of this array, then first of all, scale I by 64, because I’ll add that to the base, and then I’ll scale RDX by 4, that’s j, and add it to this array, and then do a memory reference there. You see, these two instructions have done the appropriate, the three instructions done the appropriate scaling of I and J, added them to the beginning address of J, and done the computation. On the other hand, if it’s a.<br>再说一遍，我们将在这里看到什么，这将向您展示使用二维数组进行地址计算的示例。在这种情况下，我知道c是16，k是4。所以如果我想从这个数组中获取元素，那么首先将I缩放到64，因为我会将其添加到基础，然后将RDX缩放到4，即j，并将其添加到这个数组中，然后在那里做一个记忆参考。你看，这两条指令已经做了适当的调整，三条指令对I和J进行了适当的缩放，将它们添加到J的开始地址上，并完成了计算。另一方面，如果它是a。</p><p>发言人   57:44<br>The third example I showed where n is a parameter that’s passed to the function. So it’s not known at compile time how big a scaling factor to use. You’ll see that it has to use a multiply instruction to do that, which is relatively expensive instruction in terms of performance. And then once it has that, that’s just n times I, and then it uses various combinations of leas and the scaling notation from before to compute an appropriate offset into the array to do the reference. So here, I could do it with a shift. And here I had to introduce a multiplier. I don’t know in advance how big it is. If you want to torture yourself.<br>第三个例子我展示了其中n是传递给函数的参数。所以在编译时不知道要使用多大的缩放因子。你会发现它必须使用乘法指令来做这件事，就性能而言，这是相对昂贵的指令。一旦它有了这个，那只是n次I，然后它使用leas和之前的缩放符号的各种组合来计算适当的偏移量到数组中进行引用。所以在这里，我可以改变一下。这里我必须引入一个乘数。我事先不知道它有多大。如果你想折磨自己。</p><p>发言人   58:46<br>Here’s an example I was going to go over.<br>这是我要介绍的一个例子。</p><p>发言人   58:54<br>Of Tripoli, nested possibilities and dereferencing of the same idea.<br>的黎波里，嵌套可能性和同一想法的解引用。</p><p>发言人   59:04<br>But let’s move on to pointers to structs. So the idea of a struct is actually quite simple. Well, the base idea is simple, and it gets more complicated. The idea of it is, I want to, I declare a struct to have some number of fields, each of which can be an int, or it could be, in this case, a pointer, or it could be an array itself. But the rule is basically what I’ll do is allocate enough space if I introduce one of these structs for all the different array elements fields in that struct. And then I’ll basically keep track of where each of these field starts and generate the appropriate code to offset from the beginning so the structure itself the to it will be the beginning address of the struct. And then I’ll use appropriate offsets to get to the different fields.<br>但让我们继续指向结构的指针。所以结构的概念实际上非常简单。基本思想很简单，而且它变得更加复杂了。它的想法是，我想声明一个结构，它具有一定数量的字段，每个字段可以是一个int，或者在这种情况下它可以是一个指针，或者它本身可以是一个数组。但是规则基本上是，如果我为该结构中的所有不同数组元素字段引入这些结构之一，我将分配足够的空间。然后我将基本上跟踪每个字段的开始位置，并生成适当的代码以从头开始偏移，因此结构本身将成为结构的开始地址。然后我会使用适当的偏移量来到达不同的字段。</p><p>发言人   01:00:10<br>So here’s an example of some code, imagine. Have a pointer to one of these structures. And I have an index. And what I want to do is get to the that appropriate part of array A within this struct. Well, ay A is right at the beginning of this structure, so I can treat this just like I would any array reference, scaling Idx by four and adding it to the base to get the appropriate element. So I don’t really have to do anything special for this one.<br>这里是一些代码的例子，想象一下。有一个指向这些结构之一的指针。我有一个索引。我想做的是在这个结构中获得数组A的适当部分。好的，ay A就在这个结构的开头，所以我可以像处理任何数组引用一样处理它，将Idx缩放四并将其添加到基础以获得适当的元素。所以我真的不必为此做任何特别的事情。</p><p>发言人   01:00:51<br>Let’s look at some other code that you’ll typically see. Actually, this example is pretty involved. So I’m actually doing a whole bunch of stuff here with this one struct. First of all I’m trying to retrieve element I from the structure, then I’m using that to index into array A and insert a value into there. And then I’m updating this pointer to point to the next.<br>让我们来看一些你通常会看到的其他代码。实际上，这个例子相当复杂。所以我实际上在这里用这个结构做了很多事情。首先，我正在尝试从结构中检索元素I，然后我正在使用它来索引数组A并在其中插入一个值。然后我更新此指针以指向下一个。</p><p>发言人   01:01:28<br>If this were I’m going twist, what I want to do is step to the next element, one of the list. So I need to retrieve the next field from here. And so I’m actually making three references to this structure in this one, a rather small function. So let’s try and figure it all out.<br>如果我打算扭曲，我想做的是进入下一个元素，也就是列表中的一个。所以我需要从此处检索下一个字段。所以我实际上在这个结构中引用了三个，这是一个相当小的函数。所以让我们试着把一切弄清楚。</p><p>发言人   01:01:54<br>So first of all, I have to retrieve element I from it. And here you see that we know that element I is at offset 16. And here’s where you see that displacement field being used in the memory reference. Exactly for this purpose, I want to take R, but add 16 to it to get a memory address that I can use for. For I. And you see it actually uses move slq because I itself is an int, but I’m going to use it as an array index, in which case I have to scale it.<br>首先，我必须从中检索元素I。在这里你可以看到我们知道元素I在偏移16处。在这里，您可以看到内存引用中使用了位移场。正是出于这个目的，我想取R，但将其加上16以获得我可以使用的内存地址。对于我。你会发现它实际上使用了移动slq，因为I本身是一个int，但我会将它用作数组索引，在这种情况下，我必须缩放它。</p><p>发言人   01:02:36<br>I have to do address arithmetic using 8 B quantities. So this actually retrieves the 4 B value and does a sine extension on it. And now what I want to do is store a Val at L I, and so here you’ll see that it’s using Rax is the value I’ve just computed for I scaling by four and using the starting address of the r, which happens to be the starting address of A as well, and doing a store. So that’s sort of an array operation there. And then the next part is I’m going to offset 24, which is the position of next read from that location and store that in RDI, which is R, so this is the operation R gets r arrow next, and then the loop is I’m testing until R is null, so that’s going on here.<br>我必须使用8个B的数量进行地址算术运算。所以这实际上检索4 B值并对其进行正弦扩展。现在我想做的是在L I存储一个值，所以在这里你会看到它使用的是Rax，这是我刚刚计算出来的I缩放四的值，并使用r的起始地址，这恰好也是a的起始地址。做一家商店。所以这有点像数组操作。然后下一部分是我将偏移24，这是下一次从该位置读取的位置并将其存储在RDI中，即R，因此这是操作R得到r箭头，然后循环是我正在测试直到R为null，所以这是怎么回事。</p><p>发言人   01:03:48<br>So you see that those three references to the struct were implemented using three instructions here. So it’s a very direct mapping between the code here and the x 86 instructions and part of the x 86 instructions because this kind of stuff is so commonplace in programs they kind of made the instructions map very directly toward these operations. And now you should probably see why all the bells and whistles are there for these address references question.<br>所以你可以看到这三个对结构的引用是使用这里的三条指令实现的。因此，这里的代码与x86指令和部分x86指令之间是非常直接的映射，因为这种东西在程序中非常普遍，它们使得指令非常直接地映射到这些操作。现在你应该明白为什么这些地址参考问题都有花里胡哨的东西了。</p><p>发言人   01:04:26<br>What if I was three? I’m sorry? A has three elements. Yes, it will access. Actually, I think that’s a typo. He is supposed to be 4. So if I was four, it would access itself and it would mess things up. Question, this is a typo. By the way, it should be AF 4.<br>如果我是三个呢？对不起？A有三个元素。是的，它会访问。实际上，我认为这是一个错字。他应该是四岁。所以如果我四岁，它会自动访问，把事情搞得一团糟。问题，这是一个错字。顺便说一下，它应该是AF 4。</p><p>发言人   01:05:08<br>A null point. A null is 0.<br>一个零点。A null为0。</p><p>发言人   01:05:17<br>So that’s sort of the easy version of structs. Now let’s make them a little harder. One is, for reasons that are a bit obscure, the machine generally prefers that if you have a data type, an underlying data type of k bytes, the address that that starts at via multiple of k, and so that introduces a property we call alignment, which will actually, when a structure gets allocated well, the compiler will actually insert some blank unused bytes in the data structure in its allocation just so that it can maintain this alignment.<br>所以这是结构的简单版本。现在让我们让它们变得更难一点。一是，由于有些模糊的原因，机器通常更喜欢如果你有一个数据类型，一个基础数据类型k字节，这个地址从k的倍数开始，因此引入了一个我们称之为对齐的属性，它实际上将，当结构分配得好时，编译器实际上会在数据结构的分配中插入一些未使用的空白字节，以便它可以保持这种对齐。</p><p>发言人   01:06:01<br>So for example, here I is an int, and I want it to address to be a multiple of four, and I’ll give you a minute why that’s true. Just so trust me for a minute. And so actually pad 3 unused bytes here, because the first byte is being used by CE. And in general, we’ll see in the allocation, we’re going to make sure that the pointer to this data structure is itself a multiple of eight. And the reason for that is because there’s a double here, and it should reside on a boundary that it starting a dress should be a multiple of eight. And you’ll see, as long as this is 8, a multiple of eight, and this offset here is a multiple of eight, then this address will be a multiple of eight. So that’s the idea of alignment.<br>例如，这里I是一个int，我希望它的地址是4的倍数，我会给你一分钟为什么这是真的。请相信我一分钟。所以实际上在这里填充了3个未使用的字节，因为第一个字节被欧洲合格认证使用。一般来说，我们将在分配中看到，我们将确保指向此数据结构的指针本身是八的倍数。原因是这里有一个double，它应该位于一个边界上，它开始一件衣服应该是8的倍数。你会看到，只要这是8的倍数，并且这里的偏移量是8的倍数，那么这个地址将是8的倍数。这就是对齐的想法。</p><p>发言人   01:06:55<br>And so why is that true? Well, it’s really a hardware issue that the memory system, sort of the actual hardware memory, does not reference 1 B at a time. It references, actually, in most machines nowadays, about 64 B at a time, depending on various widths within the hardware. And in general, if a particular piece of data crosses the boundaries between two blocks that are because of a misaligned address, that will take extra steps by the hardware and potentially even the operating system to deal with. So just for efficiency reason, they say, do this alignment.<br>那么为什么这是真的呢？这确实是一个硬件问题，内存系统，有点像实际的硬件内存，一次不引用1 B。实际上，在当今大多数机器中，它一次大约引用64 B，具体取决于硬件的各种宽度。一般来说，如果一个特定的数据块由于地址不对齐而跨越了两个块之间的边界，那么硬件甚至可能是操作系统将需要额外的步骤来处理。所以他们说，仅仅出于效率的原因，进行这种对齐。</p><p>发言人   01:07:39<br>Trust me, in x 86 machines, if you have unaligned data, it will execute just fine. It just might run a little bit more slowly on some other machines. If you try to do an unwind access, it will actually cause a memory fault.<br>相信我，在x86机器上，如果你有未对齐的数据，它会正常执行。在其他机器上，它可能会运行得更慢一些。如果尝试进行解除访问，实际上会导致内存故障。</p><p>发言人   01:08:07<br>The question was, how can you force it to generate unwind data? I don’t know if you could. And we’ll talk about ways you can sort of be more clever in how you do your allocation to avoid wasting space. So in general, then we have, we’re mostly looking here at data types that are either 1, 2, or 4, 8 B long. There are some 16 B data types, but we won’t be looking at those.<br>问题是，你如何强迫它生成展开数据？我不知道你是否可以。我们将讨论如何更聪明地分配空间，以避免浪费空间。所以一般来说，我们在这里主要看的是1、2或4、8 B长的数据类型。有一些16 B的数据类型，但我们不会关注它们。</p><p>发言人   01:08:40<br>And in general, with the address, then you can tell the alignment of an address by how many zeros. If it’s a power of two alignment, how many 0 is there at the end of a bit level representation of that address? And so as we showed, in general, the C compiler, when it’s creating the layout for a structure, a structure will put in panning bytes in there to make the alignment work. The other thing it will do is if it need be, it will add bytes to the end to make sure that the overall size of the data structure meets whatever underlying alignment requirement there is.<br>通常情况下，通过地址，您可以通过多少个零来判断地址的对齐方式。如果它是两个对齐的幂，那么在该地址的位级表示的末尾有多少个0？因此，正如我们所展示的，通常情况下，C编译器在创建结构布局时，结构将在其中放置平移字节以使对齐工作。它会做的另一件事是，如果需要，它会在末尾添加字节，以确保数据结构的整体大小满足任何潜在的对齐要求。</p><p>发言人   01:09:22<br>And this one, because it contains a double, the overall data structure has to be aligned on an 8 B boundary. And the reasoning for that is, imagine I had an array of structs. Of these structs in particular, then, if I can assume that if I can ensure that this array is a address is a multiple of eight, then you can see that each successive element of this, these struct is a multiple of eight. And then within that struct I’ve ensured that each field that requires an alignment by 8 is positioned with an offset that’s a multiple of eight. And so it all works out. But if you try to tinker with this by making this too short, then you’d start getting misaligned references.<br>而这个，因为它包含一个double，所以整个数据结构必须在8 B边界上对齐。其原因是，想象我有一个结构数组。特别是这些结构，那么，如果我可以假设如果我能确保这个数组的地址是8的倍数，那么你可以看到这些结构的每个连续元素都是8的倍数。然后在该结构中，我确保每个需要对齐8的字段的偏移量是8的倍数。所以一切都成功了。但是如果你试图通过太短来修补这个，那么你就会开始得到不对齐的引用。</p><p>发言人   01:10:23<br>And so one thing you’ll see is for every struct, the actual alignment requirement depends on what’s the sort of worst case alment the maximum alignment of any element. So this particular structure, for example, contains a float v, which has a size of 4. And so this would be an alignment of 4. And you’ll see in the code in general, when it has all this address arithmetic we’ve seen gets used in various different ways, too. Scale values, compute offsets, and so forth to get the appropriate elements.<br>因此，您会看到的一件事是，对于每个结构，实际的对齐要求取决于最坏情况下的任何元素的最大对齐情况。所以这个特定的结构，例如，包含一个float v，其大小为4。所以这将是4的对齐。你会在代码中看到，当它具有我们所看到的所有这些地址算术时，也会以各种不同的方式被使用。缩放值、计算偏移等，以获得适当的元素。</p><p>发言人   01:11:06<br>So your question before is, could I tell the compiler not to do alignment? And the better way is to declare your fields in a. Way that minimizes the amount of wasted space. So for example, here, I wasted 3 B here and 3 B here to meet the alignment requirements. But if I just put I at the beginning and then C and D, I would have only wasted 2 B total.<br>所以你之前的问题是，我可以告诉编译器不要进行对齐吗？而更好的方法是在中声明您的字段。最大限度地减少空间浪费的方法。例如，在这里，我浪费了3 B和3 B来满足对齐要求。但是如果我只是把I放在开头，然后是C和D，我总共只浪费了2 b。</p><p>发言人   01:11:37<br>And in general, because all the alignment requirements are powers of 2, the sort of greedy algorithm works. It says, if I just put the biggest stuff at the beginning and then success with smaller elements, I will be able to minimize any wasted space. And that’s a general property. But this is a case where you, as the writer of c-code, have that effect. The compiler will not do this for you automatically.<br>一般来说，因为所有的对齐要求都是2的幂，贪婪算法的工作原理。它说，如果我只是把最大的东西放在开头，然后用较小的元素成功，我将能够最大限度地减少浪费的空间。这是一个普遍的属性。但这是一个你作为c代码的作者具有这种效果的案例。编译器不会自动为您执行此操作。</p><p>发言人   01:12:07<br>Question in the case of. Having. What’s that, oh, but remember an array? I don’t care about the array. I care about the elements of the array. This is only down at the lowest level where I’m accessing either a single int, a single double, or a pointer, and not all the rest of this stuff. Remember, I never read an entire array from memory, so alignment only refers down to the primitive types, not the aggregate types.<br>在案件中的问题。拥有。那是什么，哦，但记得一个数组吗？我不在乎数组。我关心数组的元素。这只是在最低级别下，我正在访问单个int，单个double或指针，而不是所有其余的东西。请记住，我从来没有从内存中读取整个数组，因此对齐只涉及原始类型，而不是聚合类型。</p><p>发言人   01:12:42<br>If this is confusing, the book covers this fairly carefully. So let me just finish up with a little glimpse of floating point.<br>如果这令人困惑，这本书会相当仔细地涵盖这一点。所以，让我以浮点数的一瞥作为结束。</p><p>发言人   01:12:54<br>Floating point is a complicated history in x 80 two-six Back in the really ancient S, there was a chip that went with the 8086 processor called the $8087. And at the time, it was a masterpiece of engineering to be able to come put all the hardware necessary to implement full IEEE floating point on a single chip. And it was the first one of its type. In fact, it was sort of co developed with the IEEE floating point standard itself. But the programming model for is horrendously awful and ugly. I used to, in older editions of the book, there were, it was in the first edition, it was in a webi sidetes, the second edition, and now it’s been expunged completely because it’s so awful.<br>浮点在x80中是一个复杂的历史，在真正古老的年代，有一个芯片与8086处理器一起使用，称为 $8087。在当时，能够在单个芯片上实现完整的iee浮点所需的所有硬件是工程的杰作。这是同类产品中的第一个。实际上，它是与IEEE浮点标准本身共同开发的。但是的编程模型非常可怕和丑陋。我曾经在这本书的旧版本中，有第一版，第二版，现在已经完全删除了，因为它太可怕了。</p><p>发言人   01:13:47<br>But more recently in the world of x 86, they realized that to support things like video and all the stuff people actually do with their machines, they needed some more horsepower and numeric processing, and they implemented a class of instructions called SSE, which stands for SIMD. Something SD execution anyways, and I’ll show you in a minute what that means. And that’s now in the more recent versions of x 86 has been juiced up to something called AVX. Which but the shark machines support this version of what’s called Ssc? So let me just give you a feeling for that. And in particular, the shark machines support what’s called SOC version 3.<br>但最近在x86的世界中，他们意识到要支持视频和人们在机器上实际做的所有事情，他们需要更多马力和数字处理，因此他们实现了一类名为SSE的指令，它代表SIMD。无论如何，有些事情SD卡执行，我稍后会向您展示这意味着什么。而现在最新版本的x86已经被加进了一个叫做AVX的东西。除了鲨鱼机器之外，哪一个支持这个叫做Ssc的版本？所以让我给你一个感觉。特别是鲨鱼机器支持所谓的SOC版本3。</p><p>发言人   01:14:43<br>And what it is is that there’s 16 special registers distinct from the other registers we’ve talked about before, each of which has 16 B. And then there’s operations that can operate on those and treat them in different ways. So one is to treat this, such an register, as an array of 16 cares, or as short or 4”. And also to support double floating point arithmetic. So this stuff was sort of going on. And somebody had the observation that said, well, I could just then sort of subset all this and implement the floating point operations directly using this SSE stuff and skip the old x 87 stuff. And so that’s the way floating point is now generated on, say, the shark machines. In most recent machines.<br>它是什么，有16个特殊寄存器与我们之前讨论过的其他寄存器不同，每个寄存器都有16个B。然后有一些手术可以对这些人进行手术并以不同的方式对待他们。所以我们应该把这个，这样一个寄存器，作为16个关心的数组，或者作为短的或4个 “。并且还支持双浮点运算。所以这种事情有点发生了。有人观察到说，好吧，我可以这样做，然后直接使用SSE的东西来实现浮点操作，跳过旧的x87的东西。这就是现在在鲨鱼机器上生成浮点的方式。在最近的机器上。</p><p>发言人   01:15:41<br>This is, again, an example of where the world is more complicated than it should have to be. So for example, there is an instruction that says add SS. So add a single scalar is what? That notation, add a single precision scalar. Add a scalar single precision and it looks a little like the add instructions, the add C instructions you’ve seen it increments. It adds the source to the destination.<br>这又是一个例子，说明世界比它应该有的更复杂。例如，有一个指令说添加SS。那么添加一个标量是什么？那个符号，添加一个单精度标量。添加一个标量单精度，它看起来有点像添加指令，你看到的添加C指令会递增。它将源添加到目标。</p><p>发言人   01:16:19<br>There’s ways I can do four ads all at the same time using this is what they call SD execution, which stands for single instruction, multiple data, one instruction, the add Ps P stands for pact. We’ll do well, we will perform that one instruction. Will you do add with four different numbers? And similarly, you can do it with double precision, You can do one of them, you can do a pet, and so actually the underlying and we’ll see this when we look at code optimization, if you write code to make use of these instructions, can really boost the performance of the computer.<br>有一些方法可以同时执行四个广告，这就是他们所说的SD卡执行，代表单指令，多数据，一条指令，add Ps P代表pact。我们会做得很好，我们将执行那一条指令。你会用四个不同的数字相加吗？同样地，你可以用双精度来完成，你可以做其中一个，你可以做一个宠物，所以实际上，当我们研究代码优化时，我们会看到这一点，如果你编写代码来利用这些指令，可以真正提高计算机的性能。</p><p>发言人   01:17:03<br>But this just gives you a flavor for what floating point code looks like.<br>但这只是为你提供了浮点代码的外观。</p><p>发言人   01:17:07<br>And the rules are pretty simple that just as we saw before, that arguments get passed in registers, well, floating point arguments get passed in these Xmm registers xmm zero, you don’t have to memorize RDI RSI RDX, they’re in Xmm 0 1 2. It’s all very logical and the return value is in Xmm 0 and all the registers are call or save, there’s no call you save. So something like adding two floating point numbers, what just look like a single floating point addition instruction, same with double and if you mix together code that has a pointer and a floating point operator, the pointer will be passed in a regular register RDI. And this double will be passed in XM 0. So as it goes through the argument list, you sort of in the particular order, if it’s an integer or a pointer, it’s in one of the R registers, and if it’s a floating point value, it’s in one of the Xmm registers and potentially interleaved. Almost done. And so this is code that does this particular operation.<br>规则非常简单，就像我们之前看到的一样，参数在寄存器中传递，浮点参数在这些Xmm寄存器中传递，xmm零，你不必记住RDI RSI RDX，它们在Xmm 0 1 2中。这一切都非常合乎逻辑，返回值以Xmm 0为单位，所有寄存器都是调用或保存的，没有您保存的调用。所以像将两个浮点数相加这样的东西，看起来就像一个浮点数加法指令，与double相同，如果您将具有指针和浮点运算符的代码混合在一起，该指针将在常规寄存器RDI中传递。这个双精度值将在XM 0中传递。因此，当它浏览参数列表时，按照特定的顺序排序，如果它是整数或指针，它在R寄存器中的一个，如果它是浮点值，它在Xmm寄存器中的一个，并且可能是交错的。几乎完成了。所以这是执行这个特定操作的代码。</p><p>发言人   01:18:29<br>And it’s interesting because it’s returning a, it’s doing memory referencing. So again, there’s instructions that will read from memory and copy into an Xmm register. You can add registers, you can make a copy from one Xmm register to another, and you can store results.<br>这很有趣，因为它返回了一个，它正在进行内存引用。所以，还有一些指令可以从内存中读取并复制到Xmm寄存器中。你可以添加寄存器，可以从一个Xmm寄存器复制副本到另一个，还可以存储结果。</p><p>发言人   01:18:50<br>So this code looks a lot like what you do in integer arithmetic, except it’s using Xmm and special floating point instructions rather than the ones you’ve seen before. So the basic idea of it is fairly simple. It gets way more complicated because there are lots of instructions double float on and on and on. There’s a special instruction to do square root and all this stuff. And the comparison stuff is really nasty and messy and hard to understand.<br>所以这段代码看起来很像你在整数算术中所做的，除了它使用Xmm和特殊的浮点指令，而不是你之前看到的那些。所以它的基本思想相当简单。它会变得更加复杂，因为有很多指令是双重浮动的。有一个特殊的指令来做平方根和所有这些东西。比较的东西真的很讨厌、混乱且难以理解。</p><p>发言人   01:19:24<br>You’ll see various tricks to use constant values too, so it’s covered in the book. We’re not going to really talk about it much in this course, but underlying the basic principles of it are fairly straightforward. Okay, that’ll do this for today.<br>你也会看到使用常量值的各种技巧，所以这本书已经涵盖了。在这门课程中，我们不会过多地谈论它，但它的基本原理相当简单。好的，今天就到这里。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深入理解计算机系统 007-Machine-Level Programming III, Procedures</title>
    <link href="/2025/10/12/15213-007/"/>
    <url>/2025/10/12/15213-007/</url>
    
    <content type="html"><![CDATA[<p>发言人   00:00<br>We’re still slogging through the material on machine level programming, which is I talked to you earlier, I think is in some ways the core of this course. Much of the rest of the material builds upon, and hopefully you’ve all had a chance to check out Lab 2 and your Bam lab, and you’ve got it and started on that. And certainly by the time you’re finished with the material from today, you will be well on the way to solving all but the last one or two stages of the bomb web. So I highly recommend you get going on that, not put it off to the last minute. And what we’re talking about today is, is how procedures. I’m going to use the same terminology here, whether it’s a function, a procedure, or an object oriented programming, a method, those are all roughly the same thing. And what we’ll talk about covers them overall.<br>我们仍在努力学习机器级别编程的内容，这是我之前跟你谈过的，我认为从某些方面来说这是本课程的核心。其余的大部分材料都是建立在这个基础上的，希望你们都有机会查看实验室2和你们的Bam实验室，你们已经掌握了并开始了。当然，当你完成今天的材料时，你将会很好地解决炸弹网的所有阶段，除了最后一两个阶段。所以我强烈建议你继续这样做，不要把它推迟到最后一刻。今天我们谈论的是程序。我在这里将使用相同的术语，无论是函数、过程还是面向对象的编程方法，这些都是大致相同的东西。我们将讨论的内容涵盖了它们的整体。</p><p>发言人   01:08<br>I’ll also mention at the outset that the way this is handled in the procedures that we’ll be talking about today is a combination of the actual x 86 hardware and how it supports it, but also in some ways, more importantly, a set of conventions that were developed that basically everyone agreed to. And it’s known as an ABI. That’s I want to, which stands for application binary interface.<br>我还将在一开始提到，在我们今天将要讨论的过程中处理这个问题的方式是实际的x86硬件及其支持方式的结合，但在某些方面，更重要的是，这是一套基本上每个人都同意的约定。它被称为ABI。这就是我想要的，它代表应用程序二进制接口。</p><p>发言人   01:49<br>So the idea is a document. You can get it online and it’s cited in the book. It’s a document that people put together, the initial version when the first X 8664 machines were first being developed. And specifically for Linux, they said OK, all Linux programs that all compilers, all the operating system, all the different parts of a system that need to have some common understanding of how to manage the resources on the machine, we agree to adhere to this set of rules. And so it goes beyond actual what the hardware does to a set of software standards. And it’s called application binary interface because it’s particularly the interface at the machine level, programming machine program level. And so that’s what we’ll be covering today.<br>所以这个想法是一份文件。你可以在网上获取它，并且它在书中被引用。这是人们编写的一份文件，是第一批x8664机器首次开发时的初始版本。特别是对于Linux，他们说好的，所有的Linux程序，所有的编译器，所有的操作系统，系统的所有不同部分，需要对如何管理机器上的资源有一些共同的理解，我们同意遵守这一组规则。因此，它超越了硬件的实际功能，而是一套软件标准。它被称为应用程序二进制接口，因为它尤其是在机器级别，即编程机器程序级别的接口。这就是我们今天将要报道的内容。</p><p>发言人   02:48<br>So people ask sort of, well, who makes up these rules and things? And the point was, there was a working group that did this, and there’s a separate ABI for Windows, it’s similar, but not quite the same. There’s a separate ABI for OSX for Apple, and even free BSD, A different variant of a unix-like operating system has its own ABI that they all share a lot of in common, but some of the details differ.<br>所以人们会问，谁制定了这些规则和规则？重点是，有一个工作组做了这件事，还有一个单独的Windows的ABI，它是相似的，但不完全相同。有一个单独的ABI for OSX for Apple，甚至免费的BSD，一个类似unix的操作系统的不同变体也有自己的ABI，它们都有很多共同点，但一些细节有所不同。</p><p>发言人   03:20<br>So if you think about what goes on in a procedure, even in C, which is a relatively unsophisticated language in many ways, there’s a lot going on. And so it’s worth breaking down those and thinking about it.<br>因此，如果你考虑一个过程中发生的事情，即使是在C语言中，这在很多方面都是相对不复杂的语言，也有很多事情要做。因此，值得将它们分解并思考。</p><p>发言人   03:34<br>One is there’s a notion of control. So in my example, I show a procedure P calling a procedure Q, and so when p calls Q, then somehow the program has to jump down and begin executing the lines of code for Q, and then when Q hits it’s exit point, it’s point. Somehow it’s to get back to P and not just to any old place in P, but specifically to whatever came comes in p right after the call to Q, so somehow we have to record the information about where the return should be to be able to return to the correct place. So that’s, first of all, passing and control to a function and having that function return back to where it should get back to. Second, there is data, how do we get operands to it? So in this particular case, q is a function that takes a single argument that it calls internally. It calls I and up here, where p is calling it, it’s passing some value within p called x, so somehow that data value of x has to be recorded in a form that within q, it will have access to that information. And similarly, when q wants to return a value, and then P will make use of that value, there has to be some convention of how that data gets communicated back.<br>一是有控制的概念。所以在我的例子中，我展示了一个过程P调用一个过程Q，当p调用Q时，程序必须以某种方式跳下并开始执行Q的代码行，然后当Q到达它的退出点时，它就是点。在某种程度上，它是为了回到P，而不仅仅是回到P中的任何旧地方，而是特别是在调用Q之后，p中出现的任何东西，因此我们必须以某种方式记录返回应该在哪里的信息，以便能够返回到正确的位置。首先，传递控制给一个函数，让该函数返回到它应该返回到的地方。第二，有数据，我们如何得到它的操作数？因此，在这种特定情况下，q是一个函数，它接受内部调用的单个参数。它在这里调用I，p在这里调用它，它在p中传递一些值称为x，所以x的数据值必须以一种形式记录在q中，它将有权访问该信息。同样，当q想要返回值，然后P将利用该值时，必须有一些约定来确定数据如何传回。</p><p>发言人   05:07<br>And then finally, in a function might have some local data that requires allocation of some amount of space. And so where does that space get allocated? How do we make sure it gets allocated properly? And in particular, in C, as you know, when a function returns, any local data that it all-local should de-allocated should be freed up so that we don’t sort start consuming an unbounded amount of storage. So how do we do that?<br>最后，在一个函数中可能会有一些本地数据需要分配一些空间。那么这个空间分配在哪里呢？我们如何确保它被正确分配？特别是在C语言中，正如你所知道的，当一个函数返回时，它所有本地的数据都应该被释放，这样我们就不会开始消耗无限的存储量。那么我们该怎么做呢？</p><p>发言人   05:38<br>Those are all the of different aspects that a procedure call and return have to deal with somehow. And part of the reason for breaking it down into those good old segments is in X 8 664.<br>这些是过程调用和返回必须以某种方式处理的所有不同方面。将其分解为那些好的旧段的部分原因是在X 8 664中。</p><p>发言人   05:53<br>One of the clever things they did was to try and reduce the overhead of procedure calls as much as possible, because as you know, in good programming style, you often write these functions that do a fairly small amount of actual useful stuff. And it’s sort of good programming style to do that, especially in a more object oriented programming style. And so you don’t want the overhead, the extra number of steps taken to invoke a procedure and deal with all those aspects to take any more time than it needs to, because it’s a fairly critical overhead. So one of the things they do in this is they only do whatever is absolutely needed. So in particular, if no local storage is needed on this for data, then don’t allocate it, Don’t free it. If you’re not passing any values, don’t pass them. And in general, sort of how little can you get away with. And that makes it a little bit confusing from teaching point of view and that there’s no set template that it follows every time it sort of you have each case is a special case for how a particular procedure gets implemented.<br>他们做的一件聪明的事情是尽可能地尝试减少过程调用的开销，因为如你所知，在良好的编程风格中，你经常编写这些函数来做相当少量的实际有用的事情。这样做是一种很好的编程风格，特别是在更面向对象的编程风格中。因此，您不希望开销，即调用过程和处理所有这些方面所需的额外步骤数量花费比需要更多的时间，因为这是相当关键的开销。所以他们在这方面做的一件事是他们只做绝对需要的事情。因此，特别是，如果数据不需要本地存储，那么不要分配它，也不要释放它。如果您没有传递任何值，请不要传递它们。总的来说，你几乎无法逃脱。从教学的角度来看，这有点令人困惑，而且没有固定的模板，每次你有这种情况时，它都会遵循每个案例是如何实现特定过程的特殊情况。</p><p>发言人   07:11<br>So we’ll go through all these parts and see how they happen. And you’ve already seen little glimpses of them looking at the little fragments of code that we’ve shown already.<br>所以我们将浏览所有这些部分，看看它们是如何发生的。你已经看到了他们在看我们已经展示的代码小片段的一些小瞥见。</p><p>发言人   07:22<br>So the first one, sort of the most critical, is how do we pass control to a function? But before we can even talk about that, we have to talk about the stack. And you’ve heard that term, the stack in various ways. The stack is really not a special memory. It’s just a region of the normal memory. Remember, to the programmer’s perspective, some of a programmer’s perspective is memory is just a big array of bytes, and somewhere within that bunch of bytes, we’re going to call it the stack.<br>所以第一个问题，也是最关键的，就是我们如何将控制权传递给一个函数？但在我们谈论这个之前，我们必须先谈论堆栈。你听说过这个术语，堆栈的方式有很多种。堆栈实际上并不是特殊的内存。这只是正常记忆的一个区域。请记住，从程序员的角度来看，内存只是一个大的字节数组，在这一堆字节中，我们称之为堆栈。</p><p>发言人   08:00<br>Stack is used by the program to manage the state associated with the procedures that it calls as they return. All these potential information, the control information data and allocates local data. And the reason why it can be managed as a stack is because of the nature of the whole idea of procedure calls and returns that you make a call and you might need some information, but when you return from a call, all that information can be discarded. And so it makes use of that sort of last in, first out allocation principle meshes very well with this idea of procedure call and return.<br>堆栈被程序用来管理与其调用的过程相关联的状态，这些过程在返回时被调用。所有这些潜在信息，控制信息数据并分配本地数据。之所以可以将其作为堆栈进行管理，是因为过程调用和返回整个概念的本质，您进行调用可能需要一些信息，但是当您从调用返回时，所有这些信息都可以丢弃。因此，它利用了这种后进先出分配原则，与过程调用和返回的概念非常吻合。</p><p>发言人   08:46<br>So in x 86 stacks actually start with a very high numbered address and when they grow when more data are allocated for the it’s done by decrementing the stack pointer, So the stack pointer, as you know, is just a regular register Rsp. And its value is the address of the current top of the stack. And every time you allocate more space on the stack, it does it by decrementing that pointer now just for convention and.<br>因此，在x86中，堆栈实际上从一个非常高的地址开始，当它们增长时，随着为它分配更多的数据，它通过递减堆栈指针来完成，因此堆栈指针，如你所知，只是一个常规寄存器Rsp。其值是当前堆栈顶部的地址。每次您在堆栈上分配更多空间时，它都会通过递减该指针来实现，仅用于约定和。</p><p>发言人   09:24<br>I’m not sure why this happens, but this is the way we do it is we draw stacks upside down so that the term, the top of the stack is actually shown at the bottom. And just to add to that confusion, and also remember that the addresses go from bottom to top, not from top to bottom. So when you add to the stack, you decrement the stack pointer. Neither of those kind of meshes with your intuition, perhaps, but you just have to get used to it. We’re not going to redraw all the slides. So anyways, remember that over and over again. And that’s why these arrows show that if we were to enumerate the addresses of these different bytes in the data, they’d be increasing in this direction.<br>我不确定为什么会发生这种情况，但我们的做法是颠倒绘制堆叠，这样术语 “堆叠的顶部” 实际上会显示在底部。为了增加混淆，还要记住地址是从下到上，而不是从上到下。因此，当您添加到堆栈时，您将递减堆栈指针。这两种网格都不符合你的直觉，也许，但你只需要习惯它。我们不会重新绘制所有的幻灯片。所以无论如何，一遍又一遍地记住这一点。这就是为什么这些箭头表明，如果我们要枚举数据中这些不同字节的地址，它们会朝着这个方向增加。</p><p>发言人   10:19<br>And when we add to the stack, the stack top is at the bottom of the picture. And we do it by decrementing the stack pointer. So in particular, there’s explicit instructions. Push and pop, make use of the stack. And it’s often written push Q and pop Q, but that Q is actually an optional suffix on the instruction. So the idea of pushing something onto the stack then is there is some source operand.<br>当我们添加到堆栈时，堆栈顶部位于图片的底部。我们通过递减堆栈指针来实现。特别地，有明确的指示。Push和pop，利用堆栈。它通常写为push Q和pop Q，但Q实际上是指令上的可选后缀。因此，将某些东西推入堆栈的想法是有一些源操作数的。</p><p>发言人   10:56<br>It could be from register or from memory or an immediate. So this is sort of like a move instruction, but the destination of the move will be toward memory. And the address of the memory is determined by first decrementing the stack pointer and then doing a write. And similarly, the pop instruction takes reads data from the stack and stores it in the destination, which must be a register for this particular instruction. I think push must be a register too, now that I think of it, or immediate can’t from memory to so pop reads from memory, the address it reads from is given by the current stack pointer, and then it increments the stack pointer by 8. These both work only on 8 B operands. I’ll get to you in a second, and then the result of that is stored in a register question.<br>它可以来自寄存器、内存或即时。这有点像移动指令，但移动的目的地将是内存。内存的地址是通过首先递减堆栈指针然后进行写入来确定的。同样，pop指令从堆栈中读取数据并将其存储在目标中，目标必须是此特定指令的寄存器。我认为push也必须是一个寄存器，现在我想到了它，或者立即无法从内存中弹出读取内存，它读取的地址由当前堆栈指针给出，然后它将堆栈指针增加8。这两个都只能在8 B操作数上工作。我马上就会找到你，然后结果会存储在一个寄存器问题中。</p><p>发言人   12:11<br>Like, is there a difference between like using the pop? Oh, could you write it as a set of instructions? Yeah, you could actually, except for some weird corner cases, write it out as a set of separate instructions. But it’s a common enough thing that sort of built in as an operation, whereas call and return are special, they can’t be simulated.<br>喜欢，使用流行音乐有区别吗？哦，你能把它写成一组说明吗？是的，除了一些奇怪的角落情况，你实际上可以把它写成一组单独的指令。但这是一种很常见的内置操作，而调用和返回是特殊的，它们无法模拟。</p><p>发言人   12:37<br>So one thing to remember, too, is it’s important that in one case, you decrement, you do the arithmetic on the stack pointer before you write. Because when you first started out, the stack pointer was pointing to whatever was the top element of the stack. We want to create a new top element, so we’re going to decrement first and then do the row, whereas going the other direction, you want to read off the current top of stack element, and then you want to increment the stack pointer to sort of locate it. And one thing you’ll notice here is when I say de-allocate, it’s not like I magically erase this or something. All I’m doing is just moving a stack pointer, whatever was there at the top of the stack is still in memory. It’s just no longer considered part of the stack.<br>所以要记住的一件事是，在一种情况下，重要的是，在编写之前，你要对堆栈指针进行递减运算。因为当你刚开始的时候，堆栈指针指向堆栈的顶部元素。我们想要创建一个新的顶级元素，因此我们将首先递减然后执行行，而在另一个方向上，您想要读取当前堆栈顶部元素，然后想要递增堆栈指针以查找它。在这里你会注意到的一件事是，当我说 “取消分配” 时，它不像我神奇地擦除这个或什么东西。我所做的只是移动一个堆栈指针，堆栈顶部的任何东西仍然在内存中。它不再被视为堆栈的一部分。</p><p>发言人   13:33<br>So the idea of the stack and the instructions push and pop are to put data on the stack or take it off. But we use the same basic idea for recall and return.<br>因此，堆栈的思想和指令push和pop是将数据放入堆栈或将其取出。但是我们对回忆和返回使用相同的基本思想。</p><p>发言人   13:50<br>So let’s look at some examples. And there’s a lot of stuff up here, but this is AC function called Mt store. And then this is the slightly cleaned up output from the disassembler of that exact function. And similarly, this is a function called Mt 2, and this is its disassembled version. And the reason I’m showing this is because I want to make use of the addresses. These instructions are out that you don’t see when you write it in assembly code. So I’m showing it the disassembled version. And the reason all this is up here is because you’ll see the function malt store calls a Mt too. So I want to show how that works.<br>让我们看一些例子。这里有很多东西，但这是交流名为Mt store的功能。然后这是从该确切函数的反汇编程序中稍微清理过的输出。类似地，这是一个名为Mt 2的函数，这是它的分解版本。我展示这个的原因是因为我想利用这些地址。这些指令已经输出，当你用汇编代码编写它时看不到。所以我正在展示它的拆卸版本。所有这些出现在这里的原因是因为您会看到函数malt store也调用Mt。所以我想展示一下它是如何工作的。</p><p>发言人   14:36<br>So, and there’s two instructions, and you’ve seen these in some form to call a function, you just call it where you give a label. But keep in mind that these two instructions, and the other is when you’re ready to return, you just execute the ret instruction. And keep in mind, though, that these functions don’t do the whole business of procedure call and return. They just do the control part of it, which is we saw as only one of three aspects of a procedure.<br>所以，这里有两条指令，你已经看到它们以某种形式调用一个函数，你只需在给出标签的地方调用它。但请记住，这两条指令，另一条是当你准备返回时，你只需执行ret指令。请记住，这些函数并不执行过程调用和返回的全部业务。他们只是做控制部分，我们认为这只是一个过程的三个方面之一。</p><p>发言人   15:09<br>I also mentioned, you’ll see, especially in sometimes that we’ll say reap semicolon ret, and you can pretty much just ignore that. And it’s a bit obscure why it’s even there. It’s really the same idea.<br>我还提到，你会看到，特别是有时候我们会说收割分号，你几乎可以忽略它。它为什么还在那里有点模糊。这其实是同样的想法。</p><p>发言人   15:31<br>Okay, so let’s sort of break this down into its simplest part. So let’s imagine a scenario in which the top of stack is at hex address 120, which is not realistic, by the way. And the program counter, which is called RP, which is not anything to do with death, is indicating that the current instruction is at 544, which is this call instruction. And so what would happen with the call instruction is it would do two things. It would actually three things, the Sta pointer subtracting 8 from one to 0 in hex gives you 118, and it would write the address of the instruction following the call onto the top of the stack. And it’s important that it does it the one following the call, because if that’s the instruction I’m going to return use for my return address and I want to resume execution in this function at the instruction after the call, not the call itself. Otherwise you’d have an infinite loop.<br>好的，让我们把它分解成最简单的部分。所以让我们想象一个场景，其中栈顶在十六进制地址120，顺便说一下，这是不现实的。而程序计数器被称为RP，与死亡无关，它指示当前指令位于544，这是这个调用指令。因此，调用指令会做两件事情。它实际上有三个东西，Sta指针在十六进制中将8从1减到0得到118，它会将调用后的指令地址写入堆栈顶部。重要的是它在调用之后执行，因为如果这是我要返回使用我的返回地址的指令，并且我想在调用后的指令处恢复此函数的执行，而不是调用本身。否则，你将有一个无限循环。</p><p>发言人   16:55<br>And it is call instruction Also embedded in the encoding of the instruction is the. Destination address of it. Which happens to be the starting address of this particular function? So the program counter will be set to that value. And now the processor starts just executing along these instructions.<br>它是嵌入在指令编码中的呼叫指令。它的目标地址。哪个恰好是这个特定函数的起始地址？所以程序计数器将被设置为该值。现在处理器开始沿着这些指令执行。</p><p>发言人   17:23<br>So it did a combination of a jump and a push. And that’s why the question was raised earlier is a push instruction, could you assemble that out of existing instructions? The answer is yes for push, but not for call question back there before you actually go to the function. And like bolt store, you would put the address of multi into two. No, no, it did that. You never explicit Ares that manipulate that. It’s implicitly part of the call instruction.<br>所以它做了一个跳跃和推动的组合。这就是为什么前面提出的问题是一个推送指令，你能在现有指令的基础上组装它吗？对于推送的答案是肯定的，但对于在你实际使用该功能之前的呼叫问题的答案不是肯定的。就像螺栓商店一样，你会把multi的地址分成两部分。不，不，它做到了。你从来没有明确表示操纵的是什么。它隐式地是调用指令的一部分。</p><p>发言人   18:00<br>The call instruction will take, I don. It. Call instruction. It longs coding. And so it will take that address and use it for the new value of the program counter. So the call does both the pushing of the old, the return pointer, and setting the program counter to the new, the target for it. So it does both of those things. Question?<br>呼叫指令将会执行，我不知道。它。呼叫指令。它渴望编码。因此，它将获取该地址并将其用于程序计数器的新值。所以这个调用执行了老指针的推送返回，并将程序计数器设置为新的目标。所以它做了这两件事。问题？</p><p>发言人   18:47<br>I don’t think so with either call or return. If so, it would be really obscure. No, I don’t think so, no. So call and return are the there might be some weird system instructions that let you do that, but not you’d see in any normal program. Other questions? These are good questions.<br>我不这么认为，无论是打电话还是退货。如果是这样，那就会非常晦涩。不，我不这么认为，不。所以调用和返回可能会有一些奇怪的系统指令让你这样做，但在任何正常程序中都不会看到。其他问题？这些问题很好。</p><p>发言人   19:17<br>So that shows you control how the call works. And then so now imagine this multi two chugs along and it hits its return point and it hits this re instruction. But by the way, again, Q and red are the same instruction. And Rhet, well, its purpose is to sort of reverse the effect of a call. It assumes that the top of the stack has an address that you want to jump to. So it will pop that address off the stack, meaning it will increment the stack pointer. Like I said, the value doesn’t really disappear from the memory, is no considered part of the stack, and then it will set the program counter to what it just popped off the stack, and that will cause the program to resume back to where it came from. So you see that sort of clever idea of pushing the address of the next instruction so when the return comes, it will get it to the point where it should resume execution.<br>这表明您可以控制呼叫的工作方式。现在想象一下这个多两个点之间的碰撞，它达到了它的返回点，并且达到了这个重新指令。顺便说一下，Q和red是同一个指令。和Rhet，其目的是在某种程度上逆转呼叫的效果。它假设堆栈的顶部有一个您想要跳转到的地址。因此它将从堆栈中弹出该地址，这意味着它将增加堆栈指针。就像我说的，该值并没有真正从内存中消失，也没有被视为堆栈的一部分，然后它会将程序计数器设置为刚刚从堆栈中弹出的内容，这将导致程序恢复到原来的位置。所以你看到了推送下一条指令的地址这种聪明的想法，这样当返回到来时，它就会到达它应该继续执行的点。</p><p>发言人   20:28<br>Okay, so that’s passing control. It’s pretty simple, all these things, by the way, and is just the nature of machine code. Every single part of it is pretty simple because it’s designed to be executed by the original hardware was fairly simple. It’s not anymore, but it’s really the basic ideas are and that we use kind of combinations of instructions to build up all the layers associated with operations like procedure, call, and return data.<br>好的，那就是通过控制权。顺便说一下，所有这些事情都非常简单，这只是机器代码的本质。它的每一个部分都非常简单，因为它的设计是由原始硬件执行的，非常简单。现在不是了，但它的基本思想是，我们使用各种指令组合来构建与过程、调用和返回数据等操作相关的所有层。</p><p>发言人   21:00<br>Now, we’ve already seen a few small examples of passing data. A couple registers that get used when you’re passing arguments to a function. And we’ve seen the register rax getting used to return values from a function. And so that’s the basic idea. And again, this is all built into this ABI, defined as a set of conventions, not particularly a part of the hardware. So in particular, the rule is that the first six arguments get passed. In these particular registers. And you just have to memorize the order of them or have a table handy to look at or something like that, because there’s no particular logic to it. And the return value is returned in register Rax.<br>现在，我们已经看到了一些传递数据的小例子。当您将参数传递给函数时使用的几个寄存器。我们已经看到了寄存器rax习惯于从函数返回值。这就是基本思想。再次强调，这一切都内置在这个ABI中，定义为一组约定，不是特别硬件的一部分。所以特别的是，规则是前六个参数被传递。在这些特定的登记册中。你只需要记住它们的顺序，或者手边有一张桌子可以看，或者类似的东西，因为它没有特定的逻辑。并且返回值在寄存器Rax中返回。</p><p>发言人   21:59<br>And by the way, this, this is all for arguments that are either integers or pointers. I think I’ve got a little bit unfolding point. Those are passed in a separate set of registers.<br>顺便说一句，这一切都是针对整数或指针的参数。我想我有一点点展开的观点。这些在一组单独的寄存器中传递。</p><p>发言人   22:10<br>So these are just assume now we just are dealing with integer data, pointer data. And then you ask, well, what happens if you have more than six arguments to a function which isn’t very common, but it happens? Well, the rule on that is those get put in memory on the stack. And I’ll illustrate what I mean by that. So they’re passed to the function, and then the function has to retrieve those values off the stack.<br>所以这些只是假设现在我们只是在处理整数数据，指针数据。然后你问，如果一个函数有六个以上的参数，这不是很常见，但会发生什么？好的，那方面的规则是那些被放入堆栈上的内存中。我会说明我的意思。所以它们被传递给函数，然后函数必须从堆栈中检索这些值。</p><p>发言人   22:38<br>Back in the bad old days of IA 32, by the way, all the arguments got passed on the stack. But now, for the most part, you pass arguments in the registers. And the reason for that is register access is way faster than memory access. Okay? So here’s a kind of messy bunch of code, but just to show all the time.<br>顺便说一下，在IA 32糟糕的日子里，所有的参数都被传递到堆栈上。但是现在，大部分情况下，您可以在寄存器中传递参数。原因是寄存器访问比内存访问快得多。好吗？所以这里有一堆杂乱的代码，但只是为了一直显示。</p><p>发言人   23:09<br>And you can just see within this code that it’s making use of registers like RDI doesn’t show where and. In other places like Mt 2 has two arguments and you can see how it’s making use of RDI and RSI in the code. So basically, the code is generated under the assumptions that whatever arguments is being passed to, it will be passed in that particular set of registers in the particular order they’re listed. And the code sort of makes those assumptions. And then similarly, when you have a return value from a function, I would see Mt store does not have a return value, but Mt 2 does. And the way it does is it deposits the value into Rax. And then when the return from Rax occurs, a Tumult store, you see that it assumes now that the Mt store code can assume that register Rax holds the value, the return value, and it can store in its destination register.<br>你可以在这段代码中看到它正在使用寄存器，就像RDI没有显示位置和。在其他地方，比如Mt 2有两个参数，你可以看到它是如何在代码中使用RDI和RSI的。基本上，代码是在以下假设下生成的: 无论传递给什么参数，它都将按照列出的特定顺序传递到该组特定的寄存器中。代码会做出这些假设。类似地，当你有一个函数的返回值时，我会看到Mt store没有返回值，但Mt 2有。它的做法是将价值存入Rax。然后当Rax的返回发生时，一个动荡的存储区，你会看到它现在假设Mt存储区代码可以假设register Rax保存了值，返回值，并且它可以存储在其目标寄存器中。</p><p>发言人   24:28<br>And we’ll look in a minute why rbx gets used here. We’ll cover that in just a little waiter, but that’s the point that as long as everyone sticks to this common interface standard, then you can even use different compilers to compile code and have them be able to cooperate with each other in terms of passing arguments, returning data. And that’s the reason why you want that convention, yes.<br>我们稍后会看一下为什么这里使用rbx。我们将在一个小服务员中介绍这一点，但只要每个人都坚持这个通用的接口标准，那么你甚至可以使用不同的编译器来编译代码，并让它们能够在传递参数、返回数据方面相互合作。这就是你想要那个惯例的原因，是的。</p><p>发言人   25:00<br>8 B because, well, first of all, for call and return, it’s a 64 b machine. So all addresses are 64 b or 8 B. But also even the push and the pop instruction only work on 8 B values. If you said push L, if you tried to write that in 64 b code, it would come back with a syntax error on it if you had it in the Asse.<br>8 B，因为，首先，对于呼叫和返回，它是一台64 b的机器。所以所有地址都是64 b或8 B。但是即使是push和pop指令也只能在8 B的值上工作。如果你说push L，如果你试图用64 b代码编写它，如果你把它放在Asse中，它会返回一个语法错误。</p><p>发言人   25:31<br>And that’s different. IA 32, there’d be 4 B values here. So like I said, you’ve sort of seen that implicitly in some of the code you’ve already been looking at. Pretty straightforward to get an example that shows passing arguments, you have to have a function with at least seven arguments, which is pretty messy to do. So I won’t do it. But there’s examples in the book. But now, and we’ll sort of pick it up. I’ll show you also in this later part.<br>那就不同了。如果是32，这里应该有4个B的值。就像我说的，你已经在一些你已经看过的代码中隐含了这一点。要获得一个显示传递参数的例子非常简单，你必须有一个至少有七个参数的函数，这相当混乱。所以我不会这么做。但书中有例子。但是现在，我们会把它捡起来。我将在后面的部分向您展示。</p><p>发言人   26:09<br>And now the third part of it is, again, what if there’s some local data that we need to make use of. And so to get that idea across, I have to illus, bring in another concept, which is called the stack frame. And so this is a particular allocation pattern that’s used in memory.<br>现在第三部分是，如果有一些我们需要利用的本地数据怎么办。为了让这个想法得到理解，我必须引入另一个概念，称为堆栈框架。因此，这是内存中使用的特定分配模式。</p><p>发言人   26:30<br>And as I mentioned earlier, one of the features of calling and returning is you can imagine when you have a nested series of calls to a function, when a particular function is executing, it only needs to reference the data within that function or values that have been passed to it, some of which might be pointers, and therefore pointing to other will in memory. But the point is, the rest of the functions in your code, however many they are, are sort of frozen at that moment. Really, there’s only one function executing at any given time. I’m assuming a sort of what you’d call a single threaded model here. And so we can just allocate on this stack, whatever space is required for this particular function, And then when we return from that function, we shouldn’t, if it’s correctly written, need any of the information associated with that function. It can just sort of disappear forever. And that’s why this idea of a stack, you allocate something, if you make more calls, you keep allocating more stuff, but as they return, you kind of back out of the stack and free things up. So the stack discipline is exactly the right matches.<br>正如我之前提到的，调用和返回的特点之一是，当你有一个嵌套的一系列函数调用时，当一个特定的函数正在执行时，它只需要引用该函数中的数据或传递给它的值，其中一些可能是指针，因此指向内存中的其他意志。但关键是，你代码中的其余函数，不管它们有多少，在那一刻都有点冻结了。实际上，在任何给定时间只有一个函数执行。我假设你在这里称之为单线程模型。因此，我们可以在此堆栈上分配此特定函数所需的任何空间，然后当我们从该函数返回时，如果写入正确，我们不需要与该函数相关的任何信息。它可能会永远消失。这就是为什么这个堆栈的想法，你分配一些东西，如果你打更多的电话，你就会不断分配更多的东西，但是当它们返回时，你就会从堆栈中退出来，释放一些东西。所以堆栈纪律是完全正确的匹配。</p><p>发言人   27:57<br>Well, this whole idea of procedure call and return. So each block we use for a particular call, that is called a stack frame. And to be sort of more technical, we’ll say it’s a frame for particular instance of a procedure, a particular call to a procedure.<br>好的，这整个过程调用和返回的想法。因此，我们用于特定调用的每个块称为堆栈帧。并且更技术性地说，我们会说它是过程的特定实例的框架，对过程的特定调用。</p><p>发言人   28:26<br>Which calls a function called who? And who has multiple calls to another function called mi? And mi is recursive. It calls itself. And imagine we had a chain of calls. Where you calls, who calls? Mi, which calls itself recursively twice. And then we’ll exit out of Mi and get back to who? And then who will hit a second call to Mi, which any further?<br>哪个调用了一个叫做谁的函数？谁多次调用另一个名为mi的函数？并且mi是递归的。它自称。想象一下我们接到了一连串的电话。你在哪里打电话，谁打电话？Mi递归调用自己两次。然后我们将退出Mi并回到谁那里？然后谁会给我打第二个电话，哪个还会打吗？</p><p>发言人   29:08<br>It. But in terms of the stack? All we need, we’ll keep a frame for every sort of procedure that has been called but not yet returned on the stack. And in general, this stack is limited delimit by two pointers. One is the stack pointer, which we’re familiar with. And then there’s another called the base pointer, which register RBP indicates. But one feature of actually, it’s now become a feature of IA 32 as well, is that this is an optional pointer. And in particular, the code that we’ll see does not use a base pointer, except in some very special cases, this register.<br>它。但是在堆栈方面？所有我们需要的，我们将为已经调用但尚未返回到堆栈上的每种过程保留一个框架。一般来说，这个堆栈由两个指针分隔。一个是我们熟悉的堆栈指针。然后还有另一个称为基础指针的东西，它由寄存器RBP指示。但是实际上，它现在也成为了IA 32的一个功能，那就是这是一个可选的指针。特别是，我们将看到的代码不使用基本指针，除了在一些非常特殊的情况下，这个寄存器。</p><p>发言人   30:06<br>Show up in program being used in a special way as a frame pointer. It will be used instead just as a regular register.<br>出现在程序中，以一种特殊的方式作为帧指针使用。它将被用作常规寄存器。</p><p>发言人   30:16<br>So typically then, the only thing you’ll know about the stack pointer, you won’t even be able to figure out where the frame is exactly. You’ll just know that the top part of the stack is the top frame for the topmost function. And this is all managed by the code itself. And this is the same stack, by the way, in which you’re pushing in popping addresses too. And they all kind of get mixed together.<br>通常情况下，你唯一知道的关于堆栈指针的事情，你甚至无法弄清楚帧的确切位置。你只需要知道堆栈的顶部是最顶部函数的顶部框架。这一切都由代码本身管理。顺便说一下，这是同一个堆栈，你也在其中推入弹出地址。而且它们都有点混合在一起。</p><p>发言人   30:49<br>So we haven’t actually seen any code up till now that has to do any explicit management of the stack, because all our examples were very simple and just did made use of the stack only for return addresses. But we’ll see some that uses more. But so in general, then imagine that each time you begin a function, some space gets allocated potentially on the stack for its frame. And then, and that frame is indicated by either one pointer only or two pointers.<br>因此，到目前为止，我们还没有真正看到任何需要对堆栈进行任何显式管理的代码，因为我们所有的示例都非常简单，只是将堆栈仅用于返回地址。但我们会看到一些使用更多的。但一般来说，再想象一下，每次开始一个函数时，一些空间可能会在堆栈上分配给它的帧。然后，该帧由一个指针或两个指针指示。</p><p>发言人   31:29<br>And so now as u calls who, then that will create a new stack frame for who in some way, when Mi gets called, that creates a new stack frame.<br>所以现在当u调用谁时，这将以某种方式为谁创建一个新的堆栈帧，当Mi被调用时，这会创建一个新的堆栈帧。</p><p>发言人   31:40<br>And as we continue with these recursive calls, we’re just adding more stuff to the stack, getting deeper and deeper. And that will keep happening. That’s one of the reasons why recursion is a little bit of a risky thing is that compared to iteration, it keeps requiring more space as you go deeper in the current. And in particular, most systems limit the total depth of the stack, And you can have, because they’re afraid of the sort of infinite loop version of recursion, runaway recursion, where it just keeps trying to push more and more stuff onto the stack.<br>随着我们继续这些递归调用，我们只是在堆栈中添加更多的东西，越来越深。这将继续发生。这就是递归有点冒险的原因之一，与迭代相比，随着您在当前领域的深入，它需要更多的空间。特别是，大多数系统限制了堆栈的总深度，因为它们害怕递归的无限循环版本，失控递归，不断尝试将越来越多的东西推到堆栈上。</p><p>发言人   32:20<br>That’s an aside. And then? As these begin to return, those frames get deallocated, removed from the stack.<br>那是旁白。然后呢？当这些开始返回时，这些帧会被释放，从堆栈中移除。</p><p>发言人   32:32<br>So part of it, the nice thing about this is it means that every time, if I have multiple calls to Mi, because I’ve gone deep recursively, each one of them will have its own local state that it needs to manage. And again, the whole stack discipline is what makes it work. And what we’ll find out in particular is because of the way this is set up, recursive calls are handled the same way that regular calls are. There’s nothing special about them. All sort of infrastructure required to support recursion is built into this whole stack discipline.<br>所以其中的一部分，这样做的好处在于，这意味着每次，如果我有多个Mi调用，因为我已经递归地深入了，它们中的每一个都有自己需要管理的本地状态。再次强调，整个堆栈规程是使其工作的原因。我们将特别发现的是，由于这种设置方式，递归调用的处理方式与常规调用相同。他们没有什么特别的。支持递归所需的所有基础设施都内置在整个堆栈规程中。</p><p>发言人   33:16<br>So anyways, imagine that all these calls returned back to Who? And then who would call Mi again? And then again as we exit, we’re sort of deallocating these stack frames and getting back to the starting point. Yes, question?<br>所以无论如何，想象所有这些呼叫都返回给了谁？然后谁会再打电话给Mi？当我们退出时，我们会重新分配这些堆栈帧并回到起点。是的，有问题吗？</p><p>发言人   33:39<br>Oh, so the question was, if RBP is optional, then how does the program know how to do the deallocation? How can it reset the stack back to the right place? And the answer is, and we’ll see examples, that code is compiled so it knows, for example, when it does the allocation, it’s going to allocate 16 B. And then it knows at the end that it can deallocate at 16 B. And it actually brings up a good point. There’s sort of an obscure part of the book that goes over this. There’s a few special cases where it can’t know in advance how much space will be allocated when it has to allocate an array or memory buffer of variable size. And then it will actually use the RBP in those cases for exactly that purpose.<br>所以问题是，如果RBP是可选的，那么程序如何知道如何进行解分配？它如何将堆栈重置回正确的位置？答案是，我们将看到示例，该代码已编译，因此它知道，例如，当它进行分配时，它将分配16 B。然后它最后知道它可以在16 B释放。这实际上提出了一个很好的观点。这本书有一个晦涩的部分。有一些特殊情况，当它必须分配可变大小的数组或内存缓冲区时，它无法提前知道将分配多少空间。然后它将在这些情况下实际使用RBP用于该目的。</p><p>发言人   34:39<br>And so in general, what the stack frame will look like in one of these machines will be something like this. That and you’ll see this is the collar, and then this is the stack frame of the function that got called. So working our way back, if we have to pass more than 6 arguments, the caller will actually use its own stack frame to store those arguments so that they’d be available. And we already saw when you do a call. It will push the return address onto the stack. So before a function even starts, all this information would be on the stack.<br>因此，通常情况下，在这些机器中，堆栈框架的外观将是这样的。你会看到这是项圈，然后这是被调用函数的堆栈框架。因此，如果我们必须传递6个以上的参数，调用者实际上将使用自己的堆栈框架来存储这些参数，以便它们可用。我们已经看到你打电话的时候了。它会将返回地址推送到堆栈上。因此，在函数启动之前，所有这些信息都将在堆栈上。</p><p>发言人   35:33<br>Now, if this particular, if we’re making use of a base pointer, then we have to have somewhere to store the old value of the base pointer so that we could fix it back when we return. We won’t show any code doing that here. So this is optional. But in general, if there’s some local state, like some registers that need to be saved, and we’ll see examples of that or an array that needs to be allocated locally that will be stored within the stack frame and there might be some requirement for some extra space in the stack frame for other stuff, in particular, if it’s going to pass more than 7 arguments that need space.<br>现在，如果我们正在使用基本指针，那么我们必须有一个地方来存储基本指针的旧值，以便我们可以在返回时修复它。我们不会在这里展示任何代码这样做。所以这是可选的。但总的来说，如果有一些本地状态，比如一些寄存器需要保存，我们将看到这样的例子，或者需要在本地分配的数组，它们将存储在堆栈框架中，并且可能需要在堆栈框架中为其他内容提供一些额外的空间。特别是，如果它要传递超过7个需要空间的参数。</p><p>发言人   36:23<br>Stack pointer gets decremented soon after the procedure begins, and it gets incremented back just before it returns. That’s how it manages the stack. So let’s do some examples.<br>堆栈指针在过程开始后很快就会减少，并在返回之前增加回来。这就是它管理堆栈的方式。让我们举一些例子。</p><p>发言人   36:47<br>Let’s see, I looked at this before, but this is a function. I think the interesting thing about this function is that it it has a pointer being passed to it. So this function takes an argument. One argument is a pointer and another is an an integer value. What it does is it dereferences that pointer to get a value called x, it computes a value y by summing x and the value passed to it. It stores y back at p, but it returns x, the original value of the pointer, not the updated version of the pointer. And you can see that in the code here. It code’s pretty short.<br>让我们看看，我之前看过这个，但这是一个功能。我认为这个函数有趣的地方在于它有一个指针被传递给它。所以这个函数接受一个参数。一个参数是指针，另一个参数是整数值。它的作用是取消对该指针的引用以获取一个名为x的值，它通过将x和传递给它的值求和来计算值y。它将y存储在p，但它返回x，指针的原始值，而不是指针的更新版本。你可以在这里的代码中看到这一点。它的代码非常短。</p><p>发言人   37:34<br>Remember that in general RDI will hold the first argument. In this case, it’s a pointer. So it’ll do a read from that pointer, and it will put the value in Rax, which is where the return value should be anyhow. And then it will increment RSI, which has a value called value here initially, and now it has the value of x plus val. And then it will store that in the value pointed to by p, and it will do a return. So you see these three instructions do all the different parts of this. And as this shows, in general I’ll show register usage.<br>请记住，通常RDI将持有第一个参数。在这种情况下，它是一个指针。所以它将从该指针读取，并将值放入Rax中，无论如何返回值应该在哪里。然后它将增加RSI，它最初有一个名为value的值，现在它的值为x加val。然后它会将其存储在p指向的值中，并执行return操作。所以你可以看到这三个指令完成了这个过程的所有不同部分。正如这所显示的，一般我会展示注册使用情况。</p><p>发言人   38:20<br>It’s handy, by the way, to document this when you’re looking at code.<br>顺便说一下，当您查看代码时，将其记录下来是很方便的。</p><p>发言人   38:25<br>RDI is the first argument. RSI gets used. Initially it’s Val, but now it will be set to Y during the call. And similarly Rix is initially the value. Well, it’s both what x is here, and it’s used is the return value. So the reason to go through all that is to actually show you examples of calling this and how arguments get passed to the function and how it makes use of the stack frame.<br>RDI是第一个参数。RSI被使用了。最初它是Val，但现在在调用过程中将其设置为Y。同样，Rix最初是值。好的，它既是这里的x，也是返回值。所以，遍历所有这些的原因是为了向您展示调用这个的示例，以及参数如何传递给函数以及它如何利用堆栈框架。</p><p>发言人   39:00<br>So now there’s a function called call in, and it’s going to create a value called v and have to generate a pointer to that. So what that means is V1 can’t just stay in a register because you can’t create an address of a register. It has to be stored in memory somewhere so that you can create a pointer, an address of it. Where does it? Well, it puts it in the stack. So how does it find space on the stack? Well, it allocates it so the function call in then, and we’ll go through all the different parts of it, but you see that this red code here is generated, generates these two instructions, 1 is to allocate 16 B on the stack, and the other is to store 1 5 2 1 3 at offset 8 from the stack pointer. And as we’ll often see, the program often allocates more space on the stack than it really needs to.<br>所以现在有一个名为call的函数，它将创建一个名为v的值，并且必须生成一个指向该值的指针。这意味着V1不能仅仅停留在寄存器中，因为您无法创建寄存器的地址。它必须存储在内存中的某个地方，以便您可以创建指针，地址。它在哪里？嗯，它把它放在堆栈中。那么它是如何在堆栈上找到空间的呢？好的，它分配它，然后函数调用，我们将浏览它的所有不同部分，但是你会看到这里生成了这个红色代码，生成这两条指令，1是在堆栈上分配16 B，另一个是在堆栈指针的偏移量8处存储1 5 2 1 3。并且正如我们经常看到的那样，程序经常在堆栈上分配比实际需要更多的空间。</p><p>发言人   40:05<br>And there’s some conventions about trying to keep.<br>并且有一些关于试图保持的惯例。</p><p>发言人   40:10<br>Addresses aligned in various ways that are sort of obscure. And you should just kind of not worry about the fact there’s unused space and functions. They do it. The reasons for doing it are are. Maybe interesting to some, but not really ones you need to understand at this point. So the point being that the way we got space on the stack was to just add to the stack point in the stack. For. And we can create a pointer to it. And so now to set up this call, we need to create a pointer V1 to V1. And we have to pass the number 3000. So we’ll see that we’ll copy 3000 to register ESI. And let me just double check here.<br>地址以各种方式对齐，有些晦涩。你不应该担心有未使用的空间和功能。他们做到了。这样做的原因是。可能对某些人来说很有趣，但在这一点上你不需要真正理解。因此，重点是我们在堆栈上获得空间的方式只是添加到堆栈中的堆栈点。为了。我们可以创建一个指向它的指针。所以现在要设置这个调用，我们需要创建一个指向V1的指针。我们必须通过数字3000。所以我们会看到我们将复制3000来注册ESI。让我在这里再确认一下。</p><p>发言人   41:27<br>Just looking. So one of the annoying features is you see all the data type here on longs.<br>只是看看。因此，其中一个烦人的功能是您在longs上看到所有数据类型。</p><p>发言人   41:33<br>There’s no ints here, and yet it’s copying 3000 just to register ESI and not RSI. And it’s using a move L and not a move queue. I think we might have covered that last time, but 3000 is a small enough number. It will fit in 32 b. It’s a positive number, so we don’t have to worry about s bits. So the thing can sort of get away with a trick here of using just a move L instruction, because when any instruction has one of the ere’s is its destination, it’ll set the upper 32 b of that register to zeros. So this will have the effect of copying the number 3000 and zeroing out the upper bytes to register RSI. And the reason the compiler likes this is it takes one less byte to encode a move L than it does to encode a move c.<br>这里没有整数，但它复制了3000只是为了注册ESI而不是RSI。它使用的是移动队列而不是移动队列。我想我们上一次可能已经涵盖了，但3000是一个足够小的数字。它将适合32 b。它是一个正数，所以我们不必担心s位。所以这个东西在这里可以用一个技巧逃脱，只使用一个移动指令，因为当任何指令有其中一个是它的目的地时，它会将那个寄存器的上部32 b设置为零。所以这将具有复制数字3000并将高字节清零以注册RSI的效果。编译器喜欢这个的原因是，编码移动L比编码移动c少一个字节。</p><p>发言人   42:33<br>So just you have to get used to these kind of things. So that’s setting up argument, the second argument to the call. But the first argument, it’s using this instruction Lea or Lea Q for what it’s supposed to be used for, which is to create pointers. Remember, we talked about this instruction often getting used just to add two numbers, but it’s actually designed exactly for this purpose that it looks like a memory reference relative to the stack pointer. But instead of now reading from that memory reference, the instruction will just copy the computed address to RDI. And so RDI will now be equal to whatever the stack pointer plus 8 is. So that creates the two arguments that I’m passing to this function.<br>所以你必须习惯这些事情。所以这是设置参数，调用的第二个参数。但是第一个参数，它使用这个指令Lea或Lea Q来表示它应该用于什么，也就是创建指针。记住，我们谈到这个指令经常被用于将两个数字相加，但它实际上是专门为此目的而设计的，它看起来像相对于堆栈指针的内存引用。而不是现在从内存引用中读取，该指令只会将计算的地址复制到RDI中。因此，RDI现在将等于堆栈指针加上8的值。这样就创建了我传递给这个函数的两个参数。</p><p>发言人   43:36<br>And now the call instruction will happen. And you’ll recall that the call instruction adds 3, adds these two numbers, and stores the result back in the pointer. So its effect will be to set.<br>现在呼叫指令将会发生。你会想起调用指令加3，将这两个数字相加，然后将结果存储回指针中。所以它的效果将是设置。</p><p>发言人   43:53<br>This memory location to 18 to 13. You’ll notice the clever trick here. And also return a particular value, which we won’t make use of the return value. No, we do make use of the return value. And now the.<br>这个内存位置在18到13之间。你会注意到这里的巧妙技巧。并且还返回一个特定的值，我们不会利用这个返回值。不，我们确实利用返回值。而现在。</p><p>发言人   44:19<br>Now, when we return back, what we wanted to do is add the value in V1 to the value we just computed. The value we just computed is in V2. And we know that the V1 is designated by this memory location at Rsp plus 8. And so just read from memory and add that to Rax.<br>现在，当我们返回时，我们想做的是将V1中的值添加到我们刚刚计算的值中。我们刚刚计算的值是在v2中。并且我们知道V1是由Rsp加8的这个内存位置指定的。所以只需从内存中读取并将其添加到Rax中。</p><p>发言人   44:47<br>And then the final step is to de-allocate. So you see the map here. And this was to answer the question earlier, how does it know how to restore the stack back to its original place? Well, the compiler built into it figured out how much space it would need for this particular function, and it allocates that when it comes in, and it deallocates it when it goes out.<br>然后最后一步是取消分配。所以你可以看到这里的地图。这是为了回答之前的问题，它如何知道如何将堆栈恢复到原来的位置？嗯，内置的编译器计算出了这个特定函数需要多少空间，当它进入时分配，当它退出时释放。</p><p>发言人   45:12<br>So, and this is a very simple example, but even more elaborate examples still based on the same set of ideas. So that shows you in one, then, the data management, the stack management, the idea of using a stack frame. And now the return. By this point, the only thing that’s left is after I increment the stack pointer, it will be pointing back to this return address. Oops, wrong direction here. So now if I do a, the re instruction will always take whatever is pointed to by the stack pointer and use that as the return address. So it’s very important that Rsp get set back to where it should be before it does a rep.<br>所以，这是一个非常简单的例子，但更复杂的例子仍然基于同一组想法。因此，这向您展示了数据管理、堆栈管理以及使用堆栈帧的想法。现在是回归。此时，唯一剩下的是在我增加堆栈指针之后，它将指向返回地址。哎呀，这里方向错了。现在，如果我执行，re指令将始终获取堆栈指针指向的任何内容，并将其用作返回地址。因此，在rep之前，Rsp必须回到应该回到的位置，这非常重要。</p><p>发言人   46:08<br>Okay, so that’s sort of the basic principles now. Now let’s get a little bit more refined. An important idea is, well, what about these registers? What can be assumed about particular registers and how they get changed, so forth? And so again, it’s built into this idea of an ABI is a set of conventions about the register. Obviously Rsp is a very important register. And you don’t want programs just to randomly change its value without them knowing what to do. But it turns out we’ll also be careful with some of the other registers, too.<br>好的，这就是现在的基本原则。现在让我们再精炼一点。一个重要的想法是，这些寄存器怎么样？关于特定的寄存器可以假设什么以及它们如何更改等等？所以，再次强调，ABI是一组关于寄存器的约定，它内置于这个概念中。显然，Rsp是一个非常重要的寄存器。你不希望程序只是随意改变它的值而不知道该做什么。但事实证明，我们对其他一些寄存器也要小心。</p><p>发言人   46:47<br>And so here’s sort of a thought experiment. Imagine we had a function called you that’s going to call who, and it has some data that it wants to. Put somewhere. And then who’s going to get called? And then the question is, can I rely on the fact that register RDX will still hold the number 15 to 13? And the answer is not in general, because who might have overwritten RDX and put something else there? So in particular, of who did some operation involving Register RDX, it could have messed up the value that was there before. So the obvious answer is, well, you should not have used RDX for that purpose, right? And that’s why we’ll come up with a set of conventions.<br>所以这里有点像一个思想实验。想象一下，我们有一个名为 “你” 的函数，它将调用 “谁”，并且它有一些想要的数据。放在某个地方。然后谁会被召唤？然后问题是，我可以依赖于寄存器RDX仍将持有数字15到13的事实吗？答案不是一般的，因为谁可能会覆盖RDX并在那里放其他东西？因此，特别是谁做了一些涉及寄存器RDX的操作，它可能会搞乱之前的值。所以显而易见的答案是，你不应该为此目的使用RDX，对吧？这就是为什么我们要制定一套公约的原因。</p><p>发言人   47:52<br>So just some terminology when we’re talking about one function calling another, it’s useful to have use the following words. So we’ll call the calling function the caller, and the function that gets called the call e.<br>因此，当我们谈论一个函数调用另一个函数时，使用以下词语是有用的。因此，我们将调用调用函数作为调用者，而被调用的函数则称为调用e。</p><p>发言人   48:09<br>And now there’s basically two ways we can manage. A register can be what’s called caller saved, which means if the caller really cares, if you really wants a value that will be there when it returns, when control returns back to it, then it should store it away first.<br>现在我们基本上有两种方法可以管理。一个寄存器可以被称为调用者保存，这意味着如果调用者真的关心，如果你真的想要一个值，当它返回时，当控制返回到它时，它应该先把它存储起来。</p><p>发言人   48:32<br>It shouldn’t assume that the register will be. It should assume that the register might get altered by it. But there’s another class we can define it called call esafe, which is sort of a contract between all the functions. And it’s built into the ABI that says if a particular function wants to alter this register, what it needs to do is first store it away. And it will do it by putting the value in the stack. And then before we return from that procedure, we should restore it back to whatever it was before. So that’s a convention called Call Me Save, and it’s a little less intuitive, and it takes a while to get the hang of this, but you’ll begin to see its value.<br>它不应该假设登记册会这样。它应该假设寄存器可能会被它更改。但是我们可以定义另一个类，称为call esafe，它是所有函数之间的一种契约。并且它内置于ABI中，表示如果特定函数想要更改此寄存器，它需要做的是首先将其存储起来。它将通过将值放入堆栈来完成。然后在我们从该过程返回之前，我们应该将其恢复到之前的任何状态。所以这是一个叫做 “叫我保存” 的约定，它有点不那么直观，需要一段时间才能掌握它的窍门，但你会开始看到它的价值。</p><p>发言人   49:24<br>So in particular, with this ABI, we’ve already seen Rax gets used for the return value. And we’ve seen these six registers that get used for passing arguments. And we’ll also designate registers R 1 and R 11 to be just temporary values that can be altered by any function. That’s a meaning of color save.<br>因此，特别是有了这个ABI，我们已经看到Rax被用于返回值。我们已经看到了这六个用于传递参数的寄存器。并且我们还将指定寄存器R 1和R 11只是临时值，可以通过任何函数进行更改。这就是颜色保存的意义。</p><p>发言人   49:54<br>We’ve already seen actually within code, often them overriding these registers, because whatever gets passed to a function, the function can do whatever it wants to that data, as long as it’s not somehow corrupting other data. So those often get used as temporary storage as well. And Rx gets often overwritten multiple times before it gets set to a final return value. But we’re going to say that these four registers, and most commonly rbx, are what are called calyce registers, meaning they’ll only get used in this special way that if a function wants to alter it one of these registers, it has to, it will push the value on the stack. And then just before returning, it will pop that value back off the stack.<br>我们已经在代码中看到过，通常它们会覆盖这些寄存器，因为无论传递给函数什么，该函数都可以对该数据做任何它想做的事情，只要它不会以某种方式破坏其他数据。所以这些也经常被用作临时存储。并且Rx在被设置为最终返回值之前通常会被多次覆盖。但我们要说这四个寄存器，最常见的是rbx，它们被称为calyce寄存器，这意味着它们只会以一种特殊的方式使用，如果一个函数想要更改其中一个寄存器，它必须这样做，它会将值推送到堆栈上。然后在返回之前，它会将该值弹出堆栈。</p><p>发言人   50:47<br>So register RBP, as I told you about, is special if you’re using frame pointers. If you’re not using frame pointers, then it can be treated as a Collie save register. So I’ll get back to that in a minute. The fact can combine those two and it works fine.<br>所以，正如我告诉你的，如果你使用帧指针，注册RBP是很特别的。如果你没有使用帧指针，那么它可以被视为牧羊犬保存寄存器。所以我马上就回来讨论这个问题。事实可以将这两者结合起来，并且效果很好。</p><p>发言人   51:07<br>It’s actually a little bit subtle. And then as I mentioned, rsp is special. I’ll mess with that unless you know what you’re doing.<br>这实际上有点微妙。然后就像我提到的，rsp很特别。除非你知道自己在做什么，否则我会搞砸的。</p><p>发言人   51:15<br>So let’s look at an example of this use of call. You save registers, why, how it works, and I’ll do it by a version of of this similar function to what we did before. But now what I’m going to. Do is my return value is to add x, which is an argument being passed to this function? There were no arguments in the earlier version, so somehow I have to have x it gets passed originally and register RDI as you know, but RDI might well I’m going to have to reuse register RDI to pass a value to incur. So somehow I have to do something with X because I’m going to need x when I return back to here after the call.<br>那么让我们来看一个使用call的例子。你保存寄存器，为什么保存，它是如何工作的，我会用一个和我们之前类似的函数版本来保存。但现在我要做的是什么。我的返回值是添加x，这是传递给此函数的参数吗？早期版本中没有参数，所以不知何故，我必须让x最初传递并注册RDI，如你所知，但是RDI很可能我将不得不重复使用寄存器RDI来传递一个值。所以不知何故我必须对X做点什么，因为当我在通话后返回这里时，我将需要x。</p><p>发言人   52:14<br>So where am I going to put it? Well, that’s why I have call ESA registers, and so you see the code here at the outset of this function, then it will store away whatever is in rbx currently. It will put it on the stack. And so now the stack frame for this function looks like ISS, the return address from before, but I’m going to save the value of rbx, and then I’m going to decrement the stack pointer by 16 as I did before, but that will be on top of the 8 B I’ve already allocated to store rbx. And then you’ll see within the code, for example, when it wants to compute this return value, it can assume that rbx is whatever this call does.<br>那么我要把它放在哪里？这就是为什么我要调用ESA寄存器，所以你可以在这个函数的开头看到这里的代码，然后它会存储当前在rbx中的任何内容。它会放在堆栈上。所以现在这个函数的堆栈帧看起来像ISS，是之前的返回地址，但是我要保存rbx的值，然后像之前一样将堆栈指针减少16，但这将是在我已经分配给存储rbx的8 B之上。然后你会在代码中看到，例如，当它想要计算这个返回值时，它可以假设rbx是这个调用所做的任何事情。</p><p>发言人   53:09<br>Inker. We assume inker is well behaved, that if it makes use of register rbx, it will fix it up before it returns. And then this function, well in its exit code, will not only increment the stack pointer, but it will then pop the value of rbx back. And again, you see this of bracketing, push, subtract, add. And you’ll notice that things on the cleanup part of it, the end, you sort of do things in the reverse order that they were done coming in again because of this stack discipline.<br>这是一种补液。我们假设inker表现良好，如果它使用寄存器rbx，它会在返回之前修复它。然后这个函数，在它的退出代码中，不仅会增加堆栈指针，还会弹出rbx的值。再一次，你可以看到这个包围，推，减，加。你会注意到清理部分的事情，最后，你以相反的顺序做事情，因为这个堆栈纪律。</p><p>发言人   53:49<br>Demon? Everyone will treat rbx this way, it will save it on the stack if it’s going to alter it. If it’s not going to alter it, it doesn’t have to save. Anything is question I saw. So we haven’t seen that in other code because we didn’t typically need it. And that’s, again, an example. In this particular machine code, we only do what we have to do.<br>恶魔？每个人都会这样对待rbx，如果它要更改它，它会将其保存在堆栈上。如果它不打算改变它，它就不必保存。我看到的任何事情都是问题。所以我们在其他代码中没有看到这一点，因为我们通常不需要它。这又是一个例子。在这个特定的机器码中，我们只做我们必须做的事情。</p><p>发言人   54:20<br>Okay? Okay, so now we can kind of put this all together and look at some examples of recursion. And the important thing to keep in mind is recursion is one of those sort of magical parts of computer science that seems like some black art that it actually works. But when you look at these goal levels mechanisms, it all works out.<br>好吗？好的，现在我们可以把这些放在一起，看看一些递归的例子。需要记住的重要一点是，递归是计算机科学中一种神奇的部分，看起来像是某种黑色艺术，实际上它确实有效。但是当你观察这些目标水平机制时，一切都会奏效。</p><p>发言人   54:49<br>The C compiler doesn’t have to make any special consideration for a recursive function versus a normal function, because this whole stack discipline makes it work.<br>C编译器不必对递归函数与普通函数进行任何特殊考虑，因为这整个堆栈规程使其工作。</p><p>发言人   55:03<br>So I’m going to illustrate that then with a version of this function I call p count. I had various instances of it where you remember the role of this is to count the number of ones in an initial word. So the recursive version of this says if the argument is 0, then it has no ones in it. Otherwise, take the leading bit, the least significant bit, which is either going to be a one or a zero, of course, and add that to what you’d get by shifting x right by one position and recursively counting the number of 1 b in that. So pretty natural kind of recursion. And keep in mind, these are all unsigned numbers. The argument is, so the right shifts are logical. This would really be a bad idea with arithmetic right shifts.<br>所以我将使用这个函数的一个版本来说明这一点，我调用p计数。我有各种各样的例子，你记得这的作用是计算初始单词中1的数量。所以这个递归版本说，如果参数是0，那么它里面就没有。否则，取前导位，即最低有效位，当然，它要么是一，要么是零，然后将其添加到通过将x右移一个位置并递归计数其中的1 b的数量所得到的值上。这是一种非常自然的递归。请记住，这些都是无符号数字。论点是，因此正确的转变是合乎逻辑的。这对于算术右移位来说真的是个坏主意。</p><p>发言人   56:06<br>And this is a code generated Re. A bigger blob of code than the iterative version, because it has to do all this stack stuff. So this is about as simple as it gets in recursive calls. It apart.<br>这是生成的代码。比迭代版本更大的代码块，因为它必须做所有这些堆栈的事情。所以这就像递归调用一样简单。它分开了。</p><p>发言人   56:35<br>It first of all assumes x is going to be 0, in fact, and sets up the return value of 0 to the register. You remember the test instruction has two operands that get, and so they’re the same, just testing the value of x here. And if that Je means jump equal to 0 in this case, or it might say JZ is the. Same instruction. So if the value equals 0, it will jump to the end of the function and hit the return instruction. Like I said before, the RP semicolon, you can ignore that. So that handle set one and now the rest of the code is to handle this lower part where I have to set up the arguments to recursive call.<br>它首先假设x实际上将为0，并设置返回值0到寄存器。你记得测试指令有两个操作数，它们是相同的，只是在这里测试x的值。如果Je在这种情况下意味着跳跃等于0，或者它可能会说JZ是。同样的指示。因此，如果值为0，它将跳到函数的末尾并命中返回指令。就像我之前说的，RP分号，你可以忽略它。这样句柄就设置了一个，现在其余的代码将处理这个较低的部分，在那里我必须设置递归调用的参数。</p><p>发言人   57:30<br>I have to keep track of what at least the least significant bit of x is and handle all that stuff. So here’s the code, and it’s need the tech. Space to store rbx, which is, again, whatever it was in rbx when you enter. I’m just going to put it on the stack. I won’t look at it, I won’t make use of it, but I’ll have it there so I can restore the register when I return. So it will push the value onto the stack. And now the real meat of the body of it is it will.<br>我必须跟踪x中至少最不重要的部分是什么，并处理所有这些东西。这是代码，它需要技术。空间来存储rbx，也就是您输入时rbx中的任何内容。我只是要把它放在堆栈上。我不会看它，也不会使用它，但我会把它在那里，这样我回来时就可以恢复寄存器。所以它会将值推送到堆栈上。现在它身体的真正肉是它愿意。</p><p>发言人   58:16<br>Copy x into rbx, which we’ve just put on the stack so we can safely do it. And we just, we’ll clear out all but the least significant bit of that particular register. And again, this is one of these weird ones where I can use ebx is a destination knowing that all zero, all the high order bits. And then I’m going to take x, and I’m just going to shift it right by one position, which sets me up for this recursive call. So this red code does both of these parts of it here.<br>将x复制到rbx中，我们刚刚将其放在堆栈上，这样我们就可以安全地执行此操作。我们只需要清除该特定寄存器中除了最不重要的部分之外的所有内容。再说一遍，这是其中一个奇怪的例子，我可以使用ebx作为一个目的地，知道所有的零位，所有的高阶位。然后我将取x，并将其向右移动一个位置，这为这个递归调用设置了基础。所以这个红色代码在这里完成了它的这两个部分。</p><p>发言人   58:56<br>And now I’m ready to call p count recursive weight, because I have the shifted value in RDI. And I know because this is a well-behaved, that when p count returns, it can assume that Rax holds the recursive result. And I also know even though p count actually does modify rbx, but I know because I, the code is well behaved, the rbx will get restored to whatever was there before. And rbx in this case, just before making the call, I set it to the value of the least significant bit. So when I return back, I can assume that rbx holds the least significant bit of x, my original argument, and rax holds recursive result. So I can just add those two numbers together, call that the return value, and I’ve correctly computed the result. And then the final queen up is to pop rbx to restore whatever was in there, and then to do the return.<br>现在我准备调用p计数递归权重，因为我在RDI中有移位的值。我知道，因为这是一个很好的表现，当p计数返回时，它可以假设Rax持有递归结果。我也知道，即使p计数实际上会修改rbx，但我知道，因为代码表现良好，rbx将恢复到之前的状态。在这种情况下，和rbx，就在进行调用之前，我将其设置为最低有效位的值。所以当我返回时，我可以假设rbx保存了x的最不重要的部分，即我的原始参数，而rax保存了递归结果。所以我可以将这两个数字相加，称之为返回值，我就正确地计算了结果。然后最后的女王是弹出rbx以恢复其中的任何内容，然后执行返回。</p><p>发言人   01:00:12<br>So again, the pieces all kind of, it’s a puzzle that all fits together because all these functions are using this common set of conventions where arguments get passed, what registers can be used, hows, if some registers have to be restored back, if they get used, and all that stuff works together.<br>所以，所有的部分，都是一个拼图，因为所有这些函数都在使用一套通用的约定，在这些约定中，参数被传递，可以使用哪些寄存器，如何，如果某些寄存器必须被恢复，如果它们被使用，所有这些东西一起工作。</p><p>发言人   01:00:39<br>Which gets me back to just the point I was making before, if you’re using register RBP. For a frame pointer. So it typically point to the beginning of a frame like that. So imagine you have a function that needs a base pointer, because as I mentioned, the case is there if it has to within, that function allocates some amount of space that’s unknown at compile time. Well, imagine now that some other code gets called deep recursive calls or whatever that. Might do other things? Well, if you treat RBP as a call save register, then when these other functions return, they altered if they’ve made use of RBP for one reason or another, it’s guaranteed that they will restore it back to whatever condition it was in originally before. So now this function will have a reliable value of RBP.<br>这让我回到了我之前说过的观点，如果你使用的是注册RBP。对于帧指针。因此，它通常指向一帧的开头。所以想象一下，你有一个需要一个基指针的函数，因为正如我所提到的，如果它必须在内部，那么这个函数会在编译时分配一些未知的空间。好的，现在想象一下其他一些代码被称为深度递归调用或其他什么。可以做其他事情吗？好的，如果你将RBP视为调用保存寄存器，那么当这些其他函数返回时，如果他们出于某种原因使用了RBP，它们会发生改变，保证它们会将其恢复到原来的状态。所以现在这个函数将有一个可靠的RBP值。</p><p>发言人   01:01:57<br>So again, it shows as long as all the code obeys these conventions on how they use registers, then sort of life is good. You can make use of these. So to have a trust that things will be the way they are. And so again, that’s why there’s this sort of very careful process for creating an ABI early on in the lifetime of a new processor, so that all the compiler writers, operating systems people, and the ones who implement tools like Gdb, debugging tools, kind of all have the right set of standards by which they can work from. Okay, so just to sort of wrap things up.<br>因此，它再次表明，只要所有代码都遵守这些关于如何使用寄存器的约定，那么生活就很好。你可以利用这些。所以要相信事情会变成现在的样子。再次强调，这就是为什么在新处理器的生命周期早期创建一个ABI需要非常仔细的过程，以便所有的编译器编写者、操作系统人员以及实现像Gdb这样的工具的人，调试工具，几乎所有人都有一套正确的标准，可以据此开展工作。好的，那么就把事情总结一下。</p><p>发言人   01:02:53<br>I would say, by the way, this is the kind of thing you can. I could lecture to you for weeks, but to really get it in your mind, the best way is to almost to hand execute some very simple examples or use a debugging tool and run through them yourself just to make sure you really are convinced that this is all going to work because all these pieces just fit together. And the way they fit together is what makes it work.<br>顺便说一下，这是你可以做的事情。我可以给你讲几个星期，但要真正记住它，最好的方法是几乎手动执行一些非常简单的示例或使用调试工具并自己运行，以确保您真正确信这一切都会成功，因为所有这些部分都可以组合在一起。它们结合在一起的方式是它运作的原因。</p><p>发言人   01:03:24<br>So as I mentioned before, and I’ll say it again, that this discipline is what makes recursion work. So the idea of having a stack frame for every call to a function means that I can call a function call a function call a function call a function when I’m deep in that recursion, I still have data associated with the other outstanding calls to that function, but each of them will have their own stack frames. And so it has a place to store that sort of information that’s associated with one particular instantiation of a function. The register saving conventions, we saw a way that functions avoid sort of trashing each other’s data. If I’m using a call you save register, it’s my obligation to save it and restore it properly. It’s the obligation of any function that gets called further down to also do that, save and restore, and then the sort of.<br>所以正如我之前提到的，我会再说一遍，这个学科是使递归工作的原因。因此，为每个函数调用都有一个堆栈框架的想法意味着我可以调用函数，当我深入该递归时，函数调用函数，我仍然有与该函数的其他未完成调用相关联的数据。但它们每个人都有自己的堆栈帧。因此，它有一个位置来存储与函数的特定实例化相关联的那种信息。在寄存器保存约定中，我们看到了一种函数避免互相破坏数据的方式。如果我正在使用您保存注册的电话，我有责任保存并正确恢复它。这是任何被进一步调用的函数的义务，也要做到这一点，保存和恢复，然后是那种。</p><p>发言人   01:04:36<br>Notion of a stack being the right match of how procedure call and return works. If P calls q, then before I go back to PQ will have returned. And so I won’t need that storage for Q anymore.<br>堆栈的概念是过程调用和返回工作方式的正确匹配。如果P调用q，那么在我回到PQ之前，它将已经返回。因此，我不再需要Q的存储空间了。</p><p>发言人   01:04:52<br>Those of you who have taken 150 or other places where you look at fancier languages don’t have, can’t trust that stack discipline, and they have to use some other mechanism, though actually, if required, use heap allocation of the frames. They no longer stack frames to keep data around after function returns, but for C and sort of all the standard commonplace languages, the stack discipline is exactly what’s needed. And that’s not an accident. The designers of C knew this well. This matching of a stack to their language.<br>那些已经学习了150种或其他地方的人，如果你看到更华丽的语言，就不能相信堆栈纪律，他们必须使用一些其他机制，尽管实际上，如果需要的话，使用框架的堆分配。它们不再堆叠帧来在函数返回后保留数据，但对于C和所有标准通用语言来说，堆栈纪律正是所需要的。这不是意外。C的设计师很清楚这一点。堆栈与他们的语言的匹配。</p><p>发言人   01:05:33<br>And I’ll mention also this, I was talking about simple recursion before. There’s also mutual recursion, where a function, say, p calls q, and then Q might call p, and it looks very exotic, quite clever. But again, how it’s implemented is exactly what we’ve seen here, doesn’t take any special kind of code. So? Then to finish up, this is sort of what you need to remember about.<br>我还要提到这一点，我之前谈论过简单递归。还有相互递归，其中一个函数，比如说，p调用q，然后Q可能调用p，它看起来非常奇特，非常聪明。但是，它的实现方式正是我们在这里看到的，不需要任何特殊类型的代码。所以呢？然后结束，这就是你需要记住的事情。</p><p>发言人   01:06:11<br>Procedure calls that it’s all about the stack discipline get as you’re working through your lab, you’ll just get much more ingrained to this idea of the stack and what’s on there and being able to examine it. Okay, so that’s all I’ve got for today. So I’ll give you a little extra time in your calendar.<br>过程调用，这一切都与堆栈纪律有关，当你在实验室中工作时，你将会更加深入地了解堆栈的概念及其内容，并能够对其进行检查。好的，这就是我今天的全部内容。所以我会在你的日历上给你一点额外的时间。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深入理解计算机系统 006-Machine-Level Programming II, Control</title>
    <link href="/2025/10/12/15213-006/"/>
    <url>/2025/10/12/15213-006/</url>
    
    <content type="html"><![CDATA[<p>发言人   00:01<br>Okay, let’s continue on. In our coverage of machine level programming. The second in, I think a six part series.<br>好的，我们继续。在我们的机器级别编程的覆盖范围内。第二部分，我认为是一个六部分系列。</p><p>发言人   00:12<br>As I mentioned yesterday, machine level programming is sort of the core of this course, that it gives you a set of tools and understanding that take you well beyond what your sort of average run of the mill, a programmer, software developer would know about. And it’s very powerful in terms of your better understanding of the system, what goes wrong, why programs crash, what the meaning of those are. And so it’s a fairly core part of the material as, you know, the data lab is due tonight and the next lab out is called the Bam lab, And I believe that’s coming out tonight as well. So the Bam lab will rely on your ability to understand machine level code. So these two lectures will actually be enough to get you started on some of the earlier parts of that lab.<br>正如我昨天提到的，机器编程是本课程的核心内容，它为您提供了一套工具和理解，使您远远超出了程序员和软件开发人员所知道的一般情况。而且它非常强大，可以帮助你更好地理解系统，什么出了问题，为什么程序崩溃，这些是什么意思。因此，这是材料的一个相当核心的部分，因为你知道，数据实验室今晚要进行，下一个实验室叫做Bam实验室，我相信今晚也会出现。所以Bam实验室将依赖于你理解机器级别代码的能力。所以这两次讲座实际上足以让你开始那个实验室的一些早期部分。</p><p>发言人   01:07<br>You’ll learn a lot more at recitation on Monday, either in person or if you’re viewing the recorded version of that, that will help you move along on bawab, like all the labs in this course, at least the first two, we give you a fair amount of time for them. But don’t be fooled into thinking that means you can just slack off or work on other courses and then in the last few moments, jump in and finish this lab, the bomb lab. Once you get the hang of what you’re doing, it’s pretty, you can just kind of crank along. But there’s a certain learning curve that we’ll take you to even get started on it effectively. So don’t put it off.<br>在周一的朗诵课上，你会学到更多东西，无论是面对面学习还是观看录制的版本，这将帮助你在bawab上继续前进，就像本课程中的所有实验一样，至少前两个，我们会给你相当多的时间。但是不要被愚弄，认为这意味着你可以松懈或学习其他课程，然后在最后几分钟，跳进并完成这个实验室，这个炸弹实验室。一旦你掌握了你正在做的事情的窍门，它就很漂亮了，你可以继续前进。但是有一定的学习曲线，我们甚至会带你有效地开始学习。所以不要把它推迟。</p><p>发言人   01:59<br>What is this?<br>这是什么？</p><p>发言人   02:12<br>So last time we introduced the very basic principles of machine level programming, the idea of there being special state, that you have access to the registers, which people came out class nest or register as part of memory know, are they part of the cache? Know they’re special, they’re different, they don’t exist to AC level program. When you’re programming in C, you don’t have any visibility into them. And in general today, what we’re going to do then is go beyond the sort of very basics and start talking about the control, how you control the flow of execution of instructions at the machine level, and how you use those techniques to implement basic constructs, conditional statements, loops, and switch statements. And then next time, we’ll talk about procedures, which warrants a whole lecture of its own.<br>所以上次我们介绍了机器编程的基本原理，即存在特殊状态的想法，您可以访问寄存器，人们从类嵌套或寄存器作为内存的一部分知道，它们是缓存的一部分吗？知道它们是特别的，它们是不同的，它们不存在于交流级别的程序。当你用C编程时，你对它们没有任何可见性。总的来说，今天我们要做的是超越基础知识，开始讨论控制，如何在机器层面上控制指令的执行流程，以及如何使用这些技术实现基本结构、条件语句、循环，和切换语句。然后下一次，我们将谈论流程，这值得一整个讲座。</p><p>发言人   03:05<br>So the X 86 and several machines of its generation have these curious good old 1 b flags that are called condition codes. And they’re the basis of how conditional operations work. To a machine level programmer, then we talked last time that you have visibility of the set of registers and. The memory. But you also have more things.<br>因此，x86和它这一代的几台机器都有这些奇怪的老式的1 b标志，称为条件代码。它们是条件运算工作的基础。对于一个机器级程序员来说，我们上次讨论过您可以查看一组寄存器和。记忆。但你也有更多的东西。</p><p>发言人   03:36<br>And this is only a partial list. Actually, there’s more and more stuff that you can add to this picture. But we talked about in the 64 b x 8664, there’s now 16 registers, 8 of which have names that are historic based on old x 86 stuff, and eight of which were introduced. And so they simply named those R 8 through R 15. And of these registers, for the most part, the only one that’s really special is Rsp, it cystica pointer, it tells you where, and we’ll learn a lot more about stacks starting next time, but it’s sort of where the state is that manages the execution of procedures. And so you can’t just use it or sell it in arbitrary ways. But the other ones, you more or less can with qualifications to that statement.<br>这只是部分清单。实际上，有越来越多的东西可以添加到这张图片中。但是我们在64 b x 8664中讨论过，现在有16个寄存器，其中8个寄存器的名称是基于旧的x86名称，其中8个是引入的。因此，他们简单地将这些命名为R 8到R 15。在这些寄存器中，大多数情况下，唯一真正特别的是Rsp，它cystica指针，它告诉您在哪里，我们将在下次开始学习更多关于堆栈的知识，但它是管理过程执行的状态所在的地方。所以你不能以任意的方式使用或出售它。但其他人，你或多或少可以附带那个陈述的条件。</p><p>发言人   04:33<br>There’s another register that they call the RP, which has nothing to do with death. It means the IP means instruction pointer in IA 32, it was called EIP and now it’s called RI just like the registry used to be EA and now it’s Rix. So all it contains is the address of the currently executing instruction.<br>还有另一个他们称之为RP的寄存器，与死亡无关。这意味着IP意味着在IA 32中的指令指针，它被称为EIP，现在它被称为RI，就像注册表曾经是EA，现在是Rix一样。所以它所包含的只是当前执行指令的地址。</p><p>发言人   04:59<br>It’s not a register that you access in a normal way, but you actually, there are tricks that you can find out what the value of that is. So that just tells you where in the program, what part of the program is currently being executed.<br>它不是您以正常方式访问的注册表，但实际上，有一些技巧可以帮助您了解它的价值。这样就可以告诉你程序的哪个部分当前正在执行。</p><p>发言人   05:14<br>And then there’s these things that are called condition codes, And we’re only showing four. There’s actually more like 8 of them, but not relevant to our general discussion that are all 1 b flags. And they get set not directly, but as a side effect of other operations that take place. And they’re the basis for which conditional operation gets decided.<br>然后还有这些被称为条件代码的东西，我们只展示四个。实际上有更多类似8个，但与我们的一般讨论无关，都是1 b标志。它们不是直接设置的，而是作为发生的其他操作的副作用设置的。它们是决定条件运算的基础。</p><p>发言人   05:38<br>Let’s go through what those mean, and they’re given names, but these names are actually useful to memorize what they mean. So Cf means that carry flag and that if you think of adding two numbers, think of them as two unsigned numbers, and you do the binary arithmetic, and sometimes an extra one pops out of the left hand, that’s the carry bit. The numbers you added sort of were too big to be contained in the 32 or 64 b or even 16 or 8 b result. And so an extra bit was generated. That’s called the carry bit.<br>让我们来看看它们的意思，它们被命名，但这些名字实际上有助于记住它们的意思。所以Cf意味着进位标志，如果你想把两个数相加，把它们看作两个无符号的数，然后你进行二进制算术，有时左手会多弹出一个进位，那就是进位。您添加的数字太大，无法包含在32或64 b甚至16或8 b结果中。因此产生了一个额外的位。这就是所谓的进位位。</p><p>发言人   06:18<br>The zero flag is what it sounds like if the value you just computed is 0. These are set typically by arithmetic instructions by the way the S flag is set if the value is computed as a one.<br>如果您刚刚计算的值为0，则零标志是听起来的样子。这些通常由算术指令设置，如果值被计算为1，则通过设置S标志的方式进行设置。</p><p>发言人   06:33<br>And the most significant bit, meaning it’s a negative value, and the flag overflow flag is a tooth complement version of overflow. So in particular, if you remember from Data Lab, how do you know if if addition of two values is overflowed? Is that if signs of the operands are the same, but the sign of the result is different than that? So either you added two positive numbers and got a negative result that was a positive overflow, or you added two negative numbers and got a negative result that’s negative overflow. You can’t overflow if the two arguments are of opposite signs, right?<br>和最高有效位，表示它是一个负值，标志溢出标志是溢出的补牙版本。所以特别是，如果你从数据实验室记得，你如何知道两个值的加法是否溢出？如果操作数的符号相同，但结果的符号不同？所以要么你添加了两个正数并得到了一个负结果，即正溢出，要么你添加了两个负数并得到了一个负结果，即负溢出。如果两个参数符号相反，你就不能溢出，对吗？</p><p>发言人   07:15<br>Those four flags get set as sort of normal activity by many of the instructions, not by our friend. The Lea instruction, which I mentioned is kind of a quirky instruction that GCC really likes a lot. And you’ll see it in a lot of places. But in general, and most of the time, those flags get completely ignored because who cares? But they do show up at various points when you’re doing conditional operations.<br>这四个标志被许多指令设置为某种正常活动，而不是我们的朋友。我提到的Lea指令是一种古怪的指令，GCC非常喜欢。你会在很多地方看到它。但总的来说，大多数时候，这些旗帜被完全忽略了，因为谁在乎呢？但当你进行条件操作时，它们确实会在不同的时间点出现。</p><p>发言人   07:48<br>So there’s some special instructions whose only effect is to set condition codes. And the one that you’ll see is especially is called Compare CMP. And by the way, the cue at the end of these is all just a reflection of they’re operating on 64 b words, quad word, as I said. So the comparison is sort of like a subtraction instruction, except that you don’t, you don’t do anything with the result. A normal subtraction instructions is like x minus equals y, read 2 numbers, but then it will store the result wherever x is stored. But compare just takes these two values, does the subtraction, and doesn’t do anything with the result, but it will set these four conditioned flags And just a few things to keep in mind that are often what will be sources of confusion is remember that the arguments in the way we write them in machine code is the opposite of what you’d expect.<br>因此，有一些特殊的指令，其唯一作用是设置条件代码。你会看到的那个特别被称为比较CMP。顺便说一句，这些结尾的提示只是它们操作在64 b单词上的反映，就像我说的那样，是四字。所以比较有点像减法指令，除了你不这样做，你不需要对结果做任何事情。一个普通的减法指令就像x减法等于y一样，读取2个数字，但它会将结果存储在x存储的任何地方。但是比较只取这两个值，进行减法，对结果不做任何处理，但是它将设置这四个条件标志，并且要记住的一些事情通常会成为混淆的来源，那就是记住，我们在机器代码中编写的参数与您所期望的相反。</p><p>发言人   08:55<br>By the way, somebody asked me last time there is sort of two dialects of assembly code used on x 86 machines. There’s the one that’s used by Intel and Microsoft, and we don’t use it. And then there’s the one that’s sort of used by Linux systems, and that’s the one we use, and they’re different. And one of the quirks of them is they write their arguments in different order. So it will drive you crazy trying to read if you’re familiar with one, it’s like if you’ve ever tried to drive a car on the wrong side of the road, you often will crash or do bad things.<br>顺便说一下，上次有人问我，x86机器上使用的汇编代码有两种方言。有一个是由英特尔和微软使用的，但我们不使用它。然后是Linux系统使用的那个，那就是我们使用的那个，它们是不同的。其中一个怪癖是他们以不同的顺序编写论点。所以如果你熟悉一个东西，尝试阅读会让你发疯，就像如果你曾经试图在路的错误一侧驾驶一辆车，你经常会发生车祸或做坏事。</p><p>发言人   09:35<br>So that’s just an aside that what I find, by the way, when I’m looking at code and I see a compare instruction, I actually write as a comment, compare the two. But I flipped the order so that I’m sure that I sort of keep in my mind what the comparison was of. And so these flags get set according to the rules of subtraction. And so it turns out that the carry flag and the overflow flag, you have to sort of flip your sense of what happened because it’s a subtraction rather than an addition. But it’s the same general idea. So that sort of shows you one particular one and another instruction that you’ll see whose only purpose in the world is to set condition flags, condition codes is the test instruction.<br>所以这只是一个旁白，顺便说一下，当我查看代码时，我看到一条比较指令，我实际上是作为注释编写的，比较这两者。但我颠倒了顺序，这样我就能确定我记得比较的是什么。因此，这些标志根据减法规则进行设置。所以事实证明，进位标志和溢出标志，你必须翻转你所发生的事情的感知，因为它是减法而不是加法。但这是相同的一般想法。这样就可以向您展示一个特定的指令和另一个指令，您将看到它们的唯一目的是设置条件标志，条件代码是测试指令。</p><p>发言人   10:29<br>And this is typically used to compare as you think. It’s when you have two values and you want to compare them to each other. And the test is, if you really just have one value and you want to see what it’s like, is it 0? Is it negative? Those are the main things you care about. In fact, that’s the only thing you can determine. But just because I guess they had, they had sort of a possibility of having two arguments to this, so they decided, well, let’s go ahead and do it.<br>这通常用于进行你想象中的比较。这是当你有两个值，并且想要将它们相互比较时。测试是，如果你真的只有一个值，你想看看它是什么样子，它是0吗？是负面的吗？这些是你关心的主要事情。事实上，这是你唯一能确定的事情。但只是因为我猜他们有可能有两个论点，所以他们决定，好吧，让我们继续做下去。</p><p>发言人   10:57<br>How do you have two arguments to attest instruction, what and the two results, and then test that value? So what you’ll typically see is a test where both arguments are the same. So test q percent rix, comma percent Rix, where so that you’re just any register to itself and one property of the and operation is it’s what they call item potent, adding ending two things, the same things together gives you that same thing. So we can see these. And now, so I told you that’s how the condition codes get set.<br>你如何有两个参数来证明教学，什么和两个结果，然后测试这个值？所以你通常会看到两个参数相同的测试。所以测试q百分比里克斯，逗号百分比里克斯，这样你就只是任何对自身的寄存器，and操作的一个属性就是他们所说的项目有效，将两个相同的东西相加，同样的东西一起给你同样的东西。所以我们可以看到这些。现在，我告诉你这就是条件代码的设置方式。</p><p>发言人   11:39<br>Now, how do you actually read them? How do you make use of them? Well, there two, in principle, you can actually extract and get the condition code values directly out of this special status register, but that’s very unusual to do that. What’s more common is you either try to read it and set a 1 b flag based on the result in some other register, or you try and do a conditional branch.<br>现在，你实际上是如何阅读它们的？你如何利用它们？原则上，您可以直接从这个特殊的状态寄存器中提取并获取条件代码值，但这样做非常不寻常。更常见的是，您要么尝试读取它并根据其他寄存器中的结果设置一个1 b标志，要么尝试进行条件分支。</p><p>发言人   12:07<br>So the first example where you try to read it in a way that you can make use of it is done with the set instruction, and you’ll see there’s a whole range of instructions, but the only difference is really just what the condition they’re setting based on.<br>因此，第一个例子中，你尝试以一种可以利用它的方式阅读它，这是通过set指令完成的，你会看到有一整套指令，但唯一的区别实际上只是它们基于什么条件设置。</p><p>发言人   12:27<br>So what the set instruction does is it sets a single byte of a single register to either one or 0. And the basis for whether it sets it to one or to 0 is based on what the condition codes are In essence, what happened to your most recent instruction beforehand? Was it an arithmetic instruction or a set instruction, or a test instruction or a compare instruction? And as you can see, they’re all based on a logical combination of these condition codes that correspond to what the names imply. So for example, the set S instruction is true if the sine flag is true, meaning that the most recent result was negative and those other ones less than, less than or equal to are two’s complement comparisons. They have to take into consideration, did the most recent result cause an overflow or not? Because that will affect the result of the comparison. So that’s part of the reason we tortured you with understanding two’s complement arithmetic and how you compare results, making you understand the bit level behavior.<br>所以set指令的作用是将单个寄存器的单个字节设置为1或0。并且它是将其设置为1还是0的基础是基于条件代码本质上是什么，您之前的最新指令发生了什么事情？它是算术指令还是集合指令，还是测试指令或比较指令？正如你所看到的，它们都是基于这些条件代码的逻辑组合，这些代码对应于名称的含义。因此，例如，如果sine标志为真，则set指令为真，这意味着最近的结果是负数，而那些小于、小于或等于的其他结果是两个补数的比较。他们必须考虑，最近的结果是否导致溢出？因为这会影响比较的结果。所以这就是我们折磨你理解2的补码算术以及如何比较结果的部分原因，让你理解位级行为。</p><p>发言人   13:48<br>Do so that you can understand what these instructions do. So we’re cruel, but we have a reason for our cruelty. So you say 1 B, how do you deal with 1 B? Well, here’s another thing we didn’t tell you yet, and we’re going to keep telling you more stuff over and over again. It turns out for every one of these 16 registers, you can directly set the lowest order byte of it to either 0 or 1 and won’t affect it. Turns out it doesn’t affect any of the other 7 B of that register. And they all have quirky names. The L means low and there. So here’s an example of putting all this together to do something that’s vaguely useful.<br>这样你就能理解这些指令的作用。所以我们很残忍，但我们的残忍是有原因的。所以你说1 B，你如何处理1 B？嗯，还有一件事我们还没有告诉你，我们会一遍又一遍地告诉你更多的东西。事实证明，对于这16个寄存器中的每一个，您可以直接将其最低顺序字节设置为0或1，并且不会影响它。结果它不影响该寄存器的其他7个B中的任何一个。他们都有古怪的名字。L的意思是低和那里。所以这里有一个例子，将所有这些结合在一起做一些模糊有用的事情。</p><p>发言人   14:42<br>Suppose I want to function GT that will take two numbers and compare them and set the result, return a result value of one. If x is greater than y and 0 otherwise. And so here’s the assembly code with some tabbing problems. Fix this kind thing bugs me, hold on.<br>假设我想要函数GT，它将接受两个数字并比较它们并设置结果，返回结果值为一。如果x大于y，否则为0。这里是有一些制表符问题的汇编代码。解决这种困扰我的事情，坚持住。</p><p>发言人   15:14<br>I might not want to try and do this.<br>我可能不想尝试这样做。</p><p>发言人   15:30<br>Well, nope, I will fix this later. Anyways, it’s not the end of the world.<br>好吧，不，我以后会解决这个问题。不管怎样，这不是世界末日。</p><p>发言人   15:42<br>Normally in assembly code, 1 thing you’ve noticed is that the instructions are indented by a tab space. And the only thing that’s way over in the left margin are in way. So this is just sort of. The asselar is actually quite tolerant of formatting things, but this isn’t the way it normally looks. So anyways, the point is there’s a comparison.<br>通常在汇编代码中，您注意到的一件事是指令由制表符空格缩进。而左边唯一超过的东西就是在路上。所以这只是某种程度上的。该asselar实际上是相当宽容的格式化的东西，但这不是它通常看起来的方式。所以无论如何，重点是有一个比较。</p><p>发言人   16:07<br>One rule that you need to understand about procedure is that the first argument is passed in register RDI in the second and register RSI, and that if I’m going to return a result from a function, I do that by storing it and register Rix before I return. So the first instruction compares these two. And you notice how I flipped the order. It says RSI, which is y, and RDI, which is x, but when I annotate it, I say x to y, so that I mentally I’m thinking in the order that the actual comparison is made rather than the way they’re listed. So I always do that when I’m looking at code to help me flip those two around.<br>你需要了解的关于过程的一条规则是，第一个参数在第二个寄存器RDI和寄存器RSI中传递，如果我要从一个函数返回结果，我可以通过存储它并在我返回之前注册Rix来实现。所以第一个指令比较这两个指令。你注意到我是如何翻转顺序的。它说RSI，即y，RDI，即x，但是当我注释它时，我会说x到y，这样我心里就会按照实际比较的顺序进行思考，而不是按照它们列出的方式。所以当我查看代码时，我总是这样做，以帮助我翻转这两个方面。</p><p>发言人   16:53<br>And then here’s our instruction. So that compare instruction set, these four condition code registries. And now the set G says, now set this single byte register, the lowest byte of Rax to 0, 1. The result was the comparison was greater.<br>然后这是我们的指示。以便比较指令集，这四个条件代码注册表。现在设置G说，现在将这个单字节寄存器，即Rax的最低字节设置为0，1。结果是比较性更大。</p><p>发言人   17:13<br>So according to this rule. And the effect of that was to set just this 1 B of this 8 B register to either 0 or 1. Now, my problem is that these remaining 7 B have whatever happened to be there before. And I want it to be all zeros. So the way it does it is a bit weird.<br>所以根据这个规则。而这样做的效果是将这个8 b寄存器中的这1 b设置为0或1。现在，我的问题是这些剩下的7 b之前碰巧在那里。我希望它全部是零。所以它的操作方式有点奇怪。</p><p>发言人   17:44<br>There’s an instruction called move with 0 extension byte too long. Yeah, you get to know these better with time. And what that means is you can actually copy a byte from any place, like the low order byte of some other register into a new register. And you’ll put zeros to the left of it. That’s what they mean by zero extension. That seems logical. But one thing you’ll notice is the destination here is EA, which you’ll recall, although it doesn’t show here, that’s the lower 32 b of register rax. And then you’d say, well, that only got me halfway there.<br>有一个名为 “移动” 的指令，其0扩展字节太长。是的，随着时间的推移，你会更了解这些。这意味着你实际上可以从任何地方复制一个字节，就像把其他寄存器的低位字节复制到一个新寄存器中一样。你会在它的左边放零。这就是他们所说的零扩展的意思。这似乎是合乎逻辑的。但是你会注意到的一件事是，这里的目的地是EA，你会记得，虽然这里没有显示，但那是寄存器rax的低32 b。然后你会说，好吧，这只让我走了一半。</p><p>发言人   18:33<br>How do I make sure the upper 32 b are set to 0? Well, one of the weird quirks of X 8664 is for any computation where the result is a 32 b result, it’ll add zeros to the remaining 32 b of the register. And it’s different. For example, the byte level operations, only the bytes 2 B, or operations like what you’d have if the data type were short, only affect those 2 B. But the 4 B instructions set the upper bytes to 0, and that was some somebody at AMD, and I don’t know who it is decided this was a good idea.<br>我如何确保上限32 b设置为0？好吧，X 8664的一个奇怪的怪癖是，对于任何结果是32 b的计算，它会向寄存器的剩余32 b添加零。这是不同的。例如，字节级操作，只有字节2 B，或者数据类型短的情况下所拥有的操作，只会影响那些2 B。但是4 b指令将高字节设置为0，这是有人在AMD，我不知道是谁决定这是一个好主意。</p><p>发言人   19:21<br>And it might be a good idea, but it’s really confusing. But that’s something you’ll have to just sort of remember in the back of your mind when you see things like this. So the effect of this instruction is to take this 1 B result, which is the lower order byte of register Rax, copy it to the same place as it already is, but then set the remaining 7 B to 0, which is what we want. So you’ll see this pattern quite often.<br>这可能是个好主意，但它确实令人困惑。但当你看到这样的事情时，你必须在脑海中记住这一点。所以这个指令的作用是将这个1 B的结果，也就是寄存器Rax的低位字节，复制到它已经存在的位置，但是然后将剩余的7 B设置为0，这就是我们想要的。所以你会经常看到这种模式。</p><p>发言人   19:56<br>Question, got it. OK, so now that’s sort of sometimes I want to do this. I just want to get a 1 b flag as a result of the comparison. But more generally, I want to do something with that information and not just set 1 b. So the simplest version is what about a conditional and if and possibly an else? Well, that’s done by, there’s actually two ways to do it. So we’ll go through the sort of general purpose, traditional way, and then we’ll show the more specialized, a newer way, and we’ll compare those.<br>问题，明白了。好的，现在有时候我想这样做。我只想通过比较得到一个1 b的标志。但更一般地说，我想对这些信息做点什么，而不仅仅是设置1 b。所以最简单的版本是条件和如果以及可能的其他？好的，那是通过完成的，实际上有两种方法可以做到。因此，我们将介绍一种通用的、传统的方式，然后我们将展示更专业的、更新的方式，并进行比较。</p><p>发言人   20:35<br>So the traditional way is to use what’s known as a jump instruction and a jump instruction. Normally instructions execute in a particular order, just like when you’re writing a program and you write a series of statements, they execute one after the next. A jump instruction is a way you can go from wherever you are to someplace else and either skip over some instructions or jump back to some other previous position or wherever. And there’s two kinds of jumps, unconditional, Well, there’s several kinds. But an unconditional jump means when I say jump, you jump. But there’s other conditional jumps that will actually only do that jumping if the condition codes are set appropriately. And you’ll see that the names of these jump instructions are the same as the set instructions with the same conditions. So there’s a variety of different reasons that the program may be given to either jump or not jump.<br>所以传统的方法是使用所谓的跳转指令和跳转指令。通常指令以特定的顺序执行，就像当你编写一个程序时，你编写一系列语句，它们一个接一个地执行。跳转指令是一种方式，您可以从任何地方到其他地方，跳过一些指令或跳回其他先前的位置或任何地方。有两种跳跃方式，无条件的，有好几种。但是无条件跳跃意味着当我说跳跃时，你就跳了。但还有其他条件跳跃，只有在条件代码设置适当时才会真正进行跳跃。你会看到这些跳转指令的名称与具有相同条件的set指令的名称相同。因此，程序可能会被赋予跳跃或不跳跃的各种不同原因。</p><p>发言人   21:39<br>So I’m going to use this one example to show you several different versions of it. And like everything you’ll see here, these particular programs aren’t that useful. They illustrate ideas.<br>所以我将使用这个例子向您展示它的几个不同版本。就像你在这里看到的所有东西一样，这些特定的程序并不是那么有用。他们阐述了想法。</p><p>发言人   21:53<br>So imagine I wanted to compute the difference of two values and then take their absolute value. So there’s various ways you can imagine doing it, By the way I’m going to do it is decide to either subtract y from x or x from y, depending on the relative values of those two. And of course, the astute observer will notice that this has problems if you have a team in somewhere, if the result, because there’s no absolute value, but we’re not going to worry about that. So in other words, I just want to say, if x is greater than y, then I want to subtract y from x, and if x is less than or equal to y, I want to subtract x from y, and here’s the code for it, where the blue and the red are color coding the different parts of it.<br>想象一下，我想计算两个值的差，然后取它们的绝对值。所以有各种各样的方法可以想象，顺便说一下，我要做的是决定从x中减去y或从y中减去x，具体取决于这两者的相对值。当然，精明的观察者会注意到，如果你在某个地方有一个团队，这会有问题，如果结果，因为没有绝对的价值，但我们不会担心那个。换句话说，我只想说，如果x大于y，那么我想从x中减去y，如果x小于或等于y，我想从y中减去x，这是它的代码，其中蓝色和红色是不同部分的颜色编码。</p><p>发言人   22:46<br>So here you see the compare instruction, and again I’ve written them out in the reverse order to help me keep track of what the comparison is. And it says I’m going to compare x and y and if x is less than or equal to y I want to jump to a location specified by this label l 4. And so in general, in assembly code, if you give a name and then a colon, what’s to the left of that is called a label. And it’s just a tag that’s only visible in the assembly code. It’s not actually in the object code that will later be used to compute an address for determining that will encode where this jump will actually land.<br>所以在这里你看到了比较指令，我再次以相反的顺序写出它们，以帮助我跟踪比较的内容。它说我要比较x和y，如果x小于或等于y，我想跳转到这个标签l4指定的位置。所以一般来说，在汇编代码中，如果你给出一个名字和一个冒号，它左边的东西叫做标签。它只是一个仅在汇编代码中可见的标签。它实际上不在对象代码中，稍后将用于计算地址，以确定该地址将编码此跳跃实际降落的位置。</p><p>发言人   23:37<br>When you’re looking at assembly code, one of the features it provides is a little bit easier way to understand it than to look at addresses. And so it just tells you to be looking at that the jump would occur to this position. And what you’ll see here is.<br>当您查看汇编代码时，它提供的功能之一是比查看地址更容易理解它。所以它只是告诉你要注意这个位置会发生跳跃。你将在这里看到的是。</p><p>发言人   23:55<br>In these two branches, the blue code versus the red, what you’re doing is in one case, subtracting y from x here, you move x into rax, and then you subtract y from it. And here you do the opposite. You’re subtracting x from y? In this case, so in the first case, you’ll make the jump of x is less than or equal to y, you subtract y from x, and you’ll do a return.<br>在这两个分支中，蓝色代码与红色代码，你所做的是在一种情况下，从这里的x减去y，你将x移动到rax，然后你从中减去y。在这里，你做的是相反的。你要从y中减去x？在这种情况下，在第一种情况下，您将使x的跳跃小于或等于y，从x中减去y，然后执行返回。</p><p>发言人   24:29<br>And you remember that I don’t have to do anything special to return a value back from a function. All I have to do is stick it and register IX, and the calling function will know that’s where to find the return value. So here it does a rep, and here it does a subtraction. And it simply does a return directly from that part. Of it. So it’s a pretty straightforward piece of code. But you can see it’s using this jumping to create two different parts of code that get executed under different conditions. What’s that? I’m sorry, I didn’t hear him.<br>你要记得，我不需要做任何特别的事情就可以从一个函数返回值。我所要做的就是粘贴它并注册IX，调用函数将知道在哪里找到返回值。这里做一个rep，这里做一个减法。它只是直接从那部分返回。关于它。所以这是一个相当简单的代码。但是你可以看到它正在使用这种跳跃来创建在不同条件下执行的两个不同代码部分。那是什么？对不起，我没有听到他说话。</p><p>发言人   25:15<br>Oh, well, there’s a couple things. One is you want the result to end up in Rex. And remember, subtract all those arithmetic instructions are just two argument instructions. You take two values and then the second argument, the destination argument, you overwrite what was there with the new result. So this is a pretty typical pattern. You’ll see you move some value, a register, and then into Rex is very common, and then you do some arithmatic operation with that register as a destination to kind of update it. It’s like if you were writing and see if all the time you had to write sort of x plus equals something, x minus equals, and all your arithmetic had to be expressed in those terms.<br>哦，有几件事情。一个是你希望结果以雷克斯结束。并记住，减去所有这些算术指令只是两个参数指令。你取两个值，然后第二个参数，目标参数，你用新的结果覆盖那里的内容。所以这是一个非常典型的模式。你会看到你移动了一些值，一个寄存器，然后进入Rex是非常常见的，然后你用这个寄存器作为目标进行一些算术操作来更新它。这就像你在写作，看看你是否一直需要写一些x + 等于，x-等于，你所有的算术都必须用这些术语来表达。</p><p>发言人   26:14<br>Okay, so it’s fun to look at assembly code for about 5 minutes, and then you get sick of it.<br>好的，看大约5分钟的汇编代码很有趣，然后你就厌倦了它。</p><p>发言人   26:23<br>So one thing to sort of present these same ideas, but give it in a little bit more abstract form, is to write it in C, but in a form of C that looks a lot like assembly code. And in particular, one of the features of C that is not generally advertised, there’s a statement called go to, and you can put labels in your code. And you can tell the program that if something happens, then you want to jump to that part of the program. So it looks a lot like that assembly code, right, that you saw jump jle is sort of what this says.<br>因此，有一件事可以呈现相同的想法，但又可以给它一些更抽象的形式，那就是用C语言编写它，但是用一种看起来很像汇编代码的C语言形式。特别是，C的一个特性通常没有宣传，有一个叫做go到的语句，你可以在代码中放置标签。你可以告诉程序，如果发生了什么事情，那么你想跳转到程序的那部分。所以它看起来很像那个汇编代码，对吧，你看到jump jle就是这个意思。</p><p>发言人   27:09<br>It’s like I’m doing a test. And then if the test, which in this case I call it N test because it’s the opposite of the test that’s in the original program, and if that end test condition holds, I want to jump to another part of the program I’m calling elts. And you notice I uppercase that because it’s not the actual elses of an if then elses. And similarly, if this one is, well, actually to be most accurate, I should have simply said return result from this point. This code’s a little bit out of date. So I should have said return result. But another version would be to have done a go to down to here and return the result from there.<br>这就像我在做一个测试。然后，如果测试 (在这种情况下，我称之为N测试，因为它与原始程序中的测试相反，并且如果结束测试条件成立，我想跳转到程序的另一部分，我称之为elts。你会注意到大写的那个，因为它不是if then elses的实际情况。同样地，如果这个实际上是最准确的，我应该简单地说从这一点返回结果。这段代码有点过时了。所以我应该说一下返回结果。但另一个版本是向下转到这里并从那里返回结果。</p><p>发言人   27:56<br>And you’ll see different compilers generate in different forms. So I’m going to typically use this way of presenting code just so that you can look at and understand what these control structures look like without having to sort of scrutinize the low level assembly code instructions. So we can sort of take this question.<br>你会看到不同的编译器以不同的形式生成。所以我通常会使用这种方式来呈现代码，这样你就可以查看和理解这些控制结构是什么样子，而不必仔细检查低级汇编代码指令。这样我们就可以回答这个问题了。</p><p>发言人   28:27<br>Is there? You? Do. I think there’s a homework or a practice problem of exactly that sort In general, do it neither way. And why the compiler picks one versus the other is I think it’s a completely arbitrary decision, but consistently I have found GCC does it this way.<br>有吗？你呢？做。我认为有一个家庭作业或练习问题通常就是这种类型的，不做任何一种方式。为什么编译器选择一个而不是另一个，我认为这是一个完全武断的决定，但我一直发现GCC是这样做的。</p><p>发言人   28:47<br>Okay? So let’s sort of talk, sort of imagine you’re writing a compiler. How would you take this special case I just showed and generalize it into a rule for compiling if then else’s expressions? And I’m going to use the version and see the question mark colon version where encapsulate that whole conditional is a single expression rather than the statement. But you can understand that these rules would be the same in either case.<br>好吗？让我们来谈谈，想象一下你正在编写一个编译器。你将如何处理我刚刚展示的这种特殊情况，并将其推广为编译规则，如果那么else的表达式？我将使用该版本并查看问号冒号版本，其中封装整个条件是单个表达式而不是语句。但是你可以理解这些规则在任何一种情况下都是相同的。</p><p>发言人   29:20<br>So imagine in general, you had AC code where there’s a test controlling whether to return the result of one expression or another. And this is what my EBS diff code would look like if I wrote it in that form. And so in general, what we can say is what we’ll do is we’ll take the test and invert it and say, if that test is not true, then we will. So if n test is true, then we will jump to compiled the code, where we’ve compiled the code for the elts expression. And if that test fails here, so that the original test condition holds, then we’ll stick in whatever code it takes to compute the then expression.<br>想象一下，在一般情况下，你有交流代码，其中有一个测试控制是否返回一个表达式的结果。如果我用那个格式写的代码，这就是我的EBS diff代码的样子。因此，总的来说，我们可以说的是我们将进行测试并将其反转并说，如果该测试不正确，那么我们就会这样做。因此，如果n test为真，那么我们将跳转到编译的代码，在那里我们已经编译了elts表达式的代码。如果测试在此处失败，那么原始测试条件成立，那么我们将坚持使用计算then表达式所需的任何代码。</p><p>发言人   30:21<br>And then we’ll merge back together In the case you saw, where it’s just a single little function, we can just call it rep here and get out of the thing. But if this is one line of code, and then there’s a whole bunch of lines after that, typically you want to merge back together again and continue from there. And so that’s what this shows. I’ll finish by going to whatever it comes afterwards.<br>然后我们将在您看到的案例中重新合并，其中它只是一个小函数，我们可以在这里称其为rep并摆脱它。但如果这是一行代码，然后在那之后还有一大堆行，通常你想再次合并在一起并从那里继续。这就是它所展示的。我最后会去看看之后会发生的任何事情。</p><p>发言人   30:45<br>So this is a way I like to, although we’re not writing compilers in this course, I think it helps to think in terms of general rules of how a compiler would translate C code into assembly code so that when you see that assembly code, you’ll recognize these patterns and know what they mean.<br>所以这是我喜欢的一种方式，尽管我们在这门课程中没有编写编译器，但我认为从编译器如何将C代码转换为汇编代码的一般规则方面思考是有帮助的，这样当你看到汇编代码时，你会认识到这些模式并知道它们的意思。</p><p>发言人   31:04<br>Question, after you go to the else clause, does it fall through to the done or yes? Yes, so just as we saw, yes, in general, like here, it would fall through to the done. Good question. OK, so that’s one version of conditional. And that’s the most general way. And the way it used to always be done.<br>问题，在你转到else子句之后，它是落在完成还是是的？是的，正如我们所看到的，是的，一般来说，就像在这里，它会落在完成。好问题。好的，这是一种形式的条件。这是最普遍的方法。以及它过去一直被做的方式。</p><p>发言人   31:32<br>But there’s another approach that you’ll see fairly common in code. It’s sort of an optimization called conditional move. And it’s been non-intuitive from a software developer’s perspective of why you’d ever want to do this.<br>但是还有另一种在代码中相当常见的方法。这是一种被称为条件移动的优化。从软件开发人员的角度来看，你为什么想要这样做是不直观的。</p><p>发言人   31:48<br>The basic idea is I’m going to compute both then and the elses, the values they’d produce. And only after that, I choose which 1 I use. So it seems wasteful, but it actually turns out to be more efficient if they’re fairly simple computations. And the reason of that is, and we’ll see a little bit more when we talk about performance optimization, a modern processor is a little like an oil tanker sailing in the sea, meaning that it plows along in a certain direction and it really is hard to get it to stop or to turn. So you say, what are you talking about? Think of an instruction sequence is the ocean of code that you’re cruising through, and these things can just fly through a straight sequence of code because they do what they call pipelining, meaning they start bringing in parts of one instruction before they’re done with the next and actually go up to depths of 20 or more instructions deep of how far ahead they’re working, sort of fetching forward and future instructions while finishing up the ones that still remain. So that’s my ocean line, my tanker analogy.<br>基本的想法是我将同时计算它们和其他东西，它们产生的值。只有在那之后，我才选择我使用的1。看起来很浪费，但实际上，如果它们是相当简单的计算，它会更有效。原因是，当我们谈论性能优化时，我们会看到更多，现代处理器有点像在海上航行的油轮，这意味着它沿着某个方向前进，真的很难让它停下来或转弯。所以你说，你在说什么？把指令序列想象成你正在浏览的代码海洋，这些东西可以在直的代码序列中快速浏览，因为它们执行所谓的流水线操作。这意味着他们在完成下一个指令之前开始引入一个指令的某些部分，并实际达到20个或更多指令的深度，达到他们工作的深度，在完成剩余指令的同时向前和未来的指令。这就是我的海洋线，我的油轮类比。</p><p>发言人   33:06<br>But all of a sudden, you come, and then what happens when they hit a branch? They’ll try to guess. It’s called branch prediction. And guess is this branch going to go, where will the conditional branch be taken, or is it going to fall through? And they’re pretty good at that, They’re good at it 98% of the time.<br>但是突然之间，你来了，当他们撞到树枝时会发生什么？他们会试着猜测。这叫做分支预测。并猜测这个分支将要去哪里，条件分支将被采取，还是会失败？他们在这方面相当擅长，他们在98% 的时间都擅长。</p><p>发言人   33:29<br>Anticipate PSE of curves in the road. My analogy is breaking down and start going in that direction. And as long as they get it right, it’s very efficient. But if they get it wrong, it’s as if you have to stop the thing, back it up, turn the other way, start again, and that can take 40 instructions, 40 clock cycles, say, to do in bad situations. And this is pretty common if you think of like an absolute value, can you predict whether a value is going to be positive or negative? Not usually, So about half the time, whatever you guess, you’re going to guess wrong. So these conditional move instructions, it turns out it’s much easier to just plow through, compute both, and then at the last minute, all you have to do is move a value into a register or not. And that doesn’t require stopping the whole processor and making this turn.<br>预测道路上的曲线。我的类比是分解并开始朝那个方向前进。只要他们做对了，这是非常有效的。但如果他们弄错了，就好像你必须停止这件事情，备份它，转向另一个方向，重新开始，这可能需要40条指令，40个时钟周期，在糟糕的情况下才能完成。如果你把它想象成一个绝对值，这很常见，你能预测一个值是正的还是负的吗？通常不会，所以大约有一半的时间，无论你猜到什么，你都会猜错的。所以这些有条件的移动指令，事实证明只需犁过，计算两者都更容易，然后在最后一刻，你所要做的就是将一个值移动到一个寄存器中。这不需要停止整个处理器并进行此操作。</p><p>发言人   34:30<br>So that’s my long explanation for.<br>这就是我长时间的解释。</p><p>发言人   34:34<br>And if you don’t want to understand that I’ll just say, well, just trust me, it’s a good idea sometimes. So the general pattern then, if I use this same idea, is I want to compute both results. And I’ll call the result. And this is an eval. This is eval, the else’s value. I’ll compute both of them. I’ll do my test, and then this red thing, imagine that it’s all done with a single instruction that says I’ll copy the value of eval to result, but only if a condition holds. That’s why it’s called a conditional move. And we’ll see.<br>如果你不想理解，我就说，相信我，有时候这是个好主意。因此，如果我使用相同的想法，那么一般的模式是我想计算两个结果。我会通知结果。这是一个评估。这是eval，else的值。我将计算它们两个。我会做我的测试，然后这个红色的东西，想象一下，这一切都是通过一条指令完成的，指令说我会将eval的值复制到结果中，但前提是条件成立。这就是为什么它被称为条件移动。我们会看到的。</p><p>发言人   35:15<br>This is the code, by the way, you saw in my original version.<br>顺便说一下，这是你在我的原始版本中看到的代码。</p><p>发言人   35:19<br>Sorry to have to jump back. I had to explicitly tell the GCC, don’t use conditional moves because it really wants to very badly. And so you have to force it not to. And I did that here. So here’s the actual code then. And again, you’ll see the color coding that it’s doing both subtractions. It’s actually doing the move and subtract, move and subtract. So it’s doing both the branches you saw before, the then and the elses branch, it’s doing a comparison.<br>抱歉，我得跳回去。我必须明确告诉GCC，不要使用条件移动，因为它真的想要非常糟糕。所以你必须强迫它不要这样做。我在这里做到了。那么这是实际的代码。再一次，你会看到颜色编码，它正在进行两个减法。它实际上是在移动和减去，移动和减去。所以它正在处理你之前看到的两个分支，即then分支和elses分支，它正在进行比较。</p><p>发言人   36:00<br>And then here’s the conditional move, instruction C move. In this case, the L here is not a word size. It’s the less than or equal to direction. So in the case that I need the red value, basically you saw the red value is stored in register RDX. In that case, I will copy it into the result register. So again, it’s like this idea of just go ahead and do everything and then pick at the last end.<br>然后这是条件移动，指令C移动。在这种情况下，这里的L不是单词大小。它小于或等于方向。所以在我需要红色值的情况下，基本上你看到红色值存储在寄存器RDX中。在这种情况下，我将把它复制到结果寄存器中。所以，这就像是这个想法，继续做所有的事情，然后在最后结束时选择。</p><p>发言人   36:34<br>The point is that this one instruction, it looks just as far as for this processor execution, it’s sort of like a move instruction that it’s fairly straightforward to do.<br>重点是，这一条指令看起来就像处理器执行一样，有点像移动指令，执行起来相当简单。</p><p>发言人   36:50<br>Okay, so why doesn’t it do that all the time? Well, there’s a couple reasons. One is that might be a really, really bad idea to do both computations. If you have to crack a password in one and find the nth prime number in another, you probably don’t want to do both of those. So in general, in that case, so, and you’ll notice GCC will only do this if both branches are fairly straightforward computations that they’re trying to do.<br>好吧，那它为什么不一直这样做呢？嗯，有几个原因。一个是，做两种计算可能是一个非常非常糟糕的主意。如果你必须在一个密码中破解密码，并在另一个密码中找到第n个质数，你可能不想同时进行这两种操作。所以一般来说，在这种情况下，你会注意到，只有当两个分支都试图进行相当简单的计算时，GCC才会这样做。</p><p>发言人   37:23<br>And sometimes when you just plain can’t do it. So for example, if you’re using a conditional to guard whether a pointer can be dereferenced or not because it’s a null pointer, potentially a null pointer, then you really don’t want to try that null pointer dereference. Just as a way to save some time. And similarly, if you could have a side effect, the result of executing either branch could be to change some other part of the program state. Then you don’t really want to do that either. So the conditional move only gets used.<br>有时候你只是简单地做不到。因此，例如，如果您使用条件来保护指针是否可以解除引用，因为它是一个空指针，可能是一个空指针，那么您真的不想尝试这种空指针解除引用。只是作为一种节省时间的方式。同样地，如果你可能有一个副作用，执行任何一个分支的结果都可能是改变程序状态的其他部分。那么你也不是真的想这样做。因此，条件移动只被使用。</p><p>发言人   38:03<br>Then in this somewhat special case, you have two computations, relatively easy to do, safe to do, no side effects. But that happens just often enough that this is actually a worthwhile thing.<br>那么在这种有点特殊的情况下，你有两个计算，相对容易做到，安全可靠，没有副作用。但这种情况经常发生，这实际上是一件有价值的事情。</p><p>发言人   38:19<br>Okay, so that gets us conditionals. And now let’s look at loops. That’s the sort of next step up in control structures. And C actually has three different kinds of loops. It has a while loop, which you’re familiar with, and a for loop, which you’re familiar with, and it has a third one in my whole life of writing. And I’ve written a lot of C code in my life.<br>好的，这让我们有条件。现在让我们来看看循环。这是控制结构的下一步。而C实际上有三种不同类型的循环。它有一个你熟悉的while循环和一个你熟悉的for循环，在我整个写作生涯中它还有第三个。我一生中写了很多C代码。</p><p>发言人   38:44<br>I’ve used this bike about six times, but it turns out it’s the simplest one to implement, so we’ll go ahead and do it. So it’s called the do while loop, and so the key word is do, and then there’s some stuff you do, that’s the body of the do. And then there’s a test at the end that tells you whether to keep repeating this loop. So it sort of flips a normal while loop.<br>我已经用过这辆自行车大约六次，但事实证明它是最容易实现的，所以我们将继续进行。所以它被称为do while循环，关键词是do，然后你要做一些事情，这就是do的主体。然后在最后有一个测试，告诉你是否继续重复这个循环。所以它有点像翻转一个正常的while循环。</p><p>发言人   39:10<br>You have the conditional test at the front, and here you have it at the end and. So it turns out if we think in terms of go to, it’s a pretty straightforward thing to replace this with a code that will do a test. And if the test holds, it will jump back and say OK, re-execute that part of the program I was just in. So it sets up a loop where you can think of it literally a loop of control flow going round and round.<br>你在前面有条件测试，在这里你在最后有它。所以事实证明，如果我们从go的角度考虑，用一个可以进行测试的代码替换它是一件非常简单的事情。如果测试成立，它会跳回来并说，好的，重新执行我刚刚执行的那部分程序。所以它建立了一个循环，你可以把它想象成一个不断循环的控制流循环。</p><p>发言人   39:48<br>And by the way, this is actually a semi-reusable function, it’s called pop count sometimes. How many ones are there in a word of data, this case a sixty-fourth word? There’s been some generations of data lab where you were required to write this function using all your favorite operations. And with a fairly small limit on operations. But we’re not doing that today. So here, my point is, you see, there’s a fairly straightforward way of taking this particular loop and turning it into just a combination of conditional.<br>顺便说一下，这实际上是一个半可重复使用的函数，有时称为pop count。在一组数据中，有多少个单词？在这种情况下，是第六十四个单词？已经有几代数据实验室要求您使用所有您最喜欢的操作编写此函数。而且对操作的限制相当小。但我们今天不会这么做。所以在这里，我的观点是，你看，有一种相当直接的方法可以将这个特定的循环转化为条件的组合。</p><p>发言人   40:33<br>Where you do is you jump back to where you were before, and here’s the actual code for it. I won’t go through all of it, but you can believe from these annotations that it very closely follows the code here. And the main thing to see is this jump, if not equal. To label L 2. And that takes you back to here. And so the general form of it then is you take a do, and then this part of it’s called the body of the loop. And this is the test. And so now you set up some code where you can execute the body, perform the test. And if the test holds, you go back to the loop.<br>你所做的就是跳回你之前所在的地方，这里是它的实际代码。我不会全部解释，但你可以从这些注释中相信它非常紧密地遵循这里的代码。要看到的主要事情是这个跳跃，如果不是相等的话。给L 2打上标签。这将带你回到这里。因此，它的一般形式是你做一个事情，然后它的这一部分被称为循环体。这就是测试。所以现在你设置了一些代码，你可以在其中执行body，执行测试。如果测试成立，你就回到循环。</p><p>发言人   41:19<br>So a while loop is really just like a do loop, a do while loop, except that you move the test to the beginning. And the only difference, therefore, is with a do loop, you don’t do the test the first time through. You’re guaranteed to do it the first time no matter what. While in while loop, we will explicitly test even at the very beginning, skip over the loop if the condition doesn’t hold. So there’s two ways to generate a code.<br>所以while循环实际上就像一个do循环，一个do while循环，除了你把测试移动到开头。因此，唯一的区别在于使用do循环时，您不是第一次进行测试。无论如何，你保证第一次就做这件事。而在While循环中，我们甚至会在最开始就显式地测试，如果条件不成立就跳过循环。所以有两种生成代码的方法。</p><p>发言人   41:50<br>Well, there’s more than two ways to generate code for a while loop, but you’ll find GCC actually uses two different ways. One is what we’ll find when we use this optimization setting I talked about last time called minus capital O, which stands for optimize G, which means debug. Of course, as you’ve already know, there’s some history to what the minus G flags means. So, and as I mentioned last time, this turns out to be the perfect level of optimization for this course where you want to be able to look at machine code and understand it and how it relates to the C code because it does some sort of simple optimizations, but it doesn’t try to rewrite your whole program to make it run better. Whereas even with -0 1, which is the next level in the optimization, you’ll find sometimes it will do some pretty quirky stuff. But when you actually as a program developer as a software developer out there, or you talk to companies and you ask, what optimization level do you use, they’ll probably say minus O2, the common one. So usually there’s higher level of optimization, and we’re purposely backing off from that to make this code easier to understand. So anyways, with the default optimization we’re using for this course, it does transformation.<br>嗯，有两种以上的方法可以为while循环生成代码，但您会发现GCC实际上使用两种不同的方法。一个是当我们使用我上次谈到的这个优化设置时，我们会发现什么，这个优化设置叫做负大写字母O，它代表优化G，这意味着调试。当然，正如你已经知道的，负G标志的含义有一些历史。所以，正如我上次提到的，这证明是本课程的完美优化水平，您希望能够查看机器代码并理解它以及它与C代码的关系，因为它进行了一些简单的优化。但它不会尝试重写整个程序以使其运行得更好。而即使使用-0 1，这是优化的下一个级别，你会发现有时它会做一些非常古怪的事情。但是当你实际上作为一名程序开发人员作为软件开发人员，或者你与公司交谈并询问你使用什么优化级别时，他们可能会说-O2，常见的一个。通常会有更高级别的优化，我们故意从中退出，以使代码更容易理解。所以无论如何，通过我们在本课程中使用的默认优化，它会进行转换。</p><p>发言人   43:18<br>I call the jump to middle translation. These are, by the way, my own names. You won’t find them in any other document.<br>我称之为跳转到中间翻译。顺便说一下，这些是我自己的名字。您在任何其他文档中都找不到它们。</p><p>发言人   43:27<br>But the idea of it is, imagine again, I have a while loop of this form where there’s a test and the body to execute. Well, what the problem I have to do compared to before is somehow I have to execute the test before I start the first iteration of the loop. So the way I’ll do it here is I’ll just jump to the middle of what was the old loop code to the test portion of that loop, and then let that test determine whether I actually entered the loop itself.<br>但是它的想法是，再想象一下，我有一个这种形式的while循环，其中有一个测试和要执行的主体。与以前相比，我必须做的问题是，在开始循环的第一次迭代之前，我必须以某种方式执行测试。所以我在这里做的方式是，我会跳到旧循环代码的中间，进入该循环的测试部分，然后让该测试确定我是否实际进入了循环本身。</p><p>发言人   44:03<br>And so this is an example of a go to code version of my pop count function. So I’ve written the pop count function using a while loop. This time, it turns out whether you use a do or a while loop, you’ll get the same result in this particular function and. You’ll see the way it looks is it? It jumps to the test portion of the code. And then if that holds, it then actually starts the first execution of the loop. And then from there on, it looks the same as the do while loop. It just does what was in the loop does. The test jumps back to the beginning.<br>因此，这是我的pop计数函数的转到代码版本的示例。所以我使用while循环编写了pop计数函数。这次，无论你使用do还是while循环，你都会在这个特定的函数中得到相同的结果。你会看到它的样子吗？它跳到代码的测试部分。然后，如果这成立，它实际上开始循环的第一次执行。然后从那里开始，它看起来与do while循环相同。它只是做了循环中的事情。测试又回到了开始。</p><p>发言人   44:52<br>And then there’s a second method, which is in some ways more traditional. And you’ll find that if you use optimization 1, which is a fairly useful thing to do in practice. So just to show you that instead of deciding which 1 I was going to show you, I decided to show you both. And the idea of that is to do essentially to take a while loop and turn it into a do while loop. But introducing a conditional beforehand, that would essentially guard your entrance to the loop. So you do an initial test. And if that’s fault, then you skip over the loop altogether. Otherwise, it’s performed like a do while loop. And so that has a fairly straightforward translation into code.<br>然后还有第二种方法，在某些方面更传统。你会发现，如果你使用优化1，这在实践中是一个相当有用的事情。所以只是为了向你展示，我决定向你们展示哪一个，而不是决定要向你们展示哪一个。这个想法基本上是做一个while循环，并将其变成一个do while循环。但是预先引入一个条件，这基本上会保护你进入循环。所以你做一个初步测试。如果这是错的，那么你就完全跳过这个循环。否则，它会像do while循环一样执行。因此，这有一个相当简单的翻译到代码中。</p><p>发言人   45:42<br>And that, again, it looks a little different from before. It has an initial test, but then it looks like a do while loop. So I won’t show you the assembly versions of those. But if you look at it, actually, the code is all in directories that are linked to the class directory, the class web page. So you can actually look at the code and you’ll see that it follows exactly the way I’m describing it.<br>而且，再一次，它看起来与以前有点不同。它有一个初始测试，但看起来像一个do while循环。所以我不会向你展示它们的汇编版本。但是如果你看一下，实际上，代码都在链接到类目录，即类网页的目录中。所以你可以实际查看代码，你会发现它完全遵循我描述的方式。</p><p>发言人   46:15<br>And then a third kind of loop is the for loop, which in C is actually a very powerful, very general type of thing. And so it’s very commonly used. But you can see that the for loop has four components to it, has an initialization, has a test, has a rule for doing an update in case as a way to continue the loop. And then it has the body of the loop.<br>然后第三种循环是for循环，在C中，for循环实际上是一种非常强大、非常通用的循环类型。所以它是非常常用的。但是你可以看到，for循环有四个组件，有一个初始化，有一个测试，有一个更新规则，以继续循环。然后它有循环的主体。</p><p>发言人   46:43<br>And so here’s a version of my pop count function where I’m just going through all the bits in the word, extracting them out, and then adding them, accumulating them to be the result. So ripping apart these four, you’ll see that these four blocks of correspond to the initialization is to set I equal to 0. The test is to compare I to the word size, which I’ve set here to be eight times. So however many bytes there are in an int, multiply that by 8 to get the word size. And then the update is I plus, plus, and then the body is this stuff that’s within the brackets here.<br>这是我的pop计数函数的一个版本，我只是遍历单词中的所有位，将它们提取出来，然后将它们相加，累积为结果。所以撕开这四个块，你会看到这四个块对应于初始化是将I设置为0。测试是将I与单词大小进行比较，我在这里设置了八次单词大小。因此，无论int中有多少个字节，都要将其乘以8以获得单词大小。然后更新是I加，加号，然后正文是这里括号内的内容。</p><p>发言人   47:33<br>So I can think of that in general one general way too.<br>所以我一般也可以用一种普遍的方式来思考这个问题。</p><p>发言人   47:41<br>Think about A for loop. And C is by this rule that will turn A for loop into a while. So what it says is I first do the initialization, and then I do a loop where I guard it with this test. And then what I keep doing is executing the body and then performing whatever update there is and then continuing with the test. So that’s sort of the semantics, the definition of the behavior of A for loop in C?<br>想想一个for循环。而C通过这个规则会把for循环变成一段时间。所以它说的是我首先进行初始化，然后我进行一个循环，用这个测试来保护它。然后我一直在做的是执行body，然后执行所有更新，然后继续测试。这就是在语义上，C中for循环行为的定义？</p><p>发言人   48:20<br>So I can take my different pieces of my for loop and say, well OK. I’ll take that rule and use it to pack them in to form a while loop. And of course, you know that you can sort of go between those two. And it’s somewhat a matter of taste whether a given loop should be written using a for loop or a while loop.<br>所以我可以用我的for循环的不同部分说，好吧。我将采用该规则并使用它将它们打包成while循环。当然，你知道你可以在这两者之间走一种。给定的循环是否应该使用for循环或while循环编写，这在某种程度上是一个品味问题。</p><p>发言人   48:48<br>So one reason why it’s actually useful to do this minus o one optimization I talked to you about is it’s fairly common for the initial test to be triviality, true. So for example, in here, if I equals 0, and I’m comparing it to the word size, which would typically be 32, well, that test is true. That’s a certain thing. And so what you’ll see is that the compiler can figure that out and just throw away this guarding code that would have to be there otherwise. So that, I believe, is the main reason why this is the transformation that gets used would be 0. One optimization level is that oftentimes it doesn’t need this initial test.<br>所以做这个减去我和你谈到的一个优化实际上很有用的一个原因是，最初的测试相当普遍是琐碎的，真的。例如，在这里，如果I等于0，并且我将其与单词大小进行比较，通常为32，那么这个测试是正确的。这是一件确定的事情。所以你会看到的是，编译器可以解决这个问题，只需扔掉这些保护代码，否则就必须在那里。因此，我相信，这就是为什么使用的转换为0的主要原因。一个优化级别是通常不需要这个初始测试。</p><p>发言人   49:43<br>Okay, so now I’m going to finish up with what, to me at least, the loop stuff is sort of what you’d expect if you were to have to turn C code into something very low level where all you could do is jumps and tests. Well, maybe that’s obvious, but maybe not.<br>好的，现在我要结束一下，至少对我来说，循环的东西有点像你所期望的，如果你必须把C代码变成一个非常低级的东西，你所能做的就是跳跃和测试。好吧，也许这很明显，但也许不是。</p><p>发言人   50:07<br>The switch statement, on the other hand, is a totally different beast. And I want to show you that because no counterpart in normal C code of how you’d even think about it. And it’s fairly a little bit harder to do cipher. And you’re going to have to do it in the bomb web. So here is an example of a switch statement that of nothing about this is. Useful, except to demonstrate some principles of how to turn a switch statement into assembly code. So the point of it is, as you know and see, you switch on a particular value, some type of integer value, and then it will match different cases where each of these cases has to be some constant numeric value, constant integer value.<br>另一方面，switch语句是完全不同的东西。我想向您展示这一点，因为在普通的C代码中没有对应的代码，您甚至不会考虑它。而且密码相当难一些。你将不得不在炸弹网络中这样做。这里是一个switch语句的例子，与此无关。有用，除了演示如何将switch语句转换为汇编代码的一些原则。所以它的重点是，正如你所知道的，你打开一个特定的值，某种类型的整数值，然后它将匹配不同的情况，其中每个情况都必须是某个常量数值，常量整数值。</p><p>发言人   51:02<br>And one of the weirdest features of C is if you at the end of the case, if you don’t explicitly say break, it’ll do what’s known as falling through. So in this example here, we divide y by z, and then it will just glide right into this statement that adds z to w, this is by the way like one of the worst design decisions in the history of programming languages.<br>而C最奇怪的特点之一是，如果你在案例的最后，如果你没有明确地说break，它就会做所谓的 “掉入”。在这个例子中，我们将y除以z，然后它会滑入这个将z加到w的语句中，顺便说一下，这就像是编程语言历史上最糟糕的设计决策之一。</p><p>发言人   51:31<br>And it’s been the cause of more and more heartbreak and bugs that nobody could understand than any other single part of the language. And for some bizarre reason, they’ve kept it alive, even into Java and all these other languages that fixed a lot of the worst parts, the most dangerous parts of sea. But somehow they kept this feature. And so just as advice, as a programmer, if you ever, ever use this where you purposely want it to go from one case to another, you should have to put a comment in there to say, trust me, I really did want it to fall through. I know you almost never want to do this, but I do hear. So that’s a fairly common convention. And I don’t know how many times I’ve had bugs that were because I forgot to put breaks in. And anyways, enough of my editorializing.<br>这已经成为越来越多的心碎和错误的原因，没有人能比语言的任何其他部分更理解。由于某些奇怪的原因，他们一直保持着它的生命力，甚至进入Java和所有其他语言，这些语言修复了许多最糟糕的部分，海洋中最危险的部分。但不知何故，他们保留了这个功能。所以作为建议，作为一名程序员，如果你曾经故意希望它从一个案例转到另一个案例，你应该在那里添加一条评论说，相信我，我真的希望它失败。我知道你几乎从不想这样做，但我确实听说了。所以这是一个相当普遍的惯例。我不知道我有多少次因为我忘记放休息时间而出现错误。无论如何，我的社论已经足够了。</p><p>发言人   52:30<br>The other feature you see in C is you can sort of a bunch of multiple cases. If you think of it, that’s just a special case of the fall through. The case 5 has nothing to do but to fall through to 6. So that’s the same general way. And that’s not bad, and it doesn’t require a comment. And the other one is that there’s a default. So if none of these cases match either because x was 0 or smaller, or x was a really big number, or in this case, if x were 4, there’s no matching case. And of course, you also know that these cases don’t have to be in any particular order either.<br>你在C中看到的另一个特点是你可以处理一堆多个案例。如果你考虑一下，那只是秋季的一个特例。情况5无关，只能跌到6。所以这是相同的一般方式。这还不错，也不需要评论。另一个是有一个默认。因此，如果这些情况都不匹配，因为x是0或更小，或者x是一个非常大的数字，或者在这种情况下，如果x是4，就没有匹配的情况。当然，你也知道，这些案件也不必按照任何特定的顺序。</p><p>发言人   53:12<br>So that’s all the sort of features of a case statement, a switch statement.<br>这就是case语句，switch语句的所有功能。</p><p>发言人   53:21<br>So normally, if you write this in, sort of if you were told thou shalt not use switch statements anymore, what you’d probably do is write this big long chain of if else, if else, if else, right? And you’d expect that to be the machine code, but it’s not. And so let me show you what the machine code does. And it’s kind of a long story. So think of the general form of it as being some blocks of code. The entry points of which are labeled by these case values and then the box string together in various different ways and do various things.<br>所以通常情况下，如果你写这个，有点如果你被告知不能再使用switch语句了，你可能会写这个长链的if else，if else，if else，对吧？你会认为那是机器码，但事实并非如此。让我向您展示机器代码的作用。这是一个很长的故事。所以把它的一般形式想象成一些代码块。其入口点由这些case值标记，然后框以各种不同的方式串在一起并执行各种操作。</p><p>发言人   54:05<br>What I’m going to do is compile a code for all of those blocks and store them away in some part of memory, load up memory to contain these code blocks. And then I’m going to build a table. And each entry of this table describes the starting location of one of these code blocks. And I’ll put them in order of my case labels.<br>我要做的是编译所有这些代码块的代码，并将它们存储在内存的某个部分，加载内存以包含这些代码块。然后我将建立一个表。此表的每个条目都描述了其中一个代码块的起始位置。我会把它们按照我的案例标签的顺序排列。</p><p>发言人   54:32<br>If I have, I want to span a scope from, well, let’s assume zero, but typically that’s not the case, 0 up to n -1. I’ll have this table will have that many entries of addresses to tell me where these code blocks are located. And then I’m going to use this really cool instruction, which is sort of like it’s as if you, it’s like array indexing. So if you think of array indexing, it means you can grab a value out of the middle of some array, some set of values, without having to step through them one by one. And it’s the same idea here that I will take my value and use that to figure out directly where I should jump to a block of code without having to step through a bunch of other conditions. And you can see the efficiency you gain from that. It’s the difference between sort of in one step, knowing exactly where you want it to be versus stepping through on average and over two conditions to get to where I want to go.<br>如果我有，我想跨度一个范围，好吧，让我们假设零，但通常情况下不是这样，从0到n -1。我将让这张表有那么多地址条目，以告诉我这些代码块的位置。然后我将使用这个非常酷的指令，就好像你一样，就像数组索引一样。因此，如果您考虑数组索引，这意味着您可以从一些数组的中间获取一个值，而无需逐一遍历它们。这里的想法是一样的，我将利用我的价值并使用它来直接找出我应该跳转到代码块的位置，而不必通过一堆其他条件。你可以看到你从中获得的效率。这就是在一步中确切地知道你想要它在哪里与平均通过两个条件来达到我想要去的地方之间的区别。</p><p>发言人   55:57<br>So let’s look at this at the assembly code level. And it’s a little bit a long thing because we have to build some machinery around this.<br>让我们在汇编代码级别看一下这个。这有点长，因为我们必须围绕它建造一些机器。</p><p>发言人   56:10<br>So here’s my example. I’ve got three arguments. So just remember I told you RDI and RSI for the first two arguments. The third argument is in RDX, and here’s the beginning of the switch code. It’s just making a copy of argument Z here for some reason. And then it’s looking at comparing x to 6. And y is 6 an important number because you see 6 was the largest value of any of my cases. And now it’s using a jump instruction to go to La. What we’ll find is that tells you what the default behavior should be. So it’s sort of flushing away the default cases, the cases that are either x is too small or x is too large.<br>这是我的例子。我有三个论点。所以只记得我告诉你前两个参数的RDI和RSI。第三个参数在RDX中，这是开关代码的开始。出于某种原因，它只是在复制论点Z。然后它会比较x和6。y是一个重要的数字，因为你会发现6是我所有情况中的最大值。现在它正在使用跳转指令转到La。我们将发现的是，它告诉您默认行为应该是什么。因此，它有点冲走默认情况，即x太小或x太大的情况。</p><p>发言人   57:10<br>And I should mention, there’s a clever trick there. If you look at j means jump above, that’s the unsigned comparison. And what it’s making use of is our result that you remember that if a number is negative, if you think of it as an unsigned value, it becomes very large positive value. So by doing the ja, instead of AJG jump greater than I’m doing jump above, it’s saying I want to jump to the default if either. X is greater than 6, but also it will cause it to jump if x is less than 0, got it? So it’s a clever trick of unsigned versus signed numbers it’s taking advantage of.<br>我应该提到，这里有一个聪明的把戏。如果你看一下j意味着跳跃以上，那就是无符号比较。它所利用的是我们的结果，你记得如果一个数字是负数，如果你把它看作是无符号值，它就会变成非常大的正值。所以通过做ja，而不是AJG跳跃大于我做的跳跃上方，它说我想跳转到默认值。X大于6，但如果x小于0，它也会导致它跳跃，明白了吗？所以这是一个巧妙的无符号数字与有符号数字的技巧，它正在利用。</p><p>发言人   58:08<br>And then the final part is this is the real heart of the work. This is my very special go to instruction that letsie index into a table and extract out of that an address and then jump to that address. So that’s what letsat go directly to some block of code based on whether my values, we’ll see will be in the range between 0 and 6. So there’ll be 7 entries in that table.<br>最后一部分是这是工作的真正核心。这是我非常特别的指令，letsie索引到一个表中，从中提取一个地址，然后跳转到该地址。所以这就是让他根据我的值是否在0到6之间直接转到某个代码块的原因。因此，该表中会有7个条目。</p><p>发言人   58:48<br>One thing just to keep track of for later, you’ll see that for some reason GCC said, you know, if I look at all the code, I actually don’t use w as initialized very much. So I won’t bother doing it until somewhere within the code blocks. So just we’ll have to keep track of that here. So this is the magic construction. And now if we look, and this is all assembly code. You’ll see this is the actual jump table, and it’s constructed. It’s specified in assembly code, and it’s the job of the assembly to actually fill in the contents of this table.<br>有一件事需要稍后跟踪，你会发现由于某种原因，GCC说，你知道，如果我查看所有代码，我实际上并不经常使用初始化的w。所以我不会费心去做，直到代码块内的某个地方。所以我们必须在这里跟踪它。这就是神奇的建筑。现在，如果我们查看，这都是汇编代码。你会看到这是实际的跳跃表，它已经构建好了。它在程序集代码中指定，程序集的工作是实际填充此表的内容。</p><p>发言人   59:34<br>Me, but what the assembly code is telling the assembly where is I need a quad is just a declaration to say I need an 8 B value here. And that value should match whatever address you decide you wait or determine is the address of where I’m going to stick, label 8 and all these other ones. And these are in the order, as I mentioned, from x equals 0 through 6. And we can already see a few cases that are interesting here. Let me see if I’ve got a picture of this.<br>但是汇编代码告诉汇编在哪里我需要一个quad只是一个声明，说我在这里需要一个8 B的值。并且该值应该与您决定的任何地址匹配，您等待或确定的是我要粘贴的地址，标签8和所有其他地址。这些顺序，就像我提到的，从x等于0到6。我们已经可以看到一些有趣的案例了。让我看看我是否有这张照片。</p><p>发言人   01:00:16<br>Yeah? So we can actually already see some of the logic of this switch statement built into the ordering of entries in this table. So in particular, there is no case 0 here. So case 0 should be the default. There is no case 4 here, so case 4 should be the default. And it turns out, and we already saw before the Ja instruction going to L 8. So L 8 is actually where the code block is going to be for the default case. So you see, basically, you can think of this as sometimes having holes in your switch statement. And we’re going to just fill in those holes by saying those should go to the default case.<br>是吗？因此，我们实际上已经可以看到此表中条目的排序内置了此switch语句的一些逻辑。特别地，这里没有案例0。因此，案例0应该是默认值。这里没有案例4，因此案例4应该是默认值。结果证明，在Ja指令转到L 8之前，我们已经看到了。因此，L 8实际上是默认情况下代码块的位置。所以你看，基本上，你可以把这看作是在你的switch语句中有时会有漏洞。我们将通过说那些应该进入默认情况来填补这些漏洞。</p><p>发言人   01:01:07<br>And here you’ll notice that they’re not put in any particularly logical order. One thing you’ll see again is. L 7 is repeated twice here because it covers both cases 5 and 6. So again, you’ll see this sort of doubling up is handled automatically by the jump table, will give you the same address for multiple different cases.<br>在这里，你会注意到它们没有按照任何特别的逻辑顺序排列。你会再次看到的一件事是。L 7在这里重复两次，因为它涵盖了5和6两种情况。所以，你会再次看到这种加倍是由跳转表自动处理的，会在多个不同的情况下为您提供相同的地址。</p><p>发言人   01:01:42<br>OK, and now the rest of it is to look at the various code block. And this, by the way I’m showing you, I took a file, extracted little bits of it. But normally you’re looking at this whole listing in one big order. So now we can look at the individual Jo code box and see what’s going on. And you’ll see, for example, case one told me to multiply two numbers.<br>好的，现在剩下的就是查看各个代码块了。顺便说一下，我给你们看的是，我拿了一个文件，提取了其中的一小部分。但通常情况下，您会以一个大的顺序查看整个列表。所以现在我们可以查看单个jocode框，看看发生了什么。你会看到，例如案例一告诉我要将两个数字相乘。</p><p>发言人   01:02:06<br>And you’ll see that the break in general, it’s just going to be turned into return instructions here because my function, let’s go, sorry to jump in code. You see this function did a switch statement and then whatever, whatever gets computed within the switch statement gets returned as a result of this. So the compiler doesn’t actually come to a single point and say, okay, everyone return at this point. It just sticks, returns directly in wherever these breaks occur.<br>你会看到一般的中断，它只会在这里变成返回指令，因为我的函数，让我们开始吧，抱歉跳进代码。你会看到这个函数执行了一个switch语句，然后无论在switch语句中计算出什么，都将返回结果。所以编译器实际上并没有到达一个点，并说，好的，每个人都回到了这一点。它只是粘住，直接返回到这些中断发生的地方。</p><p>发言人   01:02:46<br>So here does it multiply and a return? Here you say? Actually, yeah, curious, by the way.<br>那么它在这里是乘法和回归吗？你在说什么？实际上，是的，顺便说一下，很好奇。</p><p>发言人   01:02:54<br>I’m always somewhat surprised by what the compiler does. It’s never exactly what you’d expect in particular. It patched together this fall through case by two blocks of code. And it had to do these separately because remember, w was not set before I entered these code blocks. It deferred setting that. And here I hit case 3. And all of a sudden, I actually need whatever w was, which was one. And so I guess the compiler said, well, gosh, I guess I better set w to one here before we continue. So as a result, it sort of creates two code blocks, but it jumps from the second one, this block, into partway through this other block.<br>我总是对编译器所做的事情感到有些惊讶。这从来都不是你特别期望的。它用两个代码块修补了这个秋天的案例。并且它必须单独执行这些操作，因为记住，在我进入这些代码块之前没有设置w。它推迟了设置。这里我碰到了第三种情况。突然间，我真的需要任何东西，那就是一个。所以我猜编译器说，好吧，天哪，我想我最好在这里设置w，然后再继续。因此，它创建了两个代码块，但它从第二个代码块跳到另一个代码块的半部。</p><p>发言人   01:03:55<br>Here’s some actual, yeah, so here’s the actual code. This is the block that does the division. It’s very quick how you have to write division, it’s covered in the book, I won’t go through it here. And then this jump L 6 is what I say go to merge, and the merge is where you’re bringing these two cases together. Here is where it’s setting L to one. Again, it’s making use of this feature and that the upper 32 b get set to 0. So I can use a move L instruction here question.<br>这是一些实际的，是的，这是实际的代码。这是执行分割的块。如何写除法很简单，这本书已经涵盖了，我不会在这里讲述。然后这个跳跃L 6就是我说的去合并，合并就是你将这两种情况结合在一起的地方。这就是将L设置为1的地方。再次强调，它正在利用这个功能，并且上面的32 b被设置为0。所以我可以在这里使用移动指令问题。</p><p>发言人   01:04:37<br>Did not have the code? For what? No, the jump table is sort of embedded. Let me just show you real quick. No, probably bad idea. If you look at the S file, the assembly code file, all this stuff I’m showing you out of that, But it’s all in there. And so the compiler generated these tables, at least the sort of framework for these tables, the details of which get filled in by the assembler. So it is generated by the compiler.<br>没有代码吗？为什么？不，跳台有点像嵌入式的。让我快速地展示给你看。不，可能是个坏主意。如果你看一下S文件、汇编代码文件，以及我向你展示的所有这些东西，但它们都在那里。因此，编译器生成了这些表格，至少是这些表格的框架类型，其详细信息由汇编器填写。所以它是由编译器生成的。</p><p>发言人   01:05:21<br>So that just shows you this one example of handling a particular way to handle the fall through case. And then the remaining ones, again, you’ll see here, if I get to this case, I need the fact that w is initialized to one. So we’ll do so here. In the default case, it just ass 2 to W, and so that’s all it does. So anyways I’ve actually shown you all the code block, but I’ve shown you 1 by one, but they’re just all kind of strong in the file and in no particular order. It doesn’t matter what order they are.<br>所以这只是向您展示了一个处理秋季案例的特定方法的示例。然后剩下的，你会在这里看到，如果我得到这种情况，我需要一个事实，即w被初始化为1。所以我们将在这里这样做。在默认情况下，它只是从2到W，这就是它所做的一切。所以无论如何，我实际上已经向您展示了所有代码块，但我已经逐一向您展示了，但它们在文件中都是强大的，没有特定的顺序。它们的顺序并不重要。</p><p>发言人   01:06:06<br>So that was the reason for that jump above at the beginning. So this jump above L was the way that if x was either less than zero or greater than 6, it would go to the default case. And it will only do this indexing trick.<br>这就是一开始跳跃的原因。所以这个高于L的跳跃是这样的，如果x小于零或大于6，它将进入默认情况。它只会做这个索引技巧。</p><p>发言人   01:06:33<br>If x is between 0 and 6, and that’s typically the way this works, that you’ll see that whatever range of values you give, it has to figure out the smallest and the largest one. So it goes to the default case if it’s out of that range, and then set up a table for the values within that range question. But if the value, it’s range of values is like some negative number to, yeah, something else, does it try to like, does it index into it without x somehow? Or so?<br>如果x在0到6之间，这通常是这样工作的，那么你会看到无论你给出的值的范围是什么，它都必须找出最小值和最大值。因此，如果超出该范围，它将转到默认情况，然后为该范围内的值问题设置一个表格。但是如果这个值，它的值范围就像一个负数，是的，别的东西，它是否尝试喜欢，它是否以某种方式在没有x的情况下进行索引？还是这样？</p><p>发言人   01:07:03<br>The question I realize I should be repeating questions. The question is, what if it’s a negative number for your case, which is perfectly legal? It will typically add a bias to it effectively so that whatever your lowest value was become zero, or it’ll do something like that to avoid having to do negative indexing.<br>我意识到我应该重复问题。问题是，如果对于你的情况是一个负数，这是完全合法的，怎么办？它通常会有效地添加偏差，使您的最低值变为零，或者它会做类似的事情，以避免进行负索引。</p><p>发言人   01:07:25<br>Another question I see. But for cases, you can put, yeah, so you can go from 0 to 1 million. Yeah, and they could be, you could go zero in a million and nothing in between, right? So you could have two cases. You really don’t want a million entry table for just two cases, so it will turn it into if elses code. But the clever thing it will do, if you know binary search, it relies on the fact that it knows in advance all the values and it will actually set up a tree of if Fels is. So really it will do it. If you want to think algorithmically, it does it with a logarithmic number of tests rather than a linear number of tests question.<br>我看到了另一个问题。但是对于情况，你可以放置，是的，所以你可以从0到100万。是的，它们可能是，你可以在一百万中达到零，在这之间什么都没有，对吗？所以你可以有两个案例。你真的不希望在只有两种情况下使用一百万个条目表，所以它会将其转换为if elses代码。但是聪明的是，如果你知道二分查找，它依赖于这样一个事实，即它事先知道所有的值，它实际上会建立一个if Fels树。所以它真的会做到。如果你想从算法上思考，它会使用对数数量的测试而不是线性数量的测试问题来完成。</p><p>发言人   01:08:20<br>Oh, yes, yes. So there’s two answers. That one is which I’ve actually answered both. Now, if one is, what if there’s some negative values? Or what if the lowest number is 5700, right? Well, what it will typically do is put some bias, add or subtract some value so that the first case is at value 0. So that’s where it handles ones that are just completely out of range. And the other is, what if it’s a really big spread of values and relatively sparse, how much you’re using it? And there it will revert to if elses code and the compiler has its own rules about how it does these things, you can sort of run experiments and try and reverse engineer it.<br>哦，是的，是的。所以有两个答案。那个问题我两个都回答过了。现在，如果有一个是，如果有一些负值怎么办？如果最小的数字是5700，对吧？嗯，它通常会做的是放置一些偏差，添加或减去一些值，使第一种情况的值为0。所以这就是它处理那些完全超出范围的问题的地方。另一个问题是，如果它是一个非常广泛的值并且相对稀疏，你用了多少？在那里，如果其他代码和编译器有自己的规则来处理这些事情，你可以运行实验并尝试反向工程。</p><p>发言人   01:09:08<br>These are all valid questions, by the way. I appreciate them.<br>这些都是有效的问题，顺便说一下。我很感激他们。</p><p>发言人   01:09:16<br>Okay, so we’re going to get through this. So anyways, like I said. I think in my own experience, you understanding the conditionals, you can kind of figure that out. It’s intuitive, sort of feels like what you’d expect a program to do, whereas the switch statement is maybe unexpected. It’s a way to do something that is. Not totally obvious, but then when you think about it and appreciate it, it actually gives you a good performance boost.<br>好的，我们将度过这个过程。不管怎样，就像我说的。我认为在我自己的经验中，如果你理解了条件语句，你就可以把它弄明白。它很直观，有点像你期望程序做的事情，而switch语句可能是意想不到的。这是做某事的一种方式。这并不完全明显，但是当你思考并欣赏它时，它实际上会给你一个很好的性能提升。</p><p>发言人   01:09:59<br>Again, algorithmically, this jump table makes it so it’s a constant time, constant number of steps to get to where you need to in the switch statement. If you just did it linearly one after the other, then that would be linear time. And you’d expect if everything’s uniform and average, it would be about halfway through on average. If it’s sparse, you’ll see it will be set up a tree of conditionals. So it can do in logarithmic time. So no matter what, it will be better than just what you would get in the obvious form of if else I saw a question over here.<br>同样，从算法上讲，这个跳转表使它成为一个恒定的时间，恒定的步数，以到达您在switch语句中需要的位置。如果你一个接一个线性地做，那就是线性时间。你会期望，如果一切都是均匀和平均的，平均来说，它大约已经过了一半。如果它是稀疏的，你会看到它将被设置一个条件树。所以它可以在对数时间内完成。所以无论如何，它都会比你明显得到的更好，比如我在这里看到了一个问题。</p><p>发言人   01:10:42<br>Well, the good news is I don’t set up the jump tree. The compiler sets up the jump tree. But if you’re asking if I were a compiler, how would I set up the jump tree, which is a good question.<br>好消息是我没有设置跳跃树。编译器设置跳转树。但是如果你问我如果我是编译器，我将如何设置跳转树，这是一个好问题。</p><p>发言人   01:10:56<br>If you know binary search, that you’ve got a range of values and you pick, you compare it to the middle value, and it’s either less or it’s greater or equal. And if it’s less, then you sort of recursively handle one set. And if it’s greater than the other, that’s exactly what these trees look like. So they’re balanced binary trees, and they’re taking advantage of the fact that in C, which is not true in all languages, that all the case conditions you’re looking at are constants. They’re determined when the compiler is doing the compilation. Those are constant values. So it can sort figure out how many there are, what range of values there are, decide which version to do the, and generate the code.<br>如果你知道二分搜索，你有一个范围的值，你可以选择，你可以将其与中间值进行比较，它要么是更少，要么是更大或相等。如果它更少，那么你可以递归地处理一组。如果它比另一个大，那就是这些树的样子。所以它们是平衡二叉树，并且它们利用了一个事实，即在C中，并非在所有语言中都如此，你正在查看的所有情况条件都是常量。它们是在编译器进行编译时确定的。这些是恒定值。因此它可以排序找出有多少，有什么范围的值，决定执行哪个版本，并生成代码。</p><p>发言人   01:11:42<br>Other questions? So these are all good. These are very good questions. And you’re starting to think about which is the way that computer scientists should think is how do you take some idea? I’ve seen one case of, well, how do I handle condition X and condition y, and what happens if this? That’s exactly what we do. We’re never happy with a simple explanation. We want to understand how we could actually implement it as a program if we ever had to do so. And so?<br>其他问题？所以这些都很好。这些问题非常好。你开始思考计算机科学家应该如何思考，你如何理解一些想法？我见过这样的情况，那么，如何处理条件X和条件y，如果这样会发生什么？这正是我们所做的。我们从不满足于一个简单的解释。我们想了解如果我们必须这样做，我们如何将其作为一个程序实际实现。所以呢？</p><p>发言人   01:12:22<br>Just in general, the main thing you see is that there’s a fairly limited bag of tricks for which the program implements conditional constructs. Basically three. One is to use conditional jumps, go to different parts of the code, another to use conditional moves, and the third is to use this jump table idea. And those are really that plus a little bit to do procedures is sort of all there is. And all the other stuff you see in a program that sort of changes the flow of execution or what gets executed are built out of those basic primitives. And that’s generally true that what we see is when you go from C code to machine code, you often have to kind of piece together various low level instructions to implement some higher level construct. And so we’ve seen these all in different forms now. And next time, then we’ll talk about procedures.<br>总的来说，你看到的主要事情是，程序实现条件构造的技巧相当有限。基本上有三个。一个是使用条件跳转，转到代码的不同部分，另一个是使用条件移动，第三个是使用这个跳转表的想法。那些真的加上一点点要做的程序就是所有的东西。你在程序中看到的所有其他改变执行流程或执行内容的东西都是由这些基本原语构建的。这通常是正确的，我们看到的是当你从C代码转到机器码时，你经常需要把各种低级指令拼凑起来，以实现一些更高级别的构造。所以我们现在已经以不同的形式看到了这些。下次，我们会谈论程序。</p><p>发言人   01:13:34<br>As you can imagine, a fairly major topic because it is worth one entire procedure. Okay, very good, thank you.<br>正如你所想象的那样，这是一个相当重要的话题，因为它值得一整个过程。好的，很好，谢谢。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深入理解计算机系统 005-Machine-Level Programming I, Basic</title>
    <link href="/2025/10/12/15213-005/"/>
    <url>/2025/10/12/15213-005/</url>
    
    <content type="html"><![CDATA[<p>发言人   00:01<br>Good afternoon, everyone. So now we’re going to jump into the part of the course that I’d call the real core of the course where we go into machine level programming.<br>大家下午好。所以现在我们将进入我称之为课程真正核心的部分，我们将进入机器级别编程。</p><span id="more"></span><p>发言人   00:14<br>And by the term machine level programming, I mean when you’re actually considering the individual instructions to get executed by the machine in response to your program. And there’s really two forms of machine programs. One is the actual object code that runs on the computer. And as we’ll see, that’s a series of bytes that encode instructions that the processor executes. But because it’s hard to look at bytes and understand them, there’s various text forms to make it more clear. And one of those is assembly code that it used to be. That’s how people program machines. And nowadays, it’s what the target of a compiler is, is to generate assembly code. And I’ll use those terms.<br>所谓机器级编程，是指当你实际考虑由机器执行的各个指令来响应你的程序时。实际上，机器程序有两种形式。一个是在计算机上运行的实际目标代码。正如我们将看到的，这是一系列对处理器执行的指令进行编码的字节。但是因为很难查看字节并理解它们，所以有各种文本形式可以使其更清晰。其中之一就是以前的汇编代码。这就是人们对机器编程的方式。而现在，编译器的目标是生成汇编代码。我会使用这些术语。</p><p>发言人   01:02<br>When I say machine code, I sort of interchangeably mean object code, the binary form or assembly code, the text version of it interchangeably, because there really is a one to one mapping between them. But in case I sort of use a term like assembly code, instead of consistently saying machine code, it’s because they’re really the same general idea. So this is sort of one place where this course, 213, 5, 13, takes a particular perspective that’s very different from done elsewhere.<br>当我说机器码时，我的意思是对象代码，二进制形式或汇编代码，它的文本版本可以互换，因为它们之间确实存在一对一的映射。但如果我使用汇编代码这样的术语，而不是一致地说机器代码，那是因为它们实际上是相同的一般思想。所以这是一个地方，这门课程213、5、13采取了与其他地方非常不同的特定观点。</p><p>发言人   01:39<br>In the bad old days of computing, you would be required to take a course. It was typically called assembly level programming. The way you actually learn to write programs in assembler, and your assignments would be to do things like to sort an array of numbers, or you set up some kind of linked list data structure, just sort of low level of programming that nowadays you wouldn’t even think of wanting to write an assembly code. And so people didn’t really enjoy those courses very well. And so they got sort of largely cut out of the curriculum.<br>在计算机行业糟糕的旧时代，你将被要求参加一门课程。它通常被称为汇编级编程。你实际上学习用汇编程序编写程序的方式，以及你的任务是做一些事情，比如对数字数组进行排序，或者你设置某种链表数据结构，只是一种低级别的编程，现在你甚至不会想写汇编代码。所以人们并没有真正喜欢这些课程。因此，他们基本上被课程所淘汰。</p><p>发言人   02:15<br>But what our version of it is, this is pretty important stuff to know as a sort of gateway between what, how you write your program, say, and see or any other language and how those programs actually execute on a machine. So machine code is sort of the intermediate form there, the intermediate language. And you need to understand that to understand better what your programs are trying to do and what the machine is trying to do. As a result of that, our perspective will be we won’t actually write except in very, very small amounts.<br>但是我们的版本是什么，这是非常重要的东西，作为一种网关，在什么，如何编写你的程序之间，比如说，看到或任何其他语言，以及这些程序如何在机器上实际执行。所以机器代码是一种中间形式，中间语言。你需要理解这一点，以便更好地理解你的程序试图做什么以及机器试图做什么。因此，我们的观点将是，除了非常小的数量外，我们实际上不会写。</p><p>发言人   02:53<br>We’re not going to actually sit down and write assembly programs in this course. But what you’ll do is you’re going to look at a lot of code that was generated by AC compiler, GCC, and try to see how does that, what came out of that compiler relate to what went into it? How does this low level of code implement the higher level constructs that I was trying to express my program in, how our procedures functions implemented in machine language? How are data structures such as arrays and structs? How are those implemented in machine code? So we’re going to learn all of that stuff. And it takes a significant chunk of this course and a fair number of lectures to get through all that material because it’s really quite a bit. But I think, like I said, I think this is sort of the core where this course is.<br>在这门课程中，我们不会真正坐下来写汇编程序。但是你要做的是查看很多由交流编译器GCC生成的代码，并尝试看看编译器产生的内容与其中的内容有何关联？这种低级别的代码如何实现我试图表达我的程序的高级结构，我们的过程如何用机器语言实现？像数组和结构这样的数据结构是怎样的？这些在机器码中是如何实现的？所以我们将学习所有这些东西。这门课程需要相当大的一部分内容和相当数量的讲座才能通过所有这些材料，因为它真的相当多。但我认为，就像我说的，我认为这是这门课程的核心。</p><p>发言人   03:53<br>And as you know, in this course, we only look at one particular class of machines, even though there’s many more different machine level programming possibilities out there. And we’ve chosen the Intel, the 64 b version of the Intel instruction set. So I’ll go through a little bit of the history behind Intel and how it got to where it is. We’ll look at sort of this idea of how does C code relate to assembly code, machine code, and so forth. We’ll go through senator, the low level basics that you need to understand of what assembly machine code looks like. And then we’ll actually take on and look at some real code focusing specifically on arithmetic operations.<br>正如你所知，在本课程中，我们只关注一类特定的机器，尽管还有许多不同的机器级别编程可能性。我们选择了英特尔，即英特尔指令集的64 b版本。所以我将介绍一下英特尔背后的历史以及它是如何发展到现在的。我们将会探讨C代码如何与汇编代码、机器码等相关的概念。我们将通过参议员，了解您需要了解的汇编机器代码的低级基础知识。然后我们将实际处理并查看一些专门关注算术运算的真实代码。</p><p>发言人   04:43<br>So x 86 is a sort of colloquial term for Intel processors. And the reason is the first one was called the 8086. And then they kind of skipped 81. But then they went to 82, 86 and 83, 86. So the one thing in common was 86. And so people just call it x 86.<br>所以x86是一种英特尔处理器的口语术语。原因是第一个被称为8086。然后他们跳过了81。但随后他们又去了82、86和83、86。所以唯一的共同点是86。所以人们就叫它x86。</p><p>发言人   05:08<br>And one thing that’s important to this, and it will have influence on what the programs look like, is x 86 is a language like English that it’s been an accrual, an evolution of different features layered on top of each other and not always the most elegant way. So just like English, there’s all these sort of quirky things. How you write it is very different from how you pronounce it, and there’s all these irregular cases. And it doesn’t make sense. It’s not sort of a purpose designed language. It’s the same with x 86, a language that just got there because of a bunch of decisions that locally were probably the right thing to do, but globally were not. There’s other instruction sets that are much cleaner and easier to understand, but we figure it’s just the same. The reason that you learn English instead of learning Esperanto or something like that, that it’s a much more useful language.<br>有一件很重要的事情，它将影响程序的外观，那就是x86是一种像英语一样的语言，它是一种权责发生制，是不同功能层层叠加的演变，并不总是最优雅的方式。所以就像英语一样，有很多古怪的东西。你写它的方式与你发音的方式非常不同，而且有许多不规则的情况。这并没有产生感知。这不是一种目的设计的语言。X86也是如此，这是一种语言，它是由于一系列决定才到达那里的，这些决定在本地可能是正确的事情，但在全球范围内则不是。还有其他更清晰、更容易理解的指令集，但我们认为它们都是一样的。你学习英语而不是学习英语或类似的东西，是因为它是一种更有用的语言。</p><p>发言人   06:09<br>X 86 is what sometimes was called a sysc. There is a big thing in the early 80s, 80s in general called risk vs, well, risks was a relatively new idea, what they called a reduced instruction set computer. And it was all the rage and nobody had a name for what came before. But the risk people named what came before a cysk for a complex instruction set computer with the obvious sort of pejorative nature to that title.<br>X86有时被称为sysc。在80年代早期，有一件大事，一般被称为风险与风险，风险是一个相对较新的概念，他们称之为精简指令集计算机。它风靡一时，没有人知道之前发生的事情的名称。但是风险人士将cysk命名为复杂指令集计算机之前的名称，该名称具有明显的贬义性质。</p><p>发言人   06:42<br>And so Intel is sort of the classic Syk architecture, meaning it has a ton of features. We’re not going to even scratch the surface if you want. The manual for it is two big fat books, which nowadays you do with PDF documents, but it’s still a huge amount of stuff and some 500 or more instructions, everything from doing decimal arithmetic to even decimal floating point and all kinds of goofy stuff in there. But it turns out that you can kind of get a pretty good handle on it by focusing more on just what does the code look like that GCC is generating for the kind of programs that you typically write. And you should also realize that at many levels. This should not have been the successful design because as I said, it’s just got lots of stuff on there. But Intel has been such a powerful company and had so much market and better technology as far as semiconductors than its competitors. But it’s been able to kind of keep this thing alive for almost 40 years.<br>因此，英特尔有点像经典的Syk架构，这意味着它有吨功能。如果你愿意，我们甚至不会去抓表面。它的手册是两本又大又胖的书，现在你可以用pdf文件来完成，但它仍然是大量的东西和大约500条或更多的指令，从十进制算术到十进制浮点以及各种愚蠢的东西。但是事实证明，通过更多地关注GCC为您通常编写的程序生成的代码看起来是什么样子，您可以相当好地处理它。你也应该认识到，在许多层面上。这不应该是成功的设计，因为正如我所说，它只是有很多东西在那里。但英特尔一直是一家强大的公司，在半导体方面拥有比竞争对手更多的市场和更好的技术。但它已经能够让这个东西存活近40年了。</p><p>发言人   08:00<br>This is pretty admirable. So just to give you a sort of time scale, as I mentioned, 8086 was the first one of the first single chip 16 b microprocessors came out in 78. And slight variation on it was the basis for the original IBM PC, which I know Preds, most of you your lives, but it was sort of the big breakthrough that put computers on the desktops of many people. And there’s been many, many generations.<br>这相当令人钦佩。所以只是为了给你一个时间尺度，正如我所提到的，8086是第一批单芯片16 B微处理器中的第一个，出现在78年。它的微小变化是最初的IBM PC的基础，我知道它会影响你们大多数人的生活，但这是一项重大突破，将计算机放在许多人的桌面上。而且已经有很多很多代人了。</p><p>发言人   08:37<br>I’m just giving you the highlights that are relevant to this particular class, the 386, which dates back to 1985, was the one that really made the transition from these being personal computers that could run not very interesting applications to ones that could actually run something like a Unix or Linux machine. And the reason is they extended it to 32 b and they removed some of the weird addressing stuff that used to be in there.<br>我只是给你与这个特定类别相关的亮点，可以追溯到1985年的386，真正实现了从可以运行不太有趣的应用程序的个人计算机到可以实际运行Unix或Linux机器的过渡。原因是他们将其扩展到32 b，并删除了一些曾经存在的奇怪寻址内容。</p><p>发言人   09:07<br>So these look like sort of a generic processor and that was queer back in 85 and that was what’s sometimes called IA 32. Intel Architecture 32, which was the dominant way of code up till just even a few years ago. So even up recently as this past summer, this course was teaching IA 32. And then, and I’ll talk about it more later, reason and a strange story behind the extension from 32 to 64 b, which kind of was sneaked in by Intel in an odd model, the Pentium 4 e. But you see, it was only about 10 years ago. And one of the smart things they did with that is that the machines that can run the 64 b code can also run 32 b code. So they were able to sort of bring out all these machines without everybody having to change over their software. And it’s taken about that amount of time for the software to largely transition away from 32 b code to 64 b code.<br>所以这些看起来有点像一个通用处理器，在85年很奇怪，这就是有时被称为IA 32的东西。英特尔架构32，这是直到几年前还是占主导地位的代码方式。所以即使最近像去年夏天，这门课程的教学水平也是32。然后，我稍后会更多地谈论它，从32扩展到64 b背后的原因和奇怪的故事，这种情况是由英特尔在一个奇怪的模型奔腾4 e中潜入的。但是你看，这只是大约10年前的事情。他们做的一个聪明的事情是，可以运行64 b代码的机器也可以运行32 b代码。因此，他们能够在不需要每个人更换软件的情况下推出所有这些机器。软件从32 b代码大部分转换到64 b代码大约花费了这么长的时间。</p><p>发言人   10:23<br>And then for actually fairly interesting reasons, you could map how fast a single processor would run. And it was climbing up at a pretty steady pace in till around 2004. And then Intel and all the companies got into serious trouble with the power consumption of their chips. They’re approaching 100 W. So imagine a 100 W light bulb and how much heat that generates inside of a box that you try to blow a fan on really hard to keep it from getting too hot. And they were reaching the point where they really couldn’t go much beyond 100 W. And so they sort of got into a power budget problem. And as a result, they haven’t been able to scale up the frequency how fast the inner clock that drives this thing is beyond just a few gigahertz since 2004.<br>然后，由于相当有趣的原因，您可以绘制单个处理器的运行速度。直到2004年左右，它一直以相当稳定的速度攀升。然后英特尔和所有公司都在芯片功耗方面陷入了严重的麻烦。它们正在接近100瓦。想象一下一个100瓦的灯泡，在一个盒子里产生多少热量，你试图用风扇吹打它，以防止它变得太热。他们已经达到了一个地步，他们真的无法超过100瓦。所以他们有点陷入了电力预算问题。因此，自2004年以来，他们一直无法将驱动这个东西的内部时钟的速度提高到超过几千兆赫的频率。</p><p>发言人   11:19<br>So what’s happened was they said, well, we can’t make any single processor faster, but we can put a bunch of processors on a single chip. And those that are referred to cores or multicore. So most of you with laptops probably have 2 cores on those. And a laptop processor and a server might have up to 16 cores. So those are independent processors that all reside on a single chip.<br>所以发生的事情是，他们说，好吧，我们无法使任何单个处理器更快，但我们可以在单个芯片上放置一堆处理器。以及那些被称为核心或多核的。所以大多数使用笔记本电脑的人可能都有两个核心。而笔记本电脑处理器和服务器可能最多有16个核心。所以这些都是独立的处理器，全部驻留在一个芯片上。</p><p>发言人   11:49<br>The shark machines date back to 2008, and they each have 4 cores on them. The shark machines, the one thing about computers haven’t really gotten that much faster in the meantime. So there’s still fairways, and they were, in their day, a very high performance machine, so they’re still pretty decent.<br>鲨鱼机器可以追溯到2008年，它们每个都有4个核心。鲨鱼机器，关于计算机的一件事并没有在此期间真正变得更快。所以还有球道，在他们的时代，他们是一台非常高性能的机器，所以他们仍然相当不错。</p><p>发言人   12:15<br>This shows a picture of the chip that makes up AI think, the shark machines or approximately that same era. And you’ll see that as the picture shows, there’s 4 cores are integrated onto one chip. And then down at the bottom is what they call a cache. And we’ll learn a lot about cache memory. It’s basically a temporary memory used to hold the most recently accessed data so that you can get to it more quickly. And you’ll see that that shared across the 4 cores. So if you look at the latest, if you were to go off shopping in the catalog, the latest instance, and I don’t have any chip pictures of it, is a model they call the Broadwell model. And you’ll see that on a single chip, they have multiple cores, 4 for a serious standard desktop model, 8 for a server request machine.<br>这张照片展示了构成人工智能思维的芯片，即鲨鱼机器或大致相同的时代。你会发现，如图所示，一个芯片上集成了4个内核。然后在底部是他们所谓的缓存。我们将会学到很多关于缓存的知识。它基本上是一个临时内存，用于保存最近访问的数据，以便您可以更快地访问它。你会看到这是在4个核心之间共享的。所以，如果你看看最新的，如果你要在目录中购物，最新的实例，我没有任何芯片图片，是一个他们称之为布罗威尔模型的模型。你会看到在一个芯片上，它们有多个核心，4个用于严格的标准桌面模型，8个用于服务器请求机器。</p><p>发言人   13:17<br>And then built around the perimeter, there are various connections to the rest of the world. So DDR is the way you connect to the main memory, what’s called DRAM dynamic Ram. PCI is the connection to peripheral devices. SATA is a connection to different types of disks and USB, well, you know what USB is, and then the Ethernet is the connection also to a network connection. That’s all integrated onto a single chip is not just the processor itself, but a logic that glues that processor into a larger system. And one interesting thing you’ll notice is that the desktop model is a higher power, 65 W versus the server is 45 W.<br>然后围绕周边建造，与世界其他地方有各种连接。所以DDR是你连接到主存的方式，这被称为DRAM动态内存。PCI是与外围设备的连接。SATA是到不同类型的磁盘和USB的连接，你知道什么是USB，然后以太网也是到网络连接的连接。集成在单个芯片上的不仅仅是处理器本身，还有将处理器粘合到更大系统中的逻辑。你会注意到的一件有趣的事情是，台式机型号是更高的功率，65瓦，而服务器是45瓦。</p><p>发言人   14:11<br>When you put a lot of computers in a room, turns out power is the biggest issue you have to deal with.<br>当你把很多电脑放在一个房间里时，电力是你必须处理的最大问题。</p><p>发言人   14:22<br>So Intel isn’t the only company in this game. They sort of historic competitor is a company called AMD. And AMD was always sort of number two behind Intel in just so I gave us this number two behind hers. They had a little burst in time when they. Kind of got out ahead of Intel because Intel had wasted their time on some bad ideas and they actually were the one that came up with the 64 b extension to Intel that we use. Right now though AMD is not doing very well. Intel sort of realized that it had to get its act together, and it did, and it was more or less crushed AMG. And I should mention, they had these ferocious patent suits many years ago.<br>所以英特尔并不是这个游戏中唯一的公司。他们的历史性竞争对手是一家名为AMD的公司。而AMD总是排在英特尔之后的第二位，所以我给了我们这个排在她之后的第二位。他们在时间上有点爆裂。有点领先于英特尔，因为英特尔在一些糟糕的想法上浪费时间，实际上他们提出了我们使用的英特尔64 b扩展。但现在AMD做得并不是很好。英特尔意识到它必须齐心协力，它做到了，它或多或少被压垮了。我应该提到，他们很多年前就有这些凶猛的专利诉讼。</p><p>发言人   15:19<br>And the result of that was a cross licensing deal that allows AMD to produce x 86 processors too.<br>其结果是达成了一项交叉许可协议，允许AMD也生产x86处理器。</p><p>发言人   15:27<br>Now, it’s interesting story behind Intel. In 64 b, they decided to make this radical shift to an architecture that they called the. They called IA 64 at the time, and it was based on a whole new concept that looked really good on paper and initial results looked promising. They invested a lot of money in this stuff. They formed a joint operation with Hewlett and Packard on this, and it turned out not to work. It was much too aggressive. It assumed miraculous optimization capabilities by the compiler. And so it was a, from a technically idea, it was very interesting technology, but in the marketplace, it didn’t work.<br>现在，英特尔背后的故事很有趣。在64 b中，他们决定彻底转变为一种他们称之为架构的架构。他们当时称之为IA 64，它基于一个全新的概念，在纸上看起来非常好，初步结果看起来很有希望。他们在这个东西上投入了很多钱。他们与休利特和包加德组成了一个联合行动，但结果并不奏效。这太咄咄逼人了。它假设编译器具有神奇的优化能力。因此，从技术角度来看，这是一项非常有趣的技术，但在市场上，它并不起作用。</p><p>发言人   16:12<br>And this was sort of a branch off that Intel pursued and felt obligated to keep it up because they’d invested so much in it.<br>这是一个分支，英特尔追求并感到有义务继续保持，因为他们在这方面投入了大量资金。</p><p>发言人   16:20<br>And along came AMD, and they said, well, we don’t have to do this radical shift. We’ll just sort of do the obvious thing of adding, making the registers bigger, making things go from 32 to 64 b. And they came along with that and were successful. And so Intel kind of had to just sheepishly follow behind AMD on this, but they could because of their cross licensing deal.<br>然后AMD来了，他们说，好吧，我们不必做这种彻底的转变。我们只是做一些显而易见的事情，增加寄存器，使内容从32 b增加到64 b。他们随之而来，并取得了成功。因此英特尔不得不羞怯地跟随AMD，但他们可以，因为他们的交叉许可协议。</p><p>发言人   16:47<br>So nowadays, as I mentioned, hardware wise, just about every processor that is in a laptop, in a desktop, even your cell phones of recent generation or all 64 b processors. So what we’ll talk about then, we used to teach IA 32, but that’s gone. This is the first term where we’re skipping it all together. So we’re using what we’ll call x 80 two-six hyphen 60 two-four. There’s various ways this is named, but this is sort of the Linux way of naming it. If you’re interested in i.e. 32, there’s a document on the web associated with the book called a webi side goes through at least some of the basics of it. But to really read that, you need to learn the 64 b because it assumes you kind of already know that. Okay, so let’s go in.<br>所以现在，正如我提到的，硬件方面，几乎每个处理器都在笔记本电脑、台式机、甚至你的最新一代手机或所有64 B处理器中。那么我们接下来要谈的是，我们以前教的是IA 32，但现在已经过去了。这是第一个我们一起跳过的学期。所以我们使用的是我们称之为x 80的2-6连字符60 2-4。有多种命名方式，但这是Linux命名它的一种方式。如果您对以下内容感兴趣:32，在网络上有一个与这本书相关的文档，称为webi面，它至少介绍了其中的一些基础知识。但是要真正阅读它，你需要学习64 b，因为它假设你已经知道了这一点。好的，我们进去吧。</p><p>发言人   17:42<br>And I should mention too, just for general interest, the other major class of processor and common use today are called Arm. So Arm actually is an acronym for Acorn Risk Machine. I just told you what risk means. It means risk reduced instruction set computer. An acorn means like the seed of an oak tree.<br>我也应该提到，只是为了大众的兴趣，另一类主要的处理器和今天常用的被称为Arm。所以Arm实际上是橡子风险机器的首字母缩写。我刚刚告诉你什么是风险。这意味着风险降低了指令集计算机。橡子的意思就像橡树的种子。</p><p>发言人   18:03<br>It was a British company that decided to make its own personal computers in the early days of it. And they said, we’re not going to buy those chips from Intel. We’re going to make them ourselves. So they designed and manufactured their own chips. Well, as a company, a computer manufacturer, it was a complete bust, but it turned out that they’d come up with a fairly good instruction set that was sufficiently simple that it could be put on chips, and better yet, it could be customized. So Arm is now a company of its own, headquartered in Cambridge, England, and the reason why, part of the reason they’re successful there is because it tends to be a lower power requirements than a x 86 machine because it’s simpler.<br>这是一家英国公司在早期决定制造自己的个人电脑。他们说，我们不会从英特尔购买这些芯片。我们将自己制作它们。所以他们设计并制造了自己的芯片。作为一家公司，一家计算机制造商，这是一个完全的破产，但事实证明，他们提出了一个相当好的指令集，这个指令集足够简单，可以放在芯片上，而且更好的是，它可以定制。所以Arm现在是一家自己的公司，总部位于英国剑桥，他们在那里成功的部分原因是因为它往往比x86机器低功耗，因为它更简单。</p><p>发言人   18:51<br>But the other is that they don’t actually sell processors. They sell companies the rights, the licensing rights to use their design. And so if you look at like a cell phone processor, the actual Arm processor is a little tiny part of it on the chip, and then they’ll have other stuff to make the graphics go better, to improve your phone calls and so forth. And so they’re really selling what, intellectual property as opposed to chips people, we’ve gotten various inquiries.<br>但另一个问题是他们实际上并不销售处理器。他们向公司出售使用其设计的权利和许可权。所以如果你看一个手机处理器，实际的Arm处理器只是芯片上的一小部分，然后它们会有其他的东西来使图形变得更好，改善你的电话通话等。所以他们真的在卖什么，知识产权而不是芯片人，我们已经收到了各种询问。</p><p>发言人   19:24<br>When are you going to start talking about Arm in your book or your course or something? And we go, it would be another book to write to do justice to arm, it would be like a whole redo of the thing. And we’re not inclined to do that right now. Just so you know, two worlds out there, x 86 and Arm are the dominant players right now.<br>你什么时候开始在你的书或课程中谈论手臂？我们去，这将是另一本书，以公正地对待武装，这将是对事情的整个重做。我们现在不倾向于这样做。只是让你知道，在那里有两个世界，x86和Arm是目前的主导者。</p><p>发言人   19:50<br>So let’s talk some terminology. And you’ve probably heard some of these terms before, but let’s make it clear. So when we talk about the instructions, the instruction set, that’s the target of a compiler to give you a series of instructions that tell the machine exactly what to do. But it turns out that the hardware people have figured out all kinds of clever ways to implement instructions. Some of them are really fast, but take a lot of hardware. Some are pretty slow, but don’t take much hardware at all. And so they managed to create this abstraction that’s called the abstraction set architecture, which is what the target of a compiler should be, and then what the hardware people figure out how best to implement it.<br>那么让我们来谈谈一些术语。你可能之前听过其中一些术语，但让我们把它说清楚。因此，当我们谈论指令时，指令集是编译器的目标，它会给你一系列的指令，告诉机器该做什么。但事实证明，硬件人员已经想出了各种聪明的方法来实现指令。其中一些速度非常快，但需要很多硬件。有些很慢，但根本不需要太多硬件。所以他们设法创建了这个抽象，称为抽象集体系结构，这是编译器的目标应该是什么，然后硬件人员想出如何最好地实现它。</p><p>发言人   20:37<br>And so that’s a concept, actually, that came along in the 1960s. So that’s even before my time as far as a computer person. But it’s a very important concept in the world of computers and then what they call the lower level stuff, how it actually gets implemented is called the microarchite, and we won’t talk very, very little about microarcsecond this course.<br>实际上，这是一个概念，出现在19 60年代。所以这甚至在我成为计算机人之前。但它在计算机世界中是一个非常重要的概念，然后他们称之为低级别的东西，它实际上是如何实现的被称为微石墨，我们在这门课程中不会谈论非常少的微石墨。</p><p>发言人   21:04<br>And as I mentioned, machine code is sort of a generic term that incorporates both the actual bytes that are operating, executing, as well as the assembly level version of it.<br>正如我所提到的，机器码是一种通用术语，包含了实际操作、执行的字节以及汇编级别版本。</p><p>发言人   21:19<br>And as I mentioned, you can think of from an instruction set point of view. So IA 3 2x 8664 and what’s called titanium, this not very successful Intel thing, Those are all in some ways different instruction set architectures. Arm, actually similar to Intel, has gone through various different generations. So there’s various different generations of its instruction set.<br>正如我所提到的，你可以从指令集的角度来考虑。所以，IA 3 2x8664和所谓的钛，这不是很成功的英特尔产品，它们在某些方面都是不同的指令集架构。Arm实际上类似于英特尔，经历了不同的世代。因此，它有不同代的指令集。</p><p>发言人   21:49<br>So from a machine level programmer’s perspective, things are a bit different than you see when you write C code.<br>因此，从机器级程序员的角度来看，事情与你编写C代码时看到的有些不同。</p><p>发言人   21:57<br>First of all, there is some very visible parts of the instruction, the machine state that you can examine and test and operate on. And you must, in fact, that you would never understand what those are if you’re just thinking in terms of C particular, some sort of a program counter tells you what address is the instruction that you’re going to execute next. Where is that located in memory? And then there’s a set of registers which are part of that the programmer actually makes use of. You can think of them as as a very small number of memory locations, but rather than giving an address from 0 up to n -1 or something, you actually give them by name specifically. And then there’s another sort of state that’s just a few bits worth of state that talk about what are the results of some recent instructions where they did it produce a value of 0? Did it produce a negative or a positive value? And those are used to implement conditional branching, which we’ll look at later as we go.<br>首先，指令中有一些非常可见的部分，您可以检查、测试和操作机器状态。而且事实上，如果你只是从特定的角度思考，你永远不会理解这些指令是什么，某种程序计数器会告诉你接下来要执行的指令是什么地址。它在记忆中的什么位置？然后有一组寄存器，它们是程序员实际使用的一部分。你可以把它们看作是数量非常少的内存位置，但是与其给出从0到n -1的地址，你实际上是专门给它们命名。然后还有另一种状态，它只是几位的状态，它谈论一些最近的指令产生的值为0的结果是什么？它产生了负值还是正值？这些用于实现条件分支，我们稍后会在进行中查看。</p><p>发言人   23:11<br>And then the other part of it, so that’s sort of the processor. And then the other part of it is the memory. And as I mentioned in. One of the first lectures, the memory is you can think of logically as just an array of bytes. And that’s what the machine level programmer sees. And it’s actually kind of a fiction in different ways.<br>然后是它的另一部分，那就是处理器。然后它的另一部分是记忆。正如我在中提到的。最早的讲座之一，内存是你可以从逻辑上想象为一个字节数组。这就是机器级程序员所看到的。这实际上在不同方面有点像虚构。</p><p>发言人   23:36<br>As I mentioned before, there’s sort of a collaboration between the operating system and the hardware, what they call virtual memory, to make it look like each program running on a processor has its own independent array of bytes that it can access, even though they actually share values within the physical memory itself, more the term cache, The idea of a cache is not visible here at all because it just is automatically loaded with recent stuff. And the only thing that will look different is if you re-access that memory, it will go faster than it would if it hadn’t been cached. But it’s not visible in terms of there’s no instructions to manipulate the cache. There’s no way you can directly access the cash. So you already see that it’s already abstract. It’s got some more details of real hardware, but underneath it, the sort of microarchitecture has some features built into it that you’re not operating on, you’re not making use of directly when you write machine level programs.<br>正如我之前提到的，操作系统和硬件之间有一种协作，他们称之为虚拟内存，以使处理器上运行的每个程序看起来都有自己独立的字节数组可以访问，即使它们实际上在物理内存本身内共享值。更多的术语是缓存，缓存的想法在这里根本不可见，因为它只是自动加载最近的东西。唯一看起来不同的是，如果您重新访问该内存，它会比没有缓存时运行得更快。但它是不可见的，因为没有操作缓存的指令。你无法直接访问现金。所以你已经看到它已经很抽象了。它有更多真实硬件的细节，但在它下面，这种微架构有一些内置的功能，你不是在操作这些功能，当你编写机器级别的程序时，你也不会直接利用这些功能。</p><p>发言人   24:54<br>So if you have a program, then say in C, it would typically a larger program that will include multiple files and it will make use of some library code. And so the process of compilation is actually a series of steps that will take what you’ve written for code, turn it into machine code, combine it with the compiler, compiler generated code for the libraries, and produce finally a file that’s your actual executable program. And so that’s shown here in this picture that the first step is to take C and actually generate assembly code from it. And then the next is to run that through an assembler, which takes the text representation of instructions and turns it into the actual byte level representation. We’ll look at all this shortly. And then there’s a program called a linker, which merges together all the different files for both your individual file. They’re compiled versions, and for the library code. And then finally there, even once you run a program, there’s actually some libraries that get imported dynamically when the program first begins, so it’s a sort of many layered set of activities.<br>所以，如果你有一个程序，比如说用C语言，它通常是一个包含多个文件的较大的程序，它将利用一些库代码。因此，编译的过程实际上是一系列步骤，这些步骤将您为代码编写的内容转化为机器码，将其与编译器结合，编译器为库生成代码，最后生成一个实际可执行程序的文件。因此，这张图片中显示的第一步是使用C并从中实际生成汇编代码。然后，接下来是通过汇编器运行它，汇编器采用指令的文本表示形式并将其转换为实际的字节级表示形式。我们很快就会看到这一切。然后有一个名为链接器的程序，它可以将您个人文件的所有不同文件合并在一起。它们是编译版本，用于库代码。最后，即使你运行了一个程序，实际上也有一些库在程序刚开始时动态导入，所以它是一组多层的活动。</p><p>发言人   26:19<br>And I’ll go through some of these one by one for you.<br>我会为你逐一介绍这些内容。</p><p>发言人   26:24<br>Example, not very interesting function in terms of doing anything useful, but it sort of demonstrates the basic ideas of compilation. And if I run this through AC compiler, I get something that looks like what’s shown on the right, and that’s the assembly code. And just to give you an idea of what it is, it looks like a sort of strange language the first time you see it. But you’ll see those percent are something. Those are the actual names of registers. Remember I told you those registers that you give by name, and then those instructions are telling it to do something?<br>这个例子并不是很有趣的函数，但它展示了编译的基本思想。如果我通过交流编译器运行这个，我会得到一些看起来像右边显示的东西，那就是汇编代码。为了让你了解它是什么，当你第一次看到它时，它看起来像是一种奇怪的语言。但是你会发现那些百分比有些关系。这些是寄存器的实际名称。记得我告诉过你那些你按名字指定的寄存器，然后那些指令告诉它做某事？</p><p>发言人   27:03<br>Push Q means push something onto a stack. Move means move, copy it from one place to another. Call means to call some procedure. Pop is the counterpart to push, and then rep is exit. Return out of this particular function. So you see each of those is an instruction and it’s written in text, but each of those will turn into one actual instruction in the object code representation. So I should tell you that this is actually a slightly cleaned up version of what really happened. So let me show you the reality because you’ll be experiencing that a bit more too.<br>Push Q的意思是将某物推到堆栈上。移动意味着移动，将其从一个地方复制到另一个地方。Call意味着调用某个过程。Pop是push的对应项，rep是exit。返回这个特定的功能。因此，您会看到其中的每一个都是一条指令，并且它是用文本编写的，但是每一个都将在目标代码表示中变成一条实际的指令。所以我应该告诉你，这实际上是对实际情况的稍微清理过的版本。所以让我向你展示现实，因为你也会经历更多。</p><p>发言人   27:49<br>I had this bigger before. Let me make it bigger.<br>我以前有过这个更大的。让我把它放大一点。</p><p>发言人   28:06<br>Blow this up so that you can see it. That, can you see it in the back there? Better?<br>把这个吹起来，这样你就能看到了。你能看到后面的那个吗？更好？</p><p>发言人   28:25<br>And let me get the other one. No, that’s not what I.<br>让我去拿另一个。不，那不是我想的。</p><p>发言人   28:52<br>And I’ve already. Logged into a fish machine to get here. This is a file. Then you see it’s called some DOC. And I’ll mention that all of these programs are available. You can see the whole well slash Afs is my own personal and all that first stuff is my own personal links. But once you get to the class web page, www slash code slash, and then it’s all given by which particular lecture it is, I think these are linked on the homepage too. And you can see various files there that are used for the demonstration.<br>而且我已经。登录到一个鱼油加工机械来这里。这是一个文件。然后你会看到它被称为某个医生。我会提到所有这些程序都是可用的。你可以看到整个井斜杠Afs是我个人的，而所有这些第一件事是我自己的个人链接。但是一旦你进入班级网页，www斜线代码斜线，然后全部由哪个特定的讲座给出，我想这些也在主页上链接了。您可以在那里看到用于演示的各种文件。</p><p>发言人   29:34<br>The C files are obviously the programs that we typed in and then ones that have an S at the end, that’s assembly code 1 that are D are what’s called disassembly. So anyways, if I say GCC is O two’s, sorry, minus 0?<br>C文件显然是我们输入的程序，然后结尾有S的程序，即汇编代码1和D，这就是所谓的 “拆卸”。无论如何，如果我说GCC是O两个，对不起，减去0？</p><p>发言人   29:54<br>G minus S capital sum dot C, what I did was just tell the compiler to take the C code and turn it into assembly code. So when you invoke GCC, you’re actually invoking it, not just one program, but a whole sequence of programs that do various stages of the compilation. And by giving it this minus capital S switch I’m saying stop. Just do the first part C to assembly code. And the minus O little g is a specification of what kind of optimization I want the compiler to do. So if you don’t say anything, if you just don’t give any directive, it will generate completely unoptimized code. And it’s actually very hard to read that code, tedious the way it works.<br>G减去S大写和点C，我所做的只是告诉编译器将C代码转换为汇编代码。因此，当您调用GCC时，实际上是在调用它，而不仅仅是一个程序，而是整个执行不同编译阶段的程序序列。通过给它这个减去大写字母的开关，我说停止。只需对汇编代码执行第一部分C即可。减号O小g是我想让编译器做什么样的优化的规范。因此，如果你什么也不说，如果你不给出任何指令，它将生成完全未优化的代码。实际上，阅读这些代码非常困难，它的工作方式非常繁琐。</p><p>发言人   30:50<br>If you say minus o one, which is what you used to do to turn on the optimizer, it turns out that as GCC, as they’ve gotten more advanced, it does a lot of optimizations now that for the purpose of this course, make the code pretty hard to understand. So just one of the most recent generations of GCC came out with this level called G for debugging. That’s a, for this course, purpose of this course, a nice level that sort of does the obvious kind of optimizations to make the code readable without being sort of extravagant and trying to rewrite your whole program in a way that would make it a lot different and hopefully more efficient.<br>如果你说-o one，这是你过去用来打开优化器的方法，结果发现，随着GCC变得更加高级，它现在会进行很多优化，为了本课程的目的，使代码变得非常难以理解。所以只有最新一代的GCC推出了这个称为G的级别来进行调试。这就是本课程的目的，一个不错的水平，它做了一些明显的优化，使代码可读，而不会有点奢侈，并试图重写整个程序，使其变得与众不同，希望更高效。</p><p>发言人   31:38<br>So that’s what we’ll use in this course. It’s only exists in the recent versions of GCC. It’s non-standard across other compilers question. No, it’s an O capital. O, it stands for Optimize.<br>这就是我们在本课程中将要用到的。它只存在于最近的GCC版本中。这在其他编译器中是非标准的问题。不，它是一个大写字母。O，它代表优化。</p><p>发言人   31:57<br>So what that command just did was produce a file called sums. So let me show you. What sum dot s is, and let me show you the function sum store. Can you see that then?<br>所以这个命令所做的就是生成一个名为sum的文件。让我向你展示一下。总和s是什么，让我向您展示函数和存储。你看见了吗？</p><p>发言人   32:30<br>So this is the code. It says some store. And then you’ll see, you’ll recognize those instructions I mentioned before, the push, the move, the call, the mush move, the pop, and the rat. But you also see other junk there that we edited it out for the presentation. And even in the book, it got edited out. And the reason is these are various directives that aren’t really directly part of the code itself. The fact they start with a period is an indication that these aren’t actually instructions. There’s something else, and they all are related to the information that needs to be fed a debugger it to be able to locate various parts of the program and some information for the linker to tell it that this is a globally defined function and various other things that you don’t really need to at least think about initially.<br>这就是代码。它说一些商店。然后你会看到，你会认出我之前提到的那些指令，推动、移动、呼叫、糊状移动、弹出和老鼠。但是你也会看到我们为演示文稿编辑的其他垃圾内容。甚至在书中，它也被编辑掉了。原因是这些是各种指令，它们并不是代码本身的直接组成部分。它们以句号开始的事实表明这些实际上并不是指令。还有一件事。它们都与需要提供给调试器的信息有关，以便能够找到程序的各个部分，以及链接器的一些信息，告诉它这是一个全局定义的函数以及其他各种你不需要考虑的东西。</p><p>发言人   33:29<br>So we sort of take those out of the program just to make them more readable. But if you ever do this yourself, you’ll find this cred in there and we don’t want you to get like, oh my gosh, this wasn’t in the book. I don’t know what to do with it.<br>所以我们把它们从程序中取出来，只是为了让它们更易读。但如果你自己做这件事，你会发现这里面有这种可信的东西，我们不希望你觉得，天哪，这本书里没有这一点。我不知道该怎么办。</p><p>发言人   33:48<br>So let’s go back.<br>那我们回去吧。</p><p>发言人   34:00<br>The other thing is people are learning on datalab is shark versus non-ss Hark, it makes a difference. And even like this is a Mac computer and I’ve got GCC installed and it generates its Intel processor in there, but it’s not directly compatible with Linux code. So it’s pretty important for this course, we’re saying just stick with the shark machines for everything you do.<br>另一件事是人们在datalab上学习的是鲨鱼和非ss哈克，这有所不同。甚至像这样，这是一台Mac计算机，我安装了GCC，它在其中生成英特尔处理器，但它不能直接与Linux代码兼容。所以对于这门课程来说，这非常重要，我们说的是，无论你做什么，都要坚持使用鲨鱼机器。</p><p>发言人   34:31<br>So what are some characteristics of assembly code? Especially, how do they differ from C? Well, first of all, there’s a number of different sort of integer data types of size 1, 2, 4, and 8 B. In integer data types, they don’t distinguish signed versus unsigned, how it gets stored, and even an address or a pointer is just stored as a number in a computer and doesn’t have any special significance to it. A floating point is handled in a very different way, on the other hand, with a different set of registers that I think I’ll talk about very briefly in one of the later lectures, the program itself is in x 86. It’s just a series of bytes. And I’ll show you some examples of those and things like arrays and structs and things that you think of as fundamental data types don’t exist at the machine level, constructed artificially by the compiler Later in the course.<br>那么，汇编代码的一些特征是什么？特别是，它们与C有什么不同？嗯，首先，有许多不同类型的整数数据类型，大小为1、2、4和8 B。在整数数据类型中，它们不区分有符号和无符号，也不区分它是如何存储的，甚至一个地址或指针只是作为一个数字存储在计算机中，对它没有任何特殊意义。一个浮点以一种非常不同的方式处理，另一方面，使用一组不同的寄存器，我想我会在后面的讲座中非常简要地谈论，程序本身是在x86中。这只是一系列的字节。我将向您展示一些示例，例如数组、结构以及您认为是基本数据类型的东西，这些东西在机器级别上是不存在的，稍后在课程中由编译器人为构建。</p><p>发言人   35:35<br>In these lectures, we’ll cross over into how that’s actually done as well. So some of the things you know about Inc exist here and some of them are sort of have to be built up in layers on top of the assembly level program.<br>在这些讲座中，我们将深入探讨这实际上也是如何做到的。因此，您所了解的有关Inc的一些事情存在于这里，其中一些必须在组装级程序的基础上分层构建。</p><p>发言人   35:54<br>So the other thing about assembly level programming is each instruction is very, very limited in what it can do. It can move data from a register to memory from, or it do an addition or a multiplication or something like that, but can really basically only do one thing and. So you have to write a whole. If you were writing it by hand, you’d have to write a whole series of instructions to get anything done. And that’s part of the reason why it’s really much better to let the compiler do that. And we’ll also see there’s sort of how things like do loops while loops. Conditionals, switch statements, those are all built up on top of some other lower level features in the instructions. So for this function, some store actually, it gets encoded by a total of 14 B.<br>因此，汇编级编程的另一件事是，每条指令所能做的事情非常非常有限。它可以将数据从寄存器移动到内存，或者进行加法、乘法或类似的操作，但实际上只能做一件事。所以你必须写一个完整的。如果你是手写的话，你必须写一整套的指令来完成任何事情。这就是为什么让编译器这样做真的要好得多的部分原因。我们还将看到像做while循环这样的事情。条件语句、switch语句，这些都是建立在指令中的一些其他较低级别功能之上的。所以对于这个函数，实际上有些存储，它被总共14 B编码。</p><p>发言人   36:57<br>And so one thing about x 86 is some instructions are as short as 1 B, but others can be as long as 15 B in the encoding.<br>关于x86的一点是，有些指令短至1 b，但有些指令在编码中可长达15 b。</p><p>发言人   37:16<br>Like I said, each instruction really typically only does one thing. So for example, in C, if you say star dust equals t, what that will typically, and not always, but the sort of way to think about that at the machine level, is it t or some local value would be typically stored in a register. And as you know, in C, if you put star in front of it, you want it referenced as a pointer. And if that reference is on the left, you want to store a number a value at that place where you’re pointing to. So what would typically happen is dust, the actual pointer value would also be stored in a register here in register rbx. And I use a move instruction to say, take the value from one register, which is called Rax here, and store it in the memory location that’s specified by another register. So you see the idea, we’ll go into more detail about all these register names and what the parentheses mean.<br>就像我说的，每个指令通常只做一件事。因此，例如在C中，如果你说星尘等于t，那通常会是什么，并不总是如此，但在机器级别上考虑这个问题的方式是，它是t还是一些本地值通常存储在寄存器中。而且如你所知，在C中，如果你在它前面放了星星，你希望它被引用为指针。如果该引用在左侧，则您希望在指向的那个位置存储一个值。所以通常会发生的是灰尘，实际的指针值也将存储在这里的寄存器rbx中。并且我使用移动指令说，从一个寄存器 (这里称为Rax) 中取出值，并将其存储在由另一个寄存器指定的内存位置中。所以你明白了这个想法，我们将更详细地介绍所有这些寄存器名称以及括号的含义。</p><p>发言人   38:20<br>You get the rough idea that a move instruction is saying can refer to either a register or a memory location, And the actual object code representation of this is just 3 B where the first byte. Tells that? And we won’t even talk much in this course about how the instructions are encoded, won’t generally let programs do that for us, but in this case, it only takes 3 B to write that particular instruction. So how can we know that kind of stuff? How can we figure out that level of detail?<br>你得到了大致的想法，即一个move指令可以引用一个寄存器或一个内存位置，而实际的目标代码表示形式只是3 b的第一个字节。告诉我？在这门课中，我们甚至不会过多地谈论指令是如何编码的，通常不会让程序为我们做这件事，但在这种情况下，编写特定的指令只需要3 b的时间。那么我们怎么知道那种东西呢？我们如何计算出这种程度的细节？</p><p>发言人   39:00<br>Well, there’s some really useful tools that let you examine machine code, even if you don’t have a copy of the original C file or even the assembly code file ahead of time. And there’s one called a disassembler. So an assembler goes from this text version of instructions to a byte level representation, and a disassembler just reverses that. Here is a series of bytes, and I, the disassembler, know that this particular byte sequence refers is a move instruction, and so it will now print out on the screen to say, oh, that was a move instruction. And so it basically reverse engineers from the object code back to the assembly code or something, sort of like the assembly code. You’ll see it lost. Well, it’s very slightly different.<br>嗯，有一些非常有用的工具可以让你检查机器码，即使你事先没有原始C文件甚至汇编代码文件的副本。还有一种叫做反汇编程序。所以汇编器从指令的文本版本转换为字节级的表示形式，而反汇编器则相反。这是一系列字节，而反汇编程序知道这个特定的字节序列引用的是一个移动指令，因此它现在将在屏幕上打印出来说，哦，那是一个移动指令。因此，它基本上将目标代码反向工程回到汇编代码或类似汇编代码的东西。你会看到它丢失了。嗯，这有点不同。</p><p>发言人   39:59<br>One thing also to notice, I should mention about assembly code is all those, all the names I used, all the names of variables are completely lost at the assembly code level. At the machine code level, things are just, they’re in registers, they’re somewhere in memory. The program has no understanding of your original source code at that level, and so the disassembled is just a way to go backward. And you can do that yourself. And you’ll find that useful in various contexts. To do that yourself? Things kind of monkeying around me. So if I compile the sum program.<br>还有一件事需要注意，我应该提到汇编代码，所有我使用的名称，所有变量的名称都在汇编代码级别完全丢失了。在机器代码层面上，事物只是，它们在寄存器中，它们在内存中的某个地方。该程序在那个级别上无法理解您的原始源代码，因此反汇编只是一种倒退的方式。你可以自己做。你会发现这在各种情况下都很有用。你自己做吗？我周围的事情有点像小人。所以如果我编译求和程序。</p><p>发言人   41:05<br>So if I do the more standard thing you do in using a compiler, you say run the compiler, give it some optimization, tell what the source files are, and tell it where to put the final executable code. Terribly clever. I call the function sum. And so sum is a binary file. Of 8663 B, you’ll see off on the left, it’s marked as executable and it actually works. I can add numbers together with it. That’s your sort of standard executable program, excuse me.<br>所以如果我使用编译器做更标准的事情，你说运行编译器，给它一些优化，告诉它源文件是什么，并告诉它在哪里放置最终的可执行代码。非常聪明。我调用函数sum。所以sum是一个二进制文件。对于8663 B，您将在左侧看到，它被标记为可执行，并且实际上可以工作。我可以和它一起相加。这是您的标准可执行程序，对不起。</p><p>发言人   41:48<br>And if I run a program called object dump. And ask it to disassemble. It can do various things. It will spit out a disassembled version of the program, and it will fly by on the screen. But if I redirect that to some file. Which I already did. I’ll remove the old one.<br>如果我运行一个名为对象转储的程序。并要求它拆卸。它可以做各种各样的事情。它会吐出一个拆解版本的程序，然后在屏幕上飞过。但是如果我将其重定向到某个文件。我已经做了。我会把旧的去掉。</p><p>发言人   42:21<br>And now I look at that. You’ll see that it has what I described as is the disassembled representation of the program, including some files that some functions that you didn’t write has ones that are sort of the low level functions that are used in the initial start-up of a program called init.<br>现在我看看这个。你会看到它具有我所描述的程序的反汇编表示，包括一些你没有编写的函数的文件，这些文件是在名为init的程序的初始启动中使用的低级函数。</p><p>发言人   42:46<br>Oops. But here, somewhere in the middle of it, you’ll see, lo and behold, is that program, that function, some sort that got compiled? And you can see that what it did was it took this 14 B from the. Object code. And it picked those apart and came back with what instructions? Those bytes and coat. So for example, the push instruction only takes a single byte. The move, as you saw before, takes 3 B. This call, because it has to give the a location of where to call, is a 5 B instruction and so forth.<br>哎呀。但是在这里，在它中间的某个地方，你会看到，你看，那个程序，那个函数，某种被编译的东西吗？你可以看到它的作用是拿走了14 B。目标代码。然后它把这些拆开，带回来什么指示？这些字节和外套。例如，push指令只占用一个字节。这个动作，正如你之前看到的，需要3 B。这个调用，因为它必须给出一个调用的位置，是一个5 B指令等等。</p><p>发言人   43:37<br>But again, the disassembly didn’t have access to the source code. It didn’t have access even to the assembly code. It figured this out just by the bytes in the actual object code file. So this is the way, if you ever want to know, actually, the byte level encoding, this is how you figure it out, is to run a program, run it through an Asse, get object code, and then come back out with it.<br>但是，再次强调，该拆解程序无法访问源代码。它甚至没有访问汇编代码的权限。它仅通过实际目标代码文件中的字节来解决这个问题。所以这就是方法，如果你想知道，实际上，字节级编码，这就是你如何解决的方法，就是运行一个程序，通过一个Asse运行它，获得目标代码，然后回来处理它。</p><p>发言人   44:06<br>There’s another way you can do it. Using the debugging program, which you’ll get to know very well in the next web you’re going to do. And it’s called gdb. And Gdb is a very powerful debugging program that you can examine and step through and operate on programs in. And again, if the source code for it’s available, it will make use of it. But it also can be used on programs for which there’s no source available.<br>你还有另一种方法可以做到。使用调试程序，您将在下一个网站中非常了解该程序。它被称为gdb。并且Gdb是一个非常强大的调试程序，您可以在中检查、逐步执行和操作程序。再次强调，如果它的源代码可用，它将利用它。但它也可以用于没有可用源代码的程序。</p><p>发言人   44:44<br>But one of the features is the ability to disassemble functions in there. So if I say disassemble. Some store, it’ll come back with something that looks a lot like what you saw from Object dump, a listing of the instructions. And here it just shows in hex what the addresses of those different instructions are. It doesn’t show the byte level encoding. So my point here is there’s various tools that let you look at a program, even if its actual representation is a binary file that you don’t want to examine directly.<br>但其中一个特点是能够反汇编其中的功能。所以如果我说拆卸。有些商店，它会返回一些看起来很像您从对象转储中看到的指令清单的东西。在这里，它只是以十六进制的形式显示这些不同指令的地址。它不显示字节级编码。所以我的观点是，有各种工具可以让你查看程序，即使它的实际表示是你不想直接检查的二进制文件。</p><p>发言人   45:38<br>And just plug this in.<br>然后把这个插上。</p><p>发言人   45:46<br>So what this slide shows is what I just showed you on the screen, which is what the object dump program produces for this function. And this is a version showing what Gdb would show you for and with Gdb, if you want to actually get the bytes out, you can do that. You can basically, for any address, you can just give an address and tell it to display some number of bytes. So this rather cryptic command to Gdb says examine 14 B in hex format starting at the address of the function some store. And it produced something that looks like what you see on the left.<br>所以这张幻灯片所展示的就是我刚刚在屏幕上向您展示的内容，也就是对象转储程序为此功能所生成的内容。这是一个展示Gdb将向您展示的版本，如果您想实际获取字节，您可以这样做。基本上，对于任何地址，您只需提供一个地址并告诉它显示一些字节数。所以这个相当神秘的Gdb命令说检查14 B以十六进制格式从函数的地址开始存储。它产生了一些看起来像你左边看到的东西。</p><p>发言人   46:36<br>In fact, disassembly is a tool that can be used as part any of reverse engineering tools. And I used to demo this by showing a disassembly of Windows of Microsoft Word. I had a PC back then, not a Mac, but some people. And our slides are online and so we got some nasty grams from people saying, you know, you’re violating the Microsoft end user license agreement when you do that because you’re supposed to. You don’t know this, but remember all those quick through, I agree things, but you never read one of them is I agree not to try to reverse engineer any Microsoft product. So this technically, so I’ve served just for modesty, I blanked this out.<br>事实上，反汇编是一种工具，可以用作任何逆向工程工具的一部分。我曾经通过展示微软Word窗口的拆解来演示这个。那时我有一台电脑，不是Mac，而是一些人。我们的幻灯片是在线的，所以我们得到了一些来自人们的恶意信息，他们说，你知道，当你这样做时，你违反了微软的最终用户许可协议，因为你应该这样做。你不知道这一点，但请记住所有那些快速通过的东西，我同意，但你从来没有读过其中的一个是我同意不要试图对任何微软产品进行逆向工程。所以从技术上讲，我服务只是为了谦虚，我把它空白了。</p><p>发言人   47:27<br>But you can actually do it if you can find where the file is. It’s sort of obscure where the actual executable files of an application are. My point is that word like any other. Application you run is just an executable file. And that executable file is just a bunch of bytes that encode instructions. So let’s go a little bit further into this assembly level programming business.<br>但是如果你能找到文件的位置，你实际上可以做到这一点。应用程序的实际可执行文件在哪里有点模糊。我的观点是这个词和其他任何词都一样。你运行的应用程序只是一个可执行文件。而这个可执行文件只是一堆编码指令的字节。因此，让我们进一步探讨这个汇编级编程业务。</p><p>发言人   47:58<br>So I keep talking about regist and X 8664 has this totally quirky set of registers. And it’s a reflection, again, of this sort of evolutionary history to it. But you’ll see that there’s 16 registers that you can use to hold integers and pointers. And some of them have these sort of alphabetic names, and some of them have numeric names. I’ll show you why in a minute. And also for each register, if you use the sort of percent r name of it, you’ll get 64 b. But if you use the percent e version of it, you’ll get 32 b. And what you’ll find in programs that manipulate long ints, you’ll see the use of r, and if they’re just int 32 b things, you’ll see code saying percent E, so you’ll see both of these show up.<br>所以我一直在谈论regist，而X 8664有这个完全古怪的寄存器集。这再次反映了这种进化历史。但是你会看到有16个寄存器可以用来保存整数和指针。其中一些有字母名称，一些有数字名称。我会在一分钟内告诉你为什么。而且对于每个寄存器，如果您使用它的百分比名称，您将获得64 b。但是如果你使用它的百分比e版本，你将得到32 b。你会在操纵长整数的程序中发现什么，你会看到r的使用，如果它们只是int 32 b的东西，你会看到代码显示百分比E，所以你会看到这两个出现。</p><p>发言人   48:54<br>And it’s fairly important to remember that percent E version is just the low order 32 b of a larger percent R entity. And in fact, it goes beyond that.<br>而且相当重要的是要记住，百分比E版本只是更大的百分比R实体的低阶32 b。事实上，它不止于此。</p><p>发言人   49:08<br>You can also reference the lower order 16 b and the low order 2 b. I’m sorry, onete bytes and 1 B. Within each of these registers as well. But again, think of these as like named locations where you can store values and you can retrieve values from them and you. I’m sort of personifying machine level programming here, not you personally. We’ll actually have to explicitly name those registers for the most part to say where things should go, where they should come out of. It’s not like a memory where you just give a number to tell where to look for. You could compute a number, each one is identified separately.<br>您也可以参考较低的阶16 b和较低的阶2 b。对不起，一个字节和1 B。在这些寄存器中也是如此。但是，请再次将这些视为命名位置，您可以在其中存储值并从中检索值。我在这里有点人格化机器级别的编程，而不是你个人。我们实际上必须明确命名这些寄存器，大部分是为了说明事物应该去哪里，它们应该从哪里出来。这不像一个记忆，你只需要给出一个数字来告诉你去哪里寻找。你可以计算一个数字，每个数字都是单独标识的。</p><p>发言人   50:01<br>So just as a little bit of history. With i.e. 32, so we just talked about there being eight registers, all the percent E versions. And one of the changes that went from IA 32 to X 8664 was to double the number of registers. And by the way, this is a really helpful thing because it was very frustrating how few registers there were in the old I 32 machines.<br>所以只是一点点历史。与e.32，所以我们刚刚谈到有八个寄存器，所有的百分比版本。从IA 32到x8664的变化之一是将寄存器数量增加了一倍。顺便说一下，这是一件非常有帮助的事情，因为在旧的i32机器中几乎没有寄存器，这非常令人沮丧。</p><p>发言人   50:37<br>As I mentioned. You could actually, in the old machine, refer to the low order 16 B of these registers. And that was a legacy from the 80, 86 days. And within the first four, you could even refer to the individual two or or bytes in those. So nowadays, you can actually get to the low order byte of all of them. And we just sort of that’s covered in the book.<br>正如我所提到的。实际上，在旧机器中，您可以参考这些寄存器的低阶16 B。那是80、86天的遗产。在前四个中，你甚至可以引用其中的单个两个或字节。所以现在，你实际上可以得到所有这些的低位字节。我们只是在书中涵盖了这一点。</p><p>发言人   51:10<br>Actually. We don’t talk about how you can get to these bytes because that’s really a legacy from back before the Ad 86 was one called the.<br>实际上。我们不谈论如何获得这些字节，因为这实际上是在Ad 86之前的遗留问题。</p><p>发言人   51:25<br>8080, which was an 8 B machine. So anyways, you can see then how you got from this kind of weird state of affairs to the even weirder state that we are in today, where some of them have names and some of them have numbers. And those names, by the way, had a reason back in ancient days. They had very specific purposes. And so they were given names that sort of reflected those purpose. But that all went away years and years ago. And so now these names are just legacy names, have nothing to do with their purpose.<br>8080，是一台8 B的机器。无论如何，你可以看到你是如何从这种奇怪的状态发展到今天更奇怪的状态的，其中一些人有名字，一些人有数字。顺便说一下，这些名字在古代是有原因的。他们有非常具体的目的。于是他们被命名，反映了这些目的。但这一切都在多年前就消失了。所以现在这些名称只是传统名称，与它们的用途无关。</p><p>发言人   52:11<br>Now, I should mention only there are some, there’s one special register nowadays as shown in pink here, and that’s called the stack pointer. And that register, you don’t just use any old way you please. It has a very specific purpose. And all the other registers, there’s some that are slightly different than the other, but for the most part, they’re all usable for holding program data. Back in the i.e. 32 days, there was a register called the base pointer that also got used for procedures, but that no longer gets used anymore either, at least not usually. So anyways, I don’t want to spend a lot of time on historic legacy stuff. Have you memorized what feature was added and what model of processor? But just in case you’re wondering why there these weird names for these things, so you appreciate the fact that this is a legacy thing.<br>现在，我应该提到的只是一些，现在有一个特殊的寄存器，在这里以粉红色显示，那就是堆栈指针。那个寄存器，你不只是使用任何旧的方式。它有一个非常具体的目的。和所有其他寄存器一样，有一些与其他寄存器略有不同，但在大多数情况下，它们都可用于保存程序数据。回到过去。在32天内，有一个名为基本指针的寄存器也被用于过程，但它也不再被使用了，至少通常不会。所以无论如何，我不想花太多时间在历史遗留的东西上。你是否记得添加了什么功能以及处理器的型号？但以防万一你想知道为什么这些东西有这些奇怪的名字，所以你很感激这是一个遗留的东西。</p><p>发言人   53:12<br>OK, so now we can think of it then, that there’s eight registers with names, and there’s eight registers that are indicated by some number. And let’s look at some of the instructions that operate on those registers. And there’s sort of three different. So the move instruction in x 86 is actually can do a lot of things. Because it can take different types of information or what they call operands. So the source is where you’re copying from the source to the destination. The source can be some what’s called immediate. It’s actually a number that’s baked into the program that you want to copy into some other location, a register we’ve talked about as one of these specially named memory locations.<br>好的，现在我们可以想象一下，有八个带有名称的寄存器，其中八个寄存器由某个数字表示。让我们来看看在这些寄存器上操作的一些指令。有三种不同的类型。所以x86中的移动指令实际上可以做很多事情。因为它可以接受不同类型的信息或他们所谓的操作数。源是你从源复制到目标的地方。来源可以是一些所谓的即时的。它实际上是一个嵌入程序中的数字，您想要复制到其他位置，我们谈论过的寄存器是这些特别命名的内存位置之一。</p><p>发言人   54:10<br>And memory is the array of bytes that you typically you have to specify what’s the address that you’re either reading from, if it’s the source, or you’re writing to if it’s the destination. And so the move instruction gives you all these possibilities.<br>而内存是一个字节数组，你通常需要指定你从哪个地址读取，如果它是源，或者如果它是目标，你要写入到哪个地址。因此，移动指令为您提供了所有这些可能性。</p><p>发言人   54:30<br>An immediate value can be written to a register or directly to memory. A register value can be copied to another register. Or written to memory? Or you can take a value from memory, read it from memory, and copy it to a register.<br>立即值可以写入寄存器或直接写入内存。一个寄存器的值可以被复制到另一个寄存器。还是写给记忆？或者你可以从内存中取出一个值，从内存中读取它，然后将它复制到一个寄存器。</p><p>发言人   54:48<br>So if you think of, wait, shouldn’t there be 9 different combinations here? Well, no, because it doesn’t make sense to have an immediate value as a destination. It’s a constant. And also just for sort of the sake of convenience of the hardware designers, it doesn’t let you directly copy from one memory location to another. What you have to do is use two instructions, one to copy from memory to read it from memory, copy it to a register, and a second to take that value in the register and write it to memory. So that’s why there’s this only five possibilities. And so each of these actual 5 combinations you’ll see in some form or another.<br>所以如果你想到，等等，这里不应该有9种不同的组合吗？不，因为作为目的地具有即时价值是没有感知的。这是一个常数。而且只是为了方便硬件设计人员，它不允许您直接从一个内存位置复制到另一个内存位置。你需要做的是使用两条指令，一条指令从内存中复制并读取，然后复制到寄存器中，第二条指令将寄存器中的值写入内存。这就是为什么只有五种可能性。因此，您将以某种形式看到这五个实际组合中的每一个。</p><p>发言人   55:35<br>So for example, if I take a constant value and copy it to a register, it’s a little like you can think of registers, sort of the temporary data that you’re operating on right now. So it’s a way of sort of assigning a constant value to a temporary. Similarly, if you have memory as your destination, it’s like storing a constant value in memory somewhere. If you’re copying from one register to another, it’s sort of like copying one temporary value to another one register to memory. It’s as if you, it’s sort of like storing to an address, a pointer dereference where the pointer is on the left side. The dereference and memory to register is the opposite. You’re reading from some location into a temporary position. So these, you’ll see all five versions get used in some form or another.<br>因此，例如，如果我取一个常量值并将其复制到寄存器中，这有点像你可以想象的寄存器，它是你现在正在操作的临时数据。所以这是一种将常量值分配给临时值的方式。同样，如果你将内存作为目的地，就像在内存的某个地方存储一个常数值一样。如果你正在从一个寄存器复制到另一个寄存器，这有点像将一个临时值复制到另一个寄存器到内存。这就好像你，有点像存储到一个地址，指针在左侧的指针引用。取消引用和记忆注册是相反的。你正在从某个位置阅读到一个临时位置。所以这些，你会看到所有五个版本都以某种形式使用。</p><p>发言人   56:40<br>So now let’s talk about how we write these pointers, how we specify either a source or a destination for a memory reference. And you already saw one version of this, in fact, in some of the code, when you put the name of a register in parentheses, that’s just saying, use this register, whatever is in that, that’s an address, and use that address to reference some memory location. And so you’ll see something like this is the equivalent of dereferencing a pointer and putting it in a temporary. You’re also allowed to do a little bit of arithmetic to derive an address from some collection of registers and other constant values. So if you see a number, it’s called the displacement d in front of this parentheses. It means to offset, not use the address that’s in the register, but add or subtract some number from it to get an address that’s just slightly off of it by some fixed amount. And that, we’ll see, is fairly useful for accessing different data structures.<br>现在让我们来谈谈如何编写这些指针，如何为内存引用指定源或目的地。实际上，您已经在一些代码中看到了这个版本，当您将寄存器的名称放在括号中时，这只是说，使用此寄存器，其中的任何地址，并使用该地址引用某些内存位置。所以你会看到这样的东西，相当于取消对指针的引用并将其放入临时文件中。你还可以进行一些算术运算，从一些寄存器和其他常量值的集合中推导出地址。所以如果你看到一个数字，它被称为这个括号前面的位移d。它的意思是偏移，不使用寄存器中的地址，而是从中添加或减去一些数字，以获得与它稍微偏离一些固定数量的地址。而且，我们将看到，对于访问不同的数据结构非常有用。</p><p>发言人   57:51<br>So here’s an example of a very simple function that we can understand everything about it already, because we know what the move instruction does. And that’s the sort of classic swapping of two values that are stored in memory. So my arguments are two pointers called XP and yp, and I’m going to dereference those pointers. I’m going to read from memory into registers, and then I’m going to copy back to memory, reversing the two destinations. And so as you can imagine, it lines up to be 4 move instructions that correspond to these four references.<br>这是一个非常简单的函数的例子，我们已经可以理解它的所有内容，因为我们知道移动指令的作用。这就是存储在内存中的两个值的经典交换。所以我的参数是两个指针XP和yp，我将取消引用这些指针。我将从内存中读取寄存器，然后将两个目标反向复制到内存中。所以你可以想象，它会排成4条移动指令，对应于这四个引用。</p><p>发言人   58:38<br>And the final one just we’ll learn more about functions and how they’re called, just think of the red as it gets you. It returns from wherever the calling position was. And so let’s look at more detail the actual code then. And so it turns out with the x 86 64.<br>最后一个我们将了解更多关于函数以及它们如何被调用的信息，只需想象一下红色的部分。它从呼叫位置所在的任何地方返回。那么让我们来看看实际代码的更多细节。因此，对于x86 64来说，情况就是这样。</p><p>发言人   59:08<br>Arguments always come in some specific registers, and the ones to remember for today is RDI will be the first argument register and Rs will be the second argument register. There can be up to six of these, and we’ll go into more of that later. So those two registers represent the values of XP and yp. Those are set before the function is actually begins executing. That’s set by the part of the code that calls this function. And those will be pointers. So what they are is they contain addresses that specifying locations in memory, and then within the code, the compiler just came up with its own ideas of how to use different registers for temporary data by whatever what’s known as the register allocation algorithm it uses.<br>自变量总是出现在一些特定的寄存器中，今天要记住的是RDI将是第一个参数寄存器，Rs将是第二个参数寄存器。最多可以有六个，稍后我们会详细讨论。所以这两个寄存器代表了XP和yp的值。这些是在函数实际开始执行之前设置的。这是由调用此函数的代码部分设置的。这些将是指针。所以它们包含指定内存中位置的地址，然后在代码中，编译器想出了自己的想法，如何通过任何所谓的寄存器分配算法来使用不同的寄存器来存储临时数据。</p><p>发言人   01:00:01<br>And we don’t really care. We just what we’ll want to do is figure out what it’s doing, and we’ll see that a register X is being used to hold the value of t 0 and RDX the value t 1.<br>我们并不在乎。我们想做的就是弄清楚它在做什么，然后我们会看到一个寄存器X被用来保存t0的值，RDX则是t1的值。</p><p>发言人   01:00:18<br>Now, so let’s get actually concrete here. And this is very detailed, but I think it’s important that you understand, sort of you can almost simulate the execution of some instructions by yourself. You’re going to really have to know this stuff. So what each of these instructions is doing and how it works, and really have that wired into you pretty well.<br>现在，让我们在这里变得更具体一些。这非常详细，但我认为重要的是你要理解，你几乎可以自己模拟一些指令的执行。你真的必须知道这些东西。那么这些指令中的每一个在做什么以及它是如何工作的，并且真的很好地融入你的思想中。</p><p>发言人   01:00:42<br>So let’s make up an example. Let’s imagine that the two addresses that are used for these two pointers in hex 1, 2 0, and 1 0 0, by the way, those would not be typical addresses. They’re way too small a number, but it’s much easier to use them as an illustration. And let’s suppose that one of them held the value 1, 2, 3, and the other 4, 5, 6. So the first instruction says use RDI as an address copy from that memory location and store the result and register rrx. So RDI is 120. I’ll read from that address. I’ll read the value 123 and store it and register Rix.<br>那么让我们举一个例子。让我们想象一下，十六进制1、2 0和1 0中用于这两个指针的两个地址，顺便说一下，这不是典型的地址。它们是一个太小的数字，但用它们来作为说明要容易得多。让我们假设其中一个持有值1、2、3，而另一个持有值4、5、6。所以第一条指令说，使用RDI作为从该内存位置复制的地址，并存储结果并注册rrx。所以RDI是120。我会从那个地址读出来。我将读取值123并存储它并注册Rix。</p><p>发言人   01:01:28<br>These are all, by the way, 8 B values. And I’m just sort of glossing over that part of it. But the Q refers to what an Intel terminology is, a quad word, a word, because it goes back to the 8086 Te bits, 2 B. Long word is 32 b and a quad word is 64 b. The terminology, and we’re stuck with it.<br>顺便说一下，这些都是8 b的值。我只是在掩盖这一部分。但是Q指的是英特尔的术语，一个四字，一个字，因为它可以追溯到8086 Te位，2 b。长单词是32 b，四单词是64 b。术语，我们被它束缚住了。</p><p>发言人   01:02:02<br>Okay, so that one instruction had that effect. The second instruction does the same thing, but using RSI, which holds 100 as an addressed, and so it copies 456 into RDX. And then the third instruction is writing back to memory. So its source is register RDX. The destination has the address of RDI, which is 120, and it’s storing that back in memory. And finally, this fourth instruction does the other part of the right, so you see these four instructions 2 read from memory into registers, two of them wrote from registers back to memory. And that’s the whole function.<br>好的，那一条指令有这种效果。第二条指令做同样的事情，但是使用RSI，它将100作为地址，因此它将456复制到RDX中。然后第三条指令是写回内存。所以它的来源是寄存器RDX。目标地址为RDI，即120，并将其存储在内存中。最后，第四条指令执行右边的另一部分，因此您会看到这四个指令2从内存读取到寄存器，其中两个指令从寄存器写入内存。这就是整个功能。</p><p>发言人   01:02:51<br>And you can see this move instruction is doing all the work here. So we’ve shown that example, just showed this very simple memory referencing that’s designated by the parentheses. And as I mentioned, you can do a version where you put a displacement there too. And in fact, there’s a much more elaborate form.<br>你可以看到这个移动指令正在完成这里的所有工作。所以我们已经展示了这个例子，只是展示了这个由括号指定的非常简单的内存引用。正如我提到的，你可以做一个版本，在那里也放置一个位移。事实上，还有一种更复杂的形式。</p><p>发言人   01:03:15<br>And we’ll see that this is useful for implementing array references where there can be actually two registers involved. And there can be a displacement, which is a constant offset, and a scale factor, which will be 1, 2, 4, 8. And the general idea of it is to take register that I’m referring to as R sub I, that’s known as an index register. You multiply it by the scale factor, you add the value of RB, register RB, and you also add the constant displacement. And these have a RB to base. RI is index and S is scale. And it turns out this will be the sort of natural way to implement array reference, and it will make a lot more sense when we talk about arrays.<br>我们将看到，这对于实现可能涉及两个寄存器的数组引用非常有用。并且可以有一个位移，它是一个恒定的偏移，和一个比例因子，它将是1、2、4、8。它的一般想法是取我称之为R sub I的寄存器，也就是所谓的索引寄存器。你将它乘以比例因子，你将RB的值相加，寄存器RB，还可以加上恒定位移。这些有一个RB基础。RI是索引，S是规模。事实证明，这将是实现数组引用的自然方式，当我们谈论数组时，这将更加感知。</p><p>发言人   01:04:11<br>But basically, you can think of as if this is an array index. I have to typically scale it by however many bytes my data type is. So if it’s an int, I have to scale it by 4. If it’s long, I have to scale it by 8. So that’s where the scale factors will come in. And basically, the format in the assembly code letsgo eliminate some of these fields if they’re not being used.<br>但基本上，你可以把它想象成数组索引。我通常必须按照我的数据类型多少字节来缩放它。所以，如果它是一个int，我必须将其缩放到4。如果它很长，我必须按8的比例缩放。这就是比例因素所在。基本上，汇编代码中的格式letsgo会消除一些字段，如果它们不被使用的话。</p><p>发言人   01:04:44<br>So we already saw the single parentheses is sort of a reduced version of this form. So let’s just do some examples of these address computations. And let’s imagine that register RDX holds he f with three zeros and rcx holds one with two zeros. Rather than doing it one at a time, you can see each of these.<br>所以我们已经看到单括号是这种形式的简化版本。那么让我们来举一些地址计算的例子。让我们假设寄存器RDX将f保存为三个零，而rcx将一个保存为两个零。与其一次做一个，你可以看到每一个。</p><p>发言人   01:05:11<br>I’m taking RDX, which is f with three zeros, adding 8. And so that’s f 0 0 8. Here I’m adding together registers, RDX and rcx, and that gives me F1 thousand. I’m doing the same here, except that I’m scaling rcx by 4. So four times 1, 0 is 4, 0 0, and I’m adding that to f, and here I’m taking RDX, which is f 0 with three zeros. If I double that, I get 1 e with three zeros. If you think about shifting and f to the left one, you get a one, and then it goes 1, 1, 1, 0, and that’s an e, and then I’m adding this displacement of 8, 0 to it.<br>我正在使用RDX，它是带有三个零的f，加上8。所以这就是f 0 0 8。在这里，我将寄存器RDX和rcx相加，这给了我F1千。我在这里做同样的事情，除了我将rcx缩放了4。所以四乘1，0是4，0 0，我把它加到f上，这里我得到RDX，它是带有三个零的f 0。如果我加倍，我会得到1个带有三个零的e。如果你考虑向左移动f，你会得到一个1，然后它会变成1，1，1，0，这就是一个e，然后我将这个位移加上8，0。</p><p>发言人   01:06:01<br>So the point of this is all of this is arithmetic. It’s all using whatever is in the register. And there’s some rules for how you combine this and get an address. And then that’s being used to either read or write some memory location. Okay, so now as a final part of it, today I’ll go through some arithmetic.<br>所以重点是所有这些都是算术。这一切都在使用寄存器中的任何东西。并且有一些规则可以规定如何组合这些并获得地址。然后它被用于读取或写入一些内存位置。好的，现在作为最后一部分，今天我将进行一些算术运算。</p><p>发言人   01:06:26<br>And one of the things that will be sure to confuse you and drive you crazy and make you be sending email to the staff for explanation is an instruction called load effective address. And the reason is its purpose in life is to do basically the ampersand operation of C to compute an address based on some whatever you want to compute an address from. But it also turns out to be a pretty handy way to do arithmetic. And the C compiler likes to use it. So in particular.<br>有一件事肯定会让你感到困惑、让你发疯，并让你向工作人员发送电子邮件进行解释，那就是所谓的加载有效地址说明。原因是它在生活中的目的基本上是做C的 &amp; 运算，根据你想从中计算地址的任何东西来计算地址。但这也证明是一种相当方便的算术方法。而C编译器喜欢使用它。尤其如此。</p><p>发言人   01:07:03<br>The format of it looks like a move instruction. There’s a source and a destination, but the destination has to be a register. And the source will be one of these memory references. So it looks like a move instruction.<br>它的格式看起来像一个移动指令。有一个来源和一个目的地，但目的地必须是一个寄存器。并且来源将是这些内存引用之一。所以它看起来像一个移动指令。</p><p>发言人   01:07:21<br>It looks like you’re doing some address computation, then you’re reading from memory and store to a register. But what it actually does is it does that, avers computation, and then it actually writes that address, not the memory value, but the value that got computed directly to the register, which is what you want to do here.<br>看起来你正在进行一些地址计算，然后你正在从内存读取并存储到寄存器。但它实际上做的是，它会进行计算，然后它实际上将该地址写入寄存器，而不是内存值，而是直接计算所得的值，这就是你想在这里做的。</p><p>发言人   01:07:44<br>Remember, the ampersand operation is give me the address of some place, give me a pointer that designate some location, so for example. X by 12, it’ll turn it into an. Address computation. And this is just a clever way to compute three times RDI adds RDI plus two times RDI. So that’s three times RDI and stores it in Rax. And then cell Q means shift left by two. And so you remember shifting up by two is like multiplying by 4. So the first value computed three times x, I shift that left by two positions, and I have 12 times x. So that’s a very special the Lea, but you’ll see it all over the place. So you need to be ready for it.<br>请记住，&amp; 操作是给我某个地方的地址，给我一个指定某个位置的指针，例如。X乘以12，它会把它变成一个。地址计算。这只是一种计算三次RDI和两次RDI相加的聪明方法。所以这是三次RDI并将其存储在Rax中。然后单元格Q表示向左偏移2。所以你记得，向上移动2就像乘以4一样。所以第一个值计算为x的三倍，我将其左移两个位置，我有12倍的x。所以这是一个非常特别的Lea，但你会在各个地方看到它。所以你需要为此做好准备。</p><p>发言人   01:08:50<br>These other ones look more like what you’d expect for arithmetic instructions. They have names like add and subtract and multiply and so forth, and they all have the same general format that they have two arguments.<br>这些其他的看起来更像你所期望的算术指令。它们的名称像加减法和乘法等等，它们都有相同的一般格式，即它们有两个参数。</p><p>发言人   01:09:04<br>And what’s called the destination is actually also a source. It’s a little like NC if you say x plus equals y, it’s saying take the value of x, add the value of y, and then store the resultant x, and now the destination is like that. The other thing that’s weird is that the operands are in the inverse order from where you’d expect them to be. So the source comes first and the destination comes last. And that’s important to remember. And other thing you’ll see that there’s nothing special here, whether it’s except that this is an arithmetic shift, and this is a logical shift of whether it’s assigned or unsigned value.<br>所谓的目的地实际上也是一个来源。这有点像NC，如果你说x加等于y，它说的是取x的值，加上y的值，然后存储结果x，现在目的地就是这样。另一件奇怪的事情是操作数的顺序与你期望的相反。所以源头是第一位的，目的地是最后一位。这很重要要记住。还有一件事，你会发现这里没有什么特别的，无论是算术移位，还是无符号值的逻辑移位。</p><p>发言人   01:09:48<br>Because you remember the bit level of behavior of these two instructions is the same. And then there’s a series of instructions that are used that are just take one operand, increment, decrement, negate, and not not is like the tilde operation in C, not the ex exclamation mark. So those are the basic instructions.<br>因为您记得这两条指令的行为位级别是相同的。然后有一系列的指令被使用，只需要一个操作数，递增、递减、求反，而不是像C中的波浪符号操作一样，而不是感叹号。这些是基本指示。</p><p>发言人   01:10:15<br>And again, now we can actually look at some programs and understand them. And here’s one that just does a bunch of junk of arithmetic instructions. And it converts into the following assembly code. And you see it’s using this Lea instruction multiple times to do addition in various forms. And it also has shifting and it has multiplication. You saw in the original code, I just have addition and multiplication. Here I have various instructions, I only have one multiplier, whereas I had two there. So the compiler is sort of scrambling things around, trying to find clever ways to implement what you’re asking for using less, less time consuming instructions.<br>再一次，现在我们可以实际查看一些程序并理解它们。这里有一个只是做一堆无用的算术指令的。并将其转换为以下汇编代码。你可以看到它正在多次使用这个Lea指令来以各种形式进行加法。它也有移位和乘法。你在原始代码中看到的，我只有加法和乘法。这里我有各种指令，我只有一个乘法器，而我有两个乘法器。所以编译器有点混乱，试图找到聪明的方法来实现你所要求的更少，更少耗时的指令。</p><p>发言人   01:11:07<br>And if you sort of go through this code carefully, what you’ll find is that this instruction here corresponds to this computation of T 1. It’s adding two values and giving it a new name. It’s putting in rax. Similarly, this one is adding z to T 1, storing it back in Rax.<br>如果你仔细阅读这段代码，你会发现这里的这条指令对应于t1的计算。它将两个值相加，并给它一个新名称。它正在放入rax。同样地，这个是将z添加到t1中，并将其存储回Rax中。</p><p>发言人   01:11:33<br>The x plus 4 doesn’t show up directly here. It turns out what it does is it jumps right ahead here and multiply y by 48. It does it by first computing 3 y, like we saw before, and computing shifting that left by 4, because three times 16 is 48. And then the four here, that’s in x plus 4 actually shows up here. It just uses the displacement field of this computation to add 4 to some other values. And so this is labeled. And these comments show how these correspond to the program, and these registers show it.<br>这里没有直接显示x加4。事实证明，它所做的就是跳到这里，然后将y乘以48。它首先计算3 y，就像我们之前看到的那样，然后将其向左移动4，因为3乘16是48。然后这里的四个，即x加4实际上显示在这里。它只是使用此计算的位移场将4添加到其他一些值。所以这被标记了。这些注释显示它们如何与程序相对应，这些寄存器显示它。</p><p>发言人   01:12:14<br>So the important thing to get from here, you will want to actually go back through this and make sure you believe the comments are correct, but it’s very important for you to figure out this Lea instruction. Otherwise you’re just going to be hopelessly confused. And it’s also important to understand that the code that gets generated will correctly implement your C function, but it might not exactly replicate at a low level the exact sequence of operations he specified at a high level. So that will just to summarize then, you’ve already gotten a glimpse then of what this very odd, a world of machine programming is and how different it is from C code already.<br>因此，从这里得到的重要的事情是，您需要实际返回并确保您相信注释是正确的，但对您来说，弄清楚这个Lea指令非常重要。否则你只会感到无可救药的困惑。而且同样重要的是要理解生成的代码将正确实现您的C函数，但它可能无法在低级准确复制他在高级指定的操作序列。所以这只是为了总结一下，你已经瞥见了这个非常奇怪的机器编程世界是什么，以及它已经与C代码有多么不同。</p><p>发言人   01:13:03<br>So you’ve already seen that x 86 is weird. Like I said, it’s English ISS, Latin, it’s not. Well designed. And but you just got to deal with that. So that’s your beginning to machine level programming, thanks a lot.<br>所以你已经看到了x86是奇怪的。就像我说的，这是英语，拉丁语，它不是。设计得很好。但你只需要处理这个问题。这就是你开始机器编程的起点，非常感谢。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深入理解计算机系统 004-Floating Point</title>
    <link href="/2025/10/12/15213-004/"/>
    <url>/2025/10/12/15213-004/</url>
    
    <content type="html"><![CDATA[<p>发言人   00:01<br>Good afternoon, everybody. Welcome, it’s good to see you. So today we’re going to study an arcane area of computer systems known as floating point, which is the way that computer systems represent the real numbers. So you’re all familiar with decimals, something like 3.14. And there’s a similar idea with binary numbers. So what does a fractional binary number like 1 0 1, 1.101 represent? And how does that work? Well, it works just like the de fractional decimal numbers that you’re used to.<br>大家下午好。欢迎，很高兴见到你。所以今天我们要研究计算机系统中的一个神秘领域，称为浮点，它是计算机系统表示实数的方式。所以你们都很熟悉小数，比如3.14。二进制数也有类似的想法。那么像1 0 1，1.101这样的小数二进制数代表什么？这是如何运作的？它的工作原理就像你习惯的小数十进制数一样。</p><span id="more"></span><p>发言人   01:05<br>So you have, in this case, it’s a binary point. And to the left of the binary point, you have bit positions, so representing powers of 2, so 2 to the 0, 2 to the 1, 2 to the two. So one half of 1, 2, 4, and so on. And to the right of the binary point, you have two to the minus one, one half, 2 to the -2, 1, 4, 2 to the -3, 1 8th, and so on. So we can represent any fractional binary number using this notation where we sum.<br>所以在这种情况下，它是一个二进制点。在二进制点的左侧，您有位位置，因此代表2的幂，因此2对0，2对1，2对2。所以，1、2、4的一半，以此类推。在二进制点的右侧，有两个到负一，二分之一，2到-2，1，4，2到-3，1 8，依此类推。因此，我们可以使用这种求和符号来表示任何分数二进制数。</p><p>发言人   01:53<br>The bit at position k times 2 to the k, so it really works exactly the same way as with base 10, just with base 2.<br>位置k的位乘以2到k，因此它的工作方式与以10为基数的方式完全相同，只是以2为基数。</p><p>发言人   02:09<br>So let’s look at some of these. Values so 5 and 3 quarters, we would represent as 111.11. This is before plus 1 is five one half plus one quarter. So 2&#x2F;4 plus 1&#x2F;4 is three quarter. So 5. And 3&#x2F;4. So that’s pretty simple. Two and 7&#x2F;8 is 10.1110. Is two, of course, and then .111 is one half. So 4&#x2F;8 plus 1&#x2F;4 2&#x2F;8 plus 1&#x2F;8, so 7&#x2F;8. And one seven sixteenths. Would be 1.0111 so that the one to the left of the binary point is one. And then we have one fourth plus one 8th plus one 16th. So one 1&#x2F;4 is 4&#x2F;16. One 8th is 2&#x2F;16 and one 16th. So you add those up, you get 7&#x2F;16.<br>让我们来看看其中的一些。值为5和3个季度，我们表示为111.11。这是在加1是5二分之一加四分之一之前。所以2&#x2F;4加上1&#x2F;4就是四分之三。所以5。和3&#x2F;4。所以这很简单。2和7&#x2F;8是10.1110。当然是2，然后.111是一半。所以4&#x2F;8加1&#x2F;4 2&#x2F;8加1&#x2F;8，所以是7&#x2F;8。一七六分之一。将是1.0111，这样二进制点左边的就是一。然后我们有四分之一加八分之一加十六分之一。所以一个1&#x2F;4是4&#x2F;16。一个8是2&#x2F;16，一个16。所以你把它们加起来，你得到7&#x2F;16。</p><p>发言人   03:50<br>Now notice for some of these numbers, this bit pattern, 1, 0, 1.11, if we shift it to the right to get one, 0.111, we’ve divided by two. So we’ve taken 5 and 3&#x2F;4 and divided it by 2. And it works the other way too. If you to the left, you multiply, you shift to the left by one, you multiply by one. And these numbers that are all ones to the right of the binary point are these are numbers that are just slightly less than one. And so we want to represent those.<br>现在请注意其中一些数字的位模式，1，0，1.11，如果我们将其向右移动以获得1，0.111，我们已经被2除了。所以我们取了5和3&#x2F;4，并将其除以2。它也以另一种方式工作。如果你向左，你乘以，你向左移动一，你乘以一。这些数字都是二进制点右侧的一，这些数字只是略小于一。所以我们想要代表他们。</p><p>发言人   04:36<br>We’ll often, we’ll sometimes refer to those numbers of that form as 1 minus epsilon. And epsilon just depends on how many bits you have to the right of the binary point. So epsilon gets smaller, the more, the more of those bits you have, or it gets closer to one. And epsilon gets smaller, the more of those bits you have.<br>我们经常，我们有时会把这种形式的数字称为1-epsilon。而epsilon只取决于二进制点右边有多少位。因此epsilon越小，你拥有的那些位就越多，或者它接近一个。当epsilon变小时，你拥有的这些位越多。</p><p>发言人   05:01<br>Now there’s. Limitations in this kind of representation. First of all, we can only represent rational numbers of the form x divided by two to the k, we can only represent numbers of that form exactly. Other numbers have to have repeating bit representations that can’t be represented with a finite number of bits that we have in a computer system. So for example, things like one third is this repeating representation, one fifth and one 10th, or other examples of that.<br>现在有了。这种表现方式的局限性。首先，我们只能表示形式为x除以二得到k的有理数，我们只能精确地表示该形式的数字。其他数字必须有重复的位表示，而这些位表示不能像计算机系统那样用有限数量的位表示。例如，三分之一是重复表示，五分之一和十分之一，或其他例子。</p><p>发言人   05:40<br>Now, the other problem we have is that we can only, there’s only so many bits to the left and the right of the binary point. If we move the binary point to the left, then we don’t have as many. We can’t represent as many large numbers. We can only represent small numbers, but we have more precision to the right of the binary point. So we can represent more fractional values. Just the range of those values will be much smaller. Similarly, if we move the binary point to the right, we’ll have a larger range of values, but we won’t be able to represent as many fractions. So there’s this kind of trade off.<br>现在，我们面临的另一个问题是，我们只能在二进制点的左边和右边只有这么多位。如果我们将二进制点向左移动，那么我们就没有那么多了。我们无法表示太多的数字。我们只能表示小数，但我们在二进制点右侧有更多的精度。这样我们就可以表示更多的分数值。只是这些值的范围会小得多。同样地，如果我们将二进制点向右移动，我们将拥有更大的值范围，但我们将无法表示尽可能多的分数。所以就有这种权衡。</p><p>发言人   06:28<br>And a floating point is a representation that enables us to move that, basically to move that binary point to represent sort of as wide a range as possible with as much precision, given the number of bits, the finite number of bits that we have to work with. So the float and floating point is this sort of shifting binary point, this floating, floating binary point. Now, up until 19, floating point was just a disaster, and every computer manufacturer had their own representation. You couldn’t. And it was just terrible because you couldn’t predict what would happen if you moved your program from one machine to another. The behavior would be different, the rounding would be different. It was a very difficult situation. And people really, computer scientists in particular, really dislike floating point.<br>浮点是一种表示形式，使我们能够移动它，基本上移动该二进制点以表示尽可能宽的范围和尽可能高的精度，给定位数，我们必须使用的有限位数。所以浮点数和浮点数就是这种移动的二进制点，这种浮动的、浮动的二进制点。现在，直到19年前，浮点运算只是一场灾难，每个计算机制造商都有自己的代表。你做不到。这真的很可怕，因为你无法预测如果你将程序从一台机器移动到另一台机器会发生什么。行为会不同，舍入也会不同。这是一个非常困难的情况。而人们，特别是计算机科学家，真的不喜欢浮点运算。</p><p>发言人   07:36<br>In 1985, IEEE, which is the professional association Electrical Engineers introduced. And it’s also a very important standards body. They introduced a standard floating point representation called IEEE floating point, which was then adopted by all computer manufacturers. So now the situation is much better. Everybody supports the same kind of floating point representation, which is what we’re going to learn about today.<br>在1985年，IEEE，这是专业协会电气工程师的介绍。它也是一个非常重要的标准机构。他们引入了一种称为IEEE浮点的标准浮点表示形式，随后被所有计算机制造商采用。所以现在的情况好多了。每个人都支持相同类型的浮点表示，这就是我们今天要学习的内容。</p><p>发言人   08:15<br>So the floating point has the form. It represents numbers in. This is like a scientific notation. It represents numbers of the form -1 to the s, where s is a sine debt. Times a significant m times 2 to some exponent e, so all of the numbers that we can represent in floating point have to be represented in this form.<br>所以浮点数的形式是。它代表数字。这就像一种科学计数法。它代表形式为-1的数字到s，其中s是正弦债务。将一个有效的m乘以2到某个指数e，因此我们可以用浮点数表示的所有数字都必须以这种形式表示。</p><p>发言人   08:53<br>So the sine bit s determines whether the number is negative or positive. Obviously, the significant m, so this is sometimes called the mantissa, which is where the M comes from. The significant m normally is a fractional value in the range between one and 2. And we’ll see the way that is in a second. And then the exponent e weights the value by some power of two.<br>所以正弦位s决定数字是负数还是正数。显然，有效m，有时也被称为尾数，即M的来源。有效m通常是介于1和2之间的分数值。我们将在一秒钟内看到它的样子。然后指数e对该值加权2的幂。</p><p>发言人   09:21<br>So this is encoded in either 32 b or 64 b in the following way. The sine bit s is the most significant bit. And then this is followed by some number of. Bits called the Exp field, which encodes the exponent E, but it’s not identical to E, it encodes E, and we’ll see how that works. And then that’s followed, the remaining bits are the frack field, which encodes them but isn’t identical to them. Now IEEE.<br>所以这按以下方式编码为32 b或64 b。正弦位s是最重要的位。然后这个后面跟着一些数字。位被称为Exp字段，它对指数E进行编码，但它与E不同，它对E进行编码，我们将看到它是如何工作的。然后，剩下的位是frack字段，它对它们进行了编码，但并不完全相同。现在，IEEE。</p><p>发言人   10:05<br>Floating point has provides two different kinds. Floating point, there’s single precision, 32 b and so called double precision, which is 64 b. There’s this funky Intel extended precision, which is non-standard and we won’t talk about it anymore. And so in the single precision 32 b, you have one sine bit. There’s always a sine bit, you have 8 Exp bits, and you have 23 frac bits. In double precision, you have 11 Exp bits, 52 frac bits.<br>浮点提供了两种不同的类型。浮点，有单精度32 b和所谓的双精度，即64 b。有一个时髦的英特尔扩展精度，这是非标准的，我们不再谈论它了。所以在单精度32 b中，你有一个正弦位。总是有一个正弦位，你有8个Exp位，还有23个frac位。在双精度中，您有11个Exp位，52个frac位。</p><p>发言人   10:43<br>Now, there’s a number of different kinds of floating point representations, The default and sort of the common representation is called normalized, so called AED normalized values. And normalized values are all the values where the Exp field is not equal to 0 and not equal to all zeros and not equal to all ones. All zeros and all ones are special kinds of numbers we’ll look at in a second.<br>现在，有许多不同种类的浮点表示形式，默认和常见的表示形式被称为归一化，即所谓的AED归一化值。规范化值是Exp字段不等于0且不等于全部零且不等于全部一的所有值。所有零和所有一都是特殊类型的数字，我们一会儿就会看到。</p><p>发言人   11:19<br>So the exponent, this exponent e, remember our numbers are -1 to the power s times m times 2 raised to the power e, the exponent e is encoded as this biased value, which is called Exp. So the exponent e is Exp. Minus some bias and Exp is the value capital. Exp is the value of the Exp bits. The bits in the Exp field treated as a positive number. So capital Exp is just you just look at it as an unsigned.<br>所以指数e，记住我们的数字是-1的幂s乘以m乘以2的幂e，指数e被编码为这个偏差值，称为Exp。所以指数e是Exp。减去一些偏见和Exp是价值资本。Exp是Exp位的值。Exp字段中的位被视为正数。所以资本出口只是你把它看作是一个未签名的。</p><p>发言人   12:06<br>7 b in case of single precision, 7 b number. Now the bias is 2 to the power k -1 -1, where k is the number of exponent bits. So for single precision. We have 8 exponent bits, so 2 to the 8th, two to the 8 -1 is seventh. So 2 to the 7th is 128 -1 is 127. So the bias for a single precision is 127. And similarly, for double precision, it’s 1023. So you just have to memorize this formula.<br>在单精度的情况下，7 b是一个7 b的数字。现在的偏差是2的幂次k -1，其中k是指数位数。所以对于单精度。我们有8个指数位，所以2的8次方，2的8 -1是第七位。所以2的7是128 -1是127。因此，单精度的偏差为127。同样，对于双精度，它是1023。所以你只需要记住这个公式。</p><p>发言人   12:55<br>The exponent e is the Exp field interpreted as an unsigned number minus the bias.<br>指数e是被解释为无符号数字减去偏差的Exp字段。</p><p>发言人   13:05<br>Now, this is kind of a strange thing. The first time you encounter a floating point, it seems kind of odd, so why not? I mean, we’ve already learned about two’s complement, that’s a perfectly fine way to represent positive and negative numbers. And we have exponents that are negative and positive. So why not just use the Exp field to represent? Or why not just use tooths complement in the Exp field to represent those positive and negative exponents, right? So it turns out that the reason that they do this. That, and if you think, think about this and we’ll come back to it.<br>现在，这是一件奇怪的事情。当你第一次遇到浮点时，它看起来有点奇怪，为什么不呢？我的意思是，我们已经学习了2的补码，这是表示正数和负数的完美方法。我们有负的和正的指数。那么为什么不直接使用Exp字段来表示呢？或者为什么不在Exp字段中使用tooths补码来表示那些正负指数，对吧？所以事实证明他们这样做的原因。如果你想的话，想想看，我们会回到这个问题上。</p><p>发言人   13:50<br>But if we encode the exponent e using this bias representation, the smallest negative exponent is represented by all zeros. And the largest exponent is represented by? Zero, 1, 1, 1, 1. So the number with the smallest.<br>但是如果我们使用这种偏差表示对指数e进行编码，最小的负指数将由全部零表示。并且最大指数由表示？零，1。所以最小的数字。</p><p>发言人   14:21<br>Exponent, if we were just to compare the bits using just some kind of unsigned representation, just comparing the bits, treating it as an unsigned number, by using this biased representation, we can just compared to floating point numbers, just as we can treat the whole floating point number as an unsigned integer and compare two numbers and get a true comparison. So the exponent uses this sort of biasing encoding.<br>指数，如果我们只是使用某种无符号表示来比较位，只是比较位，将其视为无符号数字，通过使用这种偏置表示，我们可以将其与浮点数进行比较。就像我们可以将整个浮点数视为无符号整数并比较两个数字并获得真正的比较一样。指数使用这种偏置编码。</p><p>发言人   14:56<br>And then the significant is encoded with an implied one. So, and this is where the, this is where the normalized and the normalized representation comes from that we’re always going to represent our numbers. So m, we’re always going to normalize m, no matter what the number we want to represent, we’re always going to normalize m as one point something, and then we adjust the exponent accordingly. So if the value we want to represent is 100.01, we’re going to shift it over and it’ll be 1.00. And then we’ll adjust the exponent to represent that shift.<br>然后，意义被隐含地编码。所以，这就是规范化和规范化表示的来源，我们总是要表示我们的数字。所以，我们总是要归一化m，无论我们想要表示什么数字，我们总是要将m归一化为一个点，然后相应地调整指数。因此，如果我们想要表示的值是100.01，我们将把它转移过来，它将是1.00。然后我们将调整指数以表示该转变。</p><p>发言人   15:48<br>So the bits in the Frac field Xxxxx are all of the numbers to the right of the binary point’s always implied one, but we don’t even encode it. We just throw it away because it’s always there. So this is a little trick just to get it one more bit for free. So the XXX bits in the frac field, all the bits to the right of the binary point after one point, the one point. And so the smallest frac field is all zeros, which corresponds to a sign of 1.0. And a frack field, of all ones, corresponds to 2 minus epsilon. So that’s 1.11111, and so on.<br>因此，Frac字段Xxxxx中的位是二进制点右侧的所有数字，但我们甚至没有对其进行编码。我们只是把它扔掉，因为它总是在那里。所以这是一个小技巧，只是为了免费获得它。所以在frac字段中的XXX位，在一个点之后的二进制点右边的所有位，一个点。因此，最小的frac字段全是零，对应于1.0的符号。一个压裂井，所有的一，对应于2减去epsilon。所以这是1.11111，依此类推。</p><p>发言人   16:49<br>So let’s look at an example. So let’s look at how we would encode 15, 2, and 13, which our favorite number in floating point. So if we represent that, so it’s an integer and we represent it using these bits, take my word for it, correspond to it, the integer are 213. So now we want to convert it. We want to normalize it. By expressing it as 1.110 and so on, times 2 to the 13th, same number, we just normalized it so that there’s always this leaving one. So the significant M? Is 1.11011 and so on.<br>让我们来看一个例子。那么让我们来看一下如何对我们最喜欢的浮点数15、2和13进行编码。因此，如果我们表示它，那么它是一个整数，我们使用这些位表示它，相信我的词，对应于它，整数是213。所以现在我们想要转换它。我们想要将其正常化。通过将其表示为1.110等，乘以2到13号，相同的数字，我们只是对其进行了标准化，以便总是留下一。那么重要的M？是1.11011，依此类推。</p><p>发言人   17:47<br>The frac field is everything to the right of the binary point. So we throw this one away and we just take the values to the right of the binary point. And then we padded out with zeros to get the 23 b that we need for single precision. So now we’ve got our frac field, the exponent.<br>frac字段是二进制点右侧的所有内容。所以我们把这个扔掉，我们只需要取二进制点右边的值。然后我们用零填充以获得单精度所需的23 b。所以现在我们有了我们的压裂字段，指数。</p><p>发言人   18:14<br>So in this case, e is we’re multiplying by two to the 13. So e is 13. So we want to represent the value 13 using this biased encoding. So the bias is 127. And so the exponent, the value, the value of the Exp field should be 140.<br>在这种情况下，e是我们乘以2得到13。所以e是13。所以我们想用这种偏置编码来表示值13。所以偏差是127。因此指数，值，Exp字段的值应该是140。</p><p>发言人   18:42<br>Because if we take, if we take 140 -127, we get 13. So 140 is represented using these 8 b, and that becomes our Exp field. So the resulting floating point number, and of course, it’s a positive number, so the sine bit is 0. So the resulting floating point number has the 8 b in Exp field that we computed by subtracting 127 from 140. And then the frac field are these bits that we got here by just taking everything to the right of the binary point.<br>因为如果我们取140 -127，我们得到13。所以140用这些8 b来表示，这就成为了我们的Exp字段。所以得到的浮点数，当然它是一个正数，所以正弦位是0。因此，结果浮点数在Exp字段中有8 b，我们通过从140中减去127来计算。然后frac字段是我们通过将所有东西都带到二进制点右侧而得到的这些位。</p><p>发言人   19:33<br>So? So let’s look at this exponent just a little bit more because I think can be a little confusing. So in our example.<br>所以呢？所以让我们再看看这个指数，因为我认为可能会有点困惑。在我们的例子中。</p><p>发言人   19:56<br>If we want to look at the range of Exp. So what’s the smallest value of Exp? What’s the smallest value of Exp? Now wait, man, don’t confuse the encoding with the value it represents. Exp is just the encoding. So what’s the smallest value of Exp? Zero, that’s right. And the largest value is what? What’s the largest value? Well, the largest value would be, remember, it can’t be all ones. So the largest value would be 2 to the 8th -1. So the largest value would be 0, 1, 1, 1, 1, 0, followed by seven ones. So that’s 2 to the 8th -1 is. 255, good.<br>如果我们想看Exp的范围。那么Exp的最小值是什么？Exp的最小值是什么？现在等待，伙计，不要将编码与它所代表的值混淆。Exp只是编码。那么Exp的最小值是什么？零，没错。最大的价值是什么？最大的价值是什么？好的，最大值应该是，记住，它不能全是一。因此，最大值将是第8个-1的2。所以最大值将是0，1，0，其次是七个。所以这是2的8次方-1。255，好的。</p><p>发言人   21:15<br>So then what’s the range then of e, which is the actual value that we want to encode? Okay, remember we have this definition. So we have the range of values for Exp. We have our bias. So what is the range of values for E? This is the actual exponents that we’re encoding. So what’s the smallest exponent -127, good? Because that’s 0 is our smallest DXP minus the bias, which is 127. So the smallest value of e is 127, and the largest value of e is.<br>那么e的范围是什么，我们想要编码的实际值是什么？好的，记住我们有这个定义。所以我们有Exp的值范围。我们有偏见。那么E的值范围是什么？这是我们正在编码的实际指数。那么最小指数是什么？127，好吗？因为0是我们的最小DXP减去偏差，即127。所以e的最小值是127，而e的最大值是。</p><p>发言人   22:09<br>So if we take the largest value of Exp, that’s 255 -127. 128. So the numbers that we can represent using this bias notation, we’ll have the smallest exponent will be 2 to the -127, and the largest exponent will be 2 to the raise to the power 128. You see what’s going on here? So we have, we have a range of values for e, here’s the largest value, here’s the smallest value, here’s zero right in the middle. These are the values we want to represent. This bias thing is like a ship, we’ve just now we’re shifting up by 127 so that now the smallest exponent is represented by zero. Any questions about that?<br>所以，如果我们取Exp的最大值，即255 -127。128.因此，我们可以使用这种偏差表示法表示数字，我们的最小指数将是-127的2，最大指数将是128的幂次幂的2。你看到这里发生了什么了吗？所以我们有，我们有一系列的值，这是最大值，这是最小值，这是中间的零。这些是我们想要代表的价值观。这种偏见就像一艘船，我们刚刚向上移动了127，现在最小的指数由零表示。有什么问题吗？</p><p>发言人   23:24<br>Now, these normalized values always have this implied one, which when we want to represent numbers closer to 0, that limits us. So there’s another type of floating point number called the denormal nomal has value, which is characterized by an Exp field of all zeros. And in a denormalized number or D norm, there’s no. Implied one. So the significant M is represented exactly, is encoded identically in the frac field. So there’s no implied one. And all of the numbers are the form zero point something, something, something after that.<br>现在，这些规范化的值总是有这个隐含的值，当我们想要表示接近0的数字时，这限制了我们。因此，还有另一种类型的浮点数，称为非正规正规拥有值，其特征在于所有零的Exp字段。在非规范化数或D范数中，没有。暗示了一个。因此，有效M被精确地表示，在frac字段中以相同的方式编码。所以没有任何暗示。所有的数字都是形式零点，某个东西，然后是某个东西。</p><p>发言人   24:22<br>In the exponent value e, instead of you, remember for D norms, we subtracted bias from Exp. For D norms, we subtract the bias from one. Now, if we just use the definition we use for normalized numbers, that would be the Exp would be 0. So we don’t do that instead. E is one minus the bias. And then the significant is coded with an implied leading 0 instead of a leading one, like I mentioned. So when Exp is 0, and also, I mean, think about it, if we only had denormalized numbers, we wouldn’t be able to represent 0 because there’d always be a one in there. So D norms allow us to represent 0, and they allow us to represent values that are very close to 0.<br>在指数值e中，代替你记住，对于D规范，我们从Exp中减去了偏见。对于D规范，我们从一个中减去偏见。现在，如果我们只使用我们用于规范化数字的定义，则Exp将为0。所以我们不这样做。E是一减去偏差。然后，像我提到的那样，重要信息被编码为隐含的前导0而不是前导0。所以当Exp为0时，同时，我的意思是，想想看，如果我们只有非规范化的数字，我们将无法表示0，因为那里总是有一个1。因此，D范数允许我们表示0，并且它们允许我们表示非常接近0的值。</p><p>发言人   25:24<br>So when the exponent is 0 and the Exp field is 0 and the frac field is 0, then this is the zero value. And so this is nice because all zeros represents 0, which is sort of what you want.<br>因此，当指数为0，Exp字段为0，frac字段为0时，则这是零值。所以这很好，因为所有的零都代表0，这正是你想要的。</p><p>发言人   25:40<br>Now, there is this sort of weird thing, though, that if you have the sine bit. Is one and then you’re fracking and exp or 0, Then you have negative 0. So you have this kind of odd situation where there’s a positive and negative 0. And other values, if Exp is 0 and you have a non-zero frac, then those are the equally spaced numbers that are closest to 0. Now, there’s a couple of other special values when Exp is all ones and the frac is all zeros, this represents the value infinity. So this is a value that we get when we do some kind of addition or multiplication and we overflow. So floating point always overflows to the special value called infinity, the positive or negative infinity.<br>现在，有这种奇怪的事情，如果你有正弦位。是一，然后你正在压裂和exp或0，那么你有负0。所以你会遇到这种奇怪的情况，有一个正的和负的0。和其他值，如果Exp为0并且您有一个非零的frac，则这些是最接近0的等间距数字。现在，当Exp全为一，而frac全为零时，还有一些其他的特殊值，这表示值无穷大。所以这是当我们进行某种加法或乘法并溢出时获得的值。所以浮点数总是溢出到称为无穷大的特殊值，正的或负的无穷大。</p><p>发言人   26:40<br>So it’s different from two’s complement, right? You sort of overflow in this modular way. Just back around into the range of numbers in floating point, we just overflow to the sticky value called infinity. And then everything we do on that remains infinity. So for example, if we did a. If we did one divided by zero or -1 divided by -0, we’d get positive infinity. If we divide one by 0, negative zero, we get negative infinity.<br>所以它不同于2的补语，对吧？你会以这种模块化的方式有点溢出。回到浮点数的数字范围，我们只是溢出到称为infinity的粘性值。然后我们所做的一切都是无限的。例如，如果我们做了一个。如果我们用一除以零或-1除以-0，我们将得到正无穷大。如果我们将一除以0，负零，我们得到负无穷大。</p><p>发言人   27:22<br>The fourth kind of special case, special number, is the case where the exponent again is all once, but the frac is nonzero in a nonzero value. And this represents what’s called not a number. This handles cases where there’s no answer, there’s no feasible answer. For example, try to take the square root of -1. What we’ll get back is not a number.<br>第四种特殊情况，特殊数字，是指指数再次全部为一次，但在非零值中frac是非零的情况。这代表所谓的非数字。这处理没有答案的情况，也没有可行的答案。例如，尝试取-1的平方根。我们要得到的不是数字。</p><p>发言人   27:56<br>So I think it’s helpful to visualize the number line now. So we have positive 0, negative zero right next to each other. And then to the right of that are the positive D norms. And then those sort of transition into the normalized numbers. And then you have infinity, positive infinity of a similar, similar situation for the negative numbers. And then negative and positive, not a numbers.<br>所以我认为现在将数线可视化是有帮助的。所以我们有正零，负零紧挨着。然后在它的右边是积极的D规范。然后这些过渡到归一化的数字。然后你有无穷大，负数的类似情况的正无穷大。然后是负面的和正面的，而不是数字。</p><p>发言人   28:41<br>So I think you’ve probably discovered now that a really good way to try to understand these numeric encodings is two examples with only a few number of bits.<br>所以我想你现在可能已经发现，理解这些数字编码的一个非常好的方法是使用只有几个位数的两个示例。</p><p>发言人   28:53<br>If you want to understand, for example, in tooth’s complement, if you want to understand T in and T Ma and how they relate to each other, just do a 3 b 2 S complement system. Imagine just have a system with two S complement, 3 b, and then you can just enumerate all the possibilities and you can see, and then you see where the TN is actually one greater than T max. So if you add one to T max, it actually overflows into T min. Similar thing for floating point. It’s I would really encourage you to do this.<br>如果你想理解，例如，在牙齿补语中，如果你想理解T和T马某某以及它们之间的关系，只需做一个3 b 2 S补语系统。想象一下，有一个具有两个S补码的系统，3 b，然后你可以枚举所有的可能性，你可以看到，然后你可以看到TN实际上比tmax大一的地方。所以如果你向T max加上1，它实际上会溢出到T min。浮点数也有类似的情况。我真的会鼓励你这样做。</p><p>发言人   29:32<br>Just try some simple examples with a small number of Exp and frac bits. So in this case, we’re going to look at a floating point system based on IEEE that has four Exp bits and 3 frac bits. As always, the sine bit is the most significant bit, followed by Exp, followed by Freck. So this is identical to IEEE floating point, except for the size of the Exp in frac fields. So it’s actually small enough that we can now just enumerate these values.<br>只需尝试使用少量的Exp和frac位的简单示例。所以在这种情况下，我们将看一个基于IEEE的浮点系统，它有四个Exp位和三个frac位。与往常一样，正弦位是最高有效位，其次是Exp，然后是Freck。所以这与IEEE浮点数相同，除了在frac字段中Exp的大小。所以它实际上足够小，我们现在可以枚举这些值。</p><p>发言人   30:13<br>And now you can start to see why these weird definitions for the exponent in D norms in normalized numbers. So let’s just look at. So what we’ve done here with a sine bit of 0, we’ve just enumerated all of the two to the seventh possibilities, possible combinations of Exp and frac fields starting with 0. So when Exp is all zeros, that’s a D norm by definition. And then we have the three frac bits are all 0.<br>现在你可以开始明白为什么在归一化数字中D范数指数的这些奇怪定义了。那么让我们来看看。所以我们在这里用0的正弦位做了什么，我们只是列举了所有两种到第七种可能性，从0开始的Exp和frac字段的可能组合。因此，当Exp全部为零时，根据定义，这是一个D范数。然后我们有三个frac位都是0。</p><p>发言人   31:02<br>So remember, the Exp is all zeros for D norms. The exponent value is one minus the bias. Our bias here is 7. So 1 -7 gives us a value for the exponent of -6. So we’re going to take the Fra. The bits in the frack field times. So m is 0. So m in this case, is zero times 2 to the minus sixth gives us 0. So this is our representation of 0. And like I said, it’s really, it’s nice that it actually is if we just treated this as an unsigned integer, it would be 0. So that’s kind of pleasing.<br>所以记住，Exp对于D规范都是零。指数值是一减去偏差。我们的偏见是7。所以1 -7给我们一个-6指数的值。所以我们要采取Fra。压裂现场中的钻头时间。所以m是0。在这种情况下，所以m，零乘2到负六分之一给我们0。所以这是我们对0的表示。就像我说的，这真的很好，如果我们把它当作一个无符号整数，它将是0。所以这有点令人愉悦。</p><p>发言人   31:55<br>Now let’s look at the very next number. The Exp is still 0, and we’ve just bumped up frac by one. So again, it’s one minus the bias, which is -6, and now this frac field represents this is one half, one quarter, one 8th, it represents, so this is a value of m is one 8th. So one eighth times 2 to the -6, which is one 64 equals 1 over $512. So in this floating point system, the smallest nonzero number we can represent is the denormalized representation of one over 512, The next smallest number is 0.<br>现在让我们看看下一个数字。Exp仍然是0，我们刚刚将frac提高了1。所以再说一遍，它是减去偏差，即-6，现在这个frac字段代表这是二分之一，四分之一，八分之一，它代表，所以这是一个m的值是八分之一。所以八分之一乘2到-6，也就是64等于1超过512美元。因此在这个浮点系统中，我们可以表示的最小非零数字是512之上的非规范化表示，下一个最小的数字是0。</p><p>发言人   32:46<br>OK, now at so let’s bump this up by one. So now we get a, we get a frac field of 0, 1, 0. So this represents one quarter. So em is one quarter, the significant is one quarter times 2 to the -6. So 2&#x2F;8 times one 64th is 2 to the 5 TS, the numbers were just by increment. This, by incrementing, are significant.<br>好的，现在到了，让我们把这个提高一个。所以现在我们得到一个，我们得到一个为0，1，0的frac字段。所以这代表四分之一。所以em是1&#x2F;4，有效值是1&#x2F;4乘以2的-6。所以2&#x2F;8乘以1 64次方是2的5次方，这些数字只是递增的。这个，通过增量，是重要的。</p><p>发言人   33:22<br>We’re increasing the numbers by one over 512. Now, the largest D norm in this number system is the case where the frac field is all ones, and so this encodes 1&#x2F;2 plus one four-h plus one 8th, which is 7&#x2F;8, and then our value is seven eighths times 2 to the -6, or 1 over 64. That equals 7 5 TS, so this 7 over 512 S is the largest denormalized number we can represent in this system.<br>我们将数字增加一到512。现在，这个数字系统中最大的D范数是frac字段全部为一的情况，因此它编码为1&#x2F;2加1个4h加1个8%，即7&#x2F;8，然后我们的值是八分之七乘以2的-6，或者1乘以64。这等于7 5 TS，所以这个7 over 512 S是我们在这个系统中可以表示的最大非规范化数。</p><p>发言人   34:04<br>And now if we bump our number up by one, the frac field resets to 0, and now the exp field goes from 0 to 1.<br>现在，如果我们将数字增加1，则frac字段将重置为0，现在exp字段将从0变为1。</p><p>发言人   34:19<br>Now, because the Exp field is nonzero, this is no longer a denormalized number. It’s a normalized number. So now we’re changing the definition of E from one minus the bias to Exp minus the bias. So what’s Exp in this case? One -7, the bias is -6. So lo and behold, it’s the same. It’s the same exponent as the previous denormalized number. So this is actually very clever by the IEEE folks, because you get this nice, smooth transition from D norms to norms to normalize. So you can see that our exponent e is -6 still. And now? Because we’re taking one minus the bias 7 and are significant.<br>现在，由于Exp字段非零，这不再是一个非规范化的数字。这是一个标准化的数字。所以现在我们将E的定义从1减去偏差更改为Exp减去偏差。在这种情况下，Exp是什么？1-7，偏差为-6。所以你瞧，它是一样的。它的指数与之前的非规范化数字相同。因此，这实际上是由IEEE人非常聪明的，因为你可以得到从D规范到规范的顺利过渡。所以你可以看到我们的指数e仍然是-6。现在呢？因为我们取1减去偏差7并且是显著的。</p><p>发言人   35:29<br>Now, remember, this is a normalized number because the Exp field is nonzero. A frack field of all zeros represents a significant of 1.000. So this is number is the most normalized number.<br>现在，记住，这是一个规范化的数字，因为Exp字段是非零的。所有零的frack字段表示有效值1.000。所以这个数字是最规范化的数字。</p><p>发言人   35:51<br>Represents is 1.000, which is 8, 8 times 2 to the -6, which is one over 64, which gives us 8 over 512. So we’ve made this nice smooth transition from seven over five and 12 to 8 over 512. And I’ll do one more. So if keeping the Exp field at 1, if we bump our frac field from 0 to 1, now this represents the sign of 1.0, 1.001, which is 8&#x2F;8 plus one 8th. So that’s 9, 8. And then the value is eighth times 2 to the. Minus six. Once 1 over 64, which is equal to 9 over 512, okay? Any questions about that?<br>代表的是1.000，即8乘以2的-6，即1比64，这给我们8比512。所以我们已经完成了从7&#x2F;5和12到8&#x2F;512的顺利过渡。我还会做一个。因此，如果保持Exp字段为1，如果我们将frac字段从0提升到1，现在这代表1.0，1.001的符号，即8&#x2F;8加1&#x2F;8。所以这是9，8。然后该值是8乘2的。-6。一旦1超过64，就等于9超过512，好吗？有什么问题吗？</p><p>发言人   37:01<br>Question back here. Okay, the question is, why do you choose the bias that to be 2 to the k -1 -1?<br>问题回到这里。好的，问题是，为什么你选择的偏差是2到k -1？</p><p>发言人   37:12<br>Go back to my finger diagram here. So this is the range of Exp fields that you want to. This is the range of e that you want to represent with 0 in the middle. And so you want to bias it so that this is halfway 0. The smallest exponent is halfway to 0. So you want the bias to shift it up. So it’s the smallest, the smallest encoded. The smallest value of Exp corresponds to the smallest exponent, so two to the k -1 -1 is just giving you, it’s giving you a value that’s halfway between the smallest exponent and the largest exponent, okay? That’s good, any other questions?<br>回到这里我的手指图。所以这是您想要的Exp字段范围。这是您想要用中间的0来表示的e的范围。所以你想要偏差它，使它的一半为0。最小的指数是0的一半。所以你想让偏见向上移动。所以它是最小的，最小的编码。Exp的最小值对应于最小指数，所以k -1的2只是给你，它给你一个介于最小指数和最大指数之间的值，好吗？很好，还有其他问题吗？</p><p>发言人   38:07<br>OK, if we take like a little, a smaller 6 b format, same thing as we did before, just different numbers of bits and Exp and frac. And then we plot these on the number line. You can see that. The values are very dense, around 0. So they’re very spaced very closely together. And then every time you increase the exponent by one.<br>好的，如果我们采用一个较小的6 b格式，就像之前一样，只是不同的位数、Exp和frac。然后我们将它们绘制在数字线上。你可以看到。这些值非常密集，在0左右。所以它们之间间隔得非常紧密。然后每次将指数增加一。</p><p>发言人   38:36<br>The numbers are spaced twice. Twice as far apart as the numbers that were represented by the previous exponent. So you can see like in this little example, you see these values here are all equally spaced. Well, these four values are equally spaced, and they’re right next to each other. And then you see this jump in the spacing that represents an increase in the Exp field by one. And then that spacing doubles as we go out. And you can see, you can see it even better here. If we zoom in, these blue values are, these blue values are D norms.<br>这些数字的间距为两倍。距离是之前指数所表示数字的两倍。所以你可以看到，在这个小例子中，你可以看到这里的这些值都是等距的。这四个值是等间距的，它们紧挨着。然后你会看到这个间隔的跳跃，它代表了Exp字段增加了一个。然后，当我们外出时，间隔加倍。你可以看到，你可以在这里看得更好。如果我们放大，这些蓝色值是D范数。</p><p>发言人   39:30<br>And then we have the next set of normalized values where the frac field is one, There’s the same. We saw this when we kept increasing by one over five. And then we increase the exponent by one, and the spacing doubles.<br>然后我们有了下一组规范化值，其中frac字段是一个，它们是相同的。当我们不断增长1比5时，我们看到了这一点。然后我们将指数增加一，间距就会翻倍。</p><p>发言人   39:54<br>So like I mentioned, this encoding has some pretty nice properties. The floating point 0 is encoded as integer of 0, which is nice, and with the exception of. Not a number. With the exception of not a number, you can compare any floating point numbers, including infinity, by just treating it as doing an unsigned comparison. So that’s really nice too.<br>就像我提到的，这种编码有一些非常好的特性。浮点0被编码为0的整数，这很好，除了。不是一个数字。除了不是数字外，您可以将任何浮点数 (包括无穷大) 进行比较，只需将其视为进行无符号比较。这也很不错。</p><p>发言人   40:33<br>Now, if when you add and multiply floating point numbers, we’re dealing with a limited set of bits here. So if we take two numbers, encode it as floating point, and we add them together, there’s no guarantee that we’ll be able to fit all those bits in the bits we have available to us. There’s no guarantee that we’ll be able to fit the bits in the result. So what? So what we do in this case is you can imagine the model. You want to have a floating point operations addition and multiplication is that you add or multiply, you do the addition or multiplication, and you compute the exact result.<br>现在，如果当您将浮点数相加和相乘时，我们在这里处理的是有限的一组位。因此，如果我们将两个数字编码为浮点数，然后将它们相加，则不能保证我们能够将所有这些位都放入我们可用的位中。不能保证我们能够将位拟合到结果中。那又怎样？所以在这种情况下，我们所做的是你可以想象模型。你想要进行浮点运算加法和乘法，就是你做加法或乘法，然后计算确切的结果。</p><p>发言人   41:16<br>You just assume that you have an infinite amount, number of bits. And then you use a technique called rounding to get it to fit into the available bits. So the effect is doing, say, x plus y is getting the precise value of x plus y and an infinite number of bits, and then rounding into the available bits.<br>你只是假设你有无限的数量，位数。然后您使用一种称为四舍五入的技术来使其适应可用位。这样的效果就是，比如说，x加y是得到x加y的精确值和无限数量的位，然后四舍五入到可用位。</p><p>发言人   41:42<br>So let’s look at this idea of rounding. This can be confusing the first time you see it. It requires you need to think about it carefully to get it right. Now in IEEE, there’s four different kinds of rounding round towards 0 round down, or round to minus infinity round up, which is rounding it to positive infinity. And then the default case, which is the only one we’re really going to consider, is round to the nearest even. And this is what IEEE does by default. If you go into assembly language, you can change that rounding. But we’re not going to consider it anymore. Yes, question?<br>那么让我们来看看舍入的想法。这可能会让你第一次看到它感到困惑。它要求你仔细思考才能把它做好。现在在IEEE中，有四种不同的舍入为0舍入，或舍入为负无穷大舍入，即舍入为正无穷大。然后默认情况，也就是我们真正要考虑的唯一情况，是舍入到最接近的偶数。这就是IEEE默认做的事情。如果你进入汇编语言，你可以改变那个舍入。但我们不会再考虑它了。是的，有问题吗？</p><p>发言人   42:32<br>I’m sorry, is there negative in there? Is because one, so the question, is there a distinct negative infinity and a distinct positive infinity? And there is, they have the exact same bit representation, except the most significant bit for negative infinity is one, and for positive infinity, it’s zero.<br>抱歉，里面有负面的吗？是因为一个，所以问题是，是否存在明显的负无穷大和正无穷大？而且它们有完全相同的位表示，除了负无穷大的最高有效位是一，正无穷大的最高有效位是零。</p><p>发言人   43:00<br>White is nearest even. Oh I’ll show you. Let me go over the other. The question was about nearest Stephen. Yes, doesn’t that make nitrogen greater than, well, that was the exception right? Today? That’s right, so aside from infinity, you can’t do that comparison, positive infinity works right, but not negative, so you’re right, good point.<br>白色最近均匀。我来给你看看。让我超越另一个。这个问题是关于最近的斯蒂芬的。是的，这不是使氮大于，好吧，那是个例外，对吗？今天？这是对的，所以除了无穷大之外，你不能进行比较，积极的无穷大起作用，但不是消极的，所以你说得对，很好。</p><p>发言人   43:26<br>Alright, so let’s look at these rounding modes and I’ll explain why the nearest even works, but let’s look at so rounding towards 0, what we’re going to do, we’ll use dollars. So we went around to the nearest dollar. Towards 0. Just anything less than you. Just round towards 0. So 1 dollar 40 cent would go to 1, 1 dollar 60 cent would go down to one, 1 dollar 50 to 1, 250 would go to two, negative 150, you round towards 0. So that would be negative one round down towards negative infinity. It’s similar. The only difference is that for one point negative one dollar 50, you’d round towards negative infinity, which would be -2.<br>好的，让我们来看看这些舍入模式，我将解释为什么最接近的偶数有效，但让我们看看向0舍入，我们将要做什么，我们将使用美元。所以我们绕到最近的美元。向0。只是比你更少的东西。就向0圆。所以1美元40美分会降到1美元，1美元60美分会降到1，1美元50到1，250美元会降到2，负150，你四舍五入到0。所以这将是负的，向下舍入负的无穷大。这很相似。唯一的区别是，对于1美元50的负点数，你会四舍五入到负无穷大，这将是-2。</p><p>发言人   44:15<br>Rounding up is the is symmetric to round down. The interesting case is. Round to nearest even interesting because it’s what IEEE floating point actually uses. So the idea here, if you have a value that’s less than half, then you round down. If you have a value that’s more than halfway between 2 dollar amounts, you round up. The nearest Even part comes. When you have something that’s exactly halfway, then what you do is you round towards the nearest even number.<br>向上舍入是对称到向下舍入。有趣的案例是。舍入到最接近甚至有趣的，因为这就是IEEE浮点实际使用的。所以这里的想法是，如果你有一个小于一半的值，那么你就四舍五入。如果你的价值超过2美元金额的一半，你就四舍一入。最近的偶数部分出现了。当你有一个正好一半的东西时，你要做的是朝最近的偶数四舍五入。</p><p>发言人   45:00<br>In this example, 1 dollar 40 cent because it’s less than half rounds down to 1 dollar 1 dollar 60 cents is greater than half.<br>在这个例子中，1美元40美分因为不到半个舍入到1美元60美分大于一半。</p><p>发言人   45:10<br>So we round up to 2 dollars, one dollar 50 cent, right in the middle, we round up to the nearest even dollar amount, which is 2 dollars, 2 dollars 50 cents. We round down to the nearest. Even if we rounded up, it would be 3, which is odd number and -1 dollar 50 cents. We round to we round down to -2 dollars. So the reason we do this, the reason they chose this is that statistically, you would imagine if you have a uniform distribution of sort of numbers, they’re going to round up or down about 50% of the time. So there won’t be a statistical bias rounding up or down one way or the other. So that’s the reason they did that.<br>所以我们四舍五入到2美元，1美元50美分，就在中间，我们四舍五入到最接近的偶数美元金额，也就是2美元，2美元50美分。我们四舍五入到最近的。即使我们四舍五入，它也会是3，这是奇数和-1美元50美分。我们四舍二入到-2美元。所以我们这样做的原因，他们选择这个的原因是统计学上的，你会想象如果你有一个均匀的数字分布，它们会有50% 的时间向上或向下四舍五入。这样就不会有一个统计偏差向上或向下舍入或另一种方式。这就是他们这么做的原因。</p><p>发言人   46:06<br>Now you can apply this. You can do this rounding to any value. So in the last example, we did it to the nearest dollar.<br>现在你可以应用这个了。您可以将其舍入为任何值。所以在最后一个例子中，我们把它做到了最接近的美元。</p><p>发言人   46:17<br>But suppose we wanted to round to the nearest 100th using round to even the default round to even mode. So we went to round to the. Nearest hundredth is the second position.<br>但是假设我们想使用默认的偶数模式将其舍入到最接近的100个。所以我们去了轮。最近的百分之一是第二个位置。</p><p>发言人   46:34<br>First, do we have tenths? Then hundreds? So if we have a value 7.894999, that’s less than halfway, right? Halfway would be halfway, would be any number that had a five, followed by all zeros. So 4 999 is less than that. So we would just round down to 7.89, even though 9 is odd. The only time we’re going to apply round to even is when we’re exactly halfway. Okay, the next example, 7.895001, that’s greater than halfway. If if this was a 0, it would be exactly halfway, so we round up to 7.9. Now here’s the interesting case where we have 7.895 followed by all zeros. That’s exactly halfway. So now we apply the round to nearest even rule.<br>首先，我们有十分之一吗？然后是几百个？所以如果我们有一个值7.894999，那就不到一半，对吗？一半将是一半，将是任何有五个数字，后面都是零。所以4 999比这少。所以我们将舍入到7.89，即使9是奇数。我们唯一一次要申请到甚至是在我们刚好完成了一半的时候。好的，下一个例子7.895001，比一半大。如果这是一个0，它正好是一半，所以我们四舍五入到7.9。现在这里有一个有趣的情况，我们有7.895后面都是零。这就是一半。所以现在我们将舍入应用到最近偶数规则。</p><p>发言人   47:43<br>Nine is an odd number, so that doesn’t work. So we round up and we do that basically by adding, adding a five here. So 5 and 5 is 10, and then that carries over to the next position, and 9 and 1 is 0, 9 and 1 is 10, so that carries over. And so 8 and 8 plus 1 is 9. So the result of rounding up is 7.90. Is that clear that you see, it’s a very mechanical way when you round up, it’s a very mechanical like that, You always just add the half-way number, in this case 5, and then just propagate it out, just do the addition, and that’ll give you the nearest, the nearest, that’ll round you up to the nearest 100th in this case.<br>9是一个奇数，所以这不起作用。所以我们向上四舍五入，基本上是通过添加来完成的，在这里添加五。所以5和5是10，然后这延续到下一个位置，而9和1是0，9和1是10，所以延续。所以8加1就是9。所以四舍五入的结果是7.90。你看得很清楚，当你向上取整时，这是一种非常机械的方式，它是一种非常机械的方式，你总是把一半的数字相加，在这种情况下是5，然后把它传播出去，只是做加法。这会给你最近的，最近的，在这种情况下，这将把你四舍五入到最接近的100个。</p><p>发言人   48:39<br>Now the last case, 7.885, followed by all zeros, that’s another number that’s halfway between. Between two numbers rounded to the nearest 100. So in this case, 8 is even. So we round down. And to round down, we just truncate, just throw bits, these digits away, and we get 7.88.<br>现在是最后一种情况，7.885，后面跟着全零，这是另一个介于两者之间的数字。在两个舍入到最接近的100的数字之间。所以在这种情况下，8是偶数。所以我们四舍五入。而为了向下舍入，我们只需要截断，只扔掉这些数字，我们得到7.88。</p><p>发言人   49:08<br>So are there any questions about this? Question Beck here, yes. But so is it true that everything was the same components?<br>那么对此有什么问题吗？问题贝克在这里，是的。但是，一切都是相同的组件，这是真的吗？</p><p>发言人   49:28<br>Yes, so the question was, numbers that have the same Exp field, will those numbers be equally spaced on the number line? And the answer is yes. Yes? Down. Like in the? Last, it would round up. Yeah, the only the half-way values are always in this case, because it’s base 10, the half-way number in base 10 is 5, and so it’s always the half-way number, in this case, 5, followed by all zeros. You always have the halfway. If the value is halfway between like 200, it’ll always have that, that form.<br>是的，那么问题是，具有相同Exp字段的数字，这些数字会在数字线上等距分布吗？答案是肯定的。是吗？下来。像在？最后，它会四舍五入。是的，在这种情况下，唯一的中途值始终是，因为它是以10为基数，以10为基数的中途数是5，因此它始终是中途数，在这种情况下是5，后面跟着全部零。你总是半途而废。如果该值介于200之间，它将始终具有那种形式。</p><p>发言人   50:26<br>Alright, now we can do the same thing with binary fractional numbers as well. Now a binary number is even if. Least significant digit is 0. We only have two digits. So odd is one and 0 is even and the halfway. So the half-way value is going to be a one followed by all zeros that represents exactly halfway. So it’s analogous, analogous to the base 10 example, except where the half-way value is going to be one followed by all zeros.<br>好的，现在我们也可以对二进制分数做同样的事情。现在二进制数是偶数。最小有效数字为0。我们只有两个数字。所以奇数是一，0是偶数，一半是。因此，半途值将是一个后跟所有零的数字，正好表示半途值。所以它是类似的，类似于以10为基数的例子，除了中途值将是一个后面全是零的地方。</p><p>发言人   51:08<br>So let’s look at some examples. Suppose we have, we want to represent 2 in three and 30 seconds. And suppose we only have 4 b to do that in, Okay, well, to represent that exactly, we need. 7 b. And so we have to round. So let’s look at, so we’re going to round to this 2 b, right, of the binary point. And so let’s look at all the bits that follow that. So since it starts with 0, this is going to be less than halfway. So since it’s less than halfway, we just truncate, just chop those out, and the result is 1.00.<br>让我们看一些例子。假设我们有，我们想要在3和30秒内表示2。假设我们只有4 b来完成这件事，好的，要准确地表示出来，我们需要。7 b.所以我们必须绕圈。那么让我们来看看，我们将四舍全为二进制点的这个2 b。那么让我们来看看它后面的所有位。因为它从0开始，所以这将小于一半。所以由于它不到一半，我们只需截断，切掉它们，结果就是1.00。</p><p>发言人   52:06<br>Now our next example is 1 0.00110. So if we look at these, the bits to the right of to the right of the bit we’re rounding to, since it starts with one and it’s not followed by all zeros, that’s greater than half. In this case, we have to round up and so. The way we do that, we take one and we add it to this leftmost one right here and just do the addition. And the result is 1.01.<br>现在我们的下一个例子是1 0.00110。所以如果我们看这些，我们四舍五入到的位右边的位，因为它从1开始并且后面没有全部零，那就大于一半。在这种情况下，我们必须四舍一入。我们这样做的方式是，取一个并将其添加到最左边的一个上，然后进行加法。结果是1.01。</p><p>发言人   52:48<br>Now let’s look at 2 to the 7 eights. This is represented as one 0.11100.<br>现在让我们来看看2的7个八点。这被表示为一个0.11100。</p><p>发言人   52:58<br>Now here’s that halfway marker that we were looking for. It’s a 1 followed by all 0. So this is exactly halfway. So now we have to round to the nearest even number. If we can’t just truncate, because then it would be an odd number, it would end one, 0.11 is an odd number. So we have to round up. And we do that by adding, we do that by adding a one right here to this leftmost red bit. We add one to that, and then just do the addition. And we end up with 1 1.00, which is 3. So the nearest value to 2 to the 7th, 8th, the nearest rounded value is 3.<br>现在这是我们正在寻找的半个标记。它是一个1，后跟全部0。所以这正好是一半。所以现在我们必须四舍五入到最接近的偶数。如果我们不能仅仅截断，因为它将是一个奇数，它将以1结束，0.11是一个奇数。所以我们必须围捕。我们通过添加来实现这一点，我们通过在最左边的红色位上添加一个来实现这一点。我们加一个，然后做加法。最后我们得到1.00，也就是3。所以最接近2的值到第7，第8，最接近的舍入值是3。</p><p>发言人   53:54<br>Okay, our last example, 2 to the 5 A’s, we have the same halfway marker again, 1, 0, 0, but in this case, the hundredth bit or the one quarter bit is 0. So that’s even. So we can just truncate, we just throw those bits away, and the result is simply one 0.10. It makes sense, so it’s very mechanical. Mainly, you just need to be able to recognize that halfway marker and then figure out if you need to round up or down. If you’re going to round down, just truncate. If you’re going to round up, add a 1 and just propagate it to get your result.<br>好的，我们的最后一个例子，2到5个A，我们再次有相同的中途标记，1，0，但在这种情况下，百分之一位或四分之一位是0。所以这是均匀的。所以我们可以截断，我们把那些位扔掉，结果只是0.10。它制造感知，所以非常机械化。主要来说，你只需要能够识别中途标记，然后弄清楚你是否需要向上或向下舍入。如果你要向下舍入，只需截断即可。如果你要向上舍入，加一个1，然后传播它来得到你的结果。</p><p>发言人   54:40<br>Okay? Now, we won’t spend much time. I just want to mention a few things about multiplication and addition.<br>好吗？现在，我们不会花太多时间。我只想提一些关于乘法和加法的事情。</p><p>发言人   54:51<br>So if we multiply two numbers, so we have different mantissa significance and exponents. And suppose that the result is. M times 2 to the e, the sine bit will be the Xor of the two sine bits, the 2 operons. The significant M will be multiplying M1 times M2, and the exponents are added just by the rules of exponents. So if m is, if m is greater than 2, and this is a normalized number, we have to. Put it in the range between one and two by shifting to the right and incrementing the exponent. If e is out of range, then we overflow to infinity. And then if m has too many bits, we have to use round to even to fit it into the available frac bits.<br>所以如果我们将两个数相乘，那么我们有不同的尾数重要性和指数。假设结果是。M乘以2的e，正弦位将是两个正弦位 (两个操作数) 的Xor。有效M将乘以M1乘以M2，指数仅按指数规则相加。因此，如果m是，如果m大于2，并且这是一个规范化的数字，我们必须这样做。通过向右移动并增加指数，将其放在一到二之间。如果e超出范围，那么我们将溢出到无穷大。然后，如果m有太多位，我们必须使用舍入甚至以使其适应可用的frac位。</p><p>发言人   55:58<br>Addition, So suppose we’re trying to add to floating point numbers. Conceptually, what you do is think of those numbers as fractional binary numbers. Line up the binary points, line up the binary points, then do the addition and. And then do the addition and then normalize the number so that the normalize the significance so that it’s between one and 2. And either do that by shifting right or left. If E’s too big, then you overflow, and then you round the bits in M to fit into the available frac field.<br>另外，假设我们试图将浮点数相加。从概念上讲，你要做的就是将这些数视为分数二进制数。将二进制点排成一行，将二进制点排成一行，然后进行加法和。然后进行加法，然后对数字进行归一化，以便对其重要性进行归一化，使其在1到2之间。要么向右或向左移动。如果E太大，那么您将溢出，然后您将以M为单位对位进行舍入以适合可用的frac字段。</p><p>发言人   56:46<br>Now, remember when the first day of class, we talked about what we call these great realities, that ints aren’t really integers and floats aren’t really reals. And just as we saw when we looked at two’s complement representation of integers, it’s not exactly, they’re not exactly like real integers, and operations on them aren’t exactly like real integers. But they follow very predictable mathematical properties that are similar to integers, but not quite. So the same thing holds for floating point numbers. They follow very predictable, They have very predictable mathematical properties, but they’re somewhat different from the reals. And the big thing is that the big thing with addition is that it doesn’t associate it’s commutative, but it’s not associative. And this usually happens you when you’re dealing with numbers that have very large dynamic ranges.<br>现在，还记得第一天上课的时候，我们谈到了我们称之为伟大现实的东西，整数并不是真正的整数，浮动也不是真正的现实。就像我们在查看整数的补码表示时看到的那样，它不完全是，它们不完全像实整数，对它们的操作也不完全像实整数。但它们遵循非常可预测的数学属性，类似于整数，但不完全是。这同样适用于浮点数。它们遵循非常可预测的数学属性，但它们与雷亚尔有些不同。重要的是加法的重要之处在于它不关联它是可交换的，但它不是关联的。这通常发生在您处理具有非常大的动态范围的数字时。</p><p>发言人   57:57<br>If you’re trying to add and subtract really big numbers with really little numbers, you run into this problem of non-associative. So the example was if we take 3.14 plus to the 10th to the 10th is so much larger than 3.14 that when the it be 2 to the 10th plus three 0.14, the bits that represent the 3.14, there’s bits way out here that represent there’s 1 b out here that represents 2 to the 10th, and then there’s a few bits here that represent 3.14. And there’s just not we don’t have enough bits to represent all those 3.14 goes away.<br>如果你试图用非常小的数字进行非常大的数字相加和相减，你会遇到这个非关联的问题。所以这个例子是，如果我们取3.14加上第10到第10，比3.14大得多，以至于当它是2到第10加上三个0.14时，代表3.14的位，这里有一些位元代表这里有1个b，代表2的第10个。然后这里有几个位代表3.14。我们没有足够的位来表示所有这些3.14消失了。</p><p>发言人   58:43<br>So adding a big number to a little number essentially gives the big number. And then if you subtract that big number, you get 0. Now, if we change the association, if we take this big number and subtracted it from itself, we get 0. And then so the result will be instead of 0 before we get 3.14. So other than that, you have all of the things that you would normally expect closed under addition. It’s commutative. There’s an additive identity of 0, except for infinities and Nans. There’s an additive inverse you can take for any number. There’s an inverse that’ll give you zero when you add it together and you get monetisation. Monotonicity between values, except of course, for infinities and Nans.<br>因此，将一个大的数字添加到一个小的数字上，本质上就给出了大的数字。然后，如果你减去那个大数字，你得到0。现在，如果我们改变关联，如果我们取这个大数字并从中减去它，我们得到0。然后，在我们得到3.14之前，结果将不是0。除此之外，你拥有了所有你通常期望在加法下关闭的东西。它是可交换的。有一个0的加法恒等式，除了无穷大和Nans。对于任何数字，你可以取一个加法逆。有一个反函数，当你把它加在一起时，它会给你零，你就会赚钱。值之间的单调性，当然除了无穷大和Nans。</p><p>发言人   59:41<br>Now multiplication has it’s similar. You get it’s closed generally under multiplication. It’s communicating, but it’s not associative, and it doesn’t distribute over addition, and it’s the same.<br>现在乘法已经相似了。你得到它通常在乘法下是封闭的。它在交流，但它不是联想的，它不会在加法上分布，它是一样的。</p><p>发言人   59:58<br>So here you can see we’re taking two to the 20th times 2 to the 20th times 2 to the 20th, so that gives infinity. But if we re-associate and we take I’m sorry to the times 2 to the 20th times 2 to the minus 20th, well, this first multiplication is infinity. And anything, anything you do with infinity is just infinity. So the result is infinity. However, if we reassociate and multiply two to the 20th times 2 to the minus 20th, that gives us one. And then multiply by two to the 20th, and so we get two to the 20th. So the big takeaway point here is that floating point. Floating point is an associative.<br>所以在这里你可以看到我们把2的20次方乘以2的20，这样就得到了无穷大。但是如果我们重新关联，并且我们抱歉地将2乘以20次方2乘以-20，那么，第一次乘法是无限的。你用无穷大做的任何事情都是无穷大。所以结果是无限的。然而，如果我们重新关联并乘以2的20次方乘以2的负20次方，就得到1。然后乘以2到20号，这样我们得到2到20号。所以这里的主要要点是浮点数。浮点是联合的。</p><p>发言人   01:00:52<br>Now, is that a problem? It’s something you have to be aware of. But generally, I mean I’ve done a lot of scientific computing, in particular modeling earthquake ground motion in Southern California. So basically we would build models of Southern California in the computer and then we would shake them, and then we would see how the ground moves in like Los Angeles. And that shaking, we used a numerical method called finite elements, and it used all floating point, single precision floating point numbers. And we never ran into a problem with this associativity.<br>现在，这有问题吗？这是你必须意识到的事情。但总的来说，我的意思是我已经做了很多科学计算，特别是在南加州地震地面运动的建模方面。所以基本上我们会在计算机上建立南加州的模型，然后我们会震动它们，然后我们会看到地面如何像洛杉矶一样移动。在那个震动中，我们使用了一种称为有限元素的数值方法，它使用了所有的浮点数，单精度浮点数。我们从来没有遇到过这种关联性的问题。</p><p>发言人   01:01:36<br>We would do operations in different orders. We couldn’t always guarantee that we would do the operations in the exact same order, but we never ran into a problem with this because nature in general is kind of smooth that if you look at the if one part of the ground is shaking like this and you look at the next part, it might be shaking a little more or a little less, but you’re not going to have like huge differences. And so we never ran into those kind of problems. But in some, so generally, if you’re simulating natural phenomena, you don’t often see these kind of huge dynamic ranges. But other times, if it’s not non-natural financial, maybe financial systems that use floating point, then you might see the larger dynamic ranges of numbers and it might become a problem. So as a programmer, you just generally have to be aware of this. You have to have a sense for the dynamic range of your numbers. And you have to keep in mind that if you re-associate or change the order of things, you may not get exactly the same, exactly the same answer.<br>我们会以不同的顺序进行操作。我们不能总是保证我们会以完全相同的顺序进行操作，但我们从来没有遇到过这个问题，因为自然界一般是比较平滑的，如果你看一下地面的一部分像这样摇晃，你再看看下一部分，它可能会摇晃得更多或更少，但你不会有太大的差异。所以我们从来没有遇到过这种问题。但在某些情况下，一般来说，如果你在模拟自然现象，你通常不会看到这些巨大的动态范围。但其他时候，如果它不是非自然金融系统，也许是使用浮点数的金融系统，那么你可能会看到更大的数字动态范围，这可能会成为一个问题。所以作为一名程序员，你通常必须意识到这一点。你必须有一个数字动态范围的感知。你必须记住，如果你重新关联或改变事物的顺序，你可能不会得到完全相同的答案。</p><p>发言人   01:02:46<br>Now c gives us two different kinds of floating points. So the float is the IEEE single precision and double is the IEEE double precision.<br>现在c给了我们两种不同类型的浮点数。所以浮点数是IEEE单精度，double是IEEE双精度。</p><p>发言人   01:02:58<br>Now, you remember when we did casting between ints and unsigned values back and forth, the cast never changed the bit representation, it just changed the way that, and in fact, it never even changed. How the Alu manipulated those bits. It’s really just how we’re interpreting and how we’re viewing those, those values. However, when you do casts between floats and ints and doubles, the bit representation changes. So a cast here has a dramatic effect on the actual bits themselves.<br>现在，你还记得当我们在int和unsigning值之间来回转换时，转换从未改变位表示，它只是改变了方式，事实上，它甚至从未改变。Alu是如何操纵这些比特的。这实际上只是我们如何解释和如何看待这些价值观。然而，当您在浮点数、整型和双精度值之间进行转换时，位表示会发生变化。所以这里的演员对实际的比特本身有戏剧性的影响。</p><p>发言人   01:03:35<br>Now, if we go from a double or a float to an int, it’s going to truncate the fractional part and give us the. Give us the integer part and then round to fit. Oh, actually, no, there won’t be. Okay, so think about this, how many there were. We said 23. 23 frac bits in.<br>现在，如果我们从double或float转到int，它将截断小数部分并给我们。给我们整数部分，然后舍入以适合。哦，实际上，不会有。好的，想想看，有多少人。我们说23。23个压裂位。</p><p>发言人   01:04:16<br>I forget exactly how many in doubles. Anybody remember? It doesn’t matter, it’s some number. Well, no, it does matter. So for a float, if we cast a float to an int, we’re casting 23, something that we can represent with 23, at most 23 frac bits into a 32 b in. So we’ll never lose. So we’ll never need to do any rounding.<br>我忘记双打中有多少。有人记得吗？没关系，这是一个数字。好吧，不，这很重要。对于一个浮点数，如果我们将一个浮点数转换为int，我们将转换23，我们可以用23来表示的东西，最多23个frac位转换为32 b in。所以我们永远不会输。所以我们永远不需要进行任何舍入。</p><p>发言人   01:04:55<br>But double precision?<br>但是双重精度？</p><p>发言人   01:05:01<br>Has 52 b. So there we might not be able to fit the represented integer into the int. So they’ll have to be some rounding.<br>有52个b。因此，我们可能无法将表示的整数放入int中。所以它们必须四舍五入。</p><p>发言人   01:05:44<br>Sorry PowerPoint crashed.<br>抱歉，PowerPoint崩溃了。</p><p>发言人   01:06:23<br>Right now, if we cast, if we cast from an int to a double. We’ll have enough bit so we won’t lose anything, right? The 32 b will fit in the double precision frac field, but int to float, there’s more bits than an int than there are in the frac field of a float. We’ll have to do some rounding. So so casting works the same way as any other operation. You can think of it as just taking the assume. You have an infinite number of bits, get the exact result, and then round it to fit into the available bits. All right, so the final thing I want to do today is.<br>现在，如果我们进行强制转换，如果我们从int转换为double。我们会有足够的，所以我们不会失去任何东西，对吧？32 b将适合双精度frac字段，但从int到float，比float的frac字段中的位数更多。我们必须做一些舍入。所以铸造的工作方式与任何其他操作相同。你可以把它想象成只是假设。你有无限数量的比特，得到确切的结果，然后将其舍入以适应可用的比特。好的，所以今天我想做的最后一件事是。</p><p>发言人   01:07:11<br>Sort of test your understanding. Solve some puzzles to test your understanding of these properties of floating point numbers. So imagine that we have three values, x is an, f is a float, and d is a double. And then we’re evaluating the c expressions. Is x equal to int float x?<br>有点考验你的理解力。解决一些难题，以测试您对浮点数的这些属性的理解。想象一下我们有三个值，x是an，f是浮点数，d是双精度。然后我们评估c表达式。x等于整数浮点x吗？</p><p>发言人   01:07:46<br>Or you can edit out the, you can edit out that other stuff.<br>或者你可以编辑掉，你可以编辑掉其他的东西。</p><p>发言人   01:07:57<br>So what do you think? So if we take x, which is an int, cast it to a float, and then cast that back to an int, will that always be equal to x? No, because we lose some bits, right? We don’t have enough frac bits in float. What about if we take x, cast it to a double, and then cast it back to end where we always get equivalent value? Because we have enough frac bits in double.<br>你觉得呢？所以，如果我们取x，它是一个int，将其强制转换为一个浮点数，然后将其强制转换回一个int，这是否总是等于x？不，因为我们丢失了一些比特，对吧？我们在浮点数中没有足够的frac位。如果我们取x，将其转换为双精度值，然后将其转换回结尾，我们总是得到等价的值，那会怎么样？因为我们有足够的双倍frac位。</p><p>发言人   01:08:35<br>Now, what if we take a float F, cast it to a double, and then cast it back to a float? Will that always equal the original F? Yeah, what about the converse though? What if we take the double D, cast it to a float, and cast it back to a double no? How about this, how about if we take f, negate it, and then negate that again? Will that always equal f? Because we’re just toggling a bit?<br>现在，如果我们取一个浮点数F，将其强制转换为双精度浮点数，然后再将其强制转换回浮点数会怎么样？这将始终等于原始F吗？是的，那么反过来呢？如果我们把double D转换成float，再把它转换回double no，会怎么样？这个怎么样，如果我们取f，否定它，然后再否定它，怎么样？这总是等于f吗？因为我们只是稍微切换一下？</p><p>发言人   01:09:06<br>Okay, how about two over three equal 2 over 3.0? No, because two over three is 0 and two over 3.0 is a floating point value, two thirds, the floating point representation of two thirds.<br>好的，三比二等于3.0怎么样？不，因为三的二分之一是0，而三的二分之一是浮点值，三分之二是浮点表示。</p><p>发言人   01:09:26<br>How about if the double d is less than 0? Does that imply that d times 2 is also less than 0 no matter what? Even if two times d overflows, it’ll overflow to negative infinity, which is less than. Which is less than 0? OK, how about does the double d greater than f imply that minus f is greater than minus d? Yeah, that’s that monotonicity. And again, it’s just, yes, 3.0 was a float.<br>如果double d小于0怎么办？这是否意味着无论如何，d乘以2也小于0？即使两次d溢出，它也会溢出到负无穷大，小于。哪个小于0？好的，双d比f大，这意味着负f比负d大吗？是的，这就是单调性。再说一遍，是的，3.0是浮动的。</p><p>发言人   01:10:06<br>Is that a float or a double? Oh, that’s a good question. I think it’d be a floated. I think if you put there’s an annotation in C to give it a double, but actually I’d have to check that out. And F, yeah, that’s a good question. I don’t know, we’d have to check. I’ll have to go and look in the In the Sea guide.<br>那是一个浮子还是一个替身？哦，这是个好问题。我认为它会是一个浮动的。我想如果你在C中输入一个注释来给它一个双倍，但实际上我必须检查一下。和F，是的，这是一个好问题。我不知道，我们必须检查一下。我得去找一本海上指南。</p><p>发言人   01:10:39<br>How about is d squared the double d squared always greater than or equal to 0? Yes, and how about does d plus f minus d always equal f? No, because of lack of associativity. Okay, so that was fun, right? Floating point’s always fun. So anyway, the big thing is just to realize that floats aren’t exactly really reals. They have very predictable properties and that they’re not associative or they’re not associative. And so you have to be careful about that. All right, we’ll a good weekend and we’ll see you on Tuesday.<br>Dsquared的双dsquared总是大于或等于0吗？是的，那么d加f减d总是等于f呢？不，因为缺乏关联性。好吧，那很有趣，对吧？浮点运算总是很有趣。所以无论如何，最重要的事情就是意识到花车并不完全真实。它们具有非常可预测的特性，并且它们不是联想的或者它们不是联想的。所以你必须小心这一点。好的，我们周末会很愉快，我们将在礼拜三见。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深入理解计算机系统 003-Bits,Bytes,andInteger</title>
    <link href="/2025/10/12/15213-003/"/>
    <url>/2025/10/12/15213-003/</url>
    
    <content type="html"><![CDATA[<p>2025年10月02日 08:32<br>发言人   00:00<br>I guess one thing I and the rest of the staff request is that you, whenever you have a question, you first read the book and then you re-read the assignment, and you maybe reread it again. And then you ask us, because a lot of the questions we’re getting are ones where we just say, look at this page of the book, look at this paragraph, the assignment, look at this part of the file that you were given. And so, I mean, there’s a lot of stuff. And I understand how sometimes it’s easy to miss things, not saying don’t ever ask questions, but just before you ask your questions, try and figure out if I really sort of come through the resources I have available to see if the answer to my question can be found there. So anyways, enjoy the lab.<br>我猜我和其他员工要求的一件事是，每当你有问题时，先读这本书，然后再读一遍任务，也许再读一遍。然后你问我们，因为我们得到的很多问题都是这样的: 看看书的这一页，看看这一段，看看你被分配的文件的这一部分。所以，我的意思是，有很多东西。我理解有时候很容易错过事情，不是说永远不要问问题，但在你问问题之前，试着弄清楚我是否真的通过现有的资源来找到我问题的答案。所以无论如何，享受这个实验室。</p><span id="more"></span><p>发言人   00:55<br>So today is sort a second part of a two part lecture on integers and integer arithmetic.<br>今天是关于整数和整数算术的两部分讲座的第二部分。</p><p>发言人   01:02<br>Last time we looked at representations about how bit patterns can be interpreted as either unsigned numbers, meaning they range between 0 and 2 to the word size -1, or as twos complement numbers, which is the most usual way to represent what are sometimes called sine numbers, ones that can be either negative or positive. And by the way, there are other ways to represent sign numbers out there. Tooth complement is so overwhelmingly the most used system that that’s what we concentrate on today. What we’ll do is now go beyond the representations of these values to talk about arithmetic operations on them and some of their properties. And what we’ll do in general is talk about the unsigned case, which is in some ways easier to understand and more intuitive. And then talk about the two’s complement case.<br>上次我们看了关于位模式如何被解释为无符号数字的表示，这意味着它们的范围在0和2之间，或者作为二进制补码数字，这是表示有时被称为正弦数字的最常用方法。可以是负面的也可以是正面的。顺便说一下，还有其他的方法来表示符号数字。牙齿补足是绝大多数最常用的系统，这就是我们今天关注的重点。我们现在要做的是超越这些值的表示，讨论对它们的算术运算和它们的一些属性。一般来说，我们会谈论未签名的情况，这种情况在某些方面更容易理解，也更直观。然后谈论两者的补充情况。</p><p>发言人   02:03<br>So the basic rule on this is if you take two numbers that range between up to the maximum value of an unsigned number and you add them, then in principle, you might need to get an extra bit to represent that sum If you want to represent the true sum, the sort of integer sum of those two numbers, because you’re doubling it. And unfortunately, we can’t just go out and add more bits to your computer indefinitely. So we just stop it at some point and say, well, whatever happen to be in that sort of next over bit position? We’re just going to drop it and pretend it doesn’t exist and say that the result of addition is just whatever the W bit pattern you get if you only consider the first w bits out of it with no warning, no messages, no error or anything. This is just it happens silently.<br>因此，基本规则是，如果您将两个范围在无符号数字最大值之间的数字相加，那么原则上，如果您想表示真实的总和，您可能需要获得额外的位来表示该总和。这两个数字的整数和，因为你正在加倍它。不幸的是，我们不能无限制地向您的计算机中添加更多的位。所以我们只是在某个时候停止它，然后说，好吧，无论发生在那种下一个比特位置的是什么？我们只是要放下它，假装它不存在，并说如果你只考虑其中的前W位，而没有警告，没有消息，没有错误或任何东西，那么加法的结果就是你得到的w位模式。这只是静静地发生的事情。</p><p>发言人   03:05<br>For to complement this is not such a hard thing to understand. It can be thought of as just modular arithmetic computing modulo the two to the word size. So I’m going to use some examples. And this time I’ve got them worked out a little more carefully, won’t get mixed up as much, and we’ll use a word size of 4 here. And as I mentioned last time, it really helps with this to do the examples with small word sizes to get your intuition for it, rather than trying to write out 30 two-two bit numbers, 60 two-four bit numbers, or something like that.<br>因为补充这一点并不难理解。它可以被看作是模块化的算术计算，将两者取模为单词大小。所以我将使用一些例子。这次我让他们更仔细地制定，不会混淆太多，我们这里将使用单词大小为4。正如我上次提到的，用小字大小的例子来获得你的直觉确实有帮助，而不是试图写出30个2-2位数字，60个2-4位数字或类似的东西。</p><p>发言人   03:45<br>So if you think about in the unsigned case. A 4 b number. Means that it will range between 0 and 2 to the 4th -1 or 15. And so let’s just do a few examples of cases where it overflows. So if you add 13 to 5.<br>所以如果你考虑未签名的情况。一个4 b数字。意味着它的范围将在0到2到第4个1或15之间。所以让我们举几个它溢出的例子。所以如果你把13加到5。</p><p>发言人   04:21<br>First of all, you know, I assume already that you just add binary numbers the way you learned in school, just doing carries and so forth, except it’s all module 2. So this is zero carry 1, 1, 0 carry 1, 0 carry one. So in principle, to represent the sum, which is this is 5, So to represent 18, you need 5 b, not 4. But we’re just going to conveniently drop that number and say that this is actually two, which of course, is what 18 modules 16 is. So the unsigned case is really pretty straightforward.<br>首先，你知道，我已经假设你只是像在学校学到的那样添加二进制数，只是做进位等等，除了所有的模块2。所以这是零进位1，1，0进位1，0进位1。所以原则上，要表示总和，这是5，所以要表示18，你需要5 b，而不是4。但我们只是方便地放弃这个数字，并说这实际上是2，这当然是18个模块16的意思。所以未签名的案件真的非常简单。</p><p>发言人   05:13<br>And we can visualize this in this picture is in the book too, by saying if you are representing.<br>我们可以想象这张图片也在书中，通过说明你是否在代表。</p><p>发言人   05:21<br>On the x and y axis, what they call u and v are values between 0 and 15, the range of possible unsigned numbers. And if we were to add those, we could get a sum that’s up to as much as 30. Which would in principle, require 5 b to represent, but what we’ll do is we’ll just by dropping that most significant bit, what we do is sort of create a cliff that when you roll over from 15 to 16, instead, it drops all the way down to 0. And that’s referred to as an overflow. And then from there, we’ll build up to the maximum value here will be 14, which is 30 -16. So what we’ve done is basically, as this picture shows, when we overflow, we effectively subtract off 2 to the w from the sum and keep it within the representable range of w bit numbers.<br>在x轴和y轴上，它们所称的u和v是0到15之间的值，这是可能的无符号数字的范围。如果我们将这些相加，我们可以得到最多30的总和。原则上，需要5个b来表示，但我们要做的是通过放下最高有效位，我们所做的是创建一个悬崖，当你从15翻转到16时，它会一直下降到0。这被称为溢出。然后从那里开始，我们将积累到这里的最大值为14，即30 -16。所以我们所做的基本上是，正如这张图片所示，当我们溢出时，我们有效地从总和中减去2到w，并将其保持在w位数字的可表示范围内。</p><p>发言人   06:21<br>So that’s unsigned two comple The first thing I want to convince you of is that two’s complement edition looks just like regular edition. In other words, I can perform subtraction, addition, subtraction of numbers by using this two’s complement representation for negative numbers. So let me just show you some examples of that.<br>所以这是未签名的两个comple，我想说服你的第一件事是，两个的补充版看起来就像普通版一样。换句话说，我可以通过使用这两个负数的补码表示来执行数字的减法，加法，减法。让我给你看一些例子。</p><p>发言人   06:57<br>So first of all, remember that what range of values, what’s the smallest number that could be represented with a 4 b? The most negative number, 4 b, two’s complement number -8. And the largest plus seven, thank you. So let’s just do some examples if we took.<br>首先，请记住值的范围是什么，可以用4 b表示的最小数字是什么？最负数4 b，2的补码数-8。还有最大的加七个，谢谢。所以，如果我们采取行动，让我们做一些例子。</p><p>发言人   07:27<br>This number 1, 1 0 1 as a T’s complement number is -3. And we add it to 5. We’ll get what we got before.<br>这个数字1、0作为T的补数是-3。我们把它加到5上。我们会得到我们之前得到的。</p><p>发言人   07:52<br>And we’re going to ignore whatever carry bit it is. And so the result is 2. And lo and behold, that’s what 5 -3 is. So it seems like magic because it is. And that’s part of the reason why I choose complement is sort of the most commonly used way of representing S numbers. The same hardware, the same algorithms that are used for doing addition. It works for either unsigned or two S complement numbers.<br>我们将忽略它的任何携带位。所以结果是2。瞧，这就是5 -3。所以它看起来像魔法，因为它就是。这就是我选择补码是表示S数最常用方式的部分原因。用于加法的相同硬件和相同算法。它适用于无符号或两个补码数。</p><p>发言人   08:32<br>And this works as well. Just to show you, if the overflow goes, the resulting sum goes the other way. So if I have -3, -5, and plus three, and I add those together.<br>这也行得通。只是为了向您展示，如果溢出消失，结果总和会相反。所以，如果我有-3、-5和 + 3，我把它们加在一起。</p><p>发言人   09:04<br>I’ll get 1, 1, 1, 0, which is -2. So again, if you use the patterns for the same rule for addition as you do with the unsigned case, you’ll get two complement arithmetic. So let’s look at a few cases where the two S complement overflows.<br>我会得到1，1，1，0，即-2。因此，如果您将模式用于与无符号情况相同的加法规则，您将得到两个补码算术。因此，让我们来看一些两个S补码溢出的情况。</p><p>发言人   09:36<br>So if we take three.<br>那么，如果我们拿三个。</p><p>发言人   09:46<br>And.<br>而且。</p><p>发言人   09:54<br>Minus six. And we add them together. We’ll get 1, 1, 1, 0. We’re going to drop off the carry, which is what, 7? So we’ve added two negative numbers, and it’s become positive. And that’s referred to as a negative overflow.<br>-6。然后我们把它们加在一起。我们会得到1，1，1，0。我们要把东西放下，什么是7？所以我们添加了两个负数，它变成了正数。这被称为负溢出。</p><p>发言人   10:24<br>And the reason, of course, is the number -9 can’t be represented in a 4 b chooses complement number. It overflowed. You’ll notice that the plus seven, of course, differs from -9 by 16, and that’s not next. And then going the other direction, if we had two large positive numbers. So if we had 7. And 5?<br>当然，原因是数字-9不能在4 b选择补码数字中表示。它溢出了。你会注意到，加7当然不同于-9乘16，这不是下一个。如果我们有两个大的正数，然后朝着另一个方向前进。如果我们有7个。And 5?</p><p>发言人   11:10<br>We’ll get -6. So this was 7 plus 5. Is -4? And so this is referred to as positive overflow. We’ve taken two.<br>我们会得到-6。所以这是7加5。是-4吗？因此这被称为正溢出。我们已经拿了两个。</p><p>发言人   11:38<br>Positive numbers and added them together and gotten a negative result. And you can see this, by the way, if you think about this addition, we took 7 and 5 would be 12. And this is the bit level representation of 12. It’s just that because this is now the sine bit, we think of that as -4, not positive 12. And so that’s the idea of two’s complement overflow. And you can see there’s two different cases here. One is where number the. Sum was, if we looked at the true sum, the number that you’d get, for example, 12 is too big to represent. And so when we think of that as a twos complement number, it becomes now a negative number. So that’s positive overflow.<br>将正数相加得到否定的结果。顺便说一下，如果你考虑这个加法，我们拿了7和5，就是12。这是12的位级表示。只是因为这现在是正弦位，我们认为那是-4，而不是正的12。这就是2的补码溢出的想法。你可以看到这里有两种不同的情况。一个是数字所在的地方。总和是，如果我们看看真正的总和，你得到的数字，例如12太大了，无法代表。所以当我们把它看作是一个二零补数时，它现在就变成了一个负数。所以这是正溢出。</p><p>发言人   12:33<br>Similarly, if we have two negative numbers and we add them together so that the sum is too small, too negative to represent, then those become positive numbers. That’s negative overflow. And you can see that in this picture, the same idea as before, except there’s three regions. This is the, and by the way, now you’ll see our numbers range between -8 and positive c, and the sum will also range between -8 and positive 7. But there’s these three regions. One is where everything’s fine, it’s within the representable range, the other is where the sum was so far toward the negative side that it becomes positive, or where it’s so high on the positive side that it becomes negative. And so part of data web, you’ll learn to understand these quite in quite precisely.<br>同样地，如果我们有两个负数，我们把它们相加，使得总和太小、太负而无法表示，那么它们就变成正数。这就是负面溢出。你可以看到这张图片和之前的想法一样，只是有三个区域。顺便说一句，现在你会看到我们的数字范围在-8和正c之间，总和也在-8和正7之间。但是有这三个地区。一种是一切都很好，在可表示的范围内，另一种是总和远远接近负值而变成正值，或者正值太高而变成负值。因此，作为数据网络的一部分，你将学会非常精确地理解这些。</p><p>发言人   13:44<br>But that’s the idea. And it’s a little bit counterintuitive to say. So somehow I can accept the idea that modular arithmetic for unsigned numbers, there’s some sort of mathematical beauty to modular arithmetic. And this just looks like kind of useless from a. Operational characteristic. But it’s the way it is. We’re stuck with it. And multiplication is basically the same idea. In fact, all the operations are basically the same idea.<br>但这就是我的想法。这样说有点违反直觉。因此，我可以接受这样的想法，即无符号数的模块化算术，具有某种数学美感。而这看起来只是有点没用。运营特点。但事情就是这样。我们被它卡住了。乘法基本上是相同的思想。事实上，所有的操作基本上都是相同的想法。</p><p>发言人   14:23<br>If you can’t represent it within the word size, you just take the lower w bits. So all this complicated notation here is just a way of saying, in principle, if you take two w bit numbers and multiply them together, you need the result may require as much as two times w bits to represent before addition. It’s w plus 1 multiplication. You actually have to double because you’re potentially squaring the largest number. And so again, we don’t want to just keep doubling our word size over and over again, we’ll run out of bits very quickly that way, and so we just truncate it at w bits and.<br>如果您无法在单词大小内表示它，则只需采用较低的w位。所以这里所有这些复杂的符号只是一种说法，原则上，如果你把两个w位数字相乘，你需要的结果可能需要两倍的w位才能表示出来。这是w加1乘。你实际上必须翻倍，因为你可能要平方最大的数字。所以再次强调，我们不想一遍又一遍地让我们的字数翻倍，这样我们很快就会用完位数，所以我们只需要将其截断为w位。</p><p>发言人   15:14<br>For the unsettling, it’s, again, modular arithmetic. It’s something that you can kind of understand and believe, but. And so again, let’s just do a few examples. And I won’t try workout. Multiplying in binary is like multiplying in decimal. You do a big table and it takes a long time. So I won’t try to do that. But let me just show a few examples.<br>令人不安的是，这是模块化算术。这是你可以理解和相信的事情，但是。再说一遍，让我们举几个例子。我不会尝试锻炼。二进制乘法就像十进制乘法。你做一张大桌子，需要很长时间。所以我不会尝试这样做。但让我举几个例子。</p><p>发言人   15:54<br>So if I multiply three times 5 is of course, equal to 15. And in an unsigned number, I can represent that. So, that’s OK. But if I multiply five times 5.<br>所以，如果我乘三乘5，当然等于15。在一个无符号的数字中，我可以表示它。所以，没关系。但是如果我乘五次5。</p><p>发言人   16:23<br>Then that would have a representation. If I were to think about it, as possibly as many as 8 b, it would have a representation.<br>那么就会有一个代表。如果我考虑一下，可能多达8个b，它将有一个代表性。</p><p>发言人   16:39<br>With an extra bit. And I’m going to throw this part away. And so I’d call that 9, which of course, is equal to 25 mod 16.<br>多一点。我要把这部分扔掉。所以我称之为9，当然，它等于25 mod 16。</p><p>发言人   16:56<br>And so that’s the general idea of it is regardless of whatever is in this upper part of the word, the product. I’m just going to discard that and only look at the lower one. And life gets a little more interesting with the two’s complement case. So let’s look at what that does. And the answer is even a little bit stranger in that you not only trunk throw away whatever high order bits happen to be there, but whatever bit gets left in this position will determine whether it’s a positive or a negative result, even though completely irrespective of the signs of the original two operands. So that can make you go all over the place.<br>这就是它的一般思想，无论这个词的上部是什么，产品。我只是打算放弃那个，只看下面的那个。随着两者的补充情况，生活变得更有趣了。让我们看看它的作用。答案甚至有点奇怪，因为你不仅扔掉了碰巧存在的任何高阶位，而且在这个位置留下的任何位都将决定它是正的还是负的结果，即使完全不考虑原始两个操作数的符号。这样可以让你走遍所有的地方。</p><p>发言人   18:03<br>So if we had five times 4 or 20. That would be represented. In this 8 b form.<br>如果我们有五个乘以4或20。这将被代表。在这个8 B形式中。</p><p>发言人   18:24<br>Like so. And we’d just call that four, right? Because we’re throwing this away. But if we did five times 5.<br>就像这样。我们就称它为四，对吧？因为我们要把这个扔掉。但是如果我们做了五次5。</p><p>发言人   18:40<br>As we saw before, that’s represented like this.<br>正如我们之前看到的，这就代表了这样。</p><p>发言人   18:51<br>And that? Now becomes, so we’re throwing away this and this becomes our sine bit. So the result is -8 plus 1 or -7. So you see, this is similar to an example we showed at the beginning of the first lecture, that you can have two positive numbers and multiply them and get a negative result because of the sort of quirks of this overflow question there.<br>那个呢？现在变成了，所以我们扔掉了这个，这变成了我们的正弦位。所以结果是-8加1或者-7。所以你看，这类似于我们在第一节课开始时展示的例子，你可以有两个正数，然后将它们相乘得到负面结果，因为这个溢出问题的怪癖。</p><p>发言人   19:26<br>Oh I’m just taking 25 and writing it in binary. Yeah, if you want to, you know, you start with the two numbers. I’m not going to do well. Actually, this one’s an easy one. There’s a trick for this. If you want to multiply a number by a power of two, we’re going to show that later. You just shift it left by two positions.<br>哦，我只是用二进制写25。是的，如果你想，你知道，你可以从这两个数字开始。我不会做得很好。实际上，这个很容易。这是有诀窍的。如果你想将一个数乘以2的幂，我们稍后会展示。你只需要将它向左移动两个位置。</p><p>发言人   19:56<br>So that one’s an easy one. Otherwise, you have to write out the table and sum all the results and all that stuff. I prefer to let computers do that.<br>所以这是一个容易的。否则，你必须写出表格并汇总所有结果和所有这些内容。我更喜欢让计算机来做这件事。</p><p>发言人   20:15<br>And again, the two complement stuff. One interesting feature is that it works for negative numbers too. If you do this trick of throwing away the high order bits, and you’ll have overflow cases like before because you’re throwing away information. The lower bits, if the number is representable, you’ll get the right result. So let me just demonstrate to that to you. So -3. But you remember this is equivalent to 13 as an unsigned number and. This is -2, which is equivalent to 14 as an unsigned number. So now if we multiply 13 times 14, you get 182. And that has a hex representation of B6.<br>再次，这两个补充的东西。一个有趣的特性是它也适用于负数。如果你使用这种丢弃高阶比特的技巧，就会出现像以前一样的溢出情况，因为你正在丢弃信息。在较低的位，如果数字是可表示的，你将得到正确的结果。让我向你们演示一下。所以-3。但你记得这相当于13作为一个无符号数。这是-2，相当于14作为一个无符号数。所以现在如果我们乘13乘14，你得到182。并且它的十六进制表示为b6。</p><p>发言人   21:30<br>And so just looking at the low order, 4 b are 0, 1, 1, 0 is 6. And indeed, that’s negative three times -2 is 6. So the point being, and I’m waving my hands here because I don’t want to go through all the details, but to complement multiplication also gives you, if you can do it using the exact same rules. And as you do for unsigned multiplication, same hardware, I should mention that there are instructions in the computer in ways that you can get the upper word of a multiplication 2. And those the bit patterns are different depending on whether it’s treated as two complement number versus unsigned different instructions for doing that computation, But 99% of the time or more, you just looking at this lower part of the product. And that’s the same whether it’s a tooth complement or an unsigned. And it handles negative numbers, positive, but it has these overflow characteristics.<br>所以仅仅看低阶，4 b是0，1，1，0是6。事实上，这是负数的三倍 – 2是6。所以重点是，我在这里挥手，因为我不想浏览所有的细节，但是如果你能使用完全相同的规则，补乘也会给你带来帮助。正如你对无符号乘法所做的那样，同样的硬件，我应该提到计算机中有一些指令，可以获得乘法2的上位单词。而这些位模式取决于它是否被视为两个补码数和无符号不同的指令来进行计算，但99% 以上的情况下，你只是看到乘积的这个下部。无论是牙齿补全还是无符号牙齿，都是一样的。它处理负数、正数，但它具有这些溢出特性。</p><p>发言人   22:45<br>So as I was talking about, there’s a trick we can do for multiplying by a power of two, which is just to shift the number to the left. And you’ll often see that when you have in your code, I want to multiply some number by 4. You’ll write in your C code. If you look at the assembly code, you’ll see that what the compiler generated just says. I’ll just shift it left by two. So in general, and you can see why this is true. By the way, if you think of the number. As the sum of the bits?<br>所以正如我所说的，我们可以做一个技巧来乘以2的幂，这只是将数字向左移动。你经常会看到，当你在代码中写代码时，我想把某个数字乘以4。你将用你的C代码编写。如果你查看汇编代码，你会发现编译器生成的代码只是说出来的。我会把它向左移动两点。总的来说，你可以明白为什么这是真的。顺便说一下，如果你想到数字。作为比特数的总和？</p><p>发言人   23:35<br>Where x sub I is the ith bit and x is the number it represents. If I shift everything left by two, what I’m effectively doing is increasing their weight by that number of positions. So let’s just shift by one. If I shift everything to the left by one.<br>其中，x sub I是第I个位，x是它代表的数字。如果我将所有东西左移两，我有效地做的是将它们的权重增加那么多个位置。那我们就转一个吧。如果我把所有东西向左移动一个。</p><p>发言人   24:02<br>Which we write like this in C 2, 2 less symbols. It’s like taking that sum, but now weighting the bits by 2 to the I plus one by one more. And of course, that’s equal to twice what the original sum was. And so we doubled the number. And that works. Even if you shift things so you lose some bits, they shift off to the left. All you’re doing is the way multiplication works anyhow, of truncating to W bit product.<br>我们这样用c2写，少了2个符号。这就像取那个总和，但现在将比特加权2到I加一加一。当然，这等于原始总和的两倍。所以我们将数字翻倍了。这行得通。即使你移动了一些东西，丢失了一些位，它们也会向左移动。你所做的只是乘法的工作方式，即截断为W位乘积。</p><p>发言人   24:48<br>You’ll see this, as I mentioned, quite often in compiled code, machine level code, that they’re doing shifts where you might expect them to be doing multiplications. And the reason for that is an optimization is historically, the multiplication instruction took a lot longer than a shift instruction, say one clock cycle to do a shift. And it used to be like 11, 1230 clock cycles to do a multiplication. Nowadays, like on computers, we use the shark machines, it only takes three clock cycles to do multiplication because they added a lot of hardware to do that. But three clock cycles is still more time than one. And so when you can get away with a shift, it’s generally a better idea. And the compiler has its own kind of judgment calls on when is it more efficient to substitute one operation for another?<br>正如我所提到的，在编译代码中，机器级别的代码中，你会经常看到这一点，它们正在进行移位，你可能期望它们进行乘法运算。而这样做的原因是从历史上看，乘法指令比移位指令花费了更长的时间，比如一个时钟周期来进行移位。它曾经需要大约11，1230个时钟周期来进行乘法运算。现在，就像在计算机上一样，我们使用鲨鱼机，只需要三个时钟周期就可以进行乘法，因为他们添加了很多硬件来实现这一点。但三个时钟周期仍然比一个时间更长。所以当你可以逃脱轮班时，通常是一个更好的主意。编译器有自己的判断要求，何时用一种操作代替另一种操作更有效？</p><p>发言人   25:53<br>Did I lose ground here?<br>我在这里失去了基础吗？</p><p>发言人   26:04<br>So the idea then, if we want to multiply something by two to the k, we just shift it left by k bit.<br>所以这个想法是，如果我们想将某物乘以二得到k，我们只需要将其向左移动k位。</p><p>发言人   26:21<br>It turns out that the same almost works for dividing by two as well, that if you want to divide something by a power of two, you can shift it right by in the same general idea. Only thing that becomes a little bit quirky is, well, what if the number you have is not actually divisible by that power of two?<br>事实证明，同样的方法几乎也适用于除以二，如果你想将某物除以二的幂，你可以按照同样的一般想法将其向右移动。唯一有点古怪的是，如果你拥有的数字实际上不能被2的幂整除呢？</p><p>发言人   26:52<br>So for example, if we had the number 0, 1. I want. I’m gonna use this.<br>例如，如果我们有数字0，1。我想要。我要用这个。</p><p>发言人   27:10<br>So that’s 6. So if we shift it right by one, we’ll get 0, 0, 1, 0. One, 1, thank you, which is 3. And that’s six divided by 2 is 3. If we shift that again. We’ll get one. But of course, you know that 3&#x2F;2 are 1.5. The rule on integer division is you round it down, round it towards 0, and so that goes to one. So this is what the unsigned case works fine. The signed case, which I don’t have a slide for.<br>那就是6。所以如果我们把它向右移动一，我们会得到0，0，1，0。1，1，谢谢，也就是3。6除以2就是3。如果我们再次转移。我们会得到一个。但是当然，你知道3&#x2F;2是1.5。整数除法的规则是你向下舍入，向0舍入，这样就得到1。所以这就是未签名案例运作良好的地方。签名的案子，我没有幻灯片。</p><p>发言人   28:07<br>It’s a little bit less pretty. Well, first of all, you notice if it’s a positive number, the shifting right is going to be the right thing, just as it is for unsigned. But let’s take a number that is.<br>它稍微不那么漂亮了。嗯，首先，你注意到如果它是一个正数，右移将是正确的事情，就像对无符号的情况一样。但让我们取一个数字。</p><p>发言人   28:29<br>Negative, so this is -6. Now, here’s where, remember I told you in the previous lecture, there’s two ways to do shifting. There’s logical shifting where you fill in with zeros, an arithmetic shifting where you fill in with ones. Guess where arithmetic shifting comes in this is it when you want to preserve the sine of a number while you’re dividing it by powers of 2. You want arithmetic shifts. So if we shift this by one, we’ll keep that sine bit and then copy the other ones over. So we just preserved this bit here and copied the other ones over. And this is -3. And so that’s good. But now if we shift again arithmetically. Well, get what?<br>这是负数，所以这是-6。现在，记住我在上一节课中告诉过你，这里有两种转移的方法。有逻辑移位，你用零填充，算术移位，你用一填充。猜猜算术移位的作用是什么？当你想保持一个数的正弦，同时将它除以2的幂时。你想要算术移位。所以如果我们将其移动一个，我们将保留那个正弦位，然后复制其他位。所以我们只是保留了这个位，并复制了其他的位。这是-3。这很好。但是现在如果我们再次算术转移。好吧，明白什么？</p><p>发言人   29:43<br>Nice too. I can see you guys need to know how to negate numbers, right? You don’t know that, so I’ll show you in a second. So here is a little bit problematic that we shifted. We want to divide by two, but the rule should be the same, that you should round toward 0. And what this is doing is it’s rounding toward minus infinity. It’s rounding toward a more negative number than the true thing. And so there’s a cute little trick that says, before you shift, before you divide by a power of two, before you do the shift, you should add a bias.<br>也不错。我明白你们需要知道如何否定数字，对吧？你不知道，所以我马上给你看。所以我们转移了一点问题。我们想要除以二，但规则应该是相同的，你应该四舍入到0。它所做的是向负无穷大四舍五入。它向一个比真实数字更负的四舍五入。所以有一个可爱的小技巧说，在你移动之前，在你除以2的幂之前，在你移动之前，你应该添加一个偏差。</p><p>发言人   30:34<br>Which, in this case, would just be one. And I’ll tell you where that comes from. And so if we add those numbers together, we’ll get 1, 1, 1, 0. And now when we do the shift on that, we’ll get 1, 1, 1, 1, and that’s -1. So there’s a trick.<br>在这种情况下，只有一个。我会告诉你这是从哪里来的。所以如果我们把这些数字相加，我们会得到1，1，1，0。现在当我们在上面进行转换时，我们会得到1，1，1，那就是-1。所以有一个小技巧。</p><p>发言人   30:58<br>And again, you’ll see the compiler doing this where you have in your code divide by 16, and it’ll add a bias. Then it will do a right shift instead of calling division. And by the way, division really, really is slow, even on a modern computer like what you have the shark machines, it takes 30 plus clock cycles. So anytime the compiler can avoid figure out a trick that does it with shifting and tweaking things around, it will.<br>再次，你会看到编译器在你的代码除以16的地方这样做，它会增加一个偏差。那么它将进行向右移动，而不是调用部门。顺便说一下，除法确实很慢，即使在像鲨鱼机器这样的现代计算机上，也需要30多个时钟周期。因此，只要编译器能够避免想出转移和调整事物的技巧，它就会做到。</p><p>发言人   31:30<br>So I realize I should tell you, there’s a couple ways you can.<br>所以我意识到我应该告诉你，有几种方法可以。</p><p>发言人   31:38<br>Negate a number that are handy to know if you ever have to do it in your head or on paper. And the standard way is what’s called complement and increment. So this is how do I go from x to minus x? So if I have a number. And I want to negate it, whether it’s currently a negative number or it’s a positive number. The same trick works. What I’ll do is complement it, meaning I’ll flip all of the bits. And then I’ll add one to that.<br>否定一个数字，它很方便知道你是否曾经在脑海中或在纸上做过。标准方式是所谓的补足和递增。这就是我如何从x到-x？如果我有一个号码。我想否定它，无论它是目前的负数还是正数。同样的把戏行得通。我要做的是补充它，意思是我会翻转所有的位。然后我会再添加一个。</p><p>发言人   32:21<br>And do the regular sum. And so this is 6. And this is -6. So if you ever have to do it by hand, that’s the way to do it, complement and increment. And it goes the other way. You’ll see if I complement this.<br>并做常规的总和。所以这是6。这是-6。所以，如果你必须手工完成，那就是方法，补充和增加。它是另一种方式。你会看到我是否补充了这个。</p><p>发言人   32:46<br>And I increment. It. Back to my previous number. So that’s a trick. It’s pretty much only useful when you do things on the blackboard or when you have to solve a problem in data web.<br>和I递增。它。回到我之前的号码。所以这是个小把戏。它几乎只有当你在黑板上做事情或者在数据网络中解决问题时才有用。</p><p>发言人   33:15<br>Anyways, this idea of of doing shifting to the right to do power of two division, actually, that’s the whole justification for arithmetic shifting in the first place, which by the way, and see, there’s no fixed requirement for how shifting works in C for signed numbers, for unsigned. It has to be a logical shift. Sine numbers, the C standard says there’s no fixed definition. The reality is, on our machines, most machines, just about every machine out there, when it’s a sine number, it’s two’s complement. And when you do a shift, it will be an arithmetic shift.<br>无论如何，这种向右移动以进行两除法的幂的想法实际上，这首先是算术移位的理由，顺便说一下，对于有符号的数字，对于无符号的数字，没有固定的要求。这必须是一个合乎逻辑的转变。正弦数字，C标准说没有固定的定义。现实情况是，在我们的机器上，大多数机器，几乎每台机器上，当它是正弦数时，它是2的补码。当你做一个移位时，它将是一个算术移位。</p><p>发言人   34:09<br>So getting back to then summarizing this integer arithmetic, you see that, first of all, whether it’s signed or unsigned, the addition or multiplication operations are the same, whether it’s an unsigned number or two’s comple. And it works, the negative stuff works out as long as you don’t have an overflow. And you can end up with an overflow, only one type of overflow for unsigned and two types for signed numbers. But it’s not like they just overflow and generate random numbers, a pattern to result what they are and how they can be interpreted.<br>所以回到总结这个整数算术，你会看到，首先，无论它是有符号的还是无符号的，加法或乘法操作都是相同的，无论它是无符号的数字还是2的整数。它会起作用，只要你没有溢出，负面的东西就会起作用。并且您最终可能会导致溢出，对于无符号数字只有一种类型的溢出，对于有符号数字只有两种类型。但它们并不只是溢出并生成随机数，而是一种模式来导致它们的存在以及如何解释它们。</p><p>发言人   35:03<br>So I talked about this a little bit last time and gave this example similar to this, but let me go over it a little bit more. One thing you might think of, wow, if this unsigned and signed stuff gets so murky, and we saw some funny examples last time, maybe we should just banished unsigned numbers from the universe and OAO L two’s complutum. And that’s exactly the rule that was adopted. For example, in Java, they said, is this too weird? Let’s just say every number is two’s comple The only trick they did was they put in a triple right shift. Means logical shift? This is Java, this is not C?<br>所以我上次谈了一点这个，并给出了与此类似的例子，但让我再详细介绍一下。有一件事你可能会想到，哇，如果这个无符号和有符号的东西变得如此模糊，我们上次看到了一些有趣的例子，也许我们应该把无符号的数字从宇宙中驱逐出去。这正是采用的规则。例如，在Java中，他们说，这太奇怪了吗？我们只能说每个数字都是2的comple，他们唯一的技巧就是进行了三个右移。这意味着逻辑转变？这是Java，这不是C？</p><p>发言人   36:04<br>Whereas the double is arithmetic.<br>而双精度是算术的。</p><p>发言人   36:17<br>Because they realize there’s a lot of cute little times when you want to play tricks with things and you need that logical right shift. So that’s actually one approach. Or other more modern languages and C are saying it’s okay to have signed and unsigned, but we don’t want them sort of mysteriously being cast back and forth in ways that the programmer might not recognize. And so you have to explicitly do a cast rather than implicitly. And I think that’s the better approach. But C, as I mentioned, does this implicit casting.<br>因为他们意识到，当你想玩弄事物时，有很多可爱的小时候，你需要逻辑上的右移。这实际上是一种方法。或者其他更现代的语言，C语言和C语言都说有签名和无签名是可以的，但我们不希望它们以程序员可能无法识别的方式神秘地来回转换。所以你必须明确地进行强制转换，而不是隐式地进行。我认为这是更好的方法。但是，正如我所提到的，C会进行隐式转换。</p><p>发言人   36:52<br>And so, as we saw for last time, what happens with this program when you run it? To count down through an array, do you remember? Well, I, if it’s unsigned, what will happen with this test? It always succeeds. So the thing will be in an infinite loop. Actually, what will happen is it will try to access, I will go down to 0, and then it will wrap around to become the largest possible ensign number, which is probably way out of bounds. And it will give a memory error, but it won’t do what’s supposed to be.<br>所以，正如我们上次看到的，当你运行这个程序时会发生什么？通过一个数组倒数，你还记得吗？好的，我，如果它是无符号的，这个测试会发生什么？它总是成功的。所以这个东西将会处于一个无限循环中。实际上，它会尝试访问，我将下降到0，然后它将环绕成为最大的可能的标志数字，这可能超出了界限。它会产生记忆错误，但它不会做应该做的事情。</p><p>发言人   37:40<br>And as I mentioned before, these things, there a lot of sneaky ways this problem can show up in ways you might never think of. So for example, the operator size of is defined to say how big a particular data type is, it’s a very useful operator. Its return value is what’s called a size underscore t, which is defined to be a long unsigned number. And so if we just throw in a. Constant like this. Then this subtraction we have AI is now int, but size of is unsigned. And so it will cast that to be unsigned implicitly. And when you compare it to 0, you’ll have the same problem as before.<br>正如我之前提到的，这些事情，这个问题可能会以你可能从未想过的方式出现。例如，运算符的大小被定义为特定数据类型的大小，这是一个非常有用的运算符。它的返回值称为大小下划线t，它被定义为一个长的无符号数字。所以如果我们只是投入一个。像这样不断。那么我们得到的这个减法现在是int，但size是无符号的。因此它会隐式地将其强制转换为无符号。当你将其与0进行比较时，你将遇到与之前相同的问题。</p><p>发言人   38:31<br>So just to show you that these things can sneak in very tricky ways. So one way to do that then is just don’t use unsigned like and make sure if this is.<br>所以只是为了告诉你，这些东西可以以非常棘手的方式偷偷溜走。因此，一种方法是不要使用未签名的像，并确保这是否是这样。</p><p>发言人   38:48<br>A possible unsigned number. You cast it to sign. You make sure that this is recognized and signed. But there’s another way that actually, at least there’s a fellow over at the Software Engineering Institute named Robert Secord who has written the books that are considered the. The gold standard for how to write secure code. He works for this organization called the Computer Emergency Response Team, which is out there tracking down bad things going on in computer security. And one of the things he and others have done is to try and come up with standards so that people who write programs well avoid some of the pitfalls that make their programs vulnerable to security of flaws to attack.<br>可能的无符号数字。你投它来签名。你要确保这被识别和签名。但实际上还有另一种方式，至少有一位名叫罗伯特·塞科德的软件工程研究所的研究员写了被认为是最重要的书。如何编写安全代码的黄金标准。他在一个名为计算机应急响应团队的组织工作，该团队正在追踪计算机安全方面的不良事件。他和其他人所做的事情之一就是尝试制定标准，以便编写程序的人能够避免一些使他们的程序容易受到安全漏洞攻击的陷阱。</p><p>发言人   39:43<br>And so his recommended technique is when I first saw this, it was so counterintuitive to me, it hardly made sense, right? So you start, and again, this is all unsigned arithmetic, So I’m starting to count down, and my test is when I is less than count. So here’s the thing, I started off smaller than count, and it’s only being decremented. So when would this test ever fail? When it overflows, when it wraps around, when I goes from 0 and counts down to what would now be u max, this test will fail, which is exactly when you want it to stop.<br>所以他推荐的技巧是，当我第一次看到这个时，它对我来说是如此违反直觉，几乎没有感知，对吗？所以你开始，再一次，这都是无符号算术，所以我开始倒计时，我的测试是当我小于计数时。所以事情是这样的，我一开始比计数小，它只是被减少了。那么，这个测试什么时候会失败呢？当它溢出，当它包裹时，当I从0计数到现在的最大值时，这个测试将失败，这正是你想要它停止的时候。</p><p>发言人   40:31<br>And his observation is in c with sine numbers. There’s no guarantee on what happens with overflowing. As I said, most people just assume it’s going to be too’s compliment. But if you really want to be careful, you shouldn’t assume anything outside of the C standard. And if you’re trying to write secure code, it’s probably a good idea to be cautious. Be conservative.<br>他的观察结果是在c和正弦数字之间。无法保证溢出会发生什么。正如我所说，大多数人只是假设这将是对太的赞美。但如果你真的想小心，你不应该假设C标准之外的任何事情。如果你试图编写安全的代码，保持谨慎可能是个好主意。保守一点。</p><p>发言人   40:55<br>On the other hand, the C standard guarantees that unsigned arithmetic will be modular arithmetic. So it guarantees that if you subtract 1 from 0, you’ll get the largest number that could be represented. So it will be OK. And in fact, he recommends, instead of using unsigned, which is on our machines, just a 32 b value that you call it a size t, which is a 64 b value. And write your code the way that I showed you. So I’ve actually started doing this. And once you kind of get used to it, it’s an okay way to write code, but it’s very strange looking initially. One thing I’ll point out is.<br>另一方面，C标准保证无符号算术将是模算术。因此，它保证了如果你从0中减去1，你将得到可以表示的最大数字。所以会没事的。实际上，他建议不要使用我们机器上的无符号，而只使用32 b的值，你称之为大小t，这是64 b的值。并以我展示的方式编写您的代码。所以我实际上已经开始这样做了。一旦你习惯了它，这是编写代码的一种不错的方式，但一开始看起来很奇怪。我要指出的一件事是。</p><p>发言人   41:47<br>What would happen if count were a sine number, an int, and it? Was less than 0? What would happen here? So I less than count what would happen.<br>如果count是一个正弦数，一个int数，它会发生什么？小于0？这里会发生什么？所以我数不清会发生什么。</p><p>发言人   42:14<br>And so it become a very large positive number. And this test would almost certainly succeed. So you have the same. This code doesn’t avoid the pitfall, it just shifts it to saying you better make sure you don’t test for this case beforehand before you get into it.<br>因此它成为一个非常大的正数。这个测试几乎肯定会成功。所以你有相同的。这段代码并不能避免这个陷阱，它只是将其转移到说你最好确保在进入这个案例之前不要事先测试它。</p><p>发言人   42:38<br>I think part of it is the observation that, man, if you want to be careful and write code, that that is guaranteed correct no matter what implementation goes on, as long as it’s within the C standard, It’s pretty tricky business. A question up there.<br>我认为其中的一部分是观察到，如果你想小心编写代码，那么无论执行什么实现，只要它在C标准内，都是相当棘手的业务。这里有一个问题。</p><p>发言人   43:02<br>Yes, which is unfortunate. So yes, that’s exactly the rule that it’s implicitly, silently, the C compiler doesn’t give any warnings.<br>是的，这很不幸。所以是的，这正是规则，它是隐式的，默默地，C编译器不发出任何警告。</p><p>发言人   43:14<br>You’ll never know. You cast it to unsigned. And as these examples show, when you stare at that code and you think about it, it’s really easy to have bugs that you just, you can look at it a thousand times and not realize that it’s a bug. It’s a very, and there’s examples, There are examples in the book of security flaws in sort of very important library software due to this problem exactly. So part of the reason we teach in the course is just so you appreciate that this is a quirk in this. And see that again, 99% of the time you’ll never even, it won’t bother you at all. But there will be some oddball cases that you can get in trouble with. So the other that you’ll find unsigned representation useful is, first of all, when you’re doing modular arithmetic, which is, for example, the way most encryption algorithms work, or when you’re using the bits not to represent numbers, but to represent sets the way I described it before, then you don’t’s easiest to just think of that as unsigned numbers.<br>你永远不会知道。你把它转换为未签名的。正如这些例子所展示的，当你盯着代码思考时，很容易出现bug，你可以看上几千次而没有意识到这是一个bug。这是一个非常，有例子，在书中有一些非常重要的图书馆软件安全漏洞的例子，正是由于这个问题。所以我们在这门课程中教授的部分原因只是为了让你欣赏这是其中的一个怪癖。再说一遍，99% 的时间你永远不会，它根本不会打扰你。但是也会有一些奇怪的情况，你可能会惹上麻烦。因此，你会发现无符号表示有用的另一个方面是，首先，当你在进行模算术时，例如，大多数加密算法的工作方式，或者当你使用比特不是代表数字，而是代表我之前描述的集合时，那么你最不容易把它想成无符号数字。</p><p>发言人   44:47<br>Okay, so the final thing to talk about today is some of the low level of representations of numbers within memory. And the main point is when you are running a program on a computer. From the programming perspective, even as an assembly level programmer, not just as AC programmer, in your mind, the memory is just this big array of bytes that’s numbered from 0 up to some maximum number. So for example, in the machines, we’re using the 64 b machines, an address is represented in 64 b. But in fact, the maximum address you’re allowed to use in current machines is 47 b.<br>好的，今天要讨论的最后一件事是记忆中数字的一些低水平表示。重点是当你在计算机上运行程序时。从编程的角度来看，即使是汇编级程序员，而不仅仅是交流程序员，在你的脑海中，内存只是一个大的字节数组，从0到某个最大数字编号。例如，在机器中，我们使用的是64 b机器，地址用64 b表示。但实际上，您在当前机器中允许使用的最大地址是47 b。</p><p>发言人   45:43<br>Two to the 47th is still a pretty big number. So that’s more memory than anyone’s able to buy right now anyhow. And so it’s a reasonable restriction. But the point is that logically, your program thinks that it has an array of that many bytes.<br>2到47号仍然是一个相当大的数字。因此，无论如何，这比任何人现在都能够购买的更多的记忆。所以这是一个合理的限制。但重点是，从逻辑上讲，你的程序认为它有一个这么多字节的数组。</p><p>发言人   46:01<br>Let’s try and figure out how big two to the 40 sevenths is. Anyone know it off the top of their head? So there’s a trick if you want to get an approximate idea, which is to say that two to the 10th, which is 110 24, is approximately equal to 10 to the third.<br>让我们试着弄清楚两个到40的七分之一有多大。有人知道它的头顶吗？所以如果你想要得到一个近似的想法，有一个技巧，也就是说2到10，也就是110 24，大约等于3的10。</p><p>发言人   46:31<br>You say, well, that’s really helpful. What it means is that 10 b worth of number is about the same as 3 decimal digits. So for example, to the. 20th? Is around 10 to the 6th, 2 to the 30th. It’s around 10 to the 9th, 2 to the 40th, around 10 to the 12th. And so that would tell you that two to the 48, 47th is around 128 times 10 to the 12th, which is 128 TB, right, Tara, 10 to the twelf.<br>你说，嗯，这真的很有帮助。它的意思是10 b的数字与3位十进制数字大致相同。例如，对于。20号？大约是10到6号，2到30号。大约是10到9号，2到40号，大约是10到12号。所以这就告诉你，2的48次方，47次方大约是128乘以10的12，也就是128 TB，对吧，塔拉，10的12次方。</p><p>发言人   47:26<br>So if you just want to say, get a quick figure for, and of course, these are approximations.<br>所以如果你只想说，得到一个快速的数字，当然，这些都是近似值。</p><p>发言人   47:33<br>But if you just want to get a quick handle on how big a number, what range of values can I represent with so many bits of it, this is a really easy trick to do that. So the point is, 128 TB, it’s a lot you can buy disk drives, a couple of disk drives will do that for you. You couldn’t buy enough DRAM on a normal budget to get that kind of memory. So that’s the current range of values. But logically, when you run a program, it thinks that it has that possible range. Now it doesn’t really, and in fact, what happens is that the operating system only allows certain regions within that memory to be referenced and other regions, if you try to access them, it will create a, it will a signal, an error, what they call a segmentation fault. But logically, at least, it’s as if you have this big array of bytes Now, in reality, and we’ll go into this when we talk about how the memory system works and virtual memory.<br>但是如果你只是想快速掌握一个数字的大小，我能用这么多位表示什么范围的值，这是一个非常简单的技巧。所以重点是，128 TB，你可以购买很多磁盘驱动器，几个磁盘驱动器就可以为你做到这一点。你无法以正常预算购买足够的DRAM来获得那种内存。这就是当前的值范围。但从逻辑上讲，当你运行一个程序时，它认为它有可能的范围。现在它并不是真的，事实上，发生的情况是操作系统只允许引用该内存中的某些区域，而其他区域，如果您尝试访问它们，它将创建一个信号，一个错误，他们称之为段故障。但从逻辑上讲，至少，就好像你现在有这么大的字节数组，实际上，当我们谈论内存系统和虚拟内存如何工作时，我们会深入探讨这个问题。</p><p>发言人   48:44<br>There’s this very complex combination of hardware and software. It gives the program this image of a very large, what you call flat space, just a big array of bytes, when in reality, it’s shuffling between different regions of your memory and even between your memory and your disk drive on your computer to make it implement this particular. Idea that you have this big array of bytes. And that’s all handled, as I said, by the operating system, by the computer hardware. And it’s largely invisible even to the machine level programmer, even people writing assembly code.<br>有一个非常复杂的硬件和软件组合。它给程序提供了一个非常大的图像，你称之为平坦空间，只是一个大的字节数组，而实际上，它正在你内存的不同区域之间，甚至在你的内存和计算机上的磁盘驱动器之间进行洗牌，以使其实现这个特定的功能。你有这么大的字节数组的想法。正如我所说，这一切都由操作系统、计算机硬件来处理。而且即使对于机器级程序员，甚至编写汇编代码的人来说，它也基本上是不可见的。</p><p>发言人   49:32<br>You’ll often hear the term word size and it can get very conf confusing nowadays because there’s no really fixed idea of what a word size is. But roughly speaking, the word size should be whatever the largest number is or the range, that sort of. Signifies how big a pointer is in this language? Or hardware wise, the largest sort of chunk of hardware for which there’s standard support for storing it for arithmetic operations and so forth. So when we say it’s a 64 b machine, what we mean is that regular and routinely manipulates 64 b values on arithmetic operations and also has pointers. The values of addresses are 64 b, even if for right now only 47 of those bits are usable, it’s still considered a 64 b machine. One thing that’s strange is in one of the features of. Of machines such as we have?<br>你经常会听到单词大小这个术语，现在它可能会变得非常混乱，因为对于单词大小并没有真正固定的概念。但粗略地说，单词大小应该是最大的数字或范围，那种类型。表示指针在这种语言中有多大？或硬件方面，最大的硬件块，有标准支持存储它以进行算术运算等。所以当我们说它是一台64 b的机器时，我们的意思是常规和常规地在算术运算中操作64 b的值，并且还有指针。地址的值是64 b，即使目前只有47位可用，它仍然被认为是64 b的机器。有一件事很奇怪，那就是它的一个特征。像我们这样的机器？</p><p>发言人   50:51<br>Is that if I compile a program using a GCC, is the standard compiler I can specify either I want it to be 64 b code or 32 b code as a flag? And it will actually generate two different kinds of object code as a result. And we’ll talk about these later. But for right now, the point is the hardware itself doesn’t necessarily define what the word size is. It’s a combination of the hardware and the compiler that determines what is the word size being used in this particular program. And that code can be run on. The point is that 64 b machines such as we have and most machines are nowadays, can in sort of a backward compatibility style, also execute 32 b code. And as we also saw, one of the other features is, even though it’s a 64 b word size, the data type int, without any other qualifiers to it, is just 32 b.<br>如果我使用GCC编译程序，标准编译器是否可以指定我希望它是64 b代码或32 b代码作为标志？它实际上会生成两种不同类型的目标代码。我们稍后再讨论这些。但就目前而言，关键是硬件本身并不一定定义单词大小。它是硬件和编译器的组合，确定这个特定程序中使用的单词大小。并且这些代码可以运行。关键是，像我们现在拥有的64 b机器一样，大多数机器都可以以一种向后兼容的方式执行32 b代码。正如我们所看到的，另一个特性是，即使它的字数大小为64 b，但没有任何其他限定符的数据类型int只有32 b。</p><p>发言人   52:07<br>There’s sort of this mixture of how big things are. So when people just say word or word size, and let’s say give a precise definition, that’s not a very meaningful term. And we’ll sort of throw it around when we mean sort of a generic chunk of bits without trying to assume that it has a particular number of bits to it.<br>事情有多大有点混合。所以当人们只说出单词或单词大小，假设给出一个精确的定义时，这并不是一个非常有意义的术语。当我们指的是一种通用的位块，而没有试图假设它有特定数量的位时，我们会把它扔掉。</p><p>发言人   52:39<br>Yes, so one of the things is if we ever get to 64 b words, it will be 16 PB, 18 PB, depending on how you define when those numbers get big. The error due to this approximation gets more significant. But something times 10 to the 15th bytes. But right now we can only get to 128 times 10 to the 12th.<br>是的，所以其中一件事是，如果我们达到64 b的话，它将是16 PB，18 PB，这取决于你如何定义这些数字变得很大的时候。由于这种近似而产生的误差变得更加显著。但是乘以10的第15个字节。但是现在我们只能得到128乘10的12次方。</p><p>发言人   53:15<br>So anyways, the idea that the memory itself is a series of bytes, but we can group those into blocks of words of different word sizes. And the way we do that is usually by assuming that the address of the word is the lowest valued address in it. We also will generally try to align these so that, for example, a 32 b word would be a line. So its first byte, its lowest byte, has all zeros in the first.<br>无论如何，内存本身是一系列字节的想法，但我们可以将它们分组为不同单词大小的单词块。我们通常的做法是假设单词的地址是其中价值最低的地址。我们通常也会尝试对它们进行对齐，例如，一个32 b的单词将是一行。因此它的第一个字节，它的最低字节，在第一个全部为零。</p><p>发言人   54:01<br>In the first 5 b positions, no, 30 two-women, sorry, the lowest 2 B. So as this example shows, the address is 0, 4, 8, and 12. They should have really written this in hex and said it’s C, I guess these are all in decimal anyhow. So yeah, these are decimal numbers, so 0, 4, 8, 12. So you see these are in multiples of 4 b boundaries. And similarly, the 64 b words are in multiples of 8, and those are known as aligned words. And we’ll generally, we’ll see that the compiler works pretty hard to keep things aligned because the hardware runs more efficiently that way. But the main point is that we can just take as many bytes as we want and collect them together and call it a word for whatever word size we need.<br>在前5个b的位置中，不，30个是两个女人，抱歉，最低的2个B。正如这个例子所示，地址是0、4、8和12。他们应该用十六进制写这个，并说它是C，我想这些都是十进制的。是的，这些是十进制数字，所以0、4、8、12。所以你会看到这些是以4 b边界的倍数为基础的。类似地，64 b的单词是8的倍数，这些被称为对齐单词。通常情况下，我们会看到编译器会非常努力地保持一致，因为这样硬件会更高效地运行。但主要的一点是，我们可以随心所欲地获取尽可能多的字节，并将它们收集在一起，然后根据我们需要的单词大小来称呼它。</p><p>发言人   55:01<br>I think we saw a variant of this table before, but this is the machines we’ll be working on. The standard int is still only 32 b, but if we qualify something as being wrong, then it will be 64 b. And we’ll tend to do that these two different floating point representations that we’ll talk about. And then the main feature of a 64 b machine is it has an 8 by or 64 b pointer as compared to 32.<br>我想我们之前见过这个表格的变体，但这是我们将要研究的机器。标准的int仍然只有32 b，但如果我们将某些东西限定为错误，那么它将是64 b。我们倾向于将这两种不同的浮点表示形式进行讨论。然后64 b机器的主要特点是它具有8 by或64 b指针，而32则不同。</p><p>发言人   55:34<br>Now, there’s one other kind of detail that says, okay, so if a word has multiple bytes in it, what order should those bytes be? Should it be? And there’s two basic ways this could go. One is that you put the bytes in what’s known as little Indian order, meaning that the first byte in the word is the least significant byte. And then the next, and then the next. And the final byte in the word is the most significant. Or you can flip that around. And those are called Little Indian and Big Indian.<br>现在，还有另一种细节说明，好的，如果一个单词有多个字节，这些字节应该是什么顺序？应该吗？有两种基本的方法可以实现。一种是你以所谓的小印度顺序放入字节，这意味着单词中的第一个字节是最低有效字节。然后是下一个，然后是下一个。并且单词中的最后一个字节是最重要的。或者你可以把它翻转过来。这些被称为小印度人和大印度人。</p><p>发言人   56:13<br>The sort of terms for that which comes from? English book called Gulliver’s Travels, which didn’t anticipate computers at all. But it’s an interesting story of how that comes about. So out there in the world, you’ll find both types of machines, big Indian and little Indian machines. It turns out that increasingly it’s getting hard to find big Indian machines. So literally all of x 86 is little Indian.<br>这种术语的来源是什么？英语书叫做《格列佛游记》，它根本没有预料到计算机。但这是一个有趣的故事，讲述了这是如何发生的。所以在世界上，你会发现两种类型的机器，大型印度机器和小型印度机器。事实证明，越来越难找到大型的印度机器了。所以字面上所有的x86都是小印度。</p><p>发言人   56:45<br>And it turns out Arm processors like what you have in almost every cell phone here is an Arm processor. And the hardware in those can actually be configured to run either way, big Indian or little. But when you’re running it on any of the standard operating systems that run on Arm processors. Then it’s running little Indian. So there used to be a brand called Sun Microsystems, and they were fairly common on campus and then back the Macintosh, before they were x 86 processors, they ran one called the Power PC, and that was a big Indian machine.<br>事实证明，几乎每部手机中都有Arm处理器。这些设备中的硬件实际上可以配置为运行任何一种方式，大印度或小印度。但是当你在任何在Arm处理器上运行的标准操作系统上运行它时。然后它正在运行小印度。所以曾经有一个品牌叫做Sun Microsystems，它们在校园里相当普遍，然后在Macintosh上，在x86处理器之前，他们运行一个叫做Power PC的机器，那是一个巨大的印度机器。</p><p>发言人   57:30<br>But those are long in the distant past. The internet’s about the only place out there when you send packets over the internet and you want to send 32 b words, they’re actually sent in big Indian order. And so at the network interface, you have to translate between those two.<br>但这些都在遥远的过去很久了。当你通过互联网发送数据包并且想要发送32个字时，互联网大概是唯一的地方，它们实际上是按照印度的大订单发送的。因此，在网络接口上，您必须在这两者之间进行转换。</p><p>发言人   57:51<br>So again, just to illustrate what I mean by this is think of a byte value, 4 B value like this. And remember that the way we write numbers is we put the most significant to the left and the least significant to the right. And so now with big Indian, instead of the intuitive one from that perspective, in that the bytes, if you write the words in memory from the smallest address up to the highest, the big Indian will sort of map to what you see, whereas the little Indian will look confusing. But you say 0, 1, 2, 3, 4, 5, 6, 7, because 6, 7 is actually the least significant byte here. And so that comes first in little Indian order.<br>所以，再一次，为了说明我的意思，我认为这是一个字节值，像这样的4 B值。记住，我们书写数字的方式是将最重要的放在左边，最不重要的放在右边。所以现在有了大印度，而不是从那个角度来看直观的，在字节中，如果你从最小的地址到最高地址写入内存中的单词，大印度会有点映射到你看到的地方，而小印度会看起来很混乱。但是你说0，1，2，3，4，5，6，7，因为6，7实际上是这里最不重要的字节。所以这在小印度顺序中是第一位的。</p><p>发言人   58:46<br>And so it used to be people would get impassionate arguments about this. That’s sort of in the distant past. But, and people saying, you know. And the main feature in sort of argument of big Indianness is this feature here.<br>所以以前人们会对此进行无情的争论。这有点像是遥远的过去。但是，人们说，你知道的。而大印度性争论的主要特征就是这里的这个特征。</p><p>发言人   59:08<br>When you look at it, it’s easier to write down, but computers don’t really care. They’re happy either way. And so they just want one convention or another.<br>当你看着它时，写下来更容易，但计算机并不在乎。不管怎样，他们都很高兴。所以他们只想要一个或另一个约定。</p><p>发言人   59:17<br>And like I said, some hardware is can actually be by a sort of flag to flip it from being big Indian to little Indian. But the reality is most of the machines you will encounter, you’ll encounter little Indian machines nowadays. But just to give you an example, here’s some results that I got from actual machines. There used to be some machines around.<br>就像我说的，一些硬件实际上可以通过一种旗帜将其从大印度人转变为小印度人。但现实是，你会遇到的大多数机器，现在你会遇到一些小型印度机器。但只是为了给你一个例子，这里是我从实际机器上得到的一些结果。过去周围有一些机器。</p><p>发言人   59:40<br>So back in the old days, I could run this, I don’t even know where to get a big Indian machine anymore. So these are sort of a legacy, a result. But you’ll see the main feature is between a little Indian and a big Indian machine. When you have an integer, the bytes get flipped around so that the least significant byte comes first in a little Indian machine and last in a big Indian machine. And that’s true with negative numbers as well, that you’ll get the sine bits first. In a big Indian machine along, you’ll see that.<br>所以回到过去，我可以运行这个，我甚至不知道在哪里可以买到一个大的印度机器了。所以这些都是一种遗产，一种结果。但你会看到主要特点是介于一个小印度机器和一个大印度机器之间。当你有一个整数时，字节会被翻转，使得最低有效字节在小型印度机中首先出现，在大型印度机中最后。对于负数也是如此，你首先会得到正弦位。在印度的大型机器中，你会看到。</p><p>发言人   01:00:25<br>The only difference between a 32 b machine and a 64 b machine is you have more zeros or more ones depending on whether it’s a positive or negative number. And again, a sun. And if I had access to a 64 b machine, sun is now manufactured by a company called Oracle. So in principle, I could go get one of these machines and run this experiment. But it’s really not a very interesting experiment, so I won’t bother. So in principle, I could try it on a 64 b Oracle machine and show you something different.<br>32 b机器和64 b机器之间唯一的区别是你有更多的零或更多的一，这取决于它是正数还是负数。再说一次，太阳。如果我有机会使用64 b机器，那么sun现在由一家名为Oracle的公司制造。所以原则上，我可以去拿一台这样的机器来进行这个实验。但这真的不是一个非常有趣的实验，所以我不会打扰。所以原则上，我可以在64 b的Oracle机器上尝试一下，并向您展示一些不同的东西。</p><p>发言人   01:01:07<br>So one thing that kind of a useful tool, and the book goes through some examples of this, is a little program that will take a series of bytes starting at some position start and do it for however many bytes you request, and just print out in hex format the two hex digits that represent that byte value. And here, this term pointer. I’m using an unsigned care as a pointer type, sort of generic pointer type.<br>所以有一件有用的工具，这本书介绍了一些例子，就是一个小程序，它将获取从某个位置开始的一系列字节，并为您请求的字节数执行，并以十六进制格式打印出代表该字节值的两个十六进制数字。在这里，这个术语指针。我正在使用未签名的护理作为指针类型，有点像通用的指针类型。</p><p>发言人   01:01:51<br>And so again, if I run this on a x 86 machine. And I’m also, by the way, printing out the actual address that this character is stored at to. And so you’ll see that there’s these addresses with a lot of 7 F’s. What that means is it’s in the upper end of this 47 b address space. If you work it through 7 is three ones then. Enough hex digits here to correspond to. So there’s 11 hex digits beyond the 7. And you’ll see that these addresses are at successive bytes BCB, DBE, BF, and the values are 6 D3 b 0 0 0 0. This is the least significant byte. And these are the successive bytes.<br>再次强调，如果我在x86机器上运行这个。顺便说一下，我还在打印出这个字符存储在到的实际地址。所以你会看到这些地址有很多7个F。这意味着它位于这个47 b地址空间的上端。如果你通过7来工作，那么就是三个一。这里有足够的十六进制数字来对应。所以在7之外有11个十六进制数字。你会看到这些地址是连续的字节BCB，DBE，BF，并且值是6 D3 b 0。这是最低有效字节。这些是连续的字节。</p><p>发言人   01:02:52<br>And similarly, I can use this to examine pointers of various sorts. And I can examine different values and just get their low level byte representations. And so I did this back when I could get to a sun machine, had one way of representing a pointer.<br>同样地，我可以用它来检查各种指针。我可以检查不同的值并获取它们的低级字节表示。所以当我能够到达一台太阳机时，我就这样做了，有一种表示指针的方式。</p><p>发言人   01:03:12<br>And the main point is even across machines, whether it’s byte ordering or whatever, you’ll get different values for pointers. There’s no guarantee that when you load a program into one machine and run it, that it will use the same addresses as that same programming running on a different machine, even if actually they’re identical hardware and operating system. There can be variation because pointers, you can’t directly copy a pointer from one machine to another.<br>而且主要的一点是即使在机器上，无论是字节排序还是其他什么，你都会得到不同的指针值。不能保证当你将一个程序加载到一台机器上并运行它时，它将使用与在另一台机器上运行的相同程序相同的地址，即使它们实际上是相同的硬件和操作系统。可能会有变化，因为指针，你不能直接将指针从一台机器复制到另一台机器。</p><p>发言人   01:03:47<br>One thing about also is regardless of byte ordering, the ordering of of characters is the same. And so a string and C is always represented by a series of bytes where the final byte is 0 null, called null terminated, and the individual bytes correspond to the character codes for that number. And these character codes are just sometimes called Ascii format, which is a little bit old fashioned. By the way. There’s more modern character codes that can represent non-engine alphabets, but the C standard is still back in the days of only supporting the Ascii format question.<br>还有一点是，无论字节排序如何，字符的排序都是相同的。因此，字符串和C总是由一系列字节表示，其中最后一个字节为0空，称为空终止，各个字节对应于该数字的字符代码。而这些字符代码有时被称为Ascii格式，这有点过时。顺便说一下。有更现代的字符代码可以表示非引擎字母，但C标准仍然回到了只支持Ascii格式问题的时代。</p><p>发言人   01:04:54<br>Yes, so this should have been.<br>是的，所以这应该是。</p><p>发言人   01:05:02<br>Well, no, this is good. So I’m casting, I want to show the 4 B size event because this is an int. I’m representing the pointer. Let’s see the code where it’s printing the pointer. All this notation percent p is the directive to say print out a pointer. And percent x is the directive to print out a He representation. So it’s printing out both the address, the starting position of that particular byte. And the value of that byte has two different things. Does that answer your question?<br>好吧，不，这很好。所以我正在铸造，我想展示4 B大小的事件，因为这是一个整数。我代表的是指针。让我们看看它打印指针的代码。所有这些符号百分比p是指示打印出指针的指令。百分比x是打印出表示的指令。所以它打印出地址，即该特定字节的开始位置。并且该字节的值有两个不同的东西。这回答了你的问题吗？</p><p>发言人   01:05:56<br>But remember, show bytes? Is being given a pointer and a length? And so, and what it’s saying is starting at that address, print out the next series of bytes for me. How many bytes I ask for? And in this case I’m creating a pointer to this integer, but I want to show the bytes in that integer, the 4 B that make up that integer. And that’s why I’m giving the number 4 here instead of 8 is.<br>但是记住，显示字节？被给予一个指针和一个长度？所以，它所说的是从该地址开始，为我打印出下一系列字节。我要多少字节？在这种情况下，我正在创建一个指向该整数的指针，但我想显示该整数中的字节，即构成该整数的4 B。这就是为什么我在这里给出的数字是4而不是8。</p><p>发言人   01:06:37<br>Yes, it will be. And that’s fine because in this code I’m using the percent P directive to designate how to print out the pointer. And that will print it as many bytes as it takes for that particular machine that it’s running on. So percent p is actually a very handy directive if you have to print addresses, like for debugging purposes or something, because it will automatically adapt to whatever machine it’s running on question. Well I’ve defined it to be an unsigned care here. So type De is a way to introduce a name for some data type, right? And so I’ve just declared a pointer pointer to refer to an unsigned care.<br>是的，会有的。这很好，因为在这段代码中，我使用百分比P指令来指定如何打印出指针。这将打印它所需要的字节数，因为它正在运行的特定机器上。因此，如果您需要打印地址 (例如用于调试或其他目的)，百分号p实际上是一个非常方便的指令，因为它会自动适应正在运行的任何机器。我在这里将其定义为未签字的护理。所以De类型是为某些数据类型引入名称的一种方式，对吗？所以我刚刚声明了一个指针来引用未签名的护理。</p><p>发言人   01:07:30<br>If you did avoid star, it would not be happy with this reference here, right? You can’t reference a Vo star is just a way to pass around a generic pointer, but you can’t actually reference that element. So what I’m basically doing is saying this reference is treat it like an array, treat my series of bytes as an array, and print out each of the bytes in that array. And so here where I’m a is a number. And I’m taking the address of that integer and casting it to be an unsigned care star. So sort of a slightly generic pointer, but not quite as generic as a void star, and then printing it out.<br>如果你确实避免了star，这里的引用就不会让你满意了，对吧？你不能引用Vo星号只是传递通用指针的一种方式，但你实际上不能引用该元素。所以我基本上要做的是说这个引用将其视为数组，将我的一系列字节视为数组，并打印出该数组中的每个字节。所以在这里，我是一个数字。并且我正在获取该整数的地址并将其转换为未签名的关心星。有点像一个稍微通用的指针，但不像空星那么通用，然后打印出来。</p><p>发言人   01:08:28<br>These are good questions, by the way. OK, so the point being that strings are just strings. And that’s the same from one machine to the next.<br>顺便说一下，这些问题很好。好的，关键是字符串只是字符串。从一台机器到另一台机器也是如此。</p><p>发言人   01:08:43<br>Okay, let’s finish up today with some puzzles. And these have this annoying way of showing up on exams. So it’s worth being able to do these kind of things. And you’ll also notice I cleverly did not include the answers in the slides.<br>好的，让我们以一些谜题结束今天的比赛。这些在考试中出现的方式很烦人。所以能够做这些事情是值得的。你也会注意到，我巧妙地没有在幻灯片中包含答案。</p><p>发言人   01:09:05<br>So you can’t just peek ahead and figure out what the Nss are. So let’s just go through them. But I actually worked them out to make sure I have the Nss right. So, and basically, these are sort of statements that you want to say, these are either always true, and maybe there’s some logic behind why it’s always true or it’s possibly false. And you have to give some example that would make that false. So let’s go through these as many as we have time for and see where we get to.<br>所以你不能只是往前看，然后弄清楚Nss是什么。所以让我们通过它们。但我实际上已经解决了这些问题，以确保我的Nss是正确的。所以，基本上，这些是你想说的陈述，这些要么总是正确的，也许有一些逻辑为什么它总是正确的，或者它可能是错误的。你必须给出一些例子来证明这是错误的。所以，让我们尽可能地浏览这些，看看我们能走到哪里。</p><p>发言人   01:09:36<br>So if I take x and I double it, multiply it by two, if x were negative, am I guaranteed that 2x will be negative? So by the way, one general way to find counter example ins is to try t min. It’s a really good one. And that works here. If I take TN, which is 1 and a bunch of zeros, I double it. It’s like shifting it, but left, and it will become what, 0? And so again, assume that x is at any negative number and uux. Is issed I’m sorry, any two’s complement number and uux is what happens if I cast it to be unsigned? So is uux always greater than or equal to 0, yeah?<br>所以，如果我取x，我把它加倍，乘以二，如果x是负的，我可以保证2x是负的吗？所以顺便说一下，找到反例的一种一般方法是尝试t min。这是一个非常好的。这在这里是有效的。如果我取TN，它是1和一堆零，我会加倍它。这就像转移它，但是离开了，它会变成什么，0？所以再次假设x是任何负数和uux。很抱歉，任何两个的补码数和uux是如果我将其转换为无符号会发生什么？所以uux总是大于或等于0，是吗？</p><p>发言人   01:10:30<br>It is slightly more obscure. If I take x and I mask off, 7, you remember is the bit pattern 1, 1, 1. So if I mask off all but the lowest 3 b, and I find that those are all ones. I’m already giving you the answer here, and then I shift it left by 30 positions. What can I say about the result?<br>它稍微模糊一些。如果我将x和掩码关闭为7，您记得这是位模式1，1，1。所以如果我把除了最低的3 b以外的所有都掩盖掉，我发现那些都是一的。我已经在这里给你答案了，然后我把它向左移动了30个位置。我能对结果说些什么？</p><p>发言人   01:11:04<br>So I know that x must finish with three ones, right? And I shift that. By 30.<br>所以我知道x必须以三个1结尾，对吗？我改变了这个。到30。</p><p>发言人   01:11:24<br>And these will be the only 2 b that are left after the shifting. And they will be in the most significant position. So what can I say about that number? It’s negative. So this is a true statement, rather obscure, but it is true, is uux greater than -1? It’s almost true, right? The one counter example, that would be what? Zero, well, actually, no, you’re right. There’s a lot of examples. It’s hardly ever true, it’s almost always fault. I was wrong. The only thing that would make it true would be actually, it’s never true. So it’s never true. OK, if x is greater than y is minus x less than minus y?<br>这些将是转移后剩下的唯一2 b。他们将处于最重要的位置。关于这个数字，我能说些什么呢？这是负面的。所以这是一个真实的陈述，相当晦涩，但它是真实的，uux是否大于-1？这几乎是真的，对吧？唯一的反例是什么？零，实际上，不，你是对的。有很多例子。这几乎从来都不是真的，这几乎总是错的。我错了。唯一能使它成为现实的是，它永远不是真的。所以这从来都不是真的。好的，如果x大于y是负x小于负y？</p><p>发言人   01:12:39<br>No, so by the way, one thing we didn’t really cover is what is the negative of t min?<br>不，所以顺便说一句，我们没有真正涵盖的一件事是t min的负数是什么？</p><p>发言人   01:12:51<br>And to see that we can use our comp and increment trick.<br>并且看到我们可以使用我们的comp和increment技巧。</p><p>发言人   01:13:03<br>So when you complement an increment t min, you get t min. And that’s why it’s such a great counter examples. So in particular, if. Y is t min, and x is something else. Then the left hand part will be true, but the right hand part will not be true.<br>因此，当你补足一个增量t min时，你得到t min。这就是为什么它是如此好的反例。尤其是，如果。Y是t min，x是另一种东西。那么左手部分将是正确的，但右手部分将不是正确的。</p><p>发言人   01:13:31<br>X times x greater than or equal to 0. We’ve seen examples of that being fault. If this is kind of silly, if x is greater than 0 and y is greater than 0, is x plus y greater than 0? No, if x is greater than or equal to 0, is minus x less than or equal to 0? Gotcha, you’re right. It’s true, right? Because, but let’s take its counterpart, if x is less than or equal to 0, is minus x greater than equal to 0 TN So the point being that the largest, any positive number can be represented as negative, but there’s one negative number that can’t be represented as positive. And so that asymmetry is why you get different answers to these.<br>X乘以x，大于或等于0。我们已经看到了这种错误的例子。如果这有点傻，如果x大于0而y大于0，那么x加y是否大于0？不，如果x大于或等于0，那么负x是否小于或等于0？你说得对。这是真的，对吧？因为，让我们取它的对应项，如果x小于或等于0，则减去x大于等于0 tn，因此要点是，最大的任何正数都可以表示为负数，但有一个负数不能表示为正数。因此，这种不对称性就是为什么你会得到不同的答案。</p><p>发言人   01:14:30<br>If I take x and I look at minus x, and I shift them to the right by 31 AM I going to get all ones? This is a really weird statement.<br>如果我拿x，然后看负x，然后把它们向右移动31，我会得到所有的一吗？这是一个非常奇怪的声明。</p><p>发言人   01:14:53<br>So it actually kind of works if I take all zeros.<br>所以如果我取全部零，它实际上是有效的。</p><p>发言人   01:15:07<br>And I subtract 1. I’ll get -1.<br>我减去1。我会得到-1。</p><p>发言人   01:15:16<br>And I order them. That works. So what’s wrong with this? What’s that? Oh, but if I shift this to the right 31 places, it’s going to shift arithmetically.<br>我订购了它们。这很有效。这有什么问题吗？那是什么？哦，但如果我将它向右移动31位，它将在算术上移动。</p><p>发言人   01:15:46<br>What’s that? Oh I see, oh I’m sorry, I already jumped ahead to a different puzzle. X and minus x I. So you’re right, actually, if the two numbers are 0. And I order those, I get 0. But you’ll figure out, you’ll notice if it’s anything non-zero, actually, this will be true. And that’s an interesting feature. So there’s a couple other puzzles, and I’ll let you solve those on your own. We’re all set for today.<br>那是什么？哦，我明白了，哦，对不起，我已经跳到了另一个谜题。X和-x I。所以实际上你是对的，如果这两个数字都是0。我订购那些，我得到0。但是你会发现，如果它是任何非零的东西，实际上，这将是真的。这是一个有趣的特点。所以还有其他几个谜题，我会让你自己解决这些谜题。今天我们都准备好了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深入理解计算机系统 002-Bits,Bytes,andInteger</title>
    <link href="/2025/10/12/15213-002/"/>
    <url>/2025/10/12/15213-002/</url>
    
    <content type="html"><![CDATA[<embed src="/images/15213-002.pdf" type="application/pdf" width="100%" height="600px" /><p>发言人   00:00<br>I see a lot of people figured out to come early, so good for you. So as you recall, my name is Randy Bryant and I’m cosins tuctoria this course along with Jay o’hallor, and for the next couple lectures, the first part of this course, really, we’ll be talking about sort of data representations, in particular, how numbers are represented in different forms in some of the properties. And you saw in that when I talked last week, I showed you things like you can multiply some numbers together that are positive and get negative results. So what we want to understand is what is a bit level representation of numbers and how does that affect some of the properties you have when you operate them on? And especially looking at the corner cases, when things overflow, don’t do what you might expect them to do. So we’ll start off with very basic stuff of how numbers are represented, especially integer valued numbers are represented in bits.<br>我看到很多人想出早点来，对你有好处。正如你所记得的，我叫兰迪·布莱恩特，我是科斯金斯·图克托利亚，和杰伊·奥哈罗一起上这门课程，在接下来的几次讲座中，在这门课程的第一部分，我们将特别讨论数据表示。数字在某些属性中如何以不同的形式表示。你可以看到，当我上周谈话时，我向你展示了一些东西，比如你可以将一些积极的数字相乘，得到消极的结果。所以我们想要理解的是，数字的位级表示是什么，以及当你对它们进行操作时，它如何影响你拥有的一些属性？特别是在角落里，当事情溢出时，不要做你期望他们做的事情。所以我们将从如何表示数字的最基本的东西开始，特别是用比特表示整数值的数字。</p><span id="more"></span><p>发言人   01:06<br>So I think you’ve pretty well figured out in this world that the whole digital world is sort of based on binary values. And that wasn’t always the case. I mean, since humans have 10 fingers and 10 toes, a lot of the world was based on the decimal system. And it was really only, and in fact, the first electronic computer, the ENIAC built in University of Pennsylvania, basically encoded, did all of its arithmetic using base 10. They had 10 vacuum tubes per digit they wanted to represent. So they basically turned on or off those tubes to represent which of the 10 possible digits you could want. And it really didn’t come to people until later than that. So that’s 1948, that they really should just think about base 2 for everything.<br>所以我认为你在这个世界上已经很好地意识到，整个数字世界都是基于二进制值的。但情况并非一直如此。我的意思是，由于人类有10个手指和10个脚趾，世界上很多东西都是基于十进制系统的。实际上，它是第一台电子计算机，宾夕法尼亚大学制造的ENIAC，基本上是用10为基数进行编码和所有算术运算。他们想要表示的每个数字有10个真空管。所以他们基本上打开或关闭这些管来代表你想要的10个可能的数字中的哪一个。而且直到后来才真正降临到人们身上。所以那是1948年，他们真的应该只考虑以2为基数的一切。</p><p>发言人   02:04<br>And the reason why bits are great is in the digital world, you can sort of take what’s otherwise an analog signal and quantify it and just say I’m going to say that one range of values, let’s say it’s a low voltage. I’m going to call that a 0. And the high range of values I’m going to call it a one. And if there’s noise or imperfections in the circuit or anything going on, as long as that doesn’t exceed these thresholds you’ve set up, then you’ll get a nice clean signal out of it. And that’s the main advantage of digital processing over analog processing. And so that’s sort of at the core why everything we do, and especially for storing information, it turns out it’s much easier to store 1 b of information or a digital value than it is to store an analog value.<br>比特之所以伟大的原因在于数字世界，你可以取一个模拟信号并量化它，然后说我要说的是一个范围的值，假设它是一个低电压。我会称它为0。以及我将称之为 “一” 的高范围价值观。如果电路中存在噪音或缺陷或任何情况，只要不超过您设置的这些阈值，那么您将得到一个干净的信号。这就是数字处理与模拟处理相比的主要优势。这就是我们所做的一切的核心原因，尤其是对于存储信息，事实证明，存储1 b信息或数字值比存储模拟值要容易得多。</p><p>发言人   03:04<br>Sorry. Slides went a little crazy on animations. So the point is that we represent all the numbers in a computer as sets of bits. And I think you generally understand that fairly well. And so, of course, the familiar binary representation of integers, which we’ll go over today, just uses a bit position for each power of two.<br>对不起。幻灯片在动画方面有点疯狂。关键是我们将计算机中的所有数字表示为一组位。我想你一般都相当了解这一点。所以，当然，我们今天会介绍的整数的二进制表示形式，只是对每个2的幂使用一个位位置。</p><p>发言人   03:29<br>We can also represent values that are fractional. And we’ll talk about that a week from today when we do floating point numbers, where what you do is to the right of the binary point is no longer a decimal point, it’s a binary point. And so something to the left of that would have weight 1, 2 to the zero, and the next one over would have weight 2 to the one. But what you do is you go to the right that has weight to the -1, to the -2. In other words, one, this is 2, this is one half, and this is 1 4. So we can represent just like you do the decimal representation of fractions, we can do the binary representation of fractions. And that’s the core of floating point number representations.<br>我们也可以表示分数形式的值。我们将在今天进行浮点数的一周后讨论这个问题，那时你要做的是在二进制小数点的右边不再是小数点，而是一个二进制小数点。因此，左边的物体的权重为1，2为零，下一个物体的权重为2。但你要做的是你走到权重为-1和-2的右边。换句话说，1，这是2，这是一半，这是1 4。所以我们可以像小数一样表示小数，我们可以用二进制表示小数。这就是浮点数表示的核心。</p><p>发言人   04:25<br>And so it gets very annoying if you have, say, 32 or even 64 b numbers to be writing these strings of ones and zeros out. And so what we use and what’s become largely the most common is to group collections of 4 b at a time.<br>因此，如果你有32个甚至64个b的数字要写出这些1和0的字符串，就会变得非常烦人。因此，我们使用的最常见的方法是一次将4个b的集合分组。</p><p>发言人   04:46<br>And then represent that in base 16, or what’s known as hexadecimal representation, using the letters A through F as values 10 through 15. And you’ll spend a lot of time staring at hexadecimal numbers this year, and you’ll get pretty good at being able to look at a hex number and just write it out in binary The way I do it, just to tell you is, I mean I’ve got the values from 0 to. Nine wired down pretty well. And then I keep track of a few special cases. One 0, 1, 0 is a 1, 0, 0 is C, and 1, 1, 1, 1 is f For b, d, and e, I kind of interpolate between those. So if you want to develop that skill, that’s the way you can do it.<br>然后用基数16表示，也就是所谓的十六进制表示，使用字母A到F作为值10到15。你今年会花很多时间盯着十六进制数字，你会变得相当不错，能够看到十六进制数字并像我一样以二进制形式写出，只是为了告诉你，我的意思是我得到了从0到的值。九个连接得很好。然后我会跟踪一些特殊情况。一个0，1，0是一个1，0，0是C，1，1，1是b，d和e的f，我有点在它们之间插值。所以，如果你想发展这项技能，这就是你可以做到的方式。</p><p>发言人   05:49<br>You’re looking for something connector, an Hdmi to what? No, I don’t think there’s any connector here.<br>你正在寻找连接器，Hdmi到什么？不，我不认为这里有任何连接器。</p><p>发言人   06:03<br>So that’s something you’re going to end up wanting to be able to do. So in C, we don’t.<br>所以这将是你最终想要能够做到的事情。所以在C中，我们没有。</p><p>发言人   06:13<br>In most declarations, you don’t actually are told exactly how many bytes a byte is 8 b each data value is represented as, and that’s partly C was designed actually back when microprocessors only had 16 b words. It was actually before microprocessors. So 16 b words were a fairway standard thing, and over time, that’s expanded from 16 to 32 to now 64. And so C, rather than sort of in advance saying, here’s how many bytes every value we’ll have, has these slightly ambiguous terms that vary actually from one machine to the next. And if you’re a very careful C programmer, you have to anticipate that sum. But what we’ll deal with is X 8664 is the class of machines we’ll be working with exclusively this term.<br>在大多数声明中，您实际上不会被告知每个数据值表示为8 b的字节数，并且这部分是在微处理器只有16 b字的时候设计回来的。它实际上是在微处理器出现之前。因此，16个b单词是球道标准的东西，随着时间的推移，它从16个增加到32个，现在已经增加到64个。因此，C并不是事先说每个值有多少字节，而是有这些稍微含糊不清的术语，实际上它们因机器而异。如果你是一个非常谨慎的C程序员，你必须预见到这个总和。但是我们将要处理的是X 8664，它是我们将专门使用这个术语的机器类别。</p><p>发言人   07:10<br>And so you can see that when you declare something to be a char, sometimes people call that a char. That’s a 1 B value. A short is 16 by bit, an int is 32. And if you want to get all 64 b, you have to declare it to be a long.<br>所以你可以看到，当你声明某物是char时，有时人们称之为char。这是一个1 B的值。一个short是16位的，一个int是32。如果你想获得全部64 b，你必须声明它是长的。</p><p>发言人   07:32<br>And then again, there’s two different precisions of floating point. There’s 4 B or 32 b of floating point numbers and 64 b. There’s also a slightly obscure holdover from ancient days of of floating point, where there’s a special representation in Intel machines that uses a 10 B or 80 b representation. And when you use that on a. 64 b machine. They sort of waste an extra 6 B out of that so that everything is aligned in 16 B increments.<br>然后，有两种不同精度的浮点运算。有4 B或32 b的浮点数和64 b的浮点数。还有一个与浮点数古代相比有些模糊的保持，在英特尔机器中有一个特殊的表示，它使用10 b或80 b的表示。当你在a上使用它时。64 b机器。他们有点浪费额外的6 B，这样所有的东西都以16 B的增量对齐。</p><p>发言人   08:09<br>The other thing, and this is an important feature, is any address is defined to be the word size of the machine when they say it’s a 64 b machine, what they really mean is that the addresses are 64 b values or 8 B values. And that’s different, For example, if you use an older machine, a 32 b machine, those will only be 32 b addresses.<br>另一个重要的特性是，当他们说机器是64 b时，任何地址都被定义为机器的字数，他们真正的意思是地址是64 b值或8 b值。这是不同的，例如，如果您使用一台较旧的机器，一台32 b的机器，这些将只是32 b的地址。</p><p>发言人   08:37<br>So the basis then, imagine you’ve had this at some point of how do we then think about bits is based on Boolean algebra, which actually comes from the 1890s, that a guy named George Boe who recognized a sort of relation between what we’d call bits, but they weren’t called bits back then.<br>因此，想象一下，在某个时候我们如何思考位的基础是基于布尔代数的，它实际上来自18 90年代，一个名叫George Boe的人认识到我们所谓的位之间的一种关系，但它们当时不被称为位。</p><p>发言人   09:04<br>0, 1, and logic are basically truth values in logic. I’m thinking of an algebra, sort of a structured set of operations you could apply that would capture some of the concepts that people assume in logic. So for example, if we think of one being true and 0 being false, then the And operation is true if both of the inputs, both of the arguments are true. So we get this chart here. And similarly, the Or operation is true if either input is true or one, the nod is just to flip the bit, and then the exclusive, or is what you get when you say it’s one or the other, but not both. And so it has this representation.<br>0、1和逻辑基本上都是逻辑中的真值。我正在考虑一种代数，一种可以应用的结构化操作集，可以捕捉人们在逻辑中假设的一些概念。因此，例如，如果我们认为一个是真的，0是假的，那么如果两个输入，两个参数都是真的，那么和操作就是真的。所以我们在这里得到这张图表。类似地，如果输入为真或为一真，则或操作为真，点头只是翻转位，然后是互斥，或者是当你说它是一个或另一个时得到的，而不是两个。所以它有这种代表性。</p><p>发言人   09:53<br>So just as a bit of history, it was master’s degree student at MIT named Claude Shannon who had taken a course in logic as an undergraduate at University of Michigan. And he was the one who made the connection between thinking about this, what was at the time very obscure branch of something or other of logic, and applying it to digital systems back in an era when they actually built these things out of electromechanical relays. And so his master’s thesis is probably the most impactful master’s thesis in the history of humankind. And you always wonder, well, what did they do before that? Then? How did they even think about these things anyways, the idea of applying this algebra then to bits is not something that’s sort of been true since the world began. It’s something that’s a relatively modern concept.<br>因此，作为历史的一部分，麻省理工学院的硕士研究生克劳德·香农在密歇根大学本科学习了逻辑学课程。他是那个将思考这个在当时非常模糊的逻辑分支和将其应用于数字系统之间联系起来的人，当时他们实际上是用机电继电器构建这些东西的时代。所以他的硕士论文可能是人类历史上最有影响力的硕士论文。你总是想知道，好吧，在那之前他们做了什么？那么呢？无论如何，他们是如何思考这些事情的，将代数应用于比特的想法并不是自世界开始以来就一直存在的事情。这是一个相对现代的概念。</p><p>发言人   10:59<br>Now, what’s an important? Thing that might be less obvious is we can also do these over words. We can do these Boolean operations where we apply them on each successive bit in that word. And these symbols, we use, the ampersand vertical bar cart and tilde are actually the ones that C uses to represent these operations. And so again, if we look at here, the one is only if both of the values are one. And for the, for the n for the, or if either of them are one, the exclusive, or if 1 is one and the other is 0, and tilde is just to invert the bits of it.<br>现在，什么是重要的？可能不太明显的是，我们也可以通过文字来实现这些。我们可以进行这些布尔操作，将它们应用于该单词中的每个连续位。我们所使用的这些符号、与符号垂直饮料服务车和代字符实际上是C用来表示这些操作的符号。因此，如果我们再看看这里，只有当两个值都是一个时，才会出现一个。对于n，对于n，或者如果其中一个是一个，则为互斥，或者如果1为1而另一个为0，则波浪号只是将其位反转。</p><p>发言人   11:45<br>Again, we will spend a lot of time making use of the fact that in C, and this is one of the features of C that people like, is that you can do these here at a very low level bit of manipulation directly in the language. And this actually turns out to be useful in practice.<br>再说一遍，我们将花费大量时间利用这个事实，即在C语言中，这是人们喜欢的C语言的特点之一，你可以在这里直接在语言中以非常低级别的操作来实现这些功能。这在实践中实际上是有用的。</p><p>发言人   12:05<br>And it’s sort of implicit of a way of representing sets of values. So this example is, imagine we want to represents sets where the elements of the set are numbers ranging between 0 and 7. So 1 B is enough to capture eight cases and will, if we number the bits and we number them from right to left, so this is bit 0. So that would represent whether or not the value 0 is an element of the set And simly here, you’ll see 0, 1, 2, 3. So we’re saying that bit 3 being one here means 3 is an element of the set, and so forth. So the idea. Is then the and operation becomes like set intersection, the Or operation becomes like set union, and the exclusive or operation is what’s called symmetric difference. And so these are and tilde is like complement.<br>它是一种隐含的表示值集合的方式。所以这个例子是，想象我们想要表示集合，其中集合的元素是范围在0到7之间的数字。因此，如果我们对比特进行编号并从右到左对它们进行编号，则1 B足以捕获8种情况，因此这就是第0位。因此，这将表示值0是否是集合的一个元素，简单地在这里，您将看到0，1，2，3。所以我们说这里的第3位表示1，意味着3是集合的一个元素，依此类推。所以这个想法。然后，和操作变得像集合交集，或操作变得像集合并集，而异或操作就是所谓的对称差。因此，这些是和波浪号就像补码一样。</p><p>发言人   13:15<br>So these are actually very common. For example, there’s.<br>这些其实很常见。例如，有。</p><p>发言人   13:24<br>Operations you’ll learn later when we look at file IO about IO that you can track, I want to know which set of possible inputs to the system. Think of different network connections. Have an input ready for me to read, and there is a data structure that it’s sort of hidden away among some seeing library calls. But it basically is using exactly this representation, about 1000 of bits worth of information to represent these sets and do manipulation on those sets.<br>当我们查看可以跟踪的有关IO的文件IO时，您将会学习操作，我想知道系统有哪些可能的输入。考虑不同的网络连接。有一个输入准备好供我阅读，并且有一个数据结构，它有点隐藏在一些看到的库调用中。但它基本上就是使用这种表示形式，大约1000位的信息来表示这些集合，并对这些集合进行操作。</p><p>发言人   14:08<br>So as I mentioned, those are available directly in C, the ampersand vertical bar tilde and cart.<br>正如我所提到的，这些可以直接在C中使用，即 &amp; 竖线波浪号和购物车。</p><p>发言人   14:17<br>One thing that’s really, really important and that programmers screw it up all the time, beginning programmers and even experienced programmers from time to time, is to mix up single ampersand and the double ampersand, or the single vertical bar and the double vertical bar and the tilde versus the exclamation mark, which is often pronounced, bang. And the reason so. Obviously, there’s sort of a. Syntactic similarity. And there’s actually a somewhat of a semantic relation too. This is another kind of and another kind of Or, and another kind of not. Mix and match these. You’re certainly going to have problems.<br>有一件非常重要的事情，即程序员，新手程序员甚至有经验的程序员，不时搞砸它，就是混淆单个和双符号，或者单个竖条和双竖条以及波浪号和感叹号。这通常被发音为bang。这就是原因。显然，有一种。句法相似性。实际上还有一种语义关系。这是另一种类型的或者，另一种类型的不是。混合搭配这些。你肯定会遇到问题。</p><p>发言人   15:03<br>So the double bar ones aren’t thinking about bitwise operations. They’re thinking about something that’s either true or false, period. And in that representation, the number 0 is the thing that’s false and anything else, any other bit pattern is considered to be true. And so the other feature that the double operations give you is what’s called early termination.<br>所以双线的人没有考虑按位操作。他们正在考虑一些不是对就是错的事情，时期。在这种表示中，数字0是假的，其他任何比特模式都被认为是真的。因此，双重操作给你的另一个功能是所谓的提前终止。</p><p>发言人   15:33<br>So in particular, if we do some examples on some hex pattern for one. So this is a. Not a 0. And so that’s considered true in this interpretation. The bang of that, the knot of that is 0. In same way, if you have 0, the knot of that is one. And if you apply bang to a number twice, you’ll get back a one, unless it was 0. And then similarly, these patterns here are the reason why this returns one is because it’s considered two cases that are true.<br>所以特别是，如果我们在一些十六进制模式上做一些例子。所以这是a。不是0。因此，在这种解释中，这被认为是正确的。那砰的一声，那的结是0。同样地，如果你有0，那么它的结就是1。如果你对一个数字应用两次，你会得到一个1，除非它是0。然后同样，这些模式在这里是返回一个的原因，因为它被认为是两种真实的情况。</p><p>发言人   16:20<br>So it’s not doing bitwise operations. It’s just trying to create true and false. It’s interpreting arguments to be either true or false and returning either true or false. But when it returns true, it returns one and not whatever number you happen to give it.<br>所以它不进行按位操作。它只是试图创造真实和虚假。它将参数解释为真或假，并返回真或假。但当它返回true时，它会返回一个，而不是你给它的任何数字。</p><p>发言人   16:36<br>So obviously, this is a very different operations than you have with the single versions of those. But it’s easy just because you mentally slip or because you type something wrong to do the wrong thing. But in particular, this early termination is something that, of course, people use a lot.<br>显然，这是一个与单个版本的操作非常不同的操作。但这很容易，只是因为你精神上的失误，或者因为你输入了错误的东西而做错事。但特别的是，这种提前终止当然是人们经常使用的东西。</p><p>发言人   16:57<br>If you want to make sure that you’re not accessing a null pointer, you can test whether that’s a null pointer first before accessing it. And if this is zero or a null, then it won’t do the dereferencing of null. So it’s a fairly useful feature as well. Anyways, that’s an aside. At this level, we’re mostly looking at bits, but just as a programming note, don’t mix these up.<br>如果你想确保你没有访问空指针，你可以在访问它之前先测试它是否为空指针。如果这是零或null，则它不会取消null的引用。所以这也是一个相当有用的功能。不管怎样，这是旁白。在这个层面上，我们主要看的是比特，但只是作为编程说明，不要混淆这些。</p><p>发言人   17:34<br>The other class of operations will make use of a lot are shifting, which again, is not something that you normally sort of as beginning programmers think about too much. And there’s a curious feature that left shifts are always the same, but there’s two different flavors of right shift. And we’ll see in a little bit later why there’s two different flavors of right-shift but.<br>另一类操作将会利用很多东西正在转移，这不是你通常作为新手程序员考虑得太多的事情。而且有一个奇怪的特征，即左移总是相同的，但右移有两种不同的风格。稍后我们会看到为什么有两种不同风格的右移位。</p><p>发言人   17:58<br>The idea then of shifting is that you have some argument x, and you want to shift it some number of positions either to the left or to the right, given by y, and so when you shift left, you just fill in whatever value there was. So you pick up the I’m shifting by three. So I’ll take the lower order, 5 b, move them over three positions, and then fill in with a 0 and whatever was in the upper positions of that original, where they just sort of disappear into the into nowhere. Similarly, if I do a right shift, I take the upper 6 b, I move them over two positions, and I fill in with zeros. So that’s a logical shift and that’s it’s logical.<br>移位的想法是，你有一些参数x，你想要将它向左或向右移动一些位置，由y给出，所以当你向左移动时，你只需填写任何值。所以你拿起我正在移动三个。所以我会选择较低的顺序，5 b，将它们移动到三个位置，然后填充0和原始位置较高的任何东西，在那里它们就会消失在无处。同样地，如果我右移，我取上部的6 b，将它们移动到两个位置上，然后用零填充。这是一个合乎逻辑的转变，这就是合乎逻辑的。</p><p>发言人   18:46<br>There’s another flavor called the arithmetic shift, which differs in the rule for what bits you fill in with are not based on, are not zeros necessarily, but whatever the most significant bit was in the original value. So it doesn’t matter here because the most significant bit was 0, but you’ll see in the case here of where the leading bit was a one, that when I shift it to the right arithmetically I’ll fill it in with once. And that’ll make sense more when we understand how negative numbers get represented in a machine. And that’s the purpose of it and why it’s called arithmetic. The other thing that is kind of confusing to people is what should happen if you say, I want to shift an 8 b number, 8 positions to the left?<br>还有另一种叫做算术移位的方法，它的不同之处在于您填充的位不是基于的规则，也不一定是零，而是原始值中最重要的位。所以在这里并不重要，因为最高有效位是0，但你会看到在这里的前导位是1的情况下，当我将其算术向右移动时，我将用一次填充它。当我们理解负数在机器中的表示方式时，这将使感知更加重要。这就是它的目的，也是它被称为算术的原因。另一件让人们有点困惑的事情是，如果你说我想把一个8 b的数字向左移动8个位置，应该会发生什么？</p><p>发言人   19:55<br>And x is a single byte. What do you think you should get? Zero, that would be a pretty logical thing.<br>x是一个单字节。你认为你应该得到什么？零，这将是一件相当合乎逻辑的事情。</p><p>发言人   20:06<br>You kind of shift all those bits out, you fill them with zeros. On most machines, you’ll get whatever x was. Because what it will do is it will compute this number mod a. And the reason that happens is, if you think about it, it’s looking at just the low order 3 b of the shift amount and ignoring all the rest. So that’s effectively like module 8. So that’s just a warning. And on some machines, it does what you just thought it should, and other machines it does this. And so there’s no guarantee in C that it will be one way or the other.<br>你把所有这些位都移动出来，用零填充它们。在大多数机器上，你会得到x是什么。因为它将会计算这个数字mod a。发生这种情况的原因是，如果你仔细想想，它只看移位量的低阶3 b，而忽略了所有其余的部分。所以这实际上就像模块8一样。所以这只是一个警告。在某些机器上，它会做你刚才认为它应该做的事情，而在其他机器上，它会这样做。因此，在C中并不能保证它会是一种方式还是另一种方式。</p><p>发言人   20:54<br>Same with if you try to shift left by a negative number, that might be logically, well, I guess you really want to shift right then, but that usually doesn’t work either. So now let’s talk about number representations. This is sort of a very core idea that you have to really have wired in you. And I’m going to illustrate it with some examples.<br>同样，如果你试图向左移动一个负数，这可能是逻辑上的，好吧，我猜你真的想向右移动，但这通常也不起作用。现在让我们来谈谈数字表示。这是一个非常核心的想法，你必须真正与之相连。我会用一些例子来说明。</p><p>发言人   21:29<br>So these two equations, then, are everything that we’ll talk about sort of stems from them. So one is if you have an unsigned number, then basically. So he keeps jumping on me.<br>那么这两个方程式，就是我们将要谈论的一切都源于它们。所以一个是，如果你有一个无符号的数字，那么基本上。所以他一直跳到我身上。</p><p>发言人   21:48<br>If you have an unsigned number, then this is just the conversion. Then Btu means from bit, a bit level representation to an unsigned number of some bit pattern. It just says, well, just add up the sum of the weighted bits where each bit is weighted by a power of two. And the only difference when we look at two’s complement, which is a way to represent both negative and positive numbers, we’ll consider the most significant bit to be what’s called the sine bit. So it will have a negative value. So let me just illustrate this with I’ll use some running examples, and we’ll just use 5 b numbers just as a way it really helps often if you’re trying to understand this stuff, to do it for some smaller cases. So if we think about bit positions.<br>如果您有一个无符号数字，那么这只是转换。然后Btu意味着从位，一个位级表示到某个位模式的无符号数字。它只是说，好吧，只需将加权位的总和相加，其中每个位加权2的幂。当我们看2的补码时唯一的区别是，这是一种表示负数和正数的方式，我们会认为最重要的位是所谓的正弦位。因此它将具有负值。所以让我用一些运行的例子来说明这一点，我们只使用5 B数字，如果你试图理解这些东西，对于一些较小的情况来说，它经常会有所帮助。所以，如果我们考虑位的位置。</p><p>发言人   22:50<br>Zero through 4.<br>从零到四。</p><p>发言人   23:00<br>Then those represent different powers of two weights, as I’ve shown. And so now if we take some bit pattern.<br>那么这些代表两个权重的不同幂，正如我所展示的那样。所以现在如果我们采取一些模式。</p><p>发言人   23:20<br>Like so. So that’s what I’ll call x, and I want to convert that to an unsigned number. I will just combine 8 plus 4 plus 1, and I’ll get 13. So that’s all that equation says, the left hand equation. Bit positions that are ones use the corresponding power of 2, and you’re done. And similarly, if I have a number where there’s a leading bit.<br>就像这样。所以这就是我称之为x的东西，我想将它转换为无符号数字。我只需要把8加4加1结合起来，就能得到13。这就是这个方程所说的一切，左手方程。位位置使用相应的2的幂，你就完成了。类似地，如果我有一个数字，其中有一个前导位。</p><p>发言人   24:03<br>It will be 16 plus 4 plus 2, so that will be 22. And so that’s the unsigned case.<br>它将是16加4加2，因此将是22。这就是未签署的案例。</p><p>发言人   24:16<br>And the sine case is the same idea, except that most significant bit. Has a negative value? So this is I. And our weights will be 1, 2, 4, 8. But this will now be -60. So that’s what the equation on the right is saying. But this bit, now we’re going to change it from being a negative number to a positive. So obviously, if I have, this is my bit pattern, it’s going to be the same because the other bit stay the same. So let’s do it for this case of 1 0 1 1, 0. So that will be -16 plus 4 plus 2. So that will equal -10. So you see in this case, we have the same bit pattern.<br>和正弦情况是相同的想法，除了最高有效位。有负值吗？这就是我。我们的权重将是1、2、4、8。但现在这将是-60。这就是右边的方程式所说的。但是这个位，现在我们要将它从一个负数改为正数。所以很明显，如果我有，这是我的位模式，它将是相同的，因为其他位保持不变。所以让我们为这个1 0 1，0的情况做这件事。这将是-16加4加2。这将等于-10。所以你可以看到，在这种情况下，我们有相同的位模式。</p><p>发言人   25:20<br>It’s just if we interpret it how we think about what number this represents, then in one case, it’s a positive number, 22, and in another case, it’s a negative number -10. And that’s what these equations are saying.<br>这只是如果我们如何解释它，我们认为这代表什么数字，那么在一种情况下，它是一个正数22，在另一种情况下，它是一个负数-10。这就是这些方程式所说的。</p><p>发言人   25:42<br>And so the most significant bit is sometimes called the sine bit, because if it’s a 1, the number is going to be negative. So? Let’s sort of think about. What are the sort of extreme ranges of numbers we can get with these two different representations?<br>因此，最重要的位有时被称为正弦位，因为如果它是1，则数字将是负数。所以呢？让我们思考一下。使用这两种不同的表示方式，我们可以得到什么样的数字极端范围？</p><p>发言人   26:14<br>So obviously, if these are all zeros, my number is going to equal 0. And if it’s all one?<br>所以显然，如果这些都是零，我的数字将等于0。如果都是一个呢？</p><p>发言人   26:28<br>It will be 16 plus 8 plus 4 plus 2 plus 1 will be 31. And over here, for the two’s complement, the smallest number, well, the largest number, well, actually the let. Me do it this way. Actually, the most negative number, so the smallest number in the strictest sense of the word, is this. It’s -16. And you can argue this, by the way, is the that has a negative weight, all the other ones have positive one. So certainly one, all the rest being zeros is going to be the smallest number. And similarly, the largest number you can represent.<br>它将是16加8加4加2加1将是31。在这里，对于两个补码，最小的数字，最大的数字，实际上是let。我是这样做的。实际上，最负的数字，也就是这个词最严格感知中最小的数字。这是-16。你可以争辩说，顺便说一下，是负权重的，其他所有的都有正权重。所以可以肯定的是，所有其余的都是零，将是最小的数字。同样，您可以代表的最大数字。</p><p>发言人   27:22<br>Will be 8 plus 4 plus 2 plus 1, which is 15. And so we call this number u max. And we call this number T max. And we call this number t min.<br>将是8加4加2加1，即15。所以我们称这个数字为u max。我们称这个数字为T max。我们称这个数字为t min。</p><p>发言人   27:50<br>So there’s a few things to observe about these numbers. Remember, this is a 5 b word size. So you’ll see that 31 is pretty close to 32. In fact, it’s 2 to the 5th -1. And in general, and that’s for a 5 b word size. So you would say in general, it will have value 2 to the w, if I have a w bit number -1. And that’s what this shows. And similarly, over here, this is -2 to the fourth. And so we’d say in general, that will be -2 to the w, if it’s a w number -1. All these make sense.<br>关于这些数字，有几点需要观察。记住，这是一个5 b的单词大小。所以你会看到31非常接近32。实际上，它是2的5th -1。一般来说，这适用于5 b的单词大小。所以你会说，一般来说，如果我有一个w位数字-1，它的w值将为2。这就是它所展示的。同样地，在这里，这是-2到第四个。因此，我们通常会说，如果是w编号-1，那么w的值将是-2。所有这些都使感知。</p><p>发言人   28:53<br>By the way, You’ll notice one other feature is. A whole string of one like this. If you sum up those digits, 8 plus 4 plus 2 plus 1 will be one less than the next bit position up. And you can think about that if to count this, if you were to increment this number by one, you’d get 1, 1 is 0, carry one, and so forth. And you’d carry that value up to this position. So there’s various ways you can think about that. And then similarly, this number is 2 to the 4th -1, and so that’s equal to 2 to the w -1 -1.<br>顺便说一句，你会注意到另一个特点是。像这样的一串。如果你把这些数字加起来，8加4加2加1将比下一个位位置少一。你可以考虑一下，如果要计算这个数字，如果你将这个数字增加一，你会得到1，1是0，携带一，等等。你会把这个价值带到这个位置。所以你可以有各种各样的方法来考虑这个问题。然后同样地，这个数字是2的第四个1，因此等于2的w-1-1。</p><p>发言人   29:49<br>As is shown here so. There’s a lot of the book goes through formulas and does derivations. But if you just think about it in these smaller scale ways, the intuition is pretty easy to get and don’t get lost in formulas when really at the gut level, it’s a fairly straightforward set of ideas. Or if you ever see some equations and you’re confused, try out some small examples and see what they’re saying.<br>如这里所示。这本书有很多内容都经过公式和推导。但是如果你只是以这些较小规模的方式思考，直觉很容易得到，不要迷失在公式中，当真正在直觉层面上时，这是一组相当直接的想法。或者如果你看到一些方程式而感到困惑，尝试一些小例子，看看它们在说什么。</p><p>发言人   30:24<br>Another interesting number in the world of two’s complement is what happens when you have all ones in your bit pattern. And that will have -16 plus 8, plus 4 plus 2 plus 1. And that will equal -1. The bit pattern, all one is always a -1. In this representation, I should mention two S complement is not the only way to represent positive and negative numbers, what’s sometimes called S numbers. But it’s so universal that you’ll hardly ever encounter another case. So if you understand who’s compliment, you have a pretty good understanding of what really is going on.<br>在两个补码的世界中，另一个有趣的数字是当你的位模式中有所有一个时会发生什么。那将有-16加8，加4加2加1。这将等于-1。位模式，所有一个总是-1。在这种表示中，我应该提到两个补码并不是表示正数和负数的唯一方法，有时也被称为S数。但它是如此普遍，以至于你几乎不会遇到其他案例。所以，如果你理解了谁的赞美，你就对真正发生的事情有了很好的理解。</p><p>发言人   31:23<br>So these numbers I call, max the biggest unsigned number, t min, the smallest, most negative two’s comple and TX the largest, most positive two’s complement. This chart shows the range of values for different word sizes or different numbers of bytes.<br>所以我称之为这些数字，max是最大的无符号数，t min是最小的、最负的2的comple，TX是最大的、最正的2的comple。此图表显示不同单词大小或不同字节数的值范围。</p><p>发言人   31:45<br>And so you’ll see that with an 8 b number, you only have 256 possibilities and. So we can either choose to. Think of those as presenting the range from 0 to 255, or basically with two complement numbers, we just doing sort of a wraparound. We’re saying, well, we’re going to have half of them be negative, and the other half will be either zero or positive. And so that’s a pretty limited range of values, of course. And then 16. And believe me, back when computers had 16 b word sizes, it was a nuisance to keep your numbers within that range. And 32 gives you a pretty decent range.<br>所以你会看到，对于一个8 b数字，你只有256个可能性。所以我们可以选择。把它们想象成表示从0到255的范围，或者基本上用两个补码数，我们只是做了一个环绕。我们说，嗯，我们将会有一半是负数，另一半要么是零，要么是正数。因此，这当然是一个相当有限的数值范围。然后是16。相信我，当计算机有16个b的单词大小时，把你的数字保持在那个范围内是一件麻烦事。而32为您提供了一个相当不错的范围。</p><p>发言人   32:34<br>It used to be said Microsoft had to go to 64 b word size to represent Bill Gates’s net worth. For me at least, this would easily handle my range of normal day to day transactions. But now, with 64 b, at least to us nowadays, those seem like really big numbers, hard to imagine exceeding the bounds of those. So one interesting feature that you noticed here was I was. Like this case here.<br>过去人们常说，微软必须使用64 b的字数大小来代表比尔盖茨的净资产。至少对我来说，这将很容易处理我的正常日常交易范围。但是现在，有了64个b，至少对我们现在来说，这些数字看起来真的很大，很难想象会超越它们的界限。所以你在这里注意到的一个有趣的特征是我是。就像这个案例。</p><p>发言人   33:27<br>In this case here. You ready?<br>在这种情况下。准备好了吗？</p><p>发言人   33:38<br>And then this case here of all ones. I was comparing it to this case here of all ones. So in other words, in both these cases, it’s a little hard to jump boards here.<br>然后是这里的所有一种情况。我把它和这里的所有案例进行比较。换句话说，在这两种情况下，在这里跳板都有点困难。</p><p>发言人   33:58<br>You’re seeing that you have the same bit pattern in either case, but they represent different numeric values because one is a twos complement case and the other is an unsigned. And you can actually see the relation between them is pretty simple because basically what we’re doing is we jumping between a plus 16 and a -16 between those. And so you’d expect it to change by 32. And you see that here, that this is 31 here, and -1, this is 22 and -10. So they’re different from each other by plus or -32, 2 to the 5th two to the word size. And so there’s sort of a long derivation in the book things here. But that connection is actually fairly important because when you jump back and forth between unsigned numbers and two complement numbers in C, that’s the jump that you get, in other words.<br>你会看到在任何一种情况下你都有相同的位模式，但它们代表不同的数值，因为一个是二进制补码的情况，另一个是无符号的。你实际上可以看到它们之间的关系非常简单，因为基本上我们所做的就是在这些之间跳跃在 + 16和-16之间。所以你预计它会改变32。你可以看到，这里是31，-1，这是22和-10。因此，它们彼此之间的差异是加或-32，2到单词大小的第五个二。因此，这里的书籍中有一些冗长的推导。但这种联系实际上相当重要，因为当你在C中的无符号数和两个补码数之间来回跳转时，换句话说，这就是你得到的跳跃。</p><p>发言人   35:14<br>You’ll often find cases where what used to be a very large number, because it was unsigned, all of a sudden becomes a negative number because it’s considered two’s complement. So that’s what this next part covers.<br>你经常会发现这样的情况: 曾经是一个非常大的数，因为它是无符号的，突然变成了一个负数，因为它被认为是2的补码。这就是下一部分的内容。</p><p>发言人   35:28<br>We’ll say that. If we take a chart of 4 b numbers and we write out all the possible values as unsigned or as choose these complement numbers, then the ones where the higher order bit is 0 will be the same. In both cases, the ones where the higher order bit is a one in this case will differ by 16 2 to the fourth. And similarly, you’ll notice that these numbers, there’s a unique, it goes unique in both directions. For any given bit pattern, there’s a unique number it represents, and similarly, for any number within the given range, there’s a unique bit pattern.<br>我们会这么说。如果我们采用4 b数字的图表，并将所有可能的值写出为无符号或选择这些补数，那么高阶位为0的那些将是相同的。在这两种情况下，高阶位是1的情况将相差16 2比4。同样地，你会注意到这些数字，它们是独一无二的，在两个方向上都独一无二。对于任何给定的位模式，它都有一个唯一的数字，同样，对于给定范围内的任何数字，都有一个唯一的位模式。</p><p>发言人   36:19<br>So we can sort of jump between those two and say I can make up a rule for converting between a two’s complement number x and an unsigned number uux that basically says I’ll use the same bits. I’ll just think of them as being different numbers. And so, and you can go either way. So for example, if we thought of this as a. A two’s complement representative representation, It’s -1. This function I’m calling t to u goes from that number -1 to this number 31, where in between the two I’m saying they both have the same bit pattern.<br>所以我们可以在这两者之间跳转，并说我可以制定一个规则，用于在两个补码x和无符号数uux之间进行转换，基本上说我将使用相同的位。我会把它们看作是不同的数字。所以，你可以走任何一条路。因此，例如，如果我们认为这是一个。一个2的互补代表表示，它是-1。这个我调用t到u的函数从那个数字-1到这个数字31，在这两者之间，我说它们都有相同的位模式。</p><p>发言人   37:19<br>And the reason why this rather function that would otherwise seem to have no particular use is important is because that’s basically what happens in C, or actually in the program on the.<br>这个函数似乎没有特别的用处，重要的原因是因为这基本上就是在C中发生的事情，或者实际上在程序中发生的事情。</p><p>发言人   37:33<br>Computer itself has no clue whether a given bit pattern, if it’s something you’re thinking of as being a unsigned number or two’s complement number, it just a bunch of bits to it. And similarly, so we can go back and forth between chooses, comple unsigned, keeping the bit patterns the same. And so I’ll call that t to u when I go from sine to unsigned twos, complement to unsigned and similar. I’ll call it u to t if I go from unsigned to signed.<br>计算机本身不知道给定的位模式是什么，如果它是你认为的无符号数还是2的补数，它只是一堆位。类似地，我们可以在选择之间来回切换，保持位模式相同。因此，当我从正弦到无符号二时，我会将t称为u，从补充到无符号和类似。如果我从无符号转到有符号，我会称它为u到t。</p><p>发言人   38:09<br>And as I mentioned, the difference for the numbers where the high order bit is a one will be by a factor 2 to the w, where w is the word size of the word. And so this can be thought of as a function. Where?<br>正如我所提到的，高位为1的数字之间的差异将是w的2倍，其中w是单词的单词大小。因此，这可以被看作是一个函数。在哪里？</p><p>发言人   38:37<br>Let me just dry it out.<br>让我把它擦干。</p><p>发言人   38:49<br>Over here with my 5 b numbers. This is? Two’s complement again. So that was the number -16. And then there’ll be some other negative numbers up to all ones. It the number negative one, and then I’ll have 0. And so forth, and then all up to. Going to run out of room? Plus 15, right? Just I. Got myself in trouble. Blackboard management is they didn’t teach me this school. So I’m going to. Use two boards at once here.<br>这里有我的5个b数字。这是什么？二是再次补充。这就是数字-16。然后会有一些其他负数，直到所有的一。如果数字是负一，那么我就得到0。以此类推，然后一切都由上而下。要跑出房间吗？加上15，对吧？只是我。让自己陷入了麻烦。黑板管理是他们没有在这所学校教我的。所以我要去。在这里同时使用两个板子。</p><p>发言人   40:05<br>Okay? What are you setting this up?<br>好吗？你是怎么安排的？</p><p>发言人   40:15<br>Okay, we’ll make it work. So now when we go from the Ttu function, then these numbers are going to just carry over, will get 0 up through 15. But now this number here will become positive 16.<br>好的，我们会让它起作用的。所以现在当我们从Ttu函数开始时，这些数字将只是延续，将从0上升到15。但现在这个数字将变成正数16。</p><p>发言人   40:44<br>And all ones. Will become positive 31. And so that’s what this picture is showing. Is it for the pink numbers are the ones that flip between negative and actually the largest of the positive numbers. And then the green numbers are the ones that stay the same because they’re leading bits are zeros.<br>所有的。将成为阳性31。这就是这张照片所展示的。粉色数字是在负数和实际最大的正数之间翻转的数字。绿色数字是保持不变的数字，因为它们的前导位是零。</p><p>发言人   41:17<br>So why does this matter? You never thought if you programmed in Python, say, or even Java, you don’t see that. And the reason is because C is one of the few languages where unsigned is actually an explicit data type. And so you can declare a value being unsigned. If you just say unsigned, what you’re really saying is unsigned int, or you can call something an unsigned care, an unsigned short, or an unsigned long. And you’re declaring in C that it should think about using this representation we show on the right when it’s working on those numbers. So that’s sort of one thing.<br>这有什么关系呢？你从来没有想过，如果你用Python编程，比如说，甚至是Java，你都看不到这一点。原因是因为C是少数几种实际上无符号是显式数据类型的语言之一。所以你可以声明一个无符号的值。如果你只是说unsigned，你真正说的是unsigned int，或者你可以称之为unsigned care、unsigned short或unsigned long。你在C中声明，在处理这些数字时，它应该考虑使用我们在右侧显示的这种表示。所以这是一件事。</p><p>发言人   42:07<br>It’s one thing if you declare a number and use it that way. But what gets people and often got you is if you declare something, if you have, in this case, something that’s declared as a tooth complement number x TX and you assign it a value u at y x, it’ll do an implicit casting, which is exactly based on this conversion that we’ve been talking about, and vice versa.<br>如果你声明一个数字并以这种方式使用它，那就是一回事。但是让人们经常得到的是，如果你声明了一些东西，在这种情况下，如果你有一些被声明为牙齿补码x TX的东西，并且你在y x处为它分配一个值u，它将进行隐式转换，这正是基于我们一直在谈论的这种转换，反之亦然。</p><p>发言人   42:40<br>This example, this goes through some examples that if I look at two numbers and I compare them, or actually I do any operation on them, I add them, divide them, anything implicitly, it will try to make these two be of the same type. And the way it will do that is to say, if both of them are ased, then I’ll treat them as assigned. Case if either of them is unsigned, then I’ll convert the other one to be an unsigned number and do the operation. And so in particular, this set of examples is imagine I’m comparing these.<br>在这个例子中，经过一些例子，如果我看两个数字并比较它们，或者实际上我对它们进行任何操作，我将它们相加，相除，任何隐式的东西，它都会尝试使这两个是相同类型。这样做的方式就是说，如果他们两个都被杀了，那么我会把他们视为指定的。如果其中一个是无符号的，那么我会将另一个转换为无符号数字并进行操作。特别地，想象一下我正在比较这些例子。</p><p>发言人   43:20<br>I’m saying these numbers are either equal, less or greater. What will the outcomes be? And the key to answering that question is to, first of all, figure out OK, is it assigned or an unsigned comparison? Should I convert one of these numbers to an either of these numbers to an unsigned form before I do it? And the rule is, if either argument is unsigned, then you’ve got to do it.<br>我是说这些数字要么相等，要么更少，要么更大。结果会是什么？回答这个问题的关键是，首先要弄清楚它是分配的还是无符号的比较？在我这样做之前，我应该将这些数字中的一个转换为这些数字中的任何一个转换为无符号形式吗？规则是，如果其中一个参数是无符号的，那么你必须这样做。</p><p>发言人   43:47<br>And as you see, when you put a u at the end, either a lowercase u or an uppercase u at the end of a numeric constant, you’re saying this is an unsigned value. So for example, if we compare 0 and 0 unsigned, they’re equal. And if we combine negative one, compare negative one to 0, we’ll get that the first one is less because negative one is less than 0. But what would happen with the next one when we compare negative one to an unsigned zero? Greater, right? So this is the surprise. And it has to do with.<br>正如你所看到的，当你把一个u放在数字常量的末尾，无论是小写的u还是大写的u，你就是在说这是一个无符号的值。例如，如果我们比较0和0无符号，它们是相等的。如果我们将负一个结合起来，将负一个与0进行比较，我们会得到第一个较小，因为负一个小于0。但是当我们将负1与无符号0进行比较时，下一个会发生什么？更大吧？这就是惊喜。这与。</p><p>发言人   44:41<br>A number that I erased. But we can still get it. Remember, this is negative one. But when I cast that to an unsigned number I’m flipping this from -60 into positive 16 and turning this into 31. I’m turning it into actually the largest number I can represent. And so it will be greater than 0. So it’s a little bit weird to think about. I took an unsigned zero, which after all, is just 0, and compared it to negative one. And it said, oh, you really meant 31, didn’t you? Or whatever word size we’re using. And so it said it’s greater. And basically the rest of these you can answer in a similar way.<br>一个被我擦掉的数字。但我们仍然可以得到它。请记住，这是负面的。但是当我将其转换为一个无符号数字时，我将其从-60翻转为正16并将其转换为31。我正在把它变成我能代表的最大数字。因此它将大于0。所以思考起来有点奇怪。我取了一个无符号的零，毕竟它只是0，并将其与负1进行比较。它说，哦，你真的是说31，不是吗？或者我们使用的任何单词大小。所以它说它更大。基本上，其余的你可以用类似的方式回答。</p><p>发言人   45:36<br>These two numbers are, this is query one smaller than this? No I’m sorry, this is a negative number. I compare those and the positive will be greater than the negative. I’ll tell you in a minute why this number is written this way. The next one, it’s the same pair of numbers, but you see it’s flipped and the reason is. That this number on the left is T max for?<br>这两个数字是，这个查询比这个小吗？不，对不起，这是一个负数。我比较它们，正面的会大于负面的。我马上告诉你为什么这个数字是这样写的。下一个，它是一对相同的数字，但你看到它被翻转了，原因是。左边的这个数字是T max吗？</p><p>发言人   46:22<br>So it’s the bit pattern in a 32 b number.<br>所以它是32 b数字中的位模式。</p><p>发言人   46:53<br>And to this day I’ve not memorized this number, by the way. But, and then this number is actually t min.<br>顺便说一下，直到今天我还没有记住这个数字。但是，然后这个数字实际上是t min。</p><p>发言人   47:18<br>And that when I subtract, you can think of it as this is negative t max -1. So that’s t min. So if I do an unsigned comparison between those two, now think of those, this weighting bit not being a negative weight, but a positive weight. You’ll see that this is a bigger number than this one.<br>当我减去时，你可以把它看作是负的t max -1。所以这就是t min。所以，如果我在这两者之间进行无符号比较，现在想想这些，这个加权位不是负权重，而是正权重。你会发现这个数字比这个更大。</p><p>发言人   47:44<br>And so it goes. That -1 is greater than -2 if they’re unsigned, because -1 is, you can think of it as converts into u max. It’ll be the biggest number possible. And -2 will. Would be 1 1 1, 1, 0.<br>就这样下去了。如果它们无符号，则-1大于-2，因为-1是，您可以将其视为转换为u max。这将是最大的数字。和-2将。将是1 1，1，0。</p><p>发言人   48:20<br>So that can get fairly confusing. One final quirk this way of writing this number is there’s a little side in the book about it. If you write the number as you’d expect to as minus blah, blah, blah, 6 and 48. It will actually get the C compiler gets kind of confused by that for obscure reasons. One other thing I should point out that it’s a property that I don’t think we cover well enough here. Well, let me see.<br>这可能会变得相当混乱。这样写这个数字的最后一个怪癖是，书中有一个关于它的小方面。如果你按照你期望的那样写下数字-等等，等等，6和48。它实际上会让C编译器因为一些模糊的原因而感到困惑。还有一件事我应该指出，这是一项我认为我们在这里没有充分涵盖的财产。好的，让我看看。</p><p>发言人   49:05<br>There’s a few things that the slides don’t really cover here, and I don’t know why not, I like to point out.<br>这里的幻灯片没有真正涵盖一些事情，我不知道为什么不，我想指出。</p><p>发言人   49:17<br>So they’re kind of useful properties to keep track of.<br>所以它们是跟踪的有用属性。</p><p>发言人   49:29<br>Is that you notice that if you look at the absolute value of T max? And you compare it to the absolute value of t min. That it’s off by one? So the number is more negative. The smallest negative number is more negative than the largest positive number is positive. And the reason for that actually is fairly simple, if you think about it, is that. The cases where you have zeros. Include the number 0.<br>你注意到，如果你看T max的绝对值吗？并将其与t min的绝对值进行比较。它已经被一个关闭了吗？所以这个数字更负。最小的负数比最大的正数更负。如果你仔细想想，其实原因相当简单，就是这样。当你有零的情况下。包括数字0。</p><p>发言人   50:24<br>So you can see it better. And there’s two to the half year ranges occupied by those numbers. And the negative numbers are all negative.<br>这样你就可以看得更清楚。这些数字占据了两到半年的范围。负数都是负数。</p><p>发言人   50:45<br>And so the other half of the range is in there. And the point is that you had to use one of these for 0. And so only there was one left, one less value left over. And that’s why you end up with this sort of asymmetry. And this asymmetry is the cause of no end of pain in various ways, like a few. The classic example is if you implement absolute value.<br>所以范围的另一半在那里。重点是你必须使用其中一个来表示0。所以只剩下了一个，剩下的价值少了一个。这就是为什么你最终会得到这种不对称。这种不对称性以各种方式引起了无止的疼痛，就像一些方式一样。经典的例子是，如果你实现绝对值。</p><p>发言人   51:36<br>Like, so what does this return for t min? Yeah, it returns t min. We’ll talk a little bit. Basically, when you try to negate this number that’s here. You’ll end up with it back again.<br>像，那么这对t-min有什么回报呢？是的，它返回t min。我们稍微聊一下。基本上，当你试图否定这里的这个数字时。你最终会再次得到它。</p><p>发言人   52:11<br>So it’s always a corner case. And whenever we do program testing, we always throw that case in there to break things. You said, well, like he, you said earlier about, I. Yes?<br>所以这总是一个角落。每当我们进行程序测试时，我们总是把那个情况扔进去破坏事情。你说，就像他一样，你之前说的，我。是吗？</p><p>发言人   52:36<br>No, they do that if you ever look at the. In the C constants, they use this as a way of representing t min, and they do it for that reason. You see, it’s exactly, and they put parentheses around it, president’s problem. But you see that number that in 647, that’s T max. And so basically, it’s just saying that t min is minus t max -1 question.<br>不，如果你看到他们，他们就会这样做。在C常量中，他们使用这个作为表示t min的方式，并且他们出于这个原因这样做。你看，这确实是总统的问题，他们在后面加了括号。但是你可以看到647中的数字，那就是T max。所以基本上，它只是说t min是-t max -1问题。</p><p>发言人   53:22<br>Yes, so comparison is just a special case of the more general one, which is addition, subtraction, all of those. If either argument is unsigned, then it interprets the remaining one as being unsigned, It turns out, and we’ll get into this more next time as far as bit patterns, but it turns out at the bit level, addition, subtraction, even multiplication are the same, whether it’s an unsigned number or two’s complement number. So we’ll talk about that more next time. And the other thing to observe sort of property.<br>是的，所以比较只是更一般的一种特殊情况，即加法、减法。如果其中一个参数是无符号的，那么它会将剩余的一个解释为无符号的，事实证明，我们下次会更深入地讨论位模式，但事实证明，在位级别上，加法，减法，甚至乘法都是相同的，无论它是无符号数还是2的补码数。所以下次我们会更多地谈论这个。另一件事是观察某种性质。</p><p>发言人   54:21<br>You saw that umax is sort of like? Twice t max plus one.<br>你看到umax有点像吗？两次t最大值加1。</p><p>发言人   54:36<br>So before Mas was 15 in our 5 b numbers and that’s again, not too hard to figure out. Here’s one way to think about it. T max is a 0 followed by a bunch of ones. And if I want to double that number, I basically shift it left by one position, and that would end up with a 0 here. So this is T max, and this is twice t max. And now if I add a 1 to that I’ll just set this bit to one and get this. So there’s various ways you can think about it, but that’s one way to do it.<br>所以在我们的5 b数字中Mas之前是15，这并不难弄清楚。这是思考它的一种方式。T max是一个0后面跟着一堆1。如果我想将这个数字翻倍，我基本上会将它向左移动一个位置，最终会得到一个0。这是T max，这是两倍t max。现在，如果我加一个1，我只需要将这个位设置为1，就可以得到这个。所以有各种各样的方法可以考虑它，但这是一种方法。</p><p>发言人   55:43<br>There’s one other thing that I wanted to mention too. This can get you into a lot of trouble. Programming Y, so let me just show you what I mean.<br>还有一件事我也想提一下。这可能会给你带来很多麻烦。编程Y，那么让我向你展示我的意思。</p><p>发言人   56:10<br>So imagine I wanted to. Go backwards through an array. So I write a loop of the form for I equals n -1. I is greater than. Or equal to zero, I minus, minus. And then I do something with array element A of I. I’ll just call some function of whatever you want to do in that loop. So that’s a pretty standard pattern in a loop, right? Except that you write this greater equal to 1, 0. You can imagine various uses for that.<br>所以想象一下我想要。在数组中向后移动。所以我写了一个形式为I等于n -1的循环。我大于。或等于零，I-，-。然后我对I的数组元素A做了一些事情。我会在循环中调用任何你想做的函数。所以这是一个相当标准的循环模式，对吧？除了你写的大于等于1，0。你可以想象它的各种用途。</p><p>发言人   57:01<br>So here’s an interesting question. I were declared as being unsigned. Because it’s array index, after all. What will happen with this loop? Yeah? What’s that, yes? So the loop will go forever. What would most likely happen is I would go from being 0 to being u max, and that’s a really big number. And the ray’d most likely cause a memory fault because it’s so far out of bounds. But the point is, it wouldn’t do what you want. It wouldn’t stop where you want it to. And because of the simple reason that I, of course, I is always going to be greater or equal to 0, because it’s an unsigned number.<br>这里有一个有趣的问题。我被宣布为无符号。因为它毕竟是数组索引。这个循环会发生什么？是吗？那是什么，对吗？所以循环将永远持续下去。最有可能发生的情况是我从0变成u max，这是一个非常大的数字。而射线很可能会导致记忆故障，因为它已经超出了界限。但关键是，它不会做你想做的事。它不会停在你想要的地方。原因很简单，当然，I总是大于或等于0，因为它是一个无符号数字。</p><p>发言人   57:58<br>One, you’d say OK, well, you should have figured that one out. It can be more subtle, though. If you have something like int I. And then we say something like, let me just change it here a little bit. So this will be.<br>你会说，好吧，你应该已经想出了那个。不过，这可能更加微妙。如果你有像int I这样的东西。然后我们说，让我在这里稍微改动一下。这将是如此。</p><p>发言人   58:44<br>Something like this where I’m mixing metaphors here, I have to confess. But if you use the standard term size of which is the way you get how many bytes it takes to represent some given data type, so this will actually be the number one. So it’s not the same loop as before. But imagine I’m sort of mixing in my arithmetic and making use of some of these built in forms. What would happen with this group?<br>像这样的事情，我在这里混合隐喻，我必须承认。但是如果你使用标准的术语大小，它是你获取表示某种给定数据类型所需的字节数的方式，那么这实际上将是第一。所以它不像以前那样循环。但想象一下，我在算术中混用了一些内置的形式。这个群体会发生什么？</p><p>发言人   59:24<br>Yes exactly, so size of returns an unsigned value. It’s not actually a function, it’s a built in. The result of size of is considered to be unsigned.<br>完全是，所以大小返回无符号值。它实际上不是一个功能，而是一个内置的。size的结果被认为是无符号的。</p><p>发言人   59:39<br>Just like I was saying, if you have a sine value and an unsigned in any kind of arithmetic, it’ll treat the combination of the two as unsigned. And so it will actually do an unsigned comparison here, which is almost surely not what you wanted. And this will just.<br>就像我说的，如果你有一个正弦值和一个无符号的算术，它会将这两者的组合视为无符号。因此，它实际上将在这里进行未签名的比较，这几乎肯定不是您想要的。而这将只是。</p><p>发言人   01:00:02<br>You’ll look at this program and you won’t have any idea why it’s crashing. You’ll be so confused. And that’s the kind of thing you have to know. It’s one of the quirks of C that probably if they could start over again and redesign it, they’d come up with some different set of conventions than they did. But unfortunately, it’s way too late for that. So this is just one of those things you have to remember. But yes, my point is there’s some subtleties in C about this business of sed versus unsigned arithmetic.<br>你会看到这个程序，但你不知道它为什么会崩溃。你会很困惑。这就是你必须知道的事情。这是C的怪癖之一，如果他们能重新开始并重新设计它，他们可能会提出一些与以前不同的约定。但不幸的是，现在已经太晚了。所以这只是你必须记住的事情之一。但是，是的，我的观点是，关于sed与无符号算术的业务，C中有一些微妙之处。</p><p>发言人   01:00:40<br>Okay, so now let’s look at a sort of final class of operations, which is, suppose I have a number that’s so many bits, say 8 b, and I want to now expand it to be a 16 b number. There’s a fairly cute rule for doing this that’s called sine extension. I’m talking about twos complement numbers here of how you go take a number, make it bigger without changing its value. The basic rule is you do it by copying the sine bit to the left. So let me give you the intuition behind it.<br>好的，现在让我们来看一种最终的操作类，也就是说，假设我有一个位数，比如8 b，我现在想将它扩展为一个16 b的数字。有一个相当可爱的规则来做这件事，叫做正弦扩展。我在这里谈论的是二补码，即如何在不改变其值的情况下将一个数字变大。基本规则是通过向左复制正弦位来完成。让我给你背后的直觉。</p><p>发言人   01:01:33<br>So let’s look at some 4 b values.<br>让我们来看看一些4 b的值。</p><p>发言人   01:01:45<br>Well, it’s pretty straightforward if the leading bit is a 0. I’m just going to do a left shift and then fill in.<br>如果前导位是0，那就非常简单了。我只是要做一个左移，然后补上。</p><p>发言人   01:02:02<br>Right, wait, what am I talking about? I got ahead of myself. I’m talking about something totally different. No, sorry, the same number. I’m not changing the number. I’m keeping it the same, so I just added a 0 to the lead and this will be the number 6 still.<br>对，等等，我在说什么？我超前了。我说的是完全不同的东西。不，对不起，是同一个号码。我不会换号码的。我保持不变，所以我只是在引线上加了一个0，这将是数字6。</p><p>发言人   01:02:20<br>This is plus 4 plus 2 equals 6. But now let’s think about it as where there’s a leading sign bit. So this is -8 plus 4 plus 2 is equal to -2. So now look at what happens if I copy that sine bit over one position. So this becomes a 1, 1, 1, 1, 0. And what happens is this is now has value plus 8 here, but the sine bit has value -16. And then this is still plus 2 and plus 4. And so it will still equal -2.<br>这是加4加2等于6。但现在让我们把它想象成一个前导符号位。所以这是-8加4加2等于-2。所以现在看看如果我在一个位置上复制那个正弦位会发生什么。所以这变成了1，0。发生的情况是，现在这里的值加8，但正弦位的值为-16。然后这仍然是 + 2和 + 4。因此它仍然等于-2。</p><p>发言人   01:03:17<br>So here’s what happened before. My sine bit had a weight of -8, and my new sine has a weight of -16. But I converted that old sine bit into a positive number, which is plus 8, and those two canceled out. You combine those two and you get minus A, which is exactly this. So you see by sort of copying that sine bit over, giving it twice the way, turning it, what was the sine bit into a positive number, you don’t change the net effect of the sum.<br>这就是之前发生的事情。我的正弦波位的权重为-8，而我的新正弦波位的权重为-16。但是我把那个旧的正弦位转换成了一个正数，也就是加8，然后这两个被抵消了。你把这两者结合起来，得到-A，也就是这个。所以你通过复制那个正弦位，给它两倍的方式，把它，正弦位变成一个正数，你不会改变总和的净效应。</p><p>发言人   01:03:58<br>And that’s exactly the idea of extension. Just keep going with that as far as you need to carry it over. And each time you’re doing it, you’re effectively doing this business of of coming up with a pair of bits that end up with the same value as this original bit. So that’s the idea of sine extension. And you’ll see that a lot. Bit patterns, especially if you see a bit pattern that starts with a bunch of F’s.<br>这正是扩展的想法。只要继续下去，直到你需要把它带过去。每次你这样做的时候，你都在有效地进行这项业务，即想出一对与原始位具有相同值的位。这就是正弦扩展的想法。你会经常看到这一点。位模式，特别是如果你看到一个以一堆F开头的位模式。</p><p>发言人   01:04:40<br>What that tells you, remember f is just four ones.<br>这告诉你的是，记住f只是四个一。</p><p>发言人   01:04:50<br>Is a whole bunch of leading ones that tells you the number is negative, negative, but not too far away from 0. And you’ll see that over and over again. You’ll see bit patterns. And you just sort of, when you see meeting F’s, you say, oh, that’s a negative number. I know what’s going on there. And so here’s some examples. But you can see the main idea is you carry that leading bit from the 16 b case over, make as many copies as you need to expand the word size.<br>是一堆领先的数字，告诉你数字是负数，负数，但离0不太远。你会一遍又一遍地看到这一点。你会看到比特模式。当你看到遇见F的时候，你会说，哦，那是一个负数。我知道那里发生了什么。这里有一些例子。但是你可以看到主要的想法是你从16 b的情况下开始，根据需要制作尽可能多的副本来扩展单词大小。</p><p>发言人   01:05:29<br>And I should mention with the unsigned case, obviously, you just want to fill in with zeros.<br>我应该提到未签名的情况，显然，你只想用零填充。</p><p>发言人   01:05:41<br>Do we talk about truncation? Is there any any missing slides in this?<br>我们在谈论截断吗？这个幻灯片有缺失的吗？</p><p>发言人   01:05:52<br>A final case to look at is what happens if I make something shorter? So if I had my unsigned number from before.<br>最后一个需要考虑的案例是，如果我把东西缩短会发生什么？如果我有之前的无符号号码。</p><p>发言人   01:06:11<br>If this were an unsigned number, this would be 1, 2, 8, 16, 1417, right? What if I decided, oh, I can’t afford? For a bit. I don’t have enough money. For 5 b. I’m only going to give you 4. Well, you basically just dropped the most significant bit. And you get 8 plus 2 plus one, which is 11, which is 9. And the relation there is that it’s like modular arithmetic.<br>如果这是一个无符号数字，那么它将是1，2，8，16，1417，对吧？如果我决定，哦，我负担不起怎么办？有一点。我没有足够的钱。5个b。我只会给你4。好吧，你基本上只是掉了最重要的一点。你得到8加2加1，也就是11，也就是9。那里的关系就像模块化算术一样。</p><p>发言人   01:07:03<br>Mod 16, you’re taking no. Thank you? It’s the risk of improvising. So 27.<br>Mod 16，你要不要。谢谢？这是即兴创作的风险。所以27。</p><p>发言人   01:07:26<br>And 11? Yeah, that makes sense. Difference is 16, I knew that. Okay, excuse me for my stumbling.<br>And 11?是的，这很感知。差异是16，我知道。好的，请原谅我的绊倒。</p><p>发言人   01:07:42<br>The point being that when you drop this thing effectively, you’re just taking the mod some power of two of it. Like I mentioned, the case where you’re taking modulo 8, if you just keep only the lowest order of 3 b, you’re having a module 8. Now, one, really, this is sort of logical in the unsigned world. Modular arithmetic is something that was understood by the ancient Greeks, so not too far away from human experience, but it gets a little bit funky if. Dealing with two these complement numbers because this is now. 1011 -5, right? But this number, if I just drop this bit. And call it a 4 b number. This now becomes -8, 2, and 1.<br>关键是，当你有效地放下这个东西时，你只是在利用它的一些力量。就像我提到的，在你取模8的情况下，如果你只保留最低的3 b的顺序，你就有一个模块8。现在，第一，真的，这在未签名的世界里是合乎逻辑的。模块化算术是古希腊人所理解的东西，因此与人类经验不太遥远，但如果它变得有点古怪。处理这两个补数，因为这是现在。1011 -5，对吧？但是这个数字，如果我只是放下这一点。称之为4 B数字。这现在变成了-8、2和1。</p><p>发言人   01:08:54<br>Which is -5?<br>哪个是-5？</p><p>发言人   01:09:01<br>You say, how’d that happen? Well, actually, if you look at it, this is just what you’d get by S extension, right? So this wasn’t a very interesting example. But if we changed it to this?<br>你说，这是怎么发生的？嗯，实际上，如果你看一下，这正是你通过S扩展得到的，对吗？所以这不是一个非常有趣的例子。但是如果我们把它改成这个？</p><p>发言人   01:09:27<br>Then this would be -13. And this would be plus 3. And. It’s a little harder to think about in terms of modular arithmetic, The way you basically have to think about it is, well, you know, this is -13, but it’s really kind of like 27 and 27 mod 16 is sort of like, or no, this isn’t 20.<br>那么这将是-13。这将是加3。而且。从模块化算术的角度考虑有点困难，你基本上要考虑的方式是，你知道，这是-13，但它真的有点像27和27 mod 16有点像，或者不，这不是20。</p><p>发言人   01:10:01<br>We changed our number, right? So this is really kind of like 19 and 19 mod 16 is 3, and this is 3. So you can sort of do it by coming back around to it. But it’s not some arithmetic property that would jump out at you as being something logical. But that happens all the time. And it’s very common for numbers to get truncated for one reason or another.<br>我们换了号码，对吧？所以这真的有点像19和19 mod 16是3，这是3。所以你可以通过回到它身边来做到这一点。但这并不是一些算术属性会突然出现在你身上，成为合乎逻辑的东西。但这种情况经常发生。由于某种原因数字被截断是很常见的。</p><p>发言人   01:10:30<br>And you can see that you can have a negative number become a positive number. You can have a positive number become a negative number, and all kinds of goofy stuff can happen. And we’ll see plenty of examples of that when we look at arithmetic. So that’s. That is what I want to cover for today. And we’ll cover the other arithmetic operations on Tuesday. So thank you very much.<br>你可以看到你可以让一个负数变成正数。你可以让一个正数变成负数，各种愚蠢的事情都可能发生。当我们看算术时，我们会看到很多这样的例子。就是这样。这就是我今天想要涵盖的。我们将在周二介绍其他算术运算。非常感谢。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深入理解计算机系统 001-Overview</title>
    <link href="/2025/10/12/15213-001/"/>
    <url>/2025/10/12/15213-001/</url>
    
    <content type="html"><![CDATA[<embed src="/images/15213-001.pdf" type="application/pdf" width="100%" height="600px" /><p>发言人   00:00<br>Hello everyone I’d like to welcome you all to this Falls. This term’s instance of this course is officially either 15 to 13 from computer science or 18 to 13 from electrical and computer engineering. But a large number of the people enrolled in this course are in one called 513, which is for graduate students.<br>大家好，欢迎大家来到这个学期。这学期的课程正式名称要么是计算机科学的15到13，要么是电气和计算机工程的18到13。但是，参加这门课程的很多人都在一个名为513的课程中，这是针对研究生的。</p><span id="more"></span><p>发言人   00:24<br>And to be totally honest, you’re not supposed to be here because you’re supposed to watch the videos, the lectures by video later. But we’re not checking any cards. So I don’t really know who you are. Anyways, this course is, as you can see, a very popular course on campus. We have over 700, 700, 600 shouldn’t exaggerate. Students on campus enrolled in one of those three versions of the course, which if you think about a university the size of CMU, it’s like about 5% of the total student population.<br>而且说实话，你不应该在这里，因为你应该观看视频，稍后通过视频进行讲座。但我们不会检查任何卡片。所以我真的不知道你是谁。无论如何，正如你所看到的，这门课程在校园里是非常受欢迎的课程。我们有超过700，700，600不应该夸大。校园内的学生就读于这三个版本的课程之一，如果你考虑一个CMU大小的大学，大约占学生总数的5%。</p><p>发言人   01:06<br>So we’re very glad to have you here. And this game is too high. I think we overdid the game. Try that, that’s better. So my name is Randy Bryant and my co instructor is Da O’hare. And those names might be familiar if you have been to the bookstore because the book was written by us and we actually wrote this book.<br>所以我们很高兴你在这里。而且这个游戏太高了。我认为我们把游戏做得太过人了。试试那个，那更好。所以我的名字是兰迪·布莱恩特，我的联合导师是达奥黑尔。如果你去过书店，这些名字可能会很熟悉，因为这本书是我们写的，而我们实际上写了这本书</p><p>发言人   01:36<br>We started 213 as a course in 1998. And I know that you were children then and all that stuff Out of response for a new type of course, that you’ll see today that sort of gives people in depth understanding of systems, but more from a high level of or programmer’s perspective. And we’ll talk some about the philosophy of the course later.<br>我们在1998年开始了213门课程。我知道你当时还是孩子，所有这些都是出于对一种新型课程的回应，你今天会看到这种课程让人们对系统有了深入的理解，但更多是从高层次或程序员的角度来看。我们稍后会谈论这门课程的理念。</p><p>发言人   02:02<br>So this book, as you saw, just came out its third edition last March. And that’s the required text for the course. And there is nothing you can do to avoid buying that book.<br>所以正如你所看到的，这本书在去年三月刚刚出版了第三版。这是本课程的必修教材。你无法避免购买那本书。</p><p>发言人   02:17<br>And it’s not because we’re greedy, actually. We take the money we get from royalty for students in this course or any CMU course, and we donate it to CMU. So we’re not actually making any money out of you buying the book. But it’s a simple reality that the new version is different than the old. We expect you to be using the new version. There are no electronic copies, there are no pirated versions, so you basically have to buy the book. And I don’t really apologize for that because I know you or your parents or somebody is paying a lot of money for you to be here. And so the price of the book is really a relatively small amount relative to that.<br>事实上，这并不是因为我们贪婪。我们将从版税中获得的钱用于本课程或任何CMU课程的学生，并将其捐赠给CMU。所以我们实际上并没有从你购买这本书中赚钱。但这是一个简单的现实，新版本与旧版本不同。我们希望您使用新版本。没有电子副本，没有盗版，所以你基本上必须购买这本书。我并不为此道歉，因为我知道你或你的父母或某人为你在这里付出了很多钱。因此，这本书的价格相对于这个价格来说确实是相对较小的。</p><p>发言人   03:03<br>And this course, by the way, is, is not some courses there. Oh, yeah, this book, you might want to look at it once in a while, but actually the course has nothing to do with it.<br>顺便说一下，这门课程并不是那里的一些课程。哦，是的，这本书，你可能想偶尔看看，但实际上这门课与它无关。</p><p>发言人   03:13<br>This course, the book and the course are one. They’re very tied together. They’ll be parts of the book that we don’t go into. All the details that are in the book sometimes, but we expect you to be able to figure it out. And so really the course in the book are tied together and they very much the progress of the course, the topics covered, how it’s covered, everything about it is consistent with the book.<br>这门课程，这本书和这门课程是一体的。他们非常紧密地联系在一起。它们将成为这本书的一部分，我们不会进入其中。书中的所有细节有时会出现，但我们希望你能够理解。因此，书中的课程是紧密联系在一起的，课程的进展、涵盖的主题、涵盖的方式以及有关课程的一切都与书中的内容非常一致。</p><p>发言人   03:45<br>And we wrote the book because of the course. Think of them as course notes. So, and the reason why we are teaching this term, by the way, we haven’t taught together in several years, but because this is the first rollout of this book, and not only is it being used here, but it’s actually used by about 250 schools around the world. And many of those people are also going through the same activities of teaching from this new edition for the first time. So we wanted to make sure all the material for the course was sort of put in order and things because other universities and other colleges use this material, the supporting material we’ve developed. So that’s course today as the first lecture, we’re sort of doing a tag team here. I’ll talk the high level, what the course is about, what the main themes are, and Dave will talk more about the logistics. So we refer the saying we have when.<br>我们因为课程而写了这本书。把它们想象成课程笔记。所以，我们教这个学期的原因，顺便说一下，我们已经好几年没有一起教了，但是因为这是这本书的第一次推出，它不仅在这里被使用，而且实际上被全球大约250所学校使用。其中许多人也正在经历与新版相同的教学活动。所以我们想确保这门课程的所有材料都井井有条，因为其他大学和学院都在使用我们开发的支持材料。这是今天的第一堂课，我们在这里组建了一个标签团队。我将谈论高级别的课程，课程内容是什么，主题是什么，戴夫将更多地谈论物流。所以我们指的是我们的说法。</p><p>发言人   04:55<br>The very first time I typed the number of this course into a text editor, I realized I’ve typed those five digits many times in my career because it’s the zip code of CMU 1 5 2 1 3. So that’s where we come up with the same.<br>第一次将本课程的编号输入文本编辑器时，我意识到在我的职业生涯中，我已经多次输入这五个数字，因为它是CMU 1 5 2 1 3的邮政编码。所以这就是我们想出相同的方法的地方。</p><p>发言人   05:17<br>So there’s a few things about this course. For the most part, you know, in your normal undergraduate curriculum, when you’ve learned programming, you’ve been very much separated from the realities of the machine. You just think about code. Just you put some text into some little box somehow, and outcomes of behavior that hopefully is what you intended the program to do. The purpose of this course is to give you enough understanding of what that box is doing when it executes your code and through that to help you become better what you’re trying to do.<br>所以关于这门课程有几件事情。大多数情况下，你知道，在你正常的本科课程中，当你学习编程时，你已经与机器的现实非常分离。你只需要考虑代码。你只需在某个小盒子里放一些文本，然后得到一些行为结果，希望这就是你想要程序做的事情。本课程的目的是让您足够了解该框在执行代码时的作用，并通过它来帮助您变得更好，您正在尝试做什么。</p><p>发言人   06:02<br>So some of the outcomes is there’s really two types of outcomes from this course. One is that if this is the only systems course you ever take in your whole life, you will get useful material from it. You will learn tools, tricks, methods that will help you if you ever are involved in software development, large scale software engineering projects, systems, hardware design, any aspect of computer technology, this will help you be better at what you do. You’ll understand what programs do, how they work, what the machines support them do, why sometimes they work really well, and why sometimes they don’t work so well. It also is intended as a sort of stepping stone into a whole number of other courses at CMU that will give you more in depth understanding of computer technology, but are sort of specialized by topical area, whether it’s computer networking or operating systems or embedded systems where you’ll take the sort of ideas from this course and be able to then learn in a somewhat narrower but deeper sense what’s really going on. And so it really is trying to serve those two goals of making you more effective, giving you useful ideas and tools right away, but also preparing you for waiter courses.<br>因此，这门课程的一些结果实际上有两种类型的结果。一是如果这是你一生中唯一的系统课程，你将从中获得有用的材料。如果你参与软件开发、大规模软件工程项目、系统、硬件设计、计算机技术的任何方面，你将学习工具、技巧和方法，这将有助于你更好地完成你的工作。你会理解程序的作用，它们是如何工作的，机器支持它们做什么，为什么有时它们工作得很好，以及为什么有时它们工作得不好。它还旨在作为CMU其他课程的踏脚石，让您更深入地了解计算机技术，但这些课程在主题领域上是专业化的，无论是计算机网络、操作系统还是嵌入式系统，你都将从这门课程中汲取一些想法，然后能够以更狭窄但更深入的感知了解实际发生的事情。因此，它确实在努力实现这两个目标: 让你更有效率，立即给你有用的想法和工具，同时也让你为服务员的课程做好准备。</p><p>发言人   07:30<br>So one way we talk about this is sort of what kind of stuff will you learn from this course is to go through a series of what we call great realities, places where sort of computers meet up, real life computers meet up against your expectations, and maybe they’re not quite the same. So one of them is, and the first part of the course is going to take a fairly detailed look how numbers are represented in computers. And you’ll learn some things that are on one hand surprising, and on another hand will start to make sense when you understand it better.<br>所以我们谈论这个问题的一种方式是，你将从这门课程中学到什么样的东西，是通过一系列我们称之为伟大现实的地方，在这些地方，计算机会相遇，现实生活中的计算机会与你的期望相遇，也许它们并不完全相同。所以其中一个是，本课程的第一部分将相当详细地了解数字在计算机中的表示方式。你会学到一些一方面令人惊讶的东西，另一方面当你更好地理解它时会开始感知。</p><p>发言人   08:06<br>So a simple case is for numbers. I don’t know when it was, but it was probably in about 8th grade algebra that I learned that if you square a number, it will be at least 0, if it’s not an imaginary number. So either an integer or a real number, you’d expect to square and it to be a positive value, or perhaps 0. And that’s actually generally true with float through representation of floating point numbers. But with integer or ints, the computer representation of integers, it’s not so clear.<br>一个简单的案例就是数字。我不知道它是什么时候，但可能是在大约8年级的代数中，我学到了如果你平方一个数字，如果它不是虚数，它至少会是0。所以无论是整数还是实数，你都期望平方并且它是一个正值，或者可能是0。这实际上通常适用于浮点数到浮点数的表示。但是对于整数或整数的计算机表示形式，它不是那么清楚。</p><p>发言人   08:50<br>So for example, if you square 40000 on most computers, then you’ll get whatever that should be as you’d expect. But what if you square 50000, So you could do this in your head. But I actually built into this laptop as a computer. So I’m going to go ahead and use it.<br>因此，例如，如果您在大多数计算机上平方40000，那么您将获得应有的任何预期。但是，如果你平方50000，这样你就可以在脑海中做到这一点。但实际上我将这台笔记本电脑内置为电脑。所以我将继续使用它。</p><p>发言人   09:17<br>Let me just size this a little better for you here. And use a tool, which on Unix systems is called No, it’s going on. This is working before. Try again? Here we are on Linux systems is called Gdb, but on a Macintosh OSX it’s called lldb, but they’re pretty much the same program. You will get to know this program really, really well this term. So like I said, if you square 40000, you’ll get what you’d expect, but let’s change this to 50000.<br>让我在这里给你稍微调整一下这个的大小。并使用一个在Unix系统上被称为 “不” 的工具，它正在进行中。这是以前的工作。再试一次？这里我们在Linux系统上被称为Gdb，但在Macintosh OSX上它被称为ldb，但它们几乎是相同的程序。这个学期你会非常非常了解这个项目。就像我说的，如果你平方40000，你会得到你所期望的，但让我们把它改为50000。</p><p>发言人   10:18<br>And you get a very peculiar number that doesn’t look anything like you’d expect 50000 squared to be. And in fact, it’s negative. And so that might just seem like, well, there must be a mistake or something. No, that’s just the way it is. This computer is expecting numbers to be represented as 32 b values. And the bit pattern that you get when you do this multiplication happens to be the representation of a negative number. So that’s an example of where your normal expectations about integer arithmetic may or may not hold. On the other hand, there are some places.<br>你会得到一个非常奇特的数字，看起来与你预期的50000平方完全不同。事实上，这是负面的。因此，这可能看起来像是，肯定有错误或其他什么。不，事情就是这样。此计算机期望数字表示为32 b值。当你进行这个乘法时，你得到的位模式恰好是一个负数的表示。这是一个例子，说明您对整数算术的正常期望可能成立，也可能成立。另一方面，有一些地方。</p><p>发言人   11:09<br>Like if I try to do the same thing, multiplying 300 by 400 by 500 by 600, then all of a sudden I also get a number that clearly is not what you’d expect, because the same thing has happened. I’ve gotten an overflow. It happens that it’s overflowed to a value that’s positive, not negative. But it still is obviously not the integer product of those four numbers.<br>就像如果我尝试做同样的事情，用300乘以400乘以500乘以600，然后突然间我也得到了一个显然不是你期望的数字，因为同样的事情已经发生了。我已经溢出了。碰巧它溢出到一个正的值，而不是负的值。但显然它仍然不是这四个数字的整数乘积。</p><p>发言人   11:32<br>On the other hand, one thing you’ll find is even though this arithmetic is not normal sort of integer arithmetic, it actually has some well behaved properties. So for example, if you look at. What I’ve done is I just moved the 300 around from the beginning of the product of the product. And so now if you think about how associativism and commutativity works I’m basically multiplying these four numbers in a different order. But what you see is you get the same funny looking result no matter how you do it. So what you can say from this is integer arithmetic is commutative and associative. So it obeys some of the conventional mathematical properties. It just isn’t what you’d expect it to be.<br>另一方面，你会发现，尽管这种算术不是普通的整数算术，但它实际上具有一些良好的性质。例如，如果你看。我所做的是，我刚刚从产品的开始就移动了300。所以现在如果你考虑一下结合性和交换性是如何工作的，我基本上是以不同的顺序乘以这四个数字。但你看到的是，无论你怎么做，你都会得到同样有趣的结果。所以你可以说整数算术是交换和联合的。因此，它遵循一些传统的数学属性。这不是你所期望的。</p><p>发言人   12:32<br>A normal sort of mathematical integer arithmetic so. The cartoon here. Shows an example that’s a similar possibility to get to it?<br>一种普通的数学整数算术。这里的漫画。展示了一个类似可能性的例子，可以达到这个目标吗？</p><p>发言人   13:00<br>I guess it comes at the end. So then the next question is, is addition associative?<br>我想它会在最后出现。那么下一个问题是，加法是联合加法吗？</p><p>发言人   13:07<br>Can you order the numbers? And as you probably might have figured, both the integer arithmetic, even though it has this potential for overflow, it is associative and it’s commutative too. But for floats, it’s not really quite the same because the range of values you can get in floating point are so extreme that some numbers kind of disappear on you. So the example I’ll show without having to use a computer to do it is if you take a big number and subtract it from itself, you’ll get 0. So if you add that to 3.14, you’ll get 3.14. But if you take those two numbers and you reorder how you combine them, so that 3.14 compared to -10 to the 20th is so insignificant, that result gets turned into -10 to the 20th. And you add that to 10 to the 20th, and you end up with 0. So it’s not associative.<br>你能订购号码吗？而且正如您可能已经想到的那样，整数算术尽管有可能溢出，但它是联合的，也是交换的。但对于浮点数来说，它并不完全相同，因为在浮点数中可以获得的值范围非常极端，以至于一些数字在你身上消失了。所以我将展示的例子是，如果你从一个大数中减去它自己，你会得到0。所以如果你把它加到3.14，你会得到3.14。但是如果你拿这两个数字并重新排序如何组合它们，那么3.14相对于-10的20是如此微不足道，那么结果就会变成-10的20。然后你把这个加到20的10上，最后得到的是0。所以它不是联想的。</p><p>发言人   14:11<br>And so what you see is.<br>所以你所看到的是。</p><p>发言人   14:16<br>Both these number systems have some peculiarities, and it all comes down to the fact that they use finite representations of things that are potentially infinite in their expanse. And so there’s some compromises in how those work and what the compromise is. You can overflow an integer and run out of room. And in floating point numbers, you have round off problems where you sort of drop the digits that aren’t significant. You can also overflow floating point, the more common problem is round-off.<br>这两个数系都有一些特点，这一切都归结于它们使用有限的事物表示，这些事物在它们的空间中可能是无限的。因此，在这些工作方式和妥协是什么方面存在一些妥协。你可以溢出一个整数并耗尽空间。而在浮点数中，你会遇到舍入问题，会丢弃不重要的数字。你也可以溢出浮点运算，更常见的问题是舍入。</p><p>发言人   14:49<br>So this is shown in this cartoon, this idea of overflow of somebody counting sheep, which in the us is in English language at least, a way to fall asleep. And when he or she goes from 32767 and then increment set by one, gets -32768. And we’ll see exactly why that happens. But basically, the numbers are going up to the larger value it represent. And then when it goes one more, it becomes a negative number. So these are really important things to understand.<br>所以在这幅漫画中，有人数羊的想法溢出，在美国至少在英语中是一种入睡的方式。当他或她从32767开始，然后以1为增量设置时，会得到-32768。我们会看到为什么会发生这种情况。但基本上，这些数字正在上升到它所代表的更大的价值。然后当它再多一个时，它就变成了负数。这些都是需要理解的非常重要的事情。</p><p>发言人   15:29<br>I mean, 90% of the time, maybe you can just get by writing programs and not worrying about whether your numbers are going to exceed their possible range. But sometimes when this could be really important, like controlling a rocket, you really don’t want the positive thrust to become negative or something like that. So you can see this could be an important consideration. Similarly, there’s well andnow all instances of security vulnerabilities where somebody wrote code that sort of expected a positive number in some place and clever person figured out, if I supply a negative number, I can fool the system and get it to do bad things. So these are the kind of corner cases that you need to understand better if you’re either working in programs where it’s really, really important that it worked correctly or you’re really worried about security vulnerabilities. Anytime you have possible for corner cases, you have to understand these nuances better.<br>我的意思是，90% 的时间，也许你可以通过编写程序而不必担心你的数字是否会超过它们可能的范围来获得。但有时当这可能非常重要时，比如控制火箭，你真的不希望正推力变为负推力或类似的东西。所以你可以看到这可能是一个重要的考虑因素。同样，现在所有安全漏洞的实例都存在，有人编写的代码在某些地方期望为正数，聪明的人发现，如果我提供一个负数，我可以欺骗系统并让它做坏事。因此，如果您正在处理非常重要的程序，或者您真的担心安全漏洞，则需要更好地理解这些情况。任何时候你都有可能出现角落案例，你必须更好地理解这些细微差别。</p><p>发言人   16:35<br>Similarly for floating point, if you’re going to use floating point for serious computation, whether it’s scientific research or for designing bridges or nuclear power plants or something, you better understand what the characteristics are. So that’s our first one. And we’ll spend a couple of weeks talking about numbers and number of representations in their properties here.<br>同样，对于浮点数，如果你打算将浮点数用于严肃的计算，无论是科学研究还是设计桥梁或核电站等，你最好理解它们的特点。这是我们的第一个。我们将用几周的时间来讨论它们属性中的数字和表示数量。</p><p>发言人   17:00<br>The second is we’re going to spend a lot of time in this course learning about machine level programming, meaning what the instructions are that actually get executed by the computer. And that can be described in assembly language, which is a text version of it, or an object code, which is the actual bit level binary encoding of instructions. And we’ll learn a fair bit about that and spend a fair amount of time seeing how code that you write in C gets turned into machine code and how that gets executed on the machine.<br>第二点是，我们将在这门课程中花很多时间学习机器级别编程，这意味着计算机实际执行的指令是什么。这可以用汇编语言描述，这是它的文本版本，或对象代码，这是指令的实际位级二进制编码。我们将对此进行相当多的了解，并花费相当多的时间来观察你用C编写的代码如何变成机器码，以及它如何在机器上执行。</p><p>发言人   17:36<br>One thing I’ll say is that historically, courses like this would teach assembly code by having you write programs and assembly that do various things. Not usually very interesting because it’s a lot of work to write assembly program. This course is much more about taking the assembly code that’s been generated by a compiler, AC compiler, and looking at it and understanding it. And that’s a different set of skills than you need to write it on your own. And in particular, we’re going to look at the language of Intel processors. The most recent versions of them are called x 80 two-six, a dash 64, the 64 b version of their instruction set. And one thing that’s new in this course compared to previous ones, we used to teach 32 b stuff. This course is 64 b all the time.<br>我要说的一件事是，历史上，像这样的课程会通过让你编写程序和执行各种任务的汇编来教授汇编代码。通常不是很有趣，因为编写汇编程序需要大量的工作。这门课程更多地讲述了如何将编译器生成的汇编代码，交流编译器，并观察和理解它。这是一套不同的技能，与你自己写的技能不同。特别是，我们将着眼于英特尔处理器的语言。它们的最新版本被称为x80 2-6，破折号64，即它们指令集的64 b版本。和以前的课程相比，这门课程有一个新的地方，我们以前教32个b的东西。这门课程一直是64 b。</p><p>发言人   18:34<br>Another one that we’ll talk about a fair amount that is really fairly visible to programmers, surprisingly visible aspects of the memory system. So modern computers have a very complex layered memory system to try and give you high performance and high capacity at the same time. And there are some results of that system that can mean that if you program, write a program well, it might work really well. And if you don’t, it could run very poorly because it’s not making use of this hierarchical memory system. So, and also, there’s a lot of bugs that show up, especially in C programs that have to do with memory referencing errors. And so understanding what those errors are, what their manifestation is, how to prevent them as a big part of the course.<br>另一个我们将讨论的问题，对程序员来说相当明显，令人惊讶的是内存系统的可见方面。因此，现代计算机具有非常复杂的分层内存系统，以尝试同时为您提供高性能和高容量。这个系统的一些结果可能意味着，如果你编程、编写一个好的程序，它可能会工作得很好。如果不这样做，它可能会运行得非常糟糕，因为它没有利用这种分层存储系统。因此，还有很多bug出现，特别是在与内存引用错误有关的C程序中。因此，了解这些错误是什么，它们的表现是什么，如何防止它们是课程的重要组成部分。</p><p>发言人   19:25<br>So for example, if I define a struct that contains a two integer values, A in an array, and a double precision floating point number d? This function fu n, you’ll see what it does is it’s given an argument I, and it sets the i-th element of A to some strange looking value. So as you know, I should really only be either 0 or one with this code, because that’s the range of possible values of this array.<br>因此，例如，如果我定义一个包含两个整数值的结构，一个在数组中，和一个双精度浮点数d？这个函数fu n，你会看到它的作用是给定一个参数I，并将A的第i个元素设置为某个奇怪的值。如你所知，这段代码我实际上应该只为0或1，因为这是此数组可能值的范围。</p><p>发言人   20:06<br>A, we can try other things too. So in particular, if you run it on either one or two, you’ll get what you’d expect that you assign 3.14 to element D of this structure. And when you read it back, you get the same thing. And in fact, but now if I set a of 2, two of this number, all of a sudden you’ll see that my floating point number, which it seems to have nothing to do with A, has changed. And if I do that same thing with I equal to 3, you’ll see I get a number that’s closer to two than to 3.14. And if I keep going, well, nothing much happens until I hit. Six, and then the program crashes.<br>我们也可以尝试其他的事情。所以特别是，如果你在一个或两个上运行它，你会得到你所期望的，你将3.14分配给这个结构的元素D。当你读回它时，你会得到同样的结果。事实上，但现在如果我将这个数字设置为2和2，突然之间你会看到我的浮点数已经改变了，它似乎与a没有任何关系。如果我对I等于3做同样的事情，你会看到我得到一个更接近2而不是3.14的数字。如果我继续下去，那么在我击中之前，什么都不会发生。六，然后程序崩溃了。</p><p>发言人   21:06<br>So something interesting is going on here.<br>所以这里发生了一些有趣的事情。</p><p>发言人   21:09<br>At least something quirky is going on. And the reason is, again, it has to do with how data is weighed out in memory and how it’s accessed. And one of the features of C and C++ is it doesn’t do any bounds checking on arrays. It will happily let you reference element number 5 million of a two element array and not complain. But the operating system might complain, as it did here in this particular, structure. And we’ll see more about how structures are implemented and weighed out.<br>至少有一些古怪的事情正在发生。原因是，这与数据在内存中的称重方式以及访问方式有关。C和C ++ 的特点之一是它不对数组进行任何边界检查。它将很高兴让您引用两个元素数组中的500万元素，而不会抱怨。但是操作系统可能会抱怨，就像在这个特定的结构中所做的那样。我们将看到更多关于结构如何实施和权衡的信息。</p><p>发言人   21:46<br>But basically the two, if each of these blocks in this vertical chain represents 4 B. And so the two elements of A each are 4 B, d is 8 B. And then there’s some other stuff in the other beyond that that’s not actually in the struct itself. So you’ll see that if I reference either A of zero or a of one, then I will just modify that array as designed, but what I’m calling fun of two or fun of three, what I’m actually doing is altering the bytes that encode this number d, and that’s why you saw the sort of funny numbers come out of it. And as I go up, at some point, when I hit 6 I’m modifying some state of the program that it’s using to kind of keep things organized, most likely how it keeps track of allocated memory and that’s causing the program to crash.<br>但基本上这两个，如果这个垂直链中的每个块代表4 B。因此，A的两个元素各是4 B，d是8 B。除此之外，还有一些其他的东西实际上不在结构本身中。所以你会看到，如果我引用零或一的，那么我只会按照设计修改该数组，但我所说的两个或三个的乐趣，我实际上是改变编码这个数字的字节d，这就是为什么你看到其中出现了一些有趣的数字。随着我的上升，在某个时候，当我点击6时，我正在修改程序的一些状态，它正在使用它来保持事物的组织，很可能是它如何跟踪分配的内存，这导致程序崩溃。</p><p>发言人   22:49<br>So this is a pretty good demonstration of YC programming can drive you crazy because as you saw, it doesn’t do bounds checking. So it’s easy to write code that does invalid stuff.<br>这是一个很好的演示，说明YC编程可以让你发疯，因为正如你所看到的，它不进行边界检查。所以很容易编写做无效内容的代码。</p><p>发言人   23:05<br>It’s also often the case that you’ll cause some problem and it has this sort of action a distance feature that you can modify, some think modifying some data structure and what you’re doing because of the way things are organized in memory, you’re changing something totally unrelated somewhere else in the program.<br>这也经常会导致一些问题，并且它具有这种操作距离特征，您可以修改，有些人认为修改某些数据结构和您正在做的事情是因为内存中的组织方式，您正在更改程序中完全不相关的某些内容。</p><p>发言人   23:26<br>And imagine they’re not just one apart, but they’re 10000 apart, and things might just run fine hours, days, or weeks, and then all said at some point that data that got corrupted a long time ago gets accessed and something goes wrong. So this can be some of the worst debugging nightmares that exist on Earth is to try and figure out memory referencing errors.<br>并想象它们不仅仅是一个，而是相距10000个，事物可能只运行了几个小时、几天或几周，然后在某个时候所有人都说，很久以前损坏的数据会被访问，出了问题。所以这可能是地球上存在的一些最糟糕的调试噩梦，那就是试图找出内存引用错误。</p><p>发言人   23:56<br>So this is actually one argument not to program C or C, and it’s a valid argument I’ll admit. But also as a person who’s written in a lot of C programming, you just get more experienced. And you know at times that you should actually put bounds checking in your own code. And there’s also tools available that will help you sort of. Bulletproof your code so that it will detect these kind of problems. So it’s not like you have to change languages, but it is a particular feature of these languages. And so understanding sort of the machine level representation of data structures and how they work is really makes a huge difference in your ability to deal with these kind of vulnerabilities and things. Vulnerabilities, by the way, also from a security perspective.<br>所以这实际上是一个不编程C或C的参数，我承认它是一个有效的参数。而且作为一个用很多C编程编写的人，你只会得到更多的经验。有时你知道你应该在自己的代码中进行边界检查。还有一些工具可以帮助你。你的代码可以防弹，这样它就能检测到这些问题。所以这并不是说你必须改变语言，而是这些语言的一个特定特征。因此，理解数据结构的机器级别表示及其工作方式确实会对您处理这些漏洞和事物的能力产生巨大影响。顺便说一下，漏洞也是从安全角度来看的。</p><p>发言人   24:51<br>The fourth sort of theme we’ll cover in the course is getting performance out of programs. Other parts of the curriculum and CS do much more emphasis on getting the right algorithm with the right data structure.<br>我们将在课程中涵盖的第四种主题是从程序中获得性能。课程的其他部分以及CS更加强调使用正确的算法和正确的数据结构。</p><p>发言人   25:05<br>And that’s really well and good. It’s important stuff, I don’t deny it, but there’s some amount of the sort of low level optimization that you need to do. You need to understand what the system does, what makes it run well, what makes it run poorly, in order to be able to do that kind of optimization.<br>这真的很好。这是很重要的东西，我不否认，但是你需要进行一些低级别的优化。你需要了解系统做什么，是什么使它运行良好，是什么使它运行不佳，以便能够进行这种优化。</p><p>发言人   25:25<br>So the example we like to use is these two functions do exactly the same thing in terms of their their behavior. What they do is copy a matrix or an array from called source or src to a destination Dst. They’re both size to be 2048 rows, 2048 columns, two dimensional arrays. And you’ll see that the programs do the obvious thing. You have a nested pair of loops to do the row and column indices, and you just copy from one source element to a destination element. The only thing that’s different you’ll see is that the two loops, their nesting is different. Their nesting order is different. In one case I’m going kind of row first, going through all the rows and then the columns, and the other is for any given row I’m copying all the columns.<br>所以我们喜欢使用的例子是这两个函数在行为方面做完全相同的事情。他们所做的是将一个矩阵或数组从被称为源或tgt复制到目标Dst。它们的大小都是2048行，2048列，二维数组。你会发现这些程序做了显而易见的事情。你有一对嵌套循环来执行行和列索引，你只需要从一个源元素复制到目标元素。你会看到的唯一不同的是这两个循环，它们的嵌套是不同的。它们的嵌套顺序不同。在一种情况下，我会先做行，遍历所有行，然后是列，而另一种情况是对于任何给定的行，我正在复制所有列。</p><p>发言人   26:29<br>That’s really the only difference between these two programs. But what you’ll find if you run it on a typical system is that one is much faster than the other. And this particular machine we ran it on, it was about close to 20 times difference in performance.<br>这实际上是这两个程序之间唯一的区别。但是如果你在一个典型的系统上运行它，你会发现其中一个比另一个快得多。和我们运行它的这台特定机器相比，性能差异接近20倍。</p><p>发言人   26:46<br>Fishing is going on if the same program that differs only in the seemingly insignificant way, a way that has no effect whatsoever on its functionality, can have this much performance difference.<br>如果相同的程序只是在看似无关紧要的方式上有所不同，但对其功能没有任何影响，那么钓鱼就是在进行中，可能会产生如此大的性能差异。</p><p>发言人   27:00<br>And so to understand this, you need to stare at the cover of the book. Because basically, you’re at two different points of this strange looking picture that’s on your book. And since there’s no axes or Wls on it, it makes no sense whatsoever. But it’s there. So what you see is this picture shows for different memory access patterns, and I won’t go into the details, what the throughput measured in megabytes per second on basically a copying program was. And without going into the details, what you’ll see is these two functions sort of sit at different points in this memory access pattern, The one that goes through row by row is much better than the one that goes through column by column. And as a result, you’re getting a lot better performance. And it has to do with this memory hierarchy and what they call the cache memories that you’re getting way better performance out of it in one case than the other.<br>因此，要理解这一点，你需要盯着书的封面看。因为基本上，你在这本书上这张奇怪的图片的两个不同点上。而且由于上面没有斧头或Wls，所以它没有任何感知。但它在那里。所以你所看到的是这张图片展示了不同的内存访问模式，我不会详细说明，基本上在复制程序上以兆字节每秒测量的吞吐量是什么。而且不深入细节，你会看到的是这两个函数在这种内存访问模式中处于不同点，逐行遍历的函数比逐列遍历的函数好得多。因此，您将获得更好的性能。这与内存层次结构以及他们所谓的缓存内存有关，在这种情况下，您可以获得比其他情况更好的性能。</p><p>发言人   28:08<br>So that explains what the cover of the book is about, and we’ll talk about it more later in the course.<br>这就解释了这本书的封面是关于什么的，我们将在课程的后面更多地谈论它。</p><p>发言人   28:17<br>And then a final part of the course talks more about not just getting computers to run little programs in isolation, but getting computers that talk to each other over networks and implement services like web servers and other functions like that, which of course, is where most of the world of computing sits today. It’s not just isolated machines, but computers that interact with each other over the network. They’re embedded controllers that are interacting with the physical world. Really, the world of computers is much richer environment. And we’ll cover at least some aspects of that in the final part of this course.<br>然后课程的最后一部分更多地讲述了不仅仅是让计算机孤立地运行小程序，而是让计算机通过网络相互通信并实现诸如web服务器等服务和其他类似功能，这当然是当今大多数计算领域的所在地。它不仅仅是孤立的机器，而是通过网络相互交互的计算机。它们是嵌入式控制器，与物理世界进行交互。实际上，计算机世界的环境要丰富得多。在本课程的最后一部分，我们将至少涵盖其中的某些方面。</p><p>发言人   29:00<br>So as I mentioned, the other feature of this course is it will get you ready for other systems courses you might take at CMU. And here we’ve listed actually a subset of the courses at the university that require this course is a prerequisite. And they’re mostly in computer science and ECE, but you’ll see it’s quite a range of of different courses. And each of them builds on, say, one or multiple aspects of the material you learn in the course. So the reason why we make everyone take this course, including incoming masters students, is that all these other courses at the university have come to rely on students being familiar and having done the work of 213 or 513 as a prerequisite. And they can build on that material and sort of cover more ground as a result, rather than having to do what would otherwise be somewhat remedial work on it.<br>正如我所提到的，本课程的另一个特点是它可以让你为在CMU学习其他系统课程做好准备。在这里，我们列出了大学中一部分要求这门课程是先决条件的课程。他们大多在计算机科学和希腊，但你会发现它有很多不同的课程。它们中的每一个都建立在你在课程中学习的材料的一个或多个方面之上。因此，我们让每个人 (包括即将入学的硕士生) 都上这门课的原因是，这所大学的所有其他课程都依赖于学生熟悉并完成了213或513的工作作为先决条件。他们可以在这些材料上构建并覆盖更多的土地，而不必做一些本来可能是补救的工作。</p><p>发言人   30:03<br>And in fact, one part of the genesis of this course was the people who taught the operating system course of 410 sort of complained that they were spending too much time at the beginning of the course talking about some very basics of machine programming. And Dave and I said, oh, well, we can cover that. So that was part of what got this course started.<br>事实上，这门课程的起源之一是那些教授操作系统课程的人抱怨他们在课程开始时花了太多时间谈论一些非常基础的机器编程。戴夫和我说，哦，好吧，我们可以覆盖它。所以这就是这个课程开始的一部分。</p><p>发言人   30:27<br>And as I mentioned that the course has a sort of perspective that’s very different from traditional systems courses. Most systems courses, including that whole array you saw there, were about how do I build some particular feature? How do I implement an operating system? How do I design a pipeline, microprocessor? And those, that’s all important stuff to know. We really want the people who are out there building operating systems and designing microprocessors to have learned how to do it.<br>正如我所提到的，该课程的视角与传统系统课程非常不同。大多数系统课程，包括你在那里看到的整个数组，都是关于如何构建某些特定功能的？我如何实现一个操作系统？如何设计流水线，微处理器？这些都是需要知道的重要事情。我们真的希望那些在构建操作系统和设计微处理器的人学会如何做到这一点。</p><p>发言人   31:00<br>And as a way to sort of get new into this and get the introduction and get the experience, we find it more useful to take what we call a programmer’s perspective, meaning understanding what you as a person who sits in front of a computer screen and types code, a need to know about that machine you’re typing code for in order to be effective at doing it as opposed to somebody who’s someday going to be designing the actual machine itself. So by taking that perspective, it gives you sort of an understanding. So now when you go off to implement it, you’ll actually know what these features are and why it’s important to implement them well, but also that by doing this programmer’s perspective, it letsen right away get tools that you can use in other places where you’re writing programs or doing anything related to it, and be more effective at that. So this programmer’s perspective really gives this dual benefit to it that we feel is very useful. And students who’ve taken the course in the past I’ve expressed that as well. So as I mentioned, we have two instructors for the course, and they also happen to be authors. And the longest we’ve probably taught this course more than anyone else, but it’s also taught by other people on campus as well. So what I’m going to do now is hand my pair of microphones over to Dave.<br>作为一种获得新知识、介绍和经验的方式，我们发现采用我们所谓的程序员视角更有用，这意味着理解你作为一个坐在电脑屏幕前输入代码的人，需要了解你正在键入代码的机器，以便有效地完成它，而不是某个人有一天会设计实际机器本身。所以从这个角度来看，它会给你一种理解。所以现在当你开始实现它时，你会真正知道这些功能是什么，以及为什么实现它们很重要，而且通过这个程序员的角度来看，它会立即获得可以在其他地方使用的工具，在那里你正在编写程序或做任何与之相关的事情。并且在这方面更有效。因此，这种程序员的观点确实给它带来了双重好处，我们认为这非常有用。过去参加过这门课程的学生，我也表达了同样的看法。正如我提到的，我们有两位讲师，他们也恰好是作者。这是我们教授这门课程最长的，可能比任何人都多，但也有其他人在校园里教授这门课程。所以我现在要做的是把我的一对麦克风交给戴夫。</p><p>发言人   32:36<br>All right, welcome, Good afternoon, it’s great to see you. My name is da hellern, and I’m just delighted to have the opportunity to be one of your instructors this term. This course is one of the reasons I’m so excited to be teaching this course. I mean, I just love this course. And the real reason is the opportunity it represents to have an impact on people’s lives. We really believe that the material you learn this semester can have a really positive and long lasting impact on your careers. And it’ll help you not only with your future classes, but also future positions you have.<br>好的，欢迎，下午好，很高兴见到你。我的名字是da hellern，我很高兴有机会成为你们这学期的导师之一。这门课程是我很高兴能教授这门课程的原因之一。我的意思是，我只是喜欢这门课程。真正的原因是它所代表的机会可以对人们的生活产生影响。我们真的相信，你这学期学习的材料可以对你的职业生涯产生非常积极和持久的影响。它不仅会帮助你未来的课程，还会帮助你未来的职位。</p><p>发言人   33:22<br>And I hear this from people all the time, former CMU students, students around the world who have taken the equivalent of 213 at their schools.<br>我经常从人们那里听到这个消息，这些人包括前CMU学生，以及世界各地在学校学习相当于213的学生。</p><p>发言人   33:35<br>Even a couple years ago, we were interviewing a faculty member, a tenure track faculty member who went to, did his undergrad at CMU, and then went off to Stanford, got his Phd at Stanford, and was coming back to join the faculty. And he told me that 213 changed his life in our interview. Now, I don’t know if he was trying to butter me up, but I think I believe him. He said it changed his whole life in the sense that it gave him a research direction. He didn’t really know what he knew. He kind of liked computer science, but he didn’t really know what direction to go. And after he took 213, he knew they wanted to do his life’s work in systems. Now, it was just remarkable, right, to come back And we ended up actually hiring him.<br>甚至在几年前，我们还在采访一位教职员工，他是一位终身教职员工，曾在CMU上过大学，然后去了斯坦福，在斯坦福获得了博士学位，即将回来加入教职。他告诉我，213在我们的采访中改变了他的生活。现在，我不知道他是否想讨好我，但我想我相信他。他说它改变了他的一生，感知它给了他一个研究方向。他并不真正知道他所知道的东西。他有点喜欢计算机科学，但他不知道该往哪个方向走。在他拿了213之后，他知道他们想在系统中完成他一生的工作。现在，回来真是太了不起了，我们最终聘用了他。</p><p>发言人   34:28<br>And he told me that everybody in his lab at Stanford, all of the grad students, had a copy of the book on their desk. And they were from all over, you know, all different schools.<br>他告诉我，他在斯坦福实验室的每个人，所有的研究生，都在桌子上放着这本书。他们来自各地，你知道的，所有不同的学校。</p><p>发言人   34:38<br>And so, I mean, even I was in a bookstore in Beijing a couple years ago, right outside the PKU campus, And I was up on the fifth floor trying to see if I could find a copy of the textbook. And I found the English version in one aisle. And then a couple hours over, I found the Chinese version. And I was going through the Chinese version, and this guy taps me on my shoulder, and I turn around, he says, oh, man, that book is really good. You should. The English version is two aisles over. And I mean, it just blew me away to be in the head of someone halfway around the world.<br>所以，我的意思是，几年前我甚至在北京的一家书店里，就在PKU校园外面，我在五楼试图找到一本教科书。我在一个通道中找到了英文版本。然后几个小时后，我找到了中文版本。我正在看中文版本，这个家伙拍拍我的肩膀，我转过身去，他说，哦，伙计，那本书真的很好。你应该。英文版是两条过道。我的意思是，它让我大吃一惊，成为半个世界的人的头脑。</p><p>发言人   35:23<br>It was, it was just one of those moments. And so I’m not trying to boast. I want to give you the sense of what an opportunity this course represents for Randy and I too, to have what we hope will be a really positive impact on your lives.<br>这只是那些时刻之一。所以我不是在自夸。我想给你一个感知，这门课程对兰迪和我来说是一个怎样的机会，我们希望能够对你们的生活产生真正积极的影响。</p><p>发言人   35:45<br>So let me, we have kind of a kind of a funny organization for the course in response to just the tremendous demand we found that we have for it. So there’s actually three course numbers, but it’s all the same courses, the identical courses, 513, 15, 513 is for our master’s students. And the 5 and 13, 513 doesn’t have a formal lecture, so there’s no seats assigned to it. Instead, we’ll videotape the lectures and we’ll make those available on the course web page for our for our graduate students. And the reason we do this is just because in the past, we didn’t have enough seats for everyone, And there would be cases where there might be 100 or 150 Masters students on the wait list. They wouldn’t be able to get into the course. And we didn’t really want that because they need this course to take other courses. So that’s the reason why we have this sort of does not meet version of 213 and 513 because we can admit as many, all the master’s students that need to take the course now, 15 to 13 and 18 to 13, or are for undergraduates in computer science and ECE respectively.<br>所以让我说，我们有一个有点有趣的课程组织，以响应我们发现的巨大需求。所以实际上有三个课程编号，但都是相同的课程，相同的课程，513，15，513是给我们的硕士生的。而5号和13号，513没有正式的讲座，因此没有分配座位。相反，我们会把讲座录下来，放在课程网页上，供我们的研究生使用。我们这样做的原因只是因为在过去，我们没有足够的座位给每个人，有时可能会有100或150名硕士生在等候名单上。他们将无法进入课程。我们其实并不想这样，因为他们需要这门课程来选修其他课程。这就是为什么我们有这种不符合213和513版本的原因，因为我们可以承认现在需要学习这门课程的所有硕士研究生，分别是15到13和18到13，或者是计算机科学和计算机科学本科生。</p><p>发言人   37:14<br>The undergraduates will go to lectures and recitations, okay? In person. Graduate students will watch videotapes of those, but otherwise, videotape available to all. Yeah, we’re making them available to everyone, actually. And lecture slides as well. Everything’s available on the course web page. So you’ll be doing?<br>本科生会去听课和朗诵，好吗？亲自。研究生将观看这些录像带，但除此之外，所有人都可以观看录像带。是的，实际上，我们正在使每个人都可以使用它们。还有讲座幻灯片。一切都可以在课程网页上找到。那你要做什么？</p><p>发言人   37:48<br>All students will have equal access to office hours, the staff mailing list, and everybody does the same labs and the same exams. So it’s just a question. It’s just a matter of whether you go to lecture in person or if you watch it on video. Since it’s available to everybody, if you miss lecture, it’ll be there on the web page and you can catch up, which I know you’ll probably do. Actually. I know most of you will never miss class, but the few of you who do, you’ll be able to watch the video.<br>所有学生都将有平等的使用办公时间和职员邮件列表的权利，每个人都做同样的实验和考试。所以这只是一个问题。这只是一个问题，你是亲自去讲座还是通过视频观看。因为每个人都可以使用它，如果你错过了讲座，它会在网页上出现，你可以赶上，我知道你可能会这样做。实际上。我知道你们大多数人永远不会错过课程，但你们中很少有人会错过课程，你可以观看视频。</p><p>发言人   38:22<br>Okay, all right, this is the one part. This is the part I hate. I love teaching, but this is the one part teaching that none of us really like, but we have to talk about it, and that’s academic integrity if you’re new on campus. Or coming from an international school, if you’re an international student new on campus, there might be different notions of academic integrity and different notions of cheating at undergraduate school, your old school. So if you’re new on campus, pay very close attention to this because at Carnegie Mellon, we take academic integrity very seriously. It’s not a wink, wink, nod, nod we’re very serious about. It, and we want everybody doing their own work to preserve the integrity of the courses.<br>好的，好的，这是其中的一部分。这是我讨厌的部分。我喜欢教学，但这是我们中没有人真正喜欢的教学部分，但我们必须谈论它，如果你是新来的，这是学术诚信。或者来自国际学校，如果你是校园里的新国际学生，在你原来的学校，本科学校可能会有不同的学术诚信和作弊的观念。所以，如果你是新来的校园，请密切关注这一点，因为在卡内基梅隆，我们非常认真对待学术诚信。这不是眨眼，眨眼，点头，点头我们非常认真。我们希望每个人都做好自己的工作，以保持课程的诚信。</p><p>发言人   39:28<br>So what exactly is cheating? So if you share code with anybody, either copying, retyping, looking at somebody’s code, like if you look at somebody’s code on the screen, or if you give somebody a file, all of those. Examples of sharing are cheating. If you describe your code like line by line to somebody, that’s cheating. If you coach somebody line by line, that’s cheating.<br>那么作弊到底是什么呢？因此，如果您与任何人共享代码，无论是复制，重新键入，查看某人的代码，就像您在屏幕上查看某人的代码，或者您给某人一个文件，所有这些。分享的例子就是欺骗。如果你对某人一行一行地描述你的代码，那是作弊。如果你一行一行地指导某人，那就是作弊。</p><p>发言人   40:09<br>Searching the web for solutions Just the act of searching is cheating. This is a real problem for us in particular because the courses are offered all around the world. People either maliciously or sometimes just they’re proud of their work and they post it for employers on like public GitHub sites. So it might be tempting to search for these solutions. But even the act of searching is cheating indefinitely. If you find some solution and use it, that’s cheating, even if you modify it afterwards. And I just want you to remember, I know how to use Google just as well as anybody else. I can search for solutions, too.<br>在网上搜索解决方案，仅仅搜索这个行为就是欺骗。这对我们来说是一个真正的问题，因为这些课程在世界各地都有提供。人们要么恶意地，要么有时只是为自己的工作感到自豪，并在公共GitHub网站上向雇主发布。所以寻找这些解决方案可能很有诱惑力。但即使是搜索行为也是无限期的欺骗。如果你找到了一些解决方案并使用它，那就是作弊，即使你后来修改了它。我只是想让你记住，我和其他人一样知道如何使用谷歌。我也可以寻找解决方案。</p><p>发言人   41:04<br>So copying code, you might be temp, you might be tempted to copy code from someone who took the class in a previous semester. Don’t do it, that’s cheating. Now what’s not cheating? So you can help each other use tools if somebody’s having trouble using Gdb or they have questions about how to run, use a text editor. That stuff’s all great. You help each other out using the tools, how to log in the shark machines, all of that kind of stuff. And you can discuss sort of high level design issues. And that’s probably a good idea. Yeah, Did you take it at a previous semester?<br>所以复制代码，你可能是个临时工，你可能会想从一个上学期上过这门课的人那里复制代码。不要这样做，那是作弊。现在，什么不是作弊？因此，如果有人在使用Gdb时遇到问题，或者他们对如何运行有疑问，可以使用文本编辑器，您可以互相帮助使用工具。这些东西都很棒。你们互相帮助使用工具，如何登录鲨鱼机器，所有这些东西。你可以讨论一些高层次的设计问题。这可能是个好主意。是的，你是在前学期学的吗？</p><p>发言人   41:58<br>Okay, yeah, the question was, if you took it in a previous semester, can you use your work? And the answer is yes. So you can also talk to each other about high level design issues, how you are you using an explicit list or are using a segregated list for your mallet lab? That kind of stuff is okay, high level OK, low level not OK. And basically what we want you to write your own code, this is not, it’s kind of a cut and paste world these days, right? You look stuff up on Google Stack Overflow, you cut and paste it, But that’s not the way we do it here. We want you to do the work yourself. We want you to enjoy the experience of figuring things out and learning how to solve problems.<br>好的，是的，问题是，如果你在上一学期学过，你能用你的工作吗？答案是肯定的。因此，您还可以相互讨论高级设计问题，如何在您的木槌实验室中使用明确列表或隔离列表？那种东西没关系，高水平的没关系，低水平的没关系。基本上，我们希望你编写自己的代码，这不是，现在它有点像剪切和粘贴的世界，对吧？你在谷歌堆栈溢出上查找内容，你剪切并粘贴它，但这不是我们在这里做的方式。我们希望你自己做这项工作。我们希望您享受弄清楚事情和学习如何解决问题的经验。</p><p>发言人   42:57<br>Now, the consequences for cheating, there’s a single sanction. If you’re caught cheating, you’ll be expelled from the course with an R, there’s no exceptions. If you drop the course, we’ll just reinstate you and then plunk you. It’s really, it’s a very serious, very serious penalty. Just we take it so seriously and. It’s just something we don’t want you to do. We have amazing tools to detect code plagiarism.<br>现在，作弊的后果只有一个制裁。如果你被抓到作弊，你会被开除了课程，没有例外。如果你退学，我们只会让你复职，然后解雇你。这是一个非常严重、非常严重的惩罚。我们只是非常认真地对待它。这只是我们不想让你做的事情。我们有惊人的工具来检测代码抄袭。</p><p>发言人   43:51<br>We have amazing tools to detect plagiarism. That are resilient to renaming, reformatting? They operate at a very deep syntactic level. So just please, please don’t do it.<br>我们有惊人的工具来检测抄袭。具有抗重命名、重新格式化的弹性？它们在非常深刻的语法层面上运作。所以请不要这样做。</p><p>发言人   44:10<br>We have, I think, 18 Tas will have office hours almost every day of the week. There’s plenty of opportunities and ways to get help. Start early. If you get stuck, start early enough so that if you get stuck, you can go ask for help. We have automatic extensions built in if you need more time. I’ll talk about that later form of grace days, but please, please, whatever you do, don’t cheat. It’s just tragic when it happens.<br>我想我们每周几乎每天都会有18个办公时间。有很多机会和方法可以获得帮助。早点开始。如果你被卡住了，尽早开始，这样如果你被卡住了，你可以去寻求帮助。如果您需要更多时间，我们会内置自动扩展功能。我将谈论以后形式的宽限期，但请无论你做什么，不要作弊。当它发生时，这只是悲惨的。</p><p>发言人   44:47<br>Last fall, 25 students were expelled from the course. Some were expelled from the university because it was a second offense. Many were sent home. I talked to students who were like the only person in their family to go to college, the only person in their village to go to college, and they were going home without a degree, and it’s just tragic. So please, please, please don’t do it. Do your own work and it’ll be a wonderful experience.<br>去年秋天，有25名学生被该课程开除。有些人被大学开除，因为这是第二次进攻。许多人被送回家。我和一些学生交谈，他们好像是家里唯一上大学的人，他们村里唯一上大学的人，但他们没有学位就回家了，这真是个悲剧。所以请，请，请不要这样做。做好自己的工作，这将是一次美妙的经历。</p><p>发言人   45:25<br>Okay, as Randy mentioned, the textbook is computer Systems, a programmer’s perspective, third edition. You can, there’s a whole bunch of supporting material on the book website at CSP docs dot CMU dot edu do. And as Randy mentioned, this book really matters for the course because it actually the came out of the course. The book is the course, of course is the book. And so it’ll really help you.<br>好的，正如兰迪提到的，教科书是计算机系统，程序员的视角，第三版。你可以在图书网站上找到很多支持材料，网址为CSP docs dot CMU dot edu do。正如兰迪所提到的，这本书对这门课程非常重要，因为它实际上是出自这门课程。书是课程，当然是书。所以它会真正帮助你。</p><p>发言人   45:57<br>The labs that we do come directly from material that we discuss in the book. So what I would encourage all of you to do, and I’m not sure if anybody has ever taken this advice, but I say it every year anyway, because I believe it. But I think a really good strategy for studying and preparing for this course would be to read each chapter 3 times, okay? Read it three times, work the practice problems. So we have litter throughout the book or practice problems with solutions at the end of the end of the chapter. And these practice problems are like little sort of bite size morsels just to kind of check your kind of a sanity check of your understanding of the material. So I think if you read this, if you read the book each chapter three times and worked at practice problems, that would be an excellent way.<br>我们所做的实验室直接来自我们在书中讨论的材料。所以我会鼓励你们所有人做什么，我不确定是否有人采纳了这个建议，但我每年都会说，因为我相信它。但是我认为学习和准备这门课程的一个非常好的策略是将每章阅读3次，好吗？读三遍，解决实际问题。所以我们在整本书中都有乱扔的东西，或者在章节末尾处用解决方案来练习问题。这些实践问题就像一口大小的小块，只是为了检查你对材料理解的理智检查。所以我认为，如果你读这篇文章，如果你把这本书每一章读三遍，并练习问题，那将是一个很好的方法。</p><p>发言人   46:48<br>To go through the semester and prepare, the other book we use is kenaan and Richie’s classic C programming book. I think this is still, this was written a long time ago. It’s still the best book around. I think for C, it’s a beautiful example of technical writing. It was one of the inspirations I used when I was writing the book. I tried to find that same clarity, precision that they, that kernaghan and Richie. Have in their book. So this is a really good book. I mean, this is a kind of book. It’s a reference, but it’s a kind of book you can just read from beginning to end and get a really good understanding of C?<br>为了完成学期和准备，我们使用的另一本书是kenaan和Richie的经典C编程书。我认为这仍然是很久以前写的。这仍然是最好的书。我认为对于C来说，这是一个很好的技术写作例子。这是我写书时使用的灵感之一。我试图找到与kernaghan和Richie相同的清晰度和精确度。在他们的书中。所以这是一本非常好的书。我的意思是，这是一种书。这是一个参考，但它是一种你可以从头到尾阅读并对C有很好的理解的书？</p><p>发言人   47:41<br>There’s four main components to the course. There’s lectures where we go over the high level concepts, recitations where which meet once a week for an hour, led by a Ta. The purpose of the recitations is really to help you with the labs. So it’s very practical and hands on.<br>这门课程有四个主要组成部分。有讲座，我们会讨论高级概念，背诵课，每周一次，每次一个小时，由Ta领导。复习篇的目的真的是为了帮助你进行实验。所以它非常实用和实用。</p><p>发言人   48:02<br>There’s 7 of those labs, and these are really the heart and soul of the course. This is where all the real learning comes in. I think when you actually have to do this stuff. And that’s why we take the cheating part so seriously, because if you do these labs, you’re going to learn an incredible amount of really cool stuff. If you don’t do them, you won’t learn anything, right? So each one of these labs is one or two weeks each and involves typically some kind of programming or measurement.<br>有7个这样的实验室，这些是课程的核心和灵魂。这就是所有真正学习的地方。我认为当你真的必须做这些事情的时候。这就是为什么我们如此认真地对待作弊部分，因为如果你做这些实验，你会学到很多非常酷的东西。如果你不这样做，你什么也学不到，对吧？所以这些实验室中的每一个都需要一周或两周的时间，通常涉及某种编程或测量。</p><p>发言人   48:40<br>There’s also two exams, a midterm and a final. The exams are Proctor, they’re online Proctor in Wean and Gates. And what we do for the exams is we have we take like four days from 10 to 10, and then you can sign up. And then we have like multiple clusters that are network isolated. And then you can sign up for a slot, like a six hour slot.<br>还有两次考试，一次期中考试和一次期末考试。这些考试是监考，它们是在断奶和门的在线监考。我们为考试做的是从10到10，我们需要四天的时间，然后你可以报名。然后我们有多个网络隔离的集群。然后你可以注册一个时段，比如六个小时的时段。</p><p>发言人   49:08<br>And the midterm is like nominally like an hour, 80 minute exam. It’s the same exam we gave when we used to have people sitting in person. So it’s nominally like 80 minutes, but we give you like a five or six hour window to do it. So you can sign up anytime, any day that there’s a slot. So there’s flexibility. So you can kind of tailor it to your your schedule. And I think we’ve also removed all the time pressure. So which is you can go back, you can check your work, you can just kind of relax and not be worried about how quickly you do it.<br>期中考试名义上就像一小时80分钟的考试。这和我们以前让人们亲自坐在一起的考试是一样的。所以它名义上像是80分钟，但我们给你五到六个小时的窗口来完成它。这样你就可以在任何时间、任何有空位的日子注册。所以有灵活性。所以你可以根据你的日程安排来定制它。我认为我们也消除了所有的时间压力。所以你可以回去，你可以检查你的工作，你可以放松一下，不用担心你做得有多快。</p><p>发言人   49:54<br>Now, there’s many different ways to get help. The main source of information is the course web page. That’s Www dot c.s.c.m. U Edu tilde 213 and all the information is there.<br>现在，有很多不同的方法可以获得帮助。主要的信息来源是课程网页。这是Www.c.S.c.m.。 U Edu tilde 213，所有信息都在那里。</p><p>发言人   50:09<br>We’ve got a complete schedule of lectures and assignments, we don’t change it, it’s fixed, and so you can look at that and plan your semester knowing that those dates won’t change. We’ve actually even got all of the lectures posted ahead of time for the other instructors around the world who are using the book, so we needed to get them all ready. There’s also news at the very beginning. There’s sort of news if we need to make announcements, we’ll post it there.<br>我们有一个完整的讲座和作业时间表，我们不会改变它，它是固定的，所以你可以看看它并计划你的学期，知道这些日期不会改变。我们甚至已经提前为世界各地使用这本书的其他讲师发布了所有的讲座，所以我们需要让他们准备好。最开始也有新闻。如果我们需要发布一些新闻，我们会在那里发布。</p><p>发言人   50:41<br>We don’t use either Blackboard or Piazza in the course. Instead, we have a staff mailing list that you can send mail to if you have questions and all of the Tas and all of the faculty are or subscribe to that staff mailing list. And so we’ll all see it. And we usually, we try to have really fast feedback. So there’s so many people, so many people looking at your emails that chances are very high an answer back quickly. The disadvantage of having the advantage of this mailing list is that it allows us to control the message. And control what feedback we’re giving back to you.<br>我们在课程中不使用黑板或广场。相反，我们有一个员工邮件列表，如果您有问题，您可以发送邮件，并且所有的Tas和所有的教职员工都订阅了该员工邮件列表。所以我们都会看到它。通常，我们会尝试获得非常快速的反馈。所以有这么多人，这么多人在看你的电子邮件，很快得到回复的机会非常高。拥有这个邮件列表的缺点是它允许我们控制消息。并控制我们向您提供的反馈。</p><p>发言人   51:30<br>The disadvantage is that we often get the same question over and over again. And so for that, we’ve established a fact. If we find we’re getting same questions over and over, we’ve established a fact on the course web page sort of organized by labs, you can see the answers to frequently asked questions on there.<br>缺点是我们经常一遍又一遍地遇到同样的问题。因此，我们已经确立了一个事实。如果我们发现我们反复收到相同的问题，我们已经在课程网页上建立了一个事实，该事实按实验室组织，您可以在那里看到常见问题的答案。</p><p>发言人   51:56<br>We have office hours. We’re still trying to meet with the staff and figure out the exact office hours. What we’re thinking now is that we’ll have office hours 6 days a week, every day if it’s Saturday. They will be at the same time and same place every day. So from 545 to 830 in, we the Ween 5207 cluster, we’ll have 213 Tas there to help to answer your questions so you don’t have to make appointments. I mean, you can make an appointment to see any staff member, of course, but you know that at the same time, the same place every day, there’s somebody you can go to for help.<br>我们有办公时间。我们仍在努力与员工见面，并弄清楚确切的办公时间。我们现在的想法是，如果是星期六，我们将每周有6天的办公时间。他们每天都会在同一个时间和同一个地方。所以从545到830，在我们这个5207集群中，我们将有213个Tas来帮助回答您的问题，这样您就不必预约了。我的意思是，当然，你可以预约会见任何工作人员，但你知道，每天在同一时间，同一个地方，你可以去找人帮忙。</p><p>发言人   52:51<br>Okay, for our labs and exams, every assignment, every lab is single person. So we don’t have any group projects. We want you to do the work yourself. Now, you know, it’s important to work in groups and you will learn how to work in groups and other classes, CS classes, but not in T 13.<br>好的，对于我们的实验室和考试，每个任务，每个实验室都是一个人完成的。所以我们没有任何团体项目。我们希望你自己做这项工作。现在，你知道，分组工作很重要，你将学习如何在小组和其他课程中工作，但不是在t13中。</p><p>发言人   53:09<br>This is a kind of a core course. We want you to figure stuff out yourself. All of our hand ins will be due at 1159 PM on either a Tuesday or Thursday. And this is, you can see which on the schedule page, on the course web page, and all of our hand ins are using Auto lab where you’ve probably used it for some of your other classes, but it’s an auto grading service that allows you to get instant feedback on your hand in. So when you hand it in, you get feedback right away.<br>这是一门核心课程。我们希望你自己解决问题。我们所有的下午都将在周二或周四1159点到期。这是，你可以在日程安排页面，课程网页上看到，我们所有的手都在使用自动实验室，你可能已经在其他一些课程中使用过它。但这是一项自动评分服务，可以让你即时得到反馈。所以当你交出来的时候，你会马上得到反馈。</p><p>发言人   53:44<br>The exams, like I mentioned, are going to be in network isolated clusters held over multiple days and you can just sign up for a slot that’s available. Now, what usually happens if we offer like the exam Tuesday, Wednesday, and Thursday? The Thursday slots fill up immediately. I guess you should try to sign up soon if you want, but people will always seem to want to defer to the end rather than. I mean, if it was me I’d want to get it over with, but. So I just, that is sort of a constraint, right? You can only sign up for slots that are available, okay?<br>就像我提到的，考试将在网络隔离的集群中进行，持续多天，您只需注册一个可用的时间段即可。现在，如果我们提供像星期三、星期四这样的考试，通常会发生什么？星期四的档位立刻被填满。我猜如果你想的话，你应该尽快报名，但人们似乎总是想推迟到最后而不是。我的意思是，如果是我，我想结束它，但是。所以，这只是一种限制，对吧？你只能注册可用的插槽，好吗？</p><p>发言人   54:29<br>Now, you know, we make mistakes. We always make mistakes, especially with just so many students.<br>现在，你知道，我们犯错了。我们总是犯错误，特别是有这么多学生。</p><p>发言人   54:35<br>So there’s, there’s a specific process for appealing grades if you think that there was that your work wasn’t graded properly. So what you do after either an exam or after your labs are graded, you have seven days to file an appeal. And appeals have to be in writing and hard copy. So no, we won’t consider email any appeals via email. It has to be in writing in hard copy and you give those to me and if I’m not there, you can just slide it under the desk. And what the reason we do it that way is it allows us to treat. Everybody fairly. So we get all the appeals together at once, and then we can treat everybody the same way rather than just sort of doing them one at a time like that, okay?<br>所以，如果你认为你的作业评分不正确，有一个特定的过程可以上诉评分。因此，无论是考试后还是实验室评分后，您都有七天的时间提出上诉。上诉必须是书面形式和硬拷贝。所以不，我们不会考虑通过电子邮件发送任何上诉。它必须是书面形式的硬拷贝，你把它们给我，如果我不在，你可以把它滑到桌子下面。我们这样做的原因是它让我们能够治疗。每个人都相当。所以我们一次把所有的呼吁集中在一起，然后我们可以以同样的方式对待每个人，而不是像那样一次一个地做，好吗？</p><p>发言人   55:37<br>Now for our labs we have. 10 machines that were donated by Intel called the Shark Machines. So initially, our first version of 213 in, I guess we started using Intel machines in 1999. We used the Alpha processors for the first year. I like to fish, so all of our machines, they were called the fish machines. They were freshwater fish. And then we upgraded a few years after that, and those were the saltwater fish machines. And then we upgraded like in 2011 to these nehale class servers had run out of freshwater fish and saltwater fish.<br>现在我们有了实验室。10台由英特尔捐赠的机器，称为鲨鱼机。所以最初，我们在213的第一个版本中，我想我们在1999年开始使用英特尔机器。我们第一年使用了Alpha处理器。我喜欢钓鱼，所以我们所有的机器都被称为 “鱼机”。它们是淡水鱼。几年后我们对咸水鱼机进行了升级，这些就是咸水鱼机。然后我们像在2011年一样升级到这些nehale级服务器，淡水鱼和咸水鱼用完了。</p><p>发言人   56:19<br>So the next grade up was sharks, right? So every fish is named after some kind of shark, but these are the same machines that that you that auto La uses for grading. So there’s some consistency for performance oriented labs like Mali lab, and you can access them. The names are listed on the course web page.<br>所以下一个年级是鲨鱼，对吧？因此，每条鱼都以某种鲨鱼命名，但这些机器与自动La用于分级的机器是相同的。因此，像Mali实验室这样的以性能为导向的实验室有一些一致性，您可以访问它们。这些名字列在课程网页上。</p><p>发言人   56:45<br>And so you can SSH to a specific machine. They’re all identical. If you have an Android account, you’ve already got accounts on the machines, so there’s nothing special to do. Or you can just SSH to Sharp do Ics, and it’ll just randomly put you on on one of the shark machines, okay? If you have any trouble logging in, just send mail to the staff mailing list.<br>所以你可以SSH到特定的机器上。他们都是一样的。如果你有安卓账户，那么你已经在机器上有账户了，所以没有什么特别的事情可做。或者你可以只使用SSH到Sharp做Ics，它会随机把你放在鲨鱼机器上，好吗？如果您在登录时遇到任何问题，只需发送邮件到员工邮件列表。</p><p>发言人   57:12<br>Okay, we know that during the semester things come up, grandparents die, especially near the they’re the final. That’s harsh, I know, but things come up right? And youve got you’re very busy, you’re taking a lot of courses. So instead of sort of dealing with requests for extensions and all these special cases, what we do is we give you 5 grace days that you can then spend as you wish.<br>好的，我们知道在这个学期里会出现祖父母去世的情况，特别是在他们接近期末考试时。这很严厉，我知道，但事情会发展到对吧？而且你很忙，你正在上很多课程。因此，我们不会处理延期请求和所有这些特殊情况，而是给你5个宽限期，你可以随意度过。</p><p>发言人   57:47<br>So if you hand your work in late one day late, you’ll automatically consume a grace day. We don’t allow you to sort of allocate the gray stays. You spend one of your grace stays handing in late. So if you have a grace day left and you hand in late, you’ll spend that grace day, but you won’t be penalized for the late hand in. And so we have five grade days over the entire semester. A maximum of 2 grace stays for the assignments.<br>所以，如果你晚一天把工作交给工作，你将自动享受宽限期。我们不允许您分配灰色停留。你花费了你的恩典之一，熬夜上交。所以，如果你还有宽限期，而你交晚了，你会度过这个宽限期，但你不会因为迟交而受到惩罚。因此，我们在整个学期中有五个年级日。分配的最大宽限期为2。</p><p>发言人   58:20<br>Now we’re going to set up since the first three assignments are kind of not as programming intensive and don’t take as much time, we’re not going to allow any grace stay for those because, oh, one grace day, sorry, 1 grace day. And then for the latter 4 labs, which are much more intense, we’re going to allow you a max of two grace days. And the reason we’re doing this is because we don’t want you to burn your.<br>现在我们要设置，因为前三个任务不是编程密集型的，也不需要花费太多时间，我们不会允许任何宽限期停留，因为，哦，一个宽限期，对不起，一个宽限期。对于后四个更密集的实验室，我们将给你最多两天的宽限期。我们这样做的原因是因为我们不希望你烧掉你的。</p><p>发言人   58:48<br>These grace days are valuable. They’re critical, especially later in the semester when you’re really, really busy. So we don’t want you to burn up your grace days early in the semester. And this happens every semester. And then when Malik Lab comes up, there’s no grace stays left. And it’s really sad to see that. And so we’re going to limit it to one for those first three just to help you save you from yourself. Now?<br>这些宽限期很有价值。它们很关键，尤其是在你非常忙碌的学期后期。所以我们不希望你在学期初就把你的宽限期烧掉。每学期都会发生这种情况。然后，当马利克实验室出现时，就没有留下的恩典了。看到这一点真的很难过。所以我们将前三个限制在一个，只是为了帮助你摆脱自己。现在？</p><p>发言人   59:24<br>The nominal late penalty, if you don’t have a grace stay is 15% per day. And we don’t allow any hand ins three days after the due date at all. So that auto lab shuts off and then that’s it. Now, if there’s some kind of catastrophic event, then please contact us for an extension. So we’re not, we try to be reasonable. Most of the reasons that for requesting extensions, you can handle yourself using your great stays.<br>如果您没有宽限期，则名义延迟罚款为每天15%。我们不允许在到期日后三天内进行任何操作。这样自动实验室就关闭了，就这样了。现在，如果有某种灾难性事件，请与我们联系以获取延期。所以我们不是，我们试图讲道理。大多数请求扩展的原因，你可以使用你的优质住宿来处理自己。</p><p>发言人   01:00:06<br>This is advice I give every semester too. But people often don’t, don’t pay attention, or just they’re unable to. But really, for every one of these assignments, you want to start early. And the reason is you need to give yourself time to go seek help if you get stuck, because the nature of these very programming intensive assignments like we have in 213, is that you’re going to get stuck. And often it’s very hard to bound the time you spend on some of these assignments. It’s not like problem sets where you can kind of predict this will take, this will take me like three hours to do these problem sets for a lot of the 213 assignments. It’s very difficult to sort of manage your time and bound your time. So for that reason, you really want to start early to give yourself a chance to get help when you get stuck.<br>这也是我每学期都会给出的建议。但人们通常不会，不注意，或者只是他们无法注意。但实际上，对于每一个任务，你都希望尽早开始。原因是如果你卡住了，你需要给自己时间去寻求帮助，因为这些非常需要编程的任务的性质就像我们在213中所做的那样，你会卡住的。而且通常很难限制你在这些任务上花费的时间。这不像习题那样，你可以预测这将需要多少时间，对于213个作业中的很多作业，我需要花三个小时来做这些习题。管理你的时间并限制你的时间是非常困难的。因此，当你遇到困难时，你真的想早点开始给自己一个获得帮助的机会。</p><p>发言人   01:01:02<br>Now in the lecture hall, you’re permitted to have your laptops. But we ask you not to send email or instant messaging or cell phone texting or anything like that. If you’re here, we want you to be attentive and engaged. Your presence in lectures and recitations is voluntary. So we don’t take, we don’t take role at either of those. We encourage you to come, but it’s not required. And no recordings of any kind except this one. Okay, the exams in labs are weighted equally, 50%, midterms, 20, finals, 30, and final grades are based on a straight 90, 80, 70 scale.<br>现在在演讲厅里，你可以有你的笔记本电脑。但我们要求您不要发送电子邮件、即时消息、手机短信或类似的东西。如果你在这里，我们希望你能专注和投入。你参加讲座和朗诵是自愿的。所以我们不承担，我们不承担其中任何一个的角色。我们鼓励你来，但这不是必需的。除了这一个，没有任何形式的录音。好的，实验室考试的权重相等，50%，期中考试，20分，期末考试，30分，而最终成绩则基于直90、80、70分。</p><p>发言人   01:01:56<br>Now, rough outline of the semester. The first three labs cover the machine representations of programs and data. Data Lab is how we teach you about bit level of representations of data.<br>现在，这学期的大致轮廓。前三个实验涵盖了程序和数据的机器表示。数据实验室是我们教授数据的位级表示的方式。</p><p>发言人   01:02:13<br>So you’ll solve collection of puzzles in C, like a puzzle might be, is a little function that you have to implement, like absolute value. So a function that returns the absolute value of its our input argument. The kicker is that we restrict the set of operators that you can use, and it has to be straight line code, no conditionals or loops. And so to solve these puzzles.<br>所以你将解决C中的谜题集合，就像一个谜题可能是，是一个你必须实现的小函数，比如绝对值。因此，这是一个返回其输入参数绝对值的函数。关键在于我们限制了您可以使用的运算符集，并且它必须是直线代码，没有条件或循环。所以要解决这些难题。</p><p>发言人   01:02:37<br>So imagine how you might try to solve absolute value without using an if statement. The normal way to do it would be if x less than 0 would return x or negative x? See, I told you we make mistakes, right? But imagine how you might do that without using conditionals and only using bit-level c operator. So this is our way of teaching you how data is really represented in the machine.<br>所以想象一下，你可能会尝试在不使用if语句的情况下解决绝对值。通常的方法是，如果x小于0会返回x或负x？看，我告诉过你我们会犯错误，对吧？但是想象一下，你可能会如何在不使用条件语句而只使用位级c运算符的情况下做到这一点。这是我们教你如何在机器中真正表示数据的方式。</p><p>发言人   01:03:10<br>Now, the bomb lab, which you’ve probably heard of, this is kind of famous all over the world now. And at CMU, the BA lab is the way we teach you how to read and understand assembly language.<br>现在，炸弹实验室，你可能听说过，它在世界各地都很有名。在CMU，BA实验室是我们教你如何阅读和理解汇编语言的方式。</p><p>发言人   01:03:26<br>And a bomb. Just briefly, a bomb is AC program that consists of a collection of six phases. And each phase wants you to type something in at the keyboard. If you type in the wants you to type what it expects you to type, then you’ve diffused that phase and it goes to the next phase. Then you have to type what that phase wants. And if you defuse all the phases, then you’ve defused the bomb. However, if you type in the wrong thing, then the bomb explodes by printing boom, and you have to try it again, and the kicker is, in either case, if you explode the bomb or diffuse a phase, that information gets sent to auto lab.<br>一颗炸弹。简而言之，“炸弹” 是交流由六个阶段组成的程序。每个阶段都需要你在键盘上输入一些东西。如果你输入了 “想要”，你要输入它期望你输入的内容，那么你就分散了那个阶段，它就进入了下一个阶段。那么你必须输入那个阶段想要的东西。如果你化解了所有的阶段，那么你就化解了炸弹。但是，如果你输入了错误的内容，那么炸弹就会通过打印炸弹爆炸，你必须再试一次，而关键是，无论是在哪种情况下，如果你引爆炸弹或扩散一个阶段，该信息都会被发送到自动实验室。</p><p>发言人   01:04:16<br>If you and we use the diffusing string that your bomb sends us and we check it out on a copy of your bomb that we keep on the server, well, that’s another thing. Everybody gets a different bomb, slightly different bond. So we check when you diffuse, when you diffuse a phase, auto La takes a string that it that your bomb sends us and then compares against the local copy of your bomb. If you explode phase, you lose half a point. So there’s a real consequence to exploding your bomb. It’s very tense.<br>如果你和我们使用你的炸弹发送给我们的扩散线，我们会在服务器上保存的炸弹副本上进行检查，那就是另一回事了。每个人都得到不同的炸弹，略有不同的联系。所以我们会检查你何时扩散，当你扩散一个相位时，自动洛杉矶会获取你的炸弹发送给我们的字符串，然后与你的炸弹的本地副本进行比较。如果你爆炸了阶段，你会失去半个点。所以爆炸你的炸弹会有真正的后果。它非常紧张。</p><p>发言人   01:04:57<br>Until you learn how to use Gdb to set a breakpoint before the function that sends the information to the server. And we want you to do that. So the bombs are really, the bombs are really beautiful.<br>直到您学习如何使用Gdb在将信息发送到服务器的函数之前设置断点。我们希望你这样做。所以这些炸弹真的很漂亮。</p><p>发言人   01:05:11<br>It’s kind of fun. It’s kind of like a video game. It teaches you how to read compiler generated code because, oh, the kicker is, sorry. The kicker is we don’t give you the source code. All we give you is the binary, hence the binary bomb. So in order to diffuse a bomb, you’ve got to fire up gdb single, find where the code is for each phase, single trace through that code, and sort of reverse engineer and figure out what it wants you to type in. And then you’ll quickly find out where that function that explodes the bomb is, and you’ll put a breakpoint there. And so we want you to do that because the bomb besides teaching you how to program assembly language, it also teaches you sort of organically how to use Gdb, because you really can’t do it if you don’t run Gdb.<br>这有点有趣。这有点像电子游戏。它教您如何阅读编译器生成的代码，因为，哦，踢球者是，抱歉。关键是我们不给你源代码。我们给你的只是二进制，因此是二进制炸弹。所以，为了扩散炸弹，你必须启动gdb，找到每个阶段的代码在哪里，通过该代码进行单一跟踪，并进行逆向工程，找出它要你输入的内容。然后你很快就会发现那个引爆炸弹的功能在哪里，你会在那里设置一个断点。所以我们希望你这样做，因为这个炸弹除了教你如何编写汇编语言之外，它还教你如何有机地使用Gdb，因为如果你不运行Gdb，你真的无法做到这一点。</p><p>发言人   01:06:08<br>And then the third lab, this is a new lab this semester that Randy’s developed. It’s called the Attack Lab. And we developed this lab specifically for a sixty-fourth architecture. So this is a reflection of the change from 32 b to 64 b. And this is, we’re really excited about this one. You’ll learn, you’ll learn how to. Write exploits using. To a sort of a modern technique called return to return oriented programming, which is kind of the modern way that hackers deal with the fact that stacks in newer machines move around. Prohibitive and make it impossible to execute code on the stack. So this is a brand new lab. I think it’s really, really going to be neat.<br>然后是第三个实验室，这是兰迪在本学期开发的一个新实验室。它被称为攻击实验室。我们专门为64架构开发了这个实验室。所以这是从32 b到64 b的变化的反映。我们对此感到非常兴奋。你会学到，你会学会如何做。利用编写漏洞利用。一种被称为 “面向返回编程” 的现代技术，这是黑客处理新型机器中堆栈移动这一事实的一种现代方式。禁止，使代码无法在堆栈上执行。所以这是一个全新的实验室。我认为这真的会很整洁。</p><p>发言人   01:07:06<br>In the memory hierarchy, when we study the memory hierarchy, we have a lab called the Cache lab, where you’ll build your own cache simulator. So this is how you sort of learn how this hardware that Randy was mentioning called cache memory works. You’ll build a simulator and C for that, and then you’ll take a small transpose function, and you’ll try to make that code run with as few misses as possible on your simulator. And this will involve sort of understanding of how the memory hierarchy works and how to exploit it.<br>在内存层次结构中，当我们研究内存层次结构时，我们有一个名为缓存实验室的实验室，您将在其中构建自己的缓存模拟器。这就是你如何学习Randy提到的硬件高速缓存的工作原理。你将为此构建一个模拟器和C，然后你将使用一个小的转置函数，并尝试使该代码在模拟器上尽可能少的失误运行。这将涉及对记忆层次结构如何工作以及如何利用它的理解。</p><p>发言人   01:07:45<br>The part of the course where we sort of transition from hardware to interacting with the system software, the operating system, there’s sort of a concept that we call exceptional control Fo that exists in all parts of the system. And it sort of represents that intellectual transition from hardware to software. So this is how this was sort of a key idea that allowed us to kind of smoothly move from hardware to software in some intellectually consistent way. And so the idea that you cover an exceptional control floor, like low, hard, low level hardware interrupts and exceptions.<br>在课程中，我们从硬件过渡到与系统软件交互的部分，操作系统，有一种我们称之为特殊控制的概念，存在于系统的所有部分。它代表了从硬件到软件的智力转变。所以这就是一个关键的想法，它使我们能够以某种智力上一致的方式从硬件到软件顺利转移。因此，覆盖一个特殊的控制层，如低、硬、低级的硬件中断和异常。</p><p>发言人   01:08:30<br>And then at the higher level, sort of evolving hardware and operating system software is the idea of a process context switch. So this is where you start to learn what processes are and how to ask the kernel to create manage processes for you at the next higher level or a software form of exceptional control flow called a signal. So this exists solely in the Linux kernel and then, and then even at a higher level, there’s an application in C language version of exceptional control flow called set jump and long jump. So this notion of exceptional control flow kind of exists in all parts of the system. And we cover it all at once.<br>然后在更高层次上，不断发展的硬件和操作系统软件是流程上下文切换的想法。因此，这就是您开始学习什么是进程以及如何要求内核在下一个更高的级别或称为信号的异常控制流的软件形式中为您创建管理进程的地方。所以这只存在于Linux内核中，然后，甚至在更高的层面上，在c语言版本中有一个特殊控制流的应用程序，称为set jump和long jump。因此，这种异常控制流的概念存在于系统的所有部分。我们一次性覆盖了所有内容。</p><p>发言人   01:09:17<br>And the lab that we use to sort of exercise all these ideas called the shell lab. And in the shell lab, you’ll write your own Linux shell is really cool. So that’s the program, the command line program that you interact with Whenever you log into a Linux box, you’re going to write your own. And I know for me, that was really exciting when I could write something that looked like a real shell. It was pretty neat.<br>而我们用来锻炼所有这些想法的实验室被称为贝壳实验室。在shell实验室中，您将编写自己的Linux shell真的很酷。这就是程序，每当你登录到Linux系统时与之交互的命令行程序，你将编写自己的程序。我知道对我来说，当我可以写出看起来像真正贝壳的东西时，那真的很令人兴奋。这相当整洁。</p><p>发言人   01:09:49<br>The next area we’ll study is called virtual memory. Virtual memory is a sort of combination of hardware and software that presents an abstraction to you of this of memory as a very large array of bytes, when in reality, memory is a hierarchy of hardware of cache memories and Drams, Virtual memory provides a very high level abstraction as just a linear sequence of bytes. It also does provides a lot of other useful abstractions that make many different parts of the system much easier to manage. So we’ll learn about virtual memory, we’ll learn how it works, we’ll learn about the performance impact, potential performance impact that it has on your programs, and we’ll also learn how to manage that large pool of memory that it makes available to you and the lab that we do that the lab where you’ll do that is called Malloc Lab.<br>我们要研究的下一个领域叫做虚拟内存。虚拟内存是一种硬件和软件的组合，它向您呈现了一种非常大的字节数组的内存抽象，而实际上，内存是缓存内存和dRAM的硬件层次结构，虚拟内存提供了非常高级别的抽象，只是一个线性字节序列。它还提供了许多其他有用的抽象，使系统的许多不同部分更容易管理。所以我们将学习虚拟内存，我们将学习它是如何工作的，我们将学习它对性能的影响，它对你的程序的潜在性能影响，我们还将学习如何管理它提供给您的大量内存池，以及我们进行的实验室，您将进行这项工作的实验室称为Malloc lab。</p><p>发言人   01:10:52<br>And in the malloc lab, you’ll write your own malloc and free functions.<br>在malloc实验室中，您将编写自己的malloc和free函数。</p><p>发言人   01:10:58<br>So you’ll reimplement the functionality of the LII, Mali, and free, and this is a. Maybe it’s two pages of code, but will be a guarantee. It’ll be the most sophisticated, difficult two pages of code you’ve written, not only because since it’s managing the memory system, you can’t use all of, I mean, c doesn’t have many. C doesn’t help you out a lot with abstractions for data structures when you’re writing, but at least it does give you ideas like structs and unions that you can use to structure your memory. When you’re writing a Mali package, you can’t use any of those. You have to ride exclusively on pointers and casting because malloc package is working at such a low level. And so it’s a very difficult piece of code for that reason. But also the design space for Mali is enormous.<br>所以你将重新实现LII、Mali和free的功能，这是一个。可能只有两页代码，但这将是保证。这将是你写过的最复杂、最困难的两页代码，不仅因为它管理内存系统，你不能全部使用，我的意思是，c没有很多。当你编写数据结构时，C并不能帮助你完成很多抽象，但至少它可以为你提供像结构和联合这样的想法，让你可以用来构建你的记忆。当你编写一个Mali包时，你不能使用其中的任何一个。你必须专注于指针和强制转换，因为malloc包的工作水平如此之低。因此，由于这个原因，这是一段非常困难的代码。同时，马利的设计空间也是巨大的。</p><p>发言人   01:12:02<br>You have many options. They all have implications that trade off performance and memory efficiency.<br>你有很多选择。它们都具有权衡性能和内存效率的含义。</p><p>发言人   01:12:12<br>And finally, in the last part of the course. We deal with IO input output. So, so far in the course, we’ve just talked about sort of running programs on machines. In the last part of the course, we’ll talk about input and output, sending data into and out of the machine. So we’ll look at basic concepts of Linux IO. Well, and since I think the most interesting form of IO is networking, which allows you to talk to machines anywhere in the world using the internet, We’ll also talk, we’ll learn how to do network programming.<br>最后，在课程的最后一部分。我们处理IO输入输出。到目前为止，在课程中，我们刚刚讨论了在机器上运行程序的方式。在课程的最后一部分，我们将讨论输入和输出，将数据发送到和从机器发出。所以我们来看看Linux IO的基本概念。嗯，因为我认为最有趣的IO形式是网络，它允许你使用互联网与世界上任何地方的机器交谈，所以我们也会讨论，我们将学习如何进行网络编程。</p><p>发言人   01:12:51<br>You’ll learn how to write programs that use the sockets interface, which is the basic interface for the internet to talk to machines, potentially any machine in the world. And that’s really exciting. I can still remember when developing this course, I had two windows open on my machine. I was sshd into two different machines, and I wrote a program to send a message like hello world from one machine to the other. And when that hello world appeared on the second window, it was like so exciting. I mean, if you’re a nerd, it’s really exciting. But just the thought that that have been any machine, right? That could have been any machine, opens up a whole new world.<br>你将学习如何使用套接字接口编写程序，套接字接口是互联网与机器进行通信的基本接口，可能是世界上的任何机器。这真的很令人兴奋。我还记得在开发这门课程时，我的机器上有两个窗口打开。我被分成了两台不同的机器，并编写了一个程序来将类似于 “hello world” 的消息从一台机器发送到另一台机器。当那个你好世界出现在第二扇窗户上时，感觉太令人兴奋了。我的意思是，如果你是一个书呆子，这真的很令人兴奋。但只是想到那是任何机器，对吧？这可能是任何机器，打开了一个全新的世界。</p><p>发言人   01:13:45<br>All of our hand ins are using a system called Auto La, which was developed here. And you can access it if you are on the roster as of this morning, if you go to the Auto lab link and you’ll see this course listed on your page, if you’re not enrolled, you won’t have an Auto La account and you have to be enrolled to get an Auto La account if you want to try to wait it out and wait for people to drop. I’ll make the first couple of at least the first assignment available from the course web page so you can work on it without actually handing into auto lab, but at least you can keep going.<br>我们所有的人手都在使用一个叫做Auto La的系统，这是在这里开发的。如果您在今天早上的名单上，您可以访问它，如果您转到自动实验室链接，您将看到此课程列在您的页面上，如果您没有注册，您将没有自动登录帐户，如果您想尝试等待它并等待人们退出，则必须注册才能获得自动登录帐户。我会在课程网页上提供至少第一个作业的前几个，这样你就可以在不需要真正进入自动实验室的情况下完成作业，但至少你可以继续进行。</p><p>发言人   01:14:32<br>Okay, if you were enroll, actually, I didn’t update this, but I updated the auto La accounts today. Now, one final thing, if you have wait list questions, please don’t. Don’t send email to the staff because we don’t control the wait list. You should contact one of these, either Cathy, Catherine, or Zara, depending on which class you’re in. Okay, so that’s it. Welcome again. Looking forward to a great semester, and we’ll see you on Thursday.<br>好的，如果你注册了，实际上，我没有更新这个，但我今天更新了自动洛杉矶账户。现在，最后一件事，如果您有等候名单问题，请不要。不要给员工发送电子邮件，因为我们无法控制等待名单。你应该联系其中一个，要么是凯西，要么是凯瑟琳，要么是扎拉，这取决于你在哪个班级。好的，就这样。再次欢迎。期待一个美好的学期，我们将在星期四见到你。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>自学大纲</title>
    <link href="/2025/10/12/hello-world/"/>
    <url>/2025/10/12/hello-world/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="left">主题</th><th align="left">为什么学习？</th><th align="left">视频课程</th></tr></thead><tbody><tr><td align="left">编程</td><td align="left">快速学习一门编程语言，入门</td><td align="left">MIT 6.100L 计算机导论，以及如何使用 Python 编程: <a href="https://example.com/video1">视频</a></td></tr><tr><td align="left">计算机体系结构</td><td align="left">有助于你对计算机从“黑箱”操作转变为“白箱”理解，知其然也知其所以然。</td><td align="left">CMU 15-213 深入理解计算机系统: <a href="https://example.com/video2">视频</a></td></tr><tr><td align="left">算法与数据结构</td><td align="left">如果你不知道如何使用像栈、队列、树和图这样的普遍数据结构，你就无法解决具有挑战性的问题。</td><td align="left">Princeton Algorithms, 4th Edition: <a href="https://example.com/part1">Part 1</a>, <a href="https://example.com/part2">Part 2</a></td></tr><tr><td align="left">计算机科学数学</td><td align="left">学习数学将给你带来竞争优势。</td><td align="left">MIT 6.042J 计算机科学数学: <a href="https://example.com/video3">视频</a></td></tr><tr><td align="left">操作系统</td><td align="left">你编写的大多数代码都是由操作系统运行的，所以你应该知道它们是如何交互的。</td><td align="left">MIT 6.S081 操作系统工程: <a href="https://example.com/video4">视频</a></td></tr><tr><td align="left">计算机网络</td><td align="left">互联网是计算机系统伟大的发明。</td><td align="left">Stanford CS 144 计算机网络介绍: <a href="https://example.com/video5">视频</a></td></tr><tr><td align="left">数据库</td><td align="left">数据是大多数重要程序的核心，但很少有人真正理解数据库系统是如何工作的。</td><td align="left">CMU 15-445, CMU 15-721 数据库系统原理初级，高级: <a href="https://example.com/15-445">15-445</a>, <a href="https://example.com/15-721">15-721</a></td></tr><tr><td align="left">语言和编译器</td><td align="left">如果你理解语言和编译器的实际工作原理，你会写出更好的代码，并更容易学习新语言。</td><td align="left">Stanford CS143 编译器: <a href="https://example.com/video6">视频</a></td></tr><tr><td align="left">分布式系统</td><td align="left">如今，大多数系统都是分布式系统。</td><td align="left">MIT 6.824 分布式系统: <a href="https://example.com/video7">视频</a></td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
