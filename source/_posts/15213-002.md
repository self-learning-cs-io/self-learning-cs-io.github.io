---
title: 深入理解计算机系统 002-Bits,Bytes,andInteger
---

<embed src="/images/15213-002.pdf" type="application/pdf" width="100%" height="600px" />

发言人   00:00
I see a lot of people figured out to come early, so good for you. So as you recall, my name is Randy Bryant and I'm cosins tuctoria this course along with Jay o'hallor, and for the next couple lectures, the first part of this course, really, we'll be talking about sort of data representations, in particular, how numbers are represented in different forms in some of the properties. And you saw in that when I talked last week, I showed you things like you can multiply some numbers together that are positive and get negative results. So what we want to understand is what is a bit level representation of numbers and how does that affect some of the properties you have when you operate them on? And especially looking at the corner cases, when things overflow, don't do what you might expect them to do. So we'll start off with very basic stuff of how numbers are represented, especially integer valued numbers are represented in bits. 
我看到很多人想出早点来，对你有好处。正如你所记得的，我叫兰迪·布莱恩特，我是科斯金斯·图克托利亚，和杰伊·奥哈罗一起上这门课程，在接下来的几次讲座中，在这门课程的第一部分，我们将特别讨论数据表示。数字在某些属性中如何以不同的形式表示。你可以看到，当我上周谈话时，我向你展示了一些东西，比如你可以将一些积极的数字相乘，得到消极的结果。所以我们想要理解的是，数字的位级表示是什么，以及当你对它们进行操作时，它如何影响你拥有的一些属性？特别是在角落里，当事情溢出时，不要做你期望他们做的事情。所以我们将从如何表示数字的最基本的东西开始，特别是用比特表示整数值的数字。

<!-- more -->

发言人   01:06
So I think you've pretty well figured out in this world that the whole digital world is sort of based on binary values. And that wasn't always the case. I mean, since humans have 10 fingers and 10 toes, a lot of the world was based on the decimal system. And it was really only, and in fact, the first electronic computer, the ENIAC built in University of Pennsylvania, basically encoded, did all of its arithmetic using base 10. They had 10 vacuum tubes per digit they wanted to represent. So they basically turned on or off those tubes to represent which of the 10 possible digits you could want. And it really didn't come to people until later than that. So that's 1948, that they really should just think about base 2 for everything. 
所以我认为你在这个世界上已经很好地意识到，整个数字世界都是基于二进制值的。但情况并非一直如此。我的意思是，由于人类有10个手指和10个脚趾，世界上很多东西都是基于十进制系统的。实际上，它是第一台电子计算机，宾夕法尼亚大学制造的ENIAC，基本上是用10为基数进行编码和所有算术运算。他们想要表示的每个数字有10个真空管。所以他们基本上打开或关闭这些管来代表你想要的10个可能的数字中的哪一个。而且直到后来才真正降临到人们身上。所以那是1948年，他们真的应该只考虑以2为基数的一切。


发言人   02:04
And the reason why bits are great is in the digital world, you can sort of take what's otherwise an analog signal and quantify it and just say I'm going to say that one range of values, let's say it's a low voltage. I'm going to call that a 0. And the high range of values I'm going to call it a one. And if there's noise or imperfections in the circuit or anything going on, as long as that doesn't exceed these thresholds you've set up, then you'll get a nice clean signal out of it. And that's the main advantage of digital processing over analog processing. And so that's sort of at the core why everything we do, and especially for storing information, it turns out it's much easier to store 1 b of information or a digital value than it is to store an analog value. 
比特之所以伟大的原因在于数字世界，你可以取一个模拟信号并量化它，然后说我要说的是一个范围的值，假设它是一个低电压。我会称它为0。以及我将称之为 “一” 的高范围价值观。如果电路中存在噪音或缺陷或任何情况，只要不超过您设置的这些阈值，那么您将得到一个干净的信号。这就是数字处理与模拟处理相比的主要优势。这就是我们所做的一切的核心原因，尤其是对于存储信息，事实证明，存储1 b信息或数字值比存储模拟值要容易得多。



发言人   03:04
Sorry. Slides went a little crazy on animations. So the point is that we represent all the numbers in a computer as sets of bits. And I think you generally understand that fairly well. And so, of course, the familiar binary representation of integers, which we'll go over today, just uses a bit position for each power of two. 
对不起。幻灯片在动画方面有点疯狂。关键是我们将计算机中的所有数字表示为一组位。我想你一般都相当了解这一点。所以，当然，我们今天会介绍的整数的二进制表示形式，只是对每个2的幂使用一个位位置。

发言人   03:29
We can also represent values that are fractional. And we'll talk about that a week from today when we do floating point numbers, where what you do is to the right of the binary point is no longer a decimal point, it's a binary point. And so something to the left of that would have weight 1, 2 to the zero, and the next one over would have weight 2 to the one. But what you do is you go to the right that has weight to the -1, to the -2. In other words, one, this is 2, this is one half, and this is 1 4. So we can represent just like you do the decimal representation of fractions, we can do the binary representation of fractions. And that's the core of floating point number representations. 
我们也可以表示分数形式的值。我们将在今天进行浮点数的一周后讨论这个问题，那时你要做的是在二进制小数点的右边不再是小数点，而是一个二进制小数点。因此，左边的物体的权重为1，2为零，下一个物体的权重为2。但你要做的是你走到权重为-1和-2的右边。换句话说，1，这是2，这是一半，这是1 4。所以我们可以像小数一样表示小数，我们可以用二进制表示小数。这就是浮点数表示的核心。




发言人   04:25
And so it gets very annoying if you have, say, 32 or even 64 b numbers to be writing these strings of ones and zeros out. And so what we use and what's become largely the most common is to group collections of 4 b at a time. 
因此，如果你有32个甚至64个b的数字要写出这些1和0的字符串，就会变得非常烦人。因此，我们使用的最常见的方法是一次将4个b的集合分组。

发言人   04:46
And then represent that in base 16, or what's known as hexadecimal representation, using the letters A through F as values 10 through 15. And you'll spend a lot of time staring at hexadecimal numbers this year, and you'll get pretty good at being able to look at a hex number and just write it out in binary The way I do it, just to tell you is, I mean I've got the values from 0 to. Nine wired down pretty well. And then I keep track of a few special cases. One 0, 1, 0 is a 1, 0, 0 is C, and 1, 1, 1, 1 is f For b, d, and e, I kind of interpolate between those. So if you want to develop that skill, that's the way you can do it. 
然后用基数16表示，也就是所谓的十六进制表示，使用字母A到F作为值10到15。你今年会花很多时间盯着十六进制数字，你会变得相当不错，能够看到十六进制数字并像我一样以二进制形式写出，只是为了告诉你，我的意思是我得到了从0到的值。九个连接得很好。然后我会跟踪一些特殊情况。一个0，1，0是一个1，0，0是C，1，1，1是b，d和e的f，我有点在它们之间插值。所以，如果你想发展这项技能，这就是你可以做到的方式。


发言人   05:49
You're looking for something connector, an Hdmi to what? No, I don't think there's any connector here. 
你正在寻找连接器，Hdmi到什么？不，我不认为这里有任何连接器。

发言人   06:03
So that's something you're going to end up wanting to be able to do. So in C, we don't. 
所以这将是你最终想要能够做到的事情。所以在C中，我们没有。

发言人   06:13
In most declarations, you don't actually are told exactly how many bytes a byte is 8 b each data value is represented as, and that's partly C was designed actually back when microprocessors only had 16 b words. It was actually before microprocessors. So 16 b words were a fairway standard thing, and over time, that's expanded from 16 to 32 to now 64. And so C, rather than sort of in advance saying, here's how many bytes every value we'll have, has these slightly ambiguous terms that vary actually from one machine to the next. And if you're a very careful C programmer, you have to anticipate that sum. But what we'll deal with is X 8664 is the class of machines we'll be working with exclusively this term. 
在大多数声明中，您实际上不会被告知每个数据值表示为8 b的字节数，并且这部分是在微处理器只有16 b字的时候设计回来的。它实际上是在微处理器出现之前。因此，16个b单词是球道标准的东西，随着时间的推移，它从16个增加到32个，现在已经增加到64个。因此，C并不是事先说每个值有多少字节，而是有这些稍微含糊不清的术语，实际上它们因机器而异。如果你是一个非常谨慎的C程序员，你必须预见到这个总和。但是我们将要处理的是X 8664，它是我们将专门使用这个术语的机器类别。



发言人   07:10
And so you can see that when you declare something to be a char, sometimes people call that a char. That's a 1 B value. A short is 16 by bit, an int is 32. And if you want to get all 64 b, you have to declare it to be a long. 
所以你可以看到，当你声明某物是char时，有时人们称之为char。这是一个1 B的值。一个short是16位的，一个int是32。如果你想获得全部64 b，你必须声明它是长的。

发言人   07:32
And then again, there's two different precisions of floating point. There's 4 B or 32 b of floating point numbers and 64 b. There's also a slightly obscure holdover from ancient days of of floating point, where there's a special representation in Intel machines that uses a 10 B or 80 b representation. And when you use that on a. 64 b machine. They sort of waste an extra 6 B out of that so that everything is aligned in 16 B increments. 
然后，有两种不同精度的浮点运算。有4 B或32 b的浮点数和64 b的浮点数。还有一个与浮点数古代相比有些模糊的保持，在英特尔机器中有一个特殊的表示，它使用10 b或80 b的表示。当你在a上使用它时。64 b机器。他们有点浪费额外的6 B，这样所有的东西都以16 B的增量对齐。


发言人   08:09
The other thing, and this is an important feature, is any address is defined to be the word size of the machine when they say it's a 64 b machine, what they really mean is that the addresses are 64 b values or 8 B values. And that's different, For example, if you use an older machine, a 32 b machine, those will only be 32 b addresses. 
另一个重要的特性是，当他们说机器是64 b时，任何地址都被定义为机器的字数，他们真正的意思是地址是64 b值或8 b值。这是不同的，例如，如果您使用一台较旧的机器，一台32 b的机器，这些将只是32 b的地址。


发言人   08:37
So the basis then, imagine you've had this at some point of how do we then think about bits is based on Boolean algebra, which actually comes from the 1890s, that a guy named George Boe who recognized a sort of relation between what we'd call bits, but they weren't called bits back then. 
因此，想象一下，在某个时候我们如何思考位的基础是基于布尔代数的，它实际上来自18 90年代，一个名叫George Boe的人认识到我们所谓的位之间的一种关系，但它们当时不被称为位。


发言人   09:04
0, 1, and logic are basically truth values in logic. I'm thinking of an algebra, sort of a structured set of operations you could apply that would capture some of the concepts that people assume in logic. So for example, if we think of one being true and 0 being false, then the And operation is true if both of the inputs, both of the arguments are true. So we get this chart here. And similarly, the Or operation is true if either input is true or one, the nod is just to flip the bit, and then the exclusive, or is what you get when you say it's one or the other, but not both. And so it has this representation. 
0、1和逻辑基本上都是逻辑中的真值。我正在考虑一种代数，一种可以应用的结构化操作集，可以捕捉人们在逻辑中假设的一些概念。因此，例如，如果我们认为一个是真的，0是假的，那么如果两个输入，两个参数都是真的，那么和操作就是真的。所以我们在这里得到这张图表。类似地，如果输入为真或为一真，则或操作为真，点头只是翻转位，然后是互斥，或者是当你说它是一个或另一个时得到的，而不是两个。所以它有这种代表性。


发言人   09:53
So just as a bit of history, it was master's degree student at MIT named Claude Shannon who had taken a course in logic as an undergraduate at University of Michigan. And he was the one who made the connection between thinking about this, what was at the time very obscure branch of something or other of logic, and applying it to digital systems back in an era when they actually built these things out of electromechanical relays. And so his master's thesis is probably the most impactful master's thesis in the history of humankind. And you always wonder, well, what did they do before that? Then? How did they even think about these things anyways, the idea of applying this algebra then to bits is not something that's sort of been true since the world began. It's something that's a relatively modern concept. 
因此，作为历史的一部分，麻省理工学院的硕士研究生克劳德·香农在密歇根大学本科学习了逻辑学课程。他是那个将思考这个在当时非常模糊的逻辑分支和将其应用于数字系统之间联系起来的人，当时他们实际上是用机电继电器构建这些东西的时代。所以他的硕士论文可能是人类历史上最有影响力的硕士论文。你总是想知道，好吧，在那之前他们做了什么？那么呢？无论如何，他们是如何思考这些事情的，将代数应用于比特的想法并不是自世界开始以来就一直存在的事情。这是一个相对现代的概念。

发言人   10:59
Now, what's an important? Thing that might be less obvious is we can also do these over words. We can do these Boolean operations where we apply them on each successive bit in that word. And these symbols, we use, the ampersand vertical bar cart and tilde are actually the ones that C uses to represent these operations. And so again, if we look at here, the one is only if both of the values are one. And for the, for the n for the, or if either of them are one, the exclusive, or if 1 is one and the other is 0, and tilde is just to invert the bits of it. 
现在，什么是重要的？可能不太明显的是，我们也可以通过文字来实现这些。我们可以进行这些布尔操作，将它们应用于该单词中的每个连续位。我们所使用的这些符号、与符号垂直饮料服务车和代字符实际上是C用来表示这些操作的符号。因此，如果我们再看看这里，只有当两个值都是一个时，才会出现一个。对于n，对于n，或者如果其中一个是一个，则为互斥，或者如果1为1而另一个为0，则波浪号只是将其位反转。


发言人   11:45
Again, we will spend a lot of time making use of the fact that in C, and this is one of the features of C that people like, is that you can do these here at a very low level bit of manipulation directly in the language. And this actually turns out to be useful in practice. 
再说一遍，我们将花费大量时间利用这个事实，即在C语言中，这是人们喜欢的C语言的特点之一，你可以在这里直接在语言中以非常低级别的操作来实现这些功能。这在实践中实际上是有用的。


发言人   12:05
And it's sort of implicit of a way of representing sets of values. So this example is, imagine we want to represents sets where the elements of the set are numbers ranging between 0 and 7. So 1 B is enough to capture eight cases and will, if we number the bits and we number them from right to left, so this is bit 0. So that would represent whether or not the value 0 is an element of the set And simly here, you'll see 0, 1, 2, 3. So we're saying that bit 3 being one here means 3 is an element of the set, and so forth. So the idea. Is then the and operation becomes like set intersection, the Or operation becomes like set union, and the exclusive or operation is what's called symmetric difference. And so these are and tilde is like complement. 
它是一种隐含的表示值集合的方式。所以这个例子是，想象我们想要表示集合，其中集合的元素是范围在0到7之间的数字。因此，如果我们对比特进行编号并从右到左对它们进行编号，则1 B足以捕获8种情况，因此这就是第0位。因此，这将表示值0是否是集合的一个元素，简单地在这里，您将看到0，1，2，3。所以我们说这里的第3位表示1，意味着3是集合的一个元素，依此类推。所以这个想法。然后，和操作变得像集合交集，或操作变得像集合并集，而异或操作就是所谓的对称差。因此，这些是和波浪号就像补码一样。

发言人   13:15
So these are actually very common. For example, there's. 
这些其实很常见。例如，有。

发言人   13:24
Operations you'll learn later when we look at file IO about IO that you can track, I want to know which set of possible inputs to the system. Think of different network connections. Have an input ready for me to read, and there is a data structure that it's sort of hidden away among some seeing library calls. But it basically is using exactly this representation, about 1000 of bits worth of information to represent these sets and do manipulation on those sets. 
当我们查看可以跟踪的有关IO的文件IO时，您将会学习操作，我想知道系统有哪些可能的输入。考虑不同的网络连接。有一个输入准备好供我阅读，并且有一个数据结构，它有点隐藏在一些看到的库调用中。但它基本上就是使用这种表示形式，大约1000位的信息来表示这些集合，并对这些集合进行操作。

发言人   14:08
So as I mentioned, those are available directly in C, the ampersand vertical bar tilde and cart. 
正如我所提到的，这些可以直接在C中使用，即 & 竖线波浪号和购物车。


发言人   14:17
One thing that's really, really important and that programmers screw it up all the time, beginning programmers and even experienced programmers from time to time, is to mix up single ampersand and the double ampersand, or the single vertical bar and the double vertical bar and the tilde versus the exclamation mark, which is often pronounced, bang. And the reason so. Obviously, there's sort of a. Syntactic similarity. And there's actually a somewhat of a semantic relation too. This is another kind of and another kind of Or, and another kind of not. Mix and match these. You're certainly going to have problems. 
有一件非常重要的事情，即程序员，新手程序员甚至有经验的程序员，不时搞砸它，就是混淆单个和双符号，或者单个竖条和双竖条以及波浪号和感叹号。这通常被发音为bang。这就是原因。显然，有一种。句法相似性。实际上还有一种语义关系。这是另一种类型的或者，另一种类型的不是。混合搭配这些。你肯定会遇到问题。


发言人   15:03
So the double bar ones aren't thinking about bitwise operations. They're thinking about something that's either true or false, period. And in that representation, the number 0 is the thing that's false and anything else, any other bit pattern is considered to be true. And so the other feature that the double operations give you is what's called early termination. 
所以双线的人没有考虑按位操作。他们正在考虑一些不是对就是错的事情，时期。在这种表示中，数字0是假的，其他任何比特模式都被认为是真的。因此，双重操作给你的另一个功能是所谓的提前终止。


发言人   15:33
So in particular, if we do some examples on some hex pattern for one. So this is a. Not a 0. And so that's considered true in this interpretation. The bang of that, the knot of that is 0. In same way, if you have 0, the knot of that is one. And if you apply bang to a number twice, you'll get back a one, unless it was 0. And then similarly, these patterns here are the reason why this returns one is because it's considered two cases that are true. 
所以特别是，如果我们在一些十六进制模式上做一些例子。所以这是a。不是0。因此，在这种解释中，这被认为是正确的。那砰的一声，那的结是0。同样地，如果你有0，那么它的结就是1。如果你对一个数字应用两次，你会得到一个1，除非它是0。然后同样，这些模式在这里是返回一个的原因，因为它被认为是两种真实的情况。

发言人   16:20
So it's not doing bitwise operations. It's just trying to create true and false. It's interpreting arguments to be either true or false and returning either true or false. But when it returns true, it returns one and not whatever number you happen to give it. 
所以它不进行按位操作。它只是试图创造真实和虚假。它将参数解释为真或假，并返回真或假。但当它返回true时，它会返回一个，而不是你给它的任何数字。

发言人   16:36
So obviously, this is a very different operations than you have with the single versions of those. But it's easy just because you mentally slip or because you type something wrong to do the wrong thing. But in particular, this early termination is something that, of course, people use a lot. 
显然，这是一个与单个版本的操作非常不同的操作。但这很容易，只是因为你精神上的失误，或者因为你输入了错误的东西而做错事。但特别的是，这种提前终止当然是人们经常使用的东西。

发言人   16:57
If you want to make sure that you're not accessing a null pointer, you can test whether that's a null pointer first before accessing it. And if this is zero or a null, then it won't do the dereferencing of null. So it's a fairly useful feature as well. Anyways, that's an aside. At this level, we're mostly looking at bits, but just as a programming note, don't mix these up. 
如果你想确保你没有访问空指针，你可以在访问它之前先测试它是否为空指针。如果这是零或null，则它不会取消null的引用。所以这也是一个相当有用的功能。不管怎样，这是旁白。在这个层面上，我们主要看的是比特，但只是作为编程说明，不要混淆这些。


发言人   17:34
The other class of operations will make use of a lot are shifting, which again, is not something that you normally sort of as beginning programmers think about too much. And there's a curious feature that left shifts are always the same, but there's two different flavors of right shift. And we'll see in a little bit later why there's two different flavors of right-shift but. 
另一类操作将会利用很多东西正在转移，这不是你通常作为新手程序员考虑得太多的事情。而且有一个奇怪的特征，即左移总是相同的，但右移有两种不同的风格。稍后我们会看到为什么有两种不同风格的右移位。


发言人   17:58
The idea then of shifting is that you have some argument x, and you want to shift it some number of positions either to the left or to the right, given by y, and so when you shift left, you just fill in whatever value there was. So you pick up the I'm shifting by three. So I'll take the lower order, 5 b, move them over three positions, and then fill in with a 0 and whatever was in the upper positions of that original, where they just sort of disappear into the into nowhere. Similarly, if I do a right shift, I take the upper 6 b, I move them over two positions, and I fill in with zeros. So that's a logical shift and that's it's logical. 
移位的想法是，你有一些参数x，你想要将它向左或向右移动一些位置，由y给出，所以当你向左移动时，你只需填写任何值。所以你拿起我正在移动三个。所以我会选择较低的顺序，5 b，将它们移动到三个位置，然后填充0和原始位置较高的任何东西，在那里它们就会消失在无处。同样地，如果我右移，我取上部的6 b，将它们移动到两个位置上，然后用零填充。这是一个合乎逻辑的转变，这就是合乎逻辑的。

发言人   18:46
There's another flavor called the arithmetic shift, which differs in the rule for what bits you fill in with are not based on, are not zeros necessarily, but whatever the most significant bit was in the original value. So it doesn't matter here because the most significant bit was 0, but you'll see in the case here of where the leading bit was a one, that when I shift it to the right arithmetically I'll fill it in with once. And that'll make sense more when we understand how negative numbers get represented in a machine. And that's the purpose of it and why it's called arithmetic. The other thing that is kind of confusing to people is what should happen if you say, I want to shift an 8 b number, 8 positions to the left? 
还有另一种叫做算术移位的方法，它的不同之处在于您填充的位不是基于的规则，也不一定是零，而是原始值中最重要的位。所以在这里并不重要，因为最高有效位是0，但你会看到在这里的前导位是1的情况下，当我将其算术向右移动时，我将用一次填充它。当我们理解负数在机器中的表示方式时，这将使感知更加重要。这就是它的目的，也是它被称为算术的原因。另一件让人们有点困惑的事情是，如果你说我想把一个8 b的数字向左移动8个位置，应该会发生什么？

发言人   19:55
And x is a single byte. What do you think you should get? Zero, that would be a pretty logical thing. 
x是一个单字节。你认为你应该得到什么？零，这将是一件相当合乎逻辑的事情。

发言人   20:06
You kind of shift all those bits out, you fill them with zeros. On most machines, you'll get whatever x was. Because what it will do is it will compute this number mod a. And the reason that happens is, if you think about it, it's looking at just the low order 3 b of the shift amount and ignoring all the rest. So that's effectively like module 8. So that's just a warning. And on some machines, it does what you just thought it should, and other machines it does this. And so there's no guarantee in C that it will be one way or the other. 
你把所有这些位都移动出来，用零填充它们。在大多数机器上，你会得到x是什么。因为它将会计算这个数字mod a。发生这种情况的原因是，如果你仔细想想，它只看移位量的低阶3 b，而忽略了所有其余的部分。所以这实际上就像模块8一样。所以这只是一个警告。在某些机器上，它会做你刚才认为它应该做的事情，而在其他机器上，它会这样做。因此，在C中并不能保证它会是一种方式还是另一种方式。

发言人   20:54
Same with if you try to shift left by a negative number, that might be logically, well, I guess you really want to shift right then, but that usually doesn't work either. So now let's talk about number representations. This is sort of a very core idea that you have to really have wired in you. And I'm going to illustrate it with some examples. 
同样，如果你试图向左移动一个负数，这可能是逻辑上的，好吧，我猜你真的想向右移动，但这通常也不起作用。现在让我们来谈谈数字表示。这是一个非常核心的想法，你必须真正与之相连。我会用一些例子来说明。


发言人   21:29
So these two equations, then, are everything that we'll talk about sort of stems from them. So one is if you have an unsigned number, then basically. So he keeps jumping on me. 
那么这两个方程式，就是我们将要谈论的一切都源于它们。所以一个是，如果你有一个无符号的数字，那么基本上。所以他一直跳到我身上。

发言人   21:48
If you have an unsigned number, then this is just the conversion. Then Btu means from bit, a bit level representation to an unsigned number of some bit pattern. It just says, well, just add up the sum of the weighted bits where each bit is weighted by a power of two. And the only difference when we look at two's complement, which is a way to represent both negative and positive numbers, we'll consider the most significant bit to be what's called the sine bit. So it will have a negative value. So let me just illustrate this with I'll use some running examples, and we'll just use 5 b numbers just as a way it really helps often if you're trying to understand this stuff, to do it for some smaller cases. So if we think about bit positions. 
如果您有一个无符号数字，那么这只是转换。然后Btu意味着从位，一个位级表示到某个位模式的无符号数字。它只是说，好吧，只需将加权位的总和相加，其中每个位加权2的幂。当我们看2的补码时唯一的区别是，这是一种表示负数和正数的方式，我们会认为最重要的位是所谓的正弦位。因此它将具有负值。所以让我用一些运行的例子来说明这一点，我们只使用5 B数字，如果你试图理解这些东西，对于一些较小的情况来说，它经常会有所帮助。所以，如果我们考虑位的位置。



发言人   22:50
Zero through 4. 
从零到四。

发言人   23:00
Then those represent different powers of two weights, as I've shown. And so now if we take some bit pattern. 
那么这些代表两个权重的不同幂，正如我所展示的那样。所以现在如果我们采取一些模式。

发言人   23:20
Like so. So that's what I'll call x, and I want to convert that to an unsigned number. I will just combine 8 plus 4 plus 1, and I'll get 13. So that's all that equation says, the left hand equation. Bit positions that are ones use the corresponding power of 2, and you're done. And similarly, if I have a number where there's a leading bit. 
就像这样。所以这就是我称之为x的东西，我想将它转换为无符号数字。我只需要把8加4加1结合起来，就能得到13。这就是这个方程所说的一切，左手方程。位位置使用相应的2的幂，你就完成了。类似地，如果我有一个数字，其中有一个前导位。

发言人   24:03
It will be 16 plus 4 plus 2, so that will be 22. And so that's the unsigned case. 
它将是16加4加2，因此将是22。这就是未签署的案例。

发言人   24:16
And the sine case is the same idea, except that most significant bit. Has a negative value? So this is I. And our weights will be 1, 2, 4, 8. But this will now be -60. So that's what the equation on the right is saying. But this bit, now we're going to change it from being a negative number to a positive. So obviously, if I have, this is my bit pattern, it's going to be the same because the other bit stay the same. So let's do it for this case of 1 0 1 1, 0. So that will be -16 plus 4 plus 2. So that will equal -10. So you see in this case, we have the same bit pattern. 
和正弦情况是相同的想法，除了最高有效位。有负值吗？这就是我。我们的权重将是1、2、4、8。但现在这将是-60。这就是右边的方程式所说的。但是这个位，现在我们要将它从一个负数改为正数。所以很明显，如果我有，这是我的位模式，它将是相同的，因为其他位保持不变。所以让我们为这个1 0 1，0的情况做这件事。这将是-16加4加2。这将等于-10。所以你可以看到，在这种情况下，我们有相同的位模式。

发言人   25:20
It's just if we interpret it how we think about what number this represents, then in one case, it's a positive number, 22, and in another case, it's a negative number -10. And that's what these equations are saying. 
这只是如果我们如何解释它，我们认为这代表什么数字，那么在一种情况下，它是一个正数22，在另一种情况下，它是一个负数-10。这就是这些方程式所说的。

发言人   25:42
And so the most significant bit is sometimes called the sine bit, because if it's a 1, the number is going to be negative. So? Let's sort of think about. What are the sort of extreme ranges of numbers we can get with these two different representations? 
因此，最重要的位有时被称为正弦位，因为如果它是1，则数字将是负数。所以呢？让我们思考一下。使用这两种不同的表示方式，我们可以得到什么样的数字极端范围？


发言人   26:14
So obviously, if these are all zeros, my number is going to equal 0. And if it's all one? 
所以显然，如果这些都是零，我的数字将等于0。如果都是一个呢？

发言人   26:28
It will be 16 plus 8 plus 4 plus 2 plus 1 will be 31. And over here, for the two's complement, the smallest number, well, the largest number, well, actually the let. Me do it this way. Actually, the most negative number, so the smallest number in the strictest sense of the word, is this. It's -16. And you can argue this, by the way, is the that has a negative weight, all the other ones have positive one. So certainly one, all the rest being zeros is going to be the smallest number. And similarly, the largest number you can represent. 
它将是16加8加4加2加1将是31。在这里，对于两个补码，最小的数字，最大的数字，实际上是let。我是这样做的。实际上，最负的数字，也就是这个词最严格感知中最小的数字。这是-16。你可以争辩说，顺便说一下，是负权重的，其他所有的都有正权重。所以可以肯定的是，所有其余的都是零，将是最小的数字。同样，您可以代表的最大数字。

发言人   27:22
Will be 8 plus 4 plus 2 plus 1, which is 15. And so we call this number u max. And we call this number T max. And we call this number t min. 
将是8加4加2加1，即15。所以我们称这个数字为u max。我们称这个数字为T max。我们称这个数字为t min。

发言人   27:50
So there's a few things to observe about these numbers. Remember, this is a 5 b word size. So you'll see that 31 is pretty close to 32. In fact, it's 2 to the 5th -1. And in general, and that's for a 5 b word size. So you would say in general, it will have value 2 to the w, if I have a w bit number -1. And that's what this shows. And similarly, over here, this is -2 to the fourth. And so we'd say in general, that will be -2 to the w, if it's a w number -1. All these make sense. 
关于这些数字，有几点需要观察。记住，这是一个5 b的单词大小。所以你会看到31非常接近32。实际上，它是2的5th -1。一般来说，这适用于5 b的单词大小。所以你会说，一般来说，如果我有一个w位数字-1，它的w值将为2。这就是它所展示的。同样地，在这里，这是-2到第四个。因此，我们通常会说，如果是w编号-1，那么w的值将是-2。所有这些都使感知。

发言人   28:53
By the way, You'll notice one other feature is. A whole string of one like this. If you sum up those digits, 8 plus 4 plus 2 plus 1 will be one less than the next bit position up. And you can think about that if to count this, if you were to increment this number by one, you'd get 1, 1 is 0, carry one, and so forth. And you'd carry that value up to this position. So there's various ways you can think about that. And then similarly, this number is 2 to the 4th -1, and so that's equal to 2 to the w -1 -1. 
顺便说一句，你会注意到另一个特点是。像这样的一串。如果你把这些数字加起来，8加4加2加1将比下一个位位置少一。你可以考虑一下，如果要计算这个数字，如果你将这个数字增加一，你会得到1，1是0，携带一，等等。你会把这个价值带到这个位置。所以你可以有各种各样的方法来考虑这个问题。然后同样地，这个数字是2的第四个1，因此等于2的w-1-1。

发言人   29:49
As is shown here so. There's a lot of the book goes through formulas and does derivations. But if you just think about it in these smaller scale ways, the intuition is pretty easy to get and don't get lost in formulas when really at the gut level, it's a fairly straightforward set of ideas. Or if you ever see some equations and you're confused, try out some small examples and see what they're saying. 
如这里所示。这本书有很多内容都经过公式和推导。但是如果你只是以这些较小规模的方式思考，直觉很容易得到，不要迷失在公式中，当真正在直觉层面上时，这是一组相当直接的想法。或者如果你看到一些方程式而感到困惑，尝试一些小例子，看看它们在说什么。

发言人   30:24
Another interesting number in the world of two's complement is what happens when you have all ones in your bit pattern. And that will have -16 plus 8, plus 4 plus 2 plus 1. And that will equal -1. The bit pattern, all one is always a -1. In this representation, I should mention two S complement is not the only way to represent positive and negative numbers, what's sometimes called S numbers. But it's so universal that you'll hardly ever encounter another case. So if you understand who's compliment, you have a pretty good understanding of what really is going on. 
在两个补码的世界中，另一个有趣的数字是当你的位模式中有所有一个时会发生什么。那将有-16加8，加4加2加1。这将等于-1。位模式，所有一个总是-1。在这种表示中，我应该提到两个补码并不是表示正数和负数的唯一方法，有时也被称为S数。但它是如此普遍，以至于你几乎不会遇到其他案例。所以，如果你理解了谁的赞美，你就对真正发生的事情有了很好的理解。

发言人   31:23
So these numbers I call, max the biggest unsigned number, t min, the smallest, most negative two's comple and TX the largest, most positive two's complement. This chart shows the range of values for different word sizes or different numbers of bytes. 
所以我称之为这些数字，max是最大的无符号数，t min是最小的、最负的2的comple，TX是最大的、最正的2的comple。此图表显示不同单词大小或不同字节数的值范围。


发言人   31:45
And so you'll see that with an 8 b number, you only have 256 possibilities and. So we can either choose to. Think of those as presenting the range from 0 to 255, or basically with two complement numbers, we just doing sort of a wraparound. We're saying, well, we're going to have half of them be negative, and the other half will be either zero or positive. And so that's a pretty limited range of values, of course. And then 16. And believe me, back when computers had 16 b word sizes, it was a nuisance to keep your numbers within that range. And 32 gives you a pretty decent range. 
所以你会看到，对于一个8 b数字，你只有256个可能性。所以我们可以选择。把它们想象成表示从0到255的范围，或者基本上用两个补码数，我们只是做了一个环绕。我们说，嗯，我们将会有一半是负数，另一半要么是零，要么是正数。因此，这当然是一个相当有限的数值范围。然后是16。相信我，当计算机有16个b的单词大小时，把你的数字保持在那个范围内是一件麻烦事。而32为您提供了一个相当不错的范围。

发言人   32:34
It used to be said Microsoft had to go to 64 b word size to represent Bill Gates's net worth. For me at least, this would easily handle my range of normal day to day transactions. But now, with 64 b, at least to us nowadays, those seem like really big numbers, hard to imagine exceeding the bounds of those. So one interesting feature that you noticed here was I was. Like this case here. 
过去人们常说，微软必须使用64 b的字数大小来代表比尔盖茨的净资产。至少对我来说，这将很容易处理我的正常日常交易范围。但是现在，有了64个b，至少对我们现在来说，这些数字看起来真的很大，很难想象会超越它们的界限。所以你在这里注意到的一个有趣的特征是我是。就像这个案例。


发言人   33:27
In this case here. You ready? 
在这种情况下。准备好了吗？

发言人   33:38
And then this case here of all ones. I was comparing it to this case here of all ones. So in other words, in both these cases, it's a little hard to jump boards here. 
然后是这里的所有一种情况。我把它和这里的所有案例进行比较。换句话说，在这两种情况下，在这里跳板都有点困难。

发言人   33:58
You're seeing that you have the same bit pattern in either case, but they represent different numeric values because one is a twos complement case and the other is an unsigned. And you can actually see the relation between them is pretty simple because basically what we're doing is we jumping between a plus 16 and a -16 between those. And so you'd expect it to change by 32. And you see that here, that this is 31 here, and -1, this is 22 and -10. So they're different from each other by plus or -32, 2 to the 5th two to the word size. And so there's sort of a long derivation in the book things here. But that connection is actually fairly important because when you jump back and forth between unsigned numbers and two complement numbers in C, that's the jump that you get, in other words. 
你会看到在任何一种情况下你都有相同的位模式，但它们代表不同的数值，因为一个是二进制补码的情况，另一个是无符号的。你实际上可以看到它们之间的关系非常简单，因为基本上我们所做的就是在这些之间跳跃在 + 16和-16之间。所以你预计它会改变32。你可以看到，这里是31，-1，这是22和-10。因此，它们彼此之间的差异是加或-32，2到单词大小的第五个二。因此，这里的书籍中有一些冗长的推导。但这种联系实际上相当重要，因为当你在C中的无符号数和两个补码数之间来回跳转时，换句话说，这就是你得到的跳跃。


发言人   35:14
You'll often find cases where what used to be a very large number, because it was unsigned, all of a sudden becomes a negative number because it's considered two's complement. So that's what this next part covers. 
你经常会发现这样的情况: 曾经是一个非常大的数，因为它是无符号的，突然变成了一个负数，因为它被认为是2的补码。这就是下一部分的内容。

发言人   35:28
We'll say that. If we take a chart of 4 b numbers and we write out all the possible values as unsigned or as choose these complement numbers, then the ones where the higher order bit is 0 will be the same. In both cases, the ones where the higher order bit is a one in this case will differ by 16 2 to the fourth. And similarly, you'll notice that these numbers, there's a unique, it goes unique in both directions. For any given bit pattern, there's a unique number it represents, and similarly, for any number within the given range, there's a unique bit pattern. 
我们会这么说。如果我们采用4 b数字的图表，并将所有可能的值写出为无符号或选择这些补数，那么高阶位为0的那些将是相同的。在这两种情况下，高阶位是1的情况将相差16 2比4。同样地，你会注意到这些数字，它们是独一无二的，在两个方向上都独一无二。对于任何给定的位模式，它都有一个唯一的数字，同样，对于给定范围内的任何数字，都有一个唯一的位模式。

发言人   36:19
So we can sort of jump between those two and say I can make up a rule for converting between a two's complement number x and an unsigned number uux that basically says I'll use the same bits. I'll just think of them as being different numbers. And so, and you can go either way. So for example, if we thought of this as a. A two's complement representative representation, It's -1. This function I'm calling t to u goes from that number -1 to this number 31, where in between the two I'm saying they both have the same bit pattern. 
所以我们可以在这两者之间跳转，并说我可以制定一个规则，用于在两个补码x和无符号数uux之间进行转换，基本上说我将使用相同的位。我会把它们看作是不同的数字。所以，你可以走任何一条路。因此，例如，如果我们认为这是一个。一个2的互补代表表示，它是-1。这个我调用t到u的函数从那个数字-1到这个数字31，在这两者之间，我说它们都有相同的位模式。


发言人   37:19
And the reason why this rather function that would otherwise seem to have no particular use is important is because that's basically what happens in C, or actually in the program on the. 
这个函数似乎没有特别的用处，重要的原因是因为这基本上就是在C中发生的事情，或者实际上在程序中发生的事情。

发言人   37:33
Computer itself has no clue whether a given bit pattern, if it's something you're thinking of as being a unsigned number or two's complement number, it just a bunch of bits to it. And similarly, so we can go back and forth between chooses, comple unsigned, keeping the bit patterns the same. And so I'll call that t to u when I go from sine to unsigned twos, complement to unsigned and similar. I'll call it u to t if I go from unsigned to signed. 
计算机本身不知道给定的位模式是什么，如果它是你认为的无符号数还是2的补数，它只是一堆位。类似地，我们可以在选择之间来回切换，保持位模式相同。因此，当我从正弦到无符号二时，我会将t称为u，从补充到无符号和类似。如果我从无符号转到有符号，我会称它为u到t。

发言人   38:09
And as I mentioned, the difference for the numbers where the high order bit is a one will be by a factor 2 to the w, where w is the word size of the word. And so this can be thought of as a function. Where? 
正如我所提到的，高位为1的数字之间的差异将是w的2倍，其中w是单词的单词大小。因此，这可以被看作是一个函数。在哪里？

发言人   38:37
Let me just dry it out. 
让我把它擦干。

发言人   38:49
Over here with my 5 b numbers. This is? Two's complement again. So that was the number -16. And then there'll be some other negative numbers up to all ones. It the number negative one, and then I'll have 0. And so forth, and then all up to. Going to run out of room? Plus 15, right? Just I. Got myself in trouble. Blackboard management is they didn't teach me this school. So I'm going to. Use two boards at once here. 
这里有我的5个b数字。这是什么？二是再次补充。这就是数字-16。然后会有一些其他负数，直到所有的一。如果数字是负一，那么我就得到0。以此类推，然后一切都由上而下。要跑出房间吗？加上15，对吧？只是我。让自己陷入了麻烦。黑板管理是他们没有在这所学校教我的。所以我要去。在这里同时使用两个板子。


发言人   40:05
Okay? What are you setting this up? 
好吗？你是怎么安排的？

发言人   40:15
Okay, we'll make it work. So now when we go from the Ttu function, then these numbers are going to just carry over, will get 0 up through 15. But now this number here will become positive 16. 
好的，我们会让它起作用的。所以现在当我们从Ttu函数开始时，这些数字将只是延续，将从0上升到15。但现在这个数字将变成正数16。

发言人   40:44
And all ones. Will become positive 31. And so that's what this picture is showing. Is it for the pink numbers are the ones that flip between negative and actually the largest of the positive numbers. And then the green numbers are the ones that stay the same because they're leading bits are zeros. 
所有的。将成为阳性31。这就是这张照片所展示的。粉色数字是在负数和实际最大的正数之间翻转的数字。绿色数字是保持不变的数字，因为它们的前导位是零。

发言人   41:17
So why does this matter? You never thought if you programmed in Python, say, or even Java, you don't see that. And the reason is because C is one of the few languages where unsigned is actually an explicit data type. And so you can declare a value being unsigned. If you just say unsigned, what you're really saying is unsigned int, or you can call something an unsigned care, an unsigned short, or an unsigned long. And you're declaring in C that it should think about using this representation we show on the right when it's working on those numbers. So that's sort of one thing. 
这有什么关系呢？你从来没有想过，如果你用Python编程，比如说，甚至是Java，你都看不到这一点。原因是因为C是少数几种实际上无符号是显式数据类型的语言之一。所以你可以声明一个无符号的值。如果你只是说unsigned，你真正说的是unsigned int，或者你可以称之为unsigned care、unsigned short或unsigned long。你在C中声明，在处理这些数字时，它应该考虑使用我们在右侧显示的这种表示。所以这是一件事。

发言人   42:07
It's one thing if you declare a number and use it that way. But what gets people and often got you is if you declare something, if you have, in this case, something that's declared as a tooth complement number x TX and you assign it a value u at y x, it'll do an implicit casting, which is exactly based on this conversion that we've been talking about, and vice versa. 
如果你声明一个数字并以这种方式使用它，那就是一回事。但是让人们经常得到的是，如果你声明了一些东西，在这种情况下，如果你有一些被声明为牙齿补码x TX的东西，并且你在y x处为它分配一个值u，它将进行隐式转换，这正是基于我们一直在谈论的这种转换，反之亦然。

发言人   42:40
This example, this goes through some examples that if I look at two numbers and I compare them, or actually I do any operation on them, I add them, divide them, anything implicitly, it will try to make these two be of the same type. And the way it will do that is to say, if both of them are ased, then I'll treat them as assigned. Case if either of them is unsigned, then I'll convert the other one to be an unsigned number and do the operation. And so in particular, this set of examples is imagine I'm comparing these. 
在这个例子中，经过一些例子，如果我看两个数字并比较它们，或者实际上我对它们进行任何操作，我将它们相加，相除，任何隐式的东西，它都会尝试使这两个是相同类型。这样做的方式就是说，如果他们两个都被杀了，那么我会把他们视为指定的。如果其中一个是无符号的，那么我会将另一个转换为无符号数字并进行操作。特别地，想象一下我正在比较这些例子。


发言人   43:20
I'm saying these numbers are either equal, less or greater. What will the outcomes be? And the key to answering that question is to, first of all, figure out OK, is it assigned or an unsigned comparison? Should I convert one of these numbers to an either of these numbers to an unsigned form before I do it? And the rule is, if either argument is unsigned, then you've got to do it. 
我是说这些数字要么相等，要么更少，要么更大。结果会是什么？回答这个问题的关键是，首先要弄清楚它是分配的还是无符号的比较？在我这样做之前，我应该将这些数字中的一个转换为这些数字中的任何一个转换为无符号形式吗？规则是，如果其中一个参数是无符号的，那么你必须这样做。

发言人   43:47
And as you see, when you put a u at the end, either a lowercase u or an uppercase u at the end of a numeric constant, you're saying this is an unsigned value. So for example, if we compare 0 and 0 unsigned, they're equal. And if we combine negative one, compare negative one to 0, we'll get that the first one is less because negative one is less than 0. But what would happen with the next one when we compare negative one to an unsigned zero? Greater, right? So this is the surprise. And it has to do with. 
正如你所看到的，当你把一个u放在数字常量的末尾，无论是小写的u还是大写的u，你就是在说这是一个无符号的值。例如，如果我们比较0和0无符号，它们是相等的。如果我们将负一个结合起来，将负一个与0进行比较，我们会得到第一个较小，因为负一个小于0。但是当我们将负1与无符号0进行比较时，下一个会发生什么？更大吧？这就是惊喜。这与。


发言人   44:41
A number that I erased. But we can still get it. Remember, this is negative one. But when I cast that to an unsigned number I'm flipping this from -60 into positive 16 and turning this into 31. I'm turning it into actually the largest number I can represent. And so it will be greater than 0. So it's a little bit weird to think about. I took an unsigned zero, which after all, is just 0, and compared it to negative one. And it said, oh, you really meant 31, didn't you? Or whatever word size we're using. And so it said it's greater. And basically the rest of these you can answer in a similar way. 
一个被我擦掉的数字。但我们仍然可以得到它。请记住，这是负面的。但是当我将其转换为一个无符号数字时，我将其从-60翻转为正16并将其转换为31。我正在把它变成我能代表的最大数字。因此它将大于0。所以思考起来有点奇怪。我取了一个无符号的零，毕竟它只是0，并将其与负1进行比较。它说，哦，你真的是说31，不是吗？或者我们使用的任何单词大小。所以它说它更大。基本上，其余的你可以用类似的方式回答。


发言人   45:36
These two numbers are, this is query one smaller than this? No I'm sorry, this is a negative number. I compare those and the positive will be greater than the negative. I'll tell you in a minute why this number is written this way. The next one, it's the same pair of numbers, but you see it's flipped and the reason is. That this number on the left is T max for? 
这两个数字是，这个查询比这个小吗？不，对不起，这是一个负数。我比较它们，正面的会大于负面的。我马上告诉你为什么这个数字是这样写的。下一个，它是一对相同的数字，但你看到它被翻转了，原因是。左边的这个数字是T max吗？

发言人   46:22
So it's the bit pattern in a 32 b number. 
所以它是32 b数字中的位模式。

发言人   46:53
And to this day I've not memorized this number, by the way. But, and then this number is actually t min. 
顺便说一下，直到今天我还没有记住这个数字。但是，然后这个数字实际上是t min。

发言人   47:18
And that when I subtract, you can think of it as this is negative t max -1. So that's t min. So if I do an unsigned comparison between those two, now think of those, this weighting bit not being a negative weight, but a positive weight. You'll see that this is a bigger number than this one. 
当我减去时，你可以把它看作是负的t max -1。所以这就是t min。所以，如果我在这两者之间进行无符号比较，现在想想这些，这个加权位不是负权重，而是正权重。你会发现这个数字比这个更大。



发言人   47:44
And so it goes. That -1 is greater than -2 if they're unsigned, because -1 is, you can think of it as converts into u max. It'll be the biggest number possible. And -2 will. Would be 1 1 1, 1, 0. 
就这样下去了。如果它们无符号，则-1大于-2，因为-1是，您可以将其视为转换为u max。这将是最大的数字。和-2将。将是1 1，1，0。

发言人   48:20
So that can get fairly confusing. One final quirk this way of writing this number is there's a little side in the book about it. If you write the number as you'd expect to as minus blah, blah, blah, 6 and 48. It will actually get the C compiler gets kind of confused by that for obscure reasons. One other thing I should point out that it's a property that I don't think we cover well enough here. Well, let me see. 
这可能会变得相当混乱。这样写这个数字的最后一个怪癖是，书中有一个关于它的小方面。如果你按照你期望的那样写下数字-等等，等等，6和48。它实际上会让C编译器因为一些模糊的原因而感到困惑。还有一件事我应该指出，这是一项我认为我们在这里没有充分涵盖的财产。好的，让我看看。



发言人   49:05
There's a few things that the slides don't really cover here, and I don't know why not, I like to point out. 
这里的幻灯片没有真正涵盖一些事情，我不知道为什么不，我想指出。

发言人   49:17
So they're kind of useful properties to keep track of. 
所以它们是跟踪的有用属性。

发言人   49:29
Is that you notice that if you look at the absolute value of T max? And you compare it to the absolute value of t min. That it's off by one? So the number is more negative. The smallest negative number is more negative than the largest positive number is positive. And the reason for that actually is fairly simple, if you think about it, is that. The cases where you have zeros. Include the number 0. 
你注意到，如果你看T max的绝对值吗？并将其与t min的绝对值进行比较。它已经被一个关闭了吗？所以这个数字更负。最小的负数比最大的正数更负。如果你仔细想想，其实原因相当简单，就是这样。当你有零的情况下。包括数字0。


发言人   50:24
So you can see it better. And there's two to the half year ranges occupied by those numbers. And the negative numbers are all negative. 
这样你就可以看得更清楚。这些数字占据了两到半年的范围。负数都是负数。

发言人   50:45
And so the other half of the range is in there. And the point is that you had to use one of these for 0. And so only there was one left, one less value left over. And that's why you end up with this sort of asymmetry. And this asymmetry is the cause of no end of pain in various ways, like a few. The classic example is if you implement absolute value. 
所以范围的另一半在那里。重点是你必须使用其中一个来表示0。所以只剩下了一个，剩下的价值少了一个。这就是为什么你最终会得到这种不对称。这种不对称性以各种方式引起了无止的疼痛，就像一些方式一样。经典的例子是，如果你实现绝对值。

发言人   51:36
Like, so what does this return for t min? Yeah, it returns t min. We'll talk a little bit. Basically, when you try to negate this number that's here. You'll end up with it back again. 
像，那么这对t-min有什么回报呢？是的，它返回t min。我们稍微聊一下。基本上，当你试图否定这里的这个数字时。你最终会再次得到它。

发言人   52:11
So it's always a corner case. And whenever we do program testing, we always throw that case in there to break things. You said, well, like he, you said earlier about, I. Yes? 
所以这总是一个角落。每当我们进行程序测试时，我们总是把那个情况扔进去破坏事情。你说，就像他一样，你之前说的，我。是吗？


发言人   52:36
No, they do that if you ever look at the. In the C constants, they use this as a way of representing t min, and they do it for that reason. You see, it's exactly, and they put parentheses around it, president's problem. But you see that number that in 647, that's T max. And so basically, it's just saying that t min is minus t max -1 question. 
不，如果你看到他们，他们就会这样做。在C常量中，他们使用这个作为表示t min的方式，并且他们出于这个原因这样做。你看，这确实是总统的问题，他们在后面加了括号。但是你可以看到647中的数字，那就是T max。所以基本上，它只是说t min是-t max -1问题。


发言人   53:22
Yes, so comparison is just a special case of the more general one, which is addition, subtraction, all of those. If either argument is unsigned, then it interprets the remaining one as being unsigned, It turns out, and we'll get into this more next time as far as bit patterns, but it turns out at the bit level, addition, subtraction, even multiplication are the same, whether it's an unsigned number or two's complement number. So we'll talk about that more next time. And the other thing to observe sort of property. 
是的，所以比较只是更一般的一种特殊情况，即加法、减法。如果其中一个参数是无符号的，那么它会将剩余的一个解释为无符号的，事实证明，我们下次会更深入地讨论位模式，但事实证明，在位级别上，加法，减法，甚至乘法都是相同的，无论它是无符号数还是2的补码数。所以下次我们会更多地谈论这个。另一件事是观察某种性质。

发言人   54:21
You saw that umax is sort of like? Twice t max plus one. 
你看到umax有点像吗？两次t最大值加1。

发言人   54:36
So before Mas was 15 in our 5 b numbers and that's again, not too hard to figure out. Here's one way to think about it. T max is a 0 followed by a bunch of ones. And if I want to double that number, I basically shift it left by one position, and that would end up with a 0 here. So this is T max, and this is twice t max. And now if I add a 1 to that I'll just set this bit to one and get this. So there's various ways you can think about it, but that's one way to do it. 
所以在我们的5 b数字中Mas之前是15，这并不难弄清楚。这是思考它的一种方式。T max是一个0后面跟着一堆1。如果我想将这个数字翻倍，我基本上会将它向左移动一个位置，最终会得到一个0。这是T max，这是两倍t max。现在，如果我加一个1，我只需要将这个位设置为1，就可以得到这个。所以有各种各样的方法可以考虑它，但这是一种方法。


发言人   55:43
There's one other thing that I wanted to mention too. This can get you into a lot of trouble. Programming Y, so let me just show you what I mean. 
还有一件事我也想提一下。这可能会给你带来很多麻烦。编程Y，那么让我向你展示我的意思。

发言人   56:10
So imagine I wanted to. Go backwards through an array. So I write a loop of the form for I equals n -1. I is greater than. Or equal to zero, I minus, minus. And then I do something with array element A of I. I'll just call some function of whatever you want to do in that loop. So that's a pretty standard pattern in a loop, right? Except that you write this greater equal to 1, 0. You can imagine various uses for that. 
所以想象一下我想要。在数组中向后移动。所以我写了一个形式为I等于n -1的循环。我大于。或等于零，I-，-。然后我对I的数组元素A做了一些事情。我会在循环中调用任何你想做的函数。所以这是一个相当标准的循环模式，对吧？除了你写的大于等于1，0。你可以想象它的各种用途。

发言人   57:01
So here's an interesting question. I were declared as being unsigned. Because it's array index, after all. What will happen with this loop? Yeah? What's that, yes? So the loop will go forever. What would most likely happen is I would go from being 0 to being u max, and that's a really big number. And the ray'd most likely cause a memory fault because it's so far out of bounds. But the point is, it wouldn't do what you want. It wouldn't stop where you want it to. And because of the simple reason that I, of course, I is always going to be greater or equal to 0, because it's an unsigned number. 
这里有一个有趣的问题。我被宣布为无符号。因为它毕竟是数组索引。这个循环会发生什么？是吗？那是什么，对吗？所以循环将永远持续下去。最有可能发生的情况是我从0变成u max，这是一个非常大的数字。而射线很可能会导致记忆故障，因为它已经超出了界限。但关键是，它不会做你想做的事。它不会停在你想要的地方。原因很简单，当然，I总是大于或等于0，因为它是一个无符号数字。

发言人   57:58
One, you'd say OK, well, you should have figured that one out. It can be more subtle, though. If you have something like int I. And then we say something like, let me just change it here a little bit. So this will be. 
你会说，好吧，你应该已经想出了那个。不过，这可能更加微妙。如果你有像int I这样的东西。然后我们说，让我在这里稍微改动一下。这将是如此。


发言人   58:44
Something like this where I'm mixing metaphors here, I have to confess. But if you use the standard term size of which is the way you get how many bytes it takes to represent some given data type, so this will actually be the number one. So it's not the same loop as before. But imagine I'm sort of mixing in my arithmetic and making use of some of these built in forms. What would happen with this group? 
像这样的事情，我在这里混合隐喻，我必须承认。但是如果你使用标准的术语大小，它是你获取表示某种给定数据类型所需的字节数的方式，那么这实际上将是第一。所以它不像以前那样循环。但想象一下，我在算术中混用了一些内置的形式。这个群体会发生什么？


发言人   59:24
Yes exactly, so size of returns an unsigned value. It's not actually a function, it's a built in. The result of size of is considered to be unsigned. 
完全是，所以大小返回无符号值。它实际上不是一个功能，而是一个内置的。size的结果被认为是无符号的。

发言人   59:39
Just like I was saying, if you have a sine value and an unsigned in any kind of arithmetic, it'll treat the combination of the two as unsigned. And so it will actually do an unsigned comparison here, which is almost surely not what you wanted. And this will just. 
就像我说的，如果你有一个正弦值和一个无符号的算术，它会将这两者的组合视为无符号。因此，它实际上将在这里进行未签名的比较，这几乎肯定不是您想要的。而这将只是。

发言人   01:00:02
You'll look at this program and you won't have any idea why it's crashing. You'll be so confused. And that's the kind of thing you have to know. It's one of the quirks of C that probably if they could start over again and redesign it, they'd come up with some different set of conventions than they did. But unfortunately, it's way too late for that. So this is just one of those things you have to remember. But yes, my point is there's some subtleties in C about this business of sed versus unsigned arithmetic. 
你会看到这个程序，但你不知道它为什么会崩溃。你会很困惑。这就是你必须知道的事情。这是C的怪癖之一，如果他们能重新开始并重新设计它，他们可能会提出一些与以前不同的约定。但不幸的是，现在已经太晚了。所以这只是你必须记住的事情之一。但是，是的，我的观点是，关于sed与无符号算术的业务，C中有一些微妙之处。

发言人   01:00:40
Okay, so now let's look at a sort of final class of operations, which is, suppose I have a number that's so many bits, say 8 b, and I want to now expand it to be a 16 b number. There's a fairly cute rule for doing this that's called sine extension. I'm talking about twos complement numbers here of how you go take a number, make it bigger without changing its value. The basic rule is you do it by copying the sine bit to the left. So let me give you the intuition behind it. 
好的，现在让我们来看一种最终的操作类，也就是说，假设我有一个位数，比如8 b，我现在想将它扩展为一个16 b的数字。有一个相当可爱的规则来做这件事，叫做正弦扩展。我在这里谈论的是二补码，即如何在不改变其值的情况下将一个数字变大。基本规则是通过向左复制正弦位来完成。让我给你背后的直觉。


发言人   01:01:33
So let's look at some 4 b values. 
让我们来看看一些4 b的值。

发言人   01:01:45
Well, it's pretty straightforward if the leading bit is a 0. I'm just going to do a left shift and then fill in. 
如果前导位是0，那就非常简单了。我只是要做一个左移，然后补上。

发言人   01:02:02
Right, wait, what am I talking about? I got ahead of myself. I'm talking about something totally different. No, sorry, the same number. I'm not changing the number. I'm keeping it the same, so I just added a 0 to the lead and this will be the number 6 still. 
对，等等，我在说什么？我超前了。我说的是完全不同的东西。不，对不起，是同一个号码。我不会换号码的。我保持不变，所以我只是在引线上加了一个0，这将是数字6。

发言人   01:02:20
This is plus 4 plus 2 equals 6. But now let's think about it as where there's a leading sign bit. So this is -8 plus 4 plus 2 is equal to -2. So now look at what happens if I copy that sine bit over one position. So this becomes a 1, 1, 1, 1, 0. And what happens is this is now has value plus 8 here, but the sine bit has value -16. And then this is still plus 2 and plus 4. And so it will still equal -2. 
这是加4加2等于6。但现在让我们把它想象成一个前导符号位。所以这是-8加4加2等于-2。所以现在看看如果我在一个位置上复制那个正弦位会发生什么。所以这变成了1，0。发生的情况是，现在这里的值加8，但正弦位的值为-16。然后这仍然是 + 2和 + 4。因此它仍然等于-2。

发言人   01:03:17
So here's what happened before. My sine bit had a weight of -8, and my new sine has a weight of -16. But I converted that old sine bit into a positive number, which is plus 8, and those two canceled out. You combine those two and you get minus A, which is exactly this. So you see by sort of copying that sine bit over, giving it twice the way, turning it, what was the sine bit into a positive number, you don't change the net effect of the sum. 
这就是之前发生的事情。我的正弦波位的权重为-8，而我的新正弦波位的权重为-16。但是我把那个旧的正弦位转换成了一个正数，也就是加8，然后这两个被抵消了。你把这两者结合起来，得到-A，也就是这个。所以你通过复制那个正弦位，给它两倍的方式，把它，正弦位变成一个正数，你不会改变总和的净效应。


发言人   01:03:58
And that's exactly the idea of extension. Just keep going with that as far as you need to carry it over. And each time you're doing it, you're effectively doing this business of of coming up with a pair of bits that end up with the same value as this original bit. So that's the idea of sine extension. And you'll see that a lot. Bit patterns, especially if you see a bit pattern that starts with a bunch of F's. 
这正是扩展的想法。只要继续下去，直到你需要把它带过去。每次你这样做的时候，你都在有效地进行这项业务，即想出一对与原始位具有相同值的位。这就是正弦扩展的想法。你会经常看到这一点。位模式，特别是如果你看到一个以一堆F开头的位模式。


发言人   01:04:40
What that tells you, remember f is just four ones. 
这告诉你的是，记住f只是四个一。

发言人   01:04:50
Is a whole bunch of leading ones that tells you the number is negative, negative, but not too far away from 0. And you'll see that over and over again. You'll see bit patterns. And you just sort of, when you see meeting F's, you say, oh, that's a negative number. I know what's going on there. And so here's some examples. But you can see the main idea is you carry that leading bit from the 16 b case over, make as many copies as you need to expand the word size. 
是一堆领先的数字，告诉你数字是负数，负数，但离0不太远。你会一遍又一遍地看到这一点。你会看到比特模式。当你看到遇见F的时候，你会说，哦，那是一个负数。我知道那里发生了什么。这里有一些例子。但是你可以看到主要的想法是你从16 b的情况下开始，根据需要制作尽可能多的副本来扩展单词大小。


发言人   01:05:29
And I should mention with the unsigned case, obviously, you just want to fill in with zeros. 
我应该提到未签名的情况，显然，你只想用零填充。


发言人   01:05:41
Do we talk about truncation? Is there any any missing slides in this? 
我们在谈论截断吗？这个幻灯片有缺失的吗？

发言人   01:05:52
A final case to look at is what happens if I make something shorter? So if I had my unsigned number from before. 
最后一个需要考虑的案例是，如果我把东西缩短会发生什么？如果我有之前的无符号号码。

发言人   01:06:11
If this were an unsigned number, this would be 1, 2, 8, 16, 1417, right? What if I decided, oh, I can't afford? For a bit. I don't have enough money. For 5 b. I'm only going to give you 4. Well, you basically just dropped the most significant bit. And you get 8 plus 2 plus one, which is 11, which is 9. And the relation there is that it's like modular arithmetic. 
如果这是一个无符号数字，那么它将是1，2，8，16，1417，对吧？如果我决定，哦，我负担不起怎么办？有一点。我没有足够的钱。5个b。我只会给你4。好吧，你基本上只是掉了最重要的一点。你得到8加2加1，也就是11，也就是9。那里的关系就像模块化算术一样。

发言人   01:07:03
Mod 16, you're taking no. Thank you? It's the risk of improvising. So 27. 
Mod 16，你要不要。谢谢？这是即兴创作的风险。所以27。

发言人   01:07:26
And 11? Yeah, that makes sense. Difference is 16, I knew that. Okay, excuse me for my stumbling. 
And 11?是的，这很感知。差异是16，我知道。好的，请原谅我的绊倒。

发言人   01:07:42
The point being that when you drop this thing effectively, you're just taking the mod some power of two of it. Like I mentioned, the case where you're taking modulo 8, if you just keep only the lowest order of 3 b, you're having a module 8. Now, one, really, this is sort of logical in the unsigned world. Modular arithmetic is something that was understood by the ancient Greeks, so not too far away from human experience, but it gets a little bit funky if. Dealing with two these complement numbers because this is now. 1011 -5, right? But this number, if I just drop this bit. And call it a 4 b number. This now becomes -8, 2, and 1. 
关键是，当你有效地放下这个东西时，你只是在利用它的一些力量。就像我提到的，在你取模8的情况下，如果你只保留最低的3 b的顺序，你就有一个模块8。现在，第一，真的，这在未签名的世界里是合乎逻辑的。模块化算术是古希腊人所理解的东西，因此与人类经验不太遥远，但如果它变得有点古怪。处理这两个补数，因为这是现在。1011 -5，对吧？但是这个数字，如果我只是放下这一点。称之为4 B数字。这现在变成了-8、2和1。

发言人   01:08:54
Which is -5? 
哪个是-5？

发言人   01:09:01
You say, how'd that happen? Well, actually, if you look at it, this is just what you'd get by S extension, right? So this wasn't a very interesting example. But if we changed it to this? 
你说，这是怎么发生的？嗯，实际上，如果你看一下，这正是你通过S扩展得到的，对吗？所以这不是一个非常有趣的例子。但是如果我们把它改成这个？

发言人   01:09:27
Then this would be -13. And this would be plus 3. And. It's a little harder to think about in terms of modular arithmetic, The way you basically have to think about it is, well, you know, this is -13, but it's really kind of like 27 and 27 mod 16 is sort of like, or no, this isn't 20. 
那么这将是-13。这将是加3。而且。从模块化算术的角度考虑有点困难，你基本上要考虑的方式是，你知道，这是-13，但它真的有点像27和27 mod 16有点像，或者不，这不是20。


发言人   01:10:01
We changed our number, right? So this is really kind of like 19 and 19 mod 16 is 3, and this is 3. So you can sort of do it by coming back around to it. But it's not some arithmetic property that would jump out at you as being something logical. But that happens all the time. And it's very common for numbers to get truncated for one reason or another. 
我们换了号码，对吧？所以这真的有点像19和19 mod 16是3，这是3。所以你可以通过回到它身边来做到这一点。但这并不是一些算术属性会突然出现在你身上，成为合乎逻辑的东西。但这种情况经常发生。由于某种原因数字被截断是很常见的。


发言人   01:10:30
And you can see that you can have a negative number become a positive number. You can have a positive number become a negative number, and all kinds of goofy stuff can happen. And we'll see plenty of examples of that when we look at arithmetic. So that's. That is what I want to cover for today. And we'll cover the other arithmetic operations on Tuesday. So thank you very much. 
你可以看到你可以让一个负数变成正数。你可以让一个正数变成负数，各种愚蠢的事情都可能发生。当我们看算术时，我们会看到很多这样的例子。就是这样。这就是我今天想要涵盖的。我们将在周二介绍其他算术运算。非常感谢。
