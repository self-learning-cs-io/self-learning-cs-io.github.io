---
title: 深入理解计算机系统 004-Floating Point
date: 2025-10-12 10:00:03
---

发言人   00:01
Good afternoon, everybody. Welcome, it's good to see you. So today we're going to study an arcane area of computer systems known as floating point, which is the way that computer systems represent the real numbers. So you're all familiar with decimals, something like 3.14. And there's a similar idea with binary numbers. So what does a fractional binary number like 1 0 1, 1.101 represent? And how does that work? Well, it works just like the de fractional decimal numbers that you're used to. 
大家下午好。欢迎，很高兴见到你。所以今天我们要研究计算机系统中的一个神秘领域，称为浮点，它是计算机系统表示实数的方式。所以你们都很熟悉小数，比如3.14。二进制数也有类似的想法。那么像1 0 1，1.101这样的小数二进制数代表什么？这是如何运作的？它的工作原理就像你习惯的小数十进制数一样。

<!-- more -->

发言人   01:05
So you have, in this case, it's a binary point. And to the left of the binary point, you have bit positions, so representing powers of 2, so 2 to the 0, 2 to the 1, 2 to the two. So one half of 1, 2, 4, and so on. And to the right of the binary point, you have two to the minus one, one half, 2 to the -2, 1, 4, 2 to the -3, 1 8th, and so on. So we can represent any fractional binary number using this notation where we sum. 
所以在这种情况下，它是一个二进制点。在二进制点的左侧，您有位位置，因此代表2的幂，因此2对0，2对1，2对2。所以，1、2、4的一半，以此类推。在二进制点的右侧，有两个到负一，二分之一，2到-2，1，4，2到-3，1 8，依此类推。因此，我们可以使用这种求和符号来表示任何分数二进制数。

发言人   01:53
The bit at position k times 2 to the k, so it really works exactly the same way as with base 10, just with base 2. 
位置k的位乘以2到k，因此它的工作方式与以10为基数的方式完全相同，只是以2为基数。

发言人   02:09
So let's look at some of these. Values so 5 and 3 quarters, we would represent as 111.11. This is before plus 1 is five one half plus one quarter. So 2/4 plus 1/4 is three quarter. So 5. And 3/4. So that's pretty simple. Two and 7/8 is 10.1110. Is two, of course, and then .111 is one half. So 4/8 plus 1/4 2/8 plus 1/8, so 7/8. And one seven sixteenths. Would be 1.0111 so that the one to the left of the binary point is one. And then we have one fourth plus one 8th plus one 16th. So one 1/4 is 4/16. One 8th is 2/16 and one 16th. So you add those up, you get 7/16. 
让我们来看看其中的一些。值为5和3个季度，我们表示为111.11。这是在加1是5二分之一加四分之一之前。所以2/4加上1/4就是四分之三。所以5。和3/4。所以这很简单。2和7/8是10.1110。当然是2，然后.111是一半。所以4/8加1/4 2/8加1/8，所以是7/8。一七六分之一。将是1.0111，这样二进制点左边的就是一。然后我们有四分之一加八分之一加十六分之一。所以一个1/4是4/16。一个8是2/16，一个16。所以你把它们加起来，你得到7/16。


发言人   03:50
Now notice for some of these numbers, this bit pattern, 1, 0, 1.11, if we shift it to the right to get one, 0.111, we've divided by two. So we've taken 5 and 3/4 and divided it by 2. And it works the other way too. If you to the left, you multiply, you shift to the left by one, you multiply by one. And these numbers that are all ones to the right of the binary point are these are numbers that are just slightly less than one. And so we want to represent those. 
现在请注意其中一些数字的位模式，1，0，1.11，如果我们将其向右移动以获得1，0.111，我们已经被2除了。所以我们取了5和3/4，并将其除以2。它也以另一种方式工作。如果你向左，你乘以，你向左移动一，你乘以一。这些数字都是二进制点右侧的一，这些数字只是略小于一。所以我们想要代表他们。

发言人   04:36
We'll often, we'll sometimes refer to those numbers of that form as 1 minus epsilon. And epsilon just depends on how many bits you have to the right of the binary point. So epsilon gets smaller, the more, the more of those bits you have, or it gets closer to one. And epsilon gets smaller, the more of those bits you have. 
我们经常，我们有时会把这种形式的数字称为1-epsilon。而epsilon只取决于二进制点右边有多少位。因此epsilon越小，你拥有的那些位就越多，或者它接近一个。当epsilon变小时，你拥有的这些位越多。


发言人   05:01
Now there's. Limitations in this kind of representation. First of all, we can only represent rational numbers of the form x divided by two to the k, we can only represent numbers of that form exactly. Other numbers have to have repeating bit representations that can't be represented with a finite number of bits that we have in a computer system. So for example, things like one third is this repeating representation, one fifth and one 10th, or other examples of that. 
现在有了。这种表现方式的局限性。首先，我们只能表示形式为x除以二得到k的有理数，我们只能精确地表示该形式的数字。其他数字必须有重复的位表示，而这些位表示不能像计算机系统那样用有限数量的位表示。例如，三分之一是重复表示，五分之一和十分之一，或其他例子。


发言人   05:40
Now, the other problem we have is that we can only, there's only so many bits to the left and the right of the binary point. If we move the binary point to the left, then we don't have as many. We can't represent as many large numbers. We can only represent small numbers, but we have more precision to the right of the binary point. So we can represent more fractional values. Just the range of those values will be much smaller. Similarly, if we move the binary point to the right, we'll have a larger range of values, but we won't be able to represent as many fractions. So there's this kind of trade off. 
现在，我们面临的另一个问题是，我们只能在二进制点的左边和右边只有这么多位。如果我们将二进制点向左移动，那么我们就没有那么多了。我们无法表示太多的数字。我们只能表示小数，但我们在二进制点右侧有更多的精度。这样我们就可以表示更多的分数值。只是这些值的范围会小得多。同样地，如果我们将二进制点向右移动，我们将拥有更大的值范围，但我们将无法表示尽可能多的分数。所以就有这种权衡。

发言人   06:28
And a floating point is a representation that enables us to move that, basically to move that binary point to represent sort of as wide a range as possible with as much precision, given the number of bits, the finite number of bits that we have to work with. So the float and floating point is this sort of shifting binary point, this floating, floating binary point. Now, up until 19, floating point was just a disaster, and every computer manufacturer had their own representation. You couldn't. And it was just terrible because you couldn't predict what would happen if you moved your program from one machine to another. The behavior would be different, the rounding would be different. It was a very difficult situation. And people really, computer scientists in particular, really dislike floating point. 
浮点是一种表示形式，使我们能够移动它，基本上移动该二进制点以表示尽可能宽的范围和尽可能高的精度，给定位数，我们必须使用的有限位数。所以浮点数和浮点数就是这种移动的二进制点，这种浮动的、浮动的二进制点。现在，直到19年前，浮点运算只是一场灾难，每个计算机制造商都有自己的代表。你做不到。这真的很可怕，因为你无法预测如果你将程序从一台机器移动到另一台机器会发生什么。行为会不同，舍入也会不同。这是一个非常困难的情况。而人们，特别是计算机科学家，真的不喜欢浮点运算。

发言人   07:36
In 1985, IEEE, which is the professional association Electrical Engineers introduced. And it's also a very important standards body. They introduced a standard floating point representation called IEEE floating point, which was then adopted by all computer manufacturers. So now the situation is much better. Everybody supports the same kind of floating point representation, which is what we're going to learn about today. 
在1985年，IEEE，这是专业协会电气工程师的介绍。它也是一个非常重要的标准机构。他们引入了一种称为IEEE浮点的标准浮点表示形式，随后被所有计算机制造商采用。所以现在的情况好多了。每个人都支持相同类型的浮点表示，这就是我们今天要学习的内容。

发言人   08:15
So the floating point has the form. It represents numbers in. This is like a scientific notation. It represents numbers of the form -1 to the s, where s is a sine debt. Times a significant m times 2 to some exponent e, so all of the numbers that we can represent in floating point have to be represented in this form. 
所以浮点数的形式是。它代表数字。这就像一种科学计数法。它代表形式为-1的数字到s，其中s是正弦债务。将一个有效的m乘以2到某个指数e，因此我们可以用浮点数表示的所有数字都必须以这种形式表示。


发言人   08:53
So the sine bit s determines whether the number is negative or positive. Obviously, the significant m, so this is sometimes called the mantissa, which is where the M comes from. The significant m normally is a fractional value in the range between one and 2. And we'll see the way that is in a second. And then the exponent e weights the value by some power of two. 
所以正弦位s决定数字是负数还是正数。显然，有效m，有时也被称为尾数，即M的来源。有效m通常是介于1和2之间的分数值。我们将在一秒钟内看到它的样子。然后指数e对该值加权2的幂。

发言人   09:21
So this is encoded in either 32 b or 64 b in the following way. The sine bit s is the most significant bit. And then this is followed by some number of. Bits called the Exp field, which encodes the exponent E, but it's not identical to E, it encodes E, and we'll see how that works. And then that's followed, the remaining bits are the frack field, which encodes them but isn't identical to them. Now IEEE. 
所以这按以下方式编码为32 b或64 b。正弦位s是最重要的位。然后这个后面跟着一些数字。位被称为Exp字段，它对指数E进行编码，但它与E不同，它对E进行编码，我们将看到它是如何工作的。然后，剩下的位是frack字段，它对它们进行了编码，但并不完全相同。现在，IEEE。


发言人   10:05
Floating point has provides two different kinds. Floating point, there's single precision, 32 b and so called double precision, which is 64 b. There's this funky Intel extended precision, which is non-standard and we won't talk about it anymore. And so in the single precision 32 b, you have one sine bit. There's always a sine bit, you have 8 Exp bits, and you have 23 frac bits. In double precision, you have 11 Exp bits, 52 frac bits. 
浮点提供了两种不同的类型。浮点，有单精度32 b和所谓的双精度，即64 b。有一个时髦的英特尔扩展精度，这是非标准的，我们不再谈论它了。所以在单精度32 b中，你有一个正弦位。总是有一个正弦位，你有8个Exp位，还有23个frac位。在双精度中，您有11个Exp位，52个frac位。

发言人   10:43
Now, there's a number of different kinds of floating point representations, The default and sort of the common representation is called normalized, so called AED normalized values. And normalized values are all the values where the Exp field is not equal to 0 and not equal to all zeros and not equal to all ones. All zeros and all ones are special kinds of numbers we'll look at in a second. 
现在，有许多不同种类的浮点表示形式，默认和常见的表示形式被称为归一化，即所谓的AED归一化值。规范化值是Exp字段不等于0且不等于全部零且不等于全部一的所有值。所有零和所有一都是特殊类型的数字，我们一会儿就会看到。


发言人   11:19
So the exponent, this exponent e, remember our numbers are -1 to the power s times m times 2 raised to the power e, the exponent e is encoded as this biased value, which is called Exp. So the exponent e is Exp. Minus some bias and Exp is the value capital. Exp is the value of the Exp bits. The bits in the Exp field treated as a positive number. So capital Exp is just you just look at it as an unsigned. 
所以指数e，记住我们的数字是-1的幂s乘以m乘以2的幂e，指数e被编码为这个偏差值，称为Exp。所以指数e是Exp。减去一些偏见和Exp是价值资本。Exp是Exp位的值。Exp字段中的位被视为正数。所以资本出口只是你把它看作是一个未签名的。


发言人   12:06
7 b in case of single precision, 7 b number. Now the bias is 2 to the power k -1 -1, where k is the number of exponent bits. So for single precision. We have 8 exponent bits, so 2 to the 8th, two to the 8 -1 is seventh. So 2 to the 7th is 128 -1 is 127. So the bias for a single precision is 127. And similarly, for double precision, it's 1023. So you just have to memorize this formula. 
在单精度的情况下，7 b是一个7 b的数字。现在的偏差是2的幂次k -1，其中k是指数位数。所以对于单精度。我们有8个指数位，所以2的8次方，2的8 -1是第七位。所以2的7是128 -1是127。因此，单精度的偏差为127。同样，对于双精度，它是1023。所以你只需要记住这个公式。

发言人   12:55
The exponent e is the Exp field interpreted as an unsigned number minus the bias. 
指数e是被解释为无符号数字减去偏差的Exp字段。

发言人   13:05
Now, this is kind of a strange thing. The first time you encounter a floating point, it seems kind of odd, so why not? I mean, we've already learned about two's complement, that's a perfectly fine way to represent positive and negative numbers. And we have exponents that are negative and positive. So why not just use the Exp field to represent? Or why not just use tooths complement in the Exp field to represent those positive and negative exponents, right? So it turns out that the reason that they do this. That, and if you think, think about this and we'll come back to it. 
现在，这是一件奇怪的事情。当你第一次遇到浮点时，它看起来有点奇怪，为什么不呢？我的意思是，我们已经学习了2的补码，这是表示正数和负数的完美方法。我们有负的和正的指数。那么为什么不直接使用Exp字段来表示呢？或者为什么不在Exp字段中使用tooths补码来表示那些正负指数，对吧？所以事实证明他们这样做的原因。如果你想的话，想想看，我们会回到这个问题上。

发言人   13:50
But if we encode the exponent e using this bias representation, the smallest negative exponent is represented by all zeros. And the largest exponent is represented by? Zero, 1, 1, 1, 1. So the number with the smallest. 
但是如果我们使用这种偏差表示对指数e进行编码，最小的负指数将由全部零表示。并且最大指数由表示？零，1。所以最小的数字。


发言人   14:21
Exponent, if we were just to compare the bits using just some kind of unsigned representation, just comparing the bits, treating it as an unsigned number, by using this biased representation, we can just compared to floating point numbers, just as we can treat the whole floating point number as an unsigned integer and compare two numbers and get a true comparison. So the exponent uses this sort of biasing encoding. 
指数，如果我们只是使用某种无符号表示来比较位，只是比较位，将其视为无符号数字，通过使用这种偏置表示，我们可以将其与浮点数进行比较。就像我们可以将整个浮点数视为无符号整数并比较两个数字并获得真正的比较一样。指数使用这种偏置编码。

发言人   14:56
And then the significant is encoded with an implied one. So, and this is where the, this is where the normalized and the normalized representation comes from that we're always going to represent our numbers. So m, we're always going to normalize m, no matter what the number we want to represent, we're always going to normalize m as one point something, and then we adjust the exponent accordingly. So if the value we want to represent is 100.01, we're going to shift it over and it'll be 1.00. And then we'll adjust the exponent to represent that shift. 
然后，意义被隐含地编码。所以，这就是规范化和规范化表示的来源，我们总是要表示我们的数字。所以，我们总是要归一化m，无论我们想要表示什么数字，我们总是要将m归一化为一个点，然后相应地调整指数。因此，如果我们想要表示的值是100.01，我们将把它转移过来，它将是1.00。然后我们将调整指数以表示该转变。

发言人   15:48
So the bits in the Frac field Xxxxx are all of the numbers to the right of the binary point's always implied one, but we don't even encode it. We just throw it away because it's always there. So this is a little trick just to get it one more bit for free. So the XXX bits in the frac field, all the bits to the right of the binary point after one point, the one point. And so the smallest frac field is all zeros, which corresponds to a sign of 1.0. And a frack field, of all ones, corresponds to 2 minus epsilon. So that's 1.11111, and so on. 
因此，Frac字段Xxxxx中的位是二进制点右侧的所有数字，但我们甚至没有对其进行编码。我们只是把它扔掉，因为它总是在那里。所以这是一个小技巧，只是为了免费获得它。所以在frac字段中的XXX位，在一个点之后的二进制点右边的所有位，一个点。因此，最小的frac字段全是零，对应于1.0的符号。一个压裂井，所有的一，对应于2减去epsilon。所以这是1.11111，依此类推。


发言人   16:49
So let's look at an example. So let's look at how we would encode 15, 2, and 13, which our favorite number in floating point. So if we represent that, so it's an integer and we represent it using these bits, take my word for it, correspond to it, the integer are 213. So now we want to convert it. We want to normalize it. By expressing it as 1.110 and so on, times 2 to the 13th, same number, we just normalized it so that there's always this leaving one. So the significant M? Is 1.11011 and so on. 
让我们来看一个例子。那么让我们来看一下如何对我们最喜欢的浮点数15、2和13进行编码。因此，如果我们表示它，那么它是一个整数，我们使用这些位表示它，相信我的词，对应于它，整数是213。所以现在我们想要转换它。我们想要将其正常化。通过将其表示为1.110等，乘以2到13号，相同的数字，我们只是对其进行了标准化，以便总是留下一。那么重要的M？是1.11011，依此类推。

发言人   17:47
The frac field is everything to the right of the binary point. So we throw this one away and we just take the values to the right of the binary point. And then we padded out with zeros to get the 23 b that we need for single precision. So now we've got our frac field, the exponent. 
frac字段是二进制点右侧的所有内容。所以我们把这个扔掉，我们只需要取二进制点右边的值。然后我们用零填充以获得单精度所需的23 b。所以现在我们有了我们的压裂字段，指数。

发言人   18:14
So in this case, e is we're multiplying by two to the 13. So e is 13. So we want to represent the value 13 using this biased encoding. So the bias is 127. And so the exponent, the value, the value of the Exp field should be 140. 
在这种情况下，e是我们乘以2得到13。所以e是13。所以我们想用这种偏置编码来表示值13。所以偏差是127。因此指数，值，Exp字段的值应该是140。

发言人   18:42
Because if we take, if we take 140 -127, we get 13. So 140 is represented using these 8 b, and that becomes our Exp field. So the resulting floating point number, and of course, it's a positive number, so the sine bit is 0. So the resulting floating point number has the 8 b in Exp field that we computed by subtracting 127 from 140. And then the frac field are these bits that we got here by just taking everything to the right of the binary point. 
因为如果我们取140 -127，我们得到13。所以140用这些8 b来表示，这就成为了我们的Exp字段。所以得到的浮点数，当然它是一个正数，所以正弦位是0。因此，结果浮点数在Exp字段中有8 b，我们通过从140中减去127来计算。然后frac字段是我们通过将所有东西都带到二进制点右侧而得到的这些位。



发言人   19:33
So? So let's look at this exponent just a little bit more because I think can be a little confusing. So in our example. 
所以呢？所以让我们再看看这个指数，因为我认为可能会有点困惑。在我们的例子中。

发言人   19:56
If we want to look at the range of Exp. So what's the smallest value of Exp? What's the smallest value of Exp? Now wait, man, don't confuse the encoding with the value it represents. Exp is just the encoding. So what's the smallest value of Exp? Zero, that's right. And the largest value is what? What's the largest value? Well, the largest value would be, remember, it can't be all ones. So the largest value would be 2 to the 8th -1. So the largest value would be 0, 1, 1, 1, 1, 0, followed by seven ones. So that's 2 to the 8th -1 is. 255, good. 
如果我们想看Exp的范围。那么Exp的最小值是什么？Exp的最小值是什么？现在等待，伙计，不要将编码与它所代表的值混淆。Exp只是编码。那么Exp的最小值是什么？零，没错。最大的价值是什么？最大的价值是什么？好的，最大值应该是，记住，它不能全是一。因此，最大值将是第8个-1的2。所以最大值将是0，1，0，其次是七个。所以这是2的8次方-1。255，好的。


发言人   21:15
So then what's the range then of e, which is the actual value that we want to encode? Okay, remember we have this definition. So we have the range of values for Exp. We have our bias. So what is the range of values for E? This is the actual exponents that we're encoding. So what's the smallest exponent -127, good? Because that's 0 is our smallest DXP minus the bias, which is 127. So the smallest value of e is 127, and the largest value of e is. 
那么e的范围是什么，我们想要编码的实际值是什么？好的，记住我们有这个定义。所以我们有Exp的值范围。我们有偏见。那么E的值范围是什么？这是我们正在编码的实际指数。那么最小指数是什么？127，好吗？因为0是我们的最小DXP减去偏差，即127。所以e的最小值是127，而e的最大值是。


发言人   22:09
So if we take the largest value of Exp, that's 255 -127. 128. So the numbers that we can represent using this bias notation, we'll have the smallest exponent will be 2 to the -127, and the largest exponent will be 2 to the raise to the power 128. You see what's going on here? So we have, we have a range of values for e, here's the largest value, here's the smallest value, here's zero right in the middle. These are the values we want to represent. This bias thing is like a ship, we've just now we're shifting up by 127 so that now the smallest exponent is represented by zero. Any questions about that? 
所以，如果我们取Exp的最大值，即255 -127。128.因此，我们可以使用这种偏差表示法表示数字，我们的最小指数将是-127的2，最大指数将是128的幂次幂的2。你看到这里发生了什么了吗？所以我们有，我们有一系列的值，这是最大值，这是最小值，这是中间的零。这些是我们想要代表的价值观。这种偏见就像一艘船，我们刚刚向上移动了127，现在最小的指数由零表示。有什么问题吗？


发言人   23:24
Now, these normalized values always have this implied one, which when we want to represent numbers closer to 0, that limits us. So there's another type of floating point number called the denormal nomal has value, which is characterized by an Exp field of all zeros. And in a denormalized number or D norm, there's no. Implied one. So the significant M is represented exactly, is encoded identically in the frac field. So there's no implied one. And all of the numbers are the form zero point something, something, something after that. 
现在，这些规范化的值总是有这个隐含的值，当我们想要表示接近0的数字时，这限制了我们。因此，还有另一种类型的浮点数，称为非正规正规拥有值，其特征在于所有零的Exp字段。在非规范化数或D范数中，没有。暗示了一个。因此，有效M被精确地表示，在frac字段中以相同的方式编码。所以没有任何暗示。所有的数字都是形式零点，某个东西，然后是某个东西。


发言人   24:22
In the exponent value e, instead of you, remember for D norms, we subtracted bias from Exp. For D norms, we subtract the bias from one. Now, if we just use the definition we use for normalized numbers, that would be the Exp would be 0. So we don't do that instead. E is one minus the bias. And then the significant is coded with an implied leading 0 instead of a leading one, like I mentioned. So when Exp is 0, and also, I mean, think about it, if we only had denormalized numbers, we wouldn't be able to represent 0 because there'd always be a one in there. So D norms allow us to represent 0, and they allow us to represent values that are very close to 0. 
在指数值e中，代替你记住，对于D规范，我们从Exp中减去了偏见。对于D规范，我们从一个中减去偏见。现在，如果我们只使用我们用于规范化数字的定义，则Exp将为0。所以我们不这样做。E是一减去偏差。然后，像我提到的那样，重要信息被编码为隐含的前导0而不是前导0。所以当Exp为0时，同时，我的意思是，想想看，如果我们只有非规范化的数字，我们将无法表示0，因为那里总是有一个1。因此，D范数允许我们表示0，并且它们允许我们表示非常接近0的值。

发言人   25:24
So when the exponent is 0 and the Exp field is 0 and the frac field is 0, then this is the zero value. And so this is nice because all zeros represents 0, which is sort of what you want. 
因此，当指数为0，Exp字段为0，frac字段为0时，则这是零值。所以这很好，因为所有的零都代表0，这正是你想要的。

发言人   25:40
Now, there is this sort of weird thing, though, that if you have the sine bit. Is one and then you're fracking and exp or 0, Then you have negative 0. So you have this kind of odd situation where there's a positive and negative 0. And other values, if Exp is 0 and you have a non-zero frac, then those are the equally spaced numbers that are closest to 0. Now, there's a couple of other special values when Exp is all ones and the frac is all zeros, this represents the value infinity. So this is a value that we get when we do some kind of addition or multiplication and we overflow. So floating point always overflows to the special value called infinity, the positive or negative infinity. 
现在，有这种奇怪的事情，如果你有正弦位。是一，然后你正在压裂和exp或0，那么你有负0。所以你会遇到这种奇怪的情况，有一个正的和负的0。和其他值，如果Exp为0并且您有一个非零的frac，则这些是最接近0的等间距数字。现在，当Exp全为一，而frac全为零时，还有一些其他的特殊值，这表示值无穷大。所以这是当我们进行某种加法或乘法并溢出时获得的值。所以浮点数总是溢出到称为无穷大的特殊值，正的或负的无穷大。

发言人   26:40
So it's different from two's complement, right? You sort of overflow in this modular way. Just back around into the range of numbers in floating point, we just overflow to the sticky value called infinity. And then everything we do on that remains infinity. So for example, if we did a. If we did one divided by zero or -1 divided by -0, we'd get positive infinity. If we divide one by 0, negative zero, we get negative infinity. 
所以它不同于2的补语，对吧？你会以这种模块化的方式有点溢出。回到浮点数的数字范围，我们只是溢出到称为infinity的粘性值。然后我们所做的一切都是无限的。例如，如果我们做了一个。如果我们用一除以零或-1除以-0，我们将得到正无穷大。如果我们将一除以0，负零，我们得到负无穷大。


发言人   27:22
The fourth kind of special case, special number, is the case where the exponent again is all once, but the frac is nonzero in a nonzero value. And this represents what's called not a number. This handles cases where there's no answer, there's no feasible answer. For example, try to take the square root of -1. What we'll get back is not a number. 
第四种特殊情况，特殊数字，是指指数再次全部为一次，但在非零值中frac是非零的情况。这代表所谓的非数字。这处理没有答案的情况，也没有可行的答案。例如，尝试取-1的平方根。我们要得到的不是数字。


发言人   27:56
So I think it's helpful to visualize the number line now. So we have positive 0, negative zero right next to each other. And then to the right of that are the positive D norms. And then those sort of transition into the normalized numbers. And then you have infinity, positive infinity of a similar, similar situation for the negative numbers. And then negative and positive, not a numbers. 
所以我认为现在将数线可视化是有帮助的。所以我们有正零，负零紧挨着。然后在它的右边是积极的D规范。然后这些过渡到归一化的数字。然后你有无穷大，负数的类似情况的正无穷大。然后是负面的和正面的，而不是数字。


发言人   28:41
So I think you've probably discovered now that a really good way to try to understand these numeric encodings is two examples with only a few number of bits. 
所以我想你现在可能已经发现，理解这些数字编码的一个非常好的方法是使用只有几个位数的两个示例。

发言人   28:53
If you want to understand, for example, in tooth's complement, if you want to understand T in and T Ma and how they relate to each other, just do a 3 b 2 S complement system. Imagine just have a system with two S complement, 3 b, and then you can just enumerate all the possibilities and you can see, and then you see where the TN is actually one greater than T max. So if you add one to T max, it actually overflows into T min. Similar thing for floating point. It's I would really encourage you to do this. 
如果你想理解，例如，在牙齿补语中，如果你想理解T和T马某某以及它们之间的关系，只需做一个3 b 2 S补语系统。想象一下，有一个具有两个S补码的系统，3 b，然后你可以枚举所有的可能性，你可以看到，然后你可以看到TN实际上比tmax大一的地方。所以如果你向T max加上1，它实际上会溢出到T min。浮点数也有类似的情况。我真的会鼓励你这样做。


发言人   29:32
Just try some simple examples with a small number of Exp and frac bits. So in this case, we're going to look at a floating point system based on IEEE that has four Exp bits and 3 frac bits. As always, the sine bit is the most significant bit, followed by Exp, followed by Freck. So this is identical to IEEE floating point, except for the size of the Exp in frac fields. So it's actually small enough that we can now just enumerate these values. 
只需尝试使用少量的Exp和frac位的简单示例。所以在这种情况下，我们将看一个基于IEEE的浮点系统，它有四个Exp位和三个frac位。与往常一样，正弦位是最高有效位，其次是Exp，然后是Freck。所以这与IEEE浮点数相同，除了在frac字段中Exp的大小。所以它实际上足够小，我们现在可以枚举这些值。


发言人   30:13
And now you can start to see why these weird definitions for the exponent in D norms in normalized numbers. So let's just look at. So what we've done here with a sine bit of 0, we've just enumerated all of the two to the seventh possibilities, possible combinations of Exp and frac fields starting with 0. So when Exp is all zeros, that's a D norm by definition. And then we have the three frac bits are all 0. 
现在你可以开始明白为什么在归一化数字中D范数指数的这些奇怪定义了。那么让我们来看看。所以我们在这里用0的正弦位做了什么，我们只是列举了所有两种到第七种可能性，从0开始的Exp和frac字段的可能组合。因此，当Exp全部为零时，根据定义，这是一个D范数。然后我们有三个frac位都是0。

发言人   31:02
So remember, the Exp is all zeros for D norms. The exponent value is one minus the bias. Our bias here is 7. So 1 -7 gives us a value for the exponent of -6. So we're going to take the Fra. The bits in the frack field times. So m is 0. So m in this case, is zero times 2 to the minus sixth gives us 0. So this is our representation of 0. And like I said, it's really, it's nice that it actually is if we just treated this as an unsigned integer, it would be 0. So that's kind of pleasing. 
所以记住，Exp对于D规范都是零。指数值是一减去偏差。我们的偏见是7。所以1 -7给我们一个-6指数的值。所以我们要采取Fra。压裂现场中的钻头时间。所以m是0。在这种情况下，所以m，零乘2到负六分之一给我们0。所以这是我们对0的表示。就像我说的，这真的很好，如果我们把它当作一个无符号整数，它将是0。所以这有点令人愉悦。


发言人   31:55
Now let's look at the very next number. The Exp is still 0, and we've just bumped up frac by one. So again, it's one minus the bias, which is -6, and now this frac field represents this is one half, one quarter, one 8th, it represents, so this is a value of m is one 8th. So one eighth times 2 to the -6, which is one 64 equals 1 over $512. So in this floating point system, the smallest nonzero number we can represent is the denormalized representation of one over 512, The next smallest number is 0. 
现在让我们看看下一个数字。Exp仍然是0，我们刚刚将frac提高了1。所以再说一遍，它是减去偏差，即-6，现在这个frac字段代表这是二分之一，四分之一，八分之一，它代表，所以这是一个m的值是八分之一。所以八分之一乘2到-6，也就是64等于1超过512美元。因此在这个浮点系统中，我们可以表示的最小非零数字是512之上的非规范化表示，下一个最小的数字是0。

发言人   32:46
OK, now at so let's bump this up by one. So now we get a, we get a frac field of 0, 1, 0. So this represents one quarter. So em is one quarter, the significant is one quarter times 2 to the -6. So 2/8 times one 64th is 2 to the 5 TS, the numbers were just by increment. This, by incrementing, are significant. 
好的，现在到了，让我们把这个提高一个。所以现在我们得到一个，我们得到一个为0，1，0的frac字段。所以这代表四分之一。所以em是1/4，有效值是1/4乘以2的-6。所以2/8乘以1 64次方是2的5次方，这些数字只是递增的。这个，通过增量，是重要的。

发言人   33:22
We're increasing the numbers by one over 512. Now, the largest D norm in this number system is the case where the frac field is all ones, and so this encodes 1/2 plus one four-h plus one 8th, which is 7/8, and then our value is seven eighths times 2 to the -6, or 1 over 64. That equals 7 5 TS, so this 7 over 512 S is the largest denormalized number we can represent in this system. 
我们将数字增加一到512。现在，这个数字系统中最大的D范数是frac字段全部为一的情况，因此它编码为1/2加1个4h加1个8%，即7/8，然后我们的值是八分之七乘以2的-6，或者1乘以64。这等于7 5 TS，所以这个7 over 512 S是我们在这个系统中可以表示的最大非规范化数。


发言人   34:04
And now if we bump our number up by one, the frac field resets to 0, and now the exp field goes from 0 to 1. 
现在，如果我们将数字增加1，则frac字段将重置为0，现在exp字段将从0变为1。

发言人   34:19
Now, because the Exp field is nonzero, this is no longer a denormalized number. It's a normalized number. So now we're changing the definition of E from one minus the bias to Exp minus the bias. So what's Exp in this case? One -7, the bias is -6. So lo and behold, it's the same. It's the same exponent as the previous denormalized number. So this is actually very clever by the IEEE folks, because you get this nice, smooth transition from D norms to norms to normalize. So you can see that our exponent e is -6 still. And now? Because we're taking one minus the bias 7 and are significant. 
现在，由于Exp字段非零，这不再是一个非规范化的数字。这是一个标准化的数字。所以现在我们将E的定义从1减去偏差更改为Exp减去偏差。在这种情况下，Exp是什么？1-7，偏差为-6。所以你瞧，它是一样的。它的指数与之前的非规范化数字相同。因此，这实际上是由IEEE人非常聪明的，因为你可以得到从D规范到规范的顺利过渡。所以你可以看到我们的指数e仍然是-6。现在呢？因为我们取1减去偏差7并且是显著的。



发言人   35:29
Now, remember, this is a normalized number because the Exp field is nonzero. A frack field of all zeros represents a significant of 1.000. So this is number is the most normalized number. 
现在，记住，这是一个规范化的数字，因为Exp字段是非零的。所有零的frack字段表示有效值1.000。所以这个数字是最规范化的数字。

发言人   35:51
Represents is 1.000, which is 8, 8 times 2 to the -6, which is one over 64, which gives us 8 over 512. So we've made this nice smooth transition from seven over five and 12 to 8 over 512. And I'll do one more. So if keeping the Exp field at 1, if we bump our frac field from 0 to 1, now this represents the sign of 1.0, 1.001, which is 8/8 plus one 8th. So that's 9, 8. And then the value is eighth times 2 to the. Minus six. Once 1 over 64, which is equal to 9 over 512, okay? Any questions about that? 
代表的是1.000，即8乘以2的-6，即1比64，这给我们8比512。所以我们已经完成了从7/5和12到8/512的顺利过渡。我还会做一个。因此，如果保持Exp字段为1，如果我们将frac字段从0提升到1，现在这代表1.0，1.001的符号，即8/8加1/8。所以这是9，8。然后该值是8乘2的。-6。一旦1超过64，就等于9超过512，好吗？有什么问题吗？

发言人   37:01
Question back here. Okay, the question is, why do you choose the bias that to be 2 to the k -1 -1? 
问题回到这里。好的，问题是，为什么你选择的偏差是2到k -1？


发言人   37:12
Go back to my finger diagram here. So this is the range of Exp fields that you want to. This is the range of e that you want to represent with 0 in the middle. And so you want to bias it so that this is halfway 0. The smallest exponent is halfway to 0. So you want the bias to shift it up. So it's the smallest, the smallest encoded. The smallest value of Exp corresponds to the smallest exponent, so two to the k -1 -1 is just giving you, it's giving you a value that's halfway between the smallest exponent and the largest exponent, okay? That's good, any other questions? 
回到这里我的手指图。所以这是您想要的Exp字段范围。这是您想要用中间的0来表示的e的范围。所以你想要偏差它，使它的一半为0。最小的指数是0的一半。所以你想让偏见向上移动。所以它是最小的，最小的编码。Exp的最小值对应于最小指数，所以k -1的2只是给你，它给你一个介于最小指数和最大指数之间的值，好吗？很好，还有其他问题吗？



发言人   38:07
OK, if we take like a little, a smaller 6 b format, same thing as we did before, just different numbers of bits and Exp and frac. And then we plot these on the number line. You can see that. The values are very dense, around 0. So they're very spaced very closely together. And then every time you increase the exponent by one. 
好的，如果我们采用一个较小的6 b格式，就像之前一样，只是不同的位数、Exp和frac。然后我们将它们绘制在数字线上。你可以看到。这些值非常密集，在0左右。所以它们之间间隔得非常紧密。然后每次将指数增加一。

发言人   38:36
The numbers are spaced twice. Twice as far apart as the numbers that were represented by the previous exponent. So you can see like in this little example, you see these values here are all equally spaced. Well, these four values are equally spaced, and they're right next to each other. And then you see this jump in the spacing that represents an increase in the Exp field by one. And then that spacing doubles as we go out. And you can see, you can see it even better here. If we zoom in, these blue values are, these blue values are D norms. 
这些数字的间距为两倍。距离是之前指数所表示数字的两倍。所以你可以看到，在这个小例子中，你可以看到这里的这些值都是等距的。这四个值是等间距的，它们紧挨着。然后你会看到这个间隔的跳跃，它代表了Exp字段增加了一个。然后，当我们外出时，间隔加倍。你可以看到，你可以在这里看得更好。如果我们放大，这些蓝色值是D范数。


发言人   39:30
And then we have the next set of normalized values where the frac field is one, There's the same. We saw this when we kept increasing by one over five. And then we increase the exponent by one, and the spacing doubles. 
然后我们有了下一组规范化值，其中frac字段是一个，它们是相同的。当我们不断增长1比5时，我们看到了这一点。然后我们将指数增加一，间距就会翻倍。


发言人   39:54
So like I mentioned, this encoding has some pretty nice properties. The floating point 0 is encoded as integer of 0, which is nice, and with the exception of. Not a number. With the exception of not a number, you can compare any floating point numbers, including infinity, by just treating it as doing an unsigned comparison. So that's really nice too. 
就像我提到的，这种编码有一些非常好的特性。浮点0被编码为0的整数，这很好，除了。不是一个数字。除了不是数字外，您可以将任何浮点数 (包括无穷大) 进行比较，只需将其视为进行无符号比较。这也很不错。

发言人   40:33
Now, if when you add and multiply floating point numbers, we're dealing with a limited set of bits here. So if we take two numbers, encode it as floating point, and we add them together, there's no guarantee that we'll be able to fit all those bits in the bits we have available to us. There's no guarantee that we'll be able to fit the bits in the result. So what? So what we do in this case is you can imagine the model. You want to have a floating point operations addition and multiplication is that you add or multiply, you do the addition or multiplication, and you compute the exact result. 
现在，如果当您将浮点数相加和相乘时，我们在这里处理的是有限的一组位。因此，如果我们将两个数字编码为浮点数，然后将它们相加，则不能保证我们能够将所有这些位都放入我们可用的位中。不能保证我们能够将位拟合到结果中。那又怎样？所以在这种情况下，我们所做的是你可以想象模型。你想要进行浮点运算加法和乘法，就是你做加法或乘法，然后计算确切的结果。

发言人   41:16
You just assume that you have an infinite amount, number of bits. And then you use a technique called rounding to get it to fit into the available bits. So the effect is doing, say, x plus y is getting the precise value of x plus y and an infinite number of bits, and then rounding into the available bits. 
你只是假设你有无限的数量，位数。然后您使用一种称为四舍五入的技术来使其适应可用位。这样的效果就是，比如说，x加y是得到x加y的精确值和无限数量的位，然后四舍五入到可用位。


发言人   41:42
So let's look at this idea of rounding. This can be confusing the first time you see it. It requires you need to think about it carefully to get it right. Now in IEEE, there's four different kinds of rounding round towards 0 round down, or round to minus infinity round up, which is rounding it to positive infinity. And then the default case, which is the only one we're really going to consider, is round to the nearest even. And this is what IEEE does by default. If you go into assembly language, you can change that rounding. But we're not going to consider it anymore. Yes, question? 
那么让我们来看看舍入的想法。这可能会让你第一次看到它感到困惑。它要求你仔细思考才能把它做好。现在在IEEE中，有四种不同的舍入为0舍入，或舍入为负无穷大舍入，即舍入为正无穷大。然后默认情况，也就是我们真正要考虑的唯一情况，是舍入到最接近的偶数。这就是IEEE默认做的事情。如果你进入汇编语言，你可以改变那个舍入。但我们不会再考虑它了。是的，有问题吗？


发言人   42:32
I'm sorry, is there negative in there? Is because one, so the question, is there a distinct negative infinity and a distinct positive infinity? And there is, they have the exact same bit representation, except the most significant bit for negative infinity is one, and for positive infinity, it's zero. 
抱歉，里面有负面的吗？是因为一个，所以问题是，是否存在明显的负无穷大和正无穷大？而且它们有完全相同的位表示，除了负无穷大的最高有效位是一，正无穷大的最高有效位是零。


发言人   43:00
White is nearest even. Oh I'll show you. Let me go over the other. The question was about nearest Stephen. Yes, doesn't that make nitrogen greater than, well, that was the exception right? Today? That's right, so aside from infinity, you can't do that comparison, positive infinity works right, but not negative, so you're right, good point. 
白色最近均匀。我来给你看看。让我超越另一个。这个问题是关于最近的斯蒂芬的。是的，这不是使氮大于，好吧，那是个例外，对吗？今天？这是对的，所以除了无穷大之外，你不能进行比较，积极的无穷大起作用，但不是消极的，所以你说得对，很好。

发言人   43:26
Alright, so let's look at these rounding modes and I'll explain why the nearest even works, but let's look at so rounding towards 0, what we're going to do, we'll use dollars. So we went around to the nearest dollar. Towards 0. Just anything less than you. Just round towards 0. So 1 dollar 40 cent would go to 1, 1 dollar 60 cent would go down to one, 1 dollar 50 to 1, 250 would go to two, negative 150, you round towards 0. So that would be negative one round down towards negative infinity. It's similar. The only difference is that for one point negative one dollar 50, you'd round towards negative infinity, which would be -2. 
好的，让我们来看看这些舍入模式，我将解释为什么最接近的偶数有效，但让我们看看向0舍入，我们将要做什么，我们将使用美元。所以我们绕到最近的美元。向0。只是比你更少的东西。就向0圆。所以1美元40美分会降到1美元，1美元60美分会降到1，1美元50到1，250美元会降到2，负150，你四舍五入到0。所以这将是负的，向下舍入负的无穷大。这很相似。唯一的区别是，对于1美元50的负点数，你会四舍五入到负无穷大，这将是-2。

发言人   44:15
Rounding up is the is symmetric to round down. The interesting case is. Round to nearest even interesting because it's what IEEE floating point actually uses. So the idea here, if you have a value that's less than half, then you round down. If you have a value that's more than halfway between 2 dollar amounts, you round up. The nearest Even part comes. When you have something that's exactly halfway, then what you do is you round towards the nearest even number. 
向上舍入是对称到向下舍入。有趣的案例是。舍入到最接近甚至有趣的，因为这就是IEEE浮点实际使用的。所以这里的想法是，如果你有一个小于一半的值，那么你就四舍五入。如果你的价值超过2美元金额的一半，你就四舍一入。最近的偶数部分出现了。当你有一个正好一半的东西时，你要做的是朝最近的偶数四舍五入。

发言人   45:00
In this example, 1 dollar 40 cent because it's less than half rounds down to 1 dollar 1 dollar 60 cents is greater than half. 
在这个例子中，1美元40美分因为不到半个舍入到1美元60美分大于一半。

发言人   45:10
So we round up to 2 dollars, one dollar 50 cent, right in the middle, we round up to the nearest even dollar amount, which is 2 dollars, 2 dollars 50 cents. We round down to the nearest. Even if we rounded up, it would be 3, which is odd number and -1 dollar 50 cents. We round to we round down to -2 dollars. So the reason we do this, the reason they chose this is that statistically, you would imagine if you have a uniform distribution of sort of numbers, they're going to round up or down about 50% of the time. So there won't be a statistical bias rounding up or down one way or the other. So that's the reason they did that. 
所以我们四舍五入到2美元，1美元50美分，就在中间，我们四舍五入到最接近的偶数美元金额，也就是2美元，2美元50美分。我们四舍五入到最近的。即使我们四舍五入，它也会是3，这是奇数和-1美元50美分。我们四舍二入到-2美元。所以我们这样做的原因，他们选择这个的原因是统计学上的，你会想象如果你有一个均匀的数字分布，它们会有50% 的时间向上或向下四舍五入。这样就不会有一个统计偏差向上或向下舍入或另一种方式。这就是他们这么做的原因。


发言人   46:06
Now you can apply this. You can do this rounding to any value. So in the last example, we did it to the nearest dollar. 
现在你可以应用这个了。您可以将其舍入为任何值。所以在最后一个例子中，我们把它做到了最接近的美元。

发言人   46:17
But suppose we wanted to round to the nearest 100th using round to even the default round to even mode. So we went to round to the. Nearest hundredth is the second position. 
但是假设我们想使用默认的偶数模式将其舍入到最接近的100个。所以我们去了轮。最近的百分之一是第二个位置。

发言人   46:34
First, do we have tenths? Then hundreds? So if we have a value 7.894999, that's less than halfway, right? Halfway would be halfway, would be any number that had a five, followed by all zeros. So 4 999 is less than that. So we would just round down to 7.89, even though 9 is odd. The only time we're going to apply round to even is when we're exactly halfway. Okay, the next example, 7.895001, that's greater than halfway. If if this was a 0, it would be exactly halfway, so we round up to 7.9. Now here's the interesting case where we have 7.895 followed by all zeros. That's exactly halfway. So now we apply the round to nearest even rule. 
首先，我们有十分之一吗？然后是几百个？所以如果我们有一个值7.894999，那就不到一半，对吗？一半将是一半，将是任何有五个数字，后面都是零。所以4 999比这少。所以我们将舍入到7.89，即使9是奇数。我们唯一一次要申请到甚至是在我们刚好完成了一半的时候。好的，下一个例子7.895001，比一半大。如果这是一个0，它正好是一半，所以我们四舍五入到7.9。现在这里有一个有趣的情况，我们有7.895后面都是零。这就是一半。所以现在我们将舍入应用到最近偶数规则。


发言人   47:43
Nine is an odd number, so that doesn't work. So we round up and we do that basically by adding, adding a five here. So 5 and 5 is 10, and then that carries over to the next position, and 9 and 1 is 0, 9 and 1 is 10, so that carries over. And so 8 and 8 plus 1 is 9. So the result of rounding up is 7.90. Is that clear that you see, it's a very mechanical way when you round up, it's a very mechanical like that, You always just add the half-way number, in this case 5, and then just propagate it out, just do the addition, and that'll give you the nearest, the nearest, that'll round you up to the nearest 100th in this case. 
9是一个奇数，所以这不起作用。所以我们向上四舍五入，基本上是通过添加来完成的，在这里添加五。所以5和5是10，然后这延续到下一个位置，而9和1是0，9和1是10，所以延续。所以8加1就是9。所以四舍五入的结果是7.90。你看得很清楚，当你向上取整时，这是一种非常机械的方式，它是一种非常机械的方式，你总是把一半的数字相加，在这种情况下是5，然后把它传播出去，只是做加法。这会给你最近的，最近的，在这种情况下，这将把你四舍五入到最接近的100个。

发言人   48:39
Now the last case, 7.885, followed by all zeros, that's another number that's halfway between. Between two numbers rounded to the nearest 100. So in this case, 8 is even. So we round down. And to round down, we just truncate, just throw bits, these digits away, and we get 7.88. 
现在是最后一种情况，7.885，后面跟着全零，这是另一个介于两者之间的数字。在两个舍入到最接近的100的数字之间。所以在这种情况下，8是偶数。所以我们四舍五入。而为了向下舍入，我们只需要截断，只扔掉这些数字，我们得到7.88。

发言人   49:08
So are there any questions about this? Question Beck here, yes. But so is it true that everything was the same components? 
那么对此有什么问题吗？问题贝克在这里，是的。但是，一切都是相同的组件，这是真的吗？

发言人   49:28
Yes, so the question was, numbers that have the same Exp field, will those numbers be equally spaced on the number line? And the answer is yes. Yes? Down. Like in the? Last, it would round up. Yeah, the only the half-way values are always in this case, because it's base 10, the half-way number in base 10 is 5, and so it's always the half-way number, in this case, 5, followed by all zeros. You always have the halfway. If the value is halfway between like 200, it'll always have that, that form. 
是的，那么问题是，具有相同Exp字段的数字，这些数字会在数字线上等距分布吗？答案是肯定的。是吗？下来。像在？最后，它会四舍五入。是的，在这种情况下，唯一的中途值始终是，因为它是以10为基数，以10为基数的中途数是5，因此它始终是中途数，在这种情况下是5，后面跟着全部零。你总是半途而废。如果该值介于200之间，它将始终具有那种形式。

发言人   50:26
Alright, now we can do the same thing with binary fractional numbers as well. Now a binary number is even if. Least significant digit is 0. We only have two digits. So odd is one and 0 is even and the halfway. So the half-way value is going to be a one followed by all zeros that represents exactly halfway. So it's analogous, analogous to the base 10 example, except where the half-way value is going to be one followed by all zeros. 
好的，现在我们也可以对二进制分数做同样的事情。现在二进制数是偶数。最小有效数字为0。我们只有两个数字。所以奇数是一，0是偶数，一半是。因此，半途值将是一个后跟所有零的数字，正好表示半途值。所以它是类似的，类似于以10为基数的例子，除了中途值将是一个后面全是零的地方。


发言人   51:08
So let's look at some examples. Suppose we have, we want to represent 2 in three and 30 seconds. And suppose we only have 4 b to do that in, Okay, well, to represent that exactly, we need. 7 b. And so we have to round. So let's look at, so we're going to round to this 2 b, right, of the binary point. And so let's look at all the bits that follow that. So since it starts with 0, this is going to be less than halfway. So since it's less than halfway, we just truncate, just chop those out, and the result is 1.00. 
让我们看一些例子。假设我们有，我们想要在3和30秒内表示2。假设我们只有4 b来完成这件事，好的，要准确地表示出来，我们需要。7 b.所以我们必须绕圈。那么让我们来看看，我们将四舍全为二进制点的这个2 b。那么让我们来看看它后面的所有位。因为它从0开始，所以这将小于一半。所以由于它不到一半，我们只需截断，切掉它们，结果就是1.00。

发言人   52:06
Now our next example is 1 0.00110. So if we look at these, the bits to the right of to the right of the bit we're rounding to, since it starts with one and it's not followed by all zeros, that's greater than half. In this case, we have to round up and so. The way we do that, we take one and we add it to this leftmost one right here and just do the addition. And the result is 1.01. 
现在我们的下一个例子是1 0.00110。所以如果我们看这些，我们四舍五入到的位右边的位，因为它从1开始并且后面没有全部零，那就大于一半。在这种情况下，我们必须四舍一入。我们这样做的方式是，取一个并将其添加到最左边的一个上，然后进行加法。结果是1.01。

发言人   52:48
Now let's look at 2 to the 7 eights. This is represented as one 0.11100. 
现在让我们来看看2的7个八点。这被表示为一个0.11100。

发言人   52:58
Now here's that halfway marker that we were looking for. It's a 1 followed by all 0. So this is exactly halfway. So now we have to round to the nearest even number. If we can't just truncate, because then it would be an odd number, it would end one, 0.11 is an odd number. So we have to round up. And we do that by adding, we do that by adding a one right here to this leftmost red bit. We add one to that, and then just do the addition. And we end up with 1 1.00, which is 3. So the nearest value to 2 to the 7th, 8th, the nearest rounded value is 3. 
现在这是我们正在寻找的半个标记。它是一个1，后跟全部0。所以这正好是一半。所以现在我们必须四舍五入到最接近的偶数。如果我们不能仅仅截断，因为它将是一个奇数，它将以1结束，0.11是一个奇数。所以我们必须围捕。我们通过添加来实现这一点，我们通过在最左边的红色位上添加一个来实现这一点。我们加一个，然后做加法。最后我们得到1.00，也就是3。所以最接近2的值到第7，第8，最接近的舍入值是3。

发言人   53:54
Okay, our last example, 2 to the 5 A's, we have the same halfway marker again, 1, 0, 0, but in this case, the hundredth bit or the one quarter bit is 0. So that's even. So we can just truncate, we just throw those bits away, and the result is simply one 0.10. It makes sense, so it's very mechanical. Mainly, you just need to be able to recognize that halfway marker and then figure out if you need to round up or down. If you're going to round down, just truncate. If you're going to round up, add a 1 and just propagate it to get your result. 
好的，我们的最后一个例子，2到5个A，我们再次有相同的中途标记，1，0，但在这种情况下，百分之一位或四分之一位是0。所以这是均匀的。所以我们可以截断，我们把那些位扔掉，结果只是0.10。它制造感知，所以非常机械化。主要来说，你只需要能够识别中途标记，然后弄清楚你是否需要向上或向下舍入。如果你要向下舍入，只需截断即可。如果你要向上舍入，加一个1，然后传播它来得到你的结果。


发言人   54:40
Okay? Now, we won't spend much time. I just want to mention a few things about multiplication and addition. 
好吗？现在，我们不会花太多时间。我只想提一些关于乘法和加法的事情。

发言人   54:51
So if we multiply two numbers, so we have different mantissa significance and exponents. And suppose that the result is. M times 2 to the e, the sine bit will be the Xor of the two sine bits, the 2 operons. The significant M will be multiplying M1 times M2, and the exponents are added just by the rules of exponents. So if m is, if m is greater than 2, and this is a normalized number, we have to. Put it in the range between one and two by shifting to the right and incrementing the exponent. If e is out of range, then we overflow to infinity. And then if m has too many bits, we have to use round to even to fit it into the available frac bits. 
所以如果我们将两个数相乘，那么我们有不同的尾数重要性和指数。假设结果是。M乘以2的e，正弦位将是两个正弦位 (两个操作数) 的Xor。有效M将乘以M1乘以M2，指数仅按指数规则相加。因此，如果m是，如果m大于2，并且这是一个规范化的数字，我们必须这样做。通过向右移动并增加指数，将其放在一到二之间。如果e超出范围，那么我们将溢出到无穷大。然后，如果m有太多位，我们必须使用舍入甚至以使其适应可用的frac位。

发言人   55:58
Addition, So suppose we're trying to add to floating point numbers. Conceptually, what you do is think of those numbers as fractional binary numbers. Line up the binary points, line up the binary points, then do the addition and. And then do the addition and then normalize the number so that the normalize the significance so that it's between one and 2. And either do that by shifting right or left. If E's too big, then you overflow, and then you round the bits in M to fit into the available frac field. 
另外，假设我们试图将浮点数相加。从概念上讲，你要做的就是将这些数视为分数二进制数。将二进制点排成一行，将二进制点排成一行，然后进行加法和。然后进行加法，然后对数字进行归一化，以便对其重要性进行归一化，使其在1到2之间。要么向右或向左移动。如果E太大，那么您将溢出，然后您将以M为单位对位进行舍入以适合可用的frac字段。


发言人   56:46
Now, remember when the first day of class, we talked about what we call these great realities, that ints aren't really integers and floats aren't really reals. And just as we saw when we looked at two's complement representation of integers, it's not exactly, they're not exactly like real integers, and operations on them aren't exactly like real integers. But they follow very predictable mathematical properties that are similar to integers, but not quite. So the same thing holds for floating point numbers. They follow very predictable, They have very predictable mathematical properties, but they're somewhat different from the reals. And the big thing is that the big thing with addition is that it doesn't associate it's commutative, but it's not associative. And this usually happens you when you're dealing with numbers that have very large dynamic ranges. 
现在，还记得第一天上课的时候，我们谈到了我们称之为伟大现实的东西，整数并不是真正的整数，浮动也不是真正的现实。就像我们在查看整数的补码表示时看到的那样，它不完全是，它们不完全像实整数，对它们的操作也不完全像实整数。但它们遵循非常可预测的数学属性，类似于整数，但不完全是。这同样适用于浮点数。它们遵循非常可预测的数学属性，但它们与雷亚尔有些不同。重要的是加法的重要之处在于它不关联它是可交换的，但它不是关联的。这通常发生在您处理具有非常大的动态范围的数字时。


发言人   57:57
If you're trying to add and subtract really big numbers with really little numbers, you run into this problem of non-associative. So the example was if we take 3.14 plus to the 10th to the 10th is so much larger than 3.14 that when the it be 2 to the 10th plus three 0.14, the bits that represent the 3.14, there's bits way out here that represent there's 1 b out here that represents 2 to the 10th, and then there's a few bits here that represent 3.14. And there's just not we don't have enough bits to represent all those 3.14 goes away. 
如果你试图用非常小的数字进行非常大的数字相加和相减，你会遇到这个非关联的问题。所以这个例子是，如果我们取3.14加上第10到第10，比3.14大得多，以至于当它是2到第10加上三个0.14时，代表3.14的位，这里有一些位元代表这里有1个b，代表2的第10个。然后这里有几个位代表3.14。我们没有足够的位来表示所有这些3.14消失了。


发言人   58:43
So adding a big number to a little number essentially gives the big number. And then if you subtract that big number, you get 0. Now, if we change the association, if we take this big number and subtracted it from itself, we get 0. And then so the result will be instead of 0 before we get 3.14. So other than that, you have all of the things that you would normally expect closed under addition. It's commutative. There's an additive identity of 0, except for infinities and Nans. There's an additive inverse you can take for any number. There's an inverse that'll give you zero when you add it together and you get monetisation. Monotonicity between values, except of course, for infinities and Nans. 
因此，将一个大的数字添加到一个小的数字上，本质上就给出了大的数字。然后，如果你减去那个大数字，你得到0。现在，如果我们改变关联，如果我们取这个大数字并从中减去它，我们得到0。然后，在我们得到3.14之前，结果将不是0。除此之外，你拥有了所有你通常期望在加法下关闭的东西。它是可交换的。有一个0的加法恒等式，除了无穷大和Nans。对于任何数字，你可以取一个加法逆。有一个反函数，当你把它加在一起时，它会给你零，你就会赚钱。值之间的单调性，当然除了无穷大和Nans。


发言人   59:41
Now multiplication has it's similar. You get it's closed generally under multiplication. It's communicating, but it's not associative, and it doesn't distribute over addition, and it's the same. 
现在乘法已经相似了。你得到它通常在乘法下是封闭的。它在交流，但它不是联想的，它不会在加法上分布，它是一样的。


发言人   59:58
So here you can see we're taking two to the 20th times 2 to the 20th times 2 to the 20th, so that gives infinity. But if we re-associate and we take I'm sorry to the times 2 to the 20th times 2 to the minus 20th, well, this first multiplication is infinity. And anything, anything you do with infinity is just infinity. So the result is infinity. However, if we reassociate and multiply two to the 20th times 2 to the minus 20th, that gives us one. And then multiply by two to the 20th, and so we get two to the 20th. So the big takeaway point here is that floating point. Floating point is an associative. 
所以在这里你可以看到我们把2的20次方乘以2的20，这样就得到了无穷大。但是如果我们重新关联，并且我们抱歉地将2乘以20次方2乘以-20，那么，第一次乘法是无限的。你用无穷大做的任何事情都是无穷大。所以结果是无限的。然而，如果我们重新关联并乘以2的20次方乘以2的负20次方，就得到1。然后乘以2到20号，这样我们得到2到20号。所以这里的主要要点是浮点数。浮点是联合的。

发言人   01:00:52
Now, is that a problem? It's something you have to be aware of. But generally, I mean I've done a lot of scientific computing, in particular modeling earthquake ground motion in Southern California. So basically we would build models of Southern California in the computer and then we would shake them, and then we would see how the ground moves in like Los Angeles. And that shaking, we used a numerical method called finite elements, and it used all floating point, single precision floating point numbers. And we never ran into a problem with this associativity. 
现在，这有问题吗？这是你必须意识到的事情。但总的来说，我的意思是我已经做了很多科学计算，特别是在南加州地震地面运动的建模方面。所以基本上我们会在计算机上建立南加州的模型，然后我们会震动它们，然后我们会看到地面如何像洛杉矶一样移动。在那个震动中，我们使用了一种称为有限元素的数值方法，它使用了所有的浮点数，单精度浮点数。我们从来没有遇到过这种关联性的问题。

发言人   01:01:36
We would do operations in different orders. We couldn't always guarantee that we would do the operations in the exact same order, but we never ran into a problem with this because nature in general is kind of smooth that if you look at the if one part of the ground is shaking like this and you look at the next part, it might be shaking a little more or a little less, but you're not going to have like huge differences. And so we never ran into those kind of problems. But in some, so generally, if you're simulating natural phenomena, you don't often see these kind of huge dynamic ranges. But other times, if it's not non-natural financial, maybe financial systems that use floating point, then you might see the larger dynamic ranges of numbers and it might become a problem. So as a programmer, you just generally have to be aware of this. You have to have a sense for the dynamic range of your numbers. And you have to keep in mind that if you re-associate or change the order of things, you may not get exactly the same, exactly the same answer. 
我们会以不同的顺序进行操作。我们不能总是保证我们会以完全相同的顺序进行操作，但我们从来没有遇到过这个问题，因为自然界一般是比较平滑的，如果你看一下地面的一部分像这样摇晃，你再看看下一部分，它可能会摇晃得更多或更少，但你不会有太大的差异。所以我们从来没有遇到过这种问题。但在某些情况下，一般来说，如果你在模拟自然现象，你通常不会看到这些巨大的动态范围。但其他时候，如果它不是非自然金融系统，也许是使用浮点数的金融系统，那么你可能会看到更大的数字动态范围，这可能会成为一个问题。所以作为一名程序员，你通常必须意识到这一点。你必须有一个数字动态范围的感知。你必须记住，如果你重新关联或改变事物的顺序，你可能不会得到完全相同的答案。

发言人   01:02:46
Now c gives us two different kinds of floating points. So the float is the IEEE single precision and double is the IEEE double precision. 
现在c给了我们两种不同类型的浮点数。所以浮点数是IEEE单精度，double是IEEE双精度。


发言人   01:02:58
Now, you remember when we did casting between ints and unsigned values back and forth, the cast never changed the bit representation, it just changed the way that, and in fact, it never even changed. How the Alu manipulated those bits. It's really just how we're interpreting and how we're viewing those, those values. However, when you do casts between floats and ints and doubles, the bit representation changes. So a cast here has a dramatic effect on the actual bits themselves. 
现在，你还记得当我们在int和unsigning值之间来回转换时，转换从未改变位表示，它只是改变了方式，事实上，它甚至从未改变。Alu是如何操纵这些比特的。这实际上只是我们如何解释和如何看待这些价值观。然而，当您在浮点数、整型和双精度值之间进行转换时，位表示会发生变化。所以这里的演员对实际的比特本身有戏剧性的影响。

发言人   01:03:35
Now, if we go from a double or a float to an int, it's going to truncate the fractional part and give us the. Give us the integer part and then round to fit. Oh, actually, no, there won't be. Okay, so think about this, how many there were. We said 23. 23 frac bits in. 
现在，如果我们从double或float转到int，它将截断小数部分并给我们。给我们整数部分，然后舍入以适合。哦，实际上，不会有。好的，想想看，有多少人。我们说23。23个压裂位。

发言人   01:04:16
I forget exactly how many in doubles. Anybody remember? It doesn't matter, it's some number. Well, no, it does matter. So for a float, if we cast a float to an int, we're casting 23, something that we can represent with 23, at most 23 frac bits into a 32 b in. So we'll never lose. So we'll never need to do any rounding. 
我忘记双打中有多少。有人记得吗？没关系，这是一个数字。好吧，不，这很重要。对于一个浮点数，如果我们将一个浮点数转换为int，我们将转换23，我们可以用23来表示的东西，最多23个frac位转换为32 b in。所以我们永远不会输。所以我们永远不需要进行任何舍入。

发言人   01:04:55
But double precision? 
但是双重精度？

发言人   01:05:01
Has 52 b. So there we might not be able to fit the represented integer into the int. So they'll have to be some rounding. 
有52个b。因此，我们可能无法将表示的整数放入int中。所以它们必须四舍五入。

发言人   01:05:44
Sorry PowerPoint crashed. 
抱歉，PowerPoint崩溃了。

发言人   01:06:23
Right now, if we cast, if we cast from an int to a double. We'll have enough bit so we won't lose anything, right? The 32 b will fit in the double precision frac field, but int to float, there's more bits than an int than there are in the frac field of a float. We'll have to do some rounding. So so casting works the same way as any other operation. You can think of it as just taking the assume. You have an infinite number of bits, get the exact result, and then round it to fit into the available bits. All right, so the final thing I want to do today is. 
现在，如果我们进行强制转换，如果我们从int转换为double。我们会有足够的，所以我们不会失去任何东西，对吧？32 b将适合双精度frac字段，但从int到float，比float的frac字段中的位数更多。我们必须做一些舍入。所以铸造的工作方式与任何其他操作相同。你可以把它想象成只是假设。你有无限数量的比特，得到确切的结果，然后将其舍入以适应可用的比特。好的，所以今天我想做的最后一件事是。

发言人   01:07:11
Sort of test your understanding. Solve some puzzles to test your understanding of these properties of floating point numbers. So imagine that we have three values, x is an, f is a float, and d is a double. And then we're evaluating the c expressions. Is x equal to int float x? 
有点考验你的理解力。解决一些难题，以测试您对浮点数的这些属性的理解。想象一下我们有三个值，x是an，f是浮点数，d是双精度。然后我们评估c表达式。x等于整数浮点x吗？


发言人   01:07:46
Or you can edit out the, you can edit out that other stuff. 
或者你可以编辑掉，你可以编辑掉其他的东西。


发言人   01:07:57
So what do you think? So if we take x, which is an int, cast it to a float, and then cast that back to an int, will that always be equal to x? No, because we lose some bits, right? We don't have enough frac bits in float. What about if we take x, cast it to a double, and then cast it back to end where we always get equivalent value? Because we have enough frac bits in double. 
你觉得呢？所以，如果我们取x，它是一个int，将其强制转换为一个浮点数，然后将其强制转换回一个int，这是否总是等于x？不，因为我们丢失了一些比特，对吧？我们在浮点数中没有足够的frac位。如果我们取x，将其转换为双精度值，然后将其转换回结尾，我们总是得到等价的值，那会怎么样？因为我们有足够的双倍frac位。

发言人   01:08:35
Now, what if we take a float F, cast it to a double, and then cast it back to a float? Will that always equal the original F? Yeah, what about the converse though? What if we take the double D, cast it to a float, and cast it back to a double no? How about this, how about if we take f, negate it, and then negate that again? Will that always equal f? Because we're just toggling a bit? 
现在，如果我们取一个浮点数F，将其强制转换为双精度浮点数，然后再将其强制转换回浮点数会怎么样？这将始终等于原始F吗？是的，那么反过来呢？如果我们把double D转换成float，再把它转换回double no，会怎么样？这个怎么样，如果我们取f，否定它，然后再否定它，怎么样？这总是等于f吗？因为我们只是稍微切换一下？

发言人   01:09:06
Okay, how about two over three equal 2 over 3.0? No, because two over three is 0 and two over 3.0 is a floating point value, two thirds, the floating point representation of two thirds. 
好的，三比二等于3.0怎么样？不，因为三的二分之一是0，而三的二分之一是浮点值，三分之二是浮点表示。

发言人   01:09:26
How about if the double d is less than 0? Does that imply that d times 2 is also less than 0 no matter what? Even if two times d overflows, it'll overflow to negative infinity, which is less than. Which is less than 0? OK, how about does the double d greater than f imply that minus f is greater than minus d? Yeah, that's that monotonicity. And again, it's just, yes, 3.0 was a float. 
如果double d小于0怎么办？这是否意味着无论如何，d乘以2也小于0？即使两次d溢出，它也会溢出到负无穷大，小于。哪个小于0？好的，双d比f大，这意味着负f比负d大吗？是的，这就是单调性。再说一遍，是的，3.0是浮动的。

发言人   01:10:06
Is that a float or a double? Oh, that's a good question. I think it'd be a floated. I think if you put there's an annotation in C to give it a double, but actually I'd have to check that out. And F, yeah, that's a good question. I don't know, we'd have to check. I'll have to go and look in the In the Sea guide. 
那是一个浮子还是一个替身？哦，这是个好问题。我认为它会是一个浮动的。我想如果你在C中输入一个注释来给它一个双倍，但实际上我必须检查一下。和F，是的，这是一个好问题。我不知道，我们必须检查一下。我得去找一本海上指南。

发言人   01:10:39
How about is d squared the double d squared always greater than or equal to 0? Yes, and how about does d plus f minus d always equal f? No, because of lack of associativity. Okay, so that was fun, right? Floating point's always fun. So anyway, the big thing is just to realize that floats aren't exactly really reals. They have very predictable properties and that they're not associative or they're not associative. And so you have to be careful about that. All right, we'll a good weekend and we'll see you on Tuesday. 
Dsquared的双dsquared总是大于或等于0吗？是的，那么d加f减d总是等于f呢？不，因为缺乏关联性。好吧，那很有趣，对吧？浮点运算总是很有趣。所以无论如何，最重要的事情就是意识到花车并不完全真实。它们具有非常可预测的特性，并且它们不是联想的或者它们不是联想的。所以你必须小心这一点。好的，我们周末会很愉快，我们将在礼拜三见。