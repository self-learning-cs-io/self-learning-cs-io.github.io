---
title: 深入理解计算机系统 006-Machine-Level Programming II, Control
date: 2025-10-12 10:00:05
---

发言人   00:01
Okay, let's continue on. In our coverage of machine level programming. The second in, I think a six part series. 
好的，我们继续。在我们的机器级别编程的覆盖范围内。第二部分，我认为是一个六部分系列。

发言人   00:12
As I mentioned yesterday, machine level programming is sort of the core of this course, that it gives you a set of tools and understanding that take you well beyond what your sort of average run of the mill, a programmer, software developer would know about. And it's very powerful in terms of your better understanding of the system, what goes wrong, why programs crash, what the meaning of those are. And so it's a fairly core part of the material as, you know, the data lab is due tonight and the next lab out is called the Bam lab, And I believe that's coming out tonight as well. So the Bam lab will rely on your ability to understand machine level code. So these two lectures will actually be enough to get you started on some of the earlier parts of that lab. 
正如我昨天提到的，机器编程是本课程的核心内容，它为您提供了一套工具和理解，使您远远超出了程序员和软件开发人员所知道的一般情况。而且它非常强大，可以帮助你更好地理解系统，什么出了问题，为什么程序崩溃，这些是什么意思。因此，这是材料的一个相当核心的部分，因为你知道，数据实验室今晚要进行，下一个实验室叫做Bam实验室，我相信今晚也会出现。所以Bam实验室将依赖于你理解机器级别代码的能力。所以这两次讲座实际上足以让你开始那个实验室的一些早期部分。


发言人   01:07
You'll learn a lot more at recitation on Monday, either in person or if you're viewing the recorded version of that, that will help you move along on bawab, like all the labs in this course, at least the first two, we give you a fair amount of time for them. But don't be fooled into thinking that means you can just slack off or work on other courses and then in the last few moments, jump in and finish this lab, the bomb lab. Once you get the hang of what you're doing, it's pretty, you can just kind of crank along. But there's a certain learning curve that we'll take you to even get started on it effectively. So don't put it off. 
在周一的朗诵课上，你会学到更多东西，无论是面对面学习还是观看录制的版本，这将帮助你在bawab上继续前进，就像本课程中的所有实验一样，至少前两个，我们会给你相当多的时间。但是不要被愚弄，认为这意味着你可以松懈或学习其他课程，然后在最后几分钟，跳进并完成这个实验室，这个炸弹实验室。一旦你掌握了你正在做的事情的窍门，它就很漂亮了，你可以继续前进。但是有一定的学习曲线，我们甚至会带你有效地开始学习。所以不要把它推迟。


发言人   01:59
What is this? 
这是什么？

发言人   02:12
So last time we introduced the very basic principles of machine level programming, the idea of there being special state, that you have access to the registers, which people came out class nest or register as part of memory know, are they part of the cache? Know they're special, they're different, they don't exist to AC level program. When you're programming in C, you don't have any visibility into them. And in general today, what we're going to do then is go beyond the sort of very basics and start talking about the control, how you control the flow of execution of instructions at the machine level, and how you use those techniques to implement basic constructs, conditional statements, loops, and switch statements. And then next time, we'll talk about procedures, which warrants a whole lecture of its own. 
所以上次我们介绍了机器编程的基本原理，即存在特殊状态的想法，您可以访问寄存器，人们从类嵌套或寄存器作为内存的一部分知道，它们是缓存的一部分吗？知道它们是特别的，它们是不同的，它们不存在于交流级别的程序。当你用C编程时，你对它们没有任何可见性。总的来说，今天我们要做的是超越基础知识，开始讨论控制，如何在机器层面上控制指令的执行流程，以及如何使用这些技术实现基本结构、条件语句、循环，和切换语句。然后下一次，我们将谈论流程，这值得一整个讲座。





发言人   03:05
So the X 86 and several machines of its generation have these curious good old 1 b flags that are called condition codes. And they're the basis of how conditional operations work. To a machine level programmer, then we talked last time that you have visibility of the set of registers and. The memory. But you also have more things. 
因此，x86和它这一代的几台机器都有这些奇怪的老式的1 b标志，称为条件代码。它们是条件运算工作的基础。对于一个机器级程序员来说，我们上次讨论过您可以查看一组寄存器和。记忆。但你也有更多的东西。


发言人   03:36
And this is only a partial list. Actually, there's more and more stuff that you can add to this picture. But we talked about in the 64 b x 8664, there's now 16 registers, 8 of which have names that are historic based on old x 86 stuff, and eight of which were introduced. And so they simply named those R 8 through R 15. And of these registers, for the most part, the only one that's really special is Rsp, it cystica pointer, it tells you where, and we'll learn a lot more about stacks starting next time, but it's sort of where the state is that manages the execution of procedures. And so you can't just use it or sell it in arbitrary ways. But the other ones, you more or less can with qualifications to that statement. 
这只是部分清单。实际上，有越来越多的东西可以添加到这张图片中。但是我们在64 b x 8664中讨论过，现在有16个寄存器，其中8个寄存器的名称是基于旧的x86名称，其中8个是引入的。因此，他们简单地将这些命名为R 8到R 15。在这些寄存器中，大多数情况下，唯一真正特别的是Rsp，它cystica指针，它告诉您在哪里，我们将在下次开始学习更多关于堆栈的知识，但它是管理过程执行的状态所在的地方。所以你不能以任意的方式使用或出售它。但其他人，你或多或少可以附带那个陈述的条件。

发言人   04:33
There's another register that they call the RP, which has nothing to do with death. It means the IP means instruction pointer in IA 32, it was called EIP and now it's called RI just like the registry used to be EA and now it's Rix. So all it contains is the address of the currently executing instruction. 
还有另一个他们称之为RP的寄存器，与死亡无关。这意味着IP意味着在IA 32中的指令指针，它被称为EIP，现在它被称为RI，就像注册表曾经是EA，现在是Rix一样。所以它所包含的只是当前执行指令的地址。

发言人   04:59
It's not a register that you access in a normal way, but you actually, there are tricks that you can find out what the value of that is. So that just tells you where in the program, what part of the program is currently being executed. 
它不是您以正常方式访问的注册表，但实际上，有一些技巧可以帮助您了解它的价值。这样就可以告诉你程序的哪个部分当前正在执行。

发言人   05:14
And then there's these things that are called condition codes, And we're only showing four. There's actually more like 8 of them, but not relevant to our general discussion that are all 1 b flags. And they get set not directly, but as a side effect of other operations that take place. And they're the basis for which conditional operation gets decided. 
然后还有这些被称为条件代码的东西，我们只展示四个。实际上有更多类似8个，但与我们的一般讨论无关，都是1 b标志。它们不是直接设置的，而是作为发生的其他操作的副作用设置的。它们是决定条件运算的基础。

发言人   05:38
Let's go through what those mean, and they're given names, but these names are actually useful to memorize what they mean. So Cf means that carry flag and that if you think of adding two numbers, think of them as two unsigned numbers, and you do the binary arithmetic, and sometimes an extra one pops out of the left hand, that's the carry bit. The numbers you added sort of were too big to be contained in the 32 or 64 b or even 16 or 8 b result. And so an extra bit was generated. That's called the carry bit. 
让我们来看看它们的意思，它们被命名，但这些名字实际上有助于记住它们的意思。所以Cf意味着进位标志，如果你想把两个数相加，把它们看作两个无符号的数，然后你进行二进制算术，有时左手会多弹出一个进位，那就是进位。您添加的数字太大，无法包含在32或64 b甚至16或8 b结果中。因此产生了一个额外的位。这就是所谓的进位位。


发言人   06:18
The zero flag is what it sounds like if the value you just computed is 0. These are set typically by arithmetic instructions by the way the S flag is set if the value is computed as a one. 
如果您刚刚计算的值为0，则零标志是听起来的样子。这些通常由算术指令设置，如果值被计算为1，则通过设置S标志的方式进行设置。

发言人   06:33
And the most significant bit, meaning it's a negative value, and the flag overflow flag is a tooth complement version of overflow. So in particular, if you remember from Data Lab, how do you know if if addition of two values is overflowed? Is that if signs of the operands are the same, but the sign of the result is different than that? So either you added two positive numbers and got a negative result that was a positive overflow, or you added two negative numbers and got a negative result that's negative overflow. You can't overflow if the two arguments are of opposite signs, right? 
和最高有效位，表示它是一个负值，标志溢出标志是溢出的补牙版本。所以特别是，如果你从数据实验室记得，你如何知道两个值的加法是否溢出？如果操作数的符号相同，但结果的符号不同？所以要么你添加了两个正数并得到了一个负结果，即正溢出，要么你添加了两个负数并得到了一个负结果，即负溢出。如果两个参数符号相反，你就不能溢出，对吗？

发言人   07:15
Those four flags get set as sort of normal activity by many of the instructions, not by our friend. The Lea instruction, which I mentioned is kind of a quirky instruction that GCC really likes a lot. And you'll see it in a lot of places. But in general, and most of the time, those flags get completely ignored because who cares? But they do show up at various points when you're doing conditional operations. 
这四个标志被许多指令设置为某种正常活动，而不是我们的朋友。我提到的Lea指令是一种古怪的指令，GCC非常喜欢。你会在很多地方看到它。但总的来说，大多数时候，这些旗帜被完全忽略了，因为谁在乎呢？但当你进行条件操作时，它们确实会在不同的时间点出现。

发言人   07:48
So there's some special instructions whose only effect is to set condition codes. And the one that you'll see is especially is called Compare CMP. And by the way, the cue at the end of these is all just a reflection of they're operating on 64 b words, quad word, as I said. So the comparison is sort of like a subtraction instruction, except that you don't, you don't do anything with the result. A normal subtraction instructions is like x minus equals y, read 2 numbers, but then it will store the result wherever x is stored. But compare just takes these two values, does the subtraction, and doesn't do anything with the result, but it will set these four conditioned flags And just a few things to keep in mind that are often what will be sources of confusion is remember that the arguments in the way we write them in machine code is the opposite of what you'd expect. 
因此，有一些特殊的指令，其唯一作用是设置条件代码。你会看到的那个特别被称为比较CMP。顺便说一句，这些结尾的提示只是它们操作在64 b单词上的反映，就像我说的那样，是四字。所以比较有点像减法指令，除了你不这样做，你不需要对结果做任何事情。一个普通的减法指令就像x减法等于y一样，读取2个数字，但它会将结果存储在x存储的任何地方。但是比较只取这两个值，进行减法，对结果不做任何处理，但是它将设置这四个条件标志，并且要记住的一些事情通常会成为混淆的来源，那就是记住，我们在机器代码中编写的参数与您所期望的相反。


发言人   08:55
By the way, somebody asked me last time there is sort of two dialects of assembly code used on x 86 machines. There's the one that's used by Intel and Microsoft, and we don't use it. And then there's the one that's sort of used by Linux systems, and that's the one we use, and they're different. And one of the quirks of them is they write their arguments in different order. So it will drive you crazy trying to read if you're familiar with one, it's like if you've ever tried to drive a car on the wrong side of the road, you often will crash or do bad things. 
顺便说一下，上次有人问我，x86机器上使用的汇编代码有两种方言。有一个是由英特尔和微软使用的，但我们不使用它。然后是Linux系统使用的那个，那就是我们使用的那个，它们是不同的。其中一个怪癖是他们以不同的顺序编写论点。所以如果你熟悉一个东西，尝试阅读会让你发疯，就像如果你曾经试图在路的错误一侧驾驶一辆车，你经常会发生车祸或做坏事。

发言人   09:35
So that's just an aside that what I find, by the way, when I'm looking at code and I see a compare instruction, I actually write as a comment, compare the two. But I flipped the order so that I'm sure that I sort of keep in my mind what the comparison was of. And so these flags get set according to the rules of subtraction. And so it turns out that the carry flag and the overflow flag, you have to sort of flip your sense of what happened because it's a subtraction rather than an addition. But it's the same general idea. So that sort of shows you one particular one and another instruction that you'll see whose only purpose in the world is to set condition flags, condition codes is the test instruction. 
所以这只是一个旁白，顺便说一下，当我查看代码时，我看到一条比较指令，我实际上是作为注释编写的，比较这两者。但我颠倒了顺序，这样我就能确定我记得比较的是什么。因此，这些标志根据减法规则进行设置。所以事实证明，进位标志和溢出标志，你必须翻转你所发生的事情的感知，因为它是减法而不是加法。但这是相同的一般想法。这样就可以向您展示一个特定的指令和另一个指令，您将看到它们的唯一目的是设置条件标志，条件代码是测试指令。

发言人   10:29
And this is typically used to compare as you think. It's when you have two values and you want to compare them to each other. And the test is, if you really just have one value and you want to see what it's like, is it 0? Is it negative? Those are the main things you care about. In fact, that's the only thing you can determine. But just because I guess they had, they had sort of a possibility of having two arguments to this, so they decided, well, let's go ahead and do it. 
这通常用于进行你想象中的比较。这是当你有两个值，并且想要将它们相互比较时。测试是，如果你真的只有一个值，你想看看它是什么样子，它是0吗？是负面的吗？这些是你关心的主要事情。事实上，这是你唯一能确定的事情。但只是因为我猜他们有可能有两个论点，所以他们决定，好吧，让我们继续做下去。

发言人   10:57
How do you have two arguments to attest instruction, what and the two results, and then test that value? So what you'll typically see is a test where both arguments are the same. So test q percent rix, comma percent Rix, where so that you're just any register to itself and one property of the and operation is it's what they call item potent, adding ending two things, the same things together gives you that same thing. So we can see these. And now, so I told you that's how the condition codes get set. 
你如何有两个参数来证明教学，什么和两个结果，然后测试这个值？所以你通常会看到两个参数相同的测试。所以测试q百分比里克斯，逗号百分比里克斯，这样你就只是任何对自身的寄存器，and操作的一个属性就是他们所说的项目有效，将两个相同的东西相加，同样的东西一起给你同样的东西。所以我们可以看到这些。现在，我告诉你这就是条件代码的设置方式。

发言人   11:39
Now, how do you actually read them? How do you make use of them? Well, there two, in principle, you can actually extract and get the condition code values directly out of this special status register, but that's very unusual to do that. What's more common is you either try to read it and set a 1 b flag based on the result in some other register, or you try and do a conditional branch. 
现在，你实际上是如何阅读它们的？你如何利用它们？原则上，您可以直接从这个特殊的状态寄存器中提取并获取条件代码值，但这样做非常不寻常。更常见的是，您要么尝试读取它并根据其他寄存器中的结果设置一个1 b标志，要么尝试进行条件分支。

发言人   12:07
So the first example where you try to read it in a way that you can make use of it is done with the set instruction, and you'll see there's a whole range of instructions, but the only difference is really just what the condition they're setting based on. 
因此，第一个例子中，你尝试以一种可以利用它的方式阅读它，这是通过set指令完成的，你会看到有一整套指令，但唯一的区别实际上只是它们基于什么条件设置。


发言人   12:27
So what the set instruction does is it sets a single byte of a single register to either one or 0. And the basis for whether it sets it to one or to 0 is based on what the condition codes are In essence, what happened to your most recent instruction beforehand? Was it an arithmetic instruction or a set instruction, or a test instruction or a compare instruction? And as you can see, they're all based on a logical combination of these condition codes that correspond to what the names imply. So for example, the set S instruction is true if the sine flag is true, meaning that the most recent result was negative and those other ones less than, less than or equal to are two's complement comparisons. They have to take into consideration, did the most recent result cause an overflow or not? Because that will affect the result of the comparison. So that's part of the reason we tortured you with understanding two's complement arithmetic and how you compare results, making you understand the bit level behavior. 
所以set指令的作用是将单个寄存器的单个字节设置为1或0。并且它是将其设置为1还是0的基础是基于条件代码本质上是什么，您之前的最新指令发生了什么事情？它是算术指令还是集合指令，还是测试指令或比较指令？正如你所看到的，它们都是基于这些条件代码的逻辑组合，这些代码对应于名称的含义。因此，例如，如果sine标志为真，则set指令为真，这意味着最近的结果是负数，而那些小于、小于或等于的其他结果是两个补数的比较。他们必须考虑，最近的结果是否导致溢出？因为这会影响比较的结果。所以这就是我们折磨你理解2的补码算术以及如何比较结果的部分原因，让你理解位级行为。

发言人   13:48
Do so that you can understand what these instructions do. So we're cruel, but we have a reason for our cruelty. So you say 1 B, how do you deal with 1 B? Well, here's another thing we didn't tell you yet, and we're going to keep telling you more stuff over and over again. It turns out for every one of these 16 registers, you can directly set the lowest order byte of it to either 0 or 1 and won't affect it. Turns out it doesn't affect any of the other 7 B of that register. And they all have quirky names. The L means low and there. So here's an example of putting all this together to do something that's vaguely useful. 
这样你就能理解这些指令的作用。所以我们很残忍，但我们的残忍是有原因的。所以你说1 B，你如何处理1 B？嗯，还有一件事我们还没有告诉你，我们会一遍又一遍地告诉你更多的东西。事实证明，对于这16个寄存器中的每一个，您可以直接将其最低顺序字节设置为0或1，并且不会影响它。结果它不影响该寄存器的其他7个B中的任何一个。他们都有古怪的名字。L的意思是低和那里。所以这里有一个例子，将所有这些结合在一起做一些模糊有用的事情。


发言人   14:42
Suppose I want to function GT that will take two numbers and compare them and set the result, return a result value of one. If x is greater than y and 0 otherwise. And so here's the assembly code with some tabbing problems. Fix this kind thing bugs me, hold on. 
假设我想要函数GT，它将接受两个数字并比较它们并设置结果，返回结果值为一。如果x大于y，否则为0。这里是有一些制表符问题的汇编代码。解决这种困扰我的事情，坚持住。

发言人   15:14
I might not want to try and do this. 
我可能不想尝试这样做。

发言人   15:30
Well, nope, I will fix this later. Anyways, it's not the end of the world. 
好吧，不，我以后会解决这个问题。不管怎样，这不是世界末日。

发言人   15:42
Normally in assembly code, 1 thing you've noticed is that the instructions are indented by a tab space. And the only thing that's way over in the left margin are in way. So this is just sort of. The asselar is actually quite tolerant of formatting things, but this isn't the way it normally looks. So anyways, the point is there's a comparison. 
通常在汇编代码中，您注意到的一件事是指令由制表符空格缩进。而左边唯一超过的东西就是在路上。所以这只是某种程度上的。该asselar实际上是相当宽容的格式化的东西，但这不是它通常看起来的方式。所以无论如何，重点是有一个比较。


发言人   16:07
One rule that you need to understand about procedure is that the first argument is passed in register RDI in the second and register RSI, and that if I'm going to return a result from a function, I do that by storing it and register Rix before I return. So the first instruction compares these two. And you notice how I flipped the order. It says RSI, which is y, and RDI, which is x, but when I annotate it, I say x to y, so that I mentally I'm thinking in the order that the actual comparison is made rather than the way they're listed. So I always do that when I'm looking at code to help me flip those two around. 
你需要了解的关于过程的一条规则是，第一个参数在第二个寄存器RDI和寄存器RSI中传递，如果我要从一个函数返回结果，我可以通过存储它并在我返回之前注册Rix来实现。所以第一个指令比较这两个指令。你注意到我是如何翻转顺序的。它说RSI，即y，RDI，即x，但是当我注释它时，我会说x到y，这样我心里就会按照实际比较的顺序进行思考，而不是按照它们列出的方式。所以当我查看代码时，我总是这样做，以帮助我翻转这两个方面。

发言人   16:53
And then here's our instruction. So that compare instruction set, these four condition code registries. And now the set G says, now set this single byte register, the lowest byte of Rax to 0, 1. The result was the comparison was greater. 
然后这是我们的指示。以便比较指令集，这四个条件代码注册表。现在设置G说，现在将这个单字节寄存器，即Rax的最低字节设置为0，1。结果是比较性更大。

发言人   17:13
So according to this rule. And the effect of that was to set just this 1 B of this 8 B register to either 0 or 1. Now, my problem is that these remaining 7 B have whatever happened to be there before. And I want it to be all zeros. So the way it does it is a bit weird. 
所以根据这个规则。而这样做的效果是将这个8 b寄存器中的这1 b设置为0或1。现在，我的问题是这些剩下的7 b之前碰巧在那里。我希望它全部是零。所以它的操作方式有点奇怪。

发言人   17:44
There's an instruction called move with 0 extension byte too long. Yeah, you get to know these better with time. And what that means is you can actually copy a byte from any place, like the low order byte of some other register into a new register. And you'll put zeros to the left of it. That's what they mean by zero extension. That seems logical. But one thing you'll notice is the destination here is EA, which you'll recall, although it doesn't show here, that's the lower 32 b of register rax. And then you'd say, well, that only got me halfway there. 
有一个名为 “移动” 的指令，其0扩展字节太长。是的，随着时间的推移，你会更了解这些。这意味着你实际上可以从任何地方复制一个字节，就像把其他寄存器的低位字节复制到一个新寄存器中一样。你会在它的左边放零。这就是他们所说的零扩展的意思。这似乎是合乎逻辑的。但是你会注意到的一件事是，这里的目的地是EA，你会记得，虽然这里没有显示，但那是寄存器rax的低32 b。然后你会说，好吧，这只让我走了一半。

发言人   18:33
How do I make sure the upper 32 b are set to 0? Well, one of the weird quirks of X 8664 is for any computation where the result is a 32 b result, it'll add zeros to the remaining 32 b of the register. And it's different. For example, the byte level operations, only the bytes 2 B, or operations like what you'd have if the data type were short, only affect those 2 B. But the 4 B instructions set the upper bytes to 0, and that was some somebody at AMD, and I don't know who it is decided this was a good idea. 
我如何确保上限32 b设置为0？好吧，X 8664的一个奇怪的怪癖是，对于任何结果是32 b的计算，它会向寄存器的剩余32 b添加零。这是不同的。例如，字节级操作，只有字节2 B，或者数据类型短的情况下所拥有的操作，只会影响那些2 B。但是4 b指令将高字节设置为0，这是有人在AMD，我不知道是谁决定这是一个好主意。


发言人   19:21
And it might be a good idea, but it's really confusing. But that's something you'll have to just sort of remember in the back of your mind when you see things like this. So the effect of this instruction is to take this 1 B result, which is the lower order byte of register Rax, copy it to the same place as it already is, but then set the remaining 7 B to 0, which is what we want. So you'll see this pattern quite often. 
这可能是个好主意，但它确实令人困惑。但当你看到这样的事情时，你必须在脑海中记住这一点。所以这个指令的作用是将这个1 B的结果，也就是寄存器Rax的低位字节，复制到它已经存在的位置，但是然后将剩余的7 B设置为0，这就是我们想要的。所以你会经常看到这种模式。

发言人   19:56
Question, got it. OK, so now that's sort of sometimes I want to do this. I just want to get a 1 b flag as a result of the comparison. But more generally, I want to do something with that information and not just set 1 b. So the simplest version is what about a conditional and if and possibly an else? Well, that's done by, there's actually two ways to do it. So we'll go through the sort of general purpose, traditional way, and then we'll show the more specialized, a newer way, and we'll compare those. 
问题，明白了。好的，现在有时候我想这样做。我只想通过比较得到一个1 b的标志。但更一般地说，我想对这些信息做点什么，而不仅仅是设置1 b。所以最简单的版本是条件和如果以及可能的其他？好的，那是通过完成的，实际上有两种方法可以做到。因此，我们将介绍一种通用的、传统的方式，然后我们将展示更专业的、更新的方式，并进行比较。

发言人   20:35
So the traditional way is to use what's known as a jump instruction and a jump instruction. Normally instructions execute in a particular order, just like when you're writing a program and you write a series of statements, they execute one after the next. A jump instruction is a way you can go from wherever you are to someplace else and either skip over some instructions or jump back to some other previous position or wherever. And there's two kinds of jumps, unconditional, Well, there's several kinds. But an unconditional jump means when I say jump, you jump. But there's other conditional jumps that will actually only do that jumping if the condition codes are set appropriately. And you'll see that the names of these jump instructions are the same as the set instructions with the same conditions. So there's a variety of different reasons that the program may be given to either jump or not jump. 
所以传统的方法是使用所谓的跳转指令和跳转指令。通常指令以特定的顺序执行，就像当你编写一个程序时，你编写一系列语句，它们一个接一个地执行。跳转指令是一种方式，您可以从任何地方到其他地方，跳过一些指令或跳回其他先前的位置或任何地方。有两种跳跃方式，无条件的，有好几种。但是无条件跳跃意味着当我说跳跃时，你就跳了。但还有其他条件跳跃，只有在条件代码设置适当时才会真正进行跳跃。你会看到这些跳转指令的名称与具有相同条件的set指令的名称相同。因此，程序可能会被赋予跳跃或不跳跃的各种不同原因。


发言人   21:39
So I'm going to use this one example to show you several different versions of it. And like everything you'll see here, these particular programs aren't that useful. They illustrate ideas. 
所以我将使用这个例子向您展示它的几个不同版本。就像你在这里看到的所有东西一样，这些特定的程序并不是那么有用。他们阐述了想法。


发言人   21:53
So imagine I wanted to compute the difference of two values and then take their absolute value. So there's various ways you can imagine doing it, By the way I'm going to do it is decide to either subtract y from x or x from y, depending on the relative values of those two. And of course, the astute observer will notice that this has problems if you have a team in somewhere, if the result, because there's no absolute value, but we're not going to worry about that. So in other words, I just want to say, if x is greater than y, then I want to subtract y from x, and if x is less than or equal to y, I want to subtract x from y, and here's the code for it, where the blue and the red are color coding the different parts of it. 
想象一下，我想计算两个值的差，然后取它们的绝对值。所以有各种各样的方法可以想象，顺便说一下，我要做的是决定从x中减去y或从y中减去x，具体取决于这两者的相对值。当然，精明的观察者会注意到，如果你在某个地方有一个团队，这会有问题，如果结果，因为没有绝对的价值，但我们不会担心那个。换句话说，我只想说，如果x大于y，那么我想从x中减去y，如果x小于或等于y，我想从y中减去x，这是它的代码，其中蓝色和红色是不同部分的颜色编码。

发言人   22:46
So here you see the compare instruction, and again I've written them out in the reverse order to help me keep track of what the comparison is. And it says I'm going to compare x and y and if x is less than or equal to y I want to jump to a location specified by this label l 4. And so in general, in assembly code, if you give a name and then a colon, what's to the left of that is called a label. And it's just a tag that's only visible in the assembly code. It's not actually in the object code that will later be used to compute an address for determining that will encode where this jump will actually land. 
所以在这里你看到了比较指令，我再次以相反的顺序写出它们，以帮助我跟踪比较的内容。它说我要比较x和y，如果x小于或等于y，我想跳转到这个标签l4指定的位置。所以一般来说，在汇编代码中，如果你给出一个名字和一个冒号，它左边的东西叫做标签。它只是一个仅在汇编代码中可见的标签。它实际上不在对象代码中，稍后将用于计算地址，以确定该地址将编码此跳跃实际降落的位置。

发言人   23:37
When you're looking at assembly code, one of the features it provides is a little bit easier way to understand it than to look at addresses. And so it just tells you to be looking at that the jump would occur to this position. And what you'll see here is. 
当您查看汇编代码时，它提供的功能之一是比查看地址更容易理解它。所以它只是告诉你要注意这个位置会发生跳跃。你将在这里看到的是。

发言人   23:55
In these two branches, the blue code versus the red, what you're doing is in one case, subtracting y from x here, you move x into rax, and then you subtract y from it. And here you do the opposite. You're subtracting x from y? In this case, so in the first case, you'll make the jump of x is less than or equal to y, you subtract y from x, and you'll do a return. 
在这两个分支中，蓝色代码与红色代码，你所做的是在一种情况下，从这里的x减去y，你将x移动到rax，然后你从中减去y。在这里，你做的是相反的。你要从y中减去x？在这种情况下，在第一种情况下，您将使x的跳跃小于或等于y，从x中减去y，然后执行返回。

发言人   24:29
And you remember that I don't have to do anything special to return a value back from a function. All I have to do is stick it and register IX, and the calling function will know that's where to find the return value. So here it does a rep, and here it does a subtraction. And it simply does a return directly from that part. Of it. So it's a pretty straightforward piece of code. But you can see it's using this jumping to create two different parts of code that get executed under different conditions. What's that? I'm sorry, I didn't hear him. 
你要记得，我不需要做任何特别的事情就可以从一个函数返回值。我所要做的就是粘贴它并注册IX，调用函数将知道在哪里找到返回值。这里做一个rep，这里做一个减法。它只是直接从那部分返回。关于它。所以这是一个相当简单的代码。但是你可以看到它正在使用这种跳跃来创建在不同条件下执行的两个不同代码部分。那是什么？对不起，我没有听到他说话。


发言人   25:15
Oh, well, there's a couple things. One is you want the result to end up in Rex. And remember, subtract all those arithmetic instructions are just two argument instructions. You take two values and then the second argument, the destination argument, you overwrite what was there with the new result. So this is a pretty typical pattern. You'll see you move some value, a register, and then into Rex is very common, and then you do some arithmatic operation with that register as a destination to kind of update it. It's like if you were writing and see if all the time you had to write sort of x plus equals something, x minus equals, and all your arithmetic had to be expressed in those terms. 
哦，有几件事情。一个是你希望结果以雷克斯结束。并记住，减去所有这些算术指令只是两个参数指令。你取两个值，然后第二个参数，目标参数，你用新的结果覆盖那里的内容。所以这是一个非常典型的模式。你会看到你移动了一些值，一个寄存器，然后进入Rex是非常常见的，然后你用这个寄存器作为目标进行一些算术操作来更新它。这就像你在写作，看看你是否一直需要写一些x + 等于，x-等于，你所有的算术都必须用这些术语来表达。


发言人   26:14
Okay, so it's fun to look at assembly code for about 5 minutes, and then you get sick of it. 
好的，看大约5分钟的汇编代码很有趣，然后你就厌倦了它。

发言人   26:23
So one thing to sort of present these same ideas, but give it in a little bit more abstract form, is to write it in C, but in a form of C that looks a lot like assembly code. And in particular, one of the features of C that is not generally advertised, there's a statement called go to, and you can put labels in your code. And you can tell the program that if something happens, then you want to jump to that part of the program. So it looks a lot like that assembly code, right, that you saw jump jle is sort of what this says. 
因此，有一件事可以呈现相同的想法，但又可以给它一些更抽象的形式，那就是用C语言编写它，但是用一种看起来很像汇编代码的C语言形式。特别是，C的一个特性通常没有宣传，有一个叫做go到的语句，你可以在代码中放置标签。你可以告诉程序，如果发生了什么事情，那么你想跳转到程序的那部分。所以它看起来很像那个汇编代码，对吧，你看到jump jle就是这个意思。


发言人   27:09
It's like I'm doing a test. And then if the test, which in this case I call it N test because it's the opposite of the test that's in the original program, and if that end test condition holds, I want to jump to another part of the program I'm calling elts. And you notice I uppercase that because it's not the actual elses of an if then elses. And similarly, if this one is, well, actually to be most accurate, I should have simply said return result from this point. This code's a little bit out of date. So I should have said return result. But another version would be to have done a go to down to here and return the result from there. 
这就像我在做一个测试。然后，如果测试 (在这种情况下，我称之为N测试，因为它与原始程序中的测试相反，并且如果结束测试条件成立，我想跳转到程序的另一部分，我称之为elts。你会注意到大写的那个，因为它不是if then elses的实际情况。同样地，如果这个实际上是最准确的，我应该简单地说从这一点返回结果。这段代码有点过时了。所以我应该说一下返回结果。但另一个版本是向下转到这里并从那里返回结果。


发言人   27:56
And you'll see different compilers generate in different forms. So I'm going to typically use this way of presenting code just so that you can look at and understand what these control structures look like without having to sort of scrutinize the low level assembly code instructions. So we can sort of take this question. 
你会看到不同的编译器以不同的形式生成。所以我通常会使用这种方式来呈现代码，这样你就可以查看和理解这些控制结构是什么样子，而不必仔细检查低级汇编代码指令。这样我们就可以回答这个问题了。


发言人   28:27
Is there? You? Do. I think there's a homework or a practice problem of exactly that sort In general, do it neither way. And why the compiler picks one versus the other is I think it's a completely arbitrary decision, but consistently I have found GCC does it this way. 
有吗？你呢？做。我认为有一个家庭作业或练习问题通常就是这种类型的，不做任何一种方式。为什么编译器选择一个而不是另一个，我认为这是一个完全武断的决定，但我一直发现GCC是这样做的。

发言人   28:47
Okay? So let's sort of talk, sort of imagine you're writing a compiler. How would you take this special case I just showed and generalize it into a rule for compiling if then else's expressions? And I'm going to use the version and see the question mark colon version where encapsulate that whole conditional is a single expression rather than the statement. But you can understand that these rules would be the same in either case. 
好吗？让我们来谈谈，想象一下你正在编写一个编译器。你将如何处理我刚刚展示的这种特殊情况，并将其推广为编译规则，如果那么else的表达式？我将使用该版本并查看问号冒号版本，其中封装整个条件是单个表达式而不是语句。但是你可以理解这些规则在任何一种情况下都是相同的。

发言人   29:20
So imagine in general, you had AC code where there's a test controlling whether to return the result of one expression or another. And this is what my EBS diff code would look like if I wrote it in that form. And so in general, what we can say is what we'll do is we'll take the test and invert it and say, if that test is not true, then we will. So if n test is true, then we will jump to compiled the code, where we've compiled the code for the elts expression. And if that test fails here, so that the original test condition holds, then we'll stick in whatever code it takes to compute the then expression. 
想象一下，在一般情况下，你有交流代码，其中有一个测试控制是否返回一个表达式的结果。如果我用那个格式写的代码，这就是我的EBS diff代码的样子。因此，总的来说，我们可以说的是我们将进行测试并将其反转并说，如果该测试不正确，那么我们就会这样做。因此，如果n test为真，那么我们将跳转到编译的代码，在那里我们已经编译了elts表达式的代码。如果测试在此处失败，那么原始测试条件成立，那么我们将坚持使用计算then表达式所需的任何代码。


发言人   30:21
And then we'll merge back together In the case you saw, where it's just a single little function, we can just call it rep here and get out of the thing. But if this is one line of code, and then there's a whole bunch of lines after that, typically you want to merge back together again and continue from there. And so that's what this shows. I'll finish by going to whatever it comes afterwards. 
然后我们将在您看到的案例中重新合并，其中它只是一个小函数，我们可以在这里称其为rep并摆脱它。但如果这是一行代码，然后在那之后还有一大堆行，通常你想再次合并在一起并从那里继续。这就是它所展示的。我最后会去看看之后会发生的任何事情。

发言人   30:45
So this is a way I like to, although we're not writing compilers in this course, I think it helps to think in terms of general rules of how a compiler would translate C code into assembly code so that when you see that assembly code, you'll recognize these patterns and know what they mean. 
所以这是我喜欢的一种方式，尽管我们在这门课程中没有编写编译器，但我认为从编译器如何将C代码转换为汇编代码的一般规则方面思考是有帮助的，这样当你看到汇编代码时，你会认识到这些模式并知道它们的意思。

发言人   31:04
Question, after you go to the else clause, does it fall through to the done or yes? Yes, so just as we saw, yes, in general, like here, it would fall through to the done. Good question. OK, so that's one version of conditional. And that's the most general way. And the way it used to always be done. 
问题，在你转到else子句之后，它是落在完成还是是的？是的，正如我们所看到的，是的，一般来说，就像在这里，它会落在完成。好问题。好的，这是一种形式的条件。这是最普遍的方法。以及它过去一直被做的方式。

发言人   31:32
But there's another approach that you'll see fairly common in code. It's sort of an optimization called conditional move. And it's been non-intuitive from a software developer's perspective of why you'd ever want to do this. 
但是还有另一种在代码中相当常见的方法。这是一种被称为条件移动的优化。从软件开发人员的角度来看，你为什么想要这样做是不直观的。


发言人   31:48
The basic idea is I'm going to compute both then and the elses, the values they'd produce. And only after that, I choose which 1 I use. So it seems wasteful, but it actually turns out to be more efficient if they're fairly simple computations. And the reason of that is, and we'll see a little bit more when we talk about performance optimization, a modern processor is a little like an oil tanker sailing in the sea, meaning that it plows along in a certain direction and it really is hard to get it to stop or to turn. So you say, what are you talking about? Think of an instruction sequence is the ocean of code that you're cruising through, and these things can just fly through a straight sequence of code because they do what they call pipelining, meaning they start bringing in parts of one instruction before they're done with the next and actually go up to depths of 20 or more instructions deep of how far ahead they're working, sort of fetching forward and future instructions while finishing up the ones that still remain. So that's my ocean line, my tanker analogy. 
基本的想法是我将同时计算它们和其他东西，它们产生的值。只有在那之后，我才选择我使用的1。看起来很浪费，但实际上，如果它们是相当简单的计算，它会更有效。原因是，当我们谈论性能优化时，我们会看到更多，现代处理器有点像在海上航行的油轮，这意味着它沿着某个方向前进，真的很难让它停下来或转弯。所以你说，你在说什么？把指令序列想象成你正在浏览的代码海洋，这些东西可以在直的代码序列中快速浏览，因为它们执行所谓的流水线操作。这意味着他们在完成下一个指令之前开始引入一个指令的某些部分，并实际达到20个或更多指令的深度，达到他们工作的深度，在完成剩余指令的同时向前和未来的指令。这就是我的海洋线，我的油轮类比。

发言人   33:06
But all of a sudden, you come, and then what happens when they hit a branch? They'll try to guess. It's called branch prediction. And guess is this branch going to go, where will the conditional branch be taken, or is it going to fall through? And they're pretty good at that, They're good at it 98% of the time. 
但是突然之间，你来了，当他们撞到树枝时会发生什么？他们会试着猜测。这叫做分支预测。并猜测这个分支将要去哪里，条件分支将被采取，还是会失败？他们在这方面相当擅长，他们在98% 的时间都擅长。


发言人   33:29
Anticipate PSE of curves in the road. My analogy is breaking down and start going in that direction. And as long as they get it right, it's very efficient. But if they get it wrong, it's as if you have to stop the thing, back it up, turn the other way, start again, and that can take 40 instructions, 40 clock cycles, say, to do in bad situations. And this is pretty common if you think of like an absolute value, can you predict whether a value is going to be positive or negative? Not usually, So about half the time, whatever you guess, you're going to guess wrong. So these conditional move instructions, it turns out it's much easier to just plow through, compute both, and then at the last minute, all you have to do is move a value into a register or not. And that doesn't require stopping the whole processor and making this turn. 
预测道路上的曲线。我的类比是分解并开始朝那个方向前进。只要他们做对了，这是非常有效的。但如果他们弄错了，就好像你必须停止这件事情，备份它，转向另一个方向，重新开始，这可能需要40条指令，40个时钟周期，在糟糕的情况下才能完成。如果你把它想象成一个绝对值，这很常见，你能预测一个值是正的还是负的吗？通常不会，所以大约有一半的时间，无论你猜到什么，你都会猜错的。所以这些有条件的移动指令，事实证明只需犁过，计算两者都更容易，然后在最后一刻，你所要做的就是将一个值移动到一个寄存器中。这不需要停止整个处理器并进行此操作。

发言人   34:30
So that's my long explanation for. 
这就是我长时间的解释。

发言人   34:34
And if you don't want to understand that I'll just say, well, just trust me, it's a good idea sometimes. So the general pattern then, if I use this same idea, is I want to compute both results. And I'll call the result. And this is an eval. This is eval, the else's value. I'll compute both of them. I'll do my test, and then this red thing, imagine that it's all done with a single instruction that says I'll copy the value of eval to result, but only if a condition holds. That's why it's called a conditional move. And we'll see. 
如果你不想理解，我就说，相信我，有时候这是个好主意。因此，如果我使用相同的想法，那么一般的模式是我想计算两个结果。我会通知结果。这是一个评估。这是eval，else的值。我将计算它们两个。我会做我的测试，然后这个红色的东西，想象一下，这一切都是通过一条指令完成的，指令说我会将eval的值复制到结果中，但前提是条件成立。这就是为什么它被称为条件移动。我们会看到的。

发言人   35:15
This is the code, by the way, you saw in my original version. 
顺便说一下，这是你在我的原始版本中看到的代码。

发言人   35:19
Sorry to have to jump back. I had to explicitly tell the GCC, don't use conditional moves because it really wants to very badly. And so you have to force it not to. And I did that here. So here's the actual code then. And again, you'll see the color coding that it's doing both subtractions. It's actually doing the move and subtract, move and subtract. So it's doing both the branches you saw before, the then and the elses branch, it's doing a comparison. 
抱歉，我得跳回去。我必须明确告诉GCC，不要使用条件移动，因为它真的想要非常糟糕。所以你必须强迫它不要这样做。我在这里做到了。那么这是实际的代码。再一次，你会看到颜色编码，它正在进行两个减法。它实际上是在移动和减去，移动和减去。所以它正在处理你之前看到的两个分支，即then分支和elses分支，它正在进行比较。


发言人   36:00
And then here's the conditional move, instruction C move. In this case, the L here is not a word size. It's the less than or equal to direction. So in the case that I need the red value, basically you saw the red value is stored in register RDX. In that case, I will copy it into the result register. So again, it's like this idea of just go ahead and do everything and then pick at the last end. 
然后这是条件移动，指令C移动。在这种情况下，这里的L不是单词大小。它小于或等于方向。所以在我需要红色值的情况下，基本上你看到红色值存储在寄存器RDX中。在这种情况下，我将把它复制到结果寄存器中。所以，这就像是这个想法，继续做所有的事情，然后在最后结束时选择。

发言人   36:34
The point is that this one instruction, it looks just as far as for this processor execution, it's sort of like a move instruction that it's fairly straightforward to do. 
重点是，这一条指令看起来就像处理器执行一样，有点像移动指令，执行起来相当简单。

发言人   36:50
Okay, so why doesn't it do that all the time? Well, there's a couple reasons. One is that might be a really, really bad idea to do both computations. If you have to crack a password in one and find the nth prime number in another, you probably don't want to do both of those. So in general, in that case, so, and you'll notice GCC will only do this if both branches are fairly straightforward computations that they're trying to do. 
好吧，那它为什么不一直这样做呢？嗯，有几个原因。一个是，做两种计算可能是一个非常非常糟糕的主意。如果你必须在一个密码中破解密码，并在另一个密码中找到第n个质数，你可能不想同时进行这两种操作。所以一般来说，在这种情况下，你会注意到，只有当两个分支都试图进行相当简单的计算时，GCC才会这样做。

发言人   37:23
And sometimes when you just plain can't do it. So for example, if you're using a conditional to guard whether a pointer can be dereferenced or not because it's a null pointer, potentially a null pointer, then you really don't want to try that null pointer dereference. Just as a way to save some time. And similarly, if you could have a side effect, the result of executing either branch could be to change some other part of the program state. Then you don't really want to do that either. So the conditional move only gets used. 
有时候你只是简单地做不到。因此，例如，如果您使用条件来保护指针是否可以解除引用，因为它是一个空指针，可能是一个空指针，那么您真的不想尝试这种空指针解除引用。只是作为一种节省时间的方式。同样地，如果你可能有一个副作用，执行任何一个分支的结果都可能是改变程序状态的其他部分。那么你也不是真的想这样做。因此，条件移动只被使用。


发言人   38:03
Then in this somewhat special case, you have two computations, relatively easy to do, safe to do, no side effects. But that happens just often enough that this is actually a worthwhile thing. 
那么在这种有点特殊的情况下，你有两个计算，相对容易做到，安全可靠，没有副作用。但这种情况经常发生，这实际上是一件有价值的事情。

发言人   38:19
Okay, so that gets us conditionals. And now let's look at loops. That's the sort of next step up in control structures. And C actually has three different kinds of loops. It has a while loop, which you're familiar with, and a for loop, which you're familiar with, and it has a third one in my whole life of writing. And I've written a lot of C code in my life. 
好的，这让我们有条件。现在让我们来看看循环。这是控制结构的下一步。而C实际上有三种不同类型的循环。它有一个你熟悉的while循环和一个你熟悉的for循环，在我整个写作生涯中它还有第三个。我一生中写了很多C代码。

发言人   38:44
I've used this bike about six times, but it turns out it's the simplest one to implement, so we'll go ahead and do it. So it's called the do while loop, and so the key word is do, and then there's some stuff you do, that's the body of the do. And then there's a test at the end that tells you whether to keep repeating this loop. So it sort of flips a normal while loop. 
我已经用过这辆自行车大约六次，但事实证明它是最容易实现的，所以我们将继续进行。所以它被称为do while循环，关键词是do，然后你要做一些事情，这就是do的主体。然后在最后有一个测试，告诉你是否继续重复这个循环。所以它有点像翻转一个正常的while循环。


发言人   39:10
You have the conditional test at the front, and here you have it at the end and. So it turns out if we think in terms of go to, it's a pretty straightforward thing to replace this with a code that will do a test. And if the test holds, it will jump back and say OK, re-execute that part of the program I was just in. So it sets up a loop where you can think of it literally a loop of control flow going round and round. 
你在前面有条件测试，在这里你在最后有它。所以事实证明，如果我们从go的角度考虑，用一个可以进行测试的代码替换它是一件非常简单的事情。如果测试成立，它会跳回来并说，好的，重新执行我刚刚执行的那部分程序。所以它建立了一个循环，你可以把它想象成一个不断循环的控制流循环。

发言人   39:48
And by the way, this is actually a semi-reusable function, it's called pop count sometimes. How many ones are there in a word of data, this case a sixty-fourth word? There's been some generations of data lab where you were required to write this function using all your favorite operations. And with a fairly small limit on operations. But we're not doing that today. So here, my point is, you see, there's a fairly straightforward way of taking this particular loop and turning it into just a combination of conditional. 
顺便说一下，这实际上是一个半可重复使用的函数，有时称为pop count。在一组数据中，有多少个单词？在这种情况下，是第六十四个单词？已经有几代数据实验室要求您使用所有您最喜欢的操作编写此函数。而且对操作的限制相当小。但我们今天不会这么做。所以在这里，我的观点是，你看，有一种相当直接的方法可以将这个特定的循环转化为条件的组合。

发言人   40:33
Where you do is you jump back to where you were before, and here's the actual code for it. I won't go through all of it, but you can believe from these annotations that it very closely follows the code here. And the main thing to see is this jump, if not equal. To label L 2. And that takes you back to here. And so the general form of it then is you take a do, and then this part of it's called the body of the loop. And this is the test. And so now you set up some code where you can execute the body, perform the test. And if the test holds, you go back to the loop. 
你所做的就是跳回你之前所在的地方，这里是它的实际代码。我不会全部解释，但你可以从这些注释中相信它非常紧密地遵循这里的代码。要看到的主要事情是这个跳跃，如果不是相等的话。给L 2打上标签。这将带你回到这里。因此，它的一般形式是你做一个事情，然后它的这一部分被称为循环体。这就是测试。所以现在你设置了一些代码，你可以在其中执行body，执行测试。如果测试成立，你就回到循环。


发言人   41:19
So a while loop is really just like a do loop, a do while loop, except that you move the test to the beginning. And the only difference, therefore, is with a do loop, you don't do the test the first time through. You're guaranteed to do it the first time no matter what. While in while loop, we will explicitly test even at the very beginning, skip over the loop if the condition doesn't hold. So there's two ways to generate a code. 
所以while循环实际上就像一个do循环，一个do while循环，除了你把测试移动到开头。因此，唯一的区别在于使用do循环时，您不是第一次进行测试。无论如何，你保证第一次就做这件事。而在While循环中，我们甚至会在最开始就显式地测试，如果条件不成立就跳过循环。所以有两种生成代码的方法。

发言人   41:50
Well, there's more than two ways to generate code for a while loop, but you'll find GCC actually uses two different ways. One is what we'll find when we use this optimization setting I talked about last time called minus capital O, which stands for optimize G, which means debug. Of course, as you've already know, there's some history to what the minus G flags means. So, and as I mentioned last time, this turns out to be the perfect level of optimization for this course where you want to be able to look at machine code and understand it and how it relates to the C code because it does some sort of simple optimizations, but it doesn't try to rewrite your whole program to make it run better. Whereas even with -0 1, which is the next level in the optimization, you'll find sometimes it will do some pretty quirky stuff. But when you actually as a program developer as a software developer out there, or you talk to companies and you ask, what optimization level do you use, they'll probably say minus O2, the common one. So usually there's higher level of optimization, and we're purposely backing off from that to make this code easier to understand. So anyways, with the default optimization we're using for this course, it does transformation. 
嗯，有两种以上的方法可以为while循环生成代码，但您会发现GCC实际上使用两种不同的方法。一个是当我们使用我上次谈到的这个优化设置时，我们会发现什么，这个优化设置叫做负大写字母O，它代表优化G，这意味着调试。当然，正如你已经知道的，负G标志的含义有一些历史。所以，正如我上次提到的，这证明是本课程的完美优化水平，您希望能够查看机器代码并理解它以及它与C代码的关系，因为它进行了一些简单的优化。但它不会尝试重写整个程序以使其运行得更好。而即使使用-0 1，这是优化的下一个级别，你会发现有时它会做一些非常古怪的事情。但是当你实际上作为一名程序开发人员作为软件开发人员，或者你与公司交谈并询问你使用什么优化级别时，他们可能会说-O2，常见的一个。通常会有更高级别的优化，我们故意从中退出，以使代码更容易理解。所以无论如何，通过我们在本课程中使用的默认优化，它会进行转换。


发言人   43:18
I call the jump to middle translation. These are, by the way, my own names. You won't find them in any other document. 
我称之为跳转到中间翻译。顺便说一下，这些是我自己的名字。您在任何其他文档中都找不到它们。

发言人   43:27
But the idea of it is, imagine again, I have a while loop of this form where there's a test and the body to execute. Well, what the problem I have to do compared to before is somehow I have to execute the test before I start the first iteration of the loop. So the way I'll do it here is I'll just jump to the middle of what was the old loop code to the test portion of that loop, and then let that test determine whether I actually entered the loop itself. 
但是它的想法是，再想象一下，我有一个这种形式的while循环，其中有一个测试和要执行的主体。与以前相比，我必须做的问题是，在开始循环的第一次迭代之前，我必须以某种方式执行测试。所以我在这里做的方式是，我会跳到旧循环代码的中间，进入该循环的测试部分，然后让该测试确定我是否实际进入了循环本身。


发言人   44:03
And so this is an example of a go to code version of my pop count function. So I've written the pop count function using a while loop. This time, it turns out whether you use a do or a while loop, you'll get the same result in this particular function and. You'll see the way it looks is it? It jumps to the test portion of the code. And then if that holds, it then actually starts the first execution of the loop. And then from there on, it looks the same as the do while loop. It just does what was in the loop does. The test jumps back to the beginning. 
因此，这是我的pop计数函数的转到代码版本的示例。所以我使用while循环编写了pop计数函数。这次，无论你使用do还是while循环，你都会在这个特定的函数中得到相同的结果。你会看到它的样子吗？它跳到代码的测试部分。然后，如果这成立，它实际上开始循环的第一次执行。然后从那里开始，它看起来与do while循环相同。它只是做了循环中的事情。测试又回到了开始。


发言人   44:52
And then there's a second method, which is in some ways more traditional. And you'll find that if you use optimization 1, which is a fairly useful thing to do in practice. So just to show you that instead of deciding which 1 I was going to show you, I decided to show you both. And the idea of that is to do essentially to take a while loop and turn it into a do while loop. But introducing a conditional beforehand, that would essentially guard your entrance to the loop. So you do an initial test. And if that's fault, then you skip over the loop altogether. Otherwise, it's performed like a do while loop. And so that has a fairly straightforward translation into code. 
然后还有第二种方法，在某些方面更传统。你会发现，如果你使用优化1，这在实践中是一个相当有用的事情。所以只是为了向你展示，我决定向你们展示哪一个，而不是决定要向你们展示哪一个。这个想法基本上是做一个while循环，并将其变成一个do while循环。但是预先引入一个条件，这基本上会保护你进入循环。所以你做一个初步测试。如果这是错的，那么你就完全跳过这个循环。否则，它会像do while循环一样执行。因此，这有一个相当简单的翻译到代码中。

发言人   45:42
And that, again, it looks a little different from before. It has an initial test, but then it looks like a do while loop. So I won't show you the assembly versions of those. But if you look at it, actually, the code is all in directories that are linked to the class directory, the class web page. So you can actually look at the code and you'll see that it follows exactly the way I'm describing it. 
而且，再一次，它看起来与以前有点不同。它有一个初始测试，但看起来像一个do while循环。所以我不会向你展示它们的汇编版本。但是如果你看一下，实际上，代码都在链接到类目录，即类网页的目录中。所以你可以实际查看代码，你会发现它完全遵循我描述的方式。

发言人   46:15
And then a third kind of loop is the for loop, which in C is actually a very powerful, very general type of thing. And so it's very commonly used. But you can see that the for loop has four components to it, has an initialization, has a test, has a rule for doing an update in case as a way to continue the loop. And then it has the body of the loop. 
然后第三种循环是for循环，在C中，for循环实际上是一种非常强大、非常通用的循环类型。所以它是非常常用的。但是你可以看到，for循环有四个组件，有一个初始化，有一个测试，有一个更新规则，以继续循环。然后它有循环的主体。


发言人   46:43
And so here's a version of my pop count function where I'm just going through all the bits in the word, extracting them out, and then adding them, accumulating them to be the result. So ripping apart these four, you'll see that these four blocks of correspond to the initialization is to set I equal to 0. The test is to compare I to the word size, which I've set here to be eight times. So however many bytes there are in an int, multiply that by 8 to get the word size. And then the update is I plus, plus, and then the body is this stuff that's within the brackets here. 
这是我的pop计数函数的一个版本，我只是遍历单词中的所有位，将它们提取出来，然后将它们相加，累积为结果。所以撕开这四个块，你会看到这四个块对应于初始化是将I设置为0。测试是将I与单词大小进行比较，我在这里设置了八次单词大小。因此，无论int中有多少个字节，都要将其乘以8以获得单词大小。然后更新是I加，加号，然后正文是这里括号内的内容。

发言人   47:33
So I can think of that in general one general way too. 
所以我一般也可以用一种普遍的方式来思考这个问题。

发言人   47:41
Think about A for loop. And C is by this rule that will turn A for loop into a while. So what it says is I first do the initialization, and then I do a loop where I guard it with this test. And then what I keep doing is executing the body and then performing whatever update there is and then continuing with the test. So that's sort of the semantics, the definition of the behavior of A for loop in C? 
想想一个for循环。而C通过这个规则会把for循环变成一段时间。所以它说的是我首先进行初始化，然后我进行一个循环，用这个测试来保护它。然后我一直在做的是执行body，然后执行所有更新，然后继续测试。这就是在语义上，C中for循环行为的定义？


发言人   48:20
So I can take my different pieces of my for loop and say, well OK. I'll take that rule and use it to pack them in to form a while loop. And of course, you know that you can sort of go between those two. And it's somewhat a matter of taste whether a given loop should be written using a for loop or a while loop. 
所以我可以用我的for循环的不同部分说，好吧。我将采用该规则并使用它将它们打包成while循环。当然，你知道你可以在这两者之间走一种。给定的循环是否应该使用for循环或while循环编写，这在某种程度上是一个品味问题。


发言人   48:48
So one reason why it's actually useful to do this minus o one optimization I talked to you about is it's fairly common for the initial test to be triviality, true. So for example, in here, if I equals 0, and I'm comparing it to the word size, which would typically be 32, well, that test is true. That's a certain thing. And so what you'll see is that the compiler can figure that out and just throw away this guarding code that would have to be there otherwise. So that, I believe, is the main reason why this is the transformation that gets used would be 0. One optimization level is that oftentimes it doesn't need this initial test. 
所以做这个减去我和你谈到的一个优化实际上很有用的一个原因是，最初的测试相当普遍是琐碎的，真的。例如，在这里，如果I等于0，并且我将其与单词大小进行比较，通常为32，那么这个测试是正确的。这是一件确定的事情。所以你会看到的是，编译器可以解决这个问题，只需扔掉这些保护代码，否则就必须在那里。因此，我相信，这就是为什么使用的转换为0的主要原因。一个优化级别是通常不需要这个初始测试。


发言人   49:43
Okay, so now I'm going to finish up with what, to me at least, the loop stuff is sort of what you'd expect if you were to have to turn C code into something very low level where all you could do is jumps and tests. Well, maybe that's obvious, but maybe not. 
好的，现在我要结束一下，至少对我来说，循环的东西有点像你所期望的，如果你必须把C代码变成一个非常低级的东西，你所能做的就是跳跃和测试。好吧，也许这很明显，但也许不是。


发言人   50:07
The switch statement, on the other hand, is a totally different beast. And I want to show you that because no counterpart in normal C code of how you'd even think about it. And it's fairly a little bit harder to do cipher. And you're going to have to do it in the bomb web. So here is an example of a switch statement that of nothing about this is. Useful, except to demonstrate some principles of how to turn a switch statement into assembly code. So the point of it is, as you know and see, you switch on a particular value, some type of integer value, and then it will match different cases where each of these cases has to be some constant numeric value, constant integer value. 
另一方面，switch语句是完全不同的东西。我想向您展示这一点，因为在普通的C代码中没有对应的代码，您甚至不会考虑它。而且密码相当难一些。你将不得不在炸弹网络中这样做。这里是一个switch语句的例子，与此无关。有用，除了演示如何将switch语句转换为汇编代码的一些原则。所以它的重点是，正如你所知道的，你打开一个特定的值，某种类型的整数值，然后它将匹配不同的情况，其中每个情况都必须是某个常量数值，常量整数值。



发言人   51:02
And one of the weirdest features of C is if you at the end of the case, if you don't explicitly say break, it'll do what's known as falling through. So in this example here, we divide y by z, and then it will just glide right into this statement that adds z to w, this is by the way like one of the worst design decisions in the history of programming languages. 
而C最奇怪的特点之一是，如果你在案例的最后，如果你没有明确地说break，它就会做所谓的 “掉入”。在这个例子中，我们将y除以z，然后它会滑入这个将z加到w的语句中，顺便说一下，这就像是编程语言历史上最糟糕的设计决策之一。

发言人   51:31
And it's been the cause of more and more heartbreak and bugs that nobody could understand than any other single part of the language. And for some bizarre reason, they've kept it alive, even into Java and all these other languages that fixed a lot of the worst parts, the most dangerous parts of sea. But somehow they kept this feature. And so just as advice, as a programmer, if you ever, ever use this where you purposely want it to go from one case to another, you should have to put a comment in there to say, trust me, I really did want it to fall through. I know you almost never want to do this, but I do hear. So that's a fairly common convention. And I don't know how many times I've had bugs that were because I forgot to put breaks in. And anyways, enough of my editorializing. 
这已经成为越来越多的心碎和错误的原因，没有人能比语言的任何其他部分更理解。由于某些奇怪的原因，他们一直保持着它的生命力，甚至进入Java和所有其他语言，这些语言修复了许多最糟糕的部分，海洋中最危险的部分。但不知何故，他们保留了这个功能。所以作为建议，作为一名程序员，如果你曾经故意希望它从一个案例转到另一个案例，你应该在那里添加一条评论说，相信我，我真的希望它失败。我知道你几乎从不想这样做，但我确实听说了。所以这是一个相当普遍的惯例。我不知道我有多少次因为我忘记放休息时间而出现错误。无论如何，我的社论已经足够了。


发言人   52:30
The other feature you see in C is you can sort of a bunch of multiple cases. If you think of it, that's just a special case of the fall through. The case 5 has nothing to do but to fall through to 6. So that's the same general way. And that's not bad, and it doesn't require a comment. And the other one is that there's a default. So if none of these cases match either because x was 0 or smaller, or x was a really big number, or in this case, if x were 4, there's no matching case. And of course, you also know that these cases don't have to be in any particular order either. 
你在C中看到的另一个特点是你可以处理一堆多个案例。如果你考虑一下，那只是秋季的一个特例。情况5无关，只能跌到6。所以这是相同的一般方式。这还不错，也不需要评论。另一个是有一个默认。因此，如果这些情况都不匹配，因为x是0或更小，或者x是一个非常大的数字，或者在这种情况下，如果x是4，就没有匹配的情况。当然，你也知道，这些案件也不必按照任何特定的顺序。

发言人   53:12
So that's all the sort of features of a case statement, a switch statement. 
这就是case语句，switch语句的所有功能。

发言人   53:21
So normally, if you write this in, sort of if you were told thou shalt not use switch statements anymore, what you'd probably do is write this big long chain of if else, if else, if else, right? And you'd expect that to be the machine code, but it's not. And so let me show you what the machine code does. And it's kind of a long story. So think of the general form of it as being some blocks of code. The entry points of which are labeled by these case values and then the box string together in various different ways and do various things. 
所以通常情况下，如果你写这个，有点如果你被告知不能再使用switch语句了，你可能会写这个长链的if else，if else，if else，对吧？你会认为那是机器码，但事实并非如此。让我向您展示机器代码的作用。这是一个很长的故事。所以把它的一般形式想象成一些代码块。其入口点由这些case值标记，然后框以各种不同的方式串在一起并执行各种操作。

发言人   54:05
What I'm going to do is compile a code for all of those blocks and store them away in some part of memory, load up memory to contain these code blocks. And then I'm going to build a table. And each entry of this table describes the starting location of one of these code blocks. And I'll put them in order of my case labels. 
我要做的是编译所有这些代码块的代码，并将它们存储在内存的某个部分，加载内存以包含这些代码块。然后我将建立一个表。此表的每个条目都描述了其中一个代码块的起始位置。我会把它们按照我的案例标签的顺序排列。


发言人   54:32
If I have, I want to span a scope from, well, let's assume zero, but typically that's not the case, 0 up to n -1. I'll have this table will have that many entries of addresses to tell me where these code blocks are located. And then I'm going to use this really cool instruction, which is sort of like it's as if you, it's like array indexing. So if you think of array indexing, it means you can grab a value out of the middle of some array, some set of values, without having to step through them one by one. And it's the same idea here that I will take my value and use that to figure out directly where I should jump to a block of code without having to step through a bunch of other conditions. And you can see the efficiency you gain from that. It's the difference between sort of in one step, knowing exactly where you want it to be versus stepping through on average and over two conditions to get to where I want to go. 
如果我有，我想跨度一个范围，好吧，让我们假设零，但通常情况下不是这样，从0到n -1。我将让这张表有那么多地址条目，以告诉我这些代码块的位置。然后我将使用这个非常酷的指令，就好像你一样，就像数组索引一样。因此，如果您考虑数组索引，这意味着您可以从一些数组的中间获取一个值，而无需逐一遍历它们。这里的想法是一样的，我将利用我的价值并使用它来直接找出我应该跳转到代码块的位置，而不必通过一堆其他条件。你可以看到你从中获得的效率。这就是在一步中确切地知道你想要它在哪里与平均通过两个条件来达到我想要去的地方之间的区别。

发言人   55:57
So let's look at this at the assembly code level. And it's a little bit a long thing because we have to build some machinery around this. 
让我们在汇编代码级别看一下这个。这有点长，因为我们必须围绕它建造一些机器。

发言人   56:10
So here's my example. I've got three arguments. So just remember I told you RDI and RSI for the first two arguments. The third argument is in RDX, and here's the beginning of the switch code. It's just making a copy of argument Z here for some reason. And then it's looking at comparing x to 6. And y is 6 an important number because you see 6 was the largest value of any of my cases. And now it's using a jump instruction to go to La. What we'll find is that tells you what the default behavior should be. So it's sort of flushing away the default cases, the cases that are either x is too small or x is too large. 
这是我的例子。我有三个论点。所以只记得我告诉你前两个参数的RDI和RSI。第三个参数在RDX中，这是开关代码的开始。出于某种原因，它只是在复制论点Z。然后它会比较x和6。y是一个重要的数字，因为你会发现6是我所有情况中的最大值。现在它正在使用跳转指令转到La。我们将发现的是，它告诉您默认行为应该是什么。因此，它有点冲走默认情况，即x太小或x太大的情况。



发言人   57:10
And I should mention, there's a clever trick there. If you look at j means jump above, that's the unsigned comparison. And what it's making use of is our result that you remember that if a number is negative, if you think of it as an unsigned value, it becomes very large positive value. So by doing the ja, instead of AJG jump greater than I'm doing jump above, it's saying I want to jump to the default if either. X is greater than 6, but also it will cause it to jump if x is less than 0, got it? So it's a clever trick of unsigned versus signed numbers it's taking advantage of. 
我应该提到，这里有一个聪明的把戏。如果你看一下j意味着跳跃以上，那就是无符号比较。它所利用的是我们的结果，你记得如果一个数字是负数，如果你把它看作是无符号值，它就会变成非常大的正值。所以通过做ja，而不是AJG跳跃大于我做的跳跃上方，它说我想跳转到默认值。X大于6，但如果x小于0，它也会导致它跳跃，明白了吗？所以这是一个巧妙的无符号数字与有符号数字的技巧，它正在利用。

发言人   58:08
And then the final part is this is the real heart of the work. This is my very special go to instruction that letsie index into a table and extract out of that an address and then jump to that address. So that's what letsat go directly to some block of code based on whether my values, we'll see will be in the range between 0 and 6. So there'll be 7 entries in that table. 
最后一部分是这是工作的真正核心。这是我非常特别的指令，letsie索引到一个表中，从中提取一个地址，然后跳转到该地址。所以这就是让他根据我的值是否在0到6之间直接转到某个代码块的原因。因此，该表中会有7个条目。


发言人   58:48
One thing just to keep track of for later, you'll see that for some reason GCC said, you know, if I look at all the code, I actually don't use w as initialized very much. So I won't bother doing it until somewhere within the code blocks. So just we'll have to keep track of that here. So this is the magic construction. And now if we look, and this is all assembly code. You'll see this is the actual jump table, and it's constructed. It's specified in assembly code, and it's the job of the assembly to actually fill in the contents of this table. 
有一件事需要稍后跟踪，你会发现由于某种原因，GCC说，你知道，如果我查看所有代码，我实际上并不经常使用初始化的w。所以我不会费心去做，直到代码块内的某个地方。所以我们必须在这里跟踪它。这就是神奇的建筑。现在，如果我们查看，这都是汇编代码。你会看到这是实际的跳跃表，它已经构建好了。它在程序集代码中指定，程序集的工作是实际填充此表的内容。


发言人   59:34
Me, but what the assembly code is telling the assembly where is I need a quad is just a declaration to say I need an 8 B value here. And that value should match whatever address you decide you wait or determine is the address of where I'm going to stick, label 8 and all these other ones. And these are in the order, as I mentioned, from x equals 0 through 6. And we can already see a few cases that are interesting here. Let me see if I've got a picture of this. 
但是汇编代码告诉汇编在哪里我需要一个quad只是一个声明，说我在这里需要一个8 B的值。并且该值应该与您决定的任何地址匹配，您等待或确定的是我要粘贴的地址，标签8和所有其他地址。这些顺序，就像我提到的，从x等于0到6。我们已经可以看到一些有趣的案例了。让我看看我是否有这张照片。

发言人   01:00:16
Yeah? So we can actually already see some of the logic of this switch statement built into the ordering of entries in this table. So in particular, there is no case 0 here. So case 0 should be the default. There is no case 4 here, so case 4 should be the default. And it turns out, and we already saw before the Ja instruction going to L 8. So L 8 is actually where the code block is going to be for the default case. So you see, basically, you can think of this as sometimes having holes in your switch statement. And we're going to just fill in those holes by saying those should go to the default case. 
是吗？因此，我们实际上已经可以看到此表中条目的排序内置了此switch语句的一些逻辑。特别地，这里没有案例0。因此，案例0应该是默认值。这里没有案例4，因此案例4应该是默认值。结果证明，在Ja指令转到L 8之前，我们已经看到了。因此，L 8实际上是默认情况下代码块的位置。所以你看，基本上，你可以把这看作是在你的switch语句中有时会有漏洞。我们将通过说那些应该进入默认情况来填补这些漏洞。


发言人   01:01:07
And here you'll notice that they're not put in any particularly logical order. One thing you'll see again is. L 7 is repeated twice here because it covers both cases 5 and 6. So again, you'll see this sort of doubling up is handled automatically by the jump table, will give you the same address for multiple different cases. 
在这里，你会注意到它们没有按照任何特别的逻辑顺序排列。你会再次看到的一件事是。L 7在这里重复两次，因为它涵盖了5和6两种情况。所以，你会再次看到这种加倍是由跳转表自动处理的，会在多个不同的情况下为您提供相同的地址。

发言人   01:01:42
OK, and now the rest of it is to look at the various code block. And this, by the way I'm showing you, I took a file, extracted little bits of it. But normally you're looking at this whole listing in one big order. So now we can look at the individual Jo code box and see what's going on. And you'll see, for example, case one told me to multiply two numbers. 
好的，现在剩下的就是查看各个代码块了。顺便说一下，我给你们看的是，我拿了一个文件，提取了其中的一小部分。但通常情况下，您会以一个大的顺序查看整个列表。所以现在我们可以查看单个jocode框，看看发生了什么。你会看到，例如案例一告诉我要将两个数字相乘。

发言人   01:02:06
And you'll see that the break in general, it's just going to be turned into return instructions here because my function, let's go, sorry to jump in code. You see this function did a switch statement and then whatever, whatever gets computed within the switch statement gets returned as a result of this. So the compiler doesn't actually come to a single point and say, okay, everyone return at this point. It just sticks, returns directly in wherever these breaks occur. 
你会看到一般的中断，它只会在这里变成返回指令，因为我的函数，让我们开始吧，抱歉跳进代码。你会看到这个函数执行了一个switch语句，然后无论在switch语句中计算出什么，都将返回结果。所以编译器实际上并没有到达一个点，并说，好的，每个人都回到了这一点。它只是粘住，直接返回到这些中断发生的地方。


发言人   01:02:46
So here does it multiply and a return? Here you say? Actually, yeah, curious, by the way. 
那么它在这里是乘法和回归吗？你在说什么？实际上，是的，顺便说一下，很好奇。


发言人   01:02:54
I'm always somewhat surprised by what the compiler does. It's never exactly what you'd expect in particular. It patched together this fall through case by two blocks of code. And it had to do these separately because remember, w was not set before I entered these code blocks. It deferred setting that. And here I hit case 3. And all of a sudden, I actually need whatever w was, which was one. And so I guess the compiler said, well, gosh, I guess I better set w to one here before we continue. So as a result, it sort of creates two code blocks, but it jumps from the second one, this block, into partway through this other block. 
我总是对编译器所做的事情感到有些惊讶。这从来都不是你特别期望的。它用两个代码块修补了这个秋天的案例。并且它必须单独执行这些操作，因为记住，在我进入这些代码块之前没有设置w。它推迟了设置。这里我碰到了第三种情况。突然间，我真的需要任何东西，那就是一个。所以我猜编译器说，好吧，天哪，我想我最好在这里设置w，然后再继续。因此，它创建了两个代码块，但它从第二个代码块跳到另一个代码块的半部。


发言人   01:03:55
Here's some actual, yeah, so here's the actual code. This is the block that does the division. It's very quick how you have to write division, it's covered in the book, I won't go through it here. And then this jump L 6 is what I say go to merge, and the merge is where you're bringing these two cases together. Here is where it's setting L to one. Again, it's making use of this feature and that the upper 32 b get set to 0. So I can use a move L instruction here question. 
这是一些实际的，是的，这是实际的代码。这是执行分割的块。如何写除法很简单，这本书已经涵盖了，我不会在这里讲述。然后这个跳跃L 6就是我说的去合并，合并就是你将这两种情况结合在一起的地方。这就是将L设置为1的地方。再次强调，它正在利用这个功能，并且上面的32 b被设置为0。所以我可以在这里使用移动指令问题。

发言人   01:04:37
Did not have the code? For what? No, the jump table is sort of embedded. Let me just show you real quick. No, probably bad idea. If you look at the S file, the assembly code file, all this stuff I'm showing you out of that, But it's all in there. And so the compiler generated these tables, at least the sort of framework for these tables, the details of which get filled in by the assembler. So it is generated by the compiler. 
没有代码吗？为什么？不，跳台有点像嵌入式的。让我快速地展示给你看。不，可能是个坏主意。如果你看一下S文件、汇编代码文件，以及我向你展示的所有这些东西，但它们都在那里。因此，编译器生成了这些表格，至少是这些表格的框架类型，其详细信息由汇编器填写。所以它是由编译器生成的。


发言人   01:05:21
So that just shows you this one example of handling a particular way to handle the fall through case. And then the remaining ones, again, you'll see here, if I get to this case, I need the fact that w is initialized to one. So we'll do so here. In the default case, it just ass 2 to W, and so that's all it does. So anyways I've actually shown you all the code block, but I've shown you 1 by one, but they're just all kind of strong in the file and in no particular order. It doesn't matter what order they are. 
所以这只是向您展示了一个处理秋季案例的特定方法的示例。然后剩下的，你会在这里看到，如果我得到这种情况，我需要一个事实，即w被初始化为1。所以我们将在这里这样做。在默认情况下，它只是从2到W，这就是它所做的一切。所以无论如何，我实际上已经向您展示了所有代码块，但我已经逐一向您展示了，但它们在文件中都是强大的，没有特定的顺序。它们的顺序并不重要。


发言人   01:06:06
So that was the reason for that jump above at the beginning. So this jump above L was the way that if x was either less than zero or greater than 6, it would go to the default case. And it will only do this indexing trick. 
这就是一开始跳跃的原因。所以这个高于L的跳跃是这样的，如果x小于零或大于6，它将进入默认情况。它只会做这个索引技巧。

发言人   01:06:33
If x is between 0 and 6, and that's typically the way this works, that you'll see that whatever range of values you give, it has to figure out the smallest and the largest one. So it goes to the default case if it's out of that range, and then set up a table for the values within that range question. But if the value, it's range of values is like some negative number to, yeah, something else, does it try to like, does it index into it without x somehow? Or so? 
如果x在0到6之间，这通常是这样工作的，那么你会看到无论你给出的值的范围是什么，它都必须找出最小值和最大值。因此，如果超出该范围，它将转到默认情况，然后为该范围内的值问题设置一个表格。但是如果这个值，它的值范围就像一个负数，是的，别的东西，它是否尝试喜欢，它是否以某种方式在没有x的情况下进行索引？还是这样？


发言人   01:07:03
The question I realize I should be repeating questions. The question is, what if it's a negative number for your case, which is perfectly legal? It will typically add a bias to it effectively so that whatever your lowest value was become zero, or it'll do something like that to avoid having to do negative indexing. 
我意识到我应该重复问题。问题是，如果对于你的情况是一个负数，这是完全合法的，怎么办？它通常会有效地添加偏差，使您的最低值变为零，或者它会做类似的事情，以避免进行负索引。

发言人   01:07:25
Another question I see. But for cases, you can put, yeah, so you can go from 0 to 1 million. Yeah, and they could be, you could go zero in a million and nothing in between, right? So you could have two cases. You really don't want a million entry table for just two cases, so it will turn it into if elses code. But the clever thing it will do, if you know binary search, it relies on the fact that it knows in advance all the values and it will actually set up a tree of if Fels is. So really it will do it. If you want to think algorithmically, it does it with a logarithmic number of tests rather than a linear number of tests question. 
我看到了另一个问题。但是对于情况，你可以放置，是的，所以你可以从0到100万。是的，它们可能是，你可以在一百万中达到零，在这之间什么都没有，对吗？所以你可以有两个案例。你真的不希望在只有两种情况下使用一百万个条目表，所以它会将其转换为if elses代码。但是聪明的是，如果你知道二分查找，它依赖于这样一个事实，即它事先知道所有的值，它实际上会建立一个if Fels树。所以它真的会做到。如果你想从算法上思考，它会使用对数数量的测试而不是线性数量的测试问题来完成。

发言人   01:08:20
Oh, yes, yes. So there's two answers. That one is which I've actually answered both. Now, if one is, what if there's some negative values? Or what if the lowest number is 5700, right? Well, what it will typically do is put some bias, add or subtract some value so that the first case is at value 0. So that's where it handles ones that are just completely out of range. And the other is, what if it's a really big spread of values and relatively sparse, how much you're using it? And there it will revert to if elses code and the compiler has its own rules about how it does these things, you can sort of run experiments and try and reverse engineer it. 
哦，是的，是的。所以有两个答案。那个问题我两个都回答过了。现在，如果有一个是，如果有一些负值怎么办？如果最小的数字是5700，对吧？嗯，它通常会做的是放置一些偏差，添加或减去一些值，使第一种情况的值为0。所以这就是它处理那些完全超出范围的问题的地方。另一个问题是，如果它是一个非常广泛的值并且相对稀疏，你用了多少？在那里，如果其他代码和编译器有自己的规则来处理这些事情，你可以运行实验并尝试反向工程。

发言人   01:09:08
These are all valid questions, by the way. I appreciate them. 
这些都是有效的问题，顺便说一下。我很感激他们。

发言人   01:09:16
Okay, so we're going to get through this. So anyways, like I said. I think in my own experience, you understanding the conditionals, you can kind of figure that out. It's intuitive, sort of feels like what you'd expect a program to do, whereas the switch statement is maybe unexpected. It's a way to do something that is. Not totally obvious, but then when you think about it and appreciate it, it actually gives you a good performance boost. 
好的，我们将度过这个过程。不管怎样，就像我说的。我认为在我自己的经验中，如果你理解了条件语句，你就可以把它弄明白。它很直观，有点像你期望程序做的事情，而switch语句可能是意想不到的。这是做某事的一种方式。这并不完全明显，但是当你思考并欣赏它时，它实际上会给你一个很好的性能提升。

发言人   01:09:59
Again, algorithmically, this jump table makes it so it's a constant time, constant number of steps to get to where you need to in the switch statement. If you just did it linearly one after the other, then that would be linear time. And you'd expect if everything's uniform and average, it would be about halfway through on average. If it's sparse, you'll see it will be set up a tree of conditionals. So it can do in logarithmic time. So no matter what, it will be better than just what you would get in the obvious form of if else I saw a question over here. 
同样，从算法上讲，这个跳转表使它成为一个恒定的时间，恒定的步数，以到达您在switch语句中需要的位置。如果你一个接一个线性地做，那就是线性时间。你会期望，如果一切都是均匀和平均的，平均来说，它大约已经过了一半。如果它是稀疏的，你会看到它将被设置一个条件树。所以它可以在对数时间内完成。所以无论如何，它都会比你明显得到的更好，比如我在这里看到了一个问题。


发言人   01:10:42
Well, the good news is I don't set up the jump tree. The compiler sets up the jump tree. But if you're asking if I were a compiler, how would I set up the jump tree, which is a good question. 
好消息是我没有设置跳跃树。编译器设置跳转树。但是如果你问我如果我是编译器，我将如何设置跳转树，这是一个好问题。

发言人   01:10:56
If you know binary search, that you've got a range of values and you pick, you compare it to the middle value, and it's either less or it's greater or equal. And if it's less, then you sort of recursively handle one set. And if it's greater than the other, that's exactly what these trees look like. So they're balanced binary trees, and they're taking advantage of the fact that in C, which is not true in all languages, that all the case conditions you're looking at are constants. They're determined when the compiler is doing the compilation. Those are constant values. So it can sort figure out how many there are, what range of values there are, decide which version to do the, and generate the code. 
如果你知道二分搜索，你有一个范围的值，你可以选择，你可以将其与中间值进行比较，它要么是更少，要么是更大或相等。如果它更少，那么你可以递归地处理一组。如果它比另一个大，那就是这些树的样子。所以它们是平衡二叉树，并且它们利用了一个事实，即在C中，并非在所有语言中都如此，你正在查看的所有情况条件都是常量。它们是在编译器进行编译时确定的。这些是恒定值。因此它可以排序找出有多少，有什么范围的值，决定执行哪个版本，并生成代码。

发言人   01:11:42
Other questions? So these are all good. These are very good questions. And you're starting to think about which is the way that computer scientists should think is how do you take some idea? I've seen one case of, well, how do I handle condition X and condition y, and what happens if this? That's exactly what we do. We're never happy with a simple explanation. We want to understand how we could actually implement it as a program if we ever had to do so. And so? 
其他问题？所以这些都很好。这些问题非常好。你开始思考计算机科学家应该如何思考，你如何理解一些想法？我见过这样的情况，那么，如何处理条件X和条件y，如果这样会发生什么？这正是我们所做的。我们从不满足于一个简单的解释。我们想了解如果我们必须这样做，我们如何将其作为一个程序实际实现。所以呢？


发言人   01:12:22
Just in general, the main thing you see is that there's a fairly limited bag of tricks for which the program implements conditional constructs. Basically three. One is to use conditional jumps, go to different parts of the code, another to use conditional moves, and the third is to use this jump table idea. And those are really that plus a little bit to do procedures is sort of all there is. And all the other stuff you see in a program that sort of changes the flow of execution or what gets executed are built out of those basic primitives. And that's generally true that what we see is when you go from C code to machine code, you often have to kind of piece together various low level instructions to implement some higher level construct. And so we've seen these all in different forms now. And next time, then we'll talk about procedures. 
总的来说，你看到的主要事情是，程序实现条件构造的技巧相当有限。基本上有三个。一个是使用条件跳转，转到代码的不同部分，另一个是使用条件移动，第三个是使用这个跳转表的想法。那些真的加上一点点要做的程序就是所有的东西。你在程序中看到的所有其他改变执行流程或执行内容的东西都是由这些基本原语构建的。这通常是正确的，我们看到的是当你从C代码转到机器码时，你经常需要把各种低级指令拼凑起来，以实现一些更高级别的构造。所以我们现在已经以不同的形式看到了这些。下次，我们会谈论程序。


发言人   01:13:34
As you can imagine, a fairly major topic because it is worth one entire procedure. Okay, very good, thank you. 
正如你所想象的那样，这是一个相当重要的话题，因为它值得一整个过程。好的，很好，谢谢。