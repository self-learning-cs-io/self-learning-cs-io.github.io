---
title: 操作系统工程 001-Introductionan
date: 2025-10-18 10:00:01
---


发言人   00:01
All right, welcome to 6 S 0 8 1 operating systems. I'm Robert. I'll be co lecturing with Franz and David and Nicholas with the Tas. But please, during these Zoom lectures, ask questions. You can either interrupt me by audio or enter something into the chat window and one of the staff will see and ask a question for you. By the way, we'll be recording these lectures and we'll post the recordings later so you can review them. Or for people who can't make this time so they can nevertheless see lectures. 
好的，欢迎来到6 S 0 8 1操作系统。我是罗伯特。我将与弗兰兹、大卫和尼古拉斯一起与他们共同讲课。但是请在这些Zoom讲座中提问。你可以通过音频打断我，也可以在聊天窗口输入一些内容，其中一位工作人员会看到并为你提出问题。顺便说一下，我们将录制这些讲座，稍后会发布录音，以便您进行复习。或者对于那些不能参加这个时间的人，他们仍然可以看讲座。

发言人   00:40
Or I want to start by laying out some of the goals of the course. So number one is to understand the design and implementation of operating systems. And the design is sort of high level structure. And implementation is really about what the code looks like. And we'll be spending a lot of time with both. And in the interest of getting a deep understanding of what's going on, you'll get hands on experience with a small. With a small operating system, the XV 6 operating system. And in addition to actually looking at an existing operating system, you'll be in the labs, get a bunch of experience extending the operating system, modifying its, improving its behavior, and writing system software that it uses, the operating system interfaces, if it was an application. 
或者我想先列出课程的一些目标。因此，第一件事是了解操作系统的设计和实现。并且设计是一种高层次的结构。而实现实际上是关于代码的样子。我们将花很多时间和两者在一起。为了深入了解正在发生的事情，你将获得少量的实践经验。使用一个小型操作系统，XV 6操作系统。除了实际查看现有的操作系统外，您还将在实验室中获得扩展操作系统、修改操作系统、改进其行为以及编写其使用的系统软件、操作系统接口 (如果它是一个应用程序) 的大量经验。

发言人   01:46
So this is what you're going to be doing in the course. 
这就是你在课程中要做的事情。

发言人   01:53
We're also interested in what the purpose of the operating system itself is, as well as of the course. So for that, I have a sort of list of a couple of things, which even though there's lots of operating system, different operating systems out there, they typically have a common set of purposes. One of them is to abstract the hardware. That is you. What you're given typically as a kind of starting point is you buy a computer, a computer as a CPU and memory. But that's a very low level set of resources. It's fantastic to have much higher level interfaces and abstractions that applications can use, such as processes or file systems, both for convenience and for portability. 
我们也对操作系统本身的目的感兴趣，以及课程本身。因此，我有一个几件事情的列表，即使有很多操作系统，不同的操作系统，它们通常都有一组共同的目的。其中之一是将硬件抽象化。这就是你。通常情况下，作为一种起点，你会购买一台电脑，一台作为CPU和内存的电脑。但这是一组非常低级别的资源。拥有应用程序可以使用的更高级别的接口和抽象，例如进程或文件系统，这非常棒，这既是为了方便，也是为了可移植性。


发言人   02:44
Another very important task of an operating system is to multiplex the hardware. Among many applications, you might be running a text editor and a compiler, or maybe multiple different database servers or something on your operating system. It's fantastic to be able to have the operating system run both of them at the same time or all the things that are going on at the same time without having them interfere. That's often called multiplexing because there may be a lot of things happening in the operating system at the same time. It's critical that they not interfere unintentionally, even if they above, and that's task is called isolation, the idea that. Different activities should not be allowed to interfere. 
操作系统的另一个非常重要的任务是多路复用硬件。在许多应用程序中，您可能在操作系统上运行文本编辑器和编译器，或者可能运行多个不同的数据库服务器或其他设备。能够让操作系统同时运行这两个操作系统，或者同时运行所有正在进行的事情，而不会受到干扰，这真是太棒了。这通常被称为多路复用，因为操作系统中可能同时发生很多事情。至关重要的是，即使他们在上面，也不要无意中进行干涉，这一任务被称为孤立，这个想法。不同的活动不应该被允许干涉。

发言人   03:33
On the other hand, there are times when different activities would like to interfere or would like to interact or cooperate. So for example, if I create a file with a text editor and I'd like my compiler to read the file, we definitely want to allow that kind of sharing. So we want to allow sharing when it's sort of what the user has in mind. But in many circumstances, the user doesn't want sharing. Maybe you're logged into a time sharing machine like Athena, and you don't want other people to read your files. So we also need as well sharing. We want to not share when we don't want to, which we could call security or a permission system or an access control system. 
另一方面，有时不同的活动想要干扰或想要互动或合作。因此，例如，如果我使用文本编辑器创建了一个文件，并且我希望我的编译器读取该文件，我们肯定希望允许这种共享。所以我们希望允许在用户想要的时候进行分享。但在许多情况下，用户不想分享。也许你已经登录了像Athena这样的分时共享机器，并且不希望其他人阅读你的文件。所以我们也需要分享。当我们不想分享时，我们不想分享，我们可以称之为安全、权限系统或访问控制系统。

发言人   04:16
Another thing that people value in operating systems is if you spend a lot of money on a hardware, on a computer, you'd like your application to be able to get the sort of full performance that the hardware ought to be able to provide. And a lot of that is just application programming. But inevitably, unfortunately, some of it is the operating system has to make sure that whatever services it provides don't get in the way of applications getting high performance. So you want to these not get in the way, maybe even help applications achieve good performance. 
人们在操作系统中重视的另一件事是，如果你在硬件上花了很多钱，在计算机上，你希望你的应用程序能够获得硬件应该能够提供的全部性能。其中很多只是应用程序编程。但不可避免的是，不幸的是，操作系统必须确保它提供的任何服务不会妨碍应用程序获得高性能。所以你希望这些不要妨碍，甚至可能帮助应用程序实现良好的性能。


发言人   04:56
Finally, with most operating systems, I have to support a wide range of different applications. Maybe it's a laptop running a text editor, maybe it's running games. Maybe our operating system needs to support database servers or cloud computation. And usually, because operating systems are quite expensive to design and build, people use the same operating systems for many different tasks, like Linux, for example, which I'm sure many of you are running, is used in all of the situations I mentioned. So the same operating system really has to be able to support a range of often quite different uses. So we're hoping to be able to support sort of all these different goals simultaneously, and we'll hear more about all of them during the course. 
最后，对于大多数操作系统，我必须支持各种不同的应用程序。也许它是一台运行文本编辑器的笔记本电脑，也许它正在运行游戏。也许我们的操作系统需要支持数据库服务器或云计算。通常，由于操作系统的设计和构建非常昂贵，人们使用相同的操作系统来完成许多不同的任务，例如Linux，我相信你们中的许多人正在运行，在我提到的所有情况下都在使用。因此，同一个操作系统确实必须能够支持一系列通常非常不同的用途。所以我们希望能够同时支持所有这些不同的目标，并且我们将在课程中听到更多关于所有这些目标的信息。

发言人   05:47
All right, operating systems. So people have worked out a set of design ideas over the decades that have worked pretty well, sort of ways of organizing things. And I'm going to lay out for you the sort of classic. 
好的，操作系统。所以人们在过去的几十年里已经想出了一套设计思路，这些思路已经运作得相当好，是一种组织事物的方式。我将为你奠定那种经典。

发言人   06:06
Organization sort of the standard deal for this course and is actually quite common around for many operating systems. So this is sort of an OS internal organization. The way I think about it is in terms of draw a box for the computer. The computer sort of comes with a bunch of hardware resources, which I'll put at the bottom. Maybe there's CPU and Ram and a disk for storage, and maybe a network interface. This is sort of hardware that's the lowest layer. So if at the top we want to run various applications, maybe a text editor, I happen to use VI as a text editor. If you're going to run AC compiler CC, if you run lots of other things. 
组织是本课程的标准交易，实际上在许多操作系统中非常常见。所以这是一种操作系统内部组织。我对这个问题的看法是，为电脑画一个盒子。这台计算机有点配备了一堆硬件资源，我把它们放在底部。也许有CPU、Ram和用于存储的磁盘，也许还有网络接口。这是一种硬件，是最底层。因此，如果在顶部我们想要运行各种应用程序，也许是一个文本编辑器，我碰巧使用VI作为文本编辑器。如果你要运行交流编译器CC，如果你运行许多其他的东西。

发言人   06:58
We're going to talk a lot today about the shell, which is the command line interface. So we have all these different programs that are running. And this is the sort of world in which applications run is using called user space. And as distinct from that, there's a single program, a special program that's always running called the kernel. And the kernel is sort of the guardian of the resources of the computer. It's what first boots up, and you turn on the computer, it's just one of it. It maintains data to help it manage each of these processes. And the kernel also maintains lots of data structures to help it interface all the different kinds of hardware that these user programs need to use. 
今天我们将讨论很多shell，即命令行界面。所以我们有所有这些不同的程序正在运行。这就是应用程序运行使用所谓的用户空间的世界。与之不同的是，有一个单一的程序，一个始终在运行的特殊程序，称为内核。内核在某种程度上是计算机资源的守护者。这是第一次启动，你打开电脑，这只是其中之一。它维护数据以帮助其管理这些过程。内核还维护着大量的数据结构，以帮助它连接这些用户程序需要使用的所有不同种类的硬件。


发言人   07:49
The kernel also has built in a bunch of services, and so for example, there's typically a file system implementation inside the kernel that implements things like file names and file contents and directories and understands how to store the files in the disk. Programs are going to talk to the Fas inside the kernel and the FA and implementations going to talk to the disk. And in this course, what we mostly focus on is all the things that has to happen inside the kernel and on the interfaces between user programs and the kernel, as well as the sort of structure of the software inside the kernel. So we care a lot about these services inside the kernel. One of them is the file system I mentioned. There's also management of processes. Each of these running programs, it's called a process, and it has things like its own memory, for example, as well as share the CPU time. The kernel manages processes as a kernel service. 
内核还内置了许多服务，例如，内核中通常有一个文件系统实现，它实现文件名、文件内容和目录，并了解如何将文件存储在磁盘中。程序将与内核中的Fas通信，而FA和实现将与磁盘通信。在本课程中，我们主要关注内核内部发生的所有事情，用户程序和内核之间的接口，以及内核内部软件的结构类型。所以我们非常关注内核中的这些服务。其中之一是我提到的文件系统。还有过程管理。这些正在运行的程序中的每一个都被称为一个进程，它有自己的内存之类的东西，例如，以及共享CPU时间。内核将进程作为内核服务进行管理。

发言人   09:01
The kernel manages the allocation of memory. The different processes need different amounts of memory, the kernel. Multiplexes and divides up the memory, allocates the memory among all the different processes. 
内核管理内存的分配。不同的进程需要不同的内存量，内核。多路复用和分割内存，在所有不同的进程之间分配内存。

发言人   09:24
The kernel, as I mentioned, influence the file system. File system really comes in 2 or three logical or a bunch of logical parts. For now, we can think of it in terms of managing file content that's inside files, figuring out where on disk each files content auto live. The file system also somewhat separately manages a name space. Each file has a name, and there's a hierarchy of directories. Every directory has a bunch of files in it, all that's managed by the file system. 
正如我所提到的，内核会影响文件系统。文件系统实际上有2或3个逻辑部分或一堆逻辑部分。目前，我们可以将其看作是管理文件内部的文件内容，计算出每个文件内容在磁盘上的自动存储位置。文件系统也在某种程度上单独管理命名空间。每个文件都有一个名称，并且有目录层次结构。每个目录都有一堆文件，所有这些文件都由文件系统管理。


发言人   09:54
There's typically some sort of security arrangement, maybe we'll call it access control. Which the colonel decides that know when a given process wants to read, use some resource, maybe read something from the disk or use some memory, The access control machinery inside the kernel is what get to decide. Yes, is that allowed? Is that not allowed? And that can get pretty complicated if we're talking about time sharing systems like Athena systems, whether it's know each of these processes may be run by a different user and have different access control rules applied to what it's allowed to get at. 
通常有某种安全安排，也许我们称之为访问控制。当上校决定知道一个给定的进程想要读取、使用一些资源，可能从磁盘中读取某些内容或使用一些内存时，内核中的访问控制机制是决定的。是的，这是允许的吗？这不允许吗？如果我们谈论像Athena系统这样的分时系统，这可能会变得相当复杂，无论我们是否知道这些过程中的每个过程可能由不同的用户运行，并且对其允许的访问应用不同的访问控制规则。

发言人   10:28
And in a real full blown operating system, there turns out to be many, many other services. There's typically some way for different processes to talk to each other called inner process SOS communication. Typically a whole bunch of software associated with the network, things like the TCP IP protocols for talking to the network. There's typically support for sound cards. There may be drivers for hundreds of different disks and hundreds of different network cards. So in a full-blown operating system, there's amount of stuff here, and this may run to millions of lines of code inside the kernel. So that's sort of a quick overview of what's inside the kernel. 
在一个真正成熟的操作系统中，事实证明有许多其他服务。通常，不同进程之间有一种相互通信的方式，称为内部进程之间的通信。通常是一堆与网络相关的软件，比如用于与网络通信的TCP IP协议。通常支持声卡。可能有数百个不同的磁盘和数百个不同的网卡的驱动程序。因此，在一个成熟的操作系统中，这里有很多东西，可能会在内核中运行数百万行代码。所以这就是对内核内部内容的快速概述。

发言人   11:09
We're also interested in how applications interact with the kernel and what that interface looks like. The. Usual, so this is the API for the kernel. How applications get at the kernel. Typically that's done with something called system calls. And these are things that look like function calls that programs can make, but actually jump into the kernel and execute a system called implementation in the kernel. I'll talk a bunch about that in the latter part of this lecture. 
我们还对应用程序如何与内核交互以及该接口的外观感兴趣。这个。通常，所以这是内核的API。应用程序如何到达内核。通常这是通过称为系统调用的方式完成的。这些东西看起来像是程序可以进行的函数调用，但实际上会跳入内核并执行一个称为内核实现的系统。我将在本讲座的后半部分谈很多关于这个的事情。


发言人   11:51
For now, just to give you a flavor here, what a couple of different system calls might look like in the source code of an application. One might be that if you want, if an application wants to open a file, it calls the open system call and tells the open system called the name of the file. So maybe it wants to open a file for writing called out. It would be an extra argument here saying one, in this case, saying I want to write that file. And so this thing that looks like a function call, it opens the system calls actually special code that jumps into the kernel. And the kernel can retrieve these arguments, executes some kernel code that implements open, maybe talks to the disk, and then returns a value. And that's this file descriptor as FD stands for file descriptor, which is the program can then use as sort of a handle to refer to this open file. 
现在，在这里给你一个风格，几个不同的系统调用在应用程序的源代码中可能是什么样子。其中一个可能是，如果您希望应用程序打开一个文件，它会调用open系统调用并告诉开放系统文件名。所以也许它想要打开一个文件来写入名为out的文件。在这里，这将是一个额外的参数，在这种情况下，说我想写那个文件。所以这个看起来像函数调用的东西，它打开了系统调用实际上是跳入内核的特殊代码。内核可以检索这些参数，执行一些实现开放的内核代码，可能与磁盘对话，然后返回一个值。这就是这个文件描述符，因为FD代表文件描述符，然后程序可以将其用作句柄来引用这个打开的文件。

发言人   12:46
If you want to write to a file, the system called to do that, it's called write. You have to pass it one of these file descriptors. The same was returned by open. 
如果你想写入一个文件，系统调用来完成这个任务，它被称为写入。你必须传递其中一个文件描述符。同样的东西也被open退回了。

发言人   12:56
These are now arguments that are passed in the system call from the program into the kernel. You give it a pointer to a buffer of characters. An easy way to do that in the C programming language, which these examples are written by, is double quotes. And then the string, the bytes of the string, this backslash n is a new line, and the third argument is the count of characters, and you want to write. And so this really gets point past us and addressed in memory. So you're telling the kernel, look, please write 6 B from this address to the file that this file descriptor refers to. 
这些现在是在系统调用中从程序传递到内核的参数。你给它一个字符缓冲区的指针。在C编程语言中，双引号是一个简单的方法，这些例子就是用它编写的。然后是字符串的字节数，这个反斜杠n是一个新行，第三个参数是字符数，你想要写。因此，这确实超出了我们的范围，并在内存中进行了处理。所以你告诉内核，看，请从这个地址写入6 b到这个文件描述符所指的文件中。

发言人   13:34
A much more exciting system call that you won't encounter is the fork system call. Fork is the system call that creates a new process and it returns, actually creates a process that's identical to the caller. Fork returns the An identifier, the process identifier PID of the new process, actually a little more complicated than that. And we'll hear more about this. So again, these are all look like function calls, but the system calls are special because they jump into the kernel. That's just a taste and we'll see more later. 
一个你不会遇到的更令人兴奋的系统调用是分叉系统调用。Fork是创建一个新进程的系统调用，它返回，实际上创建了一个与调用者完全相同的进程。Fork返回一个标识符，即新进程的进程标识符PID，实际上比那稍微复杂一些。我们会听到更多关于这个的。所以再次强调，这些看起来都像函数调用，但系统调用是特殊的，因为它们跳入了内核。这只是一种味道，我们稍后会看到更多。

发言人   14:15
With that as a sort of quick overview, I want to just mention why I find operating the study of operating systems to be both challenging and interesting. Why, you know, why it's maybe worth, intellectually worth taking a course in this area? So one reason why it's hard is that the environment is unforgiving. The programming environment inside the kernel is unforgiving when you're. Programming when you're modifying the kernel or extending the kernel, or writing a new operating system kernel, you're providing the infrastructure that everybody else assumes is already present to run their programs, and everybody else gets an operating system under their program when they write ordinary application programs, When we build operating systems, what we get is the hardware underneath our operating system, which turns out to be more difficult to deal with in this course. We get to use a hardware simulator called QM that simulates a CPU and a computer, and that makes life a little bit better, but it's still kind of a difficult environment to program it. 
有了这个快速概述，我想简单提一下为什么我发现操作系统的研究既具有挑战性又有趣。为什么，你知道，为什么在这个领域学习一门课程可能是值得的，理智上值得的？所以，困难的一个原因是环境是无情的。内核内部的编程环境是不可原谅的。当你修改内核或扩展内核，或者编写一个新的操作系统内核时，你提供了其他人认为已经存在的基础设施来运行他们的程序，而其他人在编写普通应用程序时会在他们的程序下得到一个操作系统，当我们构建操作系统时，我们得到的是操作系统下面的硬件，这在本课程中更难处理。我们可以使用一个名为QM的硬件模拟器，它模拟了CPU和计算机，这让生活变得更好一些，但编程环境仍然有些困难。

发言人   15:32
Another reason why it's hard and interesting is because if you're designing an operating system, you have to satisfy a bunch of tensions that require real design thought. So one is that you'd like your operating system to be both efficient, troffa means that it sort of operates at a low level, close to the hardware, but for ease of use, and because real live people have to write programs that use your operating system, we'd like it also to be to write abstract high andle, portable interfaces. And it's a neat trick to provide abstract interfaces that are simple and portable, but that are also efficient. 
另一个困难和有趣的原因是因为如果你正在设计一个操作系统，你必须满足一堆需要真正设计思维的张力。所以其中一个是你希望你的操作系统既高效，troffa意味着它在较低的水平上运行，接近硬件，但为了使用方便，因为真正的人必须编写使用你的操作系统的程序，我们希望它也能编写抽象的、高级的、可移植的接口。这是一个巧妙的技巧，提供了抽象的接口，既简单又可移植，但也很有效。

发言人   16:12
Another tension is that we'd like to provide a very powerful operating system services so that the operating system can shoulder a lot of the burden. Of running programs, we'd like a powerful operating system services, but we also want to have simple interfaces. That we don't want tremendously complex, hard to understand interfaces for programmers to use? They're not going to understand them, and they may find it hard to use. So this is really simple API. And so this is possible to do to provide simple interfaces that have powerful machinery inside them. And we'll always be searching for. So it's simple interfaces to provide powerful services. 
另一个紧张关系是我们希望提供一个非常强大的操作系统服务，以便操作系统可以承担很多负担。在运行程序方面，我们需要强大的操作系统服务，但我们也希望拥有简单的界面。我们不希望程序员使用非常复杂、难以理解的接口？他们不会理解它们，可能会发现很难使用。所以这是一个非常简单的API。因此，这是可以做到的，以提供简单的接口，其中包含强大的机械结构。我们将一直在寻找。因此，只需简单的接口就可以提供强大的服务。

发言人   17:04
Hey, Robert, we have a question in the chat. What is unique slash different about saying system calls jump into the kernel that is, as opposed to a standard function call that jumps to another function? Well, the kernel has the kernels is a piece of code that's always resident, that has special privileges that because it booted the machine, booted the kernel, the kernel has special privileges. It can get directly at all kinds of hardware, like the disk device that ordinary user programs can't get at. So if you make an ordinary function call. The function you're calling it doesn't get any special privileges with respect to the hardware. Whereas if you make a system call into the kernel, we'll talk about how this works. But that ends up when the system called jumps into the kernel, The system called implementation in the kernel then gets all these special privileges so that it can modify all kinds of sensitive and protected hardware resources, like, for example, getting directly at the hard disk. 
嘿，罗伯特，我们在聊天中有个问题。说系统调用跳转到内核，与跳转到另一个函数的标准函数调用相比，独特的斜杠有什么不同？好的，内核具有内核，内核是一段始终驻留的代码，具有特殊特权，因为它引导机器，引导内核，内核具有特殊特权。它可以直接在各种硬件上获取，例如普通用户程序无法获取的磁盘设备。所以如果你进行一个普通的函数调用。您正在调用的函数不会获得任何与硬件相关的特殊权限。而如果你对内核进行系统调用，我们将讨论它是如何工作的。但是当名为的系统跳入内核时，最终系统会获得所有这些特殊权限，以便它可以修改各种敏感和受保护的硬件资源，例如直接访问硬盘。


发言人   18:16
We'll see a lot more detail for all of this shortly. 
我们很快就会看到更多的细节。

发言人   18:20
Okay, so a final tension that we want to that all operating systems need to satisfy is you want to give programs as much flexibility as you can. You don't want to constrain them. So you want to have very flexible. Interfaces, but you do need to constrain programs somewhat because you absolutely have to have some notion of security. Can't we love for programs? Programmers complete freedom, but it can't be complete, can't be really complete because we don't want programs to get directly at the hardware or to interfere with other programs. So to be able to interfere with the operation of the operating system itself. So these are all. 
好的，我们想要所有操作系统都需要满足的最后一个张力是，你想给程序尽可能多的灵活性。你不想约束他们。所以你想要非常灵活。但是你确实需要在一定程度上限制程序，因为你绝对必须有一些安全概念。我们不能喜欢节目吗？程序员完全的自由，但它不能是完整的，不能真正完整，因为我们不希望程序直接到达硬件或干扰其他程序。以便能够干扰操作系统本身的运行。这些就是全部。

发言人   19:01
It's possible to do a good job and we'll talk a lot about it, but it's always a bit of a puzzle to provide sort of both of these, the properties in both of these columns. 
做好工作是有可能的，我们会谈论很多，但在这两个专栏中提供这两个属性总是有点困惑。

发言人   19:11
Another thing that makes OS design hard and interesting is that operating systems provide a lot of features in a lot of services, but they actually tend to interact, and sometimes in odd ways that require a lot of thought. Even in the simple examples I gave with Open and fork, those two interact. Actually, if a program allocates a file descriptor with the open system call, and then that same program forks and the semantics of fork just turn out to be that you create a new process that's a copy of the current process, this file descriptor you opened, if that's truly to be a copy, this file descriptor still has to be present and usable in the child. So that's to be thought through. That is, the open and file descriptors interact with fork in this interesting way, and somebody has to figure out, oh, should the child be able to get at the file descriptor is created before awork was called? And the answer happens to be yes. And the operating systems we're going to look at. 
另一个使操作系统设计困难而有趣的事情是，操作系统在许多服务中提供了许多功能，但实际上它们倾向于交互，有时以奇怪的方式需要很多思考。即使在我用Open和fork给出的简单示例中，这两者也相互作用。实际上，如果一个程序使用开放系统调用分配了一个文件描述符，然后相同的程序分叉和分叉的语义只是证明你创建了一个新进程，它是当前进程的副本，你打开了这个文件描述符，如果这真的是一个副本，此文件描述符仍然必须存在并在子项中可用。所以这需要深思熟虑。也就是说，开放和文件描述符以这种有趣的方式与分叉交互，有人必须弄清楚，哦，孩子应该能够在调用awork之前获得创建的文件描述符吗？而答案恰好是肯定的。以及我们将要研究的操作系统。

发言人   20:17
All right, and so other things that turn out to be interesting, I already mentioned that operating systems have to cater to a wide variety of uses. The same OS use both for database servers and smartphones, for example, and operating systems. As time goes on, the hardware that you run, hardware you get with typical computers changes. Maybe you get super fast SSD storage instead of mechanical hard drive, for example. And about 15 years ago, multicore computers went from being rare curiosities to being pervasive. And recently, we've seen order of magnitude speed ups in how fast networks operate. And so all these require rethinks periodically of how operating systems are designed now. So those are, those are sort of intellectually why you might take the course. 
好的，还有其他有趣的事情，我已经提到操作系统必须迎合广泛的用途。例如，数据库服务器、智能手机和操作系统都使用相同的操作系统。随着时间的推移，您运行的硬件，您从典型计算机获得的硬件会发生变化。也许你可以获得超快的固态硬盘存储而不是机械硬盘。大约15年前，多核计算机从罕见的好奇心变成了普及。最近，我们看到网络运行速度出现了数量级的加速提升。因此，所有这些都需要定期重新思考操作系统的设计方式。因此，这些就是智力上你为什么要参加这门课程的原因。

发言人   21:12
There's also some even more practical reasons why you might be glad to have have taken this course when if you're interested in what happens inside computers, what goes on under the hood, sort of in secret when you turn on your computer, this is a good course to take. Similarly, if you like infrastructure, that is if you enjoy building sort of services that other programs can then use, this is, of course, essentially all about infrastructure because that's what operating systems are if you ever need to spend a lot of time tracking down bugs in application code or tracking down security problems often that involves understanding what was going on inside the operating system because it's ultimately the operating system that enforces a lot of security. And when things go wrong, it's sort of the operating system that has to pick up the pieces. So that's often involved in tracking down bugs. 
还有一些更实际的原因，为什么你可能会很高兴参加这门课程，如果你对计算机内部发生的事情，引擎盖下发生的事情感兴趣，当你打开计算机时，这是一个很好的课程。同样，如果你喜欢基础设施，也就是你喜欢构建其他程序可以使用的服务，这当然是，基本上所有的事情都与基础设施有关，因为操作系统就是这样，如果你需要花很多时间追踪应用程序代码中的错误或追踪安全问题，通常需要了解操作系统内部发生了什么，因为最终是操作系统强制实施了大量的安全性。当出现问题时，操作系统必须收拾残局。这通常涉及追踪错误。

发言人   22:06
And finally two more questions from the chat. So the first is how important is it for application developers to truly, deeply understand the operating systems they're developing their applications for? Do they necessarily need to be experts? You don't have to be an expert, but if you spend a lot of time developing and maintaining and debugging applications, you'll eventually end up knowing a lot about the operating system, whether you meant to or not. It just comes up and you're often forced to understand. 
最后，还有两个来自聊天的问题。因此，第一个问题是，对于应用程序开发人员来说，真正深入了解他们开发应用程序的操作系统有多重要？他们一定需要成为专家吗？你不必成为专家，但如果你花费大量时间开发、维护和调试应用程序，你最终将了解很多关于操作系统的知识，无论你是否打算这样做。它只是出现了，你经常被迫去理解。


发言人   22:39
And the second question is, do high level programming languages like Python use system calls directly? Or are there built ins slash wrappers for convenience? A lot of high level languages are sort of at one remove from system calls. That's absolutely true. Partially because a lot of languages want to provide portable, a portable environment that works on many different operating systems. So they can't necessarily commit if the specific system calls of any one operating system. So the answer, the question, I think, is if you use Python, you're somewhat insulated from the system call interface. 
第二个问题是，像Python这样的高级编程语言是否直接使用系统调用？还是为了方便而有内置的ins斜杠包装纸？很多高级语言都是从系统调用中一次性删除的。这是完全正确的。部分原因是因为许多语言想要提供可移植的，可移植的环境，可以在许多不同的操作系统上工作。因此，如果任何一个操作系统的特定系统调用，他们不一定能提交。所以答案是，我认为问题是，如果你使用Python，你在某种程度上与系统调用接口绝缘。

发言人   23:18
Now internally, of course Python makes has to make system calls to get its work done. And certainly in Python and many other languages, there is usually a way to get directly apt the system calls or whatever your operating system you're running on. And folks, for questions, you can just feel free to jump in yourself and ask questions. You don't need to go through the chat. Okay? All right, it, sorry. 
现在在内部，当然Python必须进行系统调用才能完成其工作。当然，在Python和许多其他语言中，通常有一种方法可以直接apt系统调用或您正在运行的任何操作系统。而朋友们，对于问题，你可以随意地跳进去，提出问题。你不需要通过聊天。好吗？好的，对不起。

发言人   23:50
I'm going to spend a couple of minutes now talking about class structure 6 S 0 8 1 before switching back to actual technical content. So the, there's a website for the course, which I don't want to write out just now, but it's you can find it by looking for 6 S 0 8 1 on Google and the website has. The schedule it has the assignments on the schedule, it has the lab assignments, and it has a sort of information about course structure, like the grading policy on it. 
在切换回实际的技术内容之前，我现在要花几分钟时间谈论类结构6 s 0 8 1。所以，有一个关于这门课程的网站，我现在不想写出来，但是你可以通过在谷歌上查找6 0 8 1来找到它，该网站有。日程安排它有日程安排上的作业，它有实验作业，还有一种关于课程结构的信息，比如评分政策。

发言人   24:34
The other big resource you're going to want to keep track of it was Piazza. I guess everybody who was here got here, by the way. Piazza as well as so we use Piazza relief for two main things. One is as a way of people being able to ask questions about the lab assignments and course staff will try to answer these questions, but you should feel absolutely free to answer each other's questions as well. And the other big thing that happens on Piazza, there's announcements, If there's any announcements about the course, we'll put the announcements on Piazza. So you should keep an eye on Piazza for announcements, even if you're not using it for lab help. 
你想要跟踪的另一个重要资源是广场。顺便说一下，我想这里的每个人都到了这里。广场以及因此我们将广场浮雕用于两件主要事情。一种是作为人们能够就实验作业提出问题的方式，课程工作人员会尝试回答这些问题，但你也应该完全自由地回答彼此的问题。而在广场上发生的另一件大事是公告，如果有关于该课程的任何公告，我们将在广场上发布公告。所以你应该留意广场上的公告，即使你不是用它来帮助实验室。

发言人   25:17
One of the big parts of the course is these lectures. The lectures will cover basic ideas and operating systems. 
这些讲座是本课程的重要组成部分之一。讲座将涵盖基本思想和操作系统。


发言人   25:30
Some of the lectures will be devoted to detailed study of the code in XV 6, which is our small teaching operating system. And so talk about how it works. We'll look at the code and sort of show the code executing during lectures. And in addition, before many of the lectures, there'll be assignments, reading assignments from a book that sort of describes how XV 6 operates and why it's designed that way. So you should do the readings before the class so that you'll understand the discussion of the class, some of the lectures that are devoted to background to help you do the labs sort of explanations of how C works, of how the risk phi, which is the microprocessor that we'll be using, that you'll find helpful in understanding how to do the labs. 
一些讲座将致力于详细学习XV 6中的代码，这是我们的小型教学操作系统。所以谈谈它是如何工作的。我们将查看代码，并展示在讲座期间执行的代码。另外，在许多讲座之前，会有作业，阅读一本书中的作业，书中描述了XV 6的运作方式以及为什么这样设计。所以你应该在课前阅读一下，这样你就能理解课堂的讨论，一些关于背景的讲座可以帮助你对C的工作原理进行实验室的解释，以及风险phi (我们将使用的微处理器) 的讨论。你会发现这有助于理解如何做实验室。

发言人   26:17
And towards the end of the course, we'll spend some lectures discussing some operating system papers, research papers, and some classic papers in the field, which we'll ask that you read before the lectures. And then we'll sort of talk about the papers during the lecture For all the lectures, or almost all lectures, we ask that you submit a question about the reading for the lecturer before the actual time of the lecture, which many or all of you did for this lecture, for which thank you, and we will read those questions to help us, guide us about what to talk about. And we'll try to answer as many of the questions as we can, although there's rarely time, unfortunately, for us to answer all of them the next big part, the course of the labs, there's a programming lab do almost every week, and the point of the labs is to help you get hands on experience with implementing and using operating systems. The lab that's due next week is actually about using, using about writing applications that make the call, the system calls we'll be talking about. Whereas most of the labs after that are involve you either implementing basic operating system features or adding kernel extensions to the XV 6 operating system. 
在课程结束时，我们将花费一些讲座讨论一些操作系统论文、研究论文和该领域的一些经典论文，我们会要求你在讲座前阅读这些论文。然后我们会在所有讲座或几乎所有讲座的讲座中谈论论文，我们要求您在讲座实际时间之前向讲师提交一个有关阅读的问题，你们中的许多人或所有人为此讲座做了什么，谢谢，我们将阅读这些问题来帮助我们，指导我们谈论什么。我们会尽力回答尽可能多的问题，尽管不幸的是，我们很少有时间回答所有这些问题，下一个重要的部分，实验室的课程，几乎每周都有一个编程实验室。实验室的目的是帮助您获得实施和使用操作系统的实践经验。下周要进行的实验室实际上是关于使用，使用编写应用程序来进行调用，以及我们将讨论的系统调用。而之后的大多数实验都涉及实现基本的操作系统功能或向XV 6操作系统添加内核扩展。

发言人   27:44
The very last lab, and it's one in which you actually add a network stack and a network driver. So you'll be able to connect in over the network to the operating system that you run. You should, if you have problems with the labs, there'll be office hours. Tas will hold. In addition, you can post questions to Piazza, and very often you'll be able to get useful answers from Piazza more quickly than from office hours. 
最后一个实验，你实际上添加了网络堆栈和网络驱动程序。因此，您将能够通过网络连接到您运行的操作系统。如果你在实验室遇到问题，应该有办公时间。Tas会坚持下去。此外，您可以在广场上发布问题，通常情况下，您将能够比办公时间更快地从广场获得有用的答案。

发言人   28:13
We welcome you discussing the labs, talking about the labs, talking about how to design the lab solutions. We ask you, please do not look at other people's solutions for the labs, please. All the code you write should be your own and you shouldn't share code. Look at other solutions. 
我们欢迎您讨论实验室，谈论实验室，谈论如何设计实验室解决方案。我们要求你，请不要参考其他人对实验室的解决方案。你写的所有代码都应该是你自己的，不应该共享代码。看看其他的解决方案。

发言人   28:32
The grading the course will be mostly determined from the labs this year, so 70% of the grade will be. Based on whether or not your lab, the lab you submit, passes the tests. And for grading, we run the same tests that we supply you. So if your lab passes all the tests that we give you, the chances are you get full credit for the lab. 20% of the grade is going to be from lab check-off meetings. 
今年课程的评分将主要由实验室决定，因此70% 的成绩将由实验室决定。根据您提交的实验室是否通过测试。对于评分，我们运行与您提供的相同的测试。因此，如果您的实验室通过了我们为您提供的所有测试，您很可能会获得该实验室的全部信用。20% 的成绩将来自实验室核对会议。

发言人   29:07
We'll, for each of you, we'll pick a couple of randomly selected labs and one of the teams will talk to you and asking questions about your implementation just to make sure that you really understand what's going on. So this is the live check-offs there's 10% remaining question, will the last check-offs kind of be like a yes or no one or zero type of thing? Or would they be like, could someone get like, if they answered some of the questions right, but not all the questions right, would they get in between, you know, I haven't thought this through. There's certainly room for partial credit. It's not a, it won't be binary. It'll definitely be you can receive partial credit. 
对于你们每个人，我们将随机选择几个实验室，其中一个团队将与你们交流，询问有关你们实施的问题，以确保你们真正理解正在发生的事情。所以这是实时核对，还有10% 的问题，最后的核对会像是或没有人或零类型的事情吗？或者他们会像，有人会像，如果他们回答了一些问题，但不是所有问题都正确，他们会介于两者之间，你知道，我没有想过这个。当然有部分信贷的空间。它不是，它不会是二进制的。这肯定是你可以得到部分信用。

发言人   30:00
The last 10% is going to be driven by the homework and participation during lecture and in Piazza. There'll be no exam or quizzes. This year. And so what that means is that most of the, you know, 90% of the great is being driven by the labs. So you should spend a lot of time in the labs, make sure that you start early and have enough time to complete them and work out bugs in order to get full credit. And you, as a result of that, this is going to be a very kind of hands on software oriented course. Any questions about the machinery of the course? 
最后的10% 将由家庭作业和讲座期间的参与和广场驱动。不会有考试或测验。今年。所以这意味着大部分的，你知道的，90% 的伟大是由实验室推动的。因此，您应该在实验室花费大量时间，确保尽早开始并有足够的时间完成它们并解决错误，以获得全额学分。因此，这将是一门非常实用的面向软件的课程。对这门课程的机器有什么问题吗？


发言人   30:53
We got a couple questions in chat. So the first is a logistical question. Currently, 6 S 0 8 1 isn't listed as usable for the systems concentration in the M, are there planned status of the list of classes later? I think for that because it's not an aags, it's an AUS, it can't be used to fulfill my requirements as it's not a graduate level class. But, and then we have is the only homework to submit questions looking at the calendar, that appears to be the case. Unless I'm forgetting something. I think that's the case, yes. So have are there going to be cutoffs for grades like x percent gets an, A, y percent gets AB, etc.? No no? 
我们在聊天中有几个问题。所以第一个是逻辑问题。目前，6 s 0 8 1未被列为可用于M中的系统集中，稍后是否有类别列表的计划状态？我认为这是因为它不是aags，它是一个AUS，它不能用来满足我的要求，因为它不是研究生水平的课程。但是，然后我们有唯一的家庭作业要提交问题，看着日历，似乎就是这样。除非我忘了什么。我认为情况就是这样，是的。那么对于成绩，是否有一些临界值，比如x百分比得到一个，A，y百分比得到一个，等等？不，不？

发言人   31:48
You know, we're going to try to, for each student, estimate our impression of how well you've understood the material and assign a grade based on that. So there's no predetermined cutoffs. All right, anything else? 
你知道的，我们将尝试为每个学生估计我们对你理解材料的印象，并根据此评分。因此，没有预先确定的截止点。好的，还有别的吗？

发言人   32:13
Right, just real quick for folks in the chat asking about the concentration requirement. I'm not 100% certain, but 6. So 0 8 1 is not. It's like a temporary number before the class gets official one, so it certainly won't be listed anywhere. If you needed to fulfill a concentration, I think your best bet is probably to fill out a petition or to email somebody like Katrina laktsang to see what the status is. We don't control, you know, what, what classes fill these kind of requirements, unfortunately, and for what language we'll be using, the class will be in C? 
没错，对于那些在聊天中询问浓度要求的人来说，这真的很快。我不是100% 肯定，但是6。所以0 8 1不是。在班级正式开始之前，它就像是一个临时号码，所以它肯定不会被列出在任何地方。如果你需要集中精力，我认为你最好的选择可能是填写一份请愿书，或者给像卡特里娜·拉克桑这样的人发邮件，看看情况如何。我们无法控制，你知道什么，什么课程满足这种要求，不幸的是，对于什么语言，我们将使用C语言？


发言人   32:58
All right? All right, for the rest of the lecture, I want to talk about what systems calls look like to applications. And, you know, since the system calls or the interface to the services that the operating system provides, it's actually pretty important what those system files look like, what applications expect from system calls, and how they behave. So sort of worth understanding what the interface looks like. You'll be using the system calls we talk about in the first lab and extending and improving the implementation, internal implementation of these system calls in subsequent labs. What we're going to do is show some simple examples of little programs that call system calls, and then it'll run them in XV 6 for you going to run them. 
一切都好吗？好的，在接下来的讲座中，我想谈谈系统调用对应用程序的影响。而且，你知道，由于系统调用或操作系统提供的服务接口，实际上非常重要的是这些系统文件的外观，应用程序期望从系统调用中得到什么，以及它们的行为方式。因此，有必要了解界面的样子。你将使用我们在第一个实验中讨论的系统调用，并在后续实验中扩展和改进这些系统调用的实现和内部实现。我们将要做的是展示一些调用系统调用的小程序的简单示例，然后它将在XV 6中运行它们，供您运行。

发言人   33:56
The XV 6 is it's a mix, a simplified Unix like operating system. And Unix is an old operating system that's sort of at least intellectual basis for many present day operating systems such as Linux and OS X, so it's in very common use. XV 6, our teaching operating system is much simpler and sort of inspired by Unix and has the same overall structure, but is dramatically simpler than any real Unix operating system it's. Simple enough that hopefully it would be relatively straightforward for you to read all of the source code as well as read the book in a couple of weeks, certainly during the semester, in order to kind of understand all of what happens inside XV 6. 
XV 6是一个混合的简化的类Unix操作系统。而Unix是一种古老的操作系统，它至少是许多现代操作系统 (如Linux和OS X) 的智力基础，因此它的使用非常普遍。XV 6，我们的教学操作系统更加简单，有点受Unix的启发，并且具有相同的整体结构，但比任何真正的Unix操作系统都要简单得多。足够简单，希望你能相对简单地阅读所有源代码以及几周后阅读这本书，当然是在这个学期，以便理解XV 6中发生的所有事情。

发言人   34:49
XV 6 runs on the risk five SSR risk 5 microprocessor. And this is the same microprocessor that's the focus of recent 6 0 0 4. So many of you may actually know quite a bit about the Risk 5 instruction set. In theory, you could run XV 6 on top of a risk 5 computer, and people have done that. But we're going to run it under the QM machine emulator. 
XV 6在风险5的SSR风险5微处理器上运行。这是最近的60 0 4所关注的同一个微处理器。你们中的许多人可能实际上对风险5指令集有相当多的了解。理论上，您可以在风险计算机上运行XV 6，人们已经这样做了。但是我们将在QM机器模拟器下运行它。

发言人   35:18
Just write this down. We our operating system is XV 6. It runs on risk 5 microprocessor and not just wrist 5 microprocessor, but we assume a certain amount of surrounding hardware like memory and a disk and a console interface for us to talk to it, but we actually run under the Q Mu. Machine in simulator. Which runs under Linux so that all of you can actually run XV 6 without having to have hardware? Okay, so kind of switch to showing the code. 
把这个写下来。我们的操作系统是XV 6。它运行在风险5微处理器上，而不仅仅是手腕5微处理器，但我们假设有一定数量的周围硬件，如内存和磁盘以及一个控制台接口供我们与之通信，但我们实际上运行在Q Mu下。模拟器中的机器。哪个在Linux下运行，这样你们所有人都可以实际运行XV 6，而无需硬件？好的，那么就切换到显示代码。

发言人   36:15
All right, so first thing is I have a set up XV 6 on my laptop and I'm going to run it. I'm going to type make qmu, which you'll find yourself doing quite a bit during the labs, which compiles XV 6. It's written in C, it's compiled with the C compiler. Maybe I'll make clean for you so you can see the actual compilation. And I might type make qmu, which has the effect of compiling and building XV 6 kernel and all the user processes and then running them under the qmu emulator. It takes a moment to run the compiles and now we're up and running XV 6. And the dollar sign prompt you see is the shell, which is the command line interface to XV 6, modeled after the shell and Unix, which is if you log into an Athena or station, it's the it's like the shell that Athena shows you. 
好的，首先我在笔记本电脑上设置了XV 6，我要运行它。我将输入mermu，你会发现自己在实验室里做了很多，编译xv6。它是用C编写的，用C编译器编译。也许我会为你清理干净，这样你就可以看到实际的编译。然后我可能会输入使qmu，这将有助于编译和构建XV 6内核和所有用户进程，然后在qmu模拟器下运行它们。运行编译需要一点时间，现在我们已经启动并运行XV 6了。您看到的美元符号提示符是shell，它是XV 6的命令行界面，以shell和Unix为模型，也就是说，如果您登录到Athena或站点，它就像Athena向您展示的shell一样。


发言人   37:18
X 3 6 is is itself tiny and it comes with a small number of utility programs, including, for example, the LS program, which I'm about to run, run LS, and it gives me a list of all the files in XV six, of which there are only about two dozen, including things like GRE kill and make deer and RM, which may be familiar to us as Unix utilities. Okay, the first program I'm going to show you to illustrate system calls is a program called Copy. 
X 3 6本身很小，并且附带了少量的实用程序，例如包括LS程序，我即将运行它，运行LS，它给了我一个XV 6中所有文件的列表，其中只有大约两打，包括像GRE kill和使鹿以及RM这样的东西，这些可能是我们熟悉的Unix实用程序。好的，我要展示给你演示系统调用的第一个程序是一个叫做Copy的程序。


发言人   38:00
And here's the source. It's just a page. 
这是来源。这只是一页。

发言人   38:08
And so what you're seeing here is a program that starts on line aid in Maine is a sort of convention for C programs. It sits in a loop at line 12 and over and over again and reads some data as input and on line 13, and then writes the data just read to output on line 16. 
所以你在这里看到的是一个在缅因州的在线援助上启动的程序，是C程序的一种约定。它位于第12行的循环中，一遍又一遍地读取一些数据作为输入和第13行的数据，然后将刚刚读取的数据写入第16行的输出。

发言人   38:28
So I run copy. In XV 6, just waiting to read input. If I type some input, it reads it and spits it back up to me. So it's very simple program. It just does I out. It's written in C, as I mentioned, if you don't already know C, it's worthwhile getting the standard C programming language book by kernahan and Richie. And I think there's a more full reference to it on the course website, which explains to you in very straightforward way how to program and C? 
所以我运行复制。在XV 6中，只是等待读取输入。如果我输入一些输入，它会读取并吐回给我。所以这是一个非常简单的程序。它只是让我出去。它是用C语言编写的，正如我所提到的，如果你还不知道C语言，那么值得买一本由kernahan和Richie写的标准C语言书籍。我认为在课程网站上有更完整的参考资料，它以非常直接的方式向您解释了如何编程和编程？

发言人   39:08
As I mentioned before, read and write. This program makes two really three system calls. Read, write, and exit are system calls. 
正如我之前提到的，阅读和写作。这个程序进行了两次三次系统调用。读、写和退出都是系统调用。

发言人   39:17
If you look at the call to read on line 13, it takes three arguments. The first argument is a file descriptor, which is really a reference to a previously opened file, and the shell ensures that when a program starts, by default, its file descriptor 0 is connected to the console input and it's file descriptive one is connected to the console output. And that's why I was able to type 2, this copy program, and see the output of. Course, these file descriptors, the program expects these file descriptors to have been previously opened and set up by the shell for it. And this 0 1 file descriptors is a pervasive Unix convention. Many, many Unix programs expect to read file descriptor 1 and read and file descriptor 0 and write to file descriptor one. 
如果您查看第13行的read调用，它需要三个参数。第一个参数是文件描述符，实际上是对先前打开的文件的引用，并且shell确保当程序启动时，默认情况下，其文件描述符0连接到控制台输入，并且其文件描述连接到控制台输出。这就是为什么我能够输入2，这个复制程序，并看到输出。当然，这些文件描述符，程序期望这些文件描述符之前已经被shell打开并设置。而这个0-1文件描述符是一种普遍的Unix约定。许多Unix程序期望读取文件描述符1和读取文件描述符0并写入文件描述符1。

发言人   40:13
The second argument to read is a pointer to some memory where the program is asking the operating system to read data into that address in memory. So that's the buff argument. And line 10 allocates 64 B of memory ring on the stack per read to read into. And the third argument to read is the maximum number of bytes that the program wants to read. And the size above says just 60, maximum 64 B. So the recall reads up to 64 B from whatever it's connected to file Scripture 0. And that was my terminal in this example, the return value from read it either may determine the number of bytes red, which would be 6 in the case of me typing XYZ, z by be might be beating from a file if it gets to the end of the file and there's no more bytes, read will return 0. 
读取的第二个参数是指向某个内存的指针，该程序要求操作系统将数据读入内存中的该地址。这就是buff的论点。并且第10行在每次读取堆栈上分配64 B的内存环以进行读取。读取的第三个参数是程序想要读取的最大字节数。上面的大小只有60，最大64 B。因此，召回程序从连接到文件Scripture 0的任何内容中读取最多64 B。在这个例子中，这是我的终端，读取它的返回值可能决定红色的字节数，如果我输入XYZ，则为6，如果z by be到达文件的末尾并且没有更多的字节，它可能正在从一个文件中跳动，读取将返回0。

发言人   41:07
And if some other error occurred, like the file descriptor doesn't exist, read may return -1. And so in many of these examples, like on 16, there don't example code doesn't check system call returns for errors. But you should be more careful than me. You should figure out how system calls reflect errors. That's usually a -1 in return value and check all system called returns for errors. And if you want to know what the system call arguments and return values are, there's a table, and I think chapter 2 in the book that explains all of the XV 6 system called arguments and return values. 
如果发生其他错误，比如文件描述符不存在，read可能会返回-1。因此，在许多这样的例子中，比如在16上，没有示例代码不检查系统调用返回的错误。但是你应该比我更小心。你应该弄清楚系统调用如何反映错误。这通常是-1的返回值，并检查所有系统调用的返回值是否有错误。如果你想知道系统调用的参数和返回值是什么，有一个表格，我想书中的第二章解释了所有XV 6系统的参数和返回值。

发言人   41:52
The question regarding the read C call, what if we set the max read by to size of buff to one plus size of buff or bigger? So what if we try to read more than the size? Yeah, then if there was 65000 B to read, then the operating system would happily just copy those 65 B to the memory that you provide. And of course, there's something else in the stack up there, maybe the return program counter or an argument or something. And so if you pass 65, then you're inviting the kernel to write junk to have an unexpected place in your stack. And so that's a bug, and it may cause your firm to crash or do something else unexpected. So as a programmer, you have to be careful here. 
关于读取C调用的问题，如果我们将最大读取大小设置为增益大小的一加或更大，该怎么办？那么，如果我们尝试阅读超过尺寸的内容呢？是的，那么如果有65000 b可以读取，那么操作系统会很乐意将这65 b复制到您提供的内存中。当然，堆栈中还有其他东西，也许是返回程序计数器或参数或其他东西。因此，如果您通过65，那么您就是在邀请内核编写垃圾内容，以便在您的堆栈中占据意想不到的位置。所以这是一个错误，它可能会导致你的公司崩溃或做一些意想不到的事情。所以作为一名程序员，你在这里必须要小心。

发言人   42:39
There's nobody writing in C with these kind of interfaces. It's very, very easy to write code compiler is happy with and will run, but absolutely does the wrong thing, so that's too bad, but that's the way it is. 
没有人在C语言中编写这种接口。编写编译器满意并运行的代码非常容易，但绝对做错了，所以这太糟糕了，但这就是它的方式。

发言人   43:00
Okay, one thing to note is that this copy program and indeed the readmit system calls, they don't care about the format of data they're reading or writing. They just read and write, read and write. In this copy program, just deal with 8 b bytes with streams of 8 b bytes. How you interpret them is totally up to the application. So the application maybe parsees as data records or is C source code, or who knows what the operating system. Only thinks in terms of a stream of 8 b bytes. Okay, so copy, assume this code. 
好的，有一点需要注意的是，这个复制程序以及readmit系统调用并不关心他们正在读取或写入的数据格式。他们只是读和写，读和写。在这个复制程序中，只需处理8 b字节和8 b字节流。如何解释它们完全取决于应用程序。因此，应用程序可能会被解析为数据记录，或者是C源代码，或者谁知道操作系统是什么。只考虑8 b字节的流。好的，所以复制，假设这段代码。

发言人   43:38
My copy program can assume that the file descriptor is already set up, but we need to have a way to create file descriptors. And the most straightforward way to do that is with the open system call. And so here's the source for a program that called Open That. 
我的复制程序可以假设文件描述符已经设置好，但是我们需要有一种创建文件描述符的方法。最直接的方法是使用开放系统调用。所以这里有一个叫做Open那个的程序的源代码。


发言人   43:58
Uses the open system Call the question from the chat, what do you mean by a stream of bytes? I just mean that if a file contains a bunch of bytes then read, then successive I building a file contains a million bytes. If you make a sequence of read calls each for 100 B, it'll just read the first 100 B and then the second 100 B, and then the 3rd hundred bytes. That's all I mean. All right, so this program called Open First. I'll run it for you. What it does is open creates a new file called output dot x.t. and then writes and writes to it. It finished, so we don't see anything because it broke data to this file open, but we can look at this output dot Xt file that it created and see the o-o-o that it right wrote there. 
使用开放系统从聊天中调用问题，你所说的字节流是什么意思？我的意思是，如果一个文件包含一堆字节，然后读取，然后连续构建一个文件包含一百万个字节。如果您为每个100 b进行一系列读取调用，它将只读取前100 b，然后是第二个100 b，然后是第三个百字节。这就是我的全部意思。好的，所以这个程序叫Open优先。我会为你运行它。它所做的是打开并创建一个名为output dot x.t的新文件。 然后写信给它。它完成了，所以我们看不到任何东西，因为它打开了这个文件的数据，但是我们可以查看它创建的输出点Xt文件，并看到它正确地写在那里的o-o。

发言人   44:58
Line 11 in the program makes the open system call, gives it a file name, output dot and o underscore stuff in the second argument to open our flags that tell the opening system called implementation in the kernel that we'd like to create a file with its name and that we're going to write it open, returns a newly allocated file descriptor. 
程序中的第11行进行开放系统调用，给它一个文件名，输出点和o下划线的东西在第二个参数中打开我们的标志，告诉内核中称为实现的打开系统，我们想要创建一个文件名为的文件，并且我们要将其打开，返回新分配的文件描述符。

发言人   45:24
The ph scripture is just a small number, or it's probably two or 3 or 4 or something. And then we pass that same file descriptor to write along with a buffer and a number of bytes to write that writes data to the file that the file descriptor refers to. What that file descriptor is actually doing is indexing into a little table inside the keel. Kernel maintains state for each process that's running, each program that you run. And among other things, the kernel remembers a table for every running process of index by file descriptors. And the table sort of tells the kernel what each file descriptor refers to. 
Ph值经文只是一个很小的数字，可能是两个、三个或四个左右。然后我们传递相同的文件描述符以进行写入，同时传递一个缓冲区和一些字节以将数据写入文件描述符所引用的文件。那个文件描述符实际上是在龙骨内的一个小表格中建立索引。内核维护每个正在运行的进程和您运行的每个程序的状态。此外，内核还会为每个运行中的进程记住一个表，并按文件描述符进行索引。这个表格告诉内核每个文件描述符所指的是什么。

发言人   46:08
A critical point is that each process has its own sort of space of file descriptors before running two different processes, two different programs, and different processes. And they both open the file. They may actually get the same number back as a file descriptor, but because the kernel maintains a separate file descriptor for each process, the same file descriptor number refer to different files in different processes. 
关键是每个进程在运行两个不同的进程、两个不同的程序以及不同的进程之前，都有自己的文件描述符空间排序。他们都打开了文件。它们实际上可能得到与文件描述符相同的编号，但由于内核为每个进程维护一个单独的文件描述符，因此相同的文件描述符编号引用不同进程中的不同文件。

发言人   46:36
Any questions about open about this little program? We got a question in the chat, A question from someone not familiar with C, how are these files being described different from normal C programs? Is it because we're only using kernel calls? I couldn't we also open or write a file in Python? 
对这个小程序的开放性有任何问题吗？我们在聊天中有一个问题，一个不熟悉C的人的问题，这些文件的描述与普通C程序有什么不同？是因为我们只使用内核调用吗？我们不能在Python中打开或编写一个文件吗？

发言人   46:59
I don't think I understand. It's AC program that's opening and writing a file. 
我不认为我理解。它是交流打开和写入文件的程序。

发言人   47:15
I don think I'm going to move on. All right so. You might ask what actually happens when maybe the question someone is doing it in C any different than doing in Python minus the syntax? Well, it's not really. There's certainly ways to. Python provides nice function calls for opening and doing all these things for opening files, for example, and reading, writing files. There are sort of a layer of there are higher, somewhat higher level functions, typically not you pointers than memory, for example. And Python does more error checking for you. But when you open a file in Python or write a file in Python, the Python calls you make boil down to system calls just like these. Is that a good answer? 
我不认为我会继续前进。好的，就这样。你可能会问，当有人在C中执行的问题与在Python中执行的问题有什么不同，减去语法吗？嗯，不是真的。当然有办法。Python提供了很好的函数调用，用于打开和执行所有这些操作，例如打开文件以及读取、写入文件。有一层有点高级的函数，通常不是你的指针，而是内存。而Python会为你做更多的错误检查。但是当你在Python中打开一个文件或在Python中编写一个文件时，你所做的Python调用可以归结为像这样的系统调用。这是个好答案吗？

发言人   48:25
Thanks so all right. All right, all right. I've been over here talking to the. 
谢谢，好的。好的，好的。我一直在这里和他们谈话。

发言人   48:39
XV 6 is Unix like shell, and the shell is what people often call the command line interface, as opposed to some more graphical user interface. The shell turns. If you haven't used the shell, the shell turns out to be pretty useful interface for things like system management of Unix system. It provides a lot of utilities for messing around with files and for programming development, and for writing scripts to do all these things. 
XV 6是类似于Unix的shell，shell是人们通常所说的命令行界面，与一些更图形化的用户界面相反。外壳转动。如果你还没有使用过shell，这个shell对于像Unix系统的系统管理这样的事情来说是非常有用的界面。它提供了许多实用工具，用于摆弄文件和编程开发，以及编写脚本来完成所有这些事情。

发言人   49:09
So you saw me before or run. I just want to demonstrate a few shell features. Ordinarily, when you type things, you're telling the shell to run a program. So when I type LS, what that means is I'm asking the shell to run the program whose name is LS. And what that really means is there's a file in the file system called LS. It contains some instructions, some machine instructions, and I'm asking Michell to run the instructions that are in the file called LS about LS and LS. What it actually does is get a listing of the files in the current directory, and you can see up there on the fourth line that among the other files that LS says exists in this list is a file called LS, which is in fact the file containing the instructions I just. 
所以你之前看到我或逃跑。我只是想演示一些shell功能。通常，当你输入东西时，你是在告诉shell运行一个程序。所以当我输入LS时，这意味着我要求shell运行名为LS的程序。这实际上意味着文件系统中有一个名为LS的文件。它包含一些指令，一些机器指令，我让Michell运行名为LS和LS的文件中的指令。它实际上所做的是获取当前目录下的文件列表，您可以在第四行看到，LS说在此列表中存在的其他文件中有一个名为LS的文件，实际上它是包含指令的文件。

发言人   50:02
The shell does a few other things for you other than running programs. It allows you to redirect IO. So for example, if I say LS greater than out, what that means is I'm asking the shell to run the LS command, but with its output redirected to the file called out, I run LS. We don't see any output because the output all went to out. And now I can out contains a bunch of data. We could the cat command, reads the file and displays the contents of the file. I say cat out. I'm just going to see now. Now this is the same output of LS. 
除了运行程序之外，shell还为你做一些其他事情。它允许您重定向IO。因此，例如，如果我说LS大于out，这意味着我要求shell运行LS命令，但其输出重定向到名为out的文件，我运行LS。我们看不到任何输出，因为输出全部转到了输出。现在我可以包含一堆数据。我们可以使用cat命令读取文件并显示文件内容。我说猫出去。我现在就去看看。现在这是LS的相同输出。

发言人   50:41
You can also run a command like GRE and I can give it an argument x and what gra x is. The grep command searches for patterns. Again, if I run grep x, it's going to search for lines of input that contain x, I can redirect, tell the shell to redirect its input from the file out in order to look for instances of x in that saved LS output. And it turns out there's 3D files whose names contain X's. 
你也可以运行像GRE这样的命令，我可以给它一个参数x和gra x是什么。grep命令搜索模式。再次强调，如果我运行grep x，它将搜索包含x的输入行，我可以重定向，告诉shell将其输入从文件重定向出去，以便在保存的LS输出中查找x的实例。结果发现有名称中包含X的3D文件。

发言人   51:15
We're going to spend a bunch of time with the shell. The shell is sort of the most traditional and fundamental interface to Unix is when Unix was first developed, all there was was simple terminal interfaces like the one we're using. And the main use of Unix originally was time sharing, a bunch of people logging into the same machine, much like Athena, and talking to shells. 
我们将花很多时间与贝壳在一起。shell是Unix最传统和最基本的接口，当Unix首次开发时，只有简单的终端接口，就像我们正在使用的那个。Unix最初的主要用途是分时使用，一群人登录同一台机器，就像Athena一样，与shell交谈。

发言人   51:44
A question about system calls and the compiler. How does a compiler handle system calls? Does assembly generated make a procedure call to some code segment defined by the operating system? 
关于系统调用和编译器的问题。编译器如何处理系统调用？生成的程序集是否会对操作系统定义的某些代码段进行过程调用？

发言人   51:57
There's a special risk 5 instruction that a program can call that transfers control into the kernel. So indeed, when you write C code that makes the system call like open A, right? I mean, technically what actually happens is open is AC function in the C library, but the instructions in that function are really machine instructions. It's not open. The open function that we're calling isn't AC function, it's implemented an assembler and the assembly code. Consists of this special instruction, it's actually called e call on the wris 5, this special instruction that transfers control into the kernel. And then the kernel looks at the processes, memory, and registers to figure out what the arguments with. 
有一个特殊的风险5指令，程序可以调用它来将控制转移到内核中。因此，当您编写使系统调用像打开一样的C代码时，对吗？我的意思是，从技术上讲，实际发生的是打开C库中的交流函数，但该函数中的指令实际上是机器指令。它不是开放的。我们正在调用的开放函数不是交流函数，它实现了一个汇编器和汇编代码。由这个特殊的指令组成，它实际上被称为wris 5上的e call，这个特殊的指令将控制转移到内核中。然后内核查看进程、内存和寄存器，以弄清楚参数的内容。

发言人   52:50
All right, the next example I want to look at is an example program that calls fork to create a new process. So this is the very simple use of fork. At line 12 we're calling fork. What fork does is creates a copy of the memory of instructions and data of the calling process. Now we have two processes with identical memory fork, the fork system called returns in both processes, in the original process, the fork syco returns the process ID, which is an integer greater than 0. The original process fork returns the process ID of the newly created process, and then the newly created process for returns zero. So we sort of break even though the processes have identical memory, we kind of break the symmetry of old versus new process by the return value from the fork, And in line 16, you can see code that checks and says if the process ID is equal to 0, must be the child. It must now be running in the child of. 
好的，我想看的下一个示例是一个调用fork来创建一个新进程的示例程序。所以这就是分叉的非常简单的用法。在第12行，我们调用了fork。fork所做的是创建调用进程的指令和数据的内存副本。现在我们有两个进程具有相同的内存分叉，称为分叉的系统在两个进程中都返回，在原始进程中，分叉syco返回进程账号，它是一个大于0的整数。原始进程分叉返回新创建的进程的账号，然后新创建的进程返回零。所以即使两个进程拥有相同的内存，我们也会因为fork的返回值而打破新旧进程的对称，在第16行，你可以看到代码检查并说明进程账号是否等于0，一定是子进程。它现在必须在的子级中运行。


发言人   54:00
Course, there's two processes, and then the other process and the calling process, which is usually called the parent, the process ID is greater than 0. So the child will print child and the parent I'll compare it, and then I'll both exit. So when I run for, here's what we get. So it may look like garbage, but what's actually happening is that after the fork, both of these processes are running. They're both running at the same time, and hemu is actually emulating a multi, a multi-core microprocessor for me. So they really are running at the very same time. And so when they produce output, they're producing each byte of their output at the same time as the other processes producing the corresponding byte of its output. So the outputs in the two processes are interleaved. 
当然，有两个进程，然后是另一个进程和调用进程，通常被称为父进程，进程账号大于0。所以孩子将打印孩子和父母，我会比较它，然后我将都退出。所以当我竞选时，这就是我们得到的。所以它可能看起来像垃圾，但实际发生的是，在分叉之后，这两个进程都在运行。它们都在同时运行，hemu实际上是在为我模拟一个多核微处理器。所以他们真的在同一时间跑步。因此，当它们产生输出时，它们会在其他进程产生其输出的相应字节的同时产生其输出的每个字节。因此，两个过程的输出是交错的。

发言人   54:52
You can see that they're both typing F, they're both going to type fork returned. So you can see the F from both of them and the O for both of them and the R for both of them, and so on one of them, you can see the zero at the end of that first line is in the child for return 0. And I'm guessing that in the parent for return 19, that is the child's process. I is 19 under x 6, that basically means the 19th process was created since boot and then one of them prints child and you can see the Ch ILD and interleaver. That is the other one printing parent. So this is sort of a silly use of fork, but we can see sort of vividly in this output that it's created two processes that are and both of them are running for returning both processes and they're both running, but also note that one printed child and the other parent. So it's important that fork returns differently in the two processes. 
你可以看到他们都在输入F，他们都将输入fork返回的类型。因此，您可以看到它们中的F和它们中的O，以及它们中的R，依此类推，您可以看到第一行末尾的零在子级中返回0。我猜在回程19的父母中，那是孩子的过程。I在x6下的值为19，这基本上意味着第19个进程是自启动以来创建的，然后其中一个进程会打印子项，您可以看到Ch ILD和交织器。那是另一个打印父。所以这是对fork的一种愚蠢的使用，但我们可以在这个输出中生动地看到它创建了两个进程，它们都在运行以返回两个进程，并且它们都在运行，但还要注意一个打印子进程和另一个父进程。因此，重要的是分叉在两个过程中返回不同的结果。

发言人   55:59
The question is the child process as a result of fork always identical to the parent process or could they be different I? In XV six, they're identical except for the return value from fork you. So the instructions the same, the data is the same, the stack is the same. And also both processes, the processes are copies, and they both have their own separate address spaces. That is, you know, they both have, they both think that their memory starts at 0 and goes on up from there. But it's different. It's different memory for the two of them. 
问题是由于fork导致的子进程总是与父进程相同，或者它们可能不同吗？在XV六中，除了fork你的返回值之外，它们是相同的。因此指令相同，数据相同，堆栈相同。这两个进程都是副本，它们都有自己独立的地址空间。也就是说，你知道的，他们都认为他们的记忆从0开始，然后从那里开始上升。但它是不同的。这对他们两个来说是不同的记忆。

发言人   56:45
In a more sophisticated operating system. There are some details which we definitely don't care about. They may occasionally cause parent and child are different, but in X 6, they're the same except the return value, so the memory is the same. In addition, the file descriptor table is copied, so if the parent some files open and the child sees the same set of file descriptors although the child is sending them in a copy of the table of file descriptor information. And so we'll see in a moment that it's quite important that fork copies the table of open file descriptors as well as the memory. 
在更复杂的操作系统中。有些细节我们绝对不关心。它们可能偶尔会导致父母和孩子不同，但在x6中，除了返回值之外，它们是相同的，因此内存是相同的。此外，文件描述符表被复制，因此如果父级打开了一些文件，并且子级看到了相同的文件描述符集，尽管子级在文件描述符信息表的副本中发送它们。因此，我们一会儿就会看到，fork复制打开的文件描述符表以及内存是非常重要的。

发言人   57:31
Okay, so port creates a new process, but when we run stuff in the shell, the shell indeed creates a new process to run each command that you type, but it needs to actually run the command in it. So if I type LS, we need a shallow forks to create a process to run an LS, but there needs to be some way for that new process. Actually run the instructions from the LS program, those instructions from the file called Lx and the example program I'm going to Nall show you in a minute, uses Echo. Echo is a very simple command that just takes whatever arguments he pass to it and writes them to its applic and I prepared for you a program called exec. 
好的，所以port会创建一个新进程，但是当我们在shell中运行东西时，shell确实会创建一个新进程来运行您键入的每个命令，但它需要实际在其中运行命令。所以如果我输入LS，我们需要一个浅分叉来创建一个运行LS的进程，但这个新进程需要有一些方法。实际上运行LS程序中的指令，这些指令来自名为Lx的文件和我马上要向您展示的示例程序，使用Echo。Echo是一个非常简单的命令，只需接受他传递给它的任何参数并将它们写入其应用程序，我为您准备了一个名为exec的程序。

发言人   58:23
Which which makes the exact system called? Which replaces the calling process with the instructions read from the file you specify, loads the instructions from that file over the current process, sort of discarding its current memory, and then starts executing those instructions. So the call to ex, the system call exec on line 12. It's going to have the effect of the operating system loading the instructions from the file called echo with the current process sort of replacing the memory of the current process, and then starting to execute those instructions. In addition, you can pass arguments, command line arguments. Echo exec allows you to pass an array of command line arguments. It's just an array of pointers and C of line 10 that sets up an array of character pointers, which are essentially strings, and initializes that array to be to contain the strings. 
哪个使确切的系统被称为？它将调用进程替换为从您指定的文件读取的指令，从该文件加载指令到当前进程，丢弃其当前内存，然后开始执行这些指令。所以对ex的调用，系统在第12行调用exec。这将产生操作系统从名为echo的文件中加载指令的效果，使用当前进程替换当前进程的内存，然后开始执行这些指令。此外，您可以传递参数、命令行参数。Echo exec允许您传递一个命令行参数数组。它只是一个指针数组，第10行的C用于设置字符指针数组，这些指针本质上是字符串，并将该数组初始化为包含字符串。


发言人   59:27
Echo. This is echo, and that's equivalent to calling running the echo with command with the three arguments. This is echo. And so when I run exec. Indeed, I see this output. This is echo, even though I ran the exact program. What the exact program does is call the exec system, call to replace itself with Echo. And so it was really the Echo program producing this output. And something about the exact system call that's important for us is that it exec preserves the current table of file descriptors. So whatever files descriptor 0, 1, 2, etc., were referred to before exec, they refer to the same thing in this new program whose instructions we loaded. 
回声。这就是echo，等效于使用三个参数调用运行echo命令。这是回声。所以当我运行exec时。我确实看到了这个输出。这是回声，即使我运行了确切的程序。确切地说，程序所做的是调用exec系统，调用以用Echo替换自身。所以实际上是Echo程序产生了这个输出。关于确切的系统调用，对我们来说很重要的一点是，它可以保留当前的文件描述符表。因此，无论在exec之前引用了什么文件描述符0、1、2等，它们都引用了这个新程序中我们加载的指令中的相同内容。

发言人   01:00:20
Another point is, ordinarily, exec does not return because exec replaces the current process is memory entirely. There's nothing for exec to return to, so exact reads the instructions from that file and execute them, and then that's it. The only time exec returns is if some error occurred that prevented the operating system from running that program for you. So for example, if the program doesn't, it would exist at all. Exec can't find a file called Echo, for example. Then exec would return negative one to signal that something I'm wrong. I couldn't find the file. So ordinarily exec does not return, it only returns if the kernel couldn't actually run the file for you. 
另外一点是，通常exec不会返回，因为exec会完全替换当前进程的内存。exec没有什么可以返回的，所以从该文件中精确读取指令并执行它们，就这样了。exec返回的唯一时间是发生某些错误阻止操作系统为您运行该程序。例如，如果程序没有，它就会存在。例如，Exec无法找到名为Echo的文件。然后，exec会返回负一，以表明我做错了什么。我无法找到该文件。所以exec通常不返回，它只在内核无法实际运行文件时返回。

发言人   01:01:10
Questions about Exec One question in the chat is what is the last zero for in arc-v? It marks the end of the array. C is so low level that there's no, the C array scheme doesn't have a way for code to find out how long the array is. 
关于Exec的问题聊天中的一个问题是arc-v中的最后一个零是什么？它标志着数组的结束。C是如此低级，以至于没有，C数组方案没有办法让代码找出数组的长度。

发言人   01:01:37
And so tell the kernel that. We meant that the array contains echo. This is echo and nothing more. We put a 0 is the last, the last pointer. Each of those strings in double quotes is actually a pointer to some memory that contains those bytes. That fifth element of the array is a pointer whose value is 0, and the convention is that a pointer whose value is 0, or what's called a null pointer. Sort of signifies nothing with it, and we're done. 
所以告诉内核。我们的意思是数组包含echo。这是回声，仅此而已。我们把0放在最后，最后一个指针。每个用双引号括起来的字符串实际上是指向包含这些字节的内存的指针。该数组的第五个元素是值为0的指针，而约定是值为0的指针或所谓的空指针。有点不代表什么，我们完成了。

发言人   01:02:12
And so the code in the kernel has actually walks through this array until it finds it element whose value is 0. 
因此内核中的代码实际上已经遍历了这个数组，直到找到其值为0的元素。

发言人   01:02:24
Okay, right. So this is how a program can replace itself with another program from a file. But actually, when we run stuff in the shell like Echo, ABC or LS or anything else, we don't want to replace the shell. We don't want to have the shell just call exact because that would replace the shell with the echo command. And then when echo exited, that would be it. 
好的，对。这就是一个程序如何从一个文件用另一个程序替换自己的方法。但实际上，当我们在shell中运行像Echo、ABC、LS或其他任何东西时，我们不想替换shell。我们不希望shell只调用确切的命令，因为这会用echo命令替换shell。然后当回声退出时，就是它了。

发言人   01:02:49
You know, we don't want echo to replace the shell. So what the shell actually does is fork, and then the child calls exec. 
你知道，我们不希望echo取代外壳。所以shell实际上做的是分叉，然后孩子调用exec。

发言人   01:02:56
And that's an extremely common eunuch idiom is provenance that want to run a program but regain control that they do is call fork and have a child call exec. So here's a simple example. This a fork exec program. So in this program called forca line 12, and the child started at line 14, we call exec Mosul before the child process has to replace itself with the echo command. And echo does this thing and then exits. And then the parent process reins control because the four returns the greater than zero value in the parent process. So the parent process then continues to execute at 19. 
这是一个非常常见的太监习语，即想要运行程序但重新获得控制权的起源，他们所做的是调用fork并有一个子调用exec。这里有一个简单的例子。这是一个分叉执行程序。因此，在这个名为forca第12行的程序中，子进程从第14行开始，我们在子进程必须用echo命令替换自身之前调用exec mossul。echo做了这件事，然后退出。然后父进程控制控制权，因为这四个在父进程中返回大于零的值。所以父进程继续在19执行。


发言人   01:03:42
And Unix provides a weight system called line 20 for process to wait for one of the A child that I created with four. Because when I run a command on the line, we want the shell to wait for the command to finish before it prints the prop again, before it prints dollar sign prompt asking me for more input. And so it's the weight system calling that allows the process to wait for any of its children to return. 
而Unix提供了一个名为第20行的权重系统，供进程等待我用四个创建的子进程之一。因为当我在命令行上运行命令时，我们希望shell等待命令完成，然后再次打印prop，再打印美元符号提示符，要求我提供更多输入。因此，它是权重系统调用，允许进程等待其任何子进程返回。

发言人   01:04:12
And this status argument, is that a way for an exiting child to communicate one integer 32 b value from the exiting child to the weighting parent so on line 17 that argument to exit that one, that's the argument to exit the operating system passes that one from the exiting child. So the call to weight at line 20, so weight the ampersand, and weight is passing the address of the status variable, the kernel, the kernel fills in that address with the child's argument to exit. And the convention in Unix is that if a program completes successfully, it exit exits with state is 0. But if it encountered an error as it lines 17, then the Unix convention is that you pass one to exit. And so if you care, the calling process can look at the status from weight and decide whether the child completed successfully in that. 
此状态参数是一种方式，使退出的子级可以将一个整数32 b值从退出的子级传递给加权的父级，因此在第17行中，退出该参数的参数是操作系统将该参数传递给退出的子级。因此，在第20行调用权重，因此权重与号，权重传递状态变量的地址，内核使用子变量的参数填充该地址以退出。Unix中的约定是，如果程序成功完成，则退出的状态为0。但是如果它在第17行遇到错误，那么Unix约定是传递一个以退出。因此，如果您关心，呼叫过程可以根据体重来查看状态，并决定孩子是否成功完成了这一点。

发言人   01:05:18
Professor Morris, quick question about the exec car on 915. We mentioned not a bit ago that exec will completely go into the Echo program and not return to fork exec. So would it ever reach line 16 and 17? Well, not for this exact code, because there happens to be a program called Echo. But you know, if I modified that code here, let me let me just modify this code for you. Okay, so first let me just run fork exec. It actually does execute echo with those arguments. 
莫里斯教授，关于915号的exec车的快速问题。我们之前提到过，exec将完全进入Echo程序，而不是返回fork exec。那么它会到达16号线和17号线吗？嗯，不是针对这段代码，因为碰巧有一个叫做Echo的程序。但是你知道，如果我在这里修改了代码，让我为你修改这段代码。好的，首先让我运行一下fork exec。它实际上会使用这些参数执行echo。

发言人   01:05:56
We see the output. This is echo and we see the child exited show that echo exited successfully and the parent waits for, let me just modify the program for you and instead of echo I'm going to run some command that doesn't exist. And I actually have to exit out of qmu with Ctr Ax and then rebuild the whole thing. In order to recompile, I modified 4 gigs. Now I run 4 gigs back again after modifying and compiling it. And this time because the program we're asking to actually. The program we're asking to execute doesn't exist except does return. 
我们看到了输出。这是echo，我们看到子级退出显示echo成功退出并且父级等待，让我为你修改程序，而不是echo，我将运行一些不存在的命令。我实际上必须使用Ctr Ax退出qmu，然后重新构建整个系统。为了重新编译，我修改了4个gigs。现在我在修改和编译后再次运行4 gigs。这次是因为我们实际要求的程序。我们要求执行的程序并不存在，除了返回。

发言人   01:06:41
We see the exec failed output and the exit 1, you see the one there is communicated back to the parent, which says the child exited the status one. So exec returns back to the calling function when something went wrong, yes? 
我们看到exec失败的输出和出口1，你会看到那里的出口与父级通信，这表明子级退出了状态一。所以当出现问题时，exec会返回调用函数，是吗？

发言人   01:07:08
Okay, good. 
好的，好的。

发言人   01:07:14
All something to note here that actually, I think many of you have already noted is that this is a common idiom here. 
这里需要注意的是，实际上，我想你们中的许多人已经注意到，这是一个常见的习语。

发言人   01:07:23
This fork, followed by an exec in the child, and it's potentially a bit wasteful. The fork copies the entire parent process, but exec throws away all that copied memory and replaces it with whatever is in the file that you're running. You know, if you're worried about this kind of stuff, the copy implied by the fork is in some sense mostly wasted because all that copied memory is thrown away and replaced by the ex. And this effects actually would be significant for big programs if you have a multi gigabyte programmer calls fork and it did indeed copy, all the memory would actually take a fair fraction of a second perhaps to do the copy, which could be a problem. But later in the course, you'll actually implement some optimizations, in particular, something called copy on write fork, which will eliminate almost all of the apparent inefficiency of fork copying, only to exact throw away the copy. It turns out, with a bunch of tricks involving a virtual memory system, you can build a fork that's lazy about the copy. And that doesn't do in the common case of fork immediately followed by exec, where you don't actually have to do the copy because the child doesn't actually use most of the memory. I think you can find that's a fun and interesting lab question from chat. 
这个分叉后面跟着一个exec，可能有点浪费。该分支复制整个父进程，但exec会丢弃所有复制的内存，并用您正在运行的文件中的任何内容替换它。你知道，如果你担心这种东西，分叉隐含的副本在某种感知上会被浪费掉，因为所有复制的内存都被扔掉了，取而代之的是ex。如果你有一个多千兆字节的程序员称之为fork，并且它确实复制了，那么这种影响对于大型程序来说实际上会非常重要，所有的内存实际上可能需要几分之一秒来进行复制，这可能会成为一个问题。但在课程的后期，您将实际实现一些优化，特别是称为 “写分叉时复制” 的东西，这将消除几乎所有的分叉复制的明显低效率，只会精确地丢弃副本。事实证明，通过一堆涉及虚拟内存系统的技巧，您可以构建一个懒惰于副本的分叉。这在通常的fork后面紧跟着exec的情况下是做不到的，在这种情况下，你实际上不需要进行复制，因为孩子实际上并不使用大部分内存。我想你可以从聊天中找到一个有趣的实验室问题。


发言人   01:08:52
Why does the parent process print parent waiting completely before the child calls exec? It's just chance. The is it, you know, the observation is that, you know? It could be that the parent's output could be interleaved with the child's output in the same area that we saw before. With the simpler fork example, it just happens not to be. There's no guarantee that this is the output we would see. We shouldn't be surprised if we saw the lines of the output in the other order. 
为什么父进程打印父进程在子进程调用exec之前完全等待？这只是机会。就是这样，你知道，观察是这样的，你知道吗？父母的输出可能与孩子的输出在我们之前看到的同一区域交错。使用更简单的分叉示例，它恰好不是。不能保证这是我们会看到的输出。如果我们看到输出的行以其他顺序排列，我们不应该感到惊讶。

发言人   01:09:32
Orange or leave. I suspect what's going on is that it takes a bit of time and effort. The exact system calls a little bit expensive because it to load all those, you have to access the file system and access the disk and read the contents of the file called echo off the disk into memory after allocating some memory, and that even after freeing some memory from the old process. So there's quite a bit of machinery involved in the exec system call. And apparently that takes long enough that the parent can complete producing the output before the exec is finished and started running Echo. Does that make sense? 
橙色或离开。我怀疑发生的事情是需要一点时间和精力。确切的系统调用有点昂贵，因为它要加载所有这些，你必须访问文件系统并访问磁盘，并在分配一些内存后将称为echo的文件内容从磁盘读取到内存中，即使在从旧进程中释放一些内存后也是如此。因此，在exec系统调用中涉及相当多的机器。显然这需要足够长的时间，以至于父级可以在exec完成并开始运行Echo之前完成输出。感知了吗？

发言人   01:10:15
We have another question. Is it convention that the child can't wait for the parent? There's not a way. Unix doesn't have a way for the child. There's no straightforward way for the child to wait for the parent. The wait system call is sort of the only mechanism available. 
我们还有一个问题。孩子不能等父母来，这是惯例吗？没有办法。Unix没有给孩子的方式。没有直接的方法让孩子等待父母。等待系统调用是唯一可用的机制。

发言人   01:10:37
Well, the weight system called weights for your children, and that's it. And so what weight does is if you have any children and one of them has already exited or does exit, then weight will return. But, you know, if you don't have any children, say, because you are, because, well, in this simple case, whether it was just a parent and a child, if a child called, wait, the child doesn't have any children. And in that case, we just returns immediately with a -1 error return saying this process doesn't have any children. Anyway, the short answer is there's no way for a child to wait for its parent to exit. 
这个体重系统被称为你孩子的体重，就这样。体重的作用是，如果你有任何孩子，其中一个已经退出或退出，那么体重就会回来。但是，你知道，如果你没有孩子，因为在这个简单的例子中，无论是父母还是孩子，如果一个孩子打电话，等待，孩子没有孩子。在这种情况下，我们只是立即返回-1错误返回，说这个进程没有任何孩子。无论如何，简短的答案是，孩子没有办法等待它的父母退出。

发言人   01:11:22
And another question when we say the child copies all the memory from the parent process, what exactly do we refer to by that? I thought the child, you're going to define the variables again. 
另一个问题是，当我们说孩子从父进程复制所有内存时，我们确切地指的是什么？我想孩子，你将再次定义变量。

发言人   01:11:39
Well, when you compile A, you know? After compilation, your C program is just a bunch of instructions in memory that live in Ram. And so those can be copied because they're just bytes living in Ram. Those can be copied somewhere else. And with appropriate tricks having to do with setting up sort of virtual memory mappings and make the mappings look the same in the childhood as in the parent, you can just copy the parent memory image to the child in executed in the trial. I mean, even though we're looking at C programs, you should think of them as just a bunch of machine instructions. Which was just bytes in memory that could be copied? 
当你编译一个时，你知道吗？编译后，你的C程序只是内存中的一堆指令，它们存储在内存中。因此这些可以被复制，因为它们只是存储在Ram中的字节。这些可以在其他地方复制。并且使用与设置虚拟内存映射相关的适当技巧，并使映射在童年时看起来与在父母身上相同，您可以将父母的内存图像复制到试验中执行的孩子身上。我的意思是，即使我们在看C程序，你也应该把它们看作只是一堆机器指令。内存中哪些字节可以复制？

发言人   01:12:31
If a parent has multiple children, would wait just return as soon as the first child finishes, meaning that there could be some more interleaving with the parent and unfinished children. Would there need to be multiple separate ways to ensure all children finish? Yes, yeah, if you call fork more than one, if a if a given process, call fork twice. Then, and it wants to wait for both children, it has to call wait twice, and each call to wait will return as soon as one of the children exits. You don't when we returns, you don't necessarily know which child is exited. The weight returns the child's process ID as its return value, so you can tell after weight returns which one it was at exhibited. 
如果父母有多个孩子，将等待第一个孩子完成后立即返回，这意味着与父母和未完成的孩子之间可能会有更多的交错。是否需要有多种不同的方法来确保所有孩子完成学业？是的，如果你调用fork不止一个，如果一个给定的进程，调用fork两次。然后，它想要等待两个孩子，它必须调用wait两次，每次调用wait都会在其中一个孩子退出后立即返回。当我们回来时，你不一定知道哪个孩子退出了。重量返回孩子的过程账号作为其返回值，因此您可以在重量返回后分辨出哪个孩子在展出。

发言人   01:13:22
As a final example I'd like to show. How all of these facilities combine to implement IO redirection? 
作为我想展示的最后一个例子。所有这些设施如何结合起来实现IO重定向？

发言人   01:13:37
If you remember, the shell provides us with this handy syntax. I can say echo hello greater than out, and that runs the echo command. That argument sending its first, that sends its output to the file out, and then we look it out. Or better yet, when the cap come in with its input connected from the out file, we can see that saved output from the echo command. 
如果你还记得的话，shell为我们提供了这种方便的语法。我可以说echo hello大于out，并运行echo命令。该参数首先发送其输出，然后将其输出发送到文件，然后我们查看它。或者更好的是，当cap从out文件连接其输入时，我们可以看到echo命令保存的输出。



发言人   01:14:06
The way the shell sets this up is as follows. It the shell first forks like on line 13 and then in the child, the shell changes the way the file descriptors are set up so that the child's file descriptor one, which by convention most programs used for that output, the shell changes the child's file De to one to refer to this output file and then runs whatever command you wanted. And that leaves the parent shells file script or one unchanged. So this idiom of forking and in the child changing around the file descriptors is the usual way in Unix to sort of redirect input and output for a command that you run but not affect the input and output for the calling program because we don't want to redirect the shell's output. We only want to redirect the child program's output. Anyway, the way this works, we call fork in the usual way. 
shell设置它的方式如下。如果shell首先像第13行那样分叉，然后在孩子中，shell改变了文件描述符的设置方式，使得孩子的文件描述符成为一个，按照惯例，大多数程序都用于该输出，shell将孩子的文件De更改为1以引用此输出文件，然后运行您想要的任何命令。这使得父shell文件脚本或一个保持不变。因此，这种分叉和在子级中更改文件描述符的习惯用法是Unix中重定向您运行的命令的输入和输出的通常方式，但不会影响调用程序的输入和输出，因为我们不想重定向shell的输出。我们只想重定向子程序的输出。无论如何，这种工作方式，我们以通常的方式称之为分叉。

发言人   01:15:16
Line 15 only executes in the child, the reason for the close one on line 15 is that in this program, we're redirecting just the output of the echo command. So when I run this redirect program produces no output itself, but it ran echo with this output directed to output dot Xt. So when I look at output dot Xt. I see this expected output. 
第15行只在孩子身上执行，第15行关闭的原因是在这个程序中，我们只是重定向了echo命令的输出。所以当我运行这个重定向程序时，它本身不会产生任何输出，但是它会运行echo，并将这个输出定向到output dot Xt。所以当我看到输出点Xt时。我看到了这个预期输出。


发言人   01:15:41
The reason for the closed one on line 15 is that we want one of conventional output file script to refer to something else. It happens, so we don't, I, the child, we don't want to use the file of scripture 1 that the shell had that's connected to the console. 
第15行关闭的原因是我们希望传统的输出文件脚本引用其他内容。它发生了，所以我们不，我，孩子，我们不想使用shell所拥有的连接到控制台的scripture 1文件。

发言人   01:15:59
The call to open on line 16 is guaranteed to return one because the semantics of open are that open returns to lowest file descriptor number that's not currently in use in the calling process since we just closed one. And file descriptor 0 is still connected to the console, open is guaranteed to return one. So after the line 16 file, scripture 1 is connected to this file. And when the exact echo echo just writes its output, the file scripture 1. And now it goes to this file. And the cool thing about this is echo had no idea what's going on. Echo doesn't need to know about Ioe direction at all. It just writes itself out with the file descriptor one, only the shell knows about IO direction. 
第16行对open的调用保证返回一个，因为open的语义是open返回到调用过程中当前未使用的最低文件描述符编号，因为我们刚刚关闭了一个。并且文件描述符0仍连接到控制台，打开保证返回一个。所以在第16行文件之后，脚本1连接到这个文件。当精确的echo echo写入其输出时，文件脚本1。现在它转到这个文件。最酷的是，echo完全不知道发生了什么。Echo根本不需要知道关于iae方向的信息。它只是用文件描述符写出来，只有shell知道IO的方向。

发言人   01:16:52
This example also illustrates the sort of kind of neatness of the separation between fork andixius. The fact that fork and exec are separate system calls, separate functions means that there's a period of time in the child between the fork, between fork returns in the child and exec. We're still running the calling process as instruction, so the calling process, even though it's running, even though the instructions are running in the child, it's still the calling processes, instructions that are executing. And so the calling process is still able to change things still in control up until line 19. And this sort of interval between fork and SEC gives the shell a chance to change what the file descriptions refer to. For example, I think questions about this redirect example. 
这个例子也说明了叉子和dixius之间分离的那种整洁性。事实上，fork和exec是单独的系统调用，单独的函数意味着在fork之间的孩子中有一段时间，在孩子和exec之间的fork返回之间。我们仍将调用进程作为指令运行，因此即使调用进程正在运行，即使指令在子进程中运行，它仍然是调用进程，指令正在执行。因此，调用进程仍然能够更改仍在控制中的事物，直到第19行。这种fork和SEC之间的间隔使shell有机会更改文件描述的内容。例如，我思考有关这个重定向示例的问题。

发言人   01:17:55
All right, we're got out of time. Just wrap up. We looked at unix's, a bunch of the interfaces to unix's IO and process abstractions. A thing to take away from this is that the interfaces are relatively simple. You just pass integers like file descriptors and process Ids back and forth across as arguments, system calls, but sort of all the functionality inside the interfaces is relatively sophisticated, creating new processes and copying the current process. And furthermore, I showed some examples of ways in which the abstraction is, though individually simple, combine in useful ways. For example, to produce IO direction. 
好了，我们没时间了。结束吧。我们研究了unix，一堆unix IO和进程抽象的接口。需要说明的一点是，这些接口相对简单。您只需将文件描述符和进程ID等整数作为参数和系统调用来回传递，但接口内的所有功能都相对复杂，可以创建新进程并复制当前进程。此外，我还展示了一些抽象方式的例子，尽管它们各自简单，但却以有用的方式结合在一起。例如，产生IO方向。

发言人   01:18:44
There's a lab due at the end of next week, and that lab involves writing more simple utilities like the ones I showed that use the system calls that we discuss. So have fun with that lab, and we'll see you in class next week. And that's it? 
有一个实验室将在下周结束，该实验室涉及编写更简单的实用程序，例如我展示的使用我们讨论的系统调用的实用程序。所以在那个实验室玩得开心，我们下周在课堂上见。就这样？


发言人   01:19:15
Since I'm the one recording, how do I end this? My first time recording is in lecture, I think, where we exit, okay, and nothing special. I can just exit and it'll be saved somewhere. Yes, awesome. Zoom will create some directory and stick the file in that directory. There's also office hours right after this, right? Yes, perfect, cool. All right, all right, thank you. And I'll see you next week, thanks. 
因为我是唯一的录音，我该如何结束这件事？我的第一次录音是在讲座中，我想，我们离开的地方没什么特别的。我可以退出，它会被保存在某个地方。是的，太棒了。Zoom将创建一些目录并将文件粘贴到该目录中。这之后还有办公时间，对吗？是的，完美，酷。好的，好的，谢谢。我下周见，谢谢。
