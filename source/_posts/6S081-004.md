---
title: 操作系统工程 004-RISC-V Calling Conventionand StackFrames
date: 2025-10-18 10:00:04
---


发言人   00:01
Yeah? Can maybe people hear what I'm saying? Or you're good, good for awesome. So I just want to get started with similar to last week, where we asked you about the util lab, I just want to get started by asking a little bit about cyss call lab since that was due on Thursday. So if anybody just has like something particularly interesting they found about the lab or a nasty bug that they found, or just a silly mistake they made, anything you want to share about the syscall lab that be, that'd be great. 
是吗？也许人们能听到我在说什么吗？或者你很好，非常棒。所以我只是想开始像上周一样，我们问了你关于util实验室的问题，我只是想先问一些关于cyss call实验室的问题，因为那是上周四到期的。所以，如果有人发现了一些关于实验室的特别有趣的东西，或者发现了一个讨厌的错误，或者只是犯了一个愚蠢的错误，那么你想分享关于syscall实验室的任何事情，那就太好了。

发言人   00:38
I somehow managed to delete the part from where from fork where you have to copy over the mask. So I had that working, and then I changed something else, and then I tested it. Your audio is like cutting out, I think. Oh, it is. Sorry, you hear me? I hear you, oh, okay. Yeah, I guess so. Basically, I deleted somehow the copy of the mask and then my fork didn't work anymore. So then I was just like, I did that, how does it not work? So spend a lot of time figuring out what I did wrong, and I realized I just deleted that line. 
我不知怎么设法删除了分叉中你必须在面具上复制的部分。所以我让它工作起来，然后我改变了其他东西，然后我测试了它。我觉得你的音频就像剪切一样。哦，它是。抱歉，你听到了吗？我听到了，哦，好的。是的，我想是的。基本上，我以某种方式删除了口罩的副本，然后我的叉子就无法工作了。所以那时我就像那样，我做了，它怎么会不起作用呢？所以花了很多时间弄清楚我做错了什么，我意识到我刚刚删除了那一行。

发言人   01:22
Is anybody having trouble hearing Luca or is that on my end? I think it's on your end. Yeah, I hear I'm fine. This must be on my end. 
是有人听Luca有困难吗，还是在我这？我想它在你那一端。是的，我听说我很好。这一定是我的目的。

发言人   01:56
Sorry, maybe that'll work better now. Can you hear me now? Okay great, I was worried that I was just talking. Seems to be on my end, all right? 
抱歉，也许现在会更好。你现在能听到我说话吗？好的，太好了，我担心我只是在说话。好像是我的目标，好吗？

发言人   02:17
Awesome, why? Anybody else have anything they'd like to share about you or assist call? Anything particularly interesting? Or was the lab absolutely horrendous and you think we should cut it out of the class, never do it again? 
太棒了，为什么？还有其他人有什么想要分享的关于你或协助呼叫的事情吗？有什么特别有趣的吗？还是实验室真的很可怕，你认为我们应该把它从班上删掉，永远不要再做了？

发言人   02:33
I have something. Apparently the order of things matters, which is a general statement. So I tried to determine the mask computation inside the sys call function before determining whether I actually needed to do the tracing. And so all the Cycas were getting correctly traced except the trace call. And I was really getting disturbed by that until I think it was David who pointed out, you know, you should do the computation after you. You shouldn't trace. It was like, that's all. I'm glad you were able to catch that. 
我有一些东西。显然，事物的顺序很重要，这是一个一般性的陈述。因此，在确定我是否实际需要进行跟踪之前，我尝试确定sys调用函数中的掩码计算。因此，除了跟踪调用之外，所有的苏铁都被正确跟踪了。我真的对此感到不安，直到我认为是大卫指出的，你知道，你应该在你之后进行计算。你不应该追踪。就像，这就是全部。我很高兴你能抓住这个。

发言人   03:15
Yeah, order does matter, especially for page tables. You'll find, I think, that order matters there as well. And generally throughout the class, paying attention to the order of things will be important. It's good to not overwrite things in page table. 
是的，顺序确实很重要，尤其是对于页表。我想，你会发现那里的秩序也很重要。一般来说，在整个课堂上，注意事物的顺序是很重要的。最好不要覆盖页表中的内容。

发言人   03:31
I also had something which I'm actually still confused about. Well, I had a lot of debugging print statements in the kernel code. I then ran the trace thing with all of the bit set, so basically tracing all the system calls, and I think I saw a lot of tracing for the print statements in the kernel. And then because, and then I assumed that my print, my print F's were trying to read and write to the console, but then to write to the console. But then I was wondering, why are we, I guess I'm just confused why we're able to use printf in the kernel? 
我也有一些我仍然感到困惑的事情。嗯，我在内核代码中有很多调试打印语句。然后我用所有位集运行了跟踪程序，基本上跟踪了所有的系统调用，我认为我在内核中看到了很多对print语句的跟踪。然后因为，然后我假设我的打印，我的打印F尝试读取和写入控制台，但随后要写入控制台。但是后来我想知道，为什么我们，我想我只是感到困惑，为什么我们能够在内核中使用printf？

发言人   04:22
Yeah I'm not AI haven't looked at the printf code recently, but I think there's a file printf DOC that you might be able to look at if you want to. Figure out what was going on there. So I think the printf function should be implemented in there. At least our version of it. 
是的，我不是AI，最近没有查看printf代码，但我认为如果您愿意，您可能可以查看一个文件printf文档。弄清楚那里发生了什么。所以我认为printf函数应该在那里实现。至少是我们的版本。

发言人   04:42
I don't know, perhaps one of the one of some of the other core staff might know what's going on. The prenex in the kernel shouldn't show up in your traces because printf in the kernel doesn't call any system calls. Yeah, that's what I thought. Maybe that maybe the tracing was not from that. Yeah, I don't think it is from your prints in the colonel, okay? 
我不知道，也许其他核心员工中的一个可能知道发生了什么。内核中的prenex不应该出现在您的跟踪中，因为内核中的printf不调用任何系统调用。是的，我也是这么想的。也许追踪可能不是从那里开始的。是的，我不认为这是上校的指纹，好吗？

发言人   05:12
Okay, well, unless anybody has any other burning comments about Sysco, I think we can get started with lecture for today. 
好的，除非有人对Sysco有任何其他燃烧的评论，我想我们可以开始今天的讲座了。

发言人   05:23
I'll be talking a little bit about the process of converting C two assembly and processors. And this is more of kind of a practical lecture today, or at least that's the aim. So the goal here is to get you all familiarized with risk 5, the processor, the assembly language, and the calling conventions for risk 5. And this will be important in not, not super important for a page table, but certainly for the traps lab, which is will be assigned later this week. This will be essential for debugging and implementing things because you'll be working quite intimately with trap frames and the stack and things like that. So that's the, that's kind of the goal for today. 
我将稍微谈论一下转换C两个汇编和处理器的过程。这更像是今天的一场实用讲座，或者至少这是目的。所以这里的目标是让大家熟悉风险5、处理器、汇编语言和风险5的调用约定。这对于页表来说并不重要，但对于陷阱实验室来说肯定很重要，这将在本周晚些时候分配。这对于调试和实现事物是必不可少的，因为您将非常密切地使用陷阱帧和堆栈等。这就是今天的目标。

发言人   06:09
And my first aim was to, and this might be a little bit of review from 6 0 0 4 or any other computer architecture theme classes that you may have taken in the past, but I just want to go over briefly kind of C, the C language, how we get to assembly, and maybe a little bit about processor throughout. And of course, throughout this lecture, feel free to interrupt with any questions that you have. So you know, we have our normal main functions in C, you know, they do something, maybe they print something. Then they exit. And this all looks well and good, but as any of you are aware from 6 0 0 4 processor, don't actually understand the C language. Rather, they understand what we call assembly. Or more specifically, they understand the binary encodings of assembly. 
我的第一个目标是，这可能是对60 0 0 4或您过去可能学习的任何其他计算机体系结构主题课程的一些回顾，但我只是想简要介绍一下C语言，如何实现汇编，也许还有一点关于处理器的内容。当然，在整个讲座中，如果你有任何问题，请随时打断。所以你知道，我们在C中有我们正常的主要函数，你知道，它们做一些事情，也许它们会打印一些东西。然后他们退出。这一切看起来都很好，但是正如你们中的任何人所知，从6 0 0 4处理器来看，实际上并不理解c语言。相反，他们理解我们所谓的组装。或者更具体地说，他们理解程序集的二进制编码。


发言人   07:10
And so this here I've circled a picture of an actual risk 5 processor from a Psi five board. And when we say a processor is risk 5, that means that it understands the risk 5 instruction set. So every processor has an associated Isa or instruction. And that's kind of the set of instructions that make sense to that processor. So every instruction has an associated binary encoding or an opco, and when a processor is running and it sees a particular encoding, it knows what to do. And so, you know, this processor on this board happens to understand the risk five assembly, which is what C code is compiled to. 
因此，我在这里圈出了一张来自Psi 5板的实际风险5处理器的图片。当我们说一个处理器是风险5时，这意味着它理解风险5指令集。每个处理器都有一个关联的Isa或指令。这就是感知处理器的指令集。因此，每条指令都有一个相关的二进制编码或opco，当处理器运行时，它会看到一个特定的编码，它知道该怎么做。所以，你知道，这个电路板上的处理器恰好理解风险五汇编，也就是C代码编译的目标。

发言人   07:58
So the general process of getting C code to actually run on your processor is we start with C, it gets compiled to assembly, and there's some linking and things like that that happened between the step. But that's we're not a compiler's class. So, and then the assembly will then be translated into binary. And so this is the object or doo files that you see. So if you've ever paid attention to what's inside of your lab directory after you run, make CMU, you'll see a bunch of data files lying around. And those are the actual object files that the processor understands and the ASM files you've also seen, you haven't really written any, but if you recall from syscall uys, dopler is compiled to a file called usys DOS. And so DOS files are assembly language. And so you've certainly seen some risk five assembly and 0 0 4, I believe you've also seen a good amount of assembly language. 
因此，让C代码在处理器上实际运行的一般过程是我们从C开始，它被编译为汇编，并且在步骤之间发生了一些链接和类似的事情。但我们不是编译器的类。这样，然后程序集将被翻译成二进制。所以这是你看到的对象或doo文件。因此，如果您在运行meptcmu后注意到实验室目录内有什么，您会看到周围有一堆数据文件。这些是处理器可以理解的实际目标文件，以及您也见过的ASM文件，您实际上并没有编写任何文件，但如果您还记得syscall uys，dopler被编译到一个名为usys DOS的文件中。所以DOS文件是汇编语言。所以你肯定已经看到了一些风险5汇编和0 0 4，我相信你也看到了大量的汇编语言。

发言人   09:05
Assembly looks general, much less structured than C, so you'll just see line after line after line of instructions. You know, you'll see simple things like ad malt, etc and so on and so forth. And this doesn't have, there's no nice control flow, there's no loops, there are functions, but not in the sense that you might remember, know from C, you know, we see labels as opposed to true function definitions and the assembly. So it's a much lower language. And there are plenty of other languages that are also compiled to assembly. So the same process holds true for things like C++, you know, any, any language that's compiled will go to the same assembly language at the base. And so that's kind of the basic process of getting our computer to actually understand the C code that we're writing. 
汇编看起来一般，比C结构化得多，所以你只会看到一行一行又一行的指令。你知道，你会看到简单的东西，比如广告麦芽等等。而这并没有什么，没有漂亮的控制流，没有循环，有函数，但不是在你可能记得的感知中，从C知道，你知道，我们看到的标签与真正的函数定义和程序集相反。所以它是一种低级的语言。还有很多其他语言也被编译为汇编语言。所以同样的过程也适用于像C ++ 这样的东西，你知道，任何编译后的语言都将转到同一个汇编语言的基础上。这就是让我们的计算机真正理解我们编写的C代码的基本过程。


发言人   10:06
But you'll notice that we've been referring to risk five assembly throughout the course. And the processor is risk 5. And that's because it's important because there's many different kinds of assembly. So it's unlikely that you're using risk 5 yourself, like you're not going to be running Linux on it. And instead, most modern computers will run on what's called x 86, or you'll sometimes see it as X 8664. 
但你会注意到，我们在整个课程中一直提到风险五组装。处理器的风险为5。这是因为它很重要，因为有许多不同类型的装配。因此，您自己不太可能使用风险5，就像您不会在上面运行Linux一样。相反，大多数现代计算机将在所谓的x86上运行，或者您有时会看到它为x8664。


发言人   10:37
And this is, this is a different Isa, this is a different instruction set. It looks pretty similar to risk 5, but this is what you see in kind of your personal computers often. So if you use an Intel, so Intel Cpu's implement x 86, and I believe AMD also do. And this is relatively important distinction between the two. They're not quite as similar as they may look at first. And that comes down to the fact that risk 5 is what we call. So risk, the risk part of risk 5 refers to a reduced instruction set and X 8664 is what's called a CISC, or complex instruction set. 
这是一个不同的Isa，这是一个不同的指令集。它看起来与风险5非常相似，但这是您经常在个人计算机中看到的。所以如果你使用英特尔，那么英特尔Cpu的实现x86，我相信AMD也会这样做。这是两者之间相对重要的区别。他们并不像起初看起来那么相似。这归结于我们所说的风险5的事实。所以风险，风险5的风险部分指的是精简指令集，而X 8664则被称为CISC或复杂指令集。

发言人   11:34
And there's a couple of key differences here. One is just the number of instructions that are present in X 8664. In fact, one of the big motivations for writing, for making risk 5 was how many instructions we actually have in the Intel kind of handbook. So for reference, there's three full books that encompass the Isa and some statistics. I think there's new instructions have been added at a rate of three instructions per month since X 8664 was added. It was first published in the 70s, so I believe there's like north of 15000 instructions. In X 8664 and Risk 5, on the other hand, the assembly for risk five can be nicely contained within two documents. Kind of going off of that. 
这里有几个关键区别。一个只是X 8664中存在的指令数量。事实上，编写风险5的主要动机之一是我们在英特尔类型的手册中实际拥有多少指令。因此，作为参考，有三本完整的书涵盖了Isa和一些统计数据。我认为自添加x8664以来，每月以三条指令的速度添加了新指令。它最初是在70年代出版的，所以我相信有15000个说明。另一方面，在X 8664和风险5中，风险5的程序集可以很好地包含在两个文档中。有点偏离了那个。

发言人   12:44
We don't expect you in this course to memorize every single risk 5 instruction. But if you are interested or you ever find yourself confused by what a specific instruction is or does, if you go to the course website and we look under the references tab, under risk 5, we give you the links to both the privileged and unprivileged instruction sets. 
我们不希望你在这门课程中记住每一个风险5指令。但是，如果您感兴趣或发现自己对特定指令的内容或做法感到困惑，如果您访问课程网站，我们在参考标签下查看，在风险5下，我们会为您提供特权和非特权指令集的链接。

发言人   13:10
So this is kind of the document that gives you a whole bunch of information about the Isa. But you'll note that like this is 240 pages and this is 135 pages. So it's significantly, significantly smaller than the x 86 instruction. That's one of the nice things about about risk 5. 
所以这是一种文档，它为您提供了有关Isa的大量信息。但是你会注意到，这个是240页，这个是135页。所以它比x86指令小得多。这是关于风险5的好处之一。



发言人   13:33
So we have in risk 5, we have fewer instructions. And not only that, the instructions are simpler. So what I mean by that is that there are many instructions in X 8664 by instruction. I'm referring to something like Add or MD or sub in X 8664. There's plenty of instructions that do more than one thing. So they perform some complicated set of operations and then get you the result. 
所以我们在风险5中，我们的指令较少。不仅如此，说明也更简单。我的意思是，在X 8664中有许多指令是通过指令实现的。我指的是x8664中的添加或MD或sub之类的东西。有很多指令可以做不止一件事情。所以他们执行一些复杂的操作，然后得到结果。


发言人   14:07
And that's not not the case with risk 5. Risk 5 instructions tend to be smaller in scope and so they take no, it's less cycles to run each instruction and maybe x 8664 is, and this is just a trade off that the designers chose to undertake take there's nothing or, you know, there's no canonical reason why a reduced instruction set is better than, you know, complex in instruction set. They each have their own uses and so on and so forth. 
风险5并非如此。风险5指令的范围往往较小，因此它们不需要，运行每条指令的周期较少，可能x 8664也是如此，这只是设计人员选择采取的权衡，或者什么都没有，你知道的。没有规范的理由说明为什么精简的指令集比复杂的指令集更好。它们都有自己的用途等等。

发言人   14:40
And another, another cool thing about risk 5 as opposed to x 86 is that this is open source. So it's one of the only open source instruction sets on the market. So that means anybody can develop a board for risk 5. And it was, it came out of a research project from UC Berkeley. And so that's kind of where where Clive started. And since then it's been picked up and supported by a number of companies. You can find the list online, but there's tons of big companies that are interested in supporting an open instruction set. 
另外，与x86相比，风险5的另一个很酷的事情是它是开源的。因此，它是市场上仅有的开源指令集之一。这意味着任何人都可以开发一个风险板5。它来自于伯克利优视的一个研究项目。所以这就是Clive开始的地方。从那时起，它得到了许多公司的支持和支持。你可以在网上找到这个列表，但是有很多大公司对支持开放指令集感兴趣。

发言人   15:15
And actually, I think quite recently, there was an announcement made by Sci Fi, who are sort of the premier board manufacturer for Risk live processors that they will be releasing a board for personal computers that should ostensibly, you know, a risk life processor designed to run Linux for personal computers. And I think that that's been released in the last week or 2, the announcement about it. So if you're, if you're curious, if you're find yourself, you know, absolutely, you know, I want to use risk 5 after I finish 6 0 8 1 hopefully by that time, there will be a processor available that you can run Linux on on your own computer. 
实际上，我认为最近，科幻小说宣布，他们是风险实时处理器的首要板块制造商，他们将发布一个用于个人电脑的板，表面上应该是一个为个人电脑设计的风险生命处理器。我认为这已经在上周或上周发布了，关于它的公告。所以如果你，如果你很好奇，如果你发现自己，你知道，绝对，你知道，我想在我完成6 0 8 1后使用风险5，希望到那时，会有一个处理器可用，你可以在自己的计算机上运行Linux。

发言人   15:55
But even in your day to day lives, you're most likely using reduced instruction sets, even if you don't realize it. So the arm assembly, so that's ARMM this is also a reduced instruction set and Arm is implemented by Qualcomm, the Snapdragon series of processors, so if you have an Android phone. You are most likely running a reduced instruction set. And even if you're using iOS, iOS, I think I forget what the name of it is, that Apple has some has some version of Arm that they also implement in their own processors that runs on iPads, iPhones, and most mobile Apple devices. So, you know, reduced instruction sets are present all over the place. 
但即使在日常生活中，即使你没有意识到，你也很可能使用精简的指令集。所以arm汇编，这就是Arm，这也是一个精简的指令集，arm是由高通 (骁龙系列处理器) 实现的，所以如果你有一台安卓手机。您很可能正在运行精简指令集。即使你使用的是iOS，iOS，我想我忘了它的名字是什么了，苹果有一些版本的Arm，他们也在自己的处理器中实现，运行在iPad，iPhone和大多数移动苹果设备上。所以，你知道，简化的指令集无处不在。

发言人   16:50
And if you're looking for risk 5 in the real world, you know, outside of your qmu, you'll be able to find that in like integrated devices. So it is present. It's not as it's certainly not as ubiquitous as something like X 8664, but it's ISS. Yes, yes, I think Apple is, as Luke has just said in the chat, I think Apple is moving Max to Arm. I believe that's also the case. 
如果你在现实世界中寻找风险5，你知道，在你的qmu之外，你可以在类似集成设备中找到它。所以它是存在的。它并不像X 8664那样无处不在，但它确实是ISS。是的，我认为苹果是，就像卢克在聊天中说的那样，我认为苹果正在将马克斯转移到手臂上。我认为情况也是如此。

发言人   17:20
There's been in the last few years, there's definitely been a push towards reduced instruction sets given, given how big the Intel Isa has gotten and the reason why Intel's Isa is so big is because they're very concerned with backwards compatibility. So if you write, you know, a modern Intel processor can run the same instructions that Intel code from, you know, 30, 40 years ago was written in. So they don't really deprecate any instruction so that they maintain backwards compatibility and risk 5 is more modern. So that's not a worry. 
在过去几年中，考虑到英特尔Isa已经变得如此之大，肯定有一种朝着精简指令集方向发展的趋势，而英特尔Isa如此之大的原因是因为他们非常关注向后兼容性。所以如果你写的东西，你知道，一个现代的英特尔处理器可以运行与30、40年前的英特尔代码相同的指令。因此，他们不会真正弃用任何指令，以便保持向后兼容性，并且风险5更加现代。所以这不是一个担忧。


发言人   17:53
Risk 5 is also so if we jump back to those manuals, risk 5 is unique in that it's divided. We have what's called the base integer instruction set, which all risk 5 processors. If we have. So Gabriel asks in the chat, if we have 15000 instructions, is it nearly impossible to efficiently pipeline them? Why do we need so many, like I was saying, we need so many for backwards compatibility reasons. It's up to you to decide, you know, whether you think that that's super important. But many of those instructions, I think a ton of them are also eaten up by Cmd instructions, which are their own kind of special class of things you won't. I've never seen Intel assembly code that makes full uses, full usage out of the 15000 instruction. 
风险5也是如此，如果我们回到那些手册，风险5是独特的，因为它是分开的。我们有所谓的基本整数指令集，它们都有5个处理器的风险。如果我们有。所以加百利在聊天中问，如果我们有15000条指令，是否几乎不可能有效地将它们流水线化？为什么我们需要这么多，就像我说的，出于向后兼容性的原因，我们需要这么多。由你来决定，你知道，你是否认为这非常重要。但是其中许多指令，我认为其中吨指令也会被Cmd指令吃掉，这些指令是它们自己的特殊类别，你不会这样做。我从未见过英特尔汇编代码能够充分利用、充分利用15000指令。


发言人   18:39
Mostly this comes from from a need for backwards compatibility and Cindy, but like I was saying, so risk 5 has what's called the base integer instruction set, which contains all of the normal add and multiply things. And then processors can choose to implement a number of other modules which you can see along the it's probably impossible to read on your screen. But for example, if you want a processor know that supports standard extension for single precision floating point, then you can include the F module. And this makes it easier for risk 5 to support backwards compatibility. Because if you can just say, you know, what set of the modules do I include and support and the compiler can choose, then the compiler can say, okay, you know, this processor is telling me it supports these modules. So I can only compile this code with these modules. 
这主要是因为对向后兼容性和Cindy的需求，但就像我说的，风险5拥有所谓的基本整数指令集，其中包含所有正常的加和乘操作。然后处理器可以选择实现许多其他模块，您可以在屏幕上看到它们可能无法阅读。但是，例如，如果你想要一个处理器支持单精度浮点的标准扩展，那么你可以包括F模块。这使得风险5更容易支持向后兼容性。因为如果你可以说，你知道，我包括和支持哪些模块集，编译器可以选择，那么编译器可以说，好的，你知道，这个处理器告诉我它支持这些模块。所以我只能用这些模块编译这段代码。


发言人   19:33
Okay, bib says it seems that the only advantage of using x 86 instead of Risk 5 processor is the kind of performance you can get. However, that performance compass is massive cost and complexity and potential security. 
好的，bib说，使用x86而不是风险5处理器的唯一优势似乎是您可以获得的性能。然而，性能指南针是巨大的成本、复杂性和潜在的安全性。

发言人   19:45
My question is, why are we still using x 86 instead of moving to something like risk 5? Well, the big answer to that is the world has run on x 86 for. I don't have a great answer for why Earths 5 is pretty modern too. So the world as a whole pretty much runs on x 86. So if you suddenly start converting your processors to risk five, you run the risk of, you know, losing support for a bunch of important things. Also, there are like Intel does do interesting things within their processors, like security wise. There are enclaves in Intel processors and there's things that they've been doing in recent years try to try and give you extra edit security and some of those instructions that Intel does implement which are hyper specific cific can be really efficient for certain computations. 
我的问题是，为什么我们仍然使用x86而不是像风险5这样的东西？这个问题的重要答案是，世界已经在x86上运行了。我对为什么地球5也很现代没有很好的答案。所以整个世界基本上都是在x86上运行的。因此，如果您突然开始将处理器转换为风险五，您将面临失去对许多重要事物的支持的风险。此外，就像英特尔确实在他们的处理器中做了一些有趣的事情，比如安全方面。在英特尔处理器中有一些飞地，近年来他们一直在做一些事情，试图为您提供额外的编辑安全性，以及英特尔实施的一些超特定指令，这些指令可以真正有效地用于某些计算。


发言人   20:43
And so they have so many instructions that there's often, you know, a perfect instruction for a situation that may be more efficient than than what exists within Risk 5. But a more practical answer is that Risk 5 is relatively new and we just don't nobody's really making processors for personal computers. I think the Sci Fifi announcement is super recent and they're kind of the first people to be doing that. So on a practical level, that and the inability to run all the software design for Intel is my best answer. 
因此，他们有太多的指示，你知道，通常有一个完美的指示，用于一种情况，可能比风险5中存在的更有效。但更实际的答案是，风险5相对较新，我们只是没有人真正为个人电脑制造处理器。我认为科幻小说的公告是最近才发布的，他们是第一批这样做的人。因此，在实践层面上，无法运行英特尔的所有软件设计是我最好的答案。

发言人   21:16
We've been now chatting a little bit about assembly, so I just wanted to take a look at some actual assembly code. 
我们一直在聊汇编的事情，所以我只是想看一下一些实际的汇编代码。


发言人   21:26
So here is the C code for what's below. So this is a simple function that has an accumulator. We loop from 0 to n, and we sum up all the numbers from 0 to n, and then return that value. And at its simplest level, you know, this is the easiest kind of assembly you can get out of compiling that program if you actually go into your own computer and you write the C code and you try to compile it, you will end up with something that likely looks quite different. 
所以这是下面的C代码。所以这是一个简单的函数，有一个累加器。我们从0到n循环，将从0到n的所有数字相加，然后返回该值。在最简单的层面上，你知道，这是编译该程序所能得到的最简单的汇编类型，如果你真的进入自己的计算机，编写C代码并尝试编译它，最终你会得到一些看起来完全不同的东西。

发言人   22:01
And that's true for a variety of reasons we haven't, some of which we'll get to and some of which are compiler specific. So modern compilers make a large number of optimizations when they compile your C 2 assembly, and so your assembly instructions may look different. For instance, while you're debugging and GDV, you may come across something that tells you that it's some variable has been optimized out. And that means that the compiler decided it didn't need that variable. And so that'll be be effectively from the program. But yeah, at its most straightforward, we're moving the value that's in a 0 to t 0. We're setting a 0 to 0. And then we are just adding what's in t 0 to a 0 for every iteration of a loop until t 0 reaches 0. 
由于很多原因我们还没有做到这一点，其中一些原因我们将得到，而另一些则是编译器特定的。因此，现代编译器在编译您的C 2汇编时会进行大量优化，因此您的汇编指令可能看起来不同。例如，当你在调试和GDV时，你可能会遇到一些东西，告诉你一些变量已经被优化了。这意味着编译器决定不需要那个变量。因此，这将从该计划中有效地实现。但是，最简单的方式是，我们将0中的值移动到t0。我们将0设置为0。然后我们只是在循环的每次迭代中将t 0中的内容添加到0中，直到t 0达到0。

发言人   22:52
And that's all that's going on in this piece. 
这就是这篇文章中发生的全部内容。

发言人   22:54
Amir, your hands raised. Yeah, I was wondering what dot section, dot text and dot global do. Dot global means that you can include this from other files. So if we actually hop into, let's see, f doh. This is the file that you're will. If you aren't already, you will become quite familiar with. This includes basically all of the functions within the kernel that you may want to be using. And within here, you know, we can see that in my file I've included the definitions of these functions and so that global make sure that that these functions can be called from other places. And dot text just says this is code. 
阿米尔，举起你的手。是的，我想知道点部分、点文本和点全局是做什么的。.global意味着你可以从其他文件中包含它。所以如果我们真的跳进去，让我们看看，f doh。这是你将要处理的文件。如果你还没有，你会变得非常熟悉。这基本上包括内核中您可能想要使用的所有功能。在这里，你知道，我们可以看到，在我的文件中我包含了这些函数的定义，以便global确保这些函数可以从其他地方调用。而点文本只是说这是代码。


发言人   23:44
So if you recall from figure 3.4 in the book, So that's if we go to the book. And we go into page tables, process address space. So in here, in this diagram, that's the same thing. This is text. So it just means code. Answer your question, thanks. 
所以如果你回想起书中的图3.4，那么我们就去看这本书。我们进入页表，进程地址空间。所以在这里，在这个图表中，这是同样的事情。这是文本。所以它只是意味着代码。回答你的问题，谢谢。


发言人   24:14
And so if we want to run, let's say we have some assembly also, if you will ever find yourself interested in what the kernel looks like, we can go inside the after you compile, you can look in the file kernel slash kernel, do ASM. And this is the full kind of assembly for the kernel of XV 6. And each of these numbers on the left here is a label that tells you where in memory this in this instruction will be. And that'll come in quite handy. And so here's the, here's the actual assembly code, and you can see the labels for the functions and where they're declared. So this, this is can be really, really useful as we're debugging code. And hopefully I'll be able to show that a second. But for now, we'll jump back to this first function, sum 2, and we'll just see how we can examine that inside of GDP. 
因此，如果我们想要运行，假设我们还有一些程序集，如果您发现自己对内核的样子感兴趣，我们可以在编译后进入内部，您可以在内核斜线内核，做ASM。这是XV 6内核的完整程序集。左边的每一个数字都是一个标签，告诉你这个指令在内存中的位置。这将非常方便。所以这是实际的汇编代码，您可以看到函数的标签以及它们的声明位置。因此，这在我们调试代码时非常非常有用。希望我能展示一秒钟。但是现在，我们将回到第一个函数，sum 2，我们将看看如何在国内生产总值（GDP） 内部检查它。





发言人   25:18
So the first step is I have my two windows here. What's the difference between ASM and S files? Not 100% certain they're both assembly. I think the dot, the dot ASM file includes a bunch of extra annotations that aren't included in dot S, so usually when you compile your C code to DOS, you'll end up with something that doesn't include all of those line numbers and things like that. 
所以第一步是我在这里有两个窗户。ASM和S文件有什么区别？不是100% 确定它们都是装配的。我认为点，点ASM文件包含了许多点S中不包含的额外注释，因此通常当您将C代码编译为DOS时，最终会得到一些不包括所有这些行号和类似的东西。


发言人   25:45
If you're curious about how we get the do ASM file, I think the make file will tell you the exact steps used to get that. And so if we're in our terminal, we have our 2 wind. So the first thing to do is, of course, get qmu up and running. So we can start it with Gdb mode. So now we're frozen here, and then we can start gdb. 
如果您对我们如何获取do ASM文件感到好奇，我认为make文件会告诉您获取该文件的确切步骤。因此，如果我们在我们的终端，我们有两个风。所以首先要做的当然是启动并运行qmu。所以我们可以从Gdb模式开始。所以现在我们被冻结在这里，然后我们可以启动gdb。


发言人   26:15
And what professor kaer showed last week, which I think some people were, by the way, if you type Tui enable, you get this nice window, which is empty for now, but will come in quite useful as you're debugging. So we can set a breakpoint. And I should note that all this code is living inside the kernel. None of this is in user space. So we don't have any of those annoying problems setting breakpoints. So I can set a breakpoint in the function sum 2, and then just continue running and run that function. And now, so the first window that you see in Tui is the source window. 
上周kaer教授展示了什么，我想有些人会这样说，如果你输入Tui enable，你会得到一个漂亮的窗口，这个窗口目前是空的，但在你调试时会非常有用。这样我们就可以设置断点了。我应该注意，所有这些代码都存在于内核中。这些都不在用户空间中。因此，我们没有任何设置断点的烦人问题。所以我可以在函数sum 2中设置一个断点，然后继续运行并运行该函数。现在，您在Tui中看到的第一个窗口是源窗口。


发言人   26:57
Yes, as David is saying, those, those numbers on the left of kernel do ASM are really useful when you're debugging things and you get an address, it'll tell you. So you can see now, even here, we can see that the program, so PC here in Gdb is the program counter. So we can see this address 8, 0, 0, so on and so forth. If we go into kernel, do ASM, and we search for that specific address, we can see that it's the it comes up twice because it's a function call. But if we look here, this is that address. It's the top of the sum two function. So if you see any time you see one of these, all the kernel addresses will look something like and 0x 8, 0 0 0, some numbers, those those addresses, you can jump straight into kernel, do ASM, and find the exact line of assembly where the problem is occurring. And then you can set your breakpoints accordingly. 
是的，正如大卫所说，内核do ASM左边的那些数字在你调试东西时非常有用，当你得到一个地址时，它会告诉你。所以你现在可以看到，即使在这里，我们可以看到程序，所以Gdb中的PC是程序计数器。所以我们可以看到这个地址8、0，以此类推。如果我们进入内核，执行ASM，并搜索该特定地址，我们可以看到它出现了两次，因为它是一个函数调用。但如果我们看这里，这就是那个地址。它是总和两个函数的顶部。因此，如果您在任何时候看到其中一个，所有的内核地址看起来都像0x8，0x0，一些数字，这些地址，您可以直接跳转到内核，做ASM，找到问题发生的确切汇编行。然后你可以相应地设置你的断点。



发言人   27:56
But for now, the top window in Tui is the source. And if we want to look at specifically the assembly, we can do layout in GB ASM, And that'll give us all of the assembly instructions. And we can also look at the registers. If we type layout reg, we'll get assembly and registers. 
但目前，Tui中的顶部窗口是源。如果我们想专门查看程序集，我们可以在GB ASM中进行布局，这将为我们提供所有的程序集指令。我们还可以查看寄存器。如果我们输入布局reg，我们将获得汇编和寄存器。



发言人   28:17
And if you find yourself, you know, wanting to scroll through things now that we have three windows, we need to specify which one is focused. So if I want to look through all the registers I'm going to do focus reg. And now my focus is on the register window. So if I move the arrow keys or scroll, it'll start scrolling that window. But for now, we can focus on the assembly window. And once we're here, we can see all of the things. 
如果你发现自己现在想要滚动浏览事物，因为我们有三个窗口，我们需要指定哪个是聚焦的。因此，如果我想查看所有寄存器，我将进行焦点记录。现在我的重点是注册窗口。所以如果我移动箭头键或滚动，它将开始滚动该窗口。但是现在，我们可以专注于组装窗口。一旦我们在这里，我们可以看到所有的东西。


发言人   28:42
So let's see, we can see in the registered register window, we can see that T 0 contains this value. We can see that a zero contains this value. And as we step through the assembly, we can watch, see OK t 0 just got the value of a 0, which was 5, and it's nicely highlighted the register that's changed here. And we can just keep, remember, if we push enter, we get the most recently executed instruction. So we can go through, we set a 0 to 0, and now we can just kind of watch ourselves go through this loop. Sum up the values. And again, this is like a complete, you know, toy function. And then we can continue and, you know, live our lives. 
所以让我们看看，我们可以在注册的注册窗口中看到T 0包含这个值。我们可以看到零包含这个值。当我们逐步完成程序集时，我们可以看到，看到OK t 0刚刚得到了0的值，即5，并且它很好地突出了这里更改的寄存器。我们可以保持记住，如果我们按enter，我们会得到最近执行的指令。所以我们可以通过，我们将0设置为0，现在我们可以看着自己通过这个循环。把这些价值观总结起来。再一次，这就像一个完整的玩具功能。然后我们可以继续，你知道，过我们的生活。



发言人   29:27
And if you're ever curious about what kind of breakpoints you've set or you lose track of what you were doing, if you type info break or break points, you can see all of the breakpoints that you've set in your code. And you can even see, okay, this breakpoint has already been hit one time. And you get lots of useful information doing that if you don't want to have the register window, but you do want to look at the registers, info reg or info registers or Ire or any of the numerous Gdb shortenings will bring up the register window as well. So with that, is there any, are there any questions about Gdb? Simple ones? I know it's been, there's been lots of posts on Piazza about it, so now is a good time to just ask some straightforward and we'll I'll be showing more usage of DDB what command did you use to open the multiple windows? 
如果您对您设置的断点类型感到好奇，或者忘记了您正在做什么，如果您键入info break或break points，您可以在代码中看到您设置的所有断点。你甚至可以看到，这个断点已经命中过一次。如果你不想要注册窗口，你会得到很多有用的信息，但你确实想查看寄存器，信息寄存器或Ire或任何众多的Gdb缩写也会弹出注册窗口。有什么关于Gdb的问题吗？简单的？我知道已经有很多关于它的帖子了，所以现在是一个很好的时间来问一些直接的问题，我们将展示DDB的更多用法你用什么命令打开多个窗口？


发言人   30:24
So I use tmux so I can show just from scratch. If we go here and I open a new terminal. So here's just a blank terminal if you type Tmax and this is available on Athena. I'll address the next question in a second. So now I'm in TM, which you can tell by this green bar at the bottom. And if you want to get, so there's a couple ways you do multiple windows in Tbo tmux. 
所以我使用tmux，所以我可以从头开始显示。如果我们去这里，我打开一个新的终端。如果您输入Tmax，这里只是一个空白的终端，并且在Athena上可用。我马上回答下一个问题。所以现在我在TM，你可以从底部的绿色条看出。如果你想要的话，有几种方法可以在Tbo tmux中实现多个窗口。


发言人   30:52
If you're so you can type control DC. And I know that sometimes if you're used to using Emacs, that will make a lot of sense. But normal people who don't use Emacs, that's hitting control. And then B, and then hitting C on its own afterwards, that will get you a second window, which you can then navigate between with CR b and then PCB, and then n to go previous. And next, Yeah, and David just posted a T cheat sheet, which is useful. 
如果你这样做，你可以输入control DC。我知道有时候如果你习惯使用Emacs，会产生很多感知。但是不使用Emacs的普通人，会影响控制。然后是B，然后自己点击C，这将为您提供第二个窗口，您可以使用CR b导航，然后PCB，然后n前进。接下来，是的，大卫刚刚发布了一个有用的备忘单。

发言人   31:21
And if you want split the windows, I think it's control B, and then the percent sign will split them vertically and then double CB, and then double quote will split them horizontally. So that's how we get them. And if we're in this state, we can use CB, and o to jump between our windows. So that's what's, that's how I got multiple windows. Yeah, I don't care. 
如果你想分割窗口，我想是控制B，然后百分比符号会垂直分割它们，然后是双cb，然后双引号会水平分割它们。这就是我们得到它们的方式。如果我们处于这种状态，我们可以使用CB和o在我们的窗口之间跳转。这就是，这就是我有多个窗口的方式。是的，我不在乎。

发言人   31:48
And then Ahmed asked, why is this displaying assembly addresses again instead of C line numbers? So because the function, so if we go back to the assembly function, this is implemented entirely in assembly and not at all in C, and so there just aren't any associated C line numbers for this. 
然后艾哈迈德问道，为什么这会再次显示程序集地址而不是C行号？所以，如果我们回到汇编函数，这完全是在汇编中实现的，而不是在C中实现的，因此没有任何关联的C行号。


发言人   32:09
If we were to set a breakpoint, so if you type delete, you'll delete all your breakpoint. So I cleared the old one. If I now set a breakpoint in demo 1, so that's AC breakpoint, and continue and run this. Now if I go here and type layout split I'll get the C and the assembly. Or if I just want the C source, I can do layout source and I'll just get the C, so that's that's what's going on. It's just a quirk of the fact that this doesn't have associated C code. And so we don't see seed line numbers. Any other questions about gdb, tmax, and that sort of thing? 
如果我们要设置断点，那么如果您键入删除，您将删除所有断点。所以我清除了旧的那个。如果我现在在演示1中设置了一个断点，那么这就是交流断点，然后继续并运行它。现在，如果我去这里并输入layout split，我会得到C和程序集。或者如果我只想要C源代码，我可以做布局源代码，然后我只需要得到C，这就是正在发生的事情。这只是一个事实的怪癖，它没有相关的C代码。因此我们看不到种子行编号。还有什么关于gdb、tmax之类的问题吗？




发言人   32:53
So layout split is the one that you use to bring up this extra window of the source and assembly and so on, right out. If you do layout split, that'll get you source and assembly. Layout source will get you just source, axm will get you just assembly, and the registers are their own thing where if you type layout reg, I think, yeah, that'll bring up the registers. But unfortunately, I don't know of a way to get the register with the assembly and the C code all at the same time outside of using info reg with layout split, I have a question. So when we set the breakpoint at a line, right, it displays the address of the like, in this case, breakpoint 2 at 0x 8, 3, and 5, 4, what any instruction might have multiple, any like line of coding C might have multiple instructions. So which one does it, show? I believe it the first one, and it's to for the person who asked to start the Tui, it's I think it's Tui enable, not enable Tui. Sorry, I think, yeah. 
因此，布局分割是您用来弹出源代码和程序集等额外窗口的一种。如果你进行布局分割，那将为你提供源和程序集。布局源将只提供源代码，axm将只提供汇编，寄存器是它们自己的东西，如果您输入布局reg，我想，是的，这将打开寄存器。但不幸的是，除了使用info reg和layout split之外，我不知道如何同时使用程序集和C代码来获取注册表，我有一个问题。所以当我们在一行设置断点时，它会显示类似的地址，在这种情况下，断点2在0x8、3和5、4，任何指令可能有多个，任何类似的编码行C可能有多个指令。那么，是哪一个展示出来的呢？我相信这是第一个，对于要求启动Tui的人来说，我认为它是Tui启用，而不是Tui启用。对不起，我想，是的。

发言人   34:09
Yeah, again, there's like 100 cheat sheets out here for gdb and for TM as well. 
是的，再说一次，这里有100个关于gdb和TM的备忘单。

发言人   34:14
So if you ever find yourself lost it, gdb even has its own inbuilt. Own thing called apropos. So if you look for apropos Tui, it'll actually show you all of the commands that involve Tui. So yeah, this can be quite useful, but it can also be a little bit overwhelming. If you do apropos dash B, it'll give you even more information, I think. I don't remember, I don't use it often myself. But if if you do find or if you forget the exact way to type a command in Gdb and you don't feel like googling, apropos will often be able to find exactly what you're looking for in addition to a whole bunch of stuff you are looking for. Yeah, so, so this is, that can be quite useful. 
所以，如果你发现自己失去了它，gdb甚至有自己的内置功能。自己的东西叫做appropos。因此，如果您寻找appropos Tui，它实际上会向您显示所有涉及Tui的命令。所以，是的，这可能非常有用，但也可能有点让人不知所措。如果你使用dash B，我认为它会给你更多的信息。我不记得了，我自己不经常使用它。但是，如果您确实找到了或者忘记了在Gdb中输入命令的确切方式，而您不想在谷歌上搜索，那么除了您要查找的一大堆内容之外，appropos通常还能够准确找到您要查找的内容。是的，所以这可能非常有用。



发言人   35:06
Gdb is extremely well documented as well. Yeah, if you ever find yourself lost, you know Google is your friend. 
Gdb也有非常好的文档记录。是的，如果你发现自己迷失了方向，你就知道谷歌是你的朋友。


发言人   35:16
So now that we've kind of been over assembly and risk 5 and these sort of things, I want to dive a little bit more into the specifics of what you really need to know for the lab coming up. And also, this will be a little bit of review from the document that you've all, of course, as diligent students, read through thoroughly in preparation for this lecture. So, you know, this table will, of course, be wildly familiar to you all. And from both 0 0 4 and from what you've read. 
所以现在我们已经过了组装和风险5等事情，我想更深入地了解一下即将到来的实验室真正需要了解的细节。同时，这将是对文件的一点回顾，当然，作为勤奋的学生，你们都仔细阅读了，为这次讲座做准备。所以，你知道，这张桌子当然会对你们所有人非常熟悉。从0 0 4和你所读到的。



发言人   35:52
And this is the table of registers. And registers are little, you know, locations on the CPU or on the processor predefined that it can use to store values. And this is important because assembly operations, if we remember from the assembly code, the assembly doesn't operate on memory. It operates on registers. So when we do add, when we do subtract, we're operating on registers. 
这是寄存器表。寄存器很小，你知道，它们位于CPU或处理器上预定义的位置，可以用来存储值。这很重要，因为如果我们从汇编代码中记住，汇编操作不会在内存上操作。它在寄存器上运行。所以当我们做加法时，当我们做减法时，我们正在操作寄存器。

发言人   36:21
And so what you'll often see as the pattern for writing assembly is we'll have some kind of a load. So we'll load some value to a register. And that value can be from memory, or it can be from another register. And here I'm referring to load in general, not the load instruction. And then we'll operate. So we'll perform some operation on the register. And then if we care about the result of that operation outside of the return address, we will store that register to somewhere, to some wills, store that register to some location, either that in memory or to another register. And so that's, that's generally the way things work. 
所以你经常看到的编写汇编的模式是我们会有某种负载。所以我们将加载一些值到寄存器。这个值可以来自内存，也可以来自另一个寄存器。这里我指的是一般加载，而不是加载指令。然后我们将进行手术。所以我们将对寄存器执行一些操作。如果我们关心返回地址之外的操作结果，我们会将该寄存器存储到某个地方，存储到某些遗嘱中，将该寄存器存储到某个位置，无论是在内存中还是另一个寄存器中。所以，这通常是事情的运作方式。

发言人   37:10
And registers are the absolute fastest way to perform any sort of calculation or to access any value. And that's why it's important to use them and also why we prefer using registers overusing memory. 
寄存器是执行任何计算或访问任何值的绝对最快的方式。这就是为什么使用它们很重要，也就是为什么我们更喜欢使用寄存器而不是内存。

发言人   37:24
So if you remember from the reading, when we call function, so you can see here that registers a 0 to 7. And in general, when we speak about registers, we will be referring to them by their ABI name. Not only is it less confusing, it's just a standard. And it's also the way that you'll write assembly code. 
所以，如果你还记得的话，当我们调用函数时，你可以在这里看到注册了0到7。一般来说，当我们谈论寄存器时，我们将通过它们的ABI名称来提及它们。它不仅减少了混淆，而且只是一个标准。这也是你编写汇编代码的方式。

发言人   37:46
This, these actual numbers are not super important. The only case where it does matter is for the compressed version of risk 5 instructions. And if you want to know more about that, feel free to read up about it. 
这些实际数字并不是特别重要。唯一重要的情况是风险5指令的压缩版本。如果你想了解更多，请随时阅读相关内容。

发言人   38:02
The basic idea is that risk 5 normal instructions are 64 b, but there's also the compressed version in which instructions there are 16 b and we use less registers. And the registers we use in that case are 8 through 15. Those are the registers that are available to us. So I think somebody had a question about, you know, why is this S 1 register x 9? Why is it separated from all of the other S registers? And my guess is that that's why that we separated from all of the other ones, because it's available in compressed instruction mode, whereas S 2 to 11 or not. And so that's the idea. So that's, that's for compressed, but outside of that, registers will all be referred to by dare ABI name. 
基本思想是风险5正常指令是64 b，但也有压缩版本，其中指令有16 b，我们使用的寄存器较少。在这种情况下，我们使用的寄存器是8到15。这些是我们可用的寄存器。所以我想有人有一个问题，你知道，为什么这个S 1寄存器x 9？为什么它与所有其他的寄存器分开？我的猜测是，这就是我们与其他所有模式分开的原因，因为它在压缩指令模式下可用，而S 2到11或不可用。这就是这个想法。所以，那是为了压缩，但之外，寄存器都将由dare ABI名称引用。

发言人   38:48
And so a 0 to a 7 are used for function arguments. But if we have a function that takes more than the eight arguments that those registers give us access to, we do need to use memory. But that's this is kind of an illustration of the fact that we don't want to use memory when we can use registers. We only use a memory if we have to. 
因此，将0到7用于函数参数。但是如果我们有一个函数，它接受的参数超过了这些寄存器提供给我们访问的八个参数，那么我们确实需要使用内存。但这就是一个例子，说明当我们可以使用寄存器时，我们不想使用内存。我们只在必要时使用记忆。


发言人   39:08
And this column here, the saver column, this is also extremely important when we're discussing registers, caller versus callee saved. And the terms are I confuse them regularly, call and colony, they only differ by one letter. The easiest way that I found to remember them is that caller saved registers are not preserved. Across a function call so and call E, saved registers are preserved. What I mean by this is that. 
在这里的这个专栏，saver专栏，在我们讨论寄存器、调用者和被调用者保存时，这也是非常重要的。这些术语我经常混淆它们，呼叫和殖民地，它们只相差一个字母。我发现记住它们的最简单方法是不保留调用者保存的寄存器。在一个函数调用中，so和call E保存的寄存器被保留。我的意思是这样的。

发言人   39:55
A caller save register can be overwritten by the function. So let's say I have function A, which calls function B, any registers being used by function A that are caller saved call function B can overwrite when it gets called. And I think a good illustration of this is the return address because, you know, you can see that the return address is caller saved. And that's important because every function needs to use the return address. So when A calls B, it's important that B be able to overwrite the value in the return address, hence why it's caller saved. And call E saved registers are just our convention that we use. The frame pointer is important for that reason, and those are preserved across the function call. 
调用方保存寄存器可以被函数覆盖。所以假设我有函数A，它调用函数B，函数A使用的任何寄存器都是调用者保存的调用函数B可以在调用时覆盖它。我认为这方面的一个很好的例子就是寄语地址，因为你知道，你可以看到寄语地址被来电者保存了。这很重要，因为每个函数都需要使用返回地址。因此，当A调用B时，重要的是B能够覆盖返回地址中的值，因此它被调用者保存。并调用已保存的寄存器只是我们使用的约定。由于这个原因，框架指针很重要，这些指针在函数调用中被保留。


发言人   40:46
So basically, any register that is caller saved, the function that is making the call needs to worry about those registers. And if they're called the saved, the function that is being called needs to worry about preserving the value in those registers. And again, you know, I regularly confuse the two and find myself returning to this table to remind myself about what they do. 
基本上，任何保存调用者的寄存器，进行调用的函数都需要担心这些寄存器。如果它们被称为已保存的，则被调用的函数需要担心如何保留这些寄存器中的值。而且，你知道，我经常混淆这两者，发现自己回到这张桌子上提醒自己他们所做的事情。

发言人   41:11
And so, you know, you, if you remember from the reading, all of these registers are sixty-fourth is why? So they have 60 two-four places where we can put things and the various data types are made to fit into those sixty-fourth is based on the calling convention. 
所以，你知道，你，如果你还记得从阅读中，所有这些寄存器都是第六十四是为什么？因此，它们有60个2-4个位置，我们可以放置事物，并且各种数据类型都是为了适应这64个数据类型，这是基于调用约定的。

发言人   41:28
So if we have a 32 b integer, depending on how it's whether or not it's s extended, you know, we'll either add zeros or ones to the front of that integer in order to make it 64 b to put it in these registers. So before we move on, does anybody have questions about registers or think things of that nature? 
因此，如果我们有一个32 b的整数，具体取决于它是否扩展，你知道，我们将在该整数的前面添加零或一，以使其成为64 b，以将其放置在这些寄存器中。在我们继续之前，有没有人对寄存器有疑问或思考类似的事情？

发言人   41:58
I have a question have can you put a return value in a one? Yes, this is a good question. So I think in theory you can. The reason why we say a 0 to a one is if a function returns a long, long, which is 128 b. So if you remember from the reading, if a function argument is 100 is more than a pointer word. And so when we refer to print a word size, we're saying 64 b. So if we have something that is twice the size of a pointer word, we can put that in a register pair. And so the same convention holds true for return addresses, where if we have something that's the size of twice a pointer word, we can stick that in a 0 and a 1 and use that as the return address. 
我有一个问题，你能把一个返回值放在一个里面吗？是的，这是个好问题。所以我认为在理论上你可以。我们说0到1的原因是，如果一个函数返回一个long，long，即128 b。因此，如果你从阅读中记得，如果一个函数的参数是100，那就比一个指针单词多。所以当我们提到打印一个单词大小时，我们说的是64 b。因此，如果我们有一个指针字大小的两倍，我们可以将其放入一个寄存器对中。因此，同样的约定也适用于返回地址，如果我们有两倍指针字的大小，我们可以将其粘贴在0和1中，并将其用作返回地址。

发言人   42:46
I think you'll run into problems if you only try to put something in a one. Makes sense, thanks. Why are the registers not like cont? Why like a 0 and 1 separate from, sorry? No, that's a, that's a bad example. What's why is SS 1 separate from s 2? Why are the A's in between, like, is there any point in that? 
我认为如果你只试着把一些东西放进一个里面，你会遇到问题的。感知，谢谢。为什么寄存器不像cont一样？为什么要将0和1分开，抱歉？不，那是个不好的例子。为什么SS 1和s 2是分开的？为什么A在中间，比如，这有什么意义吗？

发言人   43:13
Yeah, so I mentioned this briefly earlier, but there is a compressed. This is a guess. I don't, I don't know for sure, but there's a compressed version of the risk 5 instructions, which are 16 b in size as opposed to 64. And you would use that to try and make your code take less space and memory. When you use those 16 b instructions, you only have accesses to registers 8 through 15. So I think S 1 is separate from S 2 to 11 because they want to make it clear that S 1 is available to you in the compressed instruction mode, where that's to 11 aren't. And the reason, you know, I don't know why they picked XX 8 to 15, but I suspect that that's just they looked at a bunch of code and we're like, oh, these are the most commonly used registers. 
是的，我之前简要提到了这一点，但有一个压缩。这是猜测。我不知道，我不确定，但是风险5指令有一个压缩版本，大小为16 b而不是64。你会用它来尝试让你的代码占用更少的空间和内存。当您使用那些16 b指令时，您只能访问寄存器8到15。所以我认为S 1与S 2到11是分开的，因为他们想明确表示，在压缩指令模式下，S 1可供您使用，而对于11则不可用。原因是，你知道的，我不知道他们为什么选择了XX 8到15，但我怀疑他们只是看了一堆代码，我们就会说，哦，这些是最常用的寄存器。

发言人   44:17
Any other questions? Question? Besides the frame pointer, the stack pointer at all? 
还有什么问题吗？问题？除了帧指针，还有堆栈指针吗？

发言人   44:27
I don't know why we would need more Colli safe registers, but we do have like a bunch of them. Yeah, the S 1 s to 11 S, those are just for, I believe, used there for freedom for the compiler or for the programmer to use. So there maybe there are certain cases where you want, you want to guarantee that something is still around. After your function call, the compiler can choose to use S 1 211 to do that. I don't have like on hand a specific example of where that's useful, but I'm sure it shows up where having a Cali save value is important. But these are basically, basically, you know, programmer compiler's choice to use that one to 11. 
我不知道为什么我们需要更多的Colli安全寄存器，但我们确实有一堆。是的，S 1到11，我相信这些只是为了编译器或程序员使用的自由。所以可能在某些情况下，你想要保证有些东西仍然存在。在您的函数调用之后，编译器可以选择使用S 1 211来执行此操作。我手头上没有一个有用的具体例子，但我确信它会显示出具有Cali保存价值的重要性。但这些基本上，基本上，你知道，程序员编译器选择使用那个到11。

发言人   45:22
And I should note that these floating point registers, they're for floating point arithmetic. As far as I'm aware, you won't see them in this class. And so you don't really need to worry about them. Okay, so we started talking a little bit about function calls. And so with that, I want to move us into discussion of the stack. 
我应该注意这些浮点寄存器，它们用于浮点算术。据我所知，你在这堂课上是看不到他们的。所以你真的不需要担心它们。好的，我们开始稍微谈论一下函数调用。因此，我想让我们进入对堆栈的讨论。


发言人   45:54
So this is, this is, we're talking about the stack and the stack, if you've seen it like before, the reason why the stacking is important is it's what keeps our functions organized and sane. And it's what allows and what makes functions work. It's what makes return work. And it's also where often we'll find ourselves saving our registers and things like that. So here I've given just a pretty simple layout of what a stack looks like. And so each of these boxes here is what we refer to as a stack frame. And every time we get, which are generated by function calls. 
所以这就是，这就是，我们谈论的是堆栈和堆栈，如果你以前见过它，那么堆栈很重要的原因是它使我们的功能有组织和健全。这就是允许和使功能发挥作用的原因。这就是让回报发挥作用的原因。这也是我们经常保存寄存器和类似东西的地方。所以在这里，我只是给出了一个非常简单的堆栈布局。因此这里的每个盒子就是我们所称的堆栈框架。每次我们得到，都是由函数调用生成的。


发言人   47:01
Every time we call a function, that function makes for itself its own stack frame and which is in which it uses itself, and does that by moving around the stack pointer. So here's the stack pointer. And this is, it's very important to remember with stacks, we start from high addresses and we grow downwards 2 low addresses. So the stack grows down always. And so you'll see that the arithmetic for a stack point area is is usually done via subtraction when we want to make a new stack frame in assembly. 
每次我们调用一个函数，该函数都会为自己创建自己的堆栈框架，并在其中使用自己，并通过在堆栈指针周围移动来实现这一点。这是堆栈指针。这是非常重要的一点，要记住堆栈，我们从高地址开始，向下增长2个低地址。因此堆栈总是向下增长。因此，你会看到，当我们想要在汇编中构建新的堆栈帧时，堆栈点区域的算术通常是通过减法完成的。

发言人   47:41
So the stack grows downwards, and stack frames for a function contain save registers, local variables also, like like I was saying, if you run out of argument registers, additional arguments will show up on the stack. And so not stack frames are not all the same size, even though they are in this diagram, that's not the case. Different functions have different numbers of local variables, different safe registers, so on and so forth. And so stack frames will be different sizes, but the two things that you can definitely count on, which are important is that, the return address will always be on the first thing and the frame pointer, the previous frame frame pointer is also going to show up on the stack at a predictable location. 
因此堆栈向下增长，函数的堆栈帧包含保存寄存器、局部变量，就像我说的，如果你用完参数寄存器，额外的参数将出现在堆栈上。因此，并非所有堆栈帧的大小都相同，即使它们在此图中，情况并非如此。不同的函数有不同数量的局部变量、不同的安全寄存器等等。堆栈帧的大小不同，但有两件事你可以肯定地依靠，这很重要，那就是返回地址将始终在第一件事上，并且帧指针，前一帧帧指针也将显示在堆栈上的可预测位置。

发言人   48:26
The two important registers here are Sp, which know, as we discussed, is used for this is the bottom of the stack. Or generally, you know, it's the location of the stack. And then FP is are also important register. And this points to the top of the current frame. And this is important because that means that the return address and the previous FP will always be at a fixed location from the current frame pointer. So that means that if I want to find my return address or I want to find the previous frame, I can always get to those values by looking at the current frame pointer. 
这里的两个重要寄存器是Sp，正如我们所讨论的，它用于这是堆栈的底部。或者一般地说，你知道，它是堆栈的位置。然后FP也是重要的寄存器。这指向当前帧的顶部。这很重要，因为这意味着返回地址和前一个FP将始终位于当前帧指针的固定位置。这意味着，如果我想找到我的返回地址或我想找到前一帧，我总是可以通过查看当前的帧指针来获得这些值。

发言人   49:13
And the reason why we store the previous frame pointer is to allow us to jump back. So once this function returns, we can move this into FP, and all of a sudden FP again, will go from pointing to this, this stack frame, to now pointing to this stack frame. And so we use the frame pointer to manipulate our stack frames and make sure we're always going into the one corresponding to the correct function, and's that's kind of how things, how things are done. 
我们存储前一个帧指针的原因是为了允许我们跳回去。所以一旦这个函数返回，我们就可以将它移到FP中，突然间FP又会从指向这个堆栈帧变成指向这个堆栈帧。因此，我们使用帧指针来操作我们的堆栈帧，并确保我们始终进入与正确函数对应的堆栈帧，这就是事情的完成方式。

发言人   49:44
And these pieces of the stack need to be created by assembly. And so everything, everything in that calling conventions document that you read about, that's all enforced by effectively by the compiler. So the compiler adheres to the calling convention, and it's what generates the stack frame. It generates the assembly code that makes our stack frames look correct. 
而堆栈的这些部分需要通过组装来创建。因此，您阅读的调用约定文档中的所有内容都由编译器有效地强制执行。因此，编译器遵循调用约定，并且它是生成堆栈帧的内容。它生成的汇编代码使我们的堆栈帧看起来正确。

发言人   50:11
So often at the top of a function, you'll see what's called function prologue. And then there will be the body of the function. And then there will be an epilogue that shows up after that. So this is kind of like what an, a, an assembly function will often look like. And we'll take a look at that now. 
经常在函数的顶部，你会看到所谓的函数序言。然后会有函数的主体。然后会有一个尾声在那之后出现。所以这有点像一个汇编函数通常看起来的样子。现在我们来看看。

发言人   50:41
So here I have another function some, and so you'll note that Itt do that sum 2 does not have any of these things that it it should, if it was a proper function. And this works fine because it's simple enough. So it does all of its computations on a 0. And so things are things are good, and we're also not it's a leaf function, So you'll see if you see the term leaf function, that's a function that doesn't call another function. And the functions are special in that they don't need to worry about saving their own return address or saving really any of the caller saved registers because they're going to, they're not going to make another function call, so they don't have to be as careful some then double on the other hand, is not a leaf function. So you can see here it calls some two, and so it does need to include that that prologue. And so we see here that we are subtracting 16 from the stack pointer, so we're making space on our stack, we're storing the return address for something double on the stack, and then we make our call to sum 2. And after that, all this this function does is it call sum two and then doubles the result, doubles the result turn by sun 2, and here you can see the epilogue, so we load the return address back in to RA and delete our stack frame, and then jump out of the function, and so we can run that to make sure it does what we would expect. 
所以这里我有另一个函数，所以你会注意到，如果它是一个适当的函数，那么求和2没有任何这些它应该有的东西。这很有效，因为它足够简单。所以它在0上进行所有计算。所以事情是好的，我们也不是它是一个叶函数，所以如果你看到术语叶函数，你会看到它是一个不调用另一个函数的函数。这些函数的特殊之处在于它们不需要担心保存自己的返回地址或保存任何调用方保存的寄存器，因为它们不会进行另一个函数调用。所以他们不必那么小心，另一方面也可以加倍小心。不是叶函数。所以你可以看到这里调用了两个，所以它确实需要包括那个序言。因此，我们在这里看到我们从堆栈指针中减去16，因此我们在堆栈上腾出空间，将返回地址存储在堆栈上，然后进行调用以求和2。之后，这个函数所做的就是调用sum 2，然后将结果加倍，将结果加倍到sun 2，这里你可以看到尾声，所以我们将返回地址加载回RA并删除我们的堆栈帧，然后跳出函数，所以我们可以运行它，以确保它达到我们的期望。





发言人   52:21
Go here? We can run. So if we run demo two or demo 1, we got a result of 15 with a sum. And I'll tell you that demo 2 just just call sum, then double. And indeed, you know it Happ doubles the sum returned by some two. And so a question I have for anybody, what happens if we delete this prologue and flog? 
去这里？我们可以跑步。因此，如果我们运行演示2或演示1，我们会得到一个结果15和一个总和。我会告诉你，演示2只需要调用总和，然后翻倍。确实，你知道它会使一些人返回的总和翻倍。所以我想问任何人，如果我们删除这个序言和鞭打会发生什么？


发言人   52:50
So what happens if we just have this as our function sum double, Can anybody predict what's going to happen? I mean, one thing is that some then double wouldn't know the return address that it should return to. So upon calling some two, that's going to override the return address to be some than double. So at the end of some than double, it's not going to return to its original color. Yeah, exactly, and we can see that that's what happened again. So if we exit out of this and we exit out of this and we recompile with now with our broken function, we can take a look at exactly what's going to happen. So we can actually set our breakpoint for something double. And set up Tui and let it continue. 
那么，如果我们将这个函数和double作为函数，会发生什么，有人能预测会发生什么吗？我的意思是，有一件事是有些double不知道它应该返回的返回地址。因此，在调用一些两个时，这将覆盖返回地址，使其超过两倍。所以在一些双倍结束时，它不会恢复到原来的颜色。是的，没错，我们可以看到这就是再次发生的事情。因此，如果我们退出这个，然后退出这个，然后使用损坏的函数重新编译，我们可以确切地看看会发生什么。所以我们实际上可以为一些双重设置我们的断点。并设置Tui并让它继续。


发言人   53:49
So if we now run demo two, okay, we're at some then double. And again, this is an assembly only function. So we're going to want to look at it in assembly layout, ASM layout range, because it's important what's in the registers in this case. And you'll see that GDP knows a whole bunch of extra information. And so we can see that. 
所以，如果我们现在运行演示2，好的，我们现在有一些然后翻倍。再次强调，这是一个只有程序集的功能。所以我们要在汇编布局，ASM布局范围中查看它，因为在这种情况下，寄存器中的内容很重要。你会发现国内生产总值（GDP） 知道一大堆额外的信息。所以我们可以看到。



发言人   54:14
We can see that a currently, so the return address currently points to demo 2 plus 18. It points effectively into the function demo 2. And now we can run, we can just kind of step through our function and see what happens. So we've called some two. And immediately we can see that the return address was overwritten by some two to now point to some than double plus four, which makes sense. You know, that's what we'd expect. If we go back into our code, we call some 2. And so sum two should return to here, And now we can step through, you know, so on up. And then we get back into. Whoops, wrong s? 
我们目前可以看到a，因此退货地址目前指向演示2加18。它有效地指向函数演示2。现在我们可以运行了，我们可以逐步完成我们的函数，看看会发生什么。所以我们叫了两个。我们可以立即看到寄信人地址被一些2覆盖，现在指向一些二重加4，这使得感知。你知道，这正是我们所期望的。如果我们回到我们的代码，我们会调用一些2。所以和二应该回到这里，现在我们可以逐步进行，你知道，等等。然后我们回到。哎呀，错了？



发言人   55:14
Okay, so now we're here. And now when some then double returns, as exactly as a mirror pointed out, it's it has not restored its own return address. And instead its return address is still the one that was used by some two. And so we will get into an infinite loop where we just keep doing this over and over and over again, and we'll never terminate from it. And so this is AI think this is a good illustration of why it's important to keep track of our caller versus callee saved registers. And hopefully, this also shows that you can use kind of Gdb to debug these sorts of problems, restore what we had, and we'll go into some other demos to talk about to. 
好的，现在我们到了。而现在，当一些人加倍返回时，正如镜子所指出的那样，它并没有恢复自己的返回地址。相反，它的返回地址仍然是一些两个人使用的地址。因此，我们将陷入一个无限循环，我们只是一遍又一遍地重复这样做，并且我们永远不会停止。因此，这就是AI认为这很好地说明了为什么跟踪我们的呼叫者与被呼叫者保存的寄存器很重要。希望这也表明您可以使用某种Gdb来调试这类问题，恢复我们所拥有的内容，我们将进入其他一些演示来讨论。


发言人   56:04
Illustrate So we ask, why are we subtracting 16? That's to put space to get our stack frame. So this is subtracting 16 from the stack pointer, so it's moving it down basically in memory, moving it down so that we now have space for our own stack frame, and then we can stick stuff there. So because at this point in, we don't want to override what's at the stack pointer, why not for I just, no, for we need to do 16 because instructions are 64. 
举例说明，所以我们问，为什么我们要减去16？这是为了留出空间来获取我们的堆栈框架。所以这是从堆栈指针中减去16，所以它基本上是在内存中将其向下移动，这样我们现在就有了自己的堆栈框架的空间，然后我们可以将内容粘贴在那里。因为此时，我们不想覆盖堆栈指针上的内容，为什么不为I，不，因为我们需要做16条，因为指令是64条。


发言人   56:44
Yeah, I guess. I guess we wouldn't don't actually need to do 16, but that's generally what you'll see. You'll generally just, I don't think, yeah, you can't, you can't do 4 because you need 8. So Ford doesn't work, but I think he can do you the instruction size and the size of the register, right? So registers are 64, yeah. And then so the convention why you usually see 16 is because if we jump back to our document, usually we have the return address and the frame pointer, but we're not doing that here because we're being, not super careful with our assembly. 
是的，我想。我猜我们实际上不需要做16个，但这通常是你会看到的。你通常会只是，我不认为，是的，你不能，你不能做4，因为你需要8。所以福特不起作用，但我认为他可以告诉你指令大小和寄存器的大小，对吗？所以寄存器是64，是的。你通常看到16的约定是因为如果我们跳回我们的文档，通常我们有返回地址和框架指针，但我们在这里没有这样做，因为我们不是非常小心地组装我们的文档。


发言人   57:22
So normally if we, if we look in I'm sure if we look in kernel at ASM, we'll see. Yeah, so if we look in kernel do ASM, we see it's also, you know, 16. This is generally what you'll see with the compiler. 
所以通常情况下，如果我们进去看，我相信如果我们在内核中查看ASM，我们会看到的。是的，所以如果我们在内核中查看ASM，我们会看到它也是16。这通常是您在编译器中看到的。


发言人   57:39
Okay, so now we can. Go back to this, fix our function. And now we can look at some C code. All right, so here we have demo 4, which is just basically a copy of a main function, like an imitation of the main function. So we have our args, which is an array of strings, and we have dummy main, which takes the a number of arguments and the argument string and just prints it out for us. And so that's all that's, that's all that's happening here. It's pretty straightforward. If we set a breakpoint in to mean. And hop over. Okay, we let this continue and we start this, we run down 4. 
好的，现在我们可以。回到这里，修复我们的功能。现在我们可以看一些C代码。好的，这里我们有了demo 4，它基本上只是一个主函数的副本，就像主函数的仿制品。所以我们有我们的args，它是一个字符串数组，我们有dummy main，它接受一些参数和参数字符串，并为我们打印出来。这就是全部，这就是这里发生的全部。这相当简单。如果我们设置一个断点来表示。然后跳过去。好的，我们让它继续，我们开始，我们运行4。




发言人   58:41
Okay, so we now we've hit Du and there's a couple of important things to remember about you can use Gdb for regarding stack frames. So if we type I, so again, that's info. If we type iframe, we can see a whole bunch of, useful information about the current stack frame. 
好的，现在我们已经点击了Du，有几个重要的事情需要记住，你可以使用Gdb来处理堆栈帧。所以如果我们输入I，那么再次输入，那就是信息。如果我们输入iframe，我们可以看到有关当前堆栈帧的大量有用信息。

发言人   59:05
So we can see we at stack level 0, level zero means it's a term is down in the call stack that we can go and the frame is at this address, the program counter, which is okay, that's all well and good. We have a safe program counter as well. And if we, again, if we take this address and we jump into kernel, do ASM, and we search for that address, we can indeed that that address is inside of inside of demo form, which is exactly where we expect the program to return to. And it was called by a frame at this address source language C, you know, that's nice to know. And then we have the argument list also starts at this address. Of course, in this case, we have most of our arguments in registers. And then we can even see what the arcs are. We mean RCC is 3, and RV is this address. 
所以我们可以看到我们处于堆栈级别0，级别0意味着它是一个在调用堆栈中向下的术语，我们可以进入并且帧位于此地址，即程序计数器，这没关系，一切都很好。我们也有一个安全的程序计数器。如果我们再次获取这个地址并跳入内核，执行ASM，然后搜索那个地址，我们确实可以知道这个地址在演示表单内部，这正是我们期望程序返回到的地方。它被这个地址源语言C的一个帧调用，你知道，很高兴知道。然后我们有参数列表也从这个地址开始。当然，在这种情况下，我们的大部分论点都在寄存器中。然后我们甚至可以看到弧线是什么。我们的意思是RCC是3，RV是这个地址。



发言人   01:00:10
And if we want to more in depth and examine things, we can look at things like info arcs, which will tell us information about the arguments to the function we can look at. But more importantly, we can type if we type back trace or BT works as well, we get a full back trace of all of the stacks, the all of the stack frames from the call stack. So we can see, you know, something questionable happen here. 
如果我们想要更深入地研究事物，我们可以查看像信息弧这样的东西，它会告诉我们可以查看的函数参数的信息。但更重要的是，如果我们输入back trace或BT也可以，我们可以获得所有堆栈的完整回溯，调用堆栈中的所有堆栈帧。所以我们可以看到，你知道，这里发生了一些可疑的事情。


发言人   01:00:40
That's when we invoked a system call. Then we get to the user track function, then to the sys call function, then to S demo, then to demo for, and then finally to dummy main. 
那时我们调用了一个系统调用。然后我们到达用户跟踪函数，然后到sys调用函数，然后到S演示，然后到演示，最后到虚拟main。

发言人   01:00:54
And if we want to investigate any of these stack frames more in depth, we can do frame, then whatever number is along the side here. So let's say I want to look at what was my stack frame when CS called got called. I can go to frame 3. And so now inside of Gdb I'm looking at that stack frame. So if I type info frame, I get this, and here we get a lot more, a lot more information. We have a bunch of saved registers, we have some local variables, we don't have any arguments to this function, can see where the program counter where we're supposed to jump back to, all kinds of things like that. So this is super, super useful for if you're debugging things, and in fact, it's so useful we make you implement your own version, not nowhere near and as in depth as what Gdb tells you, but we're one of the exercises on the next lab will be to implement your own back trace helper function for use when debugging things inside the lab. And so backtrack, quite useful. 
如果我们想更深入地调查这些堆栈帧中的任何一个，我们可以做帧，那么无论这里旁边的数字是多少。假设我想看看调用CS时我的堆栈帧是什么。我可以进入第3帧。所以现在在Gdb内部，我正在查看那个堆栈帧。所以如果我输入信息框，我会得到这个，在这里我们会得到更多，更多的信息。我们有一堆保存的寄存器，我们有一些局部变量，我们这个函数没有任何参数，可以看到我们应该跳回的程序计数器在哪里，诸如此类的事情。所以如果你在调试东西，这非常有用，事实上，它非常有用，我们让你实现自己的版本，而不是像Gdb告诉你的那样深入，但我们是下一个实验的练习之一，将是实现您自己的回溯跟踪帮助函数，以便在调试实验室内的事物时使用。所以回溯，非常有用。


发言人   01:01:56
And then if we type frame 0, we go back to where we were supposed to be, and if we want to investigate, you probably noticed it's not super helpful, you know RV is a string, an array of strings. 
然后，如果我们输入第0帧，我们就会回到我们应该去的地方，如果我们想要调查，你可能会注意到这并不是特别有帮助，你知道RV是一个字符串，一个字符串数组。


发言人   01:02:10
And so we just get a, we just get an address for where that's actually stored. And if we want to look at what's in there, there's a couple ways of doing this. The easiest is if we type print p is for print, and then if we d dereference the address, so we go look at what's out of the address, we do that. And, you know, as you would expect, we get the first element of that array because when it tries to print a string, it'll go, you know, as C says, it'll go until it hits the null character. So we get foo, which is the first element of that array, and if we want to get more things, we can put in the length. So if we do, and then a number, it'll go up to a certain index. So then we can see both of the strings here. 
所以我们只需要获取一个，我们只需要获取一个实际存储的地址。如果我们想看看里面有什么，有几种方法可以做到这一点。最简单的是，如果我们输入print p是为了打印，然后如果我们取消引用地址，所以我们去看看地址外面有什么，我们就这样做了。而且，你知道，正如你所期望的那样，我们得到了该数组的第一个元素，因为当它尝试打印字符串时，它会像C所说的那样一直运行，直到命中空字符。所以我们得到了foo，这是该数组的第一个元素，如果我们想要得到更多的东西，我们可以输入长度。所以如果我们这样做，然后一个数字，它会上升到某个指数。这样我们就可以看到这里的两个字符串。

发言人   01:02:57
You know, again, GDP is quite smart, so we can even use RCC to print out the whole argument array. And so all of that information is available to you however you want to get it. So Gdb is a super powerful tool. 
你知道，再次强调，国内生产总值（GDP） 非常聪明，所以我们甚至可以使用RCC来打印整个参数数组。因此，所有这些信息都是可用的，无论你想要什么。所以Gdb是一个超级强大的工具。


发言人   01:03:14
Why does Gdb, or sorry, why does the compiler sometimes optimize out RGC and RGB? That has happened to me before. Yeah, that just means that the compiler found a more efficient way, likely it just got rid of the variable and it's doing all of its operations directly, you know, via reg, It might be doing all of its operations on a 0, for example. It might just be doing all of its computations on the return address. It's pretty common to see something like that if you if it's a variable that's not, you know, 100% necessary, if you know, we don't like, we don't give you control over the compiler, but if you ever find that in your day to day, you can try setting the optimization flag for the compiler to 0. But even then, you know, the compiler will do do it will do some level of optimization bibek your hand is raised. 
为什么Gdb，或者抱歉，为什么编译器有时会优化RGC和RGB？这以前发生在我身上。是的，这只是意味着编译器找到了一种更有效的方法，可能它只是摆脱了变量，它直接执行所有操作，你知道，通过reg，它可能在0上执行所有操作，例如。它可能只是在返回地址上进行所有计算。如果它是一个不是100% 必要的变量，那么看到这样的东西是很常见的，如果你知道，我们不喜欢，我们不给你对编译器的控制权，但如果你在日常生活中发现这一点，您可以尝试将编译器的优化标志设置为0。但即使这样，编译器也会做，它会做某种程度的优化bibek，你的手举起来。

发言人   01:04:08
Yeah, what's the address besides that dollar one or dollar two, you know, like before food or bar, dollar this? Yeah, so what's that address? 
是的，除了那一美元或两美元以外，还有什么地址，比如在食物或酒吧之前，这一美元？是的，那么那个地址是什么？

发言人   01:04:20
Is that the address where foo is probably, but but then RV points to some other address should andt shouldn't those be the same? So RV is on this stack and it'll so the reason why you, if you look at these addresses, we can see that they're in the kernel just by the 8 0 0 0, which makes sense because we they're declared statically, right? So in demos, if I go here, they're declared here. And so they're basically they're sitting somewhere in the kernel and they're all car stars AR arcs or ARV, an array of stars. And so I imagine each element to. Its own string, right? So it's an array of pointers. 
这是foo可能所在的地址，但是RV指向另一个地址，这些地址不应该是相同的吗？所以RV在这个堆栈上，这就是为什么你，如果你看这些地址，我们可以看到它们在内核中刚好是8 0 0，这就感知了，因为它们是静态声明的，对吗？所以在演示中，如果我走到这里，它们会在这里声明。所以它们基本上就坐在内核中的某个地方，它们都是汽车星星弧或ARV，一组星星。所以我想象每个元素。它自己的字符串，对吧？所以它是一个指针数组。

发言人   01:05:17
Try and like. 
尝试并喜欢。


发言人   01:05:24
I also have a question about this. The dollar three version of the array has, if I look at these addresses, the first one is suffixed by 38, the second one is suffixed by 40, the third one is 48, which is not uniform even though the length of each, the three arguments, it's 3. So why, why are they different? Not in I'm not 100% certain, My guess is that this is an attempt to align things, right, So to get them on a reasonable alignment, it is uniform in hex as people are pointing out, Oh right, Yeah, I have to make sense, Oh, yes, I see it now, yeah, right, thanks, so you'll sometimes see where things are laid out, strangely, where there might be two things at strange offsets and that's just because not everything is naturally the same size, okay, any other questions. 
我也有一个关于这个的问题。数组的三个版本是美元，如果我查看这些地址，第一个地址的后缀是38，第二个后缀是40，第三个是48，即使每个参数的长度都是3，也是不统一的。那么，它们为什么不同呢？我不是100% 确定，我的猜测是这是试图对齐事物，对吧，所以为了使它们合理对齐，十六进制是统一的，正如人们指出的那样，哦，对，是的，我必须做出感知，哦，是的，我现在看到了，是的，谢谢，所以你有时会看到事情的布局，奇怪的是，可能有两个东西在奇怪的偏移量上，这是因为并不是所有东西自然都是相同的大小，好的，任何其他问题。

发言人   01:06:37
Okay, we can skip the 5th demo. And so another useful function that we get from Gdb are. Instead of just breakpoints, there are also watchpoints, and we can also set conditional breakpoints so. I'll just briefly go over that. 
好的，我们可以跳过第五个演示。所以我们从Gdb中得到的另一个有用函数是。除了断点，还有观察点，我们也可以设置条件断点。我将简要介绍一下。

发言人   01:07:02
We run demo 6, so we can set inside this function. We can watch. So we can set a watch point on. I think here you'll see. Yeah, so here you'll see what Luca was talking about, where we see that some has been optimized out, likely because it's just being we put in a 0 or something. We can look even at the assembly for this, right? So we can, yes. And yeah, indeed, we can see that it's just being, it's all just being done on the stack. If it looks like to me, oh no, it's all just being done in S 0 s 0 1 3. So here you can see that the. Compiler decided even to use the Col saved registers. 
我们运行demo 6，因此我们可以在此函数内部进行设置。我们可以观看。这样我们就可以设置监视点了。我想在这里你会看到。是的，所以在这里你会看到卢卡在谈论什么，我们看到有些东西已经被优化掉了，可能是因为我们只是输入了一个0或其他东西。我们甚至可以看看这个集会，对吗？所以我们可以，是的。是的，确实，我们可以看到它只是在堆栈上完成的。如果对我来说，哦，不，这一切都只是在0 s 0 1 3中完成的。所以在这里你可以看到。编译器甚至决定使用Col保存的寄存器。



发言人   01:07:51
And so we can set things like we can do watch on I, we haven't declared I yet because we're not inside. We're not inside the. For loop. So if we step through the C instructions now, if we do information for the locals, we see we get, I, we can even watch, watchpoint on some. So now anytime that some changes will actually get a notification so we can continue and then we'll get a delete here because some has been removed. So we can, we can't actually watch it. 
所以我们可以设置一些东西，就像我们可以在I上观看一样，我们还没有宣布I，因为我们不在里面。我们不在里面。For循环。所以，如果我们现在按照C指令进行操作，如果我们为当地人提供信息，我们会看到我们甚至可以在一些地方观看。所以现在任何时候一些更改都会收到通知，以便我们可以继续，然后我们将在这里删除一些更改，因为有些更改已被删除。所以我们可以，但实际上我们不能观看它。

发言人   01:08:31
We can even do things like breakpoint on some two since this is a conditional breakpoint if, well, let's actually see what is I currently. So I is currently one, let's say I think my loop is breaking and whenever I is 5, well, if I want to specifically debunk that case, I can set a breakpoint on some two if I equals 5. So now we have this breakpoint. And if we continue along, we'll get to some two and we can see that it actually printed out the first couple values. And so we only break now on some two if we hit that breakpoint condition. And so that's this can be, again, this can be useful if you want to debug specific edges of your code. And watch points can be useful if, for instance, you think that something shouldn't be changing, but you suspect that it is, or you think that something is going wrong every time you change a certain variable. And so that's, that's that's 1, one usage for that. 
我们甚至可以在两个上做断点之类的事情，因为这是一个条件断点，如果，那么，让我们看看I当前是什么。所以我目前是一个，假设我认为我的循环正在破坏，每当我是5，那么，如果我想特别揭穿这种情况，如果我等于5，我可以在大约两个上设置一个断点。所以现在我们有了这个断点。如果我们继续下去，我们将会得到两个值，我们可以看到它实际上打印出了前几个值。所以我们现在只有在达到断点条件时才会在大约两个上突破。因此，如果您想调试代码的特定边缘，这可能会很有用。例如，如果你认为某些事情不应该改变，但你怀疑它是改变的，或者你认为每次改变某个变量时都出了问题，那么观察点可能会很有用。因此，这是1，一种用法。


发言人   01:09:43
And the last thing I want to talk about today is structs. Trucks are pretty important, and they'll come. Up in the labs often. And also, so what? 
今天我最后想谈的是结构。卡车非常重要，它们会来的。经常在实验室里。还有，那又怎样？

发言人   01:09:59
I'll talk a little bit about the way structs are laid out in memory. And so a struct is basically, it's a contiguous area of memory. So if we have some struct and we have like field one, field two, field 3, when we make that struck, those fields are going to be aligned next to each other in memories. And you can kind of think of this like an array, but F1, f 2, and F3 can all be different types. And we can pass them as functions. Usually they're pass, pass them as arguments to functions, usually they're passed by reference. 
我将稍微谈谈结构在内存中的布局方式。结构基本上是一个连续的内存区域。所以，如果我们有一些结构，我们有字段1，字段2，字段3，当我们进行点击时，这些字段将在内存中彼此对齐。你可以把它想象成一个数组，但是F1、f2和F3可以是不同的类型。我们可以将它们作为函数传递。通常它们被传递，作为参数传递给函数，通常它们是按引用传递的。


发言人   01:10:37
So here I've made a struct person with two integer arguments, and I'm passing, passing a person as an argument print person and printing out some of that information. So if we hop into Gdb, and let's delete all of our breakpoint and watchpoint, and then we can set a breakpoint person, and let's continue and run 7 demo. 
所以在这里，我创建了一个带有两个整型参数的结构体，并且我正在传递，传递一个作为参数的打印人并打印出一些信息。因此，如果我们跳入Gdb，并删除所有的中断点和观察点，然后我们可以设置一个断点人员，让我们继续运行7演示。


发言人   01:11:07
We can see that now we're here. And so if we type iframe, we can see that we have an argument p, and indeed, we can if we do Transp. We can even tell that it's a stru person at this address. We can, if we dereference it, gdb will tell us exactly what p looks like. It has ID 1215, age is 22. And just to show kind of how things are laid out, we can take this address and we do x e at this address. 
我们可以看到，现在我们在这里。因此，如果我们输入iframe，我们可以看到我们有一个参数p，事实上，如果我们进行Transp，我们就可以。我们甚至可以看出这个地址是一个stru人。我们可以，如果我们取消对它的引用，gdb将告诉我们p的确切外观。它账号1215岁，年龄22岁。为了展示事物的布局，我们可以取这个地址，然后在这个地址上做x e。

发言人   01:11:54
Remember, exactly. 
记住，确切地。

发言人   01:12:02
So if we, again, so we can use this to debug our structures in the code, we can take a look at what's going on with structures this way. So Gdb is a super powerful tool, not just for, you know, stepping through code, but also for examining all kinds of potentially problematic pieces in your code and looking at arguments and stack frames and things like that. And this will be, hopefully will be useful in the next lab when you have to work with with stack frames and with assembly code. So that's, that's mostly what I wanted to talk about today. So with the last kind of seven minutes of lecture I'll open it up to any any other questions that you guys have. 
因此，如果我们可以使用它来调试代码中的结构，我们可以看看这种结构的情况。因此，Gdb是一个超级强大的工具，不仅仅是用于单步执行代码，还可以检查代码中各种潜在问题的部分，并查看参数、堆栈框架等。这将是，希望在下一个实验室中，当你必须使用堆栈框架和汇编代码时，会很有用。所以，这就是我今天想谈论的主要内容。所以在最后七分钟的讲座中，我将开放给你们任何其他问题。

发言人   01:12:59
I had a bit of a tangential question is who manages the creation of compilers from like to get from C to various instruction set architectures? Is that the creator of the instruction set architecture? Is it a third party, something like that? I believe that it is not the creator of the instruction set, so it's often a third party. So the two big C compilers that you'll see referred to GCC, which is maintained by, I think, the GNU Foundation and, slang or lldm, which is its own thing. So I think I believe Lov M is even open source, so you can find. 
我有一个有点切题的问题是，谁管理从like到从C到各种指令集架构的编译器的创建？那是指令集架构的创造者吗？它是第三方的东西吗？我相信它不是指令集的创建者，所以通常是第三方。所以你将看到的两个大型C编译器都引用了GCC，我认为这是由GNU基金会和俚语或lldm维护的，这是它自己的东西。所以我相信Lov M甚至是开源的，所以你可以找到。

发言人   01:13:42
The code specifically way that does this, when a new instruction set is released, such as risk 5, that calling convention document, as well as all of those instruction documents, I think are carefully, but I assume there's like a high level of cooperation between the compiler designer and the instruction set designer. But yeah, short answer is I believe it's a third, third party who does it likely with a lot of cooperation from the people who make the instruction set risk. 5 is probably risk five might be an exception where because it came out of a research project, they may have written the compiler for it themselves as well. But I don't think Intel, for example, has input in GCC or lldm. 
当一个新的指令集发布时，比如风险5，调用约定文档以及所有这些指令文档，我认为是谨慎的，但我认为编译器设计人员和指令集设计人员之间存在高水平的合作。但是，简短的答案是，我相信这是第三方，第三方可能在使指令集风险的人们的大量合作下完成的。5可能是一个例外，因为它来自于一个研究项目，他们可能自己也为它编写了编译器。但我不认为英特尔，例如，在GCC或lldm中有输入。

发言人   01:14:45
Other questions? 
其他问题？

发言人   01:14:54
Okay, well, thanks for listening in that case. And I guess we can, we can end the lecture here with five minutes to spare. So have a nice rest. 
好的，谢谢您在这种情况下倾听。我想我们可以，我们可以在这里结束讲座，还有五分钟的时间。所以好好休息。
