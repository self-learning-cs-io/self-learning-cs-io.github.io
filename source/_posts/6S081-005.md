---
title: 操作系统工程 005-Isolation SystemCall Entry
date: 2025-10-18 10:00:05
---

发言人   00:02
All right I'd like to get started first. Can, can anyone hear me? Yes, good, thank you very much. 
好的，我想先开始。有人能听到我吗？是的，很好，非常感谢。

发言人   00:13
All right, today I want to talk about the transition between running and user code, running programs and user code and executing in the kernel. And this is the transition that has to happen whenever a program makes a system call or it experiences a fault, like a page fault or divide by zero. Or if a device decides to interrupt, then needs to be served by a kernel device provider. There's a lot of careful design and sort of important details that go into the how these traps from user to kernel happen. And the details are pretty important for forcing isolation, security, and also performance. There's many programs that transition to the kernel a lot, either due to system calls or page. And it can be super important that the trap mechanism is as streamlined as possible. 
好的，今天我想谈谈运行和用户代码之间的转换，运行程序和用户代码以及在内核中执行。这是每当程序进行系统调用或遇到错误 (如页面错误或被零除) 时必须发生的转换。如果设备决定中断，则需要由内核设备提供程序提供服务。有很多精心的设计和一些重要的细节说明这些陷阱如何从用户到内核发生。细节对于强制隔离、安全性和性能非常重要。有许多程序经常转换到内核，可能是由于系统调用或页面。而且尽可能简化陷阱机制可能是非常重要的。

发言人   01:07
All right, so starting situation is pretty familiar. We have our user program. I want use the shell as an example, running up in user space and. We have the kernel. And what the shell would like to do is make a system call into the kernel. And I'm going to use, right? I'm going to use this shell writing. It's prompt the very first, right? That happens after you boot XV 6, use the shell trying to write, make the right system call as an example. And so we need to figure out how to actually get execution to transfer from running on the show in the user space with user privileges to running on the kernel with supervisor privileges. 
好的，所以开始的情况非常熟悉。我们有我们的用户程序。我想以shell为例，在用户空间中运行。我们有了内核。而shell想要做的是对内核进行系统调用。我要用，对吧？我将使用这个shell编写。这是第一个提示，对吗？这发生在你启动XV 6之后，使用shell尝试编写，并进行正确的系统调用作为例子。因此，我们需要弄清楚如何实际执行以从具有用户权限的在用户空间中运行的show转移到具有主管权限的在内核上运行的情况。

发言人   01:52
The state of the hardware is going to be very important because a lot of what we're doing is kind of changing the hardware state from state appropriate for running user code to state appropriate for running kernel code. 
硬件的状态将非常重要，因为我们正在做的很多事情都是将硬件状态从适合运行用户代码的状态更改为适合运行内核代码的状态。

发言人   02:06
The state that we care about, the biggest state is maybe the 32 user registers. As you remember this from Monday's discussion, we have all the user registers things like a 0 and a 1. Risk 5 has a whole lot of these 32 in total, and we can expect user code to use all of them. It's going to get the highest performance if it uses all of them. Many of them have special purposes, a few of which we'll see. A particularly interesting one is the stack pointer is actually one of these 32 general purpose registers. Okay, we have these registers, including a stack pointer. There's a separate program counter register in the hardware. 
我们关心的状态，最大的状态可能是32个用户寄存器。你还记得在Mond的讨论中，我们有所有用户注册0和1之类的东西。风险5总共有很多这32个，我们可以期望用户代码使用所有这些。如果使用所有这些功能，它将获得最高性能。它们中的许多都有特殊用途，其中一些我们会看到。特别有趣的是，堆栈指针实际上是这32个通用寄存器之一。好的，我们有这些寄存器，包括一个堆栈指针。在硬件中有一个单独的程序计数器寄存器。


发言人   02:52
There's the current mode, either supervisor or user, and of course, it's user mode when we're executing up in the shell. And then there's a bunch of registers, special registers that control how the CPU works, like there's the Sap P register that contains a pointer to the page table. 
有当前模式，无论是主管还是用户，当然，当我们在shell中执行时，它是用户模式。然后有一些寄存器，特殊的寄存器控制CPU的工作方式，就像有Sap P寄存器包含一个指向页表的指针。

发言人   03:13
And it'll turn out there's a couple of others that are super important for this discussion. There's this St V, which is addressing the instruction that should handle traps in the kernel. There's a register called scpc for saving the program counter during a trap. We'll see there's another one called a scratch, which is also very important. So this is the state of the running machine at the time of the system call. And we actually need to change a bunch of the state or do things to the state as part of get getting into the kernel and setting ourselves self up to run just ordinary C functions in the kernel. 
结果会发现还有其他几个对这次讨论非常重要。有这个St V，它处理应该在内核中处理陷阱的指令。有一个名为scpc的寄存器，用于在陷阱期间保存程序计数器。我们会看到还有另一个叫做划痕的，它也非常重要。所以这是系统调用时正在运行的计算机的状态。实际上，我们需要改变一堆状态或对状态做一些事情，作为进入内核并设置自己只在内核中运行普通的C函数的一部分。

发言人   03:50
Certainly at the instant of the trap, all the state of the CPU is set up to run user code, not kernel code. So the things that are going to need to happen as kind of a preview of what I'll talk about, one is that we need to save all 32 registers because we want to resume the user code transparently, particularly if there's a device interrupt which the user code isn't expecting. And we want to be able to have the kernel serve the interrupt and then resume the user code without ever noticing any difference. And that means that these 32 registers can't be disturbed by the kernel, which and the kernel you need to use the registers it has to save them all somewhere first. So these need to be saved. The program counter also needs to be saved somewhere because we need to, it's a user, it's almost like a user register. 
当然，在陷阱发生的瞬间，CPU的所有状态都设置为运行用户代码，而不是内核代码。因此，作为我将要讨论的预览，需要发生的事情之一是我们需要保存所有32个寄存器，因为我们希望透明地恢复用户代码，特别是如果存在用户代码不期望的设备中断。我们希望能够让内核为中断提供服务，然后在没有任何区别的情况下恢复用户代码。这意味着这32个寄存器不能被内核干扰，内核需要使用这些寄存器，它必须首先将它们保存在某个地方。所以这些需要被拯救。程序计数器也需要保存在某个地方，因为我们需要，它是一个用户，它几乎就像一个用户寄存器。

发言人   04:37
We need to continue executing the user program where it left off. We need to switch the mode to supervisor mode because we need to use various privileges in the kernel. 
我们需要继续在用户程序中断的地方执行它。我们需要将模式切换到主管模式，因为我们需要在内核中使用各种特权。

发言人   04:50
Page table pointer is currently pointing towards the user page table which only contains just the mappings that user programs need plus one or two models. We'll see, but the user page table does not contain the mappings for the bulk of the kernel data. So we need to switch page tables before we can run most kernel code. We need to switch the stack pointer to point to a stack that's in the kernel somewhere, because we need to stack the call C functions on. And finally, we need to jump into once we've set all this up and switched all, all these resources to be appropriate for use in the kernel, we need to jump to kernel C code in. 
页表指针目前指向用户页表，其中只包含用户程序需要的映射以及一个或两个模型。我们会看到，但用户页表不包含大量内核数据的映射。所以我们需要在运行大多数内核代码之前切换页表。我们需要切换堆栈指针以指向内核中某个堆栈，因为我们需要将调用C函数堆叠在其上。最后，一旦我们设置了所有这些并切换了所有这些资源，使其适合在内核中使用，我们需要跳转到内核C代码。


发言人   05:30
Once we're in C code, life is much more sort of business as usual. We're just running AC program in this kernel. And so for today at least, we'll talk about what the kernel does in the C code later. But today, the discussion is really how to get from user space into the kernel into a position where we can run C code in the kernel. 
一旦我们使用C代码，生活就会像往常一样。我们只是在这个内核中运行交流程序。所以至少今天，我们稍后会讨论内核在C代码中所做的事情。但今天的讨论实际上是如何从用户空间进入内核，使我们能够在内核中运行C代码。

发言人   05:54
There's a couple of high level goals that can our design options for this one is that for security and isolation, we really don't want to let user code interfere with this user kernel transition in a way that could be damaging to security. And so that means that the sort of hardware and kernel mechanisms that are involved in traps really can't count on anything from user space. We can't assume anything about these registers, they could be just filled with terribly malicious values. So basically, the XV 6 strap handler doesn't really even look at these registers, it just saves them away. Okay, so we're going to want to be careful to preserve isolation during this trap mechanism against intentionally malicious user code. And the other thing that's important is that we want to be transparent to user code, we'd like to be able to take the trap and do a business in the kernel and resume the user code without it ever having to notice that anything funny happened. And that's just to make it easier to write user code. 
我们的设计方案有几个高级目标，即安全性和隔离，我们真的不希望让用户代码以可能损害安全性的方式干扰用户内核转换。这意味着陷阱中涉及的硬件和内核机制实际上无法依赖用户空间的任何东西。我们无法对这些寄存器做出任何假设，它们可能只是充满了非常恶意的值。基本上，XV 6条带处理程序甚至不会真正查看这些寄存器，只是将它们保存下来。好的，所以我们要小心在这个陷阱机制中保持隔离，防止故意恶意的用户代码。另一件重要的事情是，我们希望对用户代码透明，我们希望能够掉入陷阱，在内核中做生意并恢复用户代码，而无需注意到发生了任何有趣的事情。这只是为了更容易编写用户代码。

发言人   06:56
And something to note, we care about isolation and security here. Today, we're just going to talk about the sort of aspect of security that involves getting into the kernel. But of course, the system called implementations, you know, the actual write implementation in the kernel. Also, everything in the kernel has to be careful, has to be written carefully and securely also. So even if this transition into the kernel is perfectly secure, the whole rest of the kernel has to be written securely and sort of mindful that user code may try to trick it. 
需要注意的是，我们关心这里的隔离和安全。今天，我们只是要讨论涉及进入内核的安全方面。当然，这个系统被称为实现，你知道，内核中的实际写入实现。此外，内核中的一切都必须小心，也必须仔细和安全地编写。因此，即使转换到内核是完全安全的，内核的其余部分也必须安全地编写，并注意用户代码可能会试图欺骗它。

![](/source/images/15213-07-45.png)

发言人   07:32
A particularly important thing I want to talk about is what it is that the mode flag controls. This mode is either user or supervisor. Of course, it's user and user space. 
我想谈论的特别重要的事情是模式标志控制是什么。此模式可以是用户或主管。当然，这是用户和用户空间。

发言人   07:44
The mode flag is set to supervisor when we're executing on the kernel, but it's important to know exactly what privileges we gain by changing the mode from user to supervisor. And it turns out these extra privileges are fairly restrictive. That is what you can do in supervisor mode, you couldn't do in user mode, is not maybe is. Privileges, you might think. So this is supervisor mode, like exactly what it controls. One thing it does is you can now read and write the control registers. And that is if you're in supervisor mode, you can read and write satp the page table pointer, this St VC pointer, which controls where traps go in the kernel, this register that holds the save program counter during a trap, and this a scratch register plus a few others. So supervisor couldn't and write these registers and user code could not. 
当我们在内核上执行时，模式标志被设置为supervisor，但重要的是要确切知道我们通过将模式从用户更改为supervisor获得了哪些特权。事实证明，这些额外的特权是相当限制性的。这就是你在主管模式下可以做的，在用户模式下不能做的，也许不是。特权，你可能会想。所以这是主管模式，就像它控制的那样。它所做的一件事是您现在可以读取和写入控制寄存器。也就是说，如果您处于主管模式，您可以读写satp页表指针，这个St VC指针，它控制陷阱在内核中的位置，这个寄存器在陷阱期间保存保存程序计数器，还有一个划痕寄存器和其他一些东西。因此主管无法编写这些寄存器和用户代码，也无法编写。


发言人   08:46
The only other thing supervisor code can do is it can use Ptes. That have the Pte you flag set? I don't know if you remember, but there's this Pte you flag be set or not set in each page table entry. A flag that has this. Sorry, sorry, you can use Ptes that don't have the Pte flag set. If the Pte you flag is set, it means that user code can use that page table entry. If this flag isn't set in a page table entry, it means only supervisor mode can use it. And, you know, we'll see that's important in a little bit, but these are really the only things that supervisor mode can do. 
监督员代码唯一可以做的另一件事就是可以使用Ptes。你的国旗已经设置了Pte吗？我不知道你是否还记得，但是在每个页表条目中都有这个要设置或不设置的标志。一个有这个标志的标志。抱歉，抱歉，您可以使用没有设置Pte标志的Ptes。如果设置了Pte标志，则意味着用户代码可以使用该页表条目。如果页表条目中没有设置此标志，则意味着只有主管模式可以使用它。而且，你知道，我们很快就会看到这一点很重要，但这些确实是主管模式唯一可以做的事情。

发言人   09:32
We can't do anything else in particular, for example, supervisor mode code can't just read and write arbitrary addresses, say physical addresses. No supervisor mode is forced to go through the page table just like any other code. If a virtual address isn, the isn't in the current page table pointed to by Sap P, or if it has the Pte, you bit flag set, which means it's the user Pte, then supervisor mode code can not use that address. So we're even in supervisory mode, we're restricted to whatever virtual address virtual addresses were set up in the current page table. And that's it, so we're just allowed to do these things. So, you know, we'll see. 
我们不能做任何其他特别的事情，例如，supervisor模式代码不能仅仅读写任意地址，比如物理地址。没有监督模式被强制像任何其他代码一样通过页表。如果虚拟地址不在Sap P所指向的当前页表中，或者如果它设置了Pte，您位标志，这意味着它是用户Pte，则主管模式代码不能使用该地址。所以我们甚至处于管理模式，我们被限制在当前页表中设置的虚拟地址中。就这样，我们被允许做这些事情。所以，你知道，我们会看到的。


发言人   10:17
This is a significant constraint on what the track code can do when we're entering the kernel. I can't do just anything. I'm going to preview a bit. 
当我们进入内核时，这是对跟踪代码可以执行的重要限制。我不能做任何事情。我要预览一下。


发言人   10:29
I'm going to spend most of this lecture in Gdb actually tracing through the execution of a trap entry into the kernel. In return, there's going to be a lot of details in order to. Maybe sort of help you see ahead of what's coming. We're going to be tracing the shell's call to right, which from the shell's point of view is just AC function call Part of the shell, in fact, right, makes this is a system call by issuing the E call instruction, which switches into the kernel and switch supervisor mode where that goes immediately. That is the very first instruction This executed in the kernel in supervisor mode is in a function written in assembler called user back, and this is in the part of the trampoline. 
我将在这节课的大部分时间里，通过执行一个进入内核的陷阱条目来跟踪Gdb。作为回报，将会有很多细节。也许可以帮助你提前看到即将发生的事情。我们将从右边跟踪shell的调用，从shell的角度来看，这只是shell的交流函数调用部分，实际上，通过发出E call指令使这是一个系统调用。这会切换到内核并切换到主管模式，这将立即消失。这是在内核中的主管模式下执行的第一个指令，它是在一个名为user back的汇编程序中编写的函数中，并且它在蹦床的一部分中。

发言人   11:33
In trampoline S, in the kernel source. So the very first code that's executed is this user v assembler function. And next, the data asselar function jumps into C code, in particular function called user trap in trap DOC. And now we're getting into the C code. So things are much easier to understand user trap c.o. we're executing a system call, and it calls the function. It's call which looks at the system call number and a table and calls the particular function inside the kernel that implements that system call. And for us is going to be right and right does this business, it happens to, you know, arrange for the whatever bytes were written to appear on the console, and when it's finished, it returns back up to this system call function. 
在蹦床中，在内核源代码中。所以执行的第一个代码是这个用户v汇编函数。接下来，data asselar函数跳转到C代码中，特别是在trap DOC中称为用户陷阱的函数。现在我们进入了C代码。所以事情更容易理解用户陷阱c.o。 我们正在执行一个系统调用，它调用该函数。它是call，它查看系统调用号码和表，并调用内核中实现该系统调用的特定函数。对于我们来说，这项业务将是正确的，它恰好安排了写入的任何字节出现在控制台上，完成后，它将返回到这个系统调用函数。


发言人   12:24
And then the system call function in order to return back to user space, because we want to resume after this e-scale there's a bunch of stuff we'll see that has to happen in order to return to user space that there's a separate function called user trap re. It's written in C, it's in trap DOC that does the part of this return to user space that's convenient to do in C code. There's some final things that really can only be done in assembly code. And the code for that is written in assembler. And it's, again, in this trampoline page in a function called user Re. The last, some last assembly stuff that has to happen. And then finally, this assembly function issues the machine instruction that returns back in user space and resume execution after the Eco, right? 
然后系统调用函数以返回用户空间，因为我们想要在这个电子刻度后恢复，为了返回用户空间，我们将看到必须发生的一堆事情，有一个单独的函数称为用户陷阱。它是用C编写的，它在陷阱文档中完成这部分返回到用户空间，这在C代码中很方便。还有一些最终的事情实际上只能在汇编代码中完成。并且其代码是用汇编语言编写的。它在这个蹦床页面中，位于一个名为user Re的函数中。最后，一些必须发生的最后组装事情。最后，这个汇编函数发出机器指令，返回用户空间并在生态之后恢复执行，对吗？

![](/source/images/15213-13-30.png)

发言人   13:21
Does anybody want to answer, ask a question about my about to switch into looking at stuff with gdb? Any questions about the sort of high level picture? 
有人想回答吗，问一个关于我即将转向使用gdb看东西的问题吗？对高层次的图片有什么问题吗？

发言人   13:37
All right, I am going to sorry, I can let me see what mode r VM dot c functions run in, DM dot c functions. Everything in there is part of the kernel and it's run in supervisor mode. 
好的，我会抱歉的，我可以让我看看r VM dot c函数在什么模式下运行，DM dot c函数。里面的一切都是内核的一部分，它以主管模式运行。

发言人   13:57
Yeah, okay, somebody asked why these functions are named this way. The naming is a bit of a disaster, and for next year I'm resolved to make them more rational. I think the naming question might have referred to the name of the registers in the previous board for supervisor. Other than that, there is 5 people. Pick these names. 
好的，有人问为什么这些函数都这么命名。命名有点像一场灾难，明年我决心让它们变得更加理性。我认为命名问题可能指的是上一个监事会中的寄存器的名称。除此之外，还有5个人。选择这些名字。

发言人   14:30
Somebody's asking, don't the VM DOC functions access physical memory directly? That's absolutely true. The reason why they're allowed to do that, though, is that the kernel carefully sets up direct mappings in the page table. Many, many Ptes in the page table, which cause whenever the kernel tries to read or write a physical address, it actually is a virtual address that's translated by the kernel page table into the physical address. It's equal to the virtual address that was issued. So it's like super convenient in the kernel once you're using the kernel page table because the kernel has all these direct mappings. But we've set up until the trap machinery has switched to the kernel page table, none of those mappings are available until the kernel trap code is switched to the kernel page table, we're still using the user page table, which has none of these convenient mappings for physical addresses. 
有人在问，VM文档函数不是直接访问物理内存吗？这是完全正确的。他们被允许这样做的原因是，内核仔细地在页表中设置了直接映射。页表中有很多很多的Ptes，这导致每当内核尝试读取或写入物理地址时，它实际上是一个虚拟地址，由内核页表转换为物理地址。它等于已发出的虚拟地址。因此，一旦您使用内核页表，在内核中就非常方便，因为内核具有所有这些直接映射。但是我们已经设置了，直到陷阱机器切换到内核页表，这些映射都不可用，直到内核陷阱代码切换到内核页表，我们仍在使用用户页表，它没有这些方便的物理地址映射。

发言人   15:29
Okay? Can I ask a question, please? I don't know, this is maybe not exactly relevant to what was just said, but the read and write system calls, right? Like those are pretty expensive compared to just a memory store because you have to actually switch modes and go back and forth. Would it be possible to just like instead of when, when you open a file, instead of getting back a file descriptor that you call with a system call to get a page table mapping? And then you would just write to a certain address that's just mapped to the device and you can set up the restrictions so that the program can only write to a device to like a file descriptor that it's allowed to, which is allowed to through the virtual page table mapping instead of jumping to the kernel and back. 
好吗？我可以问一个问题吗？我不知道，这可能与刚才说的并不完全相关，但是读写系统调用，对吧？与仅仅是一个内存存储相比，像这样的东西相当昂贵，因为你必须实际切换模式并来回切换。当你打开一个文件时，是否有可能不需要返回一个你用系统调用的文件描述符来获取页表映射？然后，您只需写入映射到设备的某个地址，然后您可以设置限制，使程序只能写入允许的文件描述符，这可以通过虚拟页表映射来实现，而不是跳转到内核并返回。

发言人   16:26
Yeah, that's a good observation. And indeed, many operating systems provide this, what's called memory mapped file access, where indeed you map pages that correspond to the file contents into the user virtual address space, so you can read or write them directly through memory. In fact, you'll be implementing a version of this in the nmat lab in a couple of weeks. And indeed, as you comply, it's a good deal faster for many programs than calling a beam, right? Okay? I'm going to switch to the Gdb world. 
是的，这是一个很好的观察。实际上，许多操作系统都提供了这种称为内存映射文件访问的功能，您可以将与文件内容对应的页面映射到用户虚拟地址空间中，这样您就可以直接通过内存读取或写入它们。实际上，几周后，您将在nmat实验室中实施此版本的一个版本。事实上，如果你遵守，对于许多程序来说，这比调用光束要快得多，对吧？好吗？我要切换到Gdb世界。


发言人   17:19
All right, at this point, everybody should. 
好的，在这一点上，每个人都应该。

发言人   17:26
See my screen share. We're going to watch an XP system call right? The shell's right of its initial prompt make its way through the system. You can see the user code that initiates this in Sh DOC. And I'm showing that here is just making the right system call with this dollar sign prompt. Let me fire up. Gdb? 
查看我的屏幕共享。我们要观看一个XP系统调用，对吗？shell在其初始提示符的右侧通过系统。你可以在Sh DOC中看到启动此操作的用户代码。我在这里展示的是使用这个美元符号提示符进行正确的系统调用。让我火起来。Gdb?


发言人   18:03
Excellent, so what actually happens when user code, when the shell calls right, right, is it's a library function's part of the that's linked into the shell and you can see the source for it in US dot s. So it's this couple of instructions here is the implementation of the right function that the show is actually calling. And this is a very short function. All it's doing is loading into a 7 a number Cys, right, which is just symbolically defined to be 16. That tells the kernel, I want to run the 16 right system call, which happens to be right, and then this little function uses the eeca instruction, which is what actually gets the code into the kernel. The kernel does this thing. And then when the kernel's finally done, it returns back into user space to execute the instruction after the e call, which is that Re, it returns back to the shell, returns from that right library function, back into the shell, so what I'd like to do in order to show the system call part of this I'm going to start by putting a breakpoint on that e call instruction. 
非常好，所以当用户代码，当shell调用right时，实际发生的情况是，它是链接到shell的库函数的一部分，您可以在US.s中看到它的源代码。所以这里的这几个指令是实现show实际调用的正确函数。这是一个很短的函数。它所做的只是加载到一个7一个数字Cys中，对，它只是象征性地定义为16。告诉内核，我想运行16个正确的系统调用，这恰好是正确的，然后这个小函数使用eeca指令，这实际上是将代码导入内核的原因。内核做这件事。然后当内核完成后，它返回到用户空间以在e调用后执行指令，也就是说，它返回到shell，从正确的库函数返回到shell，所以我想做什么来显示系统调用部分，我将从在e调用指令上放置一个断点开始。


发言人   19:21
And we need to know its address, of course, but we can find that out by looking at sh do ASM, which the XV 6 compilation process produces, and in Sh do ASM, there's an assembly code with addresses of the. Instructions for the shell. So I'm going to put a breakpoint on the E call instruction, which is it address De 6. Excellent, now I'm going to actually start Xe 6 running, and I'm hoping to have the system break in the shell just before executing E call. 
当然，我们需要知道它的地址，但我们可以通过查看XV 6编译过程产生的sh do ASM来找到答案，在Sh do ASM中，有一个地址为的汇编代码。shell的说明。所以我将在E call指令上设置一个断点，即它的地址De 6。非常好，现在我要实际开始运行Xe 6，并且我希望在执行E调用之前让系统在shell中崩溃。



发言人   20:02
All right, excellent. 
好的，很好。

发言人   20:03
Where now you can see from Gdb, we're about to, we're about to execute that equal, let's just check that we are where we think we are Print, We can print the program counter 0x to e 6, just what we asked for, We can also print the all 32 registers and some of these values, whatever we don't know, we don't care what they are. But a 0, a 1, and a two are the three arguments that the shell passed, right? And so those arguments are file de scriptor 2 and a 0, the pointer to the buffer of characters that the shell wants to write in a one and the number of characters it wants to write in a two. And we can convince ourselves that we're looking at the code we think we're looking at by actually printing out the by. It's in that buffer that the shuttle wants to write. And indeed, it's a dollar sign and a space. 
现在你可以从Gdb看到，我们即将执行相等的操作，让我们检查一下我们认为我们正在打印的位置，我们可以将程序计数器0x打印到e 6，这正是我们要求的。我们还可以打印所有32个寄存器和其中的一些值，无论我们不知道什么，我们都不在乎它们是什么。但是0、1和2是shell传递的三个参数，对吧？所以这些参数是文件de scriptor 2和一个0，指向shell想要写入的字符缓冲区的指针为1，并且它想要写入的字符数量为2。我们可以通过实际打印出来来说服自己，我们正在查看我们认为正在查看的代码。它在航天飞机想要写入的缓冲区中。事实上，这是一个美元符号和一个空格。




发言人   21:08
We're at the system call that that we hope to be at. One thing to notice is that program counter and the stack point are both at low addresses, quite close to 0. And that there's reinforces our belief that we're still executing in user and the user address space where all the addresses are quite small. Once we get into the kernel, you see the addresses are the kernel is actually loaded much, much higher in memory. Okay, we the point of the system calls to switch around a lot of state. One of the most important pieces of state that has to get switched and that we have to live with before it's switched is the current page table. Of course, we can look at it Sat P? But all we get there is the address and physical memory. 
我们正处于我们希望达到的系统呼叫中。需要注意的一件事是，程序计数器和堆栈点都在低地址，非常接近0。而且这加强了我们的信念，即我们仍然在用户和用户地址空间中执行，其中所有地址都非常小。一旦我们进入内核，您会看到地址实际上是内核在内存中加载了高得多的地址。好的，我们知道系统调用的目的是切换许多状态。必须进行切换的最重要的状态之一，并且在切换之前我们必须忍受的是当前页表。当然，我们可以在P上看一下？但我们得到的只是地址和物理内存。


![](/source/images/15213-21-42.png)


发言人   21:55
The page tables doesn't actually tell us much about what the mappings are with the page table looks like. Luckily, there's a way in qmu to ask it to print the current page table, and I print CR AC, I get into the qmu monitor or console, and if I then type info-mem, it'll print the complete page table. 
页表实际上并没有告诉我们很多关于页表之间的映射是什么样子的。幸运的是，在qmu中有一种方法可以要求它打印当前页表，然后我打印CR交流，进入qmu监视器或控制台，如果我然后输入info-mem，它将打印完整的页表。

![](/source/images/15213-23-27.png)


发言人   22:19
This is a very small page table that contains only six mappings. Of course, it's the page statement for the shell. Shell is a pretty small program and these six mappings are in order, the shell's instructions, the shell's data, an invalid page which access the stack, a guard page in case the shuttle tries to use too much stack space. And we can see it's invalid because it doesn't have the U flag set over here in this attribute or flag column. These are all the Pte underscore flags RW and X, or just control whether a ph can be read or written or executed. The next column is U and that's whether or not the Pte flag is set. And user code can only get at Pte entries for which the flag is set, I don't know what the next column is, I have to admit. And the next column is A for whether the page table entry has ever been used, and D for whether or write has ever been issued for this address. 
这是一个非常小的页表，只包含六个映射。当然，这是shell的页面语句。Shell是一个非常小的程序，这六个映射是有序的，shell的指令，shell的数据，一个访问堆栈的无效页面，一个保护页面，以防shuttle试图占用太多的堆栈空间。我们可以看到它是无效的，因为它在此属性或标志列中没有设置U标志。这些都是Pte下划线标志RW和X，或者只是控制是否可以读取、写入或执行ph。下一列是U，这就是是否设置了Pte标志。用户代码只能获取设置了标志的Pte条目，我不知道下一列是什么，我不得不承认。下一列是A，表示页表条目是否曾被使用过，以及D是否曾为此地址发出过write。

发言人   23:28
Okay, so we have this tiny page and the last two page table entries, by the way, are way up at an Ormus virtual addresses, very close to the top of the virtual address space. And these two, as you read about in the book, and we'll hear much more about, are the trap frame page, now the trampoline page. And as you can see, neither of them has the U bit set. So user code can't get at, can't use either of these addresses now. But once we enter the supervisor mode, we can get out these two pages. 
好的，所以我们有这个小页面，最后两个页表条目，顺便说一下，是在一个Ormus虚拟地址上，非常接近虚拟地址空间的顶部。这两个，正如你在书中读到的，我们会听到更多，是陷阱框架页，现在是蹦床页。正如你所看到的，它们都没有设置U位。因此用户代码无法访问，现在无法使用这两个地址中的任何一个。但是一旦我们进入主管模式，我们就可以看到这两页。

发言人   24:05
All right, one thing notice about this page table is there's no mappings for anything in the kernel. There's no physical address mappings. There's no mappings for the kernel's data or the kernel's instructions or anything else. This is, except for the last two, the very last two pages. Now, this is a page table almost entirely dedicated to user execution, and it's not directly particularly useful executing the kernel. 
好的，关于这个页表需要注意的一件事是，在内核中没有任何映射。没有物理地址映射。内核的数据或内核的指令或其他任何东西都没有映射。这是，除了最后两页，最后两页。现在，这是一个几乎完全用于用户执行的页表，并不直接特别有用执行内核。

发言人   24:30
All right, what's the, what's the a attribute on the on the page label listing on the top? 
好的，页面标签上的属性是什么？

发言人   24:37
Believe this means the page table has ever been, this page table entry has ever been accessed by code, that is, whether it's ever issued an address that refers to this page table entry. And the D is whether the program is ever written, ever done a store through this page table entry. And these are bits that the hardware maintains for the convenience of the operating system. And operating system is more sophisticated than XV 6. They need to eviction pages. If they're running short on physical memory, they may need to write some pages of memory to disk and invalidate the page table entries to free up the physical memory. And many policies you could imagine an operating system using to pick which pages to exist, we'll consult the A bits to see whether this page table entry has ever even been used and if it hasn't been used or haven't been used recently, then that's a good candidate for evictions. To dis the D, it tells the kernel that, oh, this page has actually been written since it was read from disk XV 6 doesn't actually use either of these. 
相信这意味着页表曾经存在，这个页表条目曾经被代码访问过，也就是说，它是否曾经发出过引用这个页表条目的地址。D是指程序是否曾经被编写过，是否曾经通过这个页表条目进行过存储。这些是硬件为方便操作系统而维护的位。操作系统比XV 6更复杂。他们需要驱逐页面。如果物理内存不足，他们可能需要将一些内存页写入磁盘并使页表条目无效以释放物理内存。并且你可以想象一个操作系统使用许多策略来选择存在的页面，我们将咨询A位，以查看这个页表条目是否曾经被使用过，如果它没有被使用或最近没有被使用，那么这是一个很好的驱逐候选。如果是D，它会告诉内核，哦，这个页面实际上是从磁盘读取的，XV 6实际上并没有使用这两个。

发言人   25:55
All right, other questions? All right, let's execute the, Let me just remind us where we are. I'm going to print out the contents of the right. We're in the right library function and In the shell. And the program counter is pointed to the eco instruction. We're about to execute the eco instruction. We're still in user space, but we won't be for long, but I executed the eeco instruction. 
好的，还有其他问题吗？好的，让我们执行一下，让我提醒一下我们现在的位置。我将打印出右边的内容。我们在正确的库函数和shell中。并且程序计数器指向eco指令。我们即将执行生态指令。我们仍在用户空间中，但不会持续很长时间，但我执行了eeco指令。


发言人   26:30
Okay, so first question is, where are we after the E call? We can look at the program counter we see is now used to be a very low number d 6. Now it's a very high number. In fact, we look at the program counter as a virtual address, like all addresses that instructions use. And we can look in the page table. Actually, let's just check what the page table is, just be sure. 
好的，第一个问题是，在E call之后我们在哪里？我们可以查看程序计数器，我们看到的现在是一个非常低的数字d 6。现在这是一个非常高的数字。事实上，我们将程序计数器视为虚拟地址，就像指令使用的所有地址一样。我们可以在页面表格中查看。实际上，让我们检查一下页表是什么，只要确认一下即可。

发言人   26:55
I'm going to ask q.u. for info me again, it's the very same page table, so nothing's changed there. We'll look up our new current program counter there. The program counter is at the right at the beginning of this trampoline page that's mapped way up high in the user memory. That's where we're executing, we can see the instructions that are there and I'm going to use. 
我要问问q.u。 再次给我提供信息，它是同一个页表，所以那里没有任何变化。我们将在那里查找我们新的当前程序计数器。程序计数器位于蹦床页面的开头右侧，该页面在用户内存中被映射得很高。这就是我们执行的地方，我们可以看到那里的指令，我将使用它们。


发言人   27:31
These are the instructions, the very first instructions that the kernel executes in supervisor mode, the very beginning of the trap. And through some weirdness in GDP, we've actually already executed the first instruction at the very beginning of this page. And we're about to execute the second instruction. 
这些是指令，内核在主管模式下执行的第一条指令，陷阱的开始。通过一些奇怪的国内生产总值（GDP），我们实际上已经执行了本页开头的第一条指令。我们即将执行第二个指令。

发言人   27:53
We can look at the registers. I don't know if you remember these register values, but nothing changed here. These are exactly the same register contents that the user program has had. So these are all full of user values for many of them, or all of them, for all we know, they're the only locations these value exist. So we have to be very careful that we can't actually use any registers at this point without first saving those registers somewhere so we can restore them. Because if the kernel was to use any of these registers at this point, it would overwrite whatever that user value is. And then if we tried to resume the user program, we wouldn't be able to set up its registers with the correct values. 
我们可以看看登记册。我不知道你是否记得这些寄存器值，但这里什么也没有改变。这些是用户程序所拥有的完全相同的寄存器内容。因此，对于其中许多或全部，这些都充满了用户价值，就我们所知，它们是这些价值存在的唯一位置。所以我们必须非常小心，如果没有先将这些寄存器保存在某个地方以便恢复它们，我们现在就不能真正使用任何寄存器。因为如果内核此时使用这些寄存器中的任何一个，它将覆盖该用户值。然后，如果我们尝试恢复用户程序，我们将无法使用正确的值设置其寄存器。


发言人   28:32
The use your program to just do something totally wrong question. Yes, could you return to the instructions panel that you had before? I'm wondering what the Crr W instruction is doing, no? The CSR W, okay, we'll talk about this in a few minutes, but the answer to your question is that instruction swaps a 0 with the contents of the special scratch register. And so in, yeah, okay, and this is like super important and basically answers the question, how can the kernel trap code do anything if it can't use any registers? 
使用你的程序来做一些完全错误的问题。是的，您能回到之前的说明面板吗？我想知道crw指令在做什么，不是吗？CSR W，好的，我们过几分钟再讨论这个问题，但是你的问题的答案是，指令用特殊暂存寄存器的内容交换0。所以，好的，这非常重要，基本上回答了这个问题，如果内核陷阱代码不能使用任何寄存器，它怎么能做任何事情？

发言人   29:17
The answer that question is that exit, it really has to execute this CSR RW a 0 scratch instruction that simultaneously saves a 0 and scratch and happens to load scratch into a 0. So now the kernel can use a 0 for whatever it wants to add to this instruction. Okay, yeah, okay. So we're currently, this address is 3 Fff, Fff F 0 0 0. 
这个问题的答案是退出，它真的必须执行这个CSR RW a 0暂存指令，同时保存0和暂存，并将暂存加载到0中。所以现在内核可以对它想添加到此指令中的任何内容使用0。好的，是的，好的。所以我们现在的地址是3 Fff，Fff F F 0 0。

发言人   29:46
This last page is the trampoline page, and we're currently executing in the trampoline page, which contains the very first instructions of the kernel's trap handling code. 
最后一页是蹦床页面，我们目前正在蹦床页面中执行，其中包含内核陷阱处理代码的第一条指令。

发言人   29:58
Eco doesn't switch page table. That's a very important thing about Eco. And what that means is that these very first instructions have to be present in every user page table because in zca doesn't switch page tables, we need to be executing the first bit of the kernel somewhere in the user page table. And it's this trampoline page, which the kernel carefully maps into every user page table that gives the kernel a place to execute at the very beginning of a trap. 
Eco不会切换页码表。这是生态非常重要的一件事。这意味着这些第一条指令必须出现在每个用户页表中，因为在zca中不切换页表，我们需要在用户页表中的某个地方执行内核的第一行。而这个蹦床页面，内核仔细地映射到每个用户页表中，为内核提供了一个在陷阱开始时执行的位置。

发言人   30:23
And we're still using the user page table. And the way this is controlled is through the St VC register. This is another privileged register only readable by the writable by the supervisor and the kernel before it entered user space. Set up the St VC to point to the place where the colonel wanted traps to go. And so as you can see, the colonel has previously set up this svec to this three Fff Fff F 0 0 0 address, which is the beginning of the trampoline page. And it's this St vac register that its contents is the reason why after the eeca, we ended up executing at this particular place. 
我们仍在使用用户页表。控制的方式是通过St VC寄存器。这是另一个特权寄存器，只能由主管和内核在进入用户空间之前可写读取。设置St VC指向上校想要陷阱的地方。正如你所看到的，上校之前已经将这个svec设置为这个三个Fff Fff F F 0 0地址，这是蹦床页面的开始。正是这个St vac寄存器，它的内容是我们在eeca之后最终在这个特定地方执行的原因。


发言人   31:05
And finally, I just want to remind you that even though the trampoline and trap frame pages are mapped into the user page table, the user address space, the user code can not write them because the Ptes for them don't have the Pte you flag. So they're protected against user code. And that's why this trick is, or part of the reason why this trick is safe. 
最后，我只是想提醒你，即使蹦床和陷阱框架页面被映射到用户页表，用户地址空间，用户代码也不能写它们，因为它们的Ptes没有Pte你标志。所以它们受到用户代码的保护。这就是为什么这个技巧是，或者为什么这个技巧是安全的部分原因。

发言人   31:28
I've been sort of telling you and assuming that we're in supervisor mode, I don't know any way of finding out what mode the machine is in directly. But I do observe that the program counter is currently executing in a page, the trampoline page that doesn't have a Pte you flag set. And that can only happen without a crash if we were in supervisor mode. So I deduce from the lack of a crash and the value of the program counter that we must be in supervisor mode. 
我一直在告诉你，假设我们处于主管模式，我不知道任何直接找出机器处于什么模式的方法。但我确实观察到程序计数器当前正在一个页面中执行，这个蹦床页面没有设置Pte您标志。而这只有在我们处于主管模式时才会发生而不会崩溃。所以我从没有崩溃和程序计数器的值推断我们必须处于主管模式。

发言人   31:58
How we got here, of course, is through E Eco really just changes 3 things. 
我们如何到达这里，当然，是通过E Eco真正改变了三件事。

发言人   32:03
First, e changes mode from user to supervisor. Second Eco saves the program counter register in the sepc register. So we can see the effect of that in the program counter. It's certainly no longer the user program counter, even though all the other registers were. It's this value copied from svec. And we can also print the saved. It's the supervisor exception program counter is what that stands for, but this is where Eco saves the user program counter, and that has the familiar value De 6, which is the address in user space of the E call instruction. So we got that one register, the saved away by E call. 
首先，将模式从用户更改为主管。第二个Eco将程序计数器寄存器保存在sepc寄存器中。所以我们可以在程序计数器中看到它的效果。它肯定不再是用户程序计数器，即使所有其他寄存器都是。这是从svec复制的值。我们也可以打印保存的。它代表的是主管异常程序计数器，但这是生态系统保存用户程序计数器的地方，它具有熟悉的值De 6，这是E呼叫指令在用户空间中的地址。所以我们得到了一个寄存器，通过E调用保存下来。


发言人   32:50
And the final thing that E call does, the third thing it does is jump to the instruction that sepc points to. 
E call做的最后一件事，它做的第三件事是跳转到sepc指向的指令。

![](/source/images/15213-33-03.png)

发言人   33:01
All right, so what needs to happen now, ecole's done a little bit of work for us, but it turns out we're nowhere near ready to actually execute ordinary C code in the kernel. What has to happen now is we need to save the 32 user register contents so we can later restore them When we want to resume the user code, we need to switch to the kernel page table because currently we're using the user page table, we need to create a stack or find a stack and set the stack pointer register to point to the kernel stack so we can run the C code, which requires a stack, and then we need to actually jump to some sensible place in the C code in the kernel now as an aside, you know Ecole, I didn't do any of these things for, you know, but you could have hardware could have defined E to do much more many more of these steps for us instead of leaving them to software and as we'll see the doing them with software is not particularly straightforward. So you should ask yourself why the eco doesn't do more of the work of getting from user space into the kernel and why doesn't it save their user registers or switch page table finders to point to the kernel page table or automatically set the stack pointer to point to the kernel stack or jump right to kernel C code? Geez, rather than having to go through all this complicated assembly code. And there's actually been machines that have done all of these things in hardware during system calls, the risk five doesn't do any of them The risk 5 really, the attitude they've taken is the eco does the absolute minimum that's required that it could possibly do and leave everything else up to software. And the reason for this is because the risk five designers want to allow maximum flexibility to the software, the operating system programmers to design the program operating system however they like. And so you can imagine ways XV 6 really doesn't use this freedom, but other operating systems do so some examples of things that are kind of enabled for the software to do because Eco is so simple. 
好的，那么现在需要发生什么，ecole已经为我们做了一些工作，但事实证明，我们还远未准备好在内核中实际执行普通的C代码。现在要做的是我们需要保存32个用户寄存器的内容，以便以后在我们想要恢复用户代码时恢复它们，我们需要切换到内核页表，因为目前我们正在使用用户页表，我们需要创建一个堆栈或找到一个堆栈并将堆栈指针寄存器设置为指向内核堆栈，以便我们可以运行C代码，这需要一个堆栈，然后我们需要实际上跳转到内核中C代码中的某个合理位置，你知道Ecole，我没做这些事情，你知道，但你可以让硬件定义E来为我们做更多的这些步骤，而不是把它们留给软件，正如我们将看到的，用软件来做这些并不是特别简单。所以你应该问问自己，为什么eco不做更多的工作，从用户空间进入内核，为什么不保存他们的用户注册表或切换页表查找器以指向内核页表，或自动设置堆栈指针以指向内核堆栈，或直接跳转到内核C代码？天哪，不必遍历所有这些复杂的汇编代码。实际上，有些机器在系统调用期间在硬件中完成了所有这些事情，风险五没有做任何事情，风险五真的没有做任何事情，他们所采取的态度是，生态环境只满足了它可能满足的最低要求，而其他一切则由软件来决定。这样做的原因是因为风险五设计师希望允许软件具有最大的灵活性，操作系统程序员可以按照自己喜欢的方式设计程序操作系统。因此，您可以想象XV 6实际上没有使用这种自由的方式，但其他操作系统确实使用了一些可以让软件实现的事情的例子，因为生态环境非常简单。

发言人   35:14
Maybe some operating systems can execute some trap some system calls without switching page tables. The switching page table is expensive If Eco forces you to do it. That rules out the possibility of very streamlined implementations for some system calls that don't switch page tables. Some operating systems map both user and kernel virtual addresses into a single page table and use the same page table for both user and kernel, and therefore don't even have to switch page tables ever when transitioning between user and kernel. And for them also, if you call switch page tables, that would just be a waste and slow things down. 
也许某些操作系统可以在不切换页表的情况下执行一些系统调用。如果生态迫使您这样做，那么切换页表是昂贵的。这排除了一些不切换页表的系统调用进行非常简化的实现的可能性。一些操作系统将用户和内核虚拟地址映射到单个页表中，并为用户和内核使用相同的页表，因此在用户和内核之间进行转换时甚至不需要切换页表。对于他们来说，如果你调用切换页表，那只会浪费时间并减慢速度。


发言人   35:53
Maybe in some circumstances, system calls, for example, some registers don't have to be saved. And which ones have to be saved? And that sort of depends on the software, the language, and the compiler. But you might be able to save a lot of time by saving fewer than 32 registers. They don't want Eco to kind of force you. They don't necessarily want Eco to force you to save all the registers. 
也许在某些情况下，例如系统调用，某些寄存器不需要保存。哪些人必须被拯救？这取决于软件、语言和编译器。但是您可以通过保存少于32个寄存器来节省大量时间。他们不希望生态系统强迫你。他们并不一定希望生态系统强迫你保存所有的寄存器。

发言人   36:14
And finally, maybe no stack at all is required for some simple system calls. So again, for operating systems that care a lot about performance, it's good that Eco doesn't force any particular stack policy on you. And again, there's many clever hardware software schemes for very streamlined, high performance system calls and traps just because the performance of this stuff is like super important that people worry about it a lot. 
最后，对于一些简单的系统调用，可能根本不需要堆栈。因此，对于非常注重性能的操作系统，Eco不会对您强制执行任何特定的堆栈策略是很好的。而且，有许多聪明的硬件软件方案可以实现非常简化、高性能的系统调用和陷阱，只是因为这些东西的性能非常重要，人们非常担心它。

发言人   36:43
Okay, so back to XV 6 and risk 5. The first thing we need to do is save some registers that can do hardly anything on the risk 5 without a few registers without being able to use register. So what are options for saving user register? On some other machine, we might be able to just write the contents of the 32 registers somewhere convenient. In physical memory. We can't actually really do that on the risk five because supervisor code isn't allowed to directly access physical memory. We can only use what's in the page table. There's not much in the page De. 
好的，那么回到XV 6和风险5。我们需要做的第一件事是保存一些几乎无法对风险做任何事情的寄存器5如果没有几个寄存器而无法使用寄存器。那么保存用户注册的选项有哪些？在其他机器上，我们也许能够在方便的地方写出32个寄存器的内容。在物理记忆中。我们实际上不能在风险五的情况下真正做到这一点，因为主管代码不允许直接访问物理内存。我们只能使用页表中的内容。这一页上没有太多信息。

发言人   37:20
Another possibility that Xb 6 doesn't do is simply setting the Sat P to the kernel page table, right? And then we could use all the kernel mappings and use them maybe to help us save the user registers and that be legal. The supervisor can certainly change satp, however, at this point in the trap handler, namely the beginning, we don't even know the address of the kernel page table. And furthermore, the instruction that you execute to change satp require that the address that you're loading into setp come from a register. So even execute the instruction to change page tables. We need some spare registers in order to put the new page table address in those registers so we can execute the Sap P modifying instruction. All right, so we really need to save the user registers. 
Xb 6不能做的另一种可能性是简单地将Sat P设置为内核页表，对吗？然后我们可以使用所有内核映射，并使用它们可能来帮助我们保存用户注册表，这是合法的。主管当然可以更改satp，但是，在陷阱处理程序的这一点上，即开头，我们甚至不知道内核页表的地址。此外，您执行的更改satp指令要求您正在加载到setp中的地址来自寄存器。所以即使执行指令来更改页表。我们需要一些备用寄存器才能将新的页表地址放入这些寄存器中，以便我们可以执行Sap P修改指令。好的，所以我们真的需要保存用户注册。

发言人   38:13
There's two parts to the solution for how XV 6 does this. On the risk, five part of the solution is that XV 6 into every user address, every user page table maps this crap frame page, and every process is zone trap, frame page. And the CFRE peach actually contains some interesting, a bunch of different kinds of data. But at this point, the most important data it contains is 32 slots, empty slots in memory in which to save the 32 registers. 
关于XV 6是如何做到这一点的解决方案有两个部分。在风险方面，解决方案的五个部分是将XV 6映射到每个用户地址，每个用户页表映射此垃圾帧页面，每个进程都是区域陷阱，帧页面。而这个桃子实际上包含了一些有趣的、不同种类的数据。但此时，它包含的最重要的数据是32个插槽，内存中的空插槽用于保存32个寄存器。


发言人   38:49
So the good news right now in the trap handling code is that we have a mapping. We're guaranteed to have a mapping set up by the kernel previously in the user page table that points to a place where that's prepared for us to save. 
所以现在陷阱处理代码中的好消息是我们有一个映射。我们保证在用户页表中预先由内核设置了一个映射，该映射指向一个为我们准备保存的位置。

发言人   39:03
This processes user registers. And it, it's three's always 3 F of f f of f e 0 0 0 virtual address. And if you want to see what's there actually in that trap frame, it's what XV 6 puts there is defined in. Proc dot h in struct Fra frame, which is right here. So you can see what's supposed to go in each slot. And there's a 32 slots, you know, named RA SB, GP, whatever, which are please to save registers. There's also these five things at the beginning, which we'll see will come in handy very soon, which are values. 
这将处理用户注册。它总是三个，其中三个是3个F的f个，f个是f个，e个是0 0个虚拟地址。如果你想看看那个陷阱框架里实际上有什么，那就是XV 6所定义的内容。Proc点h在struct Fra框架中，就在这里。所以你可以看到每个插槽应该有什么内容。还有32个插槽，你知道的，叫做RA SB，GP，或者其他什么，请保存寄存器。在开始的时候还有这五件事，我们会看到它们很快就会派上用场，它们是价值观。



发言人   39:49
Is that the kernel previously placed in these slots in the trap frame? Like for example, this very first slot in the trap frame contains a pointer to the kernel page table. And this will be the value that we're about. 
是先前放置在陷阱帧中的这些插槽中的内核吗？例如，陷阱框架中的第一个插槽包含一个指向内核页表的指针。这将是我们关注的价值。

发言人   40:00
We're very soon going to the trap handling code is going to load into satp, okay? So half the answer to how to say the registers is that the kernel is conveniently mapped. This trap frame and every user page table. The other is instruction. This a scratch register, which we mentioned before. So there's the special S scratch register provided by risk 5 for exactly the purpose we're about to use it for the kernel when before it goes into user space, puts a pointer there to the trap frame, basically just point puts into satp this address just for the convenience of the trap handling code. More importantly, though, there's an instruction on the w 5 that it's going to allow us to swap any register in that scratch, which will save that register as well as load the value of S scratch into whatever register we specified. 
我们很快就会把陷阱处理代码加载到satp中，好吗？所以如何说寄存器的一半答案是内核被方便地映射。这个陷阱框架和每个用户页面表。另一个是指导。这是我们之前提到的暂存器。因此，风险5提供了特殊的暂存寄存器，用于我们即将用于内核的目的，在它进入用户空间之前，在那里放置一个指向陷阱帧的指针，基本上只是为了方便陷阱处理代码将这个地址放入satp中。更重要的是，w 5上有一个指令，它允许我们交换该划痕中的任何寄存器，这将保存该寄存器并将S划痕的值加载到我们指定的任何寄存器中。

![](/source/images/15213-39-45.png)

发言人   40:56
As you can see, if I look at the trampoline code. Or right at the beginning of the trampoline code here, the very first thing it does is this CSR W instruction. This is the source in this window. Over in this window, we can actually see what Gdb sees in the kernel. And we've actually just executed this swap instruction, and I swap a 0 with Scratch in order to see what it did. Let's print out E 0. E 0 is now this three Fff E 0 0 0 value, which is a pointer, which is the virtual address of the trap frame, which used to be an S scratched, but we just swapped it, and then we can print out what's in S scratch, and it's two, which is the old value of the A 0 register. Of course, a 0 held the first argument to the right function, which is file descriptor two, which is what the shop pass, so we've saved away 0, and we have a pointer to the trap frame, and it turns out now that we're well on our way to be able to save the registers. 
正如你所看到的，如果我查看蹦床代码。或者就在蹦床代码的开头，它做的第一件事就是这个csrw指令。这是此窗口中的源。在这个窗口中，我们可以看到Gdb在内核中看到的内容。我们实际上刚刚执行了这个交换指令，我用Scratch交换了一个0，以便查看它做了什么。让我们打印出E 0。E 0现在是这三个Fff E 0 0值，它是一个指针，是陷阱帧的虚拟地址，它曾经是一个划痕，但我们只是交换了它，然后我们可以打印出S划痕中的内容，它是两个，这是一个0寄存器的旧值。当然，0将第一个参数保存到正确的函数，即文件描述符2，这是商店传递的，因此我们已经保存了0，并且我们有一个指向陷阱框架的指针，现在事实证明，我们正在努力保存寄存器。



发言人   42:04
In fact, that's what the very next 30 odd instructions do in this trampoline code. Just systematically use these SD instructions. These are just save 64 b save store instructions to store every single register to a different offset in the trap frame. A 0, if you'll recall now contains, after the swap, contains a pointer to the trap frame that is contains the virtual address of this page. And we're just storing each registered a different offset in the track frame. All these stores are a bit boring, so I think I'm going to skip over them. And let me set a brake print a little farther on. 
事实上，这就是这个蹦床代码中接下来的30条奇怪指令所做的事情。系统地使用这些SD卡说明。这些只是save 64 b保存存储指令，用于将每个寄存器存储到陷阱帧中的不同偏移量。如果您记得，在交换之后，0包含一个指向陷阱帧的指针，该帧包含此页的虚拟地址。我们只是在跟踪帧中存储每个注册的不同偏移量。所有这些商店都有点无聊，所以我想跳过它们。让我把刹车印得更远一点。


发言人   42:56
Question Yes. How did the address of the trap frame end up in a scratch when we swapped it with a 0? Okay, before the kernel, before it previously transitioned to user space, set s scratch to be equal to 3 fffff fffff E 0 0 0, the virtual address of the trap frame. So all the time when we were executing a user space in the shell, that scratch had this pointer to the crap frame, and then the shell executes. Eco, which jumps to the beginning of the trampoline and the very first instruction of the trampoline, is a CSR W instruction which swaps a 0 in the scratch. And so now the old value of the scratch, namely the point of the trap frame, is now in a 0. 
问题是。当我们用0交换时，陷阱帧的地址是如何划伤的？好的，在内核之前，在它之前转换到用户空间之前，将s scratch设置为等于3 fffff fff E 0 0，即陷阱帧的虚拟地址。因此，当我们在shell中执行用户空间时，scratch的指针一直指向垃圾帧，然后shell执行。Eco，跳转到蹦床的开头和蹦床的第一个指令，是一个csrw指令，在刮痕中交换0。因此，现在划痕的旧值，即陷阱帧的点，现在处于0。


发言人   43:50
Does that answer your question? I guess I'm wondering where in the look at does this happen during the allocation of the process? 
这回答了你的问题吗？我想知道在分配过程中这种情况发生在哪里？

发言人   44:00
Like where does the scratch register live? Where does this? Well, the scratch register itself lives on the CPU. It's a special register in the CPU where and the kernel sets it, well, it's a little bit involved the actual place where it's set, but I'm now showing you on the right here the code that the last two instructions that the kernel executes while returning a user space. 
比如，暂存寄存器在哪里？这在哪里？暂存寄存器本身位于CPU上。它是CPU中的一个特殊寄存器，内核进行设置，嗯，它稍微涉及到设置的实际位置，但是我现在在这里向您展示内核在返回用户空间时执行的最后两条指令的代码。


发言人   44:30
And what's happening is that the very last thing it does after the kernel restores all the user registers and is just about ready to return to user space, it actually does another one of these swaps. The kernel is set up a 0 to be equal to the trap frame. That scratch still holds the saved user a 0. So the kernel does this swap, which ends up with that scratch having a pointer, that trap frame, and a 0 having the saved user a 0, and then this SRE returns to user space. So you may wonder how a 0 ever got to have the value of the address of the trap frame? 
正在发生的事情是，在内核恢复所有用户寄存器并准备返回用户空间后，它实际上会进行另一种交换。内核被设置为0以等于陷阱帧。划痕仍然保持保存的用户为0。所以内核进行了这个交换，最终会有一个指针，那个陷阱帧，以及一个0，保存的用户为0，然后这个SRE返回到用户空间。所以你可能想知道0是怎么得到陷阱帧地址的值的？

发言人   45:08
Answer to that question is that? 
这个问题的答案是什么？

发言人   45:13
We're now looking in trap DOC. At this last C function to run on the way out to user space. And the last thing the C function does is calls this function here, whatever this fn is, and the arguments it passes are the trap frame and the user page table. And so in C code, when you call a function, the first argument goes in 0, a 0. And that's basically why a zero held the point of the trap frame. And this function, its value is set up here to be in that trampoline page. 
我们现在正在寻找陷阱文档。在这最后一个C函数中，在到达用户空间时运行。C函数做的最后一件事就是在这里调用这个函数，不管这个fn是什么，它传递的参数是陷阱框架和用户页表。所以在C代码中，当你调用一个函数时，第一个参数为0，a 0。这基本上就是为什么一个零保持陷阱框架的点。这个函数的值被设置在这个蹦床页面中。


发言人   45:54
Towards the end, that code I showed you. This code is that, is that a good answer? Yes, thanks, sorry, I also was confused about that. I was not sure when you start your process and it's good and running and then at some point it doesn't equal, I guess, something and then when did you call this return function? Because it should have been called before the call. But you didn't return from? You didn't return before, I don't know, I don't understand what you call the either travel red. 
最后，我给你看的代码。这段代码就是这样，这是一个好答案吗？是的，谢谢，抱歉，我也很困惑。我不确定你什么时候开始你的进程，它很好并且正在运行，然后在某个时候它不等于，我猜是什么，然后你什么时候调用了这个返回函数？因为它应该在调用之前调用。但是你没有回来？你之前没有回来，我不知道，我不明白你所说的 “红色旅行”。


发言人   46:39
Okay, maybe one answer to this question is that the kernel always or the machine boots up in the kernel, so when the machine starts, it's in the kernel anytime. The only way to get into user space, you know, the very first time or when returning from a system call is in fact, to execute this S red instruction, that this S instruction is the way that the risk find 5 defines to transition from supervisor mode into user mode. And so before any user code ever executes, the kernel executes the code I'm showing you here in these two editor buffers that set up all kinds of things like St scratch and st Vac. 
好的，也许这个问题的一个答案是内核或机器总是在内核中启动，所以当机器启动时，它随时都在内核中。进入用户空间的唯一方法，你知道，第一次或者从系统调用返回时，实际上是执行这个红色指令，这个指令是风险发现5定义的从主管模式转换到用户模式的方式。因此，在执行任何用户代码之前，内核会执行我在这两个编辑器缓冲区中展示的代码，这些缓冲区设置了各种功能，例如St scratch和st Vac。

发言人   47:33
Okay, I see, thank you, Welcome, I have a question. I'm not sure if we touched on this or claim again, I missed it, but when we called the E instruction in the assembly code, what triggers the trampoline code to start? Like, is it the switch of the CPU mode from supervisor? I'm sorry, from user to supervisor is something else. Okay, so the code we're executing is this E call. The shell executes it in user space, and E call does a couple things. The E call instruction sets the mode to supervisor, and the eeco instruction saves the program counter and EPC, and the E instruction sets the program counter equal to the control register called stvep. 
好的，我明白了，谢谢，欢迎，我有一个问题。我不确定我们是否触及了这个问题或再次声称，我错过了，但是当我们在汇编代码中调用E指令时，是什么触发蹦床代码启动？就像，它是supervisor CPU模式的开关吗？对不起，从用户到主管是另一回事。好的，我们正在执行的代码是这个E调用。shell在用户空间执行它，E call执行几件事情。E调用指令将模式设置为supervisor，eeco指令保存程序计数器和EPC，E指令将程序计数器设置为等于称为stvep的控制寄存器。

发言人   48:24
So, and svec is one of the many things which the kernel sets up before entering user space. And so here's St back stbc is just the kernel, set it to the beginning of the trampoline page. That is this address here. So that when E happens, e just copies svec into the program counter and continues. But now and the program counter is executing as this address in the trampoline page. That clarifies it. 
所以，svec是内核在进入用户空间之前设置的许多东西之一。所以这里的第一个后台stbc只是内核，将其设置为蹦床页面的开头。这是这里的地址。以便当E发生时，e只是将svec复制到程序计数器并继续。但是现在，程序计数器正在蹦床页面中执行此地址。这就澄清了。


发言人   48:55
Thank you, okay. I also have a question, why? So some of the registers are saved in the trap frame should. Are also registers that the user program had access to. Why did we need to. Use a new region in memory and not use the program stack. 
谢谢，好的。我也有一个问题，为什么？因此，一些寄存器保存在陷阱帧中。也是用户程序有权访问的寄存器。为什么我们需要。在内存中使用新区域，而不使用程序堆栈。


发言人   49:34
Okay, well, there's maybe two questions here. One is maybe why do we have to save the registers at all? The reason why the colonel has to save the registers is that the keel is about to run the C code, that it overwrites those registers. And if we ever want to resume the user code correctly, we need to resume it with its registers. I mean, their original values, you know, as of when the E call let's executed. So we have to save all the registers in the trap frame so that later on we can restore all of their values just before resuming the user code. 
好的，也许这里有两个问题。一个可能是为什么我们必须保存寄存器？上校必须保存寄存器的原因是龙骨将要运行C代码，它会覆盖这些寄存器。如果我们想要正确恢复用户代码，我们需要使用其寄存器恢复它。我的意思是，它们的原始值，你知道的，当E呼叫执行时。所以我们必须将所有寄存器保存在陷阱帧中，以便稍后我们可以在恢复用户代码之前恢复它们的所有值。

发言人   50:14
Maybe the other half of your question is, how come they're saved in the trap frame and not on the user stack? The answer to that is that we're not sure the user program even has a stack. There are certainly programming languages that don't have a stack, and the stack pointer doesn't point to anything in particular, might be have value 0. There's also programming languages that, yeah, they have a stack, but it's in like a format that's, you know, some weird format that the kernel doesn't understand. Maybe because the programming language allocates its stack in small blocks from the heap, and the programming language runtime understands how to use these small blocks of memory as a stack. 
也许你问题的另一半是，为什么它们被保存在陷阱框架中，而不是在用户堆栈中？答案是我们甚至不确定用户程序是否有堆栈。当然有一些编程语言没有堆栈，而且堆栈指针没有指向任何特定的东西，可能值为0。还有一些编程语言，它们有一个堆栈，但它的格式，你知道，有些奇怪的格式，内核无法理解。这可能是因为编程语言从堆中以小块分配堆栈，而编程语言运行时理解如何将这些小块内存用作堆栈。

发言人   50:54
You know, the kernel has no idea. So we, if we want to be able to run sort of arbitrary user programs written in lots of different languages, the kernel can't make any assumptions about what parts of user memory it's allowed exist or valid, or it's allowed to read, to write. And so the kernel has to be sort of self contained and saving and restoring the registers. That's why the kernel save the stuff in its own memory in the trap frame rather than in user memory. 
你知道，内核不知道。因此，如果我们希望能够运行用许多不同语言编写的任意用户程序，内核不能假设用户内存的哪些部分允许存在或有效，或者允许读取或写入。因此内核必须是自包含的，并保存和恢复寄存器。这就是为什么内核将这些东西保存在陷阱帧的自己的内存中而不是用户内存中。

发言人   51:24
Okay, makes sense. Okay, anything else? 
好的，让感知。好的，还有什么吗？

发言人   51:40
Okay, we're still right at the beginning of. The code in trampoline, this col, it is unfortunately, we refer to it both as user of Act and as the trampoline code. We barely started executing it. I think I just set a breakpoint in this code. After all the registers have been saved, I think I said a. Breakpoint of this instruction. So we'll continue executing. 
好的，我们还处在开始阶段。蹦床中的代码，不幸的是，我们将其称为行为用户和蹦床代码。我们几乎没有开始执行它。我想我只是在这段代码中设置了一个断点。在所有寄存器都保存好之后，我想我说的是a。此指令的断点。所以我们将继续执行。


发言人   52:13
Skip over all the saves of all the user registers, the trap frame. Okay, and now we're executing this load instruction. This load instruction is loading into the stack pointer register. And what is loading as the value is the eighth slot in the block of memory pointed to by a 0. We remember a zero points trap frame to this virtual dress, you know, the second to last page and the format of the trap page. But the trap frame, here's the form of the trap A, we've conveniently labeled each field with its offset in bytes, so that means they're loading the 8th starting at the eighth byte of the trap frame means we're loading the kernel stack pointer. And one of the things the kernel sets up before entering user space is that sets this slot in the trap frame to be equal to this process is kernel stack. So what this instruction here is doing is initializing the stack pointer to point to the top of this processes kernel stack as part of what you need to do in order to run user code. 
跳过所有用户寄存器的所有保存，即陷阱帧。好的，现在我们正在执行这个加载指令。这个加载指令正在加载到堆栈指针寄存器中。而正在加载的值是内存块中由0指向的第八个插槽。我们记得这件虚拟衣服的零点陷阱框架，你知道，倒数第二页和陷阱页面的格式。但是陷阱帧，这是陷阱A的形式，我们方便地标记了每个字段的字节偏移量，这意味着它们从陷阱帧的第八个字节开始加载第八个字段，意味着我们正在加载内核堆栈指针。内核在进入用户空间之前设置的一件事情是将陷阱帧中的这个插槽设置为等于该进程的内核堆栈。因此，这里的指令所做的是初始化堆栈指针以指向此进程的内核堆栈顶部，这是您需要执行的操作以运行用户代码的一部分。



发言人   53:26
All right, so what's left? Or within a few instructions of getting to the end of this trampoline code, we loaded the stack pointer. So maybe I can print the stack pointer for you, let's see. Yeah, this is. 
好的，那还剩下什么？或者在到达这个蹦床代码结尾的几个指令内，我们加载了堆栈指针。所以也许我可以为您打印堆栈指针，让我们看看。是的，这是。


发言人   53:48
All right, well, this is the kernels. This process is kernel stack. It's up in high memory because XV 6. Treats kernel SS special so that it can put a guard page under each kernel stack. 
好的，这就是内核。这个进程是内核堆栈。它在高内存中，因为XV 6。将内核SS视为特殊的，以便它可以在每个内核堆栈下放置一个保护页。

发言人   54:04
Okay, so this load into TP, it turns out that because there's no direct way in risk 5 to figure out what core, which of them multiple cores you're running on XV 6 actually keeps the core number called the heart ID in the TP register. And this is used in a bunch of places in the kernel. For example, it's part of the machinery for kernel code to figure out what process is currently running on that core. Okay, and if we execute this, hopefully. TP or running on core 0. And that makes sense because I've configured qmu to only give one core the XV 6. So we are indeed running on core 0. 
好的，所以这个加载到TP中，结果表明，因为风险5中没有直接的方法来确定您在XV 6上运行的哪个核心 (其中哪些是多个核心) 实际上在TP寄存器中保留了称为心脏账号的核心编号。这在内核的很多地方都在使用。例如，它是内核代码机器的一部分，用于找出当前在该核心上运行的进程。好的，如果我们执行这个，希望如此。TP或在核心0上运行。这很感知，因为我已经将qmu配置为只给一个内核XV 6。所以我们确实在核心0上运行。

发言人   54:53
This next thing is loading the address of. Well, actually, the load entity 0. I think loaded a pointer to the first C function that we're going to execute, which is user traps. So we'll use that in a few instructions. Just jump to the user trap C function. 
接下来是加载地址。实际上，荷载实体为0。我认为加载了一个指针，指向我们要执行的第一个C函数，即用户陷阱。所以我们将在一些说明中使用它。只需跳转到用户陷阱C函数。

发言人   55:21
This load into T 1 here is loading the address of the kernel page table we can print. So we're about to switch page tables. Turns out this thing in T 1 is not actually literally the address of the kernel page table. It's the thing you need to put into satp, which is has the address of the cardinal page table, but shifted around with some extra flag bits set. But as soon as the CSR W instruction executes, we'll switch page tables from the user page table to the kernel page table. And let me just reinforce that by looking at the current page table. 
这个加载到t1这里是加载我们可以打印的内核页表的地址。所以我们即将切换页表。事实证明，T 1中的这个东西实际上并不是内核页表的地址。这是你需要放入satp的东西，它有基本页表的地址，但在设置了一些额外的标志位后移动了位置。但是一旦csrw指令执行，我们就会将页表从用户页表切换到内核页表。让我通过查看当前页表来加强这一点。


发言人   55:57
Right now, we're still executing with this very small user page table going to run step by to execute the load into Sat P? And we'll look again at the kernel page. But now we're in a completely different page table, right? This is the kernel page table. And you can see all these different regions of memory and device control registers and whatnot that the kernel sets up in its own big kernel, page 2. So we successfully switched page tables and now to the kernel page tables. And so we're like in pretty good shape at this point because we have a stack, we have the kernel page table, we can read my kernel data. 
现在，我们仍在使用这个非常小的用户页表执行，逐步运行以执行对Sat P的加载？我们将再次查看内核页面。但是现在我们处于一个完全不同的页表中，对吗？这是内核页面表。并且您可以看到所有这些不同的内存和设备控制寄存器区域，以及内核在其自己的大内核中设置的诸如此类的内容，第2页。所以我们成功地切换了页表，现在切换到了内核页表。因此，目前我们的状态相当不错，因为我们有一个堆栈，有内核页表，可以读取我的内核数据。


发言人   56:37
We really pretty much ready to execute C code in the kernel. One puzzle, though, is how come we didn't just crash? After all, we were executing somewhere in memory, and the program counter holds a virtual address. If we switch page tables, why doesn't that just cause some random garbage or nothing at all to be mapped in the new page table underfoot where we were executing and we're not crashing or actually executing these instructions? 
我们实际上已经准备好了在内核中执行C代码。然而，一个难题是，我们为什么不只是崩溃？毕竟，我们是在内存中的某个地方执行的，而程序计数器保存着一个虚拟地址。如果我们切换页表，为什么这不会导致一些随机的垃圾或任何东西被映射到我们正在执行的新页表中，而我们没有崩溃或实际执行这些指令？

发言人   57:09
Any guesses what's going on? I think because, oh, sorry, because we're still in the trampoline code and the trampoline is mapped the same virtual address both in user and kernel. That's absolutely correct. And so you, I don't know if you remember what was mapped here in the user page table, but this mapping here at the end of the kernel page table is exactly the same mapping in the same place as the trampoline mapping at the end of the user page table. All the other mappings are different, but this mapping is the same. This is the mapping that holds the instructions we were executing. And because it didn't change when we switched page tables, we can actually continue executing and we're still executing the same sequence of instructions and not crashing. 
有没有人猜测发生了什么？我这么想是因为，哦，对不起，因为我们还在蹦床代码中，蹦床在用户和内核中都映射到了相同的虚拟地址。这是完全正确的。所以你，我不知道你是否还记得在用户页面表中映射了什么，但是这个在内核页面表末尾的映射与用户页面表末尾的蹦床映射在同一位置完全相同。所有其他映射都不同，但此映射是相同的。这是保存我们正在执行的指令的映射。而且因为当我们切换页表时它没有改变，所以我们实际上可以继续执行，并且我们仍在执行相同的指令序列而不会崩溃。

发言人   58:00
And so that's the sort of special thing about the trampoline page. It's mapped both into user page tables and into the kernel page table. And the reason it's called a trampoline pages, because you sort of bounce on it on the way from user space to kernel space. And with the annex instruction in this Jr, we're about to bounce right out of the trampoline into kernel C code and to see where we're going. 
这就是蹦床页面的特殊之处。它被映射到用户页表和内核页表中。它之所以被称为蹦床页面，是因为在从用户空间到内核空间的途中，你会在上面弹跳。在这个Jr中的附件指令下，我们即将跳出蹦床，进入内核C代码，看看我们要去哪里。

发言人   58:29
Jr is just like jump to a subroutine. The subroutine is pointed to by register T 0, print T 0 to see where we're going. Maybe we will print some instructions there. Okay, so these are the instructions. We're about to jump to the beginning of the function called User Trapp. User Trapp is just AC function define in trap DOC. 
Jr就像跳转到子程序一样。子程序由寄存器T 0指向，打印T 0查看我们的去向。也许我们会在那里打印一些说明。好的，这些是指示。我们将要跳到名为用户Trapp的函数的开头。用户traapp只是陷阱文档中定义的交流函数。

发言人   59:01
Here's user trap we are about. We're about to jump from assembly code to user trap with a stack with a kernel page table. Let me actually do the execute the instruction. And now I'm going to turn on. Turn on displaying of C code and GDP now that we're executing C code. Okay, so now we're in a much more sane world. We're just executing C code should be a little bit easier to understand. And there's you. We'll still spend some time reading and writing various interesting control registers. 
这是我们要讨论的用户陷阱。我们将要使用一个带有内核页表的堆栈从汇编代码跳转到用户陷阱。让我实际执行指令。现在我要打开了。打开C代码的显示并国内生产总值（GDP） 现在我们正在执行C代码。好的，现在我们处于一个更加理智的世界。我们只是在执行C代码，应该会更容易理解一些。还有你。我们仍然会花一些时间读写各种有趣的控制寄存器。



发言人   59:37
The environment is hopefully a good deal less mysterious than it was in the track frame, all right? Or any, any questions at this point? 
希望环境比履带架少得多神秘，好吗？或者在这一点上有什么问题吗？

发言人   59:54
I have a question, why didn't we see with the Gdb what equals? Maybe I missed it, but I think we jumped directly into the trampoline. E E did jump. What ECA does is just changes the mode bit to be supervisor and E sets the program counter register to be equal to the whatever happens, whatever the kernel happened to store in St Vac, kernel stored this value that I just printed 3D Fff 0 0 0, which is the beginning of the trampoline page. The kernel stores this number in St Vac before entering user space. So where e call goes, that is where it says the program counter to St vac, which is the beginning of the trampoline page. Does that answer your question? Yes I think so. 
我有一个问题，为什么我们没有看到Gdb等同于什么？也许我错过了，但我想我们直接跳上了蹦床。E确实跳了。ECA所做的只是将模式位更改为监督者，并将程序计数器寄存器设置为等于无论发生什么，无论内核如何存储在St Vac中，内核存储了我刚刚打印的3D Fff 0的值，这是蹦床页面的开始。在进入用户空间之前，内核将此编号存储在St Vac中。所以电子电话去的地方，就是它告诉St vac程序计数器，这是蹦床页面的开始。这回答了你的问题吗？是的，我想是的。

发言人   01:01:08
Okay, so now we're in. 
好的，现在我们进去了。

发言人   01:01:10
User trap is entered actually just like the trampoline page. Just like the trampoline page for a number of different kinds of traps. There's system calls. There's exceptions like dividing by zero or using an unmapped virtual address, and there's a device interrupts, and they all come here. And so user trap sort of saves and restores hardware state, but it also needs to look at the state, at the cause of the trap to figure out what to do with it. And so we're going to see both things as we execute along in user trap. 
用户陷阱实际上就像蹦床页面一样进入。就像蹦床页面一样，有许多不同种类的陷阱。有系统调用。有例外，比如除以零或使用未映射的虚拟地址，还有设备中断，它们都在这里。用户陷阱可以保存和恢复硬件状态，但它也需要查看状态，找出陷阱的原因，找出如何处理它。因此，当我们在用户陷阱中执行时，我们将看到这两件事情。

发言人   01:01:46
Let me just. Run stuff in user Trapp. Let's see, the first thing it does here is that it changes that stbc register. It turns out that the way XV 6 handles traps is different depending on whether they come from user space or from the kernel. 
让我来。在用户traapp中运行内容。让我们看看，它在这里做的第一件事是它更改了stbc寄存器。事实证明，XV 6处理陷阱的方式是不同的，这取决于它们是来自用户空间还是来自内核。

发言人   01:02:06
We've only been talking about what happens if a trap occurs from user space. There's a quite different sequence of events for traps that come from the kernel that occur while in the kernel. Because after all, for example, the kernel, so already using the kernel page table, you know, if a trap occurs while you're in the kernel, you already have the kernel page tables. There's a whole bunch of stuff that doesn't have to happen if the trap occurred while in the kernel. So before getting much further in the kernel code, we change Std vac to point to this kernel vac, which is the kernel trap handler rather than the user trap handler. 
我们只是在谈论如果用户空间发生陷阱会发生什么。对于来自内核的陷阱，在内核中发生的事件序列是完全不同的。因为毕竟，例如内核，已经使用内核页表了，你知道，如果在内核中发生陷阱，你已经有了内核页表。如果在内核中发生陷阱，那么有很多事情是不必发生的。因此，在深入研究内核代码之前，我们将Std vac更改为指向此内核vac，这是内核陷阱处理程序，而不是用户陷阱处理程序。

发言人   01:02:44
We need to, for various reasons, we need to figure out what process we're running. We do that by calling this my proc function. And my proc actually looks at an array indexed by the current core number, the cart ID, which you remember we put in TP. That's how my product figures out what process is currently running. 
由于各种原因，我们需要弄清楚我们正在运行的过程。我们通过调用我的proc函数来做到这一点。我的proc实际上查看由当前核心编号 (购物车账号) 索引的数组，你记得我们把它放在了TP中。这就是我的产品如何计算当前正在运行的过程。

发言人   01:03:07
We need to save that saved user program counter. It's still sitting there in sepc, but because one of the things that could happen while we're in the kernel is that we might switch to another process, and that other process might go into that process is user space. And that other process might make a system call which causes scpc to be overwritten. We have to save our scpc in some memory associated with this process so it doesn't get overwritten. And it gets, you know, we use this trap frame to save EPC as well as lots of other stuff. And anyway, that's what this current line of code is doing. 
我们需要保存保存的用户程序计数器。它仍然在sepc中，但因为我们在内核中时可能发生的事情之一是我们可能会切换到另一个进程，而另一个进程可能会进入该进程的用户空间。并且另一个进程可能会进行系统调用，导致scpc被覆盖。我们必须将我们的scpc保存在与此进程相关的一些内存中，以便它不会被覆盖。它得到了，你知道，我们使用这个陷阱框架来节省EPC以及许多其他东西。无论如何，这就是当前这行代码正在做的事情。

发言人   01:03:49
The next thing that happens we need to figure out. Why we came here? The S cause the risk 5 S cause register has a different number depending on why this trap occurred. You know, some kind of exception versus system call versus device interrupt value 8 means we're here. We took a trap because of a system call and hopefully indeed this calls us 8. It does have 8 because we're here because of the A system call. So we're going to execute if statement. 
接下来发生的事情我们需要弄清楚。我们为什么来这里？风险原因寄存器的编号因此而异，具体取决于此陷阱发生的原因。你知道，某种异常与系统调用与设备中断值8意味着我们在这里。由于系统调用，我们陷入了一个陷阱，希望这确实调用了我们8。它确实有8，因为我们在这里是因为系统调用。所以我们将执行if语句。

发言人   01:04:25
First thing is if some other process is killed, this process, we don't want to continue. But that's not the case for our shell. It turns out that the Risk 5, the program counter that gets stored in sepc is the address of the instruction that caused the trap. But when we resume, we want to resume at the next instruction after the e call. And so therefore, we this code for system calls, which need to return, we add 4 to the saved user program counter so that we resume on the next instruction and don't just re execute the equal call. All right, next, turns out that XV 6 enables interrupts while it's handling system calls, just so that interrupts can be served faster. Some system calls take at a time. Interrupts are always turned off by the risk 5 trap hardware, and so we have to explicitly turn it back on at this point. 
首先，如果某个其他进程被杀死，我们不想继续这个进程。但我们的shell并非如此。事实证明，风险5，存储在sepc中的程序计数器是导致陷阱的指令的地址。但是当我们恢复时，我们希望在e呼叫后的下一个指令恢复。因此，我们将此代码用于系统调用，需要返回，我们将4添加到保存的用户程序计数器中，以便我们继续执行下一条指令，而不仅仅是重新执行相等的调用。好的，接下来，事实证明，XV 6在处理系统调行时启用了中断，这样中断可以更快地得到服务。一些系统调用一次执行。中断总是由风险5陷阱硬件关闭，因此我们必须在这一点上显式地重新打开它。

发言人   01:05:30
And the next thing that happens is we call the syscall function. 
接下来发生的事情是我们调用syscall函数。

发言人   01:05:34
And the job of syscall. I'll just enter it. It's defined in just call that C, here we are. What it does is it looks up the system call number in this big table of system calls at the top of the page. If you remember the shells right function set, register a 7 to be the system call number, namely 16 for right. So what syscall is it retrieves the saved a seven that was saved way in the trap theme by the trampoline code. And it uses that to index into this table of pointers to functions that implement each system call. So we're going to fish this number. 
以及系统调用的工作。我就进去。它定义在这里，只需调用C。它所做的是在页面顶部的系统调用大表中查找系统调用号码。如果你还记得shell右边的函数集，请注册一个7作为系统调用号码，即16代表右边。那么syscall是什么呢？它检索被蹦床代码保存在陷阱主题中的七个。并使用它来索引到这个指针表中，这些指针指向实现每个系统调用的函数。所以我们要钓鱼这个数字。


发言人   01:06:21
I'm going to print num. Now it's the save a 7 and d, that's 16, the same 16 that the shell originally put there. The system call code indexes into the syscalls table. We can find out what function I got out of the system called table by stepping into it. 
我要打印num。现在是保存a 7和d，即16，与外壳最初放在那里的16相同。系统调用代码索引到syscalls表中。我们可以通过进入这个叫做table的系统来找出我从其中得到了什么函数。

发言人   01:06:43
Right now we're in, right, we're in sysrq. In sy file-level? Sysrq is the kernel implementation of the right system call. I'm not going to go into this complicated. What happens from here on in and the implementation of the system call for this electron. I'm only really interested in getting into and out of the kernel, so I'm going to. Step over. 
现在我们在，对，我们在sysrq。在sy文件级别？Sysrq是正确系统调用的内核实现。我不打算深入探讨这个复杂的问题。从这里开始，系统调用这个电子的实施会发生什么。我只对进入和离开内核感兴趣，所以我要去。一步过去。


发言人   01:07:26
The actual implementation of system call One thing an interesting thing to note is that the system calls need to find their arguments. So, you know, remember the arguments to write or 2 and a buffer pointer and another 2. And the way that the system called code gets at them is just looking at these. Well, looking in the trap frame. So just like we could look in the trap frame for a 7, we could look for a 0. And that's the first argument. We could look at a one, that's that buffer point. Or we can look at a two, that's the second argument, the number of. Bytes to write. Okay, so the system called does this job, and then sys write finally returns. 
系统调用的实际实现需要注意的一件有趣的事情是，系统调用需要找到它们的参数。所以，你知道，记住write或2的参数，以及一个缓冲区指针和另一个2。而被称为代码的系统获取它们的方式就是看这些。好的，在陷阱框架中寻找。因此，就像我们可以在陷阱框架中查找7一样，我们也可以查找0。这是第一个论点。我们可以看一个，那就是缓冲点。或者我们可以看一个2，这是第二个参数，数量。要写入的字节。好的，所以调用的系统完成了这项工作，然后sys write最终返回。

发言人   01:08:13
And we're going to watch what happens. The reason for this assignment here, the reason why we're assigning to E 0 in the trap frame is that this system calls all have a return value, like right returns, the number of bytes written and the convention for C code on the risk 5 is that return values are placed in register A 0 by whatever function you're calling. And so to simulate a return value, we just stick the return value in a 0 in the trap frame and we'll see by and by that when we return to user space is this a 0 slot in the trap frame is restored back into the actual zero register, and the shell sees that a zero value as m? As the return value from right? And if we execute through this and print P arrow trap frame that way zero, we'll see it has value 2. What that means is that write return value is two, saying that it actually wrote 2 B just as instructed. 
我们将观察会发生什么。这里分配的原因，我们在陷阱框架中分配给E 0的原因是这个系统调用都有一个返回值，就像正确的返回一样，写入的字节数和风险为5的C代码的约定是返回值由您调用的任何函数放置在寄存器0中。因此，为了模拟返回值，我们只需将返回值粘贴在陷阱帧中的0中，然后当我们返回用户空间时，陷阱帧中的0插槽会恢复到实际的零寄存器中。而shell看到零值为m？作为对的返回值？如果我们执行这个并以零的方式打印P箭头陷阱帧，我们将看到它的值为2。这意味着写返回值是2，说它实际上按照指示写了2 B。


发言人   01:09:14
Okay, at this point, we're back in. Trap DOC and User Trapp just after the call to sys calls are now at this PR. We're checking if the if the process has been killed because we don't want to resume executing if it's already been killed. But of course, our shell has not been killed. Skip over this. And then user Trapp calls a separate function user trap Re in order to set up all the stuff that I talked about previously Whenever I said, well, before entering user space, the kernel does blah, blah, blah. It's user trap red that's responsible for setting all that stuff up. And so we can look at all the different things it does. 
好的，在这一点上，我们又回来了。Trap DOC和用户Trapp刚刚调用sys调用之后，现在就在这个PR上。我们正在检查进程是否已被杀死，因为我们不想在它已经被杀死的情况下继续执行。但是，当然，我们的炮弹还没有被杀死。跳过这个。然后用户trap调用一个单独的函数user trap Re，以便设置我之前谈到的所有内容，无论何时我说，在进入用户空间之前，内核都会做一些诸如此类的事情。它是负责设置所有这些东西的用户陷阱红色。这样我们就可以看到它所做的所有不同的事情。



发言人   01:10:11
It turns interrupts off. They were turned on for the duration of a system call. They're turned off now because we're about to change the St VC to point to the user trap handler. Whereas while we were in the kernel, it was pointing to the kernel trap handler. So we turn off into us because once we're changed asvestochori user trap handler, we're still executing in the kernel. And if an interrupt should occur, then it would go to the user trap handler, even though we're executing in the kernel. And for various detailed reasons that would cause the kernel to malfunction. So we turn off interrupts, and they're off from between the time, from the very next line where we set up the svec to point to the trampoline all the way through the final S red instruction that returns the U, it turns out that S red instruction at the end of the trampoline turns interrupts back on. 
它关闭了中断。它们在系统调用期间被打开。它们现在已关闭，因为我们将要更改St VC以指向用户陷阱处理程序。而当我们在内核中时，它指向内核陷阱处理程序。所以我们关闭为我们，因为一旦我们更改了asvestochori用户陷阱处理程序，我们仍然在内核中执行。如果发生中断，即使我们在内核中执行，它也会进入用户陷阱处理程序。并且由于各种可能导致内核故障的详细原因。所以我们关闭中断，中断从我们设置svec的下一行指向蹦床，一直到返回U的fins红色指令，从这段时间开始关闭，原来在蹦床末端的红色指令会重新打开中断。

发言人   01:11:07
So the interrupts are on when we're executing in user code, even though we just turn them off the next couple of lines fill in those trap frame slots that we saw before that hold various values that are convenient for the trampoline code. 
所以当我们在用户代码中执行时，中断是开启的，即使我们只是关闭它们，在接下来的几行中填充我们之前看到的那些包含各种值的陷阱帧插槽，这些值对于蹦床代码来说很方便。

发言人   01:11:23
So the code here stashes away a pointer to the kernel page table in the trap frame. It stashes away to a pointer to this process's kernel stack, stashes away in the trap frame. A pointer to the user trap function, which is what the trampoline code jumped to at the very end, and it staes away the current core number read from the TP register so that the trampoline code can just restore that same value because user code may have disturbed it. 
所以这里的代码将指向内核页表的指针存储在陷阱帧中。它存储在指向此进程内核堆栈的指针，存储在陷阱帧中。指向用户陷阱函数的指针，蹦床代码在最后跳到了该函数，它会将当前从TP寄存器中读取的核心号存储掉，以便蹦床代码可以恢复相同的值，因为用户代码可能已经干扰了它。

发言人   01:12:01
Great question. Yes, why didn't we save the sepc in the trampoline? It could have? Yeah, I mean, the scpc could have been the trampoline code happens not to save it along with the other registers. We perfectly well could modify the XV 6 to save it. I mean, where it is actually saved, as you probably remember, is just happened to save it in user trap and C code instead of an assembly code in the trampoline code. I don't, I can't think of a good reason to do it one way or the other. 
好问题。是的，我们为什么不把sepc留在蹦床上呢？可能有？是的，我的意思是，scpc可能是蹦床代码碰巧没有将其与其他寄存器一起保存。我们完全可以修改XV 6来保存它。我的意思是，它实际上被保存的地方，正如你可能还记得的那样，只是碰巧将它保存在用户陷阱和C代码中，而不是在蹦床代码中的汇编代码。我不，我想不出一个好的理由去这样做或那样的方式。


发言人   01:12:40
The user registers really have to be saved in the assembly code because any C code is entitled to all. We know the compiler generates code which modifies any. User registers. Those user registers are pretty important to save them in assembly code before entering C that the EPC. We could have been saved earlier or later. 
用户注册确实必须保存在汇编代码中，因为任何C代码都有权使用所有内容。我们知道编译器生成修改任何内容的代码。用户注册。这些用户注册表非常重要，要在输入EPC之前将它们保存在汇编代码中。我们本可以更早或更晚被保存。

发言人   01:13:04
Okay, so we're using a trap re sort of preparing. We prepared the trap frame with all these values that are going to be needed next time there's a transition from user space to kernel. 
好的，我们正在使用陷阱来准备。我们准备了陷阱框架，其中包含了所有这些值，这些值下次从用户空间转换到内核时将需要。


发言人   01:13:16
Next trap. There's a couple things we have to set up in the S status control register. It turns out this Spp bit in S status controls controls the mode that SRE returns to. And by clearing it, we're just saying, well, look, next time we exude SRE, we want to go to user mode instead of supervisor mode. And this spii bit controls whether interrupts will be enabled after we execute SRE, after we get into user space. And we do want them to be enabled, we're going to set that sppi e bit, and then we're going to write this new modified S status into the actual hardware S status register. It turns out what s ret does? The SRE we're going to execute right at the end of the trampoline code. 
下一个陷阱。我们必须在状态控制寄存器中设置一些东西。事实证明，S状态控制中的这个Spp位控制着SRE返回到的模式。通过清除它，我们只是说，好吧，看，下次我们散发SRE时，我们想要进入用户模式而不是主管模式。并且这个spii位控制在我们执行SRE之后，进入用户空间之后是否启用中断。并且我们确实希望它们被启用，我们将设置该sppi e位，然后我们将此新修改的状态写入实际硬件的状态寄存器。原来s ret是做什么的？我们将在蹦床代码的末尾执行的SRE。

发言人   01:14:13
What that sretne is sets the program counter equal to the s.p.c. register. So we're now going to set up the sepc register to have the saved user program counter, which if you recall, we recently saved in the trap frame. That's what's happening here. 
那个sretne是将程序计数器设置为等于s.p.c。 注册。所以我们现在要设置sepc寄存器以保存用户程序计数器，如果你还记得的话，我们最近保存在陷阱帧中。这就是这里发生的事情。

发言人   01:14:34
If you remember also the trap frame contain a pointer to kernel page table because the trampoline needs to switch to it. We need to cook up the special little bit pattern that you need to write to satp. That's done here. And I'm sorry, we're now preparing a pointer to the user page table, which we need to switch to on the way into user space. We're actually going to do that switch in assembly code because it has to happen in the trampoline, because only code in the trampoline is mapped in both user and kernel space. So we can only really switch page tables when we're executing on the trampoline, but we're not executing on the trampoline yet. We're still just in an ordinary C function. So we prepare this pointer, and we're going to pass it to the assembly code as the second argument in A one. 
如果你还记得陷阱框架包含指向内核页表的指针，因为蹦床需要切换到它。我们需要烹饪你需要写入satp的特殊位模式。在这里完成了。抱歉，我们现在正在准备一个指向用户页表的指针，我们需要在进入用户空间的路上切换到它。我们实际上将在汇编代码中进行切换，因为它必须在蹦床中发生，因为只有蹦床中的代码在用户和内核空间中被映射。所以我们只能在蹦床上执行时真正切换页表，但我们还没有在蹦床上执行。我们仍然只是在一个普通的C函数中。所以我们准备这个指针，并将它作为一个中的第二个参数传递给程序集代码。

发言人   01:15:30
With this line here, doing is just calculating the address of where we want to jump to at the end of the trampoline code. And it turns out there's a that where we want to go with user. User writes the address, the instructions. That'll take us back to user space. And this little formula works out. The virtual address and the trampoline that corresponds to that user be function, Okay, so we calculate the address of that user at function. And then this mess, this next line call, uses this fn variable as a function pointer and jumps to that function with these two arguments in a 0 and a one, we can now just go to. 
这里有这一行，所做的只是计算我们想要跳转到的蹦床代码末尾的地址。事实证明，我们想要与用户一起去的地方。用户写下地址和说明。这将带我们回到用户空间。这个小公式就行了。虚拟地址和与该用户相对应的蹦床是函数，好的，所以我们在函数中计算该用户的地址。然后这个混乱，下一行调用，使用这个fn变量作为函数指针，跳转到这个函数，其中两个参数分别为0和1，我们现在可以转到。



发言人   01:16:28
Trampoline code. In the trampoline code there's. Well, first, we switch to the user page table. So we may actually execute this. And we can see the page tables change. Just for Chuckles, we're still using the giant kernel page table. I'm going to run through User Trap re quickly until we get to the point where it jumps to the trampoline. All right, we're in the trampoline. 
蹦床代码。蹦床代码中有。好的，首先，我们切换到用户页表。所以我们可以实际执行它。我们可以看到页表发生了变化。只是笑一下，我们仍在使用巨大的内核页表。我将快速浏览用户陷阱，直到我们到达它跳到蹦床的点。好的，我们现在在蹦床上。



发言人   01:17:07
These are the instructions or about to start executing the trampoline code. And right here, we can now, again, let's print the page table. It's still the kernel page table. The first thing that's going to happen here, though, is that the trampoline code is going to load that pointer to the user page table into the satp register. Now we switch page tables. If I type info map now, we now have a much smaller user page table, but luckily still with the trampoline page map, so we don't crash on the next instruction. The next thing that happens is this. 
这些是指令，或者即将开始执行蹦床代码。就在这里，我们现在可以再次打印页表。它仍然是内核页表。然而，在这里发生的第一件事是，蹦床代码将把指向用户页表的指针加载到satp寄存器中。现在我们切换页表。如果我现在输入信息地图，我们现在有了一个更小的用户页表，但幸运的是仍然使用蹦床页面地图，所以我们不会在下一个指令崩溃。接下来发生的事情就是这样。

发言人   01:17:49
I showed you a while ago that the second to last thing that this sequence of code does on the way to user space is swaps s scratch with a 0. So we need to set up a scratch with the saved user a 0, so that when we do that swap, a 0 will end up having a saved user. A 0 turns out a 0 is a pointer to the trap frame because the C code passes. That is the first argument, 112 of a 0 is the address of the saved a 0 in the trap frame. We're going to load that and then into t 0 and then load that into s scratch. 
我前一段时间向您展示了这段代码序列在进入用户空间的过程中所做的倒数第二件事是用0交换scratch。所以我们需要使用保存的用户设置一个0，这样当我们进行交换时，0最终会有一个保存的用户。结果是，0是指向陷阱帧的指针，因为C代码通过了。这是第一个参数，a 0的112是陷阱帧中保存的a 0的地址。我们将加载它，然后到t 0，然后加载到s中。

发言人   01:18:24
Now, at this point, we're still running with the kernel stuff and all the registers. The next 32 instructions though, load out of the trap frame, which a zero points to load all of the saved user registers out of the trap frame. Into the actual register. So we're like really close to being able to the point where we can run user code. I'm going to skip over all these loads. 
现在，在这一点上，我们仍在运行内核内容和所有的寄存器。接下来的32条指令从陷阱帧中加载，将所有已保存的用户寄存器从陷阱帧中加载为零。进入实际的登记册。所以我们真的接近能够运行用户代码的地步了。我要跳过所有这些负载。


发言人   01:18:56
Any questions before we approach closer to user space? I have one quick question. Is the value in the trap frame a 0? Now the return value of that system call that we made? 
在我们接近用户空间之前，有任何问题吗？我有一个快速的问题。陷阱帧中的值是0吗？现在，我们进行的系统调用的返回值是什么？

发言人   01:19:14
Yeah, the real laser holds just this under the trap frame. But the after we execute the well S, okay, the current location of the user saved. Yes, I was calling it the user saved a 0. But in fact, the system call return stuff overrode it with the return value that we want the shell to see in a 0. So the current location of that a zero, which we overwrote with two as the return value, is S scratch. I'm going to point S scratch and hope that it's equal to 2. It is equal to 2. That answer your question? Yes, I think so, okay. 
是的，真正的激光器只是在陷阱框架下保持这个。但是在我们执行井之后，好的，用户保存的当前位置。是的，我称其为用户保存了0。但实际上，系统调用return的东西覆盖了它，我们希望shell在0中看到的返回值。因此，我们用2作为返回值覆盖的零的当前位置是S scratch。我要划S点，希望它等于2。它等于2。这就回答了你的问题？是的，我想是的，好的。

发言人   01:19:59
I'm going skip over all these loads, the restore the saved user values out of the trap frame into the registers, and then I print out the registers at this point. Actually, kind of. Print out the registers. I don't know if these look familiar, but they happen to be the same set of user registers we saw way back at the beginning of this exercise. 
我将跳过所有这些加载，将保存的用户值从陷阱帧恢复到寄存器中，然后在此时打印出寄存器。实际上，有点。打印出寄存器。我不知道这些看起来是否很熟悉，但它们恰好是我们在本练习开始时看到的同一组用户寄存器。


发言人   01:20:24
For example, a one of the stack pointer holds this small value appropriate for a user stack load in memory. A 1 is that buffer pointer that we pass. The right 2 is that number of bytes. A 0, however, is the exception is not a saved user value because it still has the pointer to our trap frame in it. 
例如，堆栈指针中的一个保存了适合内存中用户堆栈加载的小值。1是我们传递的缓冲区指针。右边的2是那个字节数。然而，0是例外，不是已保存的用户值，因为它仍然包含指向我们的陷阱帧的指针。

发言人   01:20:49
But let's look what we're about to execute. What we're about to execute is this CSR RWA zero scratch right at the end of trampoline just before returning it to user space. 
但是让我们看看我们将要执行什么。我们即将执行的是这个CSR RWA零划痕，就在蹦床的末尾，然后将其返回到用户空间。


发言人   01:21:03
This is going to swap a 0 and scratch. Scratch indeed has. S scratch. Has two, which is going to be the return value. A 0 has this kernel pointer in it points to. Points to the trap frame, but after executing the CSR RW instruction to swap them, hopefully we'll see that a 0 holds this return value of 2 and a scratch holds a pointer to the trap frame, which is second to last page in memory. And that value is going to stay in a scratch until the user program does another crap. And at that point, the trap handling code that we talked about before, we will be able to use as scratch at the trap frame. 
这将交换一个0和划痕。Scratch确实有。S刮伤。有两个，这将是返回值。0中有这个内核指针指向。指向陷阱帧，但是在执行CSR RW指令交换它们之后，希望我们会看到0保存了这个返回值2，而划痕保存了一个指向陷阱帧的指针，这是内存中倒数第二个页面。这个价值将一直停留在原地，直到用户程序再做一次废话。到那时，我们之前谈到的陷阱处理代码将能够用作陷阱帧的划痕。


发言人   01:21:59
All right, we're and the kernel, but this is our last instruction in the kernel. And when I execute this sret, it will switch to user mode. Before I do that, let's look at. It'll switch the user mode. It'll copy sepc to the PC because we're still We're still executing with a PC that's in the trampoline, so sreet ISS going to switch to user mode, copy scpc to PC, and then we're zoo executing. So I'm going to going to run the SRE boom. 
好的，我们和内核在一起，但这是我们在内核中的最后一条指令。当我执行这个sret时，它将切换到用户模式。在我这样做之前，让我们来看看。它将切换用户模式。它会将sepc复制到PC，因为我们仍在使用蹦床中的PC执行，因此sreet ISS将切换到用户模式，将scpc复制到PC，然后我们正在执行。所以我要运行SRE boom。

发言人   01:22:45
Now we're back at packet address 0x DEA, which is a low address likely to be user memory. And it's the look back at Sh, do ASM and address Xerox DEA. Is indeed the address of the return function at the end of right and? A 0 is this return value that was supposed to be turning. So we're back in user space and we can about to do the return back to the shell from the rate system call and the right library function that made the system call. 
现在我们回到了数据包地址0x DEA，这是一个低地址，可能是用户内存。这是回顾Sh，do ASM和address施乐DEA。返回函数的地址确实在右侧的末尾吗？A 0是应该转动的返回值。所以我们回到了用户空间，我们可以从速率系统调用和进行系统调用的正确库函数返回到shell。


发言人   01:23:25
Okay, any questions? Sorry, can you repeat again what happened with the interrupt during S Red? What happened with interrupts? You said we are turning them off, but then something else turns them back on sreet? Sreet enables interrupts, So this sret, the very last instruction that we're executing in supervisor mode in the kernel. I forgot to say that just now, but as well as setting the program count equal to the scpc and social user mode, s red is going to re-enable interrupts that mean, you know, that's, you know, user programs that may run for a long time. It be nice to be able to take disk interrupts or whatever. Wow, user programs are running. I see, thank you. Other questions? 
好的，有问题吗？抱歉，你能再重复一遍S红色期间的中断情况吗？中断发生了什么？你说我们要关掉它们，但后来有别的东西把它们重新打开了？Sreet启用中断，因此这个sret是我们在内核的主管模式下执行的最后一条指令。我刚才忘了说，但是除了将程序计数设置为等于scpc和社交用户模式之外，红色还将重新启用中断，这意味着，你知道，用户程序可能会运行很长时间。能够处理磁盘中断或其他事情会很好。哇，用户程序正在运行。我明白了，谢谢。其他问题？

发言人   01:24:28
To wrap up, the system calls sort of look like function calls that are kind of meant to be thought of a lot like function calls. The user kernel transitions are much more complex than function calls are. A lot of the complexity is due to the requirement for isolation. The kernel just can't trust anything in user space. And also the desire to have simple and very fast hardware mechanisms. Really Xb 6 doesn't care that much about performance. But in general, operating system designers and the CPU designers are very interested in the sort of speed at which you can do efficiency of traps. 
总结一下，系统调用看起来有点像函数调用，而这些函数调用被认为很像函数调用。用户内核转换比函数调用复杂得多。许多复杂性归因于隔离需求。内核不能信任用户空间中的任何东西。并且希望拥有简单和非常快速的硬件机制。实际上，Xb 6并不太关心性能。但总的来说，操作系统设计师和CPU设计师对陷阱的效率和速度非常感兴趣。

发言人   01:25:08
XV 6 does does all these things in a particular way. There's certainly many other ways to do them. A few questions, a few design questions, alternatives you could think about. One is, can you think of ways to make the hardware or software aspects redesign XV 6, redesign the W 5 to make this whole sequence simpler? Or could you think of ways to make the whole sequence faster? And another sort of set of questions to keep in the back of your head is whether or not malicious programs could abuse any of these mechanisms to break isolation. 
XV 6以特定的方式完成所有这些事情。当然有很多其他的方法可以做到。一些问题，一些设计问题，你可以考虑的替代方案。一个是，你能想出一些方法来让硬件或软件方面重新设计XV 6，重新设计W 5使整个序列更简单吗？或者你能想出让整个序列更快的方法吗？还有一组需要记住的问题是，恶意程序是否可以滥用这些机制来打破隔离。

发言人   01:25:48
All right, that is all I have to say for this lecture. I'm happy to take questions, though. Sorry, I have another question. I saw that there is U i.e. register, or yeah, I think register ins status, but we don't use it, we just use S, ie, and we set it to false in user space. Why couldn't we use UI? UI? Gosh, the answer is going to be, I don't know. 
好的，这就是我这次讲座要说的全部内容。不过我很乐意回答问题。抱歉，我还有一个问题。我看到了你的存在。register，或者我认为是register ins status，但我们不使用它，我们只使用S，即，我们在用户空间中将其设置为false。为什么我们不能使用UI？是你吗？天哪，答案将是，我不知道。



发言人   01:26:24
We what we said is what we said is SPI. We may actually end up saying, I know nothing about u, i.e. I'm going to guess. Let me see. I'm going to guess that what actually happens here in this code where we're? Okay, so here we are in user trap. We're returning, we're setting SPIE in the S status, and I believe the S ret instruction will copy this Sp, ie this is the name of the supervisor, previous interrupt enable, I suspect S copies that bit into the. Into whatever controls interrupts in user mode, which is possibly this UAE and S status, How that? For a guess? I see, thank you. 
我们所说的就是我们所说的SPI。我们可能最终会说，我对你一无所知。我会去猜。让我看看。我将猜测这段代码中实际上发生了什么？好的，所以我们在用户陷阱中。我们正在返回，我们正在将间谍设置为S状态，我相信S ret指令会复制此Sp，即这是主管的名称，先前的中断启用，我怀疑S将该位复制到。进入用户模式中断的任何控件，这可能是这个UAE和S状态，这是怎么回事？为了猜测？我明白了，谢谢。

