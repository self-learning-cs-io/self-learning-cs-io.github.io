---
title: 操作系统工程 011-QA2 COW lab
date: 2025-10-18 10:00:11
---


发言人   00:11
All right, good morning or good afternoon everyone. Cand like get started, can, can people hear me? Yep, thank you. 
好的，大家早上好或下午好。像开始一样，人们能听到我吗？是的，谢谢。

发言人   00:22
All right, today what I'd like to do is give you a chance to ask questions about XV 6 and about the recent labs, and in order to kind of give us something to talk about I'm going to do as much as I can of the. Copy on write fork lab here just to give us sort of something to chew on. And you should feel free to ask any questions you like. You can ask about why my solution is different from your solution or why XV 6 works the way it does, or why the bugs that we encounter show up in the way they do. So just to remind you, although I'm sure this is sure, I don't need to remind you, the point of copy and write fork is to avoid copying costs for pages in a fork that are never modified. 
好的，今天我想给你一个机会，问一些关于XV 6和最近的实验室的问题，为了给我们一些话题，我会尽我所能。在这里复制写分叉实验室，只是为了给我们一些可以咀嚼的东西。你应该随时提出任何你喜欢的问题。你可以问为什么我的解决方案与你的解决方案不同，或者为什么XV 6以这种方式工作，或者为什么我们遇到的错误会出现在它们的方式中。所以只是为了提醒你，虽然我确信这是肯定的，但我不需要提醒你，copy and write fork的目的是为了避免在从未被修改的fork中复制页面的成本。

发言人   01:15
I put in a few lines of code to measure the reduction in the number of bytes that mem copy had to copy during user tests for my copy and write solution, and found that it actually reduced the amount of copying by 90%. And this is for user tests, which is kind of a weird program. But nevertheless, and I think a lot of it is reductions in the copying of the instruction pages because the instruction pages for or never modified. So there's never any point in having copies of them. And I think that's where a lot of the wind was from. 
我输入了几行代码来衡量在用户测试我的复制和写入解决方案期间mem copy必须复制的字节数的减少，发现它实际上减少了90% 的复制量。这是用于用户测试，这是一个有点奇怪的程序。但是尽管如此，我认为其中很大一部分是指令页面复制的减少，因为指令页面为或从未被修改。所以拥有它们的副本从来没有任何意义。我想这就是很多风的来源。

发言人   01:51
Copy and write fork also reduces Ram Use the sort of maximum amount of Ram you ever need to use, and it reduces the amount of time you spend in fork. And so fork returns more quickly. You know, on the other hand, of course, the total cost may be larger because if programs end up modifying all the copy and write pages, you end up having to do all the copies plus take all the page faults, which can be a little bit expensive. But nevertheless, people have found that in general, it's net benefit. 
Copy和write fork还可以减少内存的使用，达到您需要使用的最大内存量，并减少您在fork上花费的时间。这样fork就能更快地返回。你知道，另一方面，当然总成本可能会更高，因为如果程序最终修改了所有的复制和写入页面，你最终将不得不完成所有的复制加上所有的页面错误，这可能会有点昂贵。然而，人们发现，总的来说，这是净收益。

发言人   02:23
And as you know, the main challenges are one challenge is how to avoid freeing memory thing. And now we're sharing pages among processes. We have to not reallocate them. We have to not free them until the last process is finished using them. So we need more bookkeeping. And the other interesting challenge is that there's and copy out in particular XV 6 modifies user memory without actually going through the MMU paging hardware. And so we have to mimic page faults there. 
正如你所知，主要的挑战之一是如何避免释放内存的事情。现在我们正在进程之间共享页面。我们不必重新分配它们。在最后一个过程使用完它们之前，我们不能释放它们。所以我们需要更多的簿记。另一个有趣的挑战是，特别是XV 6会修改用户内存，而不需要实际通过MMU分页硬件。因此我们必须在那里模拟页面错误。

发言人   02:57
I'm going to go through the lab starting at the beginning, the copy and write lab. Before I start, I just want to just sort of mention the strategy that I think of myself as following when I do labs and I do a lot of labs, you know, from one year to an X, I don't remember the details of how to do the labs. And in addition to the labs change. 
我将从头开始进行实验，复制和编写实验。在我开始之前，我只想提到我自己在做实验室时遵循的策略，我做很多实验室，你知道，从一年到X，我不记得如何做实验室的细节了。除了实验室的变化。

发言人   03:19
Alright, so when I'm doing the labs, I always take small steps. I may find some sort of next subset of the problem to solve, maybe 5 or 10 lines of code. I program that up, and I run it and try to get it to working before I go on to the next proceeding, to the next step. And this is, you know, as opposed to, for example, thinking through and writing a complete solution before starting to test and debug it, always test and debug a little bit at a time. A lot of the reason for that is that even though you may have sort of thought through a lot of the things, a lot of the challenges and a lot of the design for what you're going to have to do to solve a lab, I find at least there's often surprises. If I implement everything first, I may find then that I wasted a lot of time because I didn't fully understand the problem until I actually got into debugging it. And the way I choose the next step at each point is usually driven by whatever panic or crash or test failure I see next sort of tells me what I need to fix next. 
好的，所以当我做实验室的时候，我总是采取小步骤。我可能会找到问题的下一个子集来解决，可能需要5或10行代码。我会将其编程，并运行它并尝试使其工作，然后再进行下一步骤。你知道，这与例如在开始测试和调试之前思考并编写完整的解决方案相反，总是一次测试和调试一点。造成这种情况的很多原因是，尽管你可能已经思考过很多事情，很多挑战和很多设计来解决实验室问题，但我发现至少经常会有惊喜。如果我先实现所有东西，我可能会发现浪费了很多时间，因为我没有完全理解问题，直到我真正开始调试它。并且我在每个点选择下一步的方式通常是由我看到的任何恐慌、崩溃或测试失败所驱动的，接下来我需要修复什么。

发言人   04:30
And while I'm doing this lab I'll make a few mistakes that I actually made the last time I did the lab so that we can do have a little practice debugging together. And again, feel free to break in at any time and ask questions about anything. 
在我做这个实验的时候，我会犯一些我上次做实验时实际上犯的错误，这样我们就可以一起练习调试了。而且，随时可以随时闯入并询问任何问题。

发言人   04:47
I'm starting here with a fresh copy of the copy and write lab source, same as all of you did. So I'll just fire this up and Run the copy and write test. And, you know, maybe I'll get lucky and all the tests will pass. 
我从复制和编写实验室源代码的新副本开始，和你们所有人做的一样。所以我会启动这个并运行复制和写入测试。而且，你知道的，也许我会很幸运，所有的测试都会通过。

发言人   05:07
I don't have to do anything. Too bad, one of the tests failed. Okay, so not too surprising. And, you know, a good step at this point is to go have a look at the tests and figure out what it's trying to do. And the sad truth is some of the tests are complicated and hard to understand and don't necessarily test anything specific. They just sort of try different things to see if something will break. But luckily, with this simple test, it's pretty clear what it's doing. 
我什么都不用做。太糟糕了，其中一个测试失败了。好的，所以并不太令人惊讶。而且，你知道，在这一点上，一个好的步骤是去看看测试并弄清楚它想要做什么。可悲的事实是，一些测试很复杂，难以理解，并不一定测试任何特定的东西。他们只是尝试不同的东西，看看是否有些东西会破裂。但幸运的是，通过这个简单的测试，它在做什么就很清楚了。

发言人   05:41
Question, do you mean to share your screen? You can not see anything? Oh gosh I'm sorry about that, thank you, thank you for letting me know. Or is that better? Yes, good, brilliant, sorry. 
问题，你想分享你的屏幕吗？你什么也看不见？哦天啊，我很抱歉，谢谢你让我知道。还是更好？是的，很好，很棒，抱歉。

发言人   06:01
Okay, wow, that's book number one. Okay, so I'll just here I am in my copy and write test. I ran copy and write test and it fails. I look at the test, This simple test on the screen at right is what actually failed. And this test, luckily enough, it actually tells us what it's doing, allocates what it knows to be more than half the available memory and XV 6, and then forks. And so of course, the reason this fails is that fork makes a copy. Then ordinary Xb 6, that actually literally makes a copy. And so if we have to copy more than half of memory, there's just not enough space for that. 
好的，哇，那是第一本书。好的，所以我就在这里，我在我的复制和写入测试中。我运行了复制和写入测试，但失败了。我看着这个测试，右边屏幕上的这个简单测试实际上失败了。幸运的是，这个测试实际上告诉我们它在做什么，分配它知道的超过一半的可用内存和XV 6，然后分叉。所以当然，这个失败的原因是fork复制了一个副本。然后是普通的Xb 6，实际上它实际上是一个副本。因此，如果我们必须复制超过一半的内存，那么空间就不够了。


发言人   06:51
Okay, so of course, this is what copy and writes all about. 
好的，所以当然，这就是复制和写作的全部。

发言人   06:55
And we know that the basic game is that instead of copying the process is memory, we want to just copy its page table and not the memory. So the child has just has a carbon copy of the parent's page table instead of memory referring to all the same physical pages. The place where? Fork does its copying is in VM DOC in UV and copy. And so we can just modify this code. To instead of allocating a page of memory here and copying onto it, we're going to eliminate those three lines. And instead. Just copy page table entries. 
我们知道，基本的游戏是复制过程而不是内存，我们只想复制它的页表而不是内存。因此，孩子只是有一个父母页表的副本，而不是内存引用所有相同的物理页面。地方在哪里？Fork在紫外线和复制中的VM文档中进行复制。所以我们可以修改这段代码。而不是在这里分配一页内存并复制到它上面，我们将消除这三行。相反。只需复制页表条目。


发言人   07:55
I'm actually just going to hack this. 
我实际上只是要破解这个。

发言人   08:05
Copy of. Map pages. Since we didn't actually allocate memory here I'm going to get rid of this free and I'm going to fix this Mac pages to instead of mapping mem at. Address I I'm going to map the PA, which is the physical address we pulled out of the parents page table. So is that clear? This will just have the effect of mapping all of the parents pages into the child's address space. 
的副本。地图页面。因为我们实际上并没有在这里分配内存，所以我将摆脱这个免费的，我将修复这个Mac页面，而不是映射mem。我将映射PA，这是我们从父页面表中提取的物理地址。那么清楚了吗？这只会产生将所有父页面映射到孩子的地址空间的效果。

发言人   08:39
Isn't PA already a UN 64? Probably, or is it? Is it bad if you were to cast it? If it's already that type, that cast is absolutely nothing other than shut the compiler up since it's already since the dresses are 64 b and you went 64, 64 b, that cast doesn't change the bits, it just makes the type checker less upset. But let's see, actually don't know what any of these types are. However, one thing is we don't need this member variable. Well, okay. So you're right about PA. Gosh, I wonder if we're done. Now let's run the cow test and see what happens. We're definitely not done. 
爸爸不是已经是联合国64了吗？可能是，或者是？如果你投的话，会很糟糕吗？如果它已经是那种类型，那么这种类型的转换绝对就是关闭编译器，因为它已经是64 b，而你变成了64，64 b，这种类型转换不会改变位，它只是让类型检查器不那么烦恼。但是让我们看看，实际上并不知道这些类型是什么。然而，有一点是我们不需要这个成员变量。好吧。所以你对爸爸的看法是对的。天哪，我想知道我们是否结束了。现在让我们运行奶牛测试，看看会发生什么。我们绝对还没有完成。




发言人   09:28
Okay, so what we got here is this user trap with s cause of 2. Anybody remember what s cos 2 is. I'll just tell you, instruction failure. It's an illegal instruction. So why would be getting an illegal instruction now? Is this what we expected? 
好的，所以我们在这里得到的是这个用户陷阱，s原因为2。有人记得s cos 2是什么吗？我只是告诉你，指令失败。这是非法指令。那么，为什么现在会收到非法指令呢？这是我们所期望的吗？

发言人   09:58
Did we overwrite the like portion where we have instructions? Yes, something is damaging the instructions of the user program and of course, the fault. We're not surprised we get a fault here, but we were hoping for right restored faults to derive the copying process and copy on write. We're not getting the store fault. 
我们覆盖了有指示的相似部分吗？是的，某些东西正在破坏用户程序的指令，当然还有故障。我们在这里遇到错误并不感到惊讶，但我们希望正确恢复错误以派生复制过程和写入时复制。我们没有得到商店的过错。

发言人   10:31
Any other hypotheses for this? This is not really fair because like this is my bug, Not your bug, but nevertheless. Does it have to do the flags? Yes it does. 
对此还有其他假设吗？这并不公平，因为这是我的错误，不是你的错误，但无论如何。它必须做旗帜吗？是的，确实如此。

发言人   10:53
Okay, so I'll just leave that to the side. It'll actually come up again. Another question is, we're hoping for store page faults, which will drive the copying process. Why didn't we get a store page fault? 
好的，那我就把它放在一边。它实际上会再次出现。另一个问题是，我们希望出现存储页面错误，这将推动复制过程。为什么我们没有收到商店页面错误？

发言人   11:21
All right, why would we get a store page fault? Under what circumstances does the risk vibe generate a store page fault? We would get it if the right flag is not set. But now we can just write to everything still normally. Yeah I've left the right flag set. All right, so that's bug one, which I did actually make last time I did this lab. So I've left the right flag set in the parent and I've done, haven't done anything to the right flags. This flags variable here is just the way we pulled it out of the parents' page tables. All its pages are writable. And so that means that it's going to be right up on the child too. 
好吧，为什么我们会得到一个商店页面错误？在什么情况下，风险氛围会产生商店页面故障？如果没有设置正确的标志，我们就会得到它。但现在我们可以正常地写信给一切了。是的，我已经离开了正确的旗帜。好吧，这是错误一，上次我做这个实验时实际上做了。所以我在父母中留下了正确的标志设置，我已经做了，没有对正确的标志做任何事情。这里的这个标志变量就是我们从父页表中提取它的方式。它的所有页面都是可写的。这意味着孩子也会受到影响。

发言人   12:02
We won't get store page fault so'll just be sharing a page read write, which is not what we wanted. So how am I going to turn off the, how am I going to write protect these pages? 
我们不会得到存储页面错误，所以只会以读写方式共享一个页面，这不是我们想要的。那么我要如何关闭，我要如何保护这些页面？

发言人   12:20
Any proposals which I type? How about you can do flax n equals the sign underscore w? Yeah? Yeah, so we got a, got a, we need the tilde there, I call that wave sign a tilde, we need to the is clear, we need to clear this bit in the flags, but we want to leave all the other flags set. Okay? So that's going to, well, this clear the flag and the parent of the child. 
有我输入的任何建议吗？你可以把亚麻n等于符号下划线w吗？是吗？是的，所以我们有一个，有一个，我们需要波浪号，我把那个波浪号叫做波浪号，我们需要清楚，我们需要清除旗帜中的这一点，但我们想保留所有其他旗帜。好吗？所以这将会清楚标志和孩子的父母。


发言人   13:01
Child, just the child. So how do I clear? Do I also need to clear the flag and the parent? Yes, because like we want the child to be independent for the parents. So if we write something we don't want like the child to also get the modification from the parents, That's absolutely right. We need to write protect the page and the parent as well, because we don't want the child to see the parents modifications. We're trying to mimic them having completely separate copies. So what can I do to clear the flag in the parents page table? 
孩子，只有孩子。那么我该怎么清除呢？我还需要清除旗帜和父母吗？是的，因为我们希望孩子独立于父母。因此，如果我们写了一些我们不想让孩子也得到父母的修改的东西，那绝对是正确的。我们需要保护页面和父级，因为我们不希望孩子看到父级的修改。我们正在尝试用完全独立的副本来模仿它们。那么我该怎么做才能清除父页面表中的标志呢？

发言人   13:43
You can do something like star Pt and equals not Pte, right? Yeah, so I have a parent, a pointer, the parent page table entry right here in Pte. And so I can clear the Pte flag here too. So that's pretty convenient. And my belief is that's enough to make both copies of the page or both mappings of the page read only. So hopefully now we'll start getting. Rate faults Is it possible to do to clear the PTW that before you say flags equals Pte flags of Pg and that way like the original flags is just the correct thing? Oh, I see, put away up here. Yeah, and yeah, why not? We'll give that a shot. 
你可以做一些像明星一样的事情，而不是Pte，对吧？是的，所以我在Pte中有一个父级，一个指针，父级页表条目。所以我也可以清除这里的Pte标志。所以这很方便。我相信这足以使页面的两个副本或页面的两个映射都是只读的。所以希望现在我们可以开始了。速率错误是否可以清除PTW，在你说标志等于Pg的Pte标志之前，这种方式就像原始标志一样是正确的吗？哦，我明白了，放在这里。是的，为什么不呢？我们会试一试。





发言人   14:46
Seems to work? Yeah, that makes sense. Okay, so now I get my right fault. Which is what we're hoping for? And hopefully what this right fault means is that one of the other processes tried to modify the risk 5 generated a ph fault from that. And we're going to want to react to that by. 
似乎起作用了？是的，这很感知。好的，现在我有我的错了。这就是我们所希望的？希望这个正确的故障意味着其他过程之一试图修改风险5从而产生ph故障。我们想要对此做出反应。

发言人   15:11
Making a copy of the page and mapping it. Read, write. Before we do that, just to make sure that what we're seeing, it's this f here, this S cause that is sort of making me imagine that we're seeing what we want to see, namely a storefront. Let's actually go and look and see where that happened. We know it's in process ID 3. Process ID 1 is in it. Process ID 2 is the shell, and so maybe process ID 3 is going to be cow test. We can look in. 
制作页面的副本并进行映射。读，写。在我们这样做之前，只是为了确保我们所看到的，这是因为这让我想象我们正在看到我们想要看到的东西，即一个店面。让我们去看看发生在哪里。我们知道它正在账号3日进行中。进程账号1在其中。进程账号2是shell，因此可能进程账号3将进行牛测试。我们可以进去看看。

发言人   15:51
We can look in cowt, can do ASM and look for 9 Da and see if it makes sense as a instruction that could generate a store page fault. The way this doesn't look so good. I can't even remember what aui PC does, but I don't believe it performs a store and he guesses what's going on. 
我们可以在cowt中查找，可以执行ASM并查找9 da，看看它是否将感知作为可能产生存储页面错误的指令。这样看起来不太好。我甚至不记得aui PC做了什么，但我不相信它执行存储，他猜测发生了什么。


发言人   16:28
It'd be nice if the page faults we were seeing actually made sense. 
如果我们看到的页面错误确实产生了感知，那就太好了。

发言人   16:37
I'll tell you, it turns out this page fault occurred in the shell after the shell fork before it ex cow test. And so we're really looking at the wrong ASM file. It turns out the right ASM file is the shell ASM file. So we'll look for 9 Da there. Yes, and in the shell 98 is a store instruction. And it's at the beginning of this parse command function that actually parses the cow test command that we typed and figures out what to do with it, namely called exec and's doing a store into the stack. It's the preamble that stores the Collie saved registers. And not surprisingly, this should be the first page fault we get because it's on the stack you the very first thing most functions do after fork returns is they modify the variables in the stack. 
我会告诉你，这个页面错误发生在shell分叉之后的shell测试中。所以我们真的在查看错误的ASM文件。事实证明，正确的ASM文件是shell ASM文件。所以我们会在那里寻找9 Da。是的，在shell 98中是一个存储指令。并且它在这个解析命令函数的开头，实际上解析我们输入的cow test命令并找出如何处理它，即称为exec并将其存储到堆栈中。这是存储牧羊犬保存的寄存器的序言。毫不奇怪，这应该是我们得到的第一个页面错误，因为它在堆栈上，大多数函数在fork返回后做的第一件事就是修改堆栈中的变量。


发言人   17:30
And boom, unsurprisingly, that causes a store page fault. So any questions about why we're faulting? I have a quick question. How did you figure out it was in the Shell rather than in Caltex? Because I looked at 98 in cowt test and that is not a store instruction. I thought, gosh, what could possibly be going on? 
不出所料，这导致了商店页面错误。所以对于我们为什么要犯错有什么疑问吗？我有个简短的问题。你是怎么知道它在贝壳里而不是在加德士里的？因为我在cowt测试中查看了98，这不是存储指令。我想，天哪，可能发生了什么？


发言人   18:00
Process 3. So it's 3, the shell or is that pit 3? Is pit 2 is the shell that printed that prompt? Pi 3 is the next process that's created. And so initially the shell forks to make Pi 3, but after the fork, it's still running the shell. It's a child of the shell running a copy of the shell. It's going to call exec to run C test, but it hasn't done it yet. It hasn't been able to get that far without taking a store page fault. 
过程3。所以它是3，外壳还是那个坑3？坑2是打印出该提示的外壳吗？Pi 3是下一个创建的过程。所以最初shell分叉以形成Pi 3，但分叉之后，它仍然运行shell。它是运行shell副本的shell的子级。它将调用exec来运行C测试，但它还没有这样做。如果不采取商店页面错误，它就无法走那么远。

发言人   18:35
When it writes a stack, so can you clarify, does that mean that there's like an error with the shell related to process ID too? Because it doesn't have the proper data in order for the child to have the right data? Or is it an error with process ID 3? It's a page fault that occurs in process ID 3, right? But the bug that we're seeing right here, like there's no bug. This is, you know I'm implementing copy and write fork. 
当它写入一个堆栈时，你能澄清一下，这是否意味着与进程账号相关的shell也有错误？因为它没有正确的数据，以便孩子拥有正确的数据？或者是进程账号3的错误？这是进程账号3中发生的页面错误，对吗？但是我们在这里看到的bug，就像没有bug一样。这是，你知道我正在实现复制和写入分叉。

发言人   19:09
And what we just did in VM DOC was write protect every single page in the parent and the child, right? That's what this line is doing. So the next time either the parent or the child does a store from user code, it's going to be a store and a right protected page because every page is right protected. And so it will cause a page fault. Oh, so this is a proper page fault that we want this, right? 
我们在VM文档中刚刚做的是写入保护父和子页面中的每个页面，对吧？这就是这条线正在做的事情。因此，下一次父母或孩子从用户代码中进行存储时，它将是一个商店和一个受保护的页面，因为每个页面都是受保护的。因此它会导致页面错误。哦，所以这是我们想要的正确的页面错误，对吧？


发言人   19:37
And I was just, well, I was doing, I was checking that that what's going on is exactly what we think is going on as opposed to some other bug. Gotcha makes sense, Okay, all right, so we took a page vault here and this store, which is presumably the first store the shell does after the fork. Okay, and so now we have to handle these. 
我只是，嗯，我在做，我在检查正在发生的事情是否正是我们认为正在发生的事情，而不是其他一些错误。Gotcha做感知，好的，所以我们在这里使用了一个页面存储库和这个存储库，这大概是shell在fork之后做的第一个存储库。好的，现在我们必须处理这些问题。


发言人   20:00
Now we want to do something useful in this page faults. So whereas the page fault handlers in the and trap DOC in user fault. I think it pretty much doesn't matter where we insert code to. I mean, that there's all these different cases here. That user vac, this is user vac, right? Or user trap that user trap is dealing with. We're just going to throw in another else. We're only interested in write faults. We're happy to read these shared pages because all the data is there. It's just right. So we want to catch so. 
现在我们想在这个页面错误中做一些有用的事情。因此，页面错误处理程序在用户错误和陷阱文档中。我认为在哪里插入代码几乎不重要。我的意思是，这里有所有这些不同的案例。那个用户vac，这是用户vac，对吧？或者用户陷阱，用户陷阱正在处理。我们只是要加入另一个。我们只对写入错误感兴趣。我们很高兴阅读这些共享页面，因为所有数据都在那里。它是正确的。所以我们想抓住这一点。



发言人   20:47
Now, it turns out, is, as I'm sure you know, that we're going to need to use the code I'm about to write from two different places. Just wrap it up in the code that sort of makes the copy of this page in a function I'm going to call cow fault. It needs to know the current page table and it needs to know the virtual address that we faulted on. That's st value. Sometimes it can fail because, say, it runs out of memory, maybe k.o. will fail. So we need to prepare for a return value. And pretty much no matter what the failure is, we're going to kill this process. And if we didn't kill it, we'll have cow fault return -1. 
现在，事实证明，我相信你知道，我们需要使用我即将从两个不同地方编写的代码。只需将其包装在代码中，即可将此页面的副本放在一个函数中，我将调用cow fault。它需要知道当前页表，并且需要知道我们出错的虚拟地址。这是st值。有时它可能会失败，因为，比如说，它耗尽了内存，可能是k.o. 会失败。所以我们需要为返回值做准备。而且几乎不管失败是什么，我们都会扼杀这个过程。如果我们没有杀死它，我们将会有牛故障返回-1。


发言人   21:32
If there's a failure, return 0. If there's no failure. If there's no failure, then we're going to rely on calf allt having made this virtual address writable, so that when user trap returns, the process can actually continue successfully that you put or like, is there a reason why you put. 
如果出现故障，则返回0。如果没有失败。如果没有失败，那么我们将依靠calf allt使这个虚拟地址可写，这样当用户陷阱返回时，该过程实际上可以成功地继续进行，您是否有理由放置。

发言人   21:52
This line above the else if which do Deventer? I don't think so, whether it's correct depends on what devinder does. We'll just take a look. The risk is that Devonta might see a device interrupt for some reason, even though we were in a page full. So we just got to check that devinder looks at S cause. And if s causes f, it's going to return 0. We just want to make sure that if. Yeah, if dev enter return zero, then it's going to go on to our code. So that's fine. 
这一行在else上面，如果Deventer是什么？我不这么认为，它是否正确取决于devinder所做的事情。我们只是看一看。风险在于，即使我们处于满页状态，Devonta也可能由于某种原因看到设备中断。所以我们只需要检查devinder是否查看了原因。如果s导致f，它将返回0。我们只是想确保如果。是的，如果dev输入return zero，那么它将继续进入我们的代码。所以没关系。



发言人   22:40
Okay, okay, now we only need to write. Actually, there's one thing I want to observe here, and that's that if there's a failure, we kill the process. So this is unfortunate, It would be fantastic if instead, most of the time processes allocate memory or whatever by calling system calls, the system calls going to return some error value negative one or something if there's a failure. And the process can then do something appropriate if it knows how in order to deal with that failure. 
好的，好的，现在我们只需要写。实际上，我想在这里观察到一件事，那就是如果失败，我们会终止该过程。所以这是不幸的，如果大多数时间进程通过调用系统调用来分配内存或其他方式，如果出现故障，系统调用将返回一些负的错误值，那就太棒了。如果知道如何处理失败，流程就可以做一些适当的事情。

发言人   23:10
Here, though, because there's no system call, there's not any obvious way to tell the process that something went wrong, which is irritating. You can imagine solutions to this, For example, in some more sophisticated operating system, we could have something like the alarm user fault handler that you implemented that we could call up into to say, look, you know, we can't continue your process because we can't fix this page fault, but we want to tell you something went wrong, but we're not going to do that. Now. It's much simpler to just kill the process, okay? So we have to implement page, this cow fault program takes. 
不过，由于这里没有系统调用，因此没有任何明显的方法告诉流程出了问题，这很令人恼火。你可以想象解决方案，例如，在一些更复杂的操作系统中，我们可以使用类似你实现的警报用户错误处理程序，我们可以调用它来说，看，你知道，我们无法继续您的进程，因为我们无法修复此页面错误。但我们想告诉你出了什么问题，但我们不会那样做。现在。杀死这个过程要简单得多，好吗？所以我们必须实现这个奶牛故障程序所需要的页面。


发言人   23:55
When a page table, the current process page table is argumented the virtual address that the fault occurred on. Okay, so the first question we always have to worry about when dealing with virtual addresses that the user program produced like this one is, what if it's a completely crazy address, like way up above the top of the process? Or what if it's an address in the trap frame or in the trampoline page or in the page, the stack guard page, So can anybody sort of outline a strategy for? Defending ourselves against the user process? Intentionally faulting on crazy addresses? 
当一个页表时，当前的进程页表被论证为发生故障的虚拟地址。好的，所以在处理用户程序生成的像这样的虚拟地址时，我们总是需要担心的第一个问题是，如果它是一个完全疯狂的地址，就像在进程顶部以上呢？或者如果它是陷阱框架或蹦床页面或堆叠保护页面中的地址，那么任何人都可以概述一下策略吗？在用户过程中保护自己？故意出错疯狂的地址？

发言人   24:50
Isn't there like a max virtual address? Yes, yes there is. And that will actually come up. But the top of the user address space is below. 
不是有一个最大虚拟地址吗？是的，是的。这实际上会出现。但用户地址空间的顶部在下面。

发言人   25:05
Max VA. And the? Like the stack guard page, which we shouldn't be allowing, right? You certainly shouldn't be treating as a copy and write thing. All right, I will. I'll show a solution here. 
最大VA。然后呢？就像堆栈保护页面一样，我们不应该允许这样做，对吗？你当然不应该被视为复制和写作的东西。好的，我会的。我会在这里展示一个解决方案。

发言人   25:25
We're just going to call walk for now. And one thing that can go wrong is walk doesn't find a page table entry. So for most illegal pages that a process might refer to, there's no Pte. And there's only a few exceptions to that. So if we detect the illegal, if we detect the detect the Pte not found return value from walk and return -1, we've handled almost every case. 
我们现在要打电话给步行。有一件事可能出错，那就是walk找不到页表条目。因此，对于进程可能引用的大多数非法页面，没有Pte。只有少数例外。因此，如果我们检测到非法行为，如果我们检测到从walk和return -1中找不到的返回值，我们几乎处理了所有情况。

发言人   25:55
The only cases I'm aware of where walk would return a page table entry. But we don't want to allow rights to it are for the trampoline trap frame and stack guard pages. And those all have Pte. You clear? So the way I'm going to detect crazy addresses, illegal addresses is by checking that PTU is set. And I'll also just for Chuck's look at PTV. And if either of those is clear, then we know this is like. Not an OK address. And we'll just return -1, which will be call the process. So I believe we've taken care of all the. 
我知道的唯一情况是walk会返回一个页表条目。但是我们不想允许对它的权限是针对蹦床陷阱框架和堆栈保护页面的。这些都有Pte。你明白了吗？所以我要检测疯狂地址和非法地址的方法是检查是否设置了PTU。我也会让查克看看PTV。如果其中任何一个是清楚的，那么我们就知道这就像。不是一个好的地址。并且我们将只返回-1，它将被称为进程。所以我相信我们已经照顾好了所有的事情。



发言人   26:50
Illegal addresses the user process could use, try to use. All right, how can we find out? We want to do a copy now. We want to make the process copy of the page. How do we find the page to copy from? I have a question here, please, wouldn't the strategy of using the PTA you to judge if the page is? If it's a legit page for copy and write, wouldn't the strategy not be very good for the long term process? 
用户进程可能使用的非法地址，请尝试使用。好吧，我们怎么才能知道呢？我们现在想做一个副本。我们想让进程复制页面。我们如何找到要复制的页面？我在这里有一个问题，请问使用PTA来判断页面是否合适的策略不是吗？如果这是一个合法的复制和写作页面，那么这个策略对长期过程不是很好吗？

发言人   27:24
Maybe you add some other, part 2, the address space, which is which is supposed to be a writable, which only supposed to be readable, but that doesn't get taken care of here. As in, you'll have to come back here again. 
也许你会添加一些其他的，第2部分，地址空间，它应该是可写的，只应该是可读的，但这并没有在这里得到解决。就像，你必须再回到这里。

发言人   27:40
You're absolutely right, If we were to add any other interesting paging feature you like maybe lazy page allocation, for example, we'd have to revisit these decisions and come up with some other strategy for deciding, is this a copy and write page? Is this a lazy allocation page? Is this paged out to disk page just to say memory map file? 
你说得绝对正确，如果我们要添加任何其他有趣的分页功能，比如懒惰页面分配，我们必须重新审视这些决定，并想出一些其他的决策策略，这是复制和写入页面吗？这是一个惰性分配页面吗？这个分页到磁盘的页面只是为了说内存映射文件吗？

发言人   28:03
And we'd need more sophisticated in the end, I think most serious operating systems actually keep their own data structure. Nothing to do with, you know, not a page table, but sort of mimicking a page table that describes the processes, address space, sort of describes what each page means and what its state is, and we'd have to consult that table. But for this lab, since we don't have those other features and we're not sure what they would be. I'm just going to do something straightforward. And indeed, we would have to come back and fix it if we made XV six more sophisticated. Wouldn't that panic if VA is more than max VA because of the lock? 
我们最终需要更加复杂，我认为大多数严肃的操作系统实际上都保留了自己的数据结构。这与，你知道的，不是页表无关，而是类似于描述进程、地址空间的页表，描述每个页面的含义及其状态，我们必须查阅该表。但是对于这个实验来说，因为我们没有其他的功能，也不确定它们是什么。我只是打算做一些简单的事情。的确，如果我们把XV六做得更复杂，我们就必须回来修复它。如果由于锁的原因，VA超过max VA，那不会很恐慌吗？

发言人   28:53
Gosh, maybe you would. Yeah, well, look at that. Yeah, maybe if the process. Yeah, I think you're right. Well, that's too bad. Okay, so we were certainly right. All right, well, I was was wrong about this, Wait, can you just return a negative one if you just check the maps? 
天哪，也许你会。是的，好吧，看看这个。是的，也许是这个过程。是的，我认为你是对的。那太糟糕了。好的，我们当然是对的。好的，我错了，等等，如果你只是检查地图，你能返回一个否定的吗？

发言人   29:16
VA? I think the observation is that if the user tries to intentionally program, tries to write a very large address, of course you, I can't expect to survive that. But what we would do here is call walk with a very large address. And I'm looking at here the implementation of walk In. And it's going to panic. I think we can just use the same approach as walk address those. I had the same bug. You can just return -1. Like other people were saying, if VA is greater than max VA before Wa. What I'm upset about is that the tests don't seem to test this because I didn't put this in my solution, okay? 
VA?我认为观察到的是，如果用户试图故意编程，试图写一个非常大的地址，当然，我不能指望你能幸存下来。但我们在这里要做的是使用非常大的地址进行呼叫行走。我在这里看到的是walk In的实现。它会引起恐慌。我认为我们可以使用与步行地址相同的方法。我也有同样的错误。你可以只返回-1。就像其他人所说的，如果VA大于max VA，那么在Wa之前。我感到沮丧的是，测试似乎没有测试这个，因为我没有把它放在我的解决方案中，好吗？


发言人   30:08
Okay, okay, so how do we find out? We want to copy the page. How do I get a pointer to the to the pointer to something I can copy? The PTA to PA? Yeah, so it's just in the Pte, And where am I going to copy 2? What should I copy to a nearly allocated page? Yeah, so I just got K alloc. Of course, klo is likely to fail, so I got to catch that. We're actually going to see this. So I got to put in a print statement. So we know, okay, we have 2 not. 
好的，好的，那么我们如何发现呢？我们想要复制这一页。我如何获得一个指向我可以复制的东西的指针？PTA到PA？是的，所以它只是在Pte中，我要在哪里复制2？我应该复制到几乎分配的页面上吗？是的，所以我刚刚得到了K个分配。当然，klo很可能会失败，所以我必须抓住这一点。我们实际上会看到这个。所以我得打印一份声明。所以我们知道，好吧，我们有2个没有。

发言人   31:13
I actually made this error and I wanted to reproduce it so that we would have to track it down. But you're too clever for me. All right, I want to copy PA 2. From PA 1. Okay, so how can I, what do I need to do in order to map this page, this new page PA 2 into the? Address space. 
我实际上犯了这个错误，我想重现它，以便我们不得不追踪它。但你对我来说太聪明了。好的，我想抄写PA 2。从PA 1。好的，那么我该如何，我需要做什么才能将这个页面，这个新页面PA 2映射到？地址空间。

发言人   31:46
What should I type? There's like 2 broadways. There's either on mapping and then mapping with the built ins that exist, or you could manipulate the bits. I am way too lazy to figure out how to use M on map and M map, so I'm going to just cook up a new page table entry right here. 
我应该打什么？这里有两个百老汇。要么先映射，然后用现有的内置插件进行映射，或者你可以操纵比特。我懒得弄清楚如何在地图上使用M和M地图，所以我将在这里制作一个新的页表条目。

发言人   32:13
I have a question, so actually, I ran into this issue in almost every lab in which, I somehow needed to remap things. And because it occurred so often, I implemented a map that which could remap basically. And I was wondering, is that a bad design choice? Is it like dangerous? Oh, no mapping, That's totally reasonable. 
我有一个问题，实际上，我在几乎每个实验室都遇到了这个问题，我需要以某种方式重新映射事物。因为它经常发生，所以我实现了一个可以重新映射的地图。我在想，这是一个糟糕的设计选择吗？很危险吗？哦，没有映射，那是完全合理的。

发言人   32:44
You know, the functions in XV 6 are, are, you know, specialized to XV 6 as it exists. And so they, you know, they make assumptions about how the other code works. They have panics in them that are intended, but catch other code using them in unexpected ways. But if you change the way XV 6 works, then you need to do different things. Then it's totally reasonable to modify, you know? Oh, you need to be able to remap this without a panic. Well, old XV 6 never needs to do that, but your code does, so you should feel free to modify anything you need to. Okay, so, okay, so the deal is here. 
你知道，XV 6中的功能是专门针对XV 6的。所以他们，你知道的，他们对其他代码如何工作做出假设。它们中有预期的恐慌，但会捕捉到其他以意想不到的方式使用它们的代码。但是如果你改变了XV 6的工作方式，那么你需要做不同的事情。那么修改是完全合理的，你知道吗？哦，你需要能够在没有恐慌的情况下重新映射它。好吧，旧的XV 6从来不需要这样做，但是你的代码需要这样做，所以你应该随意修改任何你需要的东西。好的，好的，交易就在这里。

发言人   33:29
We had a right protected page that was probably shared with another process. What do we have to do to that other process at this point? What do we need to do to the other process? 
我们有一个受保护的页面，可能与另一个进程共享。在这一点上，我们必须对另一个过程做什么？我们需要对另一个过程做什么？

发言人   33:46
We can just not do anything. And then when it page folds, we allocate a new page and remove the original. Know why? That's absolutely right. So you could imagine doing something, but it would be quite complex to do it correctly, and so we just do nothing. And if the other process never writes this page, well, it's not a problem. If it does write a page, then it'll go through all this, it'll make a copy, and it'll proceed safely as well. So doing nothing is totally reasonable. 
我们什么也做不了。然后当页面折叠时，我们分配一个新页面并删除原始页面。知道为什么吗？这完全正确。所以你可以想象做一些事情，但正确地做会相当复杂，所以我们什么也不做。如果另一个进程从未写过这个页面，那么这不是问题。如果它确实写了一个页面，那么它将经历所有这些，它将复制一份，并且它也将安全地进行。所以什么都不做是完全合理的。

发言人   34:20
Okay, so now we're going to return. The return value of 0 says there was no error. And hopefully the process will, well, we should free the physical page, right? Or are we not there yet? We do it or not. I guess if we're going steps, we shouldn't. Yeah, so if I did this, what would happen? Well, we would definitely crash, right? 
好的，现在我们要回去了。返回值0表示没有错误。希望这个过程能够释放物理页面，对吧？还是我们还没到？我们做或不做。我想如果我们要走几步，我们不应该。是的，那么如果我这样做，会发生什么？好吧，我们肯定会崩溃，对吧？


发言人   34:47
All right, so let's not do this. Or I don't know if we would crash, but we would then be, if we, if we freed a page, it would be presumably PA one because I don't have free PA 2 because we're using PA 2. If we free PA 1, that means the other process has got a problem. It is now mapped into its address space and presumably using you executing instructions in or I don't know what, a page that we just freed and might be reusing for some other purpose and writing something else over. So I'm reluctant to free it. Although it's? Oh yeah, so sadly among many other things XV 6 walk is never called from outside of VM DOC in ordinary XV 6. But now we're doing it. 
好的，我们不要这样做。或者我不知道我们是否会崩溃，但如果我们释放一个页面，它可能会是一个，因为我没有免费的PA 2，因为我们使用的是PA 2。如果我们释放了pa1，这意味着另一个进程有问题。它现在被映射到它的地址空间中，大概是使用你在一个我们刚刚释放的页面中执行指令，可能会被重用用于其他目的，并在上面写一些其他的东西。所以我不愿意释放它。虽然它是？哦，是的，在许多其他事情中，XV 6 walk从未在普通XV 6中从VM DOC之外被调用。但现在我们正在这样做。

发言人   35:51
Right, where were we. 
对，我们在哪里。


发言人   35:59
Okay, remember the very first page fault we got was an S causes 2. Why are we getting S causes two page faults? 
好的，请记住，我们得到的第一页错误是 “S原因2”。为什么我们得到了两个页面错误的原因？


发言人   36:14
It's an illegal instruction. 
这是非法指令。

发言人   36:20
Like, this is the next problem, we have to solve this problem now. What's gone wrong? 
就像，这是下一个问题，我们现在必须解决这个问题。出了什么问题？

发言人   36:32
Or what are some plausible guesses for what might have gone wrong? 
或者对于可能出现的错误有哪些合理的猜测？

发言人   36:43
So the sequence we, when I type cow test, what we think happens is that the shell forks. Let's copy and write fork. We have the child running. The shells instructions. Probably taking store faults, but for handling those store faults correctly. And then the child exs, the child copy of the Shell Execs cow test. 
因此，当我进行奶牛测试时，我们认为发生的序列是外壳分叉。让我们复制并编写fork。我们有孩子在跑步。炮弹的指示。可能会接受存储故障，但为了正确处理这些存储故障。然后是child exs，Shell Execs cow测试的子副本。

发言人   37:13
What bad thing might that do to the parent shell? 
这会对父shell产生什么不好的影响？

发言人   37:22
Well, when you call exec, the implementation of exec frees up all the processes current pages, and then allocates new pages to load the file into that you're exec team. What's going to happen in the child? The child she that calls exec when it frees all of its pages? 
当您调用exec时，exec的实现会释放所有进程的当前页面，然后分配新的页面以将文件加载到您的exec团队中。孩子会发生什么？当孩子释放所有页面时，她会调用exec？

发言人   37:50
What's that going to do to the parents shell? Is it going accidentally free? The shells Phd page pages? Yes, we're going to free every single one of the shells pages except the one or two that the that were written. So this includes the shell's instruction pages, and then we're going to reallocate them. They're going to be instantly reallocated by exact to hold other stuff loaded from the file that we're running. Cow test. So that's going to totally change everything in the shell underfoot. And unsurprisingly, it's going to instantly crash. So we have to not free those pages somehow. Does everyone see that? A good question. What does the scpc here point to which assembly file would you find that instruction well? 
这对父母的外壳会有什么影响？它会意外地自由吗？贝壳Phd页面页面？是的，我们将释放每个shell页面，除了写的一两个页面。所以这包括shell的指令页面，然后我们将重新分配它们。它们将被立即重新分配，以保存从我们运行的文件中加载的其他内容。奶牛测试。所以这将完全改变脚下的一切。不出所料，它会立即崩溃。所以我们不能以某种方式释放这些页面。大家看到了吗？好问题。这里的scpc指向了哪个汇编文件，你会很好地找到那个指令？

发言人   38:53
You said it Shell, right? It's last time was for some other fault somewhere else. It was shell. What it is here, I actually don't know. I never, I did not, unfortunately, take the time to track this down. So one problem with any answer, even if I could give you an answer, so the answer is either the shell or cow test for process ID 3. That again is the, it's probably cow test. I have to say, I don't completely know what's going on here. 
你说它是壳，对吧？上一次是在其他地方因为其他错误。它是贝壳。这里是什么，我其实不知道。不幸的是，我从来没有，我没有花时间去追踪这件事。所以任何答案都有一个问题，即使我能给你一个答案，所以答案是过程账号3的外壳测试或牛测试。这又是一个，可能是奶牛测试。我不得不说，我不完全知道这里发生了什么。

发言人   39:28
Looking at the ASM file is unlikely to be helpful because the whole problem that we believe has happened is that the page holding the instructions was freed and reused, and so they were therefore not executing the instructions and it's in the ASM file anymore, or executing some garbage. That makes sense? Yeah, so we could look at the address 2004, but it, it wouldn't really tell us what had happened. We might, we probably could find this out using the debugger. We could break in GDP and then look at the instructions. It's actually at whatever virtual address 1004 points to quick follow up question about that fault. 
查看ASM文件不太可能有帮助，因为我们认为发生的整个问题是包含指令的页面被释放并被重用，因此它们没有执行指令，而不再在ASM文件中，或者执行一些垃圾。这就是感知？是的，所以我们可以看看地址2004，但是它并不能告诉我们发生了什么。我们可能，我们可能可以使用调试器找到这一点。我们可以国内生产总值（GDP） 打开，然后看说明书。它实际上在任何虚拟地址1004点快速跟进有关该故障的问题。

发言人   40:17
So my understanding is that we're getting like an invalid instruction fault because like we're changing the instruction page instruction physical memory underfoot, and like the memory is just being written to something else. Is it possible that like in some lucky case, that they are being rewritten? But when we look at it again, it's being rewritten to valid instruction pages? So we actually just start executing like random instructions and we don't actually get an invalid instruction fault, we get some other fault? Yes, absolutely, absolutely, yeah. 
所以我的理解是，我们得到了一个无效的指令错误，因为就像我们在改变指令页，指令物理内存在脚下，而内存只是被写入其他东西。有没有可能就像在某些幸运的情况下一样，它们正在被重写？但是当我们再次查看时，它被重写为有效的说明页面？所以我们实际上只是像随机指令一样开始执行，我们实际上并没有得到无效指令错误，我们得到了一些其他错误？是的，绝对，绝对，是的。

发言人   40:53
Yeah, I mean, really, we're now like anything could happen. I see, I would not have been able to guess if I had not done this lab. I wouldn't be able to guess what would go wrong at this point. And indeed, I think I have seen other strange things happen at this point because maybe the data, maybe the first page that has garbage in it actually has data in it. And the shell trips over some complete garbage data like a stack instead of instructions. Okay, so we don't want to free the page right away. We only want to free the page when it's really not being used anymore. 
是的，我是说，真的，我们现在好像任何事情都可能发生。我明白了，如果我没有做这个实验，我就无法猜测。我无法猜测在这个时候会出什么问题。事实上，我认为我在这一点上看到了其他奇怪的事情发生，因为也许数据，也许第一个有垃圾的页面实际上有数据。并且shell会像堆栈而不是指令一样访问一些完整的垃圾数据。好的，所以我们不想立即释放页面。我们只想在页面不再使用时释放页面。

发言人   41:39
So can anybody propose a sort of criterion for when we should or shouldn't free the free each page of memory we could keep track of like how many times or like basically whenever in K Alec, whenever you should increment and decrement some type of variable and keep an array of like all the different addresses? Yes, yeah, exactly. 
因此，任何人都可以提出一种标准，来确定我们何时应该或不应该释放每页的空闲内存，我们可以跟踪多少次，或者基本上无论何时，无论何时，你应该递增和递减某种类型的变量，并保留一个由所有不同地址组成的数组？是的，没错。

发言人   42:07
So one way to think about this is that we want to only free a page when there's zero page tables that refer to it, but there could be many if a program forks and then forks again and then forks again, boy, we can now have like 3 or four different processes that all refer due to copy and write fork to this one page. This count of how many times, how many page tables refer to a page can go up due to fork and it can go back down when a process exits or calls exec, you know, it's is all these references out of its page table entry or if a process actually does a right and causes a right fault, that's also a situation in which we have one fewer reference from one fewer page tables referring to a page. So we want to keep a count and we want to count be counting the number of page table entries that refer to a page. So we're going to need to think about how to maintain this count and when to increment it, exactly where in the code, increment it, and decrement it. 
因此，有一种思考方法是，我们只想在有零页表引用时释放页面，但是如果程序分叉，然后再次分叉，则可能会有很多分叉，男孩，我们现在可以有3到4个不同的进程，它们都由于复制和写分叉而引用到这个one page上。这个计数是多少次，有多少页表引用一个页面可以由于fork而上升，当进程退出或调用exec时，它可以回落，你知道，它是所有这些引用都不在其页表条目中，或者如果一个进程实际上做了正确的事情并导致了正确的错误，这也是一种情况，我们从更少的页表中得到更少的引用来引用一个页面。所以我们想保留一个计数，我们想计数引用一个页面的页表条目的数量。因此，我们需要考虑如何维护这个计数以及何时递增它，确切地说，在代码的哪个位置递增和递减它。

发言人   43:13
Okay, so the, there's, you may be aware there's multiple ways to maintain this count. The way I do it is I make an array called ref count. 
好的，所以你可能意识到有多种方法可以维护这个计数。我的做法是创建一个名为ref计数的数组。


发言人   43:30
It's just going to have a for every page account, we need to know how many entries are in ref count in x.c. 6. It's so simple that it just has, it just uses a fixed amount of memory, physical memory. We only need to keep account per page of physical memory. We know that from inspecting KNN that XV 6 uses only fizz top amount of physical memory. We only need to keep a count per page, not per byte. So we're going to divide fizz top by 4096. And that's how many array elements we need. In a more serious operating system where we don't know how much memory is available until we inspect the hardware, we might have to, we would have to allocate this array dynamically. 
它只是为每个页面帐户设置一个，我们需要知道x.c中有多少个条目在引用计数中。 6.它是如此简单，以至于它只使用固定数量的内存，物理内存。我们只需要记录每页的物理内存。我们知道，通过检查KNN，XV 6只使用了大量的物理内存。我们只需要保持每页的计数，而不是每字节。所以我们要将顶部的fizz除以4096。这就是我们需要的数组元素数量。在一个更严肃的操作系统中，我们不知道有多少内存可用，直到我们检查硬件，我们可能不得不动态分配这个数组。

发言人   44:21
Any questions about where to put the counts? All right, actually, yes. I'm wondering, is there a reason that you're using 4096 specifically and not the page size macro? Yeah, the reason is that I can remember 4096 and I don't remember the name of the page size macro, but I'm happy to use it if you like. I mean, actually, if if XV 6 was intended to be portable and to be able to run on all kinds of different machines with different page sizes, you have to be much more careful about this. But there's 500 ways in which XV 6 is totally not portable, so. I don't worry about it. 
对于把计数放在哪里有问题吗？好的，实际上，是的。我想知道，你为什么要专门使用4096而不是页面大小宏？是的，原因是我能记住4096，我不记得页面大小宏的名称，但如果你喜欢，我很乐意使用它。我的意思是，实际上，如果XV 6旨在可移植并能够在具有不同页面大小的各种不同机器上运行，那么您必须更加小心。但是XV 6有500种完全不可移植的方式。我不担心这个。


发言人   45:09
Space size is determined in hardware. And I guess where and the hardware that is 5 manual says how big pages? Yeah, because the, it's the MMU that takes a virtual address and uses it to index into the page table. Oh, right, right, because the address translation happens in hardware. So the hardware has to know how big Yeah, pages are. Okay, it's configuring, but there's a couple of different strategies you can tell the hardware to use, but we tell it to use 4096 B pages. 
空间大小由硬件决定。我猜5个手册的硬件和硬件说页面有多大？是的，因为它是一个MMU，它获取一个虚拟地址并使用它来索引到页表中。哦，对的，对的，因为地址翻译发生在硬件中。所以硬件必须知道页面有多大。好的，它正在配置，但有几种不同的策略可以告诉硬件使用，但我们告诉它使用4096 b页面。

发言人   45:49
Okay, sorry for question. So where are I guess this is AC question, so in where are like global variables like ref count stored? Like what, like are they associated with the specific process? Or this is the kernel? What's going on is that the file, the executable file? That the compiler and the loader or linker produces? 
好的，抱歉提问。所以我猜这是交流问题，像引用计数这样的全局变量存储在哪里？就像什么，就像它们与特定过程相关联吗？或者这就是内核？这个文件是怎么回事，这个可执行文件？编译器和加载程序或链接器产生的？

发言人   46:22
Has a sort of? Indicates how much? How the total size of all the global variables in the program? And so we don't see the code for this, but when QM loads the kernel. Well, what's really going on is that when you compile a program called the linker figures out based on it looks at all the global variables and their sizes, and assigns an address in memory to each global variable. And that's where it lives in memory. I mean? And we just arranged that, you know, so the XV 6 kernel uses, I don't know, 10000 B of various global variables. And wherever the boot process loads it into memory, say he address a million, it just. Uses those addresses for the global variables? 
有一种？表示多少？程序中所有全局变量的总大小是多少？所以我们看不到这个的代码，但是当QM加载内核时。实际上，当你编译一个叫做链接器的程序时，它会根据这个程序查看所有的全局变量及其大小，并在内存中为每个全局变量分配一个地址。这就是它存在于记忆中的地方。我是说？我们刚刚安排好了，你知道的，所以XV 6内核使用了，我不知道，10000 B的各种全局变量。无论引导过程在哪里将其加载到内存中，假设他的地址是一百万，它就是这样。使用这些地址作为全局变量？

发言人   47:40
Is this similar to how like there's only one copy of like the instructions for a program on disk and there's only like one copy of the kind of global variables for that program on this? Well? My program is, well I'm not really sure how to answer this. 
这是否类似于磁盘上只有一个指令的副本，并且这个程序只有一个全局变量的副本？好吧？我的程序是，我不太确定如何回答这个问题。

发言人   48:09
When you declare a global variable, like in X, when you compile the compiler and the linker just decide based on who knows what, or it's configurable, but they decide the address for that variable, They decide, all right, boy, x is going to go to address 1000. And then the code that reads a write x, you know, if we have code that says no ref count of zero equals one, you know what that compiled into was just setting the memory at address 1000 or wherever we took linker decided to put ref count, which is does a store to set the memory it address 1000 to 1. 
当你声明一个全局变量时，比如在X中，当你编译时，编译器和链接器只是根据谁知道什么或者它是可配置的来决定，但是他们决定了这个变量的地址，他们决定，好吧，男孩，x将去地址1000。然后是读取write x的代码，你知道，如果我们有代码说没有ref计数0等于1，你知道编译成什么只是将内存设置在地址1000或我们采取链接器决定放置ref计数的地方，这是进行存储以将其地址1000的内存设置为1。

发言人   48:50
Yeah? It's not, it's actually almost exactly the same that happens when you run an ordinary user program. The linker and the compiler decide where memory global variables are. They just read and write there, and it just works. I'm sorry, that's not much of an explanation. All right, so we just define this global array of counts, one per physical page. And we need to modify these counts in various places. Certainly, when we first allocate a page, we're going to say that it has one reference because we return the rest of the page to whoever the whoever called klo. And at the moment, only that program has a reference to this page. So I'm just going to. 
是吗？不是的，实际上它几乎与运行普通用户程序时发生的情况完全相同。链接器和编译器决定内存全局变量的位置。他们只是在那里读和写，而且它就是有效的。对不起，这不是一个很好的解释。好的，所以我们只定义这个计数的全局数组，每个物理页面一个。我们需要在不同的地方修改这些计数。当然，当我们第一次分配一个页面时，我们会说它有一个引用，因为我们将页面的其余部分返回给任何称之为klo的人。目前，只有那个程序引用了这个页面。所以我就这么做。


发言人   49:49
Set the ref count for this page. To be one. So first of all I'm just going to calculate the page number, which is the address of the page divided by 4096. That's the page number. And then I'm going to set the reference count for the page we just allocated to one. 
设置此页面的引用计数。成为一。所以首先，我只是要计算页码，即页面地址除以4096。这是页码。然后我将为刚刚分配给一个的页面设置引用计数。

发言人   50:21
Any questions about this code? 
对这个代码有什么问题吗？

发言人   50:28
Just because I know that I'm going to have bugs with reference counting. I'm actually going to do a little bit of a sanity check here. Just, you know, the reference count really should be 0 if the pages we just allocated a page that was free, boy, you better have a reference count of 0. 
只是因为我知道我会在引用计数方面遇到错误。我实际上要在这里进行一点理智检查。只是，你知道，如果我们刚刚分配了一个免费的页面，那么引用计数真的应该是0，男孩，你最好有一个0的引用计数。

发言人   50:54
Any questions about this code? Right, so in general, we want to increment the reference count when we add A when in copy and write fork adds a page table entry that points to an existing page. And we want to actually, we want to decrement the reference count. As it turns out, in many places, for example, when a process exits, we need to decrement the reference count of all its pages when you call exec, and that frees all the current memory because it's going to replace it. We want to decrement all those reference counts, copy and write page fault happens, and we make a copy. 
对此代码有任何问题吗？正确的，所以通常情况下，当我们在copy和write中添加一个指向现有页面的页表条目时，我们希望在添加时增加引用计数。我们实际上想要减少引用计数。事实证明，在许多地方，例如，当一个进程退出时，我们需要在调用exec时减少其所有页面的引用计数，这将释放所有当前内存，因为它将替换它。我们想要减少所有这些引用计数，复制和写入页面错误发生，然后制作一个副本。

发言人   51:36
We want to decrement a reference count on the old page. It turns out these are all the same places that currently free a page because the current XV 6 thinks there's only ever one reference to each page. So in most of the places we care about where we want to decrement, there's currently a call AK free. So what I'm going to do is modify K free to be have somewhat different semantics and to have k free B sort of a function that decrements the reference count and frees the page only if the reference count has dropped to 0. And that will just automatically fix all the places that call k free. 
我们希望减少旧页面的引用计数。事实证明，这些都是当前释放页面的相同位置，因为当前的XV 6认为每个页面只有一个引用。因此，在我们关心的大多数地方，我们想要减少的地方，目前都有一个免费的呼叫。所以我要做的是将K free修改为具有有所不同的语义，并具有k free B排序的函数，该函数减少引用计数并仅在引用计数降至0时释放页面。这将自动修复所有呼叫k free的地方。


发言人   52:16
All right, so we need to actually do the check before we fill the page with a junk. So this makes the K 3 a little bit more complicated because even though there's a critical section with locks and K 3 already, we can't use it because it happens after the point at which we filled the page with garbage so. We need to lock because we could be freeing the same page at the same time from multiple different cores. Again I'm going to find the page number by dividing the physical address by 4096. I want to panic again. Just a sanity check. Gosh, you know, if we're freeing a page, it better have more than 0 ref counts. 
好的，所以我们需要在用垃圾填充页面之前实际进行检查。因此，这使得K 3变得更加复杂，因为即使已经有一个包含锁和K 3的临界区，我们也无法使用它，因为它发生在我们用垃圾填充页面的点之后。我们需要锁定，因为我们可以同时从多个不同的核心释放同一页面。再次，我将通过将物理地址除以4096来找到页码。我想再次恐慌。只是一个理智检查。天哪，你知道，如果我们要释放一个页面，它最好有超过0的参考文献计数。


发言人   53:15
We need to return if the page has more than one reference count to it. Or actually let's. Decrement the reference count we want to return after we release locks. And so we have to remember a variable. We're going to remember whether the page has more references and then release locks and then return. So I'm going to make a temporary variable which has the. And release. Then say if there's still references to this page, let's just return and not create. And only if the reference count drop is 0, do we free yet. Any questions? 
如果页面有多个引用计数，我们需要返回。或者实际上让我们。在释放锁后，减少我们想要返回的引用计数。所以我们必须记住一个变量。我们将记住页面是否有更多的引用，然后释放锁，然后返回。所以我将创建一个具有的临时变量。和释放。然后说如果仍然有对此页面的引用，让我们返回而不是创建。只有当参考计数下降为0时，我们才会自由。有问题吗？

发言人   53:58
Can you explain again why you have to acquire the Km lock process? Why you have to acquire it at all? Yeah, when you're doing the page number calculations and it's this line. Really, is this line and the next line that the problem? The issue is that on this page we now is likely has more than one reference to it. And so if two processes with a reference to the same with a page table entry point at the same page, if they both exit at the same time on different cores, they're both going to call k free for the same page at the same time. 
你能再次解释一下为什么你必须获得公里锁定过程吗？为什么你必须获得它？是的，当你进行页码计算时，就是这一行。真的，这行和下一行有问题吗？问题是，在这个页面上，我们现在可能有不止一个引用它。因此，如果两个进程在同一页上引用了相同的页表入口点，如果它们同时退出到不同的核心，它们都将同时为同一页调用k free。

发言人   54:38
Yeah, could you just create a new look for the reference count variable and use that as well, yes? Yes, yeah, basically everybody, you know, all code that manipulates these counts needs to use the same block. I don't think it matters what lock it is. Okay, so this takes care of most of the decrements we care about. 
是的，你可以为引用计数变量创建一个新外观并使用它吗？是的，基本上每个人，你知道的，所有操纵这些计数的代码都需要使用同一个块。我认为锁是什么并不重要。好的，这就解决了我们关心的大部分减法。

发言人   55:04
Every time a page is free, we're really going to know only free it If the reference count is falling to 0, we also inc at the reference count. Where do we need to increment the reference count? 
每当一个页面空闲时，我们实际上只知道在引用计数降至0时释放它，我们还包括引用计数。我们需要在哪里增加参考计数？

发言人   55:22
Well, because I know we're going to need to do it and to write the function that anybody can call Again, I want to panic if something is weird. So if the address is wacky, I certainly don't want to. Go beyond the end of the ray. Or if we don't want to increment the reference count of a page whose reference counts currently 0, that's also an error. And I'm just putting these in there because I know from experience with my code that this is exactly the kind of place I'm going to have a bug in. 
嗯，因为我知道我们需要这样做，并编写任何人都可以再次调用的函数，如果出现奇怪的事情，我想恐慌。所以如果地址很古怪，我当然不想。越过射线的末端。或者，如果我们不想增加引用计数当前为0的页面的引用计数，这也是一个错误。我只是把这些放进去，因为根据我的代码经验，这正是我会有一个bug的地方。



发言人   56:25
All right, where should I call increment from? You view VM copy when you? Yeah, I think U Vm's copy is the only place that makes another reference to a page. 
好的，我应该从哪里调用增量？你在什么时候查看VM copy？是的，我认为你的Vm副本是唯一引用页面的地方。


发言人   56:46
All right, gosh, where am I going to put this? Well, that almost doesn't really matter. We're making another reference to PA, so we want to say incre PA. Or likely to run into trouble from the compiler if we don't put a definition for it in trap study age? Whatever, okay? 
好吧，我要把这个放在哪里？好吧，那几乎不重要。我们又提到了PA，所以我们想说incre PA。或者如果我们不在陷阱研究时代定义编译器可能会遇到麻烦？随便，好吗？

发言人   57:18
All right, let's see. 
好的，让我们看看。



发言人   57:39
Well, that was pretty quick. All right, was the K 3 ref. K 3 is unhappy. Okay, well, here's the time. We don't know. This is very early in the boot process, which is maybe a hint at as to what's going wrong, if anybody has any. Guesses I'd be happy to hear them. Meanwhile I'll just fire up the debugger to try to get a back trace. It is during K and it because you're trying to put things into the linked list and you haven't allocated yet. So when you trying to load everything into little link list, you haven't called KL before that. Yeah, that's exactly right. So see that in action here. 
嗯，那相当快。好的，是K 3裁判。K 3不开心。好吧，现在是时候了。我们不知道。这是启动过程的早期阶段，这可能是对出现问题的一个暗示，如果有人有的话。我猜我会很高兴听到它们。同时，我会启动调试器以尝试获取回溯跟踪。它在K和它期间，因为你正在尝试将东西放入链表，但你还没有分配。所以当你试图将所有内容加载到小链接表中时，你还没有调用KL。是的，完全正确。所以在这里看到行动。



发言人   58:31
Okay, I got the panic, I type wear and it's in here's K free being called and panicked and it's being called from free range right at the beginning when we're initializing the free list indeed. So there's something to be fixed in free range. The problem is I'm calling key K free as as you said I'm calling K free. But of course all the reference counts are 0 and k free panics of the reference count is 0. So I'll just. Hack this to be? 
好的，我感到恐慌了，我输入了wear，它在这里被调用并惊慌失措，当我们初始化免费列表时，它从一开始就被调用了。所以在自由范围内有一些东西需要固定。问题是，正如你所说，我叫K免费。但当然所有引用计数都是0，并且引用计数的k次自由恐慌是0。所以我就。破解这个？


发言人   59:11
How about that? 
怎么样？

发言人   59:20
Oh okay, we managed to boot now. I wonder if we're done, let's see. Okay, so let let's run the cow test again. At least we passed this simple test. Aha, so we passed the simple test, which is great. And we passed one time through the three tests, but we didn't, we didn't make it through the second time through three test. And the three tests triggered the print statement that I added to trap, which said cow ka-lok fail, which only would print it if we're out of memory. So we're out of memory. Why are we out of memory? 
好的，我们现在设法启动了。我想知道我们是否完成了，让我们看看。好的，让我们再次运行奶牛测试。至少我们通过了这个简单的测试。所以我们通过了简单的测试，这很棒。我们通过了一次三个测试，但我们没有通过，我们没有通过第二次三个测试。这三个测试触发了我添加到trap的打印语句，该语句说cow ka-lok失败了，只有在内存不足时才会打印它。所以我们没有记忆了。为什么我们的记忆不足？



发言人   01:00:17
So we've updated reference counts every time we've allocated, but we haven't decremented counts whenever we've tried to free, right? So where should I add? With your current approach, I think PA one, that reference count needs to get decremented, so we would need to K free it. Yeah, exactly, so I think somebody actually possibly you brought this up. 
所以我们每次分配时都更新了引用计数，但是每当我们尝试释放时，我们都没有减少计数，对吧？那么我该补充什么呢？使用您目前的方法，我认为引用计数需要减少，因此我们需要释放它。是的，确切地说，我想可能有人提出了这个问题。

发言人   01:00:46
45 minutes ago. Let's see, let's free PA 1 PA 2, Okay? And so now what K free means now is don't is not free this page, it's what K free means is decrement the reference count on this page and free it if it's 0. And so if we're in a simple situation where there was just one fork, and so there were two references to the page, and we've taken a right fault that made a copy, where now all k freeze is going to do is decrement the count to be one. And now the other process can use the page. We're not actually going to free it. Okay, so hopefully now we'll. 
45分钟前。让我们看看，让我们免费PA 1 PA 2，好吗？所以现在K free的意思是不释放这个页面，它的意思是减少这个页面上的引用计数，如果它是0，就释放它。因此，如果我们处于一个简单的情况下，只有一个fork，因此有两个对页面的引用，并且我们已经犯了一个正确的错误，创建了一个副本，现在所有的k冻结将要做的就是将计数减小为1。现在，另一个进程可以使用该页面。我们实际上不会释放它。好的，希望现在我们能。

发言人   01:01:35
Not run out of memory in countest? I love it, okay. We made it through the three test without running out of memory. All right? But we're not done, sadly. We have this interesting error. In the file test, let's take a look at the file test. 
不是内存不足吗？我喜欢它，好的。我们通过了三次测试，而没有耗尽内存。一切都好吗？但遗憾的是，我们还没有结束。我们犯了这个有趣的错误。在文件测试中，让我们来看看文件测试。


发言人   01:02:11
All right, so here's the file test. And it says right on the comment of the test that it's investigating, copy out a good hint of where our problem is going to be. 
好的，这是文件测试。并且它在测试的评论上说它正在调查，复制出一个关于我们的问题将会在哪里的好的提示。


发言人   01:02:23
The thing that actually failed is, I mean, you have to use your imagination a little bit, but the error message seems to be this one printed from two different processes at the same time. And indeed, this is a loop. This test is a loop for four iterations, just forks. And so it's going to produce four concurrent processes. Those error messages will be interleaved. So we need to know why that read failed if we want to understand what the bug is, we need to know why the read failed. The first step is maybe to figure out what the read actually returned. All we know is that it. 
实际上失败的是，我的意思是，你必须发挥你的想象力，但错误信息似乎是同时从两个不同过程打印出来的。实际上，这是一个循环。这个测试是一个四次迭代的循环，只是分叉。因此，它将产生四个并发进程。这些错误消息将被交错处理。因此，如果我们想了解错误是什么，我们需要知道读取失败的原因。第一步可能是弄清楚read实际返回了什么。我们只知道它。

发言人   01:03:03
Returns something other than size of I, but we don't know what it returns. So I'm going to capture the return value. 
返回大小I以外的值，但我们不知道它返回什么。所以我将捕获返回值。

发言人   01:03:15
And I'm going to print the return value at least, no? Oh, I have a question, sorry. It seems like three of the threads failed, but one of them didn't. And he said like it still running, Why is it not failing? Why did the third Fred Kno fail the fourth? Why did the fourth? If you do cow tests and then echo, that other one is still going to be running and you're going to see more output. Yeah, 3 field and went didn't? Let's just finish investigating why any of them failed, and then I can make a guess, although I don't really know why one of them didn't fail. 
我至少要打印返回值，不是吗？哦，我有一个问题，抱歉。似乎有三个线程失败了，但其中一个没有。他说，好像它还在运行，为什么它没有失败？为什么第三个弗雷德·诺失败了，第四个？为什么是第四个呢？如果你进行奶牛测试然后进行回应，另一个仍在运行，你将会看到更多的输出。是的，三个领域没有去吗？让我们完成调查为什么其中任何一个失败了，然后我可以猜测，虽然我真的不知道为什么其中一个没有失败。


发言人   01:04:05
Okay, so what's happening here is that read is returning -1. So why is read returning -1? You might hypothesize that, you know, we we're passing this buffer into read. You might imagine that and read needs to do something, namely called copy out to copy file data into this, into this buff buffer that we pass to read. And maybe something's going wrong with that and its relationship to copy and write fork. So let's take a look at read. And see why it's failing. Try to track down why. 
好的，所以这里发生的事情是read返回-1。那么为什么read返回-1？你可能会假设，我们正在将这个缓冲区传递给读取。您可能会想象，读取需要做一些事情，即称为copy out，将文件数据复制到这个buff缓冲区中，然后传递给读取。也许它出了问题，它与复制和编写分叉的关系。让我们来看看阅读。看看它为什么失败了。试着找出原因。


发言人   01:04:45
All right, so let's capture the what read all sys read does this, the system calls the calls file read after fetching a bunch of arguments. So we'll fix this to take us one step closer to understanding why things are going wrong. We're expecting CC to be -1. 
好的，那么让我们来捕捉一下读取所有sys读取的过程，系统在获取一堆参数后调用文件读取。所以我们将解决这个问题，让我们更接近理解为什么事情会出错。我们预计CC会是-1。


发言人   01:05:19
That's interesting, we never saw CC minus equals -1. In fact, the failure occurred. Failure starts occurring here before we get any corresponding CC print print statements. And it's not -1 at all, it's 4, which is a non failure value. So what that means is that something before the call to file read must have caused, must have trigger this return. So one of these functions here has caused read to return -1. 
有趣的是，我们从未见过CC负等于-1。事实上，失败发生了。在我们获得任何相应的CC打印语句之前，这里失败开始发生。它根本不是-1，它是4，这是一个非故障值。因此，这意味着在调用文件读取之前必须有某些事情引起，必须触发此返回。所以这里的这些函数之一导致了read返回-1。

发言人   01:05:59
Please feel free to guess while I'm typing. This was a complete surprise to me, by the way, when I tracked it down. Oh, I think in the file deor, yeah, the file descriptor I saw, what I expected was that file read was failing due to something and copy out not doing the right thing with copy and write pages. But that is not at all where the failure is. 
请在我打字的时候随意猜测。顺便说一下，当我找到它的时候，这对我来说是一个完全的惊喜。哦，我想在文件deor中，是的，我看到的文件描述符，我所期望的是文件读取由于某些原因而失败，并且复制和写入页面没有做正确的事情。但这根本不是失败的所在。


发言人   01:06:26
Okay, so if we want to find out, like it's either org FD or argan or orga or that's failing, let's start with agfd. I'm just going to stick print statements in here to help me. Figure out which one of these failure cases is actually triggering only two places. It returns -1 and this one. There's something wrong with the FD itself. So we're going to get these print statements on cases where R of d returns -1. 
好的，所以如果我们想找出答案，就像org FD或argan或orga一样，或者失败了，让我们从agfd开始。我只是想在这里粘贴打印语句来帮助我。找出这些失败案例中哪一个实际上只触发了两个地方。它返回-1和这个。FD本身有问题。因此，我们将在d的R返回-1的情况下获取这些打印语句。


发言人   01:07:06
What does this mean if, all right, that we expect these FD printouts to occur just before the error? So what we saw is FD 9, it was FD 9. This causes the error. 
如果我们预计这些FD打印输出会在错误发生之前发生，这意味着什么？所以我们看到的是FD 9，它是FD 9。这会导致错误。

发言人   01:07:22
So FD 9 failed one of these three tests, but we know it's not less than 0. I happen to know it's not greater than equal to no O file for number of open files. And so that means that the O file array for 9 file descriptor 9 must have been zero. That is, in this process, there is no file descriptor 9. So somehow copy on write, test this code in The copy on write test is passing an invalid file descriptor to read. So this files of scriptures comes from Fds. Fds comes from a call to pipe. How could usually pipe? If it doesn't fail? It leaves the file descriptor in the array. So how could this go wrong? 
所以FD 9没有通过这三个测试中的一个，但我们知道它不小于0。我碰巧知道，对于打开的文件数量，它不等于没有O文件。这意味着9文件描述符9的O文件数组必须为零。也就是说，在此过程中，没有文件描述符9。因此不知何故，写时复制，写时复制测试中的此代码被测试传递了一个无效的文件描述符来读取。所以这些经文文件来自Fds。Fds来自对管道的调用。通常怎么可能管？如果它不失败？它将文件描述符保留在数组中。那么这怎么会出错呢？


发言人   01:08:19
Well, we all know the answer has to be blah, blah, blah, Copy out. So what's the missing piece? 
嗯，我们都知道答案必须是等等，等等，抄写出来。那么缺失的部分是什么？

发言人   01:08:38
I mean, I guess like one thing that helped me track this down is I realized at least first of all FD should not be 9 in every iteration. Nine is kind of the value that you would expect kind of at on the last iteration. That's kind of like the highest call. Yeah, they all got 9, right? That's something. They're kind of touching each other's memory. Strange. Yeah, that's exactly right. 
我的意思是，我想有一件事帮助我找到了这个问题，那就是我意识到至少首先，每次迭代FD不应该是9。9是您在上一次迭代中期望的值。这有点像最高的呼声。是的，他们都有9个，对吧？这很重要。他们有点触动了彼此的记忆。奇怪。是的，完全正确。

发言人   01:09:04
So you know, the Fds pipe, the way pipe returns the file descriptors is that it calls copy out to copy the file descriptor number that it's allocated into the caller's address space. Well, we're using copy and write for key if we're not careful, So at least initially, there's just one page, and it's shared among all the processes. So the first process that calls pipe, if something goes wrong, the pipe system call might conceivably write the shared page. And that value, that file descriptor, will then be seen by all the processes instead of just the process that actually allocated the descriptor. So everybody see this as a kind of at least hypothetical risk? 
所以你知道，Fds管道，管道返回文件描述符的方式是它调用copy out来将它分配的文件描述符编号复制到调用方的地址空间中。嗯，如果我们不小心的话，我们会使用copy and write for key，所以至少在最初阶段，只有one page，并且在所有过程之间共享。所以第一个调用管道的进程，如果出现问题，管道系统调用可能会写入共享页面。然后，该文件描述符的值将被所有进程看到，而不仅仅是实际分配描述符的进程。所以每个人都认为这是一种至少是假设的风险？

发言人   01:09:54
So let's look at what try to imagine. So first, let's look at sys file-level. How pipe? Copies out the file descriptors it allocates. And indeed, down here are these two calls to copy out, to copy the two elements of that pipe array. 
让我们来看看尝试想象的是什么。首先，让我们看一下sys的文件级别。管道是什么？复制它分配的文件描述符。实际上，在这里有两个调用来复制，以复制该管道数组的两个元素。


发言人   01:10:19
So pipe is using copy out to copy the file descriptor numbers into the array and user space, so what does copy-out do? Well, it looks up the virtual address to find a physical address and then? It writes cop it over that physical address, that's it. The one thing it is not doing is checking for write permission doesn't look at PTW. And so with this page, this virtual address refers to a copy on write shared page. Copy out just has no idea. It just goes ahead and writes it. And so that means, indeed, when pipe calls copy out, it's going to be writing a shared page that all of the forked processes see this modification, not just the process, the call pipe. 
所以管道使用copy out将文件描述符号复制到数组和用户空间中，那么copy-out做什么呢？嗯，它会查找虚拟地址以查找物理地址，然后？它在那个物理地址上写了cop，就这样。它没有做的一件事是检查写入权限，而不看PTW。因此，在这个页面中，这个虚拟地址指的是写入共享页面上的一个副本。复制出来只是没有想法。它只是继续写下去。这意味着，实际上，当管道调用复制出去时，它将编写一个共享页面，所有分叉的进程都可以看到这种修改，而不仅仅是进程，调用管道。


发言人   01:11:15
Any questions about why this is happening? 
对为什么会发生这种情况有疑问吗？

发言人   01:11:25
Okay? All right, so as you all know, we need some modify copy out to since copy out is looking up a virtual address and translating into a physical address, but it is not using the MMU, so the MMU doesn't catch the right fault because the m.u. is not involved. A walk at or looks at the page table itself instead of basically getting there and you to look at the page table for it. Okay, so we need to modify copy out. We don't want to call, walk at or walk at or just produces a physical address. We actually want the page table entry because we want to look at the permission bits to see if it's a copy and write a write protected page. So we're going to call walk instead. 
好吗？好的，正如你们所知，我们需要对复制进行一些修改，因为复制是在查找一个虚拟地址并将其转换为物理地址，但它没有使用MMU，因此MMU无法捕捉到正确的错误，因为m.u。 不涉及。漫步或查看页表本身，而不是基本上到达那里，你需要查看页表。好的，所以我们需要修改副本。我们不想打电话，走在或只是产生一个物理地址。我们实际上想要页表条目，因为我们想查看权限位，以查看它是否为副本并写入受写入保护的页面。所以我们要改为叫步行。

发言人   01:12:20
We need to check all the usual errors. So maybe there's no mapping at all. Maybe it's not a valid mapping, or maybe it's mapping that the user code is not allowed to use. And in all those cases, it's an error. But this time, we can actually return an error, which we'll call it just read to return -1 instead of killing the process. So that's nice. Next, we need to know how to check whether it's a copy on write page. Any any ideas for how we can. Check whether we should apply copy, whether we should do a copy at this point. 
我们需要检查所有常见错误。所以可能根本没有映射。可能它不是有效的映射，或者可能是用户代码不允许使用的映射。在所有这些情况下，这是一个错误。但这一次，我们实际上可以返回一个错误，我们将其称为read返回-1而不是终止进程。这很好。接下来，我们需要知道如何检查它是否是写入页面上的副本。任何关于我们如何能做到的想法。检查我们是否应该应用复制，此时是否应该复制。


发言人   01:13:11
What's different about between copy and write pages and just sort of ordinary unshared pages? With the reference count, be large. That's a good point. If the reference count was. Greater than one? That's certainly be a very strong hint. That's a copy of a right page. But if the reference count is one, does that mean it's not a copy and write page? 
复制和写入页面与普通的非共享页面有什么不同？对于参考计数，应该很大。这是一个很好的观点。如果引用计数为。大于一？这无疑是一个非常强烈的暗示。这是右页的副本。但如果引用计数是一，这是否意味着它不是一个复制和写入页面？

发言人   01:13:45
It turns out if you fork and the child takes a copy and write fault and makes a copy, that reduces the reference count to one, but the page is still right protected in the parent. And actually, probably we could get away with modifying in that case. So I think we actually could check the reference count and only treat it as a copy and write page if the reference count is greater than 0. But what I'm going to do is a different, an even even shortcut and say it the page is write protected. The only way a page can be right protected and have the Pte you bit set and this version of XV 6 is if it's a copy on white page. So this will see a little bit of typing compared to checking the reference count. 
事实证明，如果您fork并且子级发生了copy和write错误并复制了一份，这会将引用计数减少到一，但该页面在父级中仍然受到保护。实际上，在这种情况下，我们可能可以通过修改来逃脱。所以我认为我们实际上可以检查引用计数，只有在引用计数大于0时才将其视为复制和写入页面。但是我要做的是一个不同的，均匀的快捷方式，说页面是写保护的。唯一的方法是对一个页面进行正确保护并设置Pte，这个版本的XV 6是在白页上的副本。因此，与检查引用计数相比，这将会看到一点点打字。


发言人   01:14:38
We already wrote the code to deal with this in trap DOC. So I'm just going to call that code from here. We still have to deal with the possible error return if it's a. A crazy address. Oh, actually, we don't. 
我们已经在陷阱文档中编写了处理这个问题的代码。所以我只是要从这里调用那个代码。如果是，我们仍然必须处理可能的错误返回。一个疯狂的地址。哦，实际上，我们不知道。


发言人   01:15:12
All right? All right, so if the page is not writable, we're just going to call copy and write fault. And copy and write fault, you know, does the copy, and it makes the page writable. So I think we're. Almost done at this point. However, if copy CW fault did make a. 
一切都好吗？好的，所以如果页面不可写，我们就调用copy和write fault。复制和写入错误，你知道，进行复制，它使页面可写。所以我认为我们是。此时几乎完成了。但是，如果复制的CW故障确实产生了a。


发言人   01:15:41
We got to get rid of this. If CW Fault did make a copy, it's going to have modified the physical address in the page table entry. So we have to pull that physical address out of the page table entry again in case it was changed. I'm just going to do that since we have the. Page table entry right here. And I think this is more or less enough. So any questions about the modification to copy out? All right, I got to make a global declaration for COO fault. 
我们必须摆脱这个。如果CW故障确实创建了副本，它将修改页表条目中的物理地址。所以我们必须再次从页表条目中提取该物理地址，以防它被更改。我打算这么做，因为我们有了。页表条目就在这里。我认为这或多或少已经足够了。那么对于复制的修改有什么问题吗？好的，我得对原产地证明的错误发表一份全球宣言。

发言人   01:16:37
Beautiful. 
美丽。


发言人   01:16:43
All right, that's looking great. Anybody happen to know if we're done? 
好的，看起来不错。有人碰巧知道我们是否完成了吗？

发言人   01:16:57
We may or may not be. We also have to pass user tests. Oh, all right. Let me get rid of this. It's print statements. 
我们可能是，也可能不是。我们还必须通过用户测试。哦，好吧。让我摆脱这个。这是印刷声明。


发言人   01:17:25
I think the exec out test intentionally allocates a lot of memory. All right, any questions while we? Wait for the verdict from user tests. Aha, okay. User test was unhappy. I think this is a familiar piece of damage which somebody has brought up already. It's the. It's the panic and walk. If the user process, the user test actually, I think does intentionally, we'll take a look at user tests. 
我认为exec out测试故意分配了大量内存。好的，我们有问题吗？等待用户测试的结果。好吧。用户测试不满意。我认为这是已经有人提出的一个熟悉的损害。就是这个。它是恐慌和步行。如果用户过程，实际上是用户测试，我认为是有意的，我们会看一下用户测试。


发言人   01:18:09
And it's the copy out test. And it even says in the comment, it passes ridiculous pointers to system calls. All right, so what we're faced with is copy out. We pass in a ridiculous pointer. It simply calls walk with that ridiculous pointer, and walk panics if you give it a ridiculous pointer so. As somebody mentioned, we need to not call walk with ridiculous pointers. What is it max VA or something? Of course, we're totally entitled to return an error if the user process passes us to the out of bound pointer. 
这是复制测试。它甚至在评论中说，它将荒谬的指针传递给系统调用。好的，所以我们面临的是复制出来。我们传递了一个荒谬的指针。它只是简单地称之为带着那个荒谬的指针行走，如果你给它一个荒谬的指针，走路会感到恐慌。正如有人提到的，我们不需要用荒谬的指针来称呼步行。什么是max VA或其他什么？当然，如果用户进程将我们传递给超出绑定的指针，我们完全有权返回错误。


发言人   01:19:00
Right I'm i.m. just hoping it passes now. I'm not aware of any other problems. 
对，我是I.m. 只是希望它现在通过。我不知道还有其他问题。

发言人   01:19:09
Okay, questions? I guess my question is more broad, like we saw when we were doing that with small steps, we're getting random bugs at point at I have. If you're doing the lab from scratch, then wouldn't it be confusing to get all of those weird bugs? And how would, how do you, how do you know whether it's a bug with something you wrote or about? Because you didn't write the rest of it? I'm afraid I can not answer your question. 
好的，有问题吗？我想我的问题更广泛，就像我们看到的那样，当我们一步一步地做这件事时，我们在我有随机错误。如果你从头开始做实验室，那么得到所有这些奇怪的虫子不会令人困惑吗？以及如何，你如何知道它是否是你写的东西的错误？因为剩下的部分不是你写的？恐怕我无法回答你的问题。



发言人   01:19:52
The sad truth about bugs, particularly bugs caused by doing funny things to page tables inside the kernel, is that every, you know, every bug. Is different and how you know, what turns out to be the winning strategy for tracking a bug down? It just depends totally on the nature of the bug. You know, my usual, you know, I have some, I have a sort of a collection of strategies that are sometimes helpful and sometimes not, like I'm a huge believer. 
关于bug的悲哀真相，尤其是由于在内核中做了有趣的事情分页表而引起的bug，是每一个bug。是不同的，你怎么知道，追踪错误的成功策略是什么？这完全取决于bug的性质。你知道，我平常有一些，我有一些策略的集合，有时是有帮助的，有时不是，就像我是一个巨大的信徒。

发言人   01:20:26
I'm putting print statements into the code in order to gather information or to verify hypotheses. I'll often spend time just looking at the code just for the purpose of generating, sort of brainstorming with myself to just try to generate, you know, things that could possibly be going wrong at this point and then put print statements in or panics or something to try to rule in or rule out various guesses at what the problem might be. Another possibility is that you know, you've made some, you know, your code worked or didn't show this error or something, you know, half an hour ago and then you made some changes and now you have some bug, so another possibility is to if you can back up to a version of the code that didn't have the bug and sort of add your changes bit by bit until the bug shows up. None of these are, I don't know, any strategy that always works or even works more than a fraction of the time. But the truth is, part of what you're learning in this class, as well as learning about operating systems. You know, you're getting experience writing and debugging code. Sorry not to be more helpful. Other questions? 
我正在将打印语句放入代码中，以收集信息或验证假设。我经常花时间只是为了生成代码，与自己进行头脑风暴来尝试生成，你知道的，此时可能会出错的事情，然后放入打印语句或恐慌或其他东西，试图排除或排除对问题可能是什么的各种猜测。另一种可能性是，你知道，你已经做了一些，你知道，你的代码工作或没有显示这个错误或其他什么，你知道，半小时前你做了一些更改，现在你有一些错误，因此，另一种可能性是，如果您可以备份到没有错误的代码版本，并逐步添加您的更改，直到错误出现。这些都不是，我不知道，任何总是有效甚至不止是一小部分时间有效的策略。但事实是，你在这门课上学到的一部分，还有学习操作系统的知识。你知道，你正在获得编写和调试代码的经验。很抱歉不能提供更多帮助。其他问题？

发言人   01:21:52
All right, we're at that end of class time. I'm happy to talk more, but we're done with the formal part of this class. All right, and just see you all on Wednesday. Oh, sorry, I actually have another question when we were seeing our first. Right, fault. We also saw after that for the shell, illegal instruction fault and then something for the unit process, what was that? 
好的，我们已经到了上课时间的最后。我很乐意谈论更多，但我们已经完成了本课程的正式部分。好的，请在星期三见到你们。哦，抱歉，当我们第一次见面时，我有另一个问题。对，错。我们之后也看到了shell的非法指令错误，然后是单元进程的一些东西，那是什么？

发言人   01:22:40
Well? 
好吧？

发言人   01:22:47
I don't have a theory. The init process I don't think would share pages with anything, I just don't know. I'm sorry, we could, I would have to back up, but this happened very early when I was doing the lab right? We just had a copy of the page table and nothing else. I think it was a like escort F for the shell and I think Escort C for the init process. All right, all right. Let me, let's see if you really, let's see, let's see, we can. Let's reconstruct. 
我没有理论。我认为init进程不会与任何东西共享页面，我只是不知道。对不起，我们可以，我需要备份，但这发生在我做实验室的时候，对吗？我们只有一个页表的副本，没有其他的了。我认为这就像是外壳的护送F，而我认为是init进程的护送C。好的，好的。让我看看你是否真的，让我们看看，让我们看看，我们可以。让我们重建。

发言人   01:23:40
The lab from scratch. So I'm going to clone. 
从零开始的实验室。所以我要克隆。

发言人   01:24:07
Okay, at this point we had made, just made. Changes to UV and copy, right? So we were. What are we not doing here? We're not allocating and we're not doing MMO. But we are. We're going to pass PA to map pages. And well, I think the very was the very first time I ran anything like this was the state of play. It was after we did the flag. So, so okay. 
好的，在这一点上我们已经做了，刚刚做了。更改紫外线和复制，对吗？所以我们是。我们不在这里做什么？我们没有进行分配，也没有进行MMO。但我们是。我们将把PA传递给地图页面。而且，我认为这是我第一次跑这样的比赛，这是比赛的状态。这是在我们做了旗帜之后。所以，好吧。


发言人   01:24:55
All right, so let's clear. And. 
好的，那么让我们明确一下。而且。

发言人   01:25:11
Does that look good? 
看起来不错吗？


发言人   01:25:35
All right, we got AC? Well, let's CCIs instruction page fault this, okay? So s calls two, you know, is, you know, we think shared in process ID 2. Oh man, you write is process ID 1? 
好的，我们有交流吗？那么，让CCIs指令页面出错，好吗？所以调用两个，你知道，是，你知道，我们认为在过程账号2中共享。哦，伙计，你写的是过程账号1？

发言人   01:26:00
I just don't have a theory for y process ID 1. Way to run. Its control is let's look at what in Itt does. 
我只是没有一个关于y过程账号1的理论。跑步的方式。它的控制让我们看看in Itt是做什么的。

发言人   01:26:14
This in it. 
这个在里面。


发言人   01:26:22
What is compassion called? 
同情被称为什么？

发言人   01:26:33
Okay, it exacts the shell. I don't know? You know, okay, Oh, here's an idea. Process ID 2 has taken a fault and it's exited. So you do fork later like right? And so that means that this weight in A, it has returned, right? And so it's going to go back around the loop and call a fork again. And so, you know, after a fork, we're now sharing and, you know, depending on all this damage code. Oh, okay, I see, okay. Yeah, that's, that's very confusing. Oh yeah, these errors are just like complete bananas because we violated all sorts of intuitions about how things should work, okay? Anything. 
好的，这确实是外壳。我不知道？你知道，好吧，哦，这里有一个想法。进程账号2出现故障，已退出。所以你以后要做叉子，对吧？这意味着A中的这个重量，它已经返回了，对吗？因此，它将绕过循环再次调用分叉。所以，你知道，分叉之后，我们现在正在分享，你知道，这取决于所有这些损坏的代码。哦，好的，我明白了，好的。是的，那非常令人困惑。是的，这些错误就像完全的香蕉一样，因为我们违反了关于事情应该如何运作的各种直觉，好吗？任何事情。
