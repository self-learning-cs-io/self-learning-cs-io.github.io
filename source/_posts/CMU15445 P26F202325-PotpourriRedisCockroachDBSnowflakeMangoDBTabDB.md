---
title: CMU15445 P26F202325 PotpourriRedisCockroachDBSnowflakeMangoDBTabDB
---

1
00:00:00,000 --> 00:00:04,179
Dont stop.

2
00:00:04,179 --> 00:00:07,379
Good luck!

3
00:00:07,379 --> 00:00:22,300
Good luck!

4
00:00:22,300 --> 00:00:24,900
Dri masturbate and circuitedوا

5
00:00:24,900 --> 00:00:27,260
ride out to take your parts

6
00:00:27,260 --> 00:00:27,960
please

7
00:00:27,960 --> 00:00:30,960
How you doing?

8
00:00:30,960 --> 00:00:31,960
I'm doing well.

9
00:00:31,960 --> 00:00:33,960
I think a lot of things here today.

10
00:00:33,960 --> 00:00:39,960
And by the way, so DTHPL's agent sent over his glossies.

11
00:00:39,960 --> 00:00:42,960
So he's signing autographs if you want with him afterwards.

12
00:00:42,960 --> 00:00:44,960
So we have enough for everyone.

13
00:00:44,960 --> 00:00:45,960
So it's a nice photo.

14
00:00:45,960 --> 00:00:46,960
Yeah, it's pretty nice.

15
00:00:46,960 --> 00:00:47,960
Yeah.

16
00:00:47,960 --> 00:00:49,960
Yeah, your agent is very aggressive.

17
00:00:49,960 --> 00:00:50,960
He's got to sign autographs.

18
00:00:50,960 --> 00:00:51,960
It's a class.

19
00:00:51,960 --> 00:00:52,960
It's kind of weird.

20
00:00:52,960 --> 00:00:53,960
But whatever.

21
00:00:53,960 --> 00:00:54,960
All right.

22
00:00:54,960 --> 00:00:55,960
All right, guys.

23
00:00:55,960 --> 00:00:56,960
A lot to cover.

24
00:00:56,960 --> 00:00:58,960
So let's finish up.

25
00:00:58,960 --> 00:01:02,960
So for the major thing on the doc, if you guys other than the final exam,

26
00:01:02,960 --> 00:01:04,960
again, is Project 4.

27
00:01:04,960 --> 00:01:06,960
It's going to be due this Monday at midnight.

28
00:01:06,960 --> 00:01:10,960
And then we're having the extra office hours on Saturday,

29
00:01:10,960 --> 00:01:12,960
on the fourth floor in gates.

30
00:01:12,960 --> 00:01:13,960
OK?

31
00:01:13,960 --> 00:01:16,960
Who here has not started Project 4?

32
00:01:16,960 --> 00:01:17,960
Really?

33
00:01:17,960 --> 00:01:18,960
Bold.

34
00:01:18,960 --> 00:01:20,960
OK.

35
00:01:20,960 --> 00:01:22,960
That's not a good idea.

36
00:01:22,960 --> 00:01:23,960
OK.

37
00:01:23,959 --> 00:01:24,959
All right.

38
00:01:24,959 --> 00:01:26,959
Any high level questions about Project 4?

39
00:01:26,959 --> 00:01:27,959
Yes.

40
00:01:27,959 --> 00:01:29,959
You can use the idea of Project 4.

41
00:01:29,959 --> 00:01:30,959
Yes.

42
00:01:30,959 --> 00:01:35,959
I mean, we set the due date because the university policies that we're not supposed

43
00:01:35,959 --> 00:01:37,959
to have anything due during the finals week.

44
00:01:37,959 --> 00:01:39,959
I did it one year ago in trouble.

45
00:01:39,959 --> 00:01:40,959
So yeah.

46
00:01:40,959 --> 00:01:43,959
Any other questions?

47
00:01:43,959 --> 00:01:44,959
Yes.

48
00:01:44,959 --> 00:01:50,959
Is this a project called on the plan and used in subsequent phases?

49
00:01:50,959 --> 00:01:54,959
Because it's, I feel like, the most type of student project on all of it.

50
00:01:54,959 --> 00:01:57,959
His state of it is, is Project 4 going to be used in previous semesters?

51
00:01:57,959 --> 00:02:00,959
Because it's the most time consuming of all the projects you've done so far.

52
00:02:00,959 --> 00:02:01,959
Yeah.

53
00:02:01,959 --> 00:02:03,959
We were, the plan is yes.

54
00:02:03,959 --> 00:02:07,959
We probably will use it in subsequent semesters.

55
00:02:07,959 --> 00:02:10,959
We try to dial down down the complexity quite a bit.

56
00:02:10,959 --> 00:02:13,959
This is sort of why we give you the test ahead of time, why we said,

57
00:02:13,959 --> 00:02:17,959
OK, here's all this extra bonus stuff you could do if you wanted to.

58
00:02:18,960 --> 00:02:21,960
But we'll see how it goes and we will adjust accordingly.

59
00:02:21,960 --> 00:02:22,960
Yes.

60
00:02:22,960 --> 00:02:25,960
I just remind you to talk about some things that we can find out.

61
00:02:25,960 --> 00:02:26,960
That'll be later at the end.

62
00:02:26,960 --> 00:02:27,960
I didn't forget.

63
00:02:27,960 --> 00:02:29,960
There's slides on that.

64
00:02:29,960 --> 00:02:30,960
There's some things you brought up here.

65
00:02:30,960 --> 00:02:32,960
I'll tell you what we discussed in that.

66
00:02:32,960 --> 00:02:33,960
What we'll discuss at the end.

67
00:02:33,960 --> 00:02:34,960
All right.

68
00:02:34,960 --> 00:02:36,960
The question about Project 4.

69
00:02:36,960 --> 00:02:37,960
All right.

70
00:02:37,960 --> 00:02:38,960
Cool.

71
00:02:38,960 --> 00:02:41,960
So again, reminder, and we'll post us a few apps again.

72
00:02:41,960 --> 00:02:44,960
If you like databases a lot, you like this class.

73
00:02:44,960 --> 00:02:48,960
Or you think bus stop is terrible and you want to rewrite a lot of it.

74
00:02:48,960 --> 00:02:51,960
Gignette is teaching this next semester in the spring.

75
00:02:51,960 --> 00:02:55,960
So if you're going to be around in one of the TA, by all means, please sign up.

76
00:02:55,960 --> 00:02:58,960
And again, you don't have to be like, gee,

77
00:02:58,960 --> 00:03:01,960
gee is violating labor laws sometimes.

78
00:03:01,960 --> 00:03:04,960
And we don't want to do that.

79
00:03:04,960 --> 00:03:07,960
So don't, I've had two people come to me like, yeah, I want to be a TA.

80
00:03:07,960 --> 00:03:09,960
But do I have to be like, gee, and there's no.

81
00:03:09,960 --> 00:03:10,960
OK.

82
00:03:10,960 --> 00:03:11,960
The kids are freak.

83
00:03:11,960 --> 00:03:12,960
He might be on cocaine.

84
00:03:12,960 --> 00:03:15,960
But he's graduating.

85
00:03:15,960 --> 00:03:16,960
All right.

86
00:03:16,960 --> 00:03:18,960
Any questions about this?

87
00:03:18,960 --> 00:03:19,960
All right.

88
00:03:19,960 --> 00:03:21,960
So the other thing, too, also, will pistols and piata.

89
00:03:21,960 --> 00:03:22,960
Your feedback is strongly needed.

90
00:03:22,960 --> 00:03:26,960
So the point he has brought up, hey, Project 4 is way too hard relative to the other projects.

91
00:03:26,960 --> 00:03:28,960
It used to be Project 2 was too hard.

92
00:03:28,960 --> 00:03:30,960
And then we try to be balancing.

93
00:03:30,960 --> 00:03:32,960
So we do listen to feedback.

94
00:03:32,960 --> 00:03:34,960
And we went to your opinion about everything.

95
00:03:34,960 --> 00:03:37,960
Now, for undergrads, I don't need to explain to you what's like the right course feedback.

96
00:03:37,960 --> 00:03:39,960
It's for the master students.

97
00:03:39,960 --> 00:03:40,960
You guys are terrible.

98
00:03:40,960 --> 00:03:44,960
I'm not saying you, anybody in particular, but every year the master students like, this class is great.

99
00:03:44,960 --> 00:03:45,960
This class is great.

100
00:03:45,960 --> 00:03:46,960
This class is great.

101
00:03:46,960 --> 00:03:50,960
Whereas the undergrads go in very details and a lot of these are about what things are wrong and what we can do better.

102
00:03:50,960 --> 00:03:52,960
So if you're a master student, please be brutal.

103
00:03:52,960 --> 00:03:53,960
It's a non-nose.

104
00:03:53,960 --> 00:03:54,960
I can't see it.

105
00:03:54,960 --> 00:03:55,960
We don't see names.

106
00:03:55,960 --> 00:03:58,960
So by all means, if things are, you want to do things better, let us know.

107
00:03:58,960 --> 00:03:59,960
OK.

108
00:03:59,960 --> 00:04:07,960
And again, if you're not graduating, come make suggestions in the course feedback and then come in the spring of BTA and fix things for future people.

109
00:04:08,960 --> 00:04:14,960
For office hours leading up to the final exam, I'm moving mine to be on Monday at 9.30 in the morning over Zoom.

110
00:04:14,960 --> 00:04:17,960
Tignesh is actually with his wife right now.

111
00:04:17,960 --> 00:04:19,960
So he's not going to be on campus for less of a semester.

112
00:04:19,960 --> 00:04:22,960
So his office hours also be a noon or so over Zoom.

113
00:04:22,960 --> 00:04:27,960
If you want to meet with me, beyond these hours, please send an email and I will try to accommodate you.

114
00:04:27,960 --> 00:04:28,960
OK.

115
00:04:28,960 --> 00:04:31,960
And then the TAs will hold the regular office hours up to and including this Friday.

116
00:04:32,959 --> 00:04:40,959
They will have the project for office hours on Saturday and then there won't be any office hours from the TAs starting next week.

117
00:04:40,959 --> 00:04:41,959
OK.

118
00:04:41,959 --> 00:04:43,959
All right.

119
00:04:43,959 --> 00:04:44,959
So the final exam.

120
00:04:44,959 --> 00:04:46,959
Who has to take it?

121
00:04:46,959 --> 00:04:48,959
Anyone in the role in the class?

122
00:04:48,959 --> 00:04:51,959
It's going to be in positive 153.

123
00:04:51,959 --> 00:04:52,959
I'll explain how this is going to work yet.

124
00:04:52,959 --> 00:04:53,959
We actually have three locations.

125
00:04:53,959 --> 00:04:55,959
We'll see how it's going to be that up.

126
00:04:55,959 --> 00:04:58,959
That'll be next Tuesday, 8.30 a.m.

127
00:04:58,959 --> 00:05:01,959
And go watch that video to understand why.

128
00:05:01,959 --> 00:05:03,959
If you need a special combination, some of you have already done this.

129
00:05:03,959 --> 00:05:09,959
If you haven't yet, please do this as soon as possible so that way we have time to prepare and work with the disability office.

130
00:05:09,959 --> 00:05:17,959
And then the, I'll put this on the computer after the class, but the final guide for the exam.

131
00:05:17,959 --> 00:05:21,959
And the practice exam is available on the website now.

132
00:05:21,959 --> 00:05:22,959
All right.

133
00:05:22,959 --> 00:05:29,959
So if you ever looked at the, the, the, the CMU schedule for the final exams, we're actually assigned three classrooms.

134
00:05:29,959 --> 00:05:33,959
We're in Posner and then the Hall of Arts and then two different rooms.

135
00:05:33,959 --> 00:05:39,959
So when everyone to show up at Posner 153, which is the big building, they're starting the big room, show up there.

136
00:05:39,959 --> 00:05:42,959
We will then assign you to a random location so that we can spread out.

137
00:05:42,959 --> 00:05:43,959
Posner is the bigger one.

138
00:05:43,959 --> 00:05:47,959
Most of you guys would be in there, but we'll just randomly spread out across the different rooms that are close to each other.

139
00:05:47,959 --> 00:05:53,959
And there'll be two TAs in every single room and then myself, I'll be bouncing around asking questions and helping as, as we go along.

140
00:05:53,959 --> 00:05:54,959
Okay.

141
00:05:54,959 --> 00:06:00,959
So again, everyone show up to Posner, one key to three and then we'll figure out where do you go after that?

142
00:06:00,959 --> 00:06:03,959
The rooms are as far as I know, they're, they're close to each other.

143
00:06:03,959 --> 00:06:04,959
Okay.

144
00:06:04,959 --> 00:06:05,959
All right.

145
00:06:05,959 --> 00:06:06,959
So what to bring.

146
00:06:06,959 --> 00:06:09,959
Obviously, we need your CMU ID, bring a pencil and an eraser.

147
00:06:09,959 --> 00:06:15,959
You can take the exam and a pen if you want to, but then you're going to scratch things out and it's going to be huge pain for us to deal with.

148
00:06:16,959 --> 00:06:19,959
So please, be a pencil, please, be an eraser.

149
00:06:19,959 --> 00:06:21,959
You may need a calculator.

150
00:06:21,959 --> 00:06:24,959
Using your cell phone is sufficient because most of you don't have single calculators.

151
00:06:24,959 --> 00:06:31,959
And then you can bring one sheet of notes double-sided and they had to be handwritten, just like you had in the midterm exam.

152
00:06:31,959 --> 00:06:35,959
One year, K was hacking HFT theme clothing.

153
00:06:35,959 --> 00:06:39,959
This is two years ago when that was a thing.

154
00:06:39,959 --> 00:06:41,959
Actually, I take that.

155
00:06:41,959 --> 00:06:42,959
I don't care if you want to.

156
00:06:42,959 --> 00:06:43,959
I waste your money on NFT clothing.

157
00:06:43,959 --> 00:06:44,959
That's, that's your problem.

158
00:06:44,959 --> 00:06:45,959
Okay.

159
00:06:45,959 --> 00:06:46,959
But you can bring food.

160
00:06:46,959 --> 00:06:49,959
We'll have fee and donuts for everyone as well early in the morning.

161
00:06:49,959 --> 00:06:51,959
All right.

162
00:06:51,959 --> 00:06:55,959
All right. So what will be on the exam in terms of everything that was before the midterm.

163
00:06:55,959 --> 00:06:57,959
Obviously, you need to know SQL.

164
00:06:57,959 --> 00:07:03,959
If you've forgotten SQL at this point after homework one and other things, then you have other problems.

165
00:07:03,959 --> 00:07:05,959
But everyone should have basic understanding of SQL.

166
00:07:05,959 --> 00:07:07,959
So if we show you SQL query, you understand what it's doing.

167
00:07:07,959 --> 00:07:12,959
You obviously need to know what the Buffalo manager is doing because in the context of logging recovery,

168
00:07:12,959 --> 00:07:16,959
how do you know when things are allowed to be written out the disk.

169
00:07:16,959 --> 00:07:20,959
You need to understand basic data structures, hash trees, people's trees, when to use one versus the other.

170
00:07:20,959 --> 00:07:22,959
The storage model is column storage.

171
00:07:22,959 --> 00:07:23,959
This is row stores.

172
00:07:23,959 --> 00:07:26,959
And how much data is going to get moved around potentially if it's in an instrument environment.

173
00:07:26,959 --> 00:07:28,959
Query processing models.

174
00:07:28,959 --> 00:07:32,959
What are the actual operators themselves when they're pushing or pulling data up?

175
00:07:32,959 --> 00:07:36,959
Are they sending batches, vectors, or entire results set?

176
00:07:36,959 --> 00:07:39,959
And then basic interquery parallelism.

177
00:07:39,959 --> 00:07:42,959
Like there's an exchange operator you would use to combine things.

178
00:07:42,959 --> 00:07:43,959
Sorry, that's interquery.

179
00:07:43,959 --> 00:07:46,959
Interquery parallelism, the multiple queries, running at the same time.

180
00:07:46,959 --> 00:07:48,959
What are the implications of that?

181
00:07:48,959 --> 00:07:53,959
All right. So the basic high level information need to know from before the midterm.

182
00:07:53,959 --> 00:07:56,959
For the things that we did cover the midterm going forward,

183
00:07:56,959 --> 00:07:59,959
you know, understand basics about query optimization.

184
00:07:59,959 --> 00:08:02,959
We obviously only had one lecture on this and it's a very complicated topic.

185
00:08:02,959 --> 00:08:10,959
So we can't go into too much detail, but it's basic information about what are the implications of doing predicate pushdown into query plan or projection pushdown.

186
00:08:10,959 --> 00:08:16,959
Or how can you rewrite a sub query to pull things out and execute it as a join?

187
00:08:16,959 --> 00:08:20,959
We're obviously not going to ask you to derive an algorithm that does that because it's hard,

188
00:08:20,959 --> 00:08:23,959
but at high level, what does that actually look like?

189
00:08:23,959 --> 00:08:28,959
We talked about basic information about collecting statistics, cardinality, estimations, histograms.

190
00:08:28,959 --> 00:08:33,960
Again, we can't obviously go into too much detail, but you can understand this at a high level.

191
00:08:33,960 --> 00:08:36,960
And then what are the implications of something using a cost-based search?

192
00:08:36,960 --> 00:08:42,960
Like how would that plug in with one of these cost models to determine the correct join order, for example?

193
00:08:42,960 --> 00:08:47,960
And then you can see how you can fuse this synthesize this knowledge with the distributed basis later on.

194
00:08:47,960 --> 00:08:50,960
And understand that the cost model will have to include moving data across the network.

195
00:08:50,960 --> 00:08:55,960
So again, high level things like this, not specific formulas.

196
00:08:55,960 --> 00:08:58,960
We spent a lot of time talking about transactions.

197
00:08:58,960 --> 00:09:04,960
So the first sort of set of lectures, or the first lecture was on what we'll call the theory of transactions, concurrently control.

198
00:09:04,960 --> 00:09:08,960
Like what does it mean for a database system to say it provides asset guarantees,

199
00:09:08,960 --> 00:09:12,960
animosity, consistency, isolation, and durability?

200
00:09:12,960 --> 00:09:15,960
And again, when it was a single node, consistency didn't quite make sense.

201
00:09:15,960 --> 00:09:22,960
It made some more sense in the distributed environment, but certainly animosity, isolation, and durability mattered a lot on a single node.

202
00:09:22,960 --> 00:09:26,960
Then we spent time talking about conflict sterilized ability and view sterilized ability.

203
00:09:26,960 --> 00:09:32,960
Again, high level concepts and ideas, not necessarily the protocols we'd use to support them.

204
00:09:32,960 --> 00:09:33,960
That comes later.

205
00:09:33,960 --> 00:09:37,960
So how would you determine whether a schedule is correct?

206
00:09:37,960 --> 00:09:38,960
Is conflict sterilizable?

207
00:09:38,960 --> 00:09:43,960
And how can you determine whether two different schedules are conflict equivalent?

208
00:09:43,960 --> 00:09:44,960
And then view sterilized ability.

209
00:09:44,960 --> 00:09:51,960
The main thing is understanding what is the difference of view sterilized ability in terms of what the application sees.

210
00:09:51,960 --> 00:09:58,960
In terms of correctness and the ordering of operations in a schedule relative to conflict sterilized ability.

211
00:09:58,960 --> 00:09:59,960
Right.

212
00:09:59,960 --> 00:10:09,960
In the case of like view sterilized ability, it was about you could reorder things and you still end up the client still end up seeing the same result.

213
00:10:09,960 --> 00:10:15,960
And again, if a node system implements view sterilized ability, you could need to understand what does correct mean to the application.

214
00:10:15,960 --> 00:10:19,960
And that's not something any did to some can reason about now.

215
00:10:19,960 --> 00:10:25,960
We talked about recoverable schedules and then we talked about isolation levels and anomalies.

216
00:10:25,960 --> 00:10:30,960
Right. What's the lowest isolation level in the NC standard?

217
00:10:30,960 --> 00:10:32,960
Read uncommitted.

218
00:10:32,960 --> 00:10:34,960
What's the highest?

219
00:10:34,960 --> 00:10:35,960
Serialized.

220
00:10:35,960 --> 00:10:37,960
Yes. Is there anything about the sterilizable?

221
00:10:37,960 --> 00:10:38,960
Strict sterilized.

222
00:10:38,960 --> 00:10:39,960
Strict sterilized. Yes. Good.

223
00:10:39,960 --> 00:10:40,960
Excellent.

224
00:10:40,960 --> 00:10:42,960
Right. Again, like there's no form of these.

225
00:10:42,960 --> 00:10:45,960
There's to understand what what the anomalies you could have.

226
00:10:45,960 --> 00:10:49,960
Right. The phantoms, the dirty reads, the unrepeatable reads.

227
00:10:49,960 --> 00:10:54,960
Right. Understanding all those those things in the context of concurrency tool.

228
00:10:54,960 --> 00:10:57,960
At the end for specific protocols, we spent a lot of time talking about two days locking.

229
00:10:57,960 --> 00:11:01,960
Right. The difference between rigorous and non rigorous or strict versus non strict.

230
00:11:01,960 --> 00:11:03,960
We talked about the cascading of boards problem.

231
00:11:03,960 --> 00:11:08,960
Right. It's somebody read for transaction reads data that was uncommitted from another transaction and that other transaction.

232
00:11:09,960 --> 00:11:12,960
Aborts. You got to roll everyone back in the cascades.

233
00:11:12,960 --> 00:11:17,960
We talked about the different methods to handle deadlocks, which is the big problem you have in two days locking.

234
00:11:17,960 --> 00:11:19,960
Right. How do you detect it?

235
00:11:19,960 --> 00:11:21,960
Where the weights photograph and determine who to kill.

236
00:11:21,960 --> 00:11:24,960
And then deadlock prevention was wounder weight, weight, and die.

237
00:11:24,960 --> 00:11:32,960
Trying to figure out some kind of ordering mechanism based on transaction IDs or timestamps of transactions to determine who to kill to avoid a deadlock.

238
00:11:32,960 --> 00:11:35,960
Or curious of earlier kill somebody else.

239
00:11:36,960 --> 00:11:39,960
And then we talked about hierarchal locking or multiple granularity locking.

240
00:11:39,960 --> 00:11:41,960
And this is where we introduced intention locks.

241
00:11:41,960 --> 00:11:46,960
So as you're traversing down this hierarchy of the database system, there's a database.

242
00:11:46,960 --> 00:11:48,960
You can have a table, table of pages, so forth.

243
00:11:48,960 --> 00:11:56,960
Or you can take intention locks in those higher levels to to give hints to other transactions that come along about what you may be doing in those lower lower levels.

244
00:11:56,960 --> 00:12:03,960
And the key thing here is understanding the performance trade offs of allowing for more parallelism by taking as.

245
00:12:04,960 --> 00:12:12,960
The minimum permission locks as you need at the lowest point in this tree versus having to go to the lock manager over and over again to say I have this lock.

246
00:12:12,960 --> 00:12:17,960
There's whole, you know, that's a has to be concurrent data structure in itself.

247
00:12:17,960 --> 00:12:24,960
And then lock escalation would be if I hold a lock in this mode, can I take a lock in another mode? When is that allowed?

248
00:12:24,960 --> 00:12:26,960
Yes.

249
00:12:27,960 --> 00:12:32,960
So you need to memorize the intention lock grid.

250
00:12:32,960 --> 00:12:34,960
I mean, that helps you understand it.

251
00:12:34,960 --> 00:12:39,960
But like the, if you understand what like we're sharing attention shared attention to so you know anything what they are.

252
00:12:39,960 --> 00:12:40,960
Yeah.

253
00:12:40,960 --> 00:12:41,960
Yes.

254
00:12:41,960 --> 00:12:43,960
You go over the performance trade offs.

255
00:12:43,960 --> 00:12:50,960
So the, the, there's a trade-off between how much parallels am I have?

256
00:12:51,960 --> 00:13:02,960
I want to have allowing other transactions to run at the same time and take, take compatible locks on different parts of the database system versus having to go to the lock manager and make a request I want to acquire these locks.

257
00:13:02,960 --> 00:13:12,960
Right. So an example would be if I have a table and a table has a billion tuples and I want to update all one billion of them, I could take a scoosal lock on the entire table.

258
00:13:12,960 --> 00:13:16,960
And then that blocks anybody else from doing anything below, below in the tree.

259
00:13:16,960 --> 00:13:26,960
But then I, but I don't think of the lock manager once or I could go down take, you know, take an intention scoosal lock on the table and then take exclusive locks on the individual tuples I want to update.

260
00:13:26,960 --> 00:13:30,960
But now I got to go to the lock manager every single time I need to acquire those locks.

261
00:13:30,960 --> 00:13:31,960
Right.

262
00:13:31,960 --> 00:13:37,960
That again, big picture there isn't, there's not math involved in turning that. Just understand the pros and cons of both of them. Yes.

263
00:13:37,960 --> 00:13:42,960
Specifically by lock escalation, I think it was mentioned in my trip or what was really done.

264
00:13:42,960 --> 00:13:50,960
The question is, what do I mean by lock escalation? It'd be if I hold in which cases, for what, if I hold a lock in what mode?

265
00:13:50,960 --> 00:13:55,960
Can I escalate it to a higher mode and when is that allowed?

266
00:13:55,960 --> 00:14:04,960
So obviously, say ignore intention locks. I hold a shared lock. Can I escalate to automatically to an exclusive lock?

267
00:14:04,960 --> 00:14:17,960
No, because you don't know who else may be holding the share lock. Now if nobody else holds the shared lock, which you would know because you have a lock manager, then you could do that.

268
00:14:17,960 --> 00:14:23,960
High level details. We're not at there's no formulas here.

269
00:14:23,960 --> 00:14:24,960
Yes.

270
00:14:24,960 --> 00:14:27,960
So why would we update the lens?

271
00:14:27,960 --> 00:14:31,960
It's question when would you try to upgrade locks?

272
00:14:31,960 --> 00:14:38,960
If again, don't think of like a single query coming in and quieting locks and walking away. Think of a multi-query transaction.

273
00:14:38,960 --> 00:14:43,960
I do a select on something. The application gets the result. Then it comes back and does an update.

274
00:14:43,960 --> 00:14:50,960
Right. So then I, and I, you know, if I'm doing, I'm doing the, the rigorous to his locking. I hold the lock until the very end.

275
00:14:50,960 --> 00:14:56,960
So can I go back on the second query and escalate that shared lock into a social lock?

276
00:14:56,960 --> 00:15:06,960
Right. Yeah. And then we talked about like hints. You can do select for update. You can do a select query and say, oh, by the way, I'm going to update immediately afterwards.

277
00:15:06,960 --> 00:15:13,960
So take, don't take share locks. Take a school of locks on the objects I read. So then when the update query comes, it already holds an exclusive mode.

278
00:15:14,960 --> 00:15:20,960
Right. Again, that's a low level detail. We don't know what to worry about.

279
00:15:20,960 --> 00:15:25,960
Right. So actually, it's like when we talked about time stamp ordering protocols or optimistic protocols.

280
00:15:25,960 --> 00:15:30,960
We talked about the basic time stamp ordering, currently told, we talked with this one optimization, the Thomas Wright rule.

281
00:15:30,960 --> 00:15:40,960
It allows you to write things overwrite, to write objects to objects, even though they've been updating the future and you just ignore them.

282
00:15:40,960 --> 00:15:48,960
We talked about doing OCC, the free phases, the re-phase, validation phase and write phase. And there's a little very similar to what you'll see, what you did in the homework.

283
00:15:48,960 --> 00:15:54,960
And I think we have a question on this on the practice as well. And then we sent time talking about multi-versa-curator control.

284
00:15:54,960 --> 00:16:03,960
And I'm not so much worried about like, how do you fit in OCC or 2PL in MPCC? It was really the different design decisions you would have in a database system.

285
00:16:03,960 --> 00:16:09,960
If you want to support multi-versioning, how would you actually organize those versions in storage?

286
00:16:09,960 --> 00:16:24,960
Do you order the newest oldest oldest newest? How do you do garbage collection, clean up old versions? And then how do you maintain indexes, which may have pointers to different versions?

287
00:16:24,960 --> 00:16:45,960
Yes. The question is, is OCC an alternative to 2PL? Yes. So most every non-academic system like this. Yeah, pretty much every system.

288
00:16:45,960 --> 00:17:09,960
There are some active prototypes that kind of blend them. Like if you know, if you know your low-contention, OCC will be better. And then maybe if you add more content, it will automatically switch to 2PL. But like, it's so hard. You guys just see this in Project 4. It's so hard. It's just an implement one of them. Nobody implements two and tries to be clever like that. Everyone just picks one.

289
00:17:09,960 --> 00:17:25,960
We sometimes have a crash recovery. So this is about, if I have a bunch of changes sitting in memory, when can the buffer pool flush them out? And there's sort of two denying decisions whether to steal, no steal, or force, or no force.

290
00:17:25,960 --> 00:17:38,960
Again, steal is when the data systems allow to flush out pages that have been modified by transactions that have not committed yet. And in order to make room for other things you need. And no steal says you can't do that. You can only flush out data when it's been committed.

291
00:17:38,960 --> 00:17:52,960
And then force is, for source of no force is the requirement that I have to flush all the dirty changes from a transaction immediately when it commits before I can tell the outside world that it committed. Or can I do this? Can I defer to some later point?

292
00:17:53,960 --> 00:18:07,960
So the right-hand logging scheme that we talked about was what was steal versus no steal? Most data systems are an implement steal. Yes. Right. Because otherwise, if I have, if I, if I update more data that can fit memory, I can never do it.

293
00:18:07,960 --> 00:18:25,960
And now they force versus no force, no force, right? Because again, I can defer the change. I put my right-hand log. Here's the changes, here's the changes that I've mod, or here's the modification that made to the data system. That has to get persisted. So then if there's a crash, you can replay that log and recreate the what was in the buffer pool.

294
00:18:26,960 --> 00:18:48,960
We talk a little bit about about logging schemes. And again, I'm not the decision to be physical and physiological is not what we're really worried about. It's physical or versus logical. Right. The idea that I do, I'm updating in my log, my log records are going to be, here's like the deltos of the changes I made to individual records or tuples in my database. Or is it the query that I executed?

295
00:18:49,960 --> 00:19:06,960
Right. And then what are the tradeoffs of the two of them? Like if it's physical, yeah, I may, may store a lot more data, like my query may update a billion tuples. And therefore, I have a billion wall records for all those one billion updates. And then when I recover, I, you know, I just have to replay all those and logical would be just here's the single update query.

296
00:19:06,960 --> 00:19:08,960
Question this.

297
00:19:19,960 --> 00:19:26,960
His question is in the homework, there was something about no steel, right hand logging using no steel and force.

298
00:19:26,960 --> 00:19:33,960
Is that the shadow paging? More or less, yes.

299
00:19:33,960 --> 00:19:43,960
With shadow paging, like because you're writing to the shadow files, it doesn't matter, rather actually things get flushed like while you're still running.

300
00:19:43,960 --> 00:19:51,960
And no other transaction can see them. But again, very few systems do that.

301
00:19:51,960 --> 00:20:01,960
All right, we talk about checkpoints, like fuzzy checkpoints versus like stop the world checkpoints. And then we spend time talking about areas against understanding the three phases analyze redo and undo.

302
00:20:01,960 --> 00:20:07,960
And then what happens to the database system? What makes the changes? What, how does it update the internal state or the metadata?

303
00:20:07,960 --> 00:20:11,960
It's, it's using to keep track of here's the changes that are being made.

304
00:20:11,960 --> 00:20:27,960
How do the log sequence numbers of LSNs fit into the protocol? And how do the conversation log records? How are they being used to make sure that if I crash the decision crash is during recovery, I can recover from my recovery.

305
00:20:27,960 --> 00:20:37,960
And lastly, we talked about distributed databases. And again, because there wasn't a project based on this and it was sort of a sort of a high level overview of the different topics in the space, right.

306
00:20:37,960 --> 00:20:41,960
We can't really ask you deep questions about like how would you actually let this thing and that thing.

307
00:20:41,960 --> 00:20:50,960
All right, it's more about what are the different system architectures and primarily the difference between shared disk and shared memory, what are the pros and cons, or what are the trade offs of these different designs?

308
00:20:50,960 --> 00:20:58,960
How can a devistence replicate this data across different nodes and make sure that it's always available or can recover if a machine dies.

309
00:20:58,960 --> 00:21:07,960
The different implications of different partitioning schemes. Again, like if I have a range partitioning, I can do range queries for hash partitioning, I can maybe only do point queries.

310
00:21:07,960 --> 00:21:14,960
And then basic information like as we asked you in the homework about two basic commit.

311
00:21:14,960 --> 00:21:17,960
Any questions about any of this? Yes.

312
00:21:17,960 --> 00:21:24,960
The question is, when will the homework grains be released? We will do that this week. Yes. Probably today.

313
00:21:24,960 --> 00:21:38,960
The question is, Paxis on there. I mean, not really. Again, we would not show you like, hey, you know, high level questions, two basic commit is enough.

314
00:21:38,960 --> 00:21:46,960
If you understand two basic commit high level, you would understand Paxis. The difference is that Paxis is a quorum. Two-phase commit is everyone has to agree.

315
00:21:46,960 --> 00:21:49,960
Other questions?

316
00:21:49,960 --> 00:22:02,960
All right, so what's not on exam? Obviously, single store. And then this has come up in previous years where because myself and Dignage will be lecture, we like to say, oh, my sequel does this, a prescription of this or whatever.

317
00:22:02,960 --> 00:22:12,960
Like, all that is obviously we're not going to ask about. That's a color commentary for your own edification, you understand how the concepts we talk about during the semester, map to real world systems.

318
00:22:12,960 --> 00:22:15,960
Okay.

319
00:22:15,960 --> 00:22:28,960
All right, final exam, Tuesday, a 30am, come to Paxi on 153. And the practice exam is posted on the website. We'll post the link on Piazza, the files on Piazza after this class.

320
00:22:28,960 --> 00:22:32,960
And then office hours with the G next to myself on Monday.

321
00:22:32,960 --> 00:22:35,960
Okay.

322
00:22:35,960 --> 00:22:39,960
Today's lecture count is like the delta for the world.

323
00:22:39,960 --> 00:22:49,960
It's actually like, well, this, what today's lecture be on the exam? No. This is Andy just ranting about Davis, it's not.

324
00:22:49,960 --> 00:23:00,960
If the whole actually you were saying the PL class is basically them ranting about why he hits other programming languages. I like to think I'm getting it's more than this, right?

325
00:23:00,960 --> 00:23:10,960
So, no, if any any rants are not on the exam. Other questions?

326
00:23:10,960 --> 00:23:18,960
All right, so let's get to the fun stuff. So I don't, I didn't make a graph of this because of the what people voted for.

327
00:23:18,960 --> 00:23:25,960
There was one system that got the most votes will come that in a second.

328
00:23:25,960 --> 00:23:32,960
Most of this, I realize also too, I probably, in retrospect, I probably should have said here's the system you could choose from just because the votes were all over the place.

329
00:23:32,960 --> 00:23:35,960
Like everyone, the most systems got one vote.

330
00:23:35,960 --> 00:23:43,960
The first system we're going to cover got the most votes that was the non joke system. So if you know what the joke system was, everyone voted for that.

331
00:23:43,960 --> 00:23:48,960
But this one got the most votes and then the other two, there was other ones that were also tied in sort of second and third place.

332
00:23:48,960 --> 00:23:53,960
But I'm recovering the ones that I could put together slides quickly for.

333
00:23:53,960 --> 00:23:58,960
So the first one's going to be reddest. This one got the most votes.

334
00:23:58,960 --> 00:24:01,960
So here, who here has actually used reddest?

335
00:24:01,960 --> 00:24:06,960
Yeah, a lot. Okay, Houston. Who here has actually written a clone of reddest?

336
00:24:06,960 --> 00:24:10,960
Nobody. You laugh. That's what loads a lot of, there's a lot of clones of this.

337
00:24:10,960 --> 00:24:18,960
So reddest is considered the canonical no-sequel data system. Like along with Mongo, they sort of came out in the same area.

338
00:24:18,960 --> 00:24:23,960
So came out in 2009 by this Italian guy. He wrote a lot of it himself.

339
00:24:23,960 --> 00:24:26,960
It's a reddest stands for remote dictionary server.

340
00:24:26,960 --> 00:24:33,960
So at its core, reddest is a single node key value database system written in C.

341
00:24:33,960 --> 00:24:42,960
And what's interesting about it is that it, it, it, it, it's designed to be as fast, you know, do you keep the operations fast as possible?

342
00:24:42,960 --> 00:24:47,960
So it has a single thread execution engine and all the data resides entirely in memory.

343
00:24:47,960 --> 00:24:51,960
So the first thing, so this is taking the memory stuff first.

344
00:24:51,960 --> 00:24:55,960
So, you know, this entire semester has been about disk-oriented DB systems.

345
00:24:55,960 --> 00:25:00,960
So you have to have a buffer pool and you bring pages in from, from, from memory into, from disk into memory.

346
00:25:00,960 --> 00:25:03,960
And then there's a page table, you keep track of where things actually being located.

347
00:25:03,960 --> 00:25:13,960
Right? All of that requires additional internal latching to make sure that the data structure of the page table and all the other things that's inside the buffer pool are thread safe.

348
00:25:13,960 --> 00:25:15,960
Right? But there's overhead to that.

349
00:25:15,960 --> 00:25:28,960
And so it, traditionally, if your disk is slow, which historically, it always has been, then you're okay with taking, paying the penalty of taking those latches in memory because going to disk is so expensive anyway.

350
00:25:28,960 --> 00:25:31,960
Right? It's, it's a, it's not the high pool intent.

351
00:25:31,960 --> 00:25:36,960
And so, but now if you say my entire database is going to be in memory, there is no buffer pool.

352
00:25:36,960 --> 00:25:40,960
Everything I could ever need, any page or any record I want is always in memory.

353
00:25:40,960 --> 00:25:47,960
Then the cost of acquiring those, those, those latches starts to add up and that becomes the, the more, becomes the bottleneck.

354
00:25:47,960 --> 00:25:50,960
So in reddus, they say, well, we're not going to do any of that.

355
00:25:50,960 --> 00:25:53,960
We're, we're, the engine itself is going to be single threaded.

356
00:25:53,960 --> 00:25:59,960
And there's only one reader and there's only one, you know, only one thread can actually be doing anything in the database at a time.

357
00:25:59,960 --> 00:26:03,960
So therefore, I don't need those latches. I don't need any internal data structures to keep track of things.

358
00:26:03,960 --> 00:26:06,960
I basically can almost run as bare metal speed.

359
00:26:06,960 --> 00:26:12,960
This is why reddus is, historically, been known as one, you know, one of the faster database systems.

360
00:26:12,960 --> 00:26:18,960
So, what's also interesting about reddus is that beyond is being, there's a bunch of other key value stores that are out there.

361
00:26:18,960 --> 00:26:23,960
But what they do that, which is interesting is that they actually have specialized value types.

362
00:26:23,960 --> 00:26:28,960
Right? So, so when I say a, sort of generic key value store would be, here's my key and here's my value.

363
00:26:28,960 --> 00:26:31,960
And the value is just a blob, right? A, some, some byte stream.

364
00:26:31,960 --> 00:26:34,960
The data center doesn't know anything about what's inside of it.

365
00:26:34,960 --> 00:26:38,960
And so anytime you want to interpret within that byte stream, you got to do this in application code.

366
00:26:38,960 --> 00:26:44,960
So in reddus, their values could be either strings or hashes or integers or lists or sets.

367
00:26:45,960 --> 00:26:54,960
And then they have specific commands that can do manipulation on those data structures within a single, you know, round trip update.

368
00:26:54,960 --> 00:26:59,960
Instead of having to bring stuff in the application, modify stuff and then push it back out.

369
00:26:59,960 --> 00:27:05,960
So that part is interesting. That, that part is, is other than, there were a bunch of clones of reddus.

370
00:27:05,960 --> 00:27:09,960
But that, I think that part of reddus was novel when it came out.

371
00:27:09,960 --> 00:27:15,960
Because it's in memory, we'll talk in a second how they handle, make sure that their data is persistent.

372
00:27:15,960 --> 00:27:21,960
In the real world, I come across reddus being primarily used as a cache.

373
00:27:21,960 --> 00:27:25,960
Right? So you would have your regular Davies system, my SQL, Postgres, Mongo, whatever you want.

374
00:27:25,960 --> 00:27:30,960
And then you would have this cache, this, this cache on the side, the side card cache.

375
00:27:30,960 --> 00:27:33,960
And then your application would say, oh, I need to get this key.

376
00:27:33,960 --> 00:27:36,960
Set them to go to the Davies system run in the query. I'll go check reddus.

377
00:27:36,960 --> 00:27:40,960
If it's there, great others use that. If not, then I'll go to the Davies system.

378
00:27:40,960 --> 00:27:43,960
So it's a way to avoid having to do a bunch of additional operations.

379
00:27:43,960 --> 00:27:46,960
Davies system, which would be expensive to do.

380
00:27:46,960 --> 00:27:54,960
So I was joking before I asked him why anybody has written a clone because there's, there's a ton of these like hobby projects that are out there where people like,

381
00:27:54,960 --> 00:27:59,960
you know, they have lettuce because it's, you know, they were, whatever programming language you can think of,

382
00:27:59,960 --> 00:28:02,960
take the first letter of that programming language and there, and there'll be a reddus clone.

383
00:28:02,960 --> 00:28:07,960
Like there's jettis and like there's, there's, with the J or G or go or job it right.

384
00:28:07,960 --> 00:28:09,960
There's a bunch of these clones of them.

385
00:28:09,960 --> 00:28:16,960
These are, these key B and dragify that to how the two most developed, other tenders out of ten set as well.

386
00:28:16,960 --> 00:28:21,960
These probably the two most well developed extensions or rewrites of reddus.

387
00:28:21,960 --> 00:28:24,960
Actually, key B, key B was Canadian. They got bought by,

388
00:28:25,960 --> 00:28:31,960
what's the other, not Instagram, what's the other social media with Hig Photos with the ghost?

389
00:28:31,960 --> 00:28:33,960
Snapchat, yeah, they go bought by Snapchat.

390
00:28:33,960 --> 00:28:36,960
Oh, they did, they fucking put a latch in front of it, right?

391
00:28:36,960 --> 00:28:40,960
So they say they're, they can do, sort of set it being single threaded, it's multi threaded, but they just put a latch, right?

392
00:28:40,960 --> 00:28:42,960
And they got acquired for that.

393
00:28:42,960 --> 00:28:44,960
Drag and fly is complete rewrite.

394
00:28:44,960 --> 00:28:47,960
Tendus is ten cent, I think it's open source. I don't know whether they fork it or not.

395
00:28:47,960 --> 00:28:52,960
But there's a, again, if you go to DBDO, if you go click the compatibility with reddus, there's a ton of these systems.

396
00:28:52,960 --> 00:28:54,960
And there's a bunch of them I don't even put on.

397
00:28:54,960 --> 00:29:00,960
And there's some, there's some company where they'll sell you basically a course like 445,

398
00:29:00,960 --> 00:29:02,960
where you basically learn how to write your own reddus clone.

399
00:29:02,960 --> 00:29:03,960
Yes.

400
00:29:03,960 --> 00:29:06,960
How did you handle variable length types and both of them?

401
00:29:06,960 --> 00:29:09,960
Like, the kind of direction, it's the display.

402
00:29:09,960 --> 00:29:10,960
So how did they handle what, sorry?

403
00:29:10,960 --> 00:29:11,960
A variable length.

404
00:29:11,960 --> 00:29:13,960
If it's what, sorry, if what?

405
00:29:13,960 --> 00:29:15,960
Like, because the strings are happy to go variable length.

406
00:29:15,960 --> 00:29:16,960
Yeah.

407
00:29:16,960 --> 00:29:17,960
How did they handle it?

408
00:29:17,960 --> 00:29:18,960
It's a hashable.

409
00:29:18,960 --> 00:29:19,960
Yeah.

410
00:29:19,960 --> 00:29:22,960
We'll give that in a second.

411
00:29:22,960 --> 00:29:23,960
Right. Yes.

412
00:29:23,960 --> 00:29:25,960
What do you think added a match?

413
00:29:25,960 --> 00:29:26,960
Like global latch?

414
00:29:26,960 --> 00:29:31,960
So like they would have, yeah, they had a global latch in front of the data structure.

415
00:29:31,960 --> 00:29:32,960
Can my student look at this?

416
00:29:32,960 --> 00:29:33,960
It's a global latch in front of the data structure.

417
00:29:33,960 --> 00:29:36,960
So you can have multiple, multiple updates come in, right?

418
00:29:36,960 --> 00:29:39,960
But then still, there's still a latch in front of the data structure.

419
00:29:39,960 --> 00:29:47,960
I mean, like, it's concurrent network connection.

420
00:29:47,960 --> 00:29:48,960
I don't know.

421
00:29:48,960 --> 00:29:49,960
Huh?

422
00:29:49,960 --> 00:29:50,960
It might allow multiple reads.

423
00:29:50,960 --> 00:29:51,960
Yeah.

424
00:29:51,960 --> 00:29:52,960
Yeah.

425
00:29:52,960 --> 00:29:53,960
Okay.

426
00:29:53,960 --> 00:29:56,960
So here's what keys look like.

427
00:29:56,960 --> 00:29:57,960
Right?

428
00:29:57,960 --> 00:29:58,960
It's just, there's like strings.

429
00:29:58,960 --> 00:30:09,960
And then you have different, you know, different, uh, nomenclatures, which are just corresponded

430
00:30:09,960 --> 00:30:11,960
like, is it a, like, well, here's it.

431
00:30:11,960 --> 00:30:16,960
If you want a sorted set, a hash table, you get a list, a set, and then there's regular strings

432
00:30:16,960 --> 00:30:17,960
that have been stored there.

433
00:30:17,960 --> 00:30:18,960
Right?

434
00:30:18,960 --> 00:30:19,960
And then the other side here, these are his values.

435
00:30:19,960 --> 00:30:22,960
Well, we can give a quick demo what this looks like.

436
00:30:22,960 --> 00:30:25,960
Um, and so red is by default doesn't support SQL.

437
00:30:25,960 --> 00:30:28,960
Um, there is, there was a red is SQL.

438
00:30:28,960 --> 00:30:31,960
There was like, yeah, there's people take red is they put SQL and stuff on top of it.

439
00:30:31,960 --> 00:30:33,960
Uh, they put graph, apis on top of it.

440
00:30:33,960 --> 00:30:38,960
Um, the, the entire guy that originally started writing red is he no longer works in the project.

441
00:30:38,960 --> 00:30:39,960
I don't know what, I don't know what he's doing now.

442
00:30:39,960 --> 00:30:44,960
And then there's a, there was a company that was doing hosted red is called red is labs.

443
00:30:44,960 --> 00:30:49,960
I think they bought the red is name and now they're just called red is the company and they're

444
00:30:49,960 --> 00:30:54,960
trying to commercialize red is and what they're basically trying to do is go beyond the,

445
00:30:54,960 --> 00:30:59,960
sort of break the mind share thought or the perception that red is is only used as a cache.

446
00:30:59,960 --> 00:31:03,960
And they're trying to build a bunch of apis in front of it so you could use it as your primary storage database.

447
00:31:03,960 --> 00:31:06,960
And it remains to be seen how successful they will be.

448
00:31:06,960 --> 00:31:08,960
So again, it doesn't work SQL.

449
00:31:08,960 --> 00:31:13,960
So instead you get a bunch of just these commands that do very specific operations on,

450
00:31:13,960 --> 00:31:16,960
uh, the different data types, right?

451
00:31:16,960 --> 00:31:23,960
Uh, and so in your application code, you have to be able to specify or know like I'm doing,

452
00:31:23,960 --> 00:31:26,960
you know, I'm operating on a key that looks at this type.

453
00:31:26,960 --> 00:31:28,960
And therefore I can only run these commands.

454
00:31:28,960 --> 00:31:30,960
Otherwise, it will throw an error.

455
00:31:30,960 --> 00:31:33,960
Um, again, I only learned red is last night.

456
00:31:33,960 --> 00:31:34,960
So let's see how it goes.

457
00:31:34,960 --> 00:31:36,960
Um,

458
00:31:36,960 --> 00:31:46,960
let's see.

459
00:31:46,960 --> 00:31:47,960
Uh, materialize.

460
00:31:47,960 --> 00:31:48,960
Sorry.

461
00:31:48,960 --> 00:31:51,960
I want to go to eight.

462
00:31:51,960 --> 00:31:52,960
Right.

463
00:31:52,960 --> 00:31:55,960
So, uh, you can do something that's like set.

464
00:31:55,960 --> 00:31:59,960
This is a command interface that has a nice, uh, like, you know, suggestions.

465
00:31:59,960 --> 00:32:00,960
So do a key.

466
00:32:00,960 --> 00:32:02,960
You call your class.

467
00:32:02,960 --> 00:32:04,960
And we'll put ABC in.

468
00:32:04,960 --> 00:32:06,960
Right.

469
00:32:06,960 --> 00:32:10,960
So now if I call get ABC.

470
00:32:10,960 --> 00:32:14,960
Oh, sorry, get key.

471
00:32:14,960 --> 00:32:16,960
Class.

472
00:32:16,960 --> 00:32:17,960
Right.

473
00:32:17,960 --> 00:32:18,960
I get that back.

474
00:32:18,960 --> 00:32:28,960
Um, then you can do other things like you can do.

475
00:32:28,960 --> 00:32:29,960
This is me trying to figure it out.

476
00:32:29,960 --> 00:32:30,960
Right.

477
00:32:30,960 --> 00:32:32,960
So they have incremental, they have increments.

478
00:32:32,960 --> 00:32:36,960
So you can define like a, um,

479
00:32:36,960 --> 00:32:40,960
you can divide, you basically define a counter, right.

480
00:32:40,960 --> 00:32:44,960
So I can say increment.

481
00:32:44,960 --> 00:32:45,960
And then we'll give it a counter.

482
00:32:45,960 --> 00:32:48,960
We'll call it counter X.

483
00:32:48,960 --> 00:32:49,960
Right.

484
00:32:49,960 --> 00:32:52,960
And every time I call that command, it'll automatically add one to it.

485
00:32:52,960 --> 00:32:53,960
Right.

486
00:32:53,960 --> 00:32:54,960
So think of like it's a game.

487
00:32:54,960 --> 00:32:55,960
You're keeping track of score or something.

488
00:32:55,960 --> 00:32:56,960
You do things like that.

489
00:32:56,960 --> 00:32:57,960
What's kind of funky?

490
00:32:57,960 --> 00:33:00,960
You can put a number in front of this and say I went increment it five times.

491
00:33:00,960 --> 00:33:01,960
Right.

492
00:33:01,960 --> 00:33:07,960
Um, if I call get, I should be able to get the current value counter X.

493
00:33:07,960 --> 00:33:08,960
Right.

494
00:33:08,960 --> 00:33:10,960
What's interesting here.

495
00:33:10,960 --> 00:33:12,960
I am assuming here that they're returning back.

496
00:33:12,960 --> 00:33:14,960
Hey, the type is an integer when I call increment.

497
00:33:14,960 --> 00:33:18,960
But when I call get, I get the response back as a string.

498
00:33:18,960 --> 00:33:19,960
Right.

499
00:33:19,960 --> 00:33:22,960
So I think they're storing everything is strings.

500
00:33:22,960 --> 00:33:25,960
And then I can't actually I said, sorry, take that.

501
00:33:25,960 --> 00:33:29,960
The wire protocol says everything back as a string in and out as a string.

502
00:33:29,960 --> 00:33:34,960
They must be doing something here to cast it or store it natively as an integer on the server side.

503
00:33:34,960 --> 00:33:37,960
But I haven't looked at the source code to figure that out.

504
00:33:37,960 --> 00:33:40,960
Um, but let's make a list now.

505
00:33:40,960 --> 00:33:43,960
So.

506
00:33:43,960 --> 00:33:51,960
Get key.

507
00:33:51,960 --> 00:33:52,960
Scan.

508
00:33:52,960 --> 00:33:53,960
Right.

509
00:33:53,960 --> 00:33:54,960
Yeah.

510
00:33:54,960 --> 00:33:55,960
So here we'll make a list.

511
00:33:55,960 --> 00:33:57,960
We'll call list X.

512
00:33:57,960 --> 00:34:03,960
Right.

513
00:34:03,960 --> 00:34:08,960
And then I can add something else.

514
00:34:08,960 --> 00:34:09,960
So, all right.

515
00:34:09,960 --> 00:34:11,960
So when I was doing this last time, okay, great.

516
00:34:11,960 --> 00:34:12,960
I got a list.

517
00:34:12,960 --> 00:34:13,960
Give me back the list.

518
00:34:13,960 --> 00:34:16,960
So I thought, okay, I'll do list X.

519
00:34:16,960 --> 00:34:17,960
Doesn't like that.

520
00:34:17,960 --> 00:34:18,960
Right.

521
00:34:18,960 --> 00:34:20,960
Because it knows that it's a list.

522
00:34:20,960 --> 00:34:26,960
And I'm asking for a command that's not on that for like basic, by repairs and not list.

523
00:34:26,960 --> 00:34:31,960
So this is actually goes back to something that's had very, very beginning about, uh, Y SQL and relational models a good idea.

524
00:34:31,960 --> 00:34:36,960
And that there was earlier systems that had these APIs were based on the type or the value restoring.

525
00:34:36,960 --> 00:34:38,960
You had one set of commands or some other set of commands.

526
00:34:38,960 --> 00:34:42,960
To me, it seems perfectly reasonable to say, hey, get me that list.

527
00:34:42,960 --> 00:34:43,960
But no, you can't do that.

528
00:34:43,960 --> 00:34:44,960
It doesn't let you to do that.

529
00:34:44,960 --> 00:34:45,960
Right.

530
00:34:45,960 --> 00:34:50,960
Because it's not storing any potentially any information on the server side about what the type actually is.

531
00:34:50,960 --> 00:34:53,960
So it's relying on you, the application to know what command you should call it on.

532
00:34:53,960 --> 00:34:56,960
You just call on a different data type.

533
00:34:56,960 --> 00:34:57,960
Right.

534
00:34:57,960 --> 00:35:01,960
So like, if now I do this, let's see if I let me do this.

535
00:35:01,960 --> 00:35:06,960
What if I call list X now, you know, one, two, three.

536
00:35:06,960 --> 00:35:07,960
Let me do that.

537
00:35:07,960 --> 00:35:09,960
But now I can call.

538
00:35:09,960 --> 00:35:11,960
Now I get it back.

539
00:35:11,960 --> 00:35:12,960
Right.

540
00:35:12,960 --> 00:35:14,960
The data system let me do that.

541
00:35:14,960 --> 00:35:17,960
And so that means that someone makes mistakes in your application code.

542
00:35:17,960 --> 00:35:18,960
It doesn't know that it's calling.

543
00:35:19,960 --> 00:35:24,960
You know, it's calling certain commands based on a list type versus a regular type.

544
00:35:24,960 --> 00:35:28,960
You might break your, you know, break your database when you're in your data.

545
00:35:28,960 --> 00:35:33,960
So this is a great example of like Y schemas and Y of the relational model is a good idea.

546
00:35:33,960 --> 00:35:36,960
Because your post because my SQL won't let you do that.

547
00:35:36,960 --> 00:35:39,960
Furthermore, it's a select.

548
00:35:39,960 --> 00:35:42,960
You don't care in your query what the data type actually is.

549
00:35:42,960 --> 00:35:45,960
You just say, give me these results and get it back.

550
00:35:45,960 --> 00:35:48,960
Now yeah, there's certain function to call that you have to know what type it is.

551
00:35:48,960 --> 00:35:51,960
And it made it his own tries to do type inference and other things of the cast stuff.

552
00:35:51,960 --> 00:35:56,960
But to me, that seems bizarre that I can't call get on a list.

553
00:35:56,960 --> 00:35:57,960
Right.

554
00:35:57,960 --> 00:35:59,960
To me, that seems wrong.

555
00:35:59,960 --> 00:36:03,960
So then the way you get it back, I think it took a while to figure this out.

556
00:36:03,960 --> 00:36:05,960
Yeah, here.

557
00:36:05,960 --> 00:36:08,960
The way you get it back was you have to call this L range.

558
00:36:08,960 --> 00:36:09,960
So it's a list range.

559
00:36:09,960 --> 00:36:10,960
And I went from zero.

560
00:36:10,960 --> 00:36:14,960
And then it's like the Python syntax for like negative one is the last item list.

561
00:36:14,960 --> 00:36:15,960
Right.

562
00:36:15,960 --> 00:36:17,960
Oh, yeah, see if I broke it.

563
00:36:17,960 --> 00:36:18,960
So now I got to go back.

564
00:36:18,960 --> 00:36:19,960
All right.

565
00:36:19,960 --> 00:36:20,960
Can't do that.

566
00:36:20,960 --> 00:36:23,960
So make it make a new list.

567
00:36:23,960 --> 00:36:24,960
Um.

568
00:36:24,960 --> 00:36:28,960
List Y.

569
00:36:28,960 --> 00:36:39,960
And then now.

570
00:36:39,960 --> 00:36:40,960
I missed it.

571
00:36:40,960 --> 00:36:41,960
Yeah, yeah, yeah, yeah.

572
00:36:41,960 --> 00:36:42,960
Thank you.

573
00:36:42,960 --> 00:36:45,960
I used my laptop type instead of this.

574
00:36:45,960 --> 00:36:46,960
Right.

575
00:36:46,960 --> 00:36:48,960
Then I get to list back.

576
00:36:48,960 --> 00:36:49,960
All right.

577
00:36:49,960 --> 00:36:52,960
So that's.

578
00:36:52,960 --> 00:36:53,960
Yes.

579
00:36:53,960 --> 00:36:55,960
Yes.

580
00:36:55,960 --> 00:36:56,960
Yes.

581
00:36:56,960 --> 00:36:57,960
Yes.

582
00:36:57,960 --> 00:36:58,960
Yes.

583
00:36:58,960 --> 00:36:59,960
Yes.

584
00:36:59,960 --> 00:37:00,960
Yes.

585
00:37:00,960 --> 00:37:01,960
Yes.

586
00:37:01,960 --> 00:37:02,960
Yes.

587
00:37:02,960 --> 00:37:03,960
Yes.

588
00:37:03,960 --> 00:37:04,960
Yes.

589
00:37:04,960 --> 00:37:05,960
Yes.

590
00:37:05,960 --> 00:37:06,960
Yes.

591
00:37:06,960 --> 00:37:07,960
Yes.

592
00:37:07,960 --> 00:37:08,960
Yes.

593
00:37:08,960 --> 00:37:09,960
Yes.

594
00:37:09,960 --> 00:37:10,960
Yes.

595
00:37:10,960 --> 00:37:11,960
Yes.

596
00:37:11,960 --> 00:37:12,960
Yes.

597
00:37:12,960 --> 00:37:13,960
It's David is,

598
00:37:13,960 --> 00:37:15,960
If I add a adding SQL,

599
00:37:15,960 --> 00:37:18,960
and an relational model on top of the system,

600
00:37:18,960 --> 00:37:20,960
like we have a bus top or other systems,

601
00:37:20,960 --> 00:37:21,960
wouldn't this be,

602
00:37:21,960 --> 00:37:27,960
wouldn't that slow things down because you at the parts of querying all that subject?

603
00:37:27,960 --> 00:37:28,960
Absolutely.

604
00:37:28,960 --> 00:37:29,960
Yes.

605
00:37:29,960 --> 00:37:30,960
So for like simple things,

606
00:37:30,960 --> 00:37:32,960
like a key value store for a cash.

607
00:37:32,960 --> 00:37:33,960
Sure.

608
00:37:33,960 --> 00:37:34,960
That's fine.

609
00:37:34,960 --> 00:37:39,960
But if you to use this as your primary database and not have something enforce your schema.

610
00:37:39,960 --> 00:37:43,960
to protect you from shooting yourself in the foot like it did just now.

611
00:37:43,960 --> 00:37:45,960
That's a recipe for disaster.

612
00:37:45,960 --> 00:37:48,960
It'll help you get stuff up and running very quickly,

613
00:37:48,960 --> 00:37:51,960
but think of like five years from now, 10 years from now.

614
00:37:51,960 --> 00:37:54,960
You're dead or whatever, you've been fired,

615
00:37:54,960 --> 00:37:56,960
you're not working application anymore.

616
00:37:56,960 --> 00:37:59,960
Somebody else is picking up your code and they got to deal with your clusterfuck.

617
00:37:59,960 --> 00:38:03,960
So having things that prevent humans from doing stupid things

618
00:38:03,960 --> 00:38:06,960
for a primary source database is a good idea.

619
00:38:06,960 --> 00:38:09,960
For a cache, like if the key is just a session ID

620
00:38:09,960 --> 00:38:11,960
and you get back JSON or whatever, that's fine.

621
00:38:11,960 --> 00:38:12,960
I don't care.

622
00:38:12,960 --> 00:38:14,960
The second question,

623
00:38:14,960 --> 00:38:16,960
is there an other system that has been got?

624
00:38:16,960 --> 00:38:18,960
What is called a cache?

625
00:38:18,960 --> 00:38:19,960
Yes.

626
00:38:19,960 --> 00:38:21,960
Is there a code that has been added for the board?

627
00:38:21,960 --> 00:38:23,960
Like, I know maybe it's called the one that's moving,

628
00:38:23,960 --> 00:38:26,960
but if you want to extend it to an edge,

629
00:38:26,960 --> 00:38:27,960
then it's a good idea.

630
00:38:27,960 --> 00:38:29,960
Yeah, so the question is,

631
00:38:29,960 --> 00:38:31,960
I'm saying red is just a cache,

632
00:38:31,960 --> 00:38:33,960
but there's another famous cache,

633
00:38:33,960 --> 00:38:36,960
a distributed cache called memcache d,

634
00:38:36,960 --> 00:38:38,960
that came out of live journal.

635
00:38:38,960 --> 00:38:39,960
If you know what that,

636
00:38:39,960 --> 00:38:41,960
think of like,

637
00:38:41,960 --> 00:38:43,960
before Tumblr, if you know what Tumblr was,

638
00:38:43,960 --> 00:38:45,960
before Medium, right?

639
00:38:45,960 --> 00:38:47,960
There's Medium now,

640
00:38:47,960 --> 00:38:48,960
or Substack,

641
00:38:48,960 --> 00:38:50,960
and then there was Tumblr with the hot bang,

642
00:38:50,960 --> 00:38:52,960
and then before that was live journal.

643
00:38:52,960 --> 00:38:54,960
It still exists, I think, for the furries or whatever.

644
00:38:54,960 --> 00:38:57,960
They built this distributed cache called memcache d,

645
00:38:57,960 --> 00:39:00,960
and it is a consistent hash table

646
00:39:00,960 --> 00:39:03,960
that does to basically get and sets.

647
00:39:03,960 --> 00:39:05,960
So what memcache d, as far as I know,

648
00:39:05,960 --> 00:39:07,960
they only support get set and leads.

649
00:39:07,960 --> 00:39:09,960
Redis has all these, I showed the commands,

650
00:39:09,960 --> 00:39:12,960
does all these other detailed commands you could do

651
00:39:12,960 --> 00:39:13,960
on different data types.

652
00:39:13,960 --> 00:39:15,960
I think that's why this would be different.

653
00:39:15,960 --> 00:39:16,960
Now, the question is,

654
00:39:16,960 --> 00:39:17,960
can you make redis distributed?

655
00:39:17,960 --> 00:39:20,960
Yes, there is a distributed version of redis.

656
00:39:20,960 --> 00:39:23,960
I don't know whether it's a middleware on the front

657
00:39:23,960 --> 00:39:27,960
or whether you can read and write to any node.

658
00:39:27,960 --> 00:39:29,960
I don't know how it works.

659
00:39:29,960 --> 00:39:30,960
Yes.

660
00:39:30,960 --> 00:39:33,960
I was going to mention that it can be used in memory cache

661
00:39:33,960 --> 00:39:36,960
to cache something that's not used to create data.

662
00:39:36,960 --> 00:39:37,960
Yes.

663
00:39:37,960 --> 00:39:39,960
So who does want to be distributed in the case of

664
00:39:39,960 --> 00:39:41,960
making things interesting?

665
00:39:41,960 --> 00:39:42,960
So his question is,

666
00:39:42,960 --> 00:39:43,960
in my scenario,

667
00:39:43,960 --> 00:39:45,960
where you said you had a redis as a cache,

668
00:39:45,960 --> 00:39:47,960
and then Postgres or Royard Davidson as the primary storage,

669
00:39:47,960 --> 00:39:49,960
who's responsible for maintaining the cache,

670
00:39:49,960 --> 00:39:51,960
the application code?

671
00:39:51,960 --> 00:39:53,960
It's a sidecar cache,

672
00:39:53,960 --> 00:39:55,960
not a right-through cache.

673
00:39:55,960 --> 00:39:56,960
A right-through cache would be like,

674
00:39:56,960 --> 00:39:57,960
sits in front of the system,

675
00:39:57,960 --> 00:39:58,960
if you're right,

676
00:39:58,960 --> 00:40:00,960
and then it gets propagated to the data system.

677
00:40:00,960 --> 00:40:02,960
Redis doesn't support SQL,

678
00:40:02,960 --> 00:40:03,960
doesn't support any of that.

679
00:40:03,960 --> 00:40:04,960
So in the application code,

680
00:40:04,960 --> 00:40:06,960
your response will be doing that.

681
00:40:06,960 --> 00:40:07,960
So that means, of course, again,

682
00:40:07,960 --> 00:40:08,960
that if you now do an update,

683
00:40:08,960 --> 00:40:09,960
and something gets invalidated,

684
00:40:09,960 --> 00:40:13,960
you have to send a delete request to the cache.

685
00:40:13,960 --> 00:40:14,960
Yes.

686
00:40:14,960 --> 00:40:15,960
So you said that there,

687
00:40:15,960 --> 00:40:16,960
providing the system,

688
00:40:16,960 --> 00:40:20,960
what does it not make it so much better?

689
00:40:20,960 --> 00:40:22,960
This question is,

690
00:40:22,960 --> 00:40:25,960
I'm saying that they're providing some kind of level of persistence.

691
00:40:25,960 --> 00:40:27,960
Does that mean single-threaded,

692
00:40:27,960 --> 00:40:29,960
is a bad idea?

693
00:40:29,960 --> 00:40:32,960
So,

694
00:40:32,960 --> 00:40:34,960
not necessarily.

695
00:40:34,960 --> 00:40:38,960
So if you're only getting like a single key at a time,

696
00:40:38,960 --> 00:40:42,960
or getting data that's always going to be within the same partition,

697
00:40:42,960 --> 00:40:44,960
then what you could do with Redis,

698
00:40:44,960 --> 00:40:46,960
and other systems do this single approach,

699
00:40:46,960 --> 00:40:49,960
like my PC thesis was on this approach,

700
00:40:49,960 --> 00:40:52,960
you could have every core,

701
00:40:52,960 --> 00:40:54,960
just run a whole instance of the database server,

702
00:40:54,960 --> 00:40:56,960
and they don't need to talk to each other,

703
00:40:56,960 --> 00:40:58,960
because everything's going to be within that single system,

704
00:40:58,960 --> 00:41:00,960
and a single thread it.

705
00:41:00,960 --> 00:41:02,960
So then now, something above this is decided,

706
00:41:02,960 --> 00:41:03,960
okay, I need to get this data,

707
00:41:03,960 --> 00:41:06,960
you could hash it in the side which core you want to then talk to.

708
00:41:06,960 --> 00:41:08,960
So you could scale out Redis,

709
00:41:08,960 --> 00:41:11,960
because the transactions don't need to talk to each other,

710
00:41:11,960 --> 00:41:12,960
don't need to talk to different partitions,

711
00:41:12,960 --> 00:41:14,960
you can scale this out very easily.

712
00:41:14,960 --> 00:41:16,960
But something above it needs to handle it,

713
00:41:16,960 --> 00:41:17,960
and I think the Redis,

714
00:41:17,960 --> 00:41:18,960
the commercial company,

715
00:41:18,960 --> 00:41:20,960
has something that does that.

716
00:41:20,960 --> 00:41:23,960
It's when you have to start talking to,

717
00:41:23,960 --> 00:41:25,960
if you want an intersectional,

718
00:41:25,960 --> 00:41:27,960
I get an intersection in a system manner,

719
00:41:27,960 --> 00:41:29,960
I need to get data to two partitions,

720
00:41:29,960 --> 00:41:31,960
then that's where things become problematic,

721
00:41:31,960 --> 00:41:33,960
because then it's a distribution of transactions,

722
00:41:33,960 --> 00:41:35,960
like we talked about before,

723
00:41:35,960 --> 00:41:39,960
because you got a coordinate across each instance.

724
00:41:39,960 --> 00:41:41,960
All right, so,

725
00:41:41,960 --> 00:41:42,960
if it's in memory,

726
00:41:42,960 --> 00:41:45,960
in my demo here,

727
00:41:45,960 --> 00:41:47,960
if I shut the system off, turn it back on,

728
00:41:47,960 --> 00:41:49,960
it gets wiped out every single time,

729
00:41:49,960 --> 00:41:51,960
because everything is in memory.

730
00:41:51,960 --> 00:41:54,960
The thing that makes things

731
00:41:54,960 --> 00:41:55,960
that are persistent and durable,

732
00:41:55,960 --> 00:41:57,960
is that they use a right-of-hand log

733
00:41:57,960 --> 00:41:59,960
for a keep track of individual updates,

734
00:41:59,960 --> 00:42:01,960
and that literally is writing out the command

735
00:42:01,960 --> 00:42:03,960
that gets sent over the wire.

736
00:42:03,960 --> 00:42:04,960
Like, when I type it in the console,

737
00:42:04,960 --> 00:42:05,960
they literally take that string,

738
00:42:05,960 --> 00:42:06,960
and they write it to a file.

739
00:42:06,960 --> 00:42:08,960
It's logical logging,

740
00:42:08,960 --> 00:42:10,960
because then when you load back up,

741
00:42:10,960 --> 00:42:12,960
then they replay the log,

742
00:42:12,960 --> 00:42:14,960
as if it was coming over the wire.

743
00:42:14,960 --> 00:42:15,960
But what they do,

744
00:42:15,960 --> 00:42:17,960
the handle checkpoints or snapshots,

745
00:42:17,960 --> 00:42:19,960
is that they basically have a background-crong job,

746
00:42:19,960 --> 00:42:21,960
by default, I think, 60 seconds.

747
00:42:21,960 --> 00:42:22,960
Every 60 seconds,

748
00:42:22,960 --> 00:42:24,960
they're going to fork the process.

749
00:42:24,960 --> 00:42:27,960
What happens in the OS when you fork the process in memory?

750
00:42:27,960 --> 00:42:28,960
What's that?

751
00:42:28,960 --> 00:42:30,960
Copy-one, right?

752
00:42:30,960 --> 00:42:32,960
So, you're going to fork the process,

753
00:42:32,960 --> 00:42:34,960
and now you have a consistent snapshot

754
00:42:34,960 --> 00:42:36,960
of what was in memory,

755
00:42:36,960 --> 00:42:39,960
at the time the process got forked in the child process.

756
00:42:39,960 --> 00:42:42,960
The parent process can keep processing updates,

757
00:42:42,960 --> 00:42:44,960
and making modifications to M-memory,

758
00:42:44,960 --> 00:42:46,960
then the OS does the copy-on-write,

759
00:42:46,960 --> 00:42:48,960
updates, and makes new pages in memory,

760
00:42:48,960 --> 00:42:51,960
and so the child process doesn't see any of those updates.

761
00:42:51,960 --> 00:42:53,960
And because it's single-threaded,

762
00:42:53,960 --> 00:42:55,960
you know that there's no inflight transactions

763
00:42:55,960 --> 00:42:57,960
while you're running,

764
00:42:57,960 --> 00:42:59,960
so again, it has a consistent view of the database,

765
00:42:59,960 --> 00:43:02,960
and then that child process just takes whatever's in memory

766
00:43:02,960 --> 00:43:03,960
and writes it out the disk,

767
00:43:03,960 --> 00:43:04,960
as a checkpoint.

768
00:43:04,960 --> 00:43:06,960
There's a clever trick to reduce.

769
00:43:06,960 --> 00:43:09,960
It's basically stop the world checkpoints,

770
00:43:09,960 --> 00:43:11,960
but because it's single-threaded,

771
00:43:11,960 --> 00:43:13,960
and because you can do this fork,

772
00:43:13,960 --> 00:43:16,960
there's very little overhead involved in doing this.

773
00:43:16,960 --> 00:43:19,960
The pause isn't very long.

774
00:43:19,960 --> 00:43:20,960
So that part is very clever,

775
00:43:20,960 --> 00:43:23,960
and that is the unique to retis.

776
00:43:23,960 --> 00:43:25,960
For other things, we can get rid of that as a single-threaded.

777
00:43:25,960 --> 00:43:27,960
It's a chain hash table.

778
00:43:27,960 --> 00:43:29,960
There's no secondary indexes,

779
00:43:29,960 --> 00:43:31,960
so again, I can only do look-ups on the primary key,

780
00:43:31,960 --> 00:43:32,960
on the key,

781
00:43:32,960 --> 00:43:33,960
and there's no schema,

782
00:43:33,960 --> 00:43:34,960
there's no constraints for preventing you

783
00:43:34,960 --> 00:43:36,960
from putting whatever data you want in.

784
00:43:36,960 --> 00:43:37,960
Yes.

785
00:43:37,960 --> 00:43:39,960
You know why they chose a chain dash table?

786
00:43:39,960 --> 00:43:41,960
Flash like, how do you resize it?

787
00:43:41,960 --> 00:43:43,960
You don't get like that in a year.

788
00:43:43,960 --> 00:43:45,960
It's a question.

789
00:43:45,960 --> 00:43:47,960
Why do they choose a chain hash table?

790
00:43:47,960 --> 00:43:48,960
I don't know.

791
00:43:48,960 --> 00:43:50,960
Then how do you resize it?

792
00:43:50,960 --> 00:43:51,960
You don't.

793
00:43:51,960 --> 00:43:54,960
You basically say,

794
00:43:54,960 --> 00:43:58,960
you basically say, you define,

795
00:43:58,960 --> 00:44:01,960
you allocate the amount of memory you want at the very beginning.

796
00:44:01,960 --> 00:44:03,960
And then if you run out,

797
00:44:03,960 --> 00:44:06,960
I mean, I think you've got to turn it off and turn it back on.

798
00:44:06,960 --> 00:44:08,960
But now, for the periodic checkpoints,

799
00:44:08,960 --> 00:44:10,960
because I think it's just writing out the contents of memory,

800
00:44:10,960 --> 00:44:12,960
so it's literally writing out the data structures of memory,

801
00:44:12,960 --> 00:44:14,960
I don't know whether you can resize it

802
00:44:14,960 --> 00:44:15,960
based on a checkpoint,

803
00:44:15,960 --> 00:44:16,960
or whether you get the replayed entire,

804
00:44:16,960 --> 00:44:18,960
right, or a log to repopulate it.

805
00:44:21,960 --> 00:44:24,960
All right, so they have some notion on transactions.

806
00:44:24,960 --> 00:44:28,960
But the basically way it works is it's client-side transactions.

807
00:44:28,960 --> 00:44:30,960
I don't know how to do this in the command line.

808
00:44:30,960 --> 00:44:31,960
We could look it up,

809
00:44:31,960 --> 00:44:33,960
because it's not begin commit.

810
00:44:33,960 --> 00:44:36,960
When you call begin,

811
00:44:36,960 --> 00:44:39,960
they're going to begin on the client side.

812
00:44:39,960 --> 00:44:42,960
Then any operation you apply,

813
00:44:42,960 --> 00:44:44,960
then it just gets batched.

814
00:44:44,960 --> 00:44:45,960
And then when you go commit,

815
00:44:45,960 --> 00:44:49,960
then everything gets sent over the wire to the Davies server.

816
00:44:49,960 --> 00:44:51,960
And again, because it's single threaded,

817
00:44:51,960 --> 00:44:54,960
then it just runs whatever commands you provide it all at once.

818
00:44:54,960 --> 00:44:57,960
That's their notion of transactions.

819
00:44:57,960 --> 00:45:00,960
So the problem, though, is they don't allow for a rollback.

820
00:45:00,960 --> 00:45:04,960
So if I send a batch of queries over to do updates,

821
00:45:04,960 --> 00:45:06,960
and I make a mistake, like I showed before,

822
00:45:06,960 --> 00:45:08,960
and I update, say I have two records,

823
00:45:08,960 --> 00:45:09,960
then I make a mistake,

824
00:45:09,960 --> 00:45:10,960
and the transaction gets aborted,

825
00:45:10,960 --> 00:45:13,960
and I can't rollback the previous things that I already did.

826
00:45:13,960 --> 00:45:16,960
So there's not true at atomic transactions,

827
00:45:16,960 --> 00:45:20,960
at least in the open source version.

828
00:45:20,960 --> 00:45:21,960
For the replication,

829
00:45:21,960 --> 00:45:24,960
they're doing asynchronous primary replica replication.

830
00:45:24,960 --> 00:45:27,960
So the master is just going to send the op-log of the commands

831
00:45:27,960 --> 00:45:28,960
that came out of the wire,

832
00:45:28,960 --> 00:45:30,960
do down-street replicas.

833
00:45:30,960 --> 00:45:34,960
And you can configure it to allow the primary to wait

834
00:45:34,960 --> 00:45:37,960
until some quorum of the replicas respond

835
00:45:37,960 --> 00:45:39,960
and they got the requests.

836
00:45:39,960 --> 00:45:40,960
Not that they actually applied them,

837
00:45:40,960 --> 00:45:42,960
that they just got the network messages.

838
00:45:42,960 --> 00:45:45,960
By default, though, I don't think that's turned on.

839
00:45:45,960 --> 00:45:48,960
So it's like eventually consistent.

840
00:45:48,960 --> 00:45:50,960
Again, for a cache, that's probably okay.

841
00:45:50,960 --> 00:45:56,960
The primary data base, or primary storage, probably a bad idea.

842
00:45:56,960 --> 00:45:58,960
Okay?

843
00:45:58,960 --> 00:46:00,960
So one thing I hope you get out of this,

844
00:46:00,960 --> 00:46:02,960
going with these systems very quickly,

845
00:46:02,960 --> 00:46:04,960
is that there's a bunch of these buzzwords I'm using

846
00:46:04,960 --> 00:46:05,960
that we've covered throughout the semester.

847
00:46:05,960 --> 00:46:07,960
You see now how you can look at any system

848
00:46:08,960 --> 00:46:10,960
and apply the concepts and methods and things

849
00:46:10,960 --> 00:46:12,960
we talked about throughout the entire semester,

850
00:46:12,960 --> 00:46:14,960
and say, okay, now I understand what the systems actually do

851
00:46:14,960 --> 00:46:16,960
and when they say they're this or they're doing that.

852
00:46:16,960 --> 00:46:21,960
And what would it pose the cons of all of them?

853
00:46:21,960 --> 00:46:26,960
All right, so the next one that was the most was cucklers DB.

854
00:46:26,960 --> 00:46:29,960
So cuckler DB came out in 2015.

855
00:46:29,960 --> 00:46:32,960
It was less so recently,

856
00:46:32,960 --> 00:46:34,960
but initially when it first came out,

857
00:46:34,960 --> 00:46:36,960
it was sort of incorrectly described

858
00:46:36,960 --> 00:46:38,960
as the open source version of Google Spanner,

859
00:46:38,960 --> 00:46:41,960
because the co-founders worked at Google

860
00:46:41,960 --> 00:46:43,960
before they started cucklers DB,

861
00:46:43,960 --> 00:46:45,960
but they didn't work on Spanner.

862
00:46:45,960 --> 00:46:47,960
They just said, let's go a bit of distributed data system.

863
00:46:47,960 --> 00:46:50,960
So it's a distributed relational data system that's written and go,

864
00:46:50,960 --> 00:46:54,960
and it's going to be a decentralized homogenous shared nothing architecture

865
00:46:54,960 --> 00:46:57,960
that's going to use rain partition to split the data

866
00:46:57,960 --> 00:46:59,960
across different nodes.

867
00:46:59,960 --> 00:47:02,960
So it's going to be, they can be post-cress compatible,

868
00:47:02,960 --> 00:47:05,960
but for the SQL dialect and for the wire protocol

869
00:47:05,960 --> 00:47:07,960
and the catalog, meaning like in theory,

870
00:47:07,960 --> 00:47:10,960
if I have my application written for post-cress using post-cress,

871
00:47:10,960 --> 00:47:12,960
you know, SQL syntax and so forth,

872
00:47:12,960 --> 00:47:15,960
and post-cress, you know, client drivers,

873
00:47:15,960 --> 00:47:17,960
I could just point at that cuckler should everything will work.

874
00:47:17,960 --> 00:47:20,960
Not entirely true, some things will be different,

875
00:47:20,960 --> 00:47:21,960
semantics or certain things will be different

876
00:47:21,960 --> 00:47:23,960
because cuckler DB is distributed.

877
00:47:23,960 --> 00:47:27,960
And certainly there's new features to come out in post-cress

878
00:47:27,960 --> 00:47:29,960
that just came out,

879
00:47:29,960 --> 00:47:32,960
the cuckler's pie wouldn't support that.

880
00:47:32,960 --> 00:47:34,960
So we haven't really talked about licensing models this semester,

881
00:47:34,960 --> 00:47:39,960
but it's interesting to point out that cuckler's DB is open source,

882
00:47:39,960 --> 00:47:43,960
but they use what is called the BSL, the business source license.

883
00:47:43,960 --> 00:47:49,960
And this is sort of a trend that lasts five, six, seven,

884
00:47:49,960 --> 00:47:51,960
eight years in databases, in particular,

885
00:47:51,960 --> 00:47:53,960
probably in other open source projects,

886
00:47:53,960 --> 00:47:56,960
but definitely in databases where it is open source,

887
00:47:56,960 --> 00:48:00,960
but the idea is that if you're just like, you know,

888
00:48:00,960 --> 00:48:02,960
research, researchers like us,

889
00:48:02,960 --> 00:48:04,960
or just like, you know, building a hobby project,

890
00:48:04,960 --> 00:48:06,960
or just want to use it for your, you know,

891
00:48:06,960 --> 00:48:07,960
for whatever your application is,

892
00:48:07,960 --> 00:48:09,960
you can just download the software and you can just use it.

893
00:48:09,960 --> 00:48:11,960
The BSL, so it's open source,

894
00:48:11,960 --> 00:48:14,960
but it prevents you from being a cloud vendor

895
00:48:14,960 --> 00:48:16,960
and taking their software and then selling it as a service,

896
00:48:16,960 --> 00:48:20,960
like an Amazon, like a Google, like a Microsoft.

897
00:48:20,960 --> 00:48:23,960
And as a bunch of systems have changed their licensing model

898
00:48:23,960 --> 00:48:25,960
to switch to something like the BSL,

899
00:48:25,960 --> 00:48:27,960
Mongo has something similar,

900
00:48:27,960 --> 00:48:29,960
a elastic switch to something similar.

901
00:48:29,960 --> 00:48:31,960
And again, basically, there's a bunch of these open source projects

902
00:48:31,960 --> 00:48:36,960
where Amazon was making more money selling their data system

903
00:48:36,960 --> 00:48:40,960
than the actual people building the data system.

904
00:48:40,960 --> 00:48:44,960
And so they switched this licensing model to prevent that.

905
00:48:44,960 --> 00:48:46,960
It hasn't been challenged in court,

906
00:48:46,960 --> 00:48:48,960
but there's been enough,

907
00:48:48,960 --> 00:48:52,960
it's enough to scare away some cloud vendors from doing certain things.

908
00:48:52,960 --> 00:48:55,960
Mongo has had dust-ups with Amazon,

909
00:48:55,960 --> 00:48:58,960
elastic search had dust-ups with Amazon,

910
00:48:59,960 --> 00:49:02,960
so Amazon forked it and things called open search now.

911
00:49:02,960 --> 00:49:04,960
Everyone's trying to avoid getting taken over,

912
00:49:04,960 --> 00:49:07,960
eating a lie by the cloud vendors.

913
00:49:07,960 --> 00:49:09,960
So, Cochishy B, on every single note,

914
00:49:09,960 --> 00:49:10,960
even though it's distributed,

915
00:49:10,960 --> 00:49:12,960
it's going to be log-truck your storage.

916
00:49:12,960 --> 00:49:14,960
Let's talk about that in a second.

917
00:49:14,960 --> 00:49:16,960
The query engine is going to be a pool-based,

918
00:49:16,960 --> 00:49:19,960
a pool-based, vectorized processing model.

919
00:49:19,960 --> 00:49:22,960
So you even know it was originally designed for OOTP.

920
00:49:22,960 --> 00:49:24,960
They switched to a vectorized model a few years ago

921
00:49:24,960 --> 00:49:27,960
because they want to support also analytics on the system.

922
00:49:27,960 --> 00:49:30,960
And they're going to do MVGC, OCC,

923
00:49:30,960 --> 00:49:32,960
and what's interesting is that all the transactions,

924
00:49:32,960 --> 00:49:33,960
even distributed transactions,

925
00:49:33,960 --> 00:49:36,960
will run with a serializable isolation level.

926
00:49:36,960 --> 00:49:38,960
Like if you call, like, I want to run read and committed

927
00:49:38,960 --> 00:49:39,960
or recommitted,

928
00:49:39,960 --> 00:49:43,960
that's just an alias for serializable.

929
00:49:43,960 --> 00:49:46,960
They don't run anything lower than that,

930
00:49:46,960 --> 00:49:48,960
which is really interesting.

931
00:49:49,960 --> 00:49:51,960
So the way they want Cochishy's architecture,

932
00:49:51,960 --> 00:49:54,960
it's the multilayer stuff that we've been seeing before,

933
00:49:54,960 --> 00:49:58,960
but at its core, it's just a replicated key value store.

934
00:49:58,960 --> 00:50:01,960
And that there's this infrastructure on top of the database system,

935
00:50:01,960 --> 00:50:03,960
or on top of the key value store,

936
00:50:03,960 --> 00:50:05,960
that understands SQL, understands partitioning schemes,

937
00:50:05,960 --> 00:50:07,960
understands transactions and so forth.

938
00:50:07,960 --> 00:50:10,960
And so they're basically, you can think of the storage layer,

939
00:50:10,960 --> 00:50:14,960
it's just a giant sort of map in the key value store,

940
00:50:14,960 --> 00:50:16,960
and then the upper layers are trying to figure out,

941
00:50:16,960 --> 00:50:18,960
okay, for this query, you need data from here

942
00:50:18,960 --> 00:50:20,960
and go up here and so forth, right?

943
00:50:20,960 --> 00:50:22,960
So when Cochishy B first came out,

944
00:50:22,960 --> 00:50:27,960
they were using RoxyB, which is Facebook's log structure

945
00:50:27,960 --> 00:50:29,960
to key value store, like this single note

946
00:50:29,960 --> 00:50:31,960
embedded database system.

947
00:50:31,960 --> 00:50:34,960
And then I remember they were telling me a few years ago

948
00:50:34,960 --> 00:50:36,960
when I went to go visit them, that the overhead

949
00:50:36,960 --> 00:50:40,960
of going from go into SQL Sustained for RoxyB

950
00:50:40,960 --> 00:50:42,960
was, the overhead was quite high.

951
00:50:42,960 --> 00:50:44,960
So a few years ago, they threw RoxyB away

952
00:50:44,960 --> 00:50:49,960
and they wrote their own clone of RoxyB in Go called Pebble.

953
00:50:50,960 --> 00:50:54,960
And that way, the whole stack is now entirely written in Go.

954
00:50:55,960 --> 00:50:57,960
And that's the logo for Pebble that I made,

955
00:50:57,960 --> 00:50:59,960
because they didn't have one so I sent it to them,

956
00:50:59,960 --> 00:51:01,960
because I had to put something.

957
00:51:02,960 --> 00:51:05,960
Anyway, and to do transactions,

958
00:51:05,960 --> 00:51:06,960
they're not going to use two-base commit,

959
00:51:06,960 --> 00:51:09,960
they're not going to use Paxos, they're going to use Rafft,

960
00:51:09,960 --> 00:51:12,960
which again, it's just a variant of Paxos

961
00:51:12,960 --> 00:51:14,960
that we talked about last time.

962
00:51:16,960 --> 00:51:18,960
So the way they're going to order transactions is interesting.

963
00:51:19,960 --> 00:51:21,960
So they're going to use what are called hybrid clocks,

964
00:51:21,960 --> 00:51:23,960
which I think we talked about a little bit earlier

965
00:51:23,960 --> 00:51:26,960
in the semester, where, because now,

966
00:51:26,960 --> 00:51:28,960
they want to run transactions across nodes

967
00:51:28,960 --> 00:51:31,960
that could be in different locations around the world

968
00:51:31,960 --> 00:51:33,960
in the data center, you can't guarantee

969
00:51:33,960 --> 00:51:36,960
that their times are all going to be tightly synchronized.

970
00:51:36,960 --> 00:51:40,960
And so the transactions are going to get timestamps

971
00:51:40,960 --> 00:51:43,960
using a combination of the wall clock time

972
00:51:43,960 --> 00:51:45,960
and you get from the server you're running on,

973
00:51:46,960 --> 00:51:48,960
and then a logical counter,

974
00:51:48,960 --> 00:51:51,960
and like a host ID to break ties.

975
00:51:52,960 --> 00:51:56,960
And that's enough to make every transaction globally unique

976
00:51:56,960 --> 00:52:00,960
and also determine the order in which transactions should commit.

977
00:52:01,960 --> 00:52:04,960
So the local clocks are still being synchronized using NTP,

978
00:52:04,960 --> 00:52:06,960
but it's not going to be super precise.

979
00:52:06,960 --> 00:52:07,960
Like when we talked about Spanner,

980
00:52:07,960 --> 00:52:11,960
they were using GPS satellite receivers and atomic clocks,

981
00:52:11,960 --> 00:52:14,960
and that guarantee their times would be within some bounds

982
00:52:15,960 --> 00:52:17,960
of being of a synchronized across the world.

983
00:52:17,960 --> 00:52:19,960
But in this, in cockroach TV,

984
00:52:19,960 --> 00:52:21,960
since they can't run that proprietary hardware,

985
00:52:21,960 --> 00:52:24,960
they rely on the wall clocks being loosely synchronized,

986
00:52:24,960 --> 00:52:27,960
and that's just good enough for them to,

987
00:52:27,960 --> 00:52:32,960
to at least coordinate without massive delays.

988
00:52:33,960 --> 00:52:35,960
Of course, now, if you have some node where like the clocks

989
00:52:35,960 --> 00:52:36,960
way off by like an hour,

990
00:52:36,960 --> 00:52:37,960
then every transaction is going to fail,

991
00:52:37,960 --> 00:52:42,960
because those transactions are going to be way back in the past,

992
00:52:42,960 --> 00:52:43,960
and that will break things.

993
00:52:43,960 --> 00:52:45,960
And therefore, you manually intervene to kill that node,

994
00:52:45,960 --> 00:52:47,960
but that's beside the point.

995
00:52:48,960 --> 00:52:50,960
So for OCC, the way they're going to do is

996
00:52:50,960 --> 00:52:52,960
that the transaction is going to stage all the rights as intense,

997
00:52:52,960 --> 00:52:54,960
and then when they go commit, then they go,

998
00:52:54,960 --> 00:52:56,960
that's when they go check to see whether

999
00:52:56,960 --> 00:52:59,960
you pass the validation phase to allow the store to stop.

1000
00:52:59,960 --> 00:53:02,960
And then all the metadata about where the transaction state

1001
00:53:02,960 --> 00:53:06,960
and the partition scheme or the catalog of the data to self,

1002
00:53:06,960 --> 00:53:10,960
that's just also stored it as a table in the key value store.

1003
00:53:11,960 --> 00:53:15,960
And that's replicated and you do transactions on top of that.

1004
00:53:17,960 --> 00:53:19,960
So here's the basic overview of how a transaction will work.

1005
00:53:19,960 --> 00:53:21,960
Again, so you have some kind of catalog that keeps track

1006
00:53:21,960 --> 00:53:23,960
of the partition scheme of the database,

1007
00:53:23,960 --> 00:53:26,960
and I think by default, in Cochris DB,

1008
00:53:26,960 --> 00:53:28,960
everything's always range partitioned.

1009
00:53:28,960 --> 00:53:31,960
And so this state catalog, we replicate it across all the nodes.

1010
00:53:32,960 --> 00:53:34,960
So if I want to do an update,

1011
00:53:34,960 --> 00:53:37,960
say a simple case where I'm updating on the primary key,

1012
00:53:38,960 --> 00:53:43,960
I go check the catalog to say where can I find this partition?

1013
00:53:44,960 --> 00:53:47,960
And then I'll figure out which one is the leader,

1014
00:53:47,960 --> 00:53:50,960
and he's run leader election for that partition whenever you need to,

1015
00:53:50,960 --> 00:53:52,960
determine who's the leader.

1016
00:53:52,960 --> 00:53:55,960
And then all the rights will go to this node, the leader,

1017
00:53:55,960 --> 00:53:57,960
and then it's responsible for them propagating the updates

1018
00:53:57,960 --> 00:54:01,960
to the other partitions or other nodes that have the replicated copies

1019
00:54:01,960 --> 00:54:04,960
of that partition using RAPT,

1020
00:54:04,960 --> 00:54:07,960
and then get everyone to agree that this changed a lot to happen,

1021
00:54:07,960 --> 00:54:09,960
and then you go ahead and commit.

1022
00:54:10,960 --> 00:54:14,960
When you do a read, by default,

1023
00:54:14,960 --> 00:54:17,960
you would always want to go read from the leader,

1024
00:54:17,960 --> 00:54:21,960
because again, they only run with serialized isolation level,

1025
00:54:21,960 --> 00:54:24,960
so you can't do by default still reads.

1026
00:54:24,960 --> 00:54:26,960
So you can guarantee, if you always go to the leader,

1027
00:54:26,960 --> 00:54:28,960
that you always see the latest version of any object

1028
00:54:28,960 --> 00:54:29,960
that you're looking for.

1029
00:54:29,960 --> 00:54:32,960
So you'll be directed to go do reads here.

1030
00:54:33,960 --> 00:54:35,960
And obviously when we talked about primary RAPT,

1031
00:54:35,960 --> 00:54:37,960
like replication versus multi-home,

1032
00:54:37,960 --> 00:54:40,960
this was, if all your rights are going to the leader,

1033
00:54:40,960 --> 00:54:42,960
and all your reads are going to the leader,

1034
00:54:42,960 --> 00:54:46,960
the leader can become a bottleneck and slow things down.

1035
00:54:46,960 --> 00:54:50,960
So I don't think they don't let you set the isolation level

1036
00:54:50,960 --> 00:54:52,960
to go read from other nodes.

1037
00:54:52,960 --> 00:54:55,960
You actually have to modify the SQL syntax to introduce the,

1038
00:54:55,960 --> 00:54:58,960
or give a hint to the database system that you're okay

1039
00:54:58,960 --> 00:55:01,960
with reading STALE data on the replicas.

1040
00:55:01,960 --> 00:55:03,960
So in this case here, you change the select query to say,

1041
00:55:03,960 --> 00:55:07,960
select from table XXX, as a system time within the max STALE,

1042
00:55:07,960 --> 00:55:09,960
STALE in a sub 10 seconds.

1043
00:55:09,960 --> 00:55:12,960
So this men allow the data inside, okay,

1044
00:55:12,960 --> 00:55:15,960
if this node is at least 10 seconds in sync with the leader,

1045
00:55:15,960 --> 00:55:19,960
I can then read any data from that.

1046
00:55:19,960 --> 00:55:21,960
So although CockersDB is open source,

1047
00:55:21,960 --> 00:55:23,960
I think for this feature, it's only available in like,

1048
00:55:23,960 --> 00:55:27,960
the enterprise commercial version.

1049
00:55:28,960 --> 00:55:30,960
So again, CockersDB,

1050
00:55:30,960 --> 00:55:32,960
decentralized, homogeneous,

1051
00:55:32,960 --> 00:55:36,960
shared nothing distributed database system that's using raft

1052
00:55:36,960 --> 00:55:38,960
to do transactions across different nodes,

1053
00:55:38,960 --> 00:55:41,960
and they're doing multi-versioning on top of that.

1054
00:55:44,960 --> 00:55:46,960
All right, next one, snowflake.

1055
00:55:46,960 --> 00:55:50,960
So if you take 721, we're going to spend a lot of time talking about snowflake.

1056
00:55:50,960 --> 00:55:53,960
So it's one of the first cloud native,

1057
00:55:54,960 --> 00:55:55,960
OLA updated the systems.

1058
00:55:55,960 --> 00:55:57,960
Everything's written in C++.

1059
00:55:57,960 --> 00:56:01,960
It's one of the first systems that did a shared disk architecture,

1060
00:56:01,960 --> 00:56:03,960
at least with a cloud.

1061
00:56:03,960 --> 00:56:07,960
The query engine itself is going to be a push-based vectorized query processing engine.

1062
00:56:07,960 --> 00:56:10,960
And this is what actually made snowflake different than a bunch of other systems

1063
00:56:10,960 --> 00:56:14,960
that sort of, we're trying to analyze at that time.

1064
00:56:14,960 --> 00:56:17,960
In fact, they leverage very heavily on using SIMD

1065
00:56:17,960 --> 00:56:19,960
or vectorizing structures on the CPU,

1066
00:56:19,960 --> 00:56:22,960
the process things in parallel within operators.

1067
00:56:24,960 --> 00:56:30,960
To avoid the overhead of trying to interpret bytes or the types of columns and data

1068
00:56:30,960 --> 00:56:34,960
at runtime and having a bunch of indirection in the code,

1069
00:56:34,960 --> 00:56:36,960
like a giant switch statement says,

1070
00:56:36,960 --> 00:56:38,960
if I'm adding two numbers together or two values together,

1071
00:56:38,960 --> 00:56:40,960
if this integer do this, if the float do that,

1072
00:56:40,960 --> 00:56:44,960
they want to avoid all that indirection because it's not great for modern CPUs.

1073
00:56:44,960 --> 00:56:49,960
So what they do is they pre-compile all these low-level primitive operations

1074
00:56:49,960 --> 00:56:51,960
for different data types.

1075
00:56:52,960 --> 00:56:55,960
So if I want to add two types together,

1076
00:56:55,960 --> 00:57:00,960
or I want to check maybe whether a value is greater than another value.

1077
00:57:00,960 --> 00:57:03,960
So I would have different copies of that same function,

1078
00:57:03,960 --> 00:57:08,960
but one for floats, one for integers, one for strings, one for dates, and so forth.

1079
00:57:08,960 --> 00:57:14,960
And you pre-compile them when you're actually making the build for the system.

1080
00:57:14,960 --> 00:57:17,960
And then at runtime, you go figure out, because you have a catalog,

1081
00:57:17,960 --> 00:57:18,960
you can look in the schema and say,

1082
00:57:18,960 --> 00:57:20,960
oh, I know I'm going to operate in a column with this type.

1083
00:57:20,960 --> 00:57:24,960
Then you go pick the primitive out that knows how to operate on 32-bit integers

1084
00:57:24,960 --> 00:57:26,960
or 64-bit integers and so forth.

1085
00:57:28,960 --> 00:57:29,960
Yes.

1086
00:57:29,960 --> 00:57:32,960
Is this being like, if I did a flip-flop template?

1087
00:57:32,960 --> 00:57:34,960
Sqs, would this be able to see the list template? Yes.

1088
00:57:37,960 --> 00:57:38,960
In bust-top, we don't do that.

1089
00:57:38,960 --> 00:57:42,960
In bust-top, if you look at the value code for the value types,

1090
00:57:42,960 --> 00:57:44,960
there's a switch statement.

1091
00:57:44,960 --> 00:57:45,960
And that's how most systems do it.

1092
00:57:45,960 --> 00:57:47,960
Post-crested others, my SQL does a lot of stuff to do this.

1093
00:57:49,960 --> 00:57:52,960
But again, I'm going to read a billion two-poles, and the type is always going to be the same.

1094
00:57:52,960 --> 00:57:54,960
I don't want to do that switch statement over and over again.

1095
00:57:54,960 --> 00:57:55,960
It's a waste.

1096
00:57:55,960 --> 00:57:57,960
What's the other thing you have the same code?

1097
00:57:57,960 --> 00:57:58,960
You're going to be writing the same code, right?

1098
00:57:58,960 --> 00:57:59,960
You have a switch statement.

1099
00:57:59,960 --> 00:58:00,960
You have all these different versions of what's going to happen.

1100
00:58:00,960 --> 00:58:03,960
Like, there's a save you much to do with a switch statement.

1101
00:58:03,960 --> 00:58:08,960
There's a save you much to do over a switch statement.

1102
00:58:10,960 --> 00:58:14,960
But like, think of like, it's more like the dispatch code.

1103
00:58:14,960 --> 00:58:16,960
So you give it to the switch statement, and you literally say,

1104
00:58:16,960 --> 00:58:19,960
here's the pointer to the function that does 32-bit integer comparisons.

1105
00:58:19,960 --> 00:58:22,960
Then at runtime, when you generate the query plan,

1106
00:58:22,960 --> 00:58:25,960
you literally put in the point, you call that pointer,

1107
00:58:25,960 --> 00:58:27,960
instead of calling the function that has a switch statement,

1108
00:58:27,960 --> 00:58:29,960
the man calls that for you.

1109
00:58:29,960 --> 00:58:31,960
It's like a software engineering thing.

1110
00:58:31,960 --> 00:58:33,960
Do you say much time doing switch statement?

1111
00:58:33,960 --> 00:58:36,960
You're writing all the same things that you did in the last time.

1112
00:58:36,960 --> 00:58:38,960
Do you say much time, sorry, what?

1113
00:58:38,960 --> 00:58:40,960
You're using switch statements instead of time, but...

1114
00:58:40,960 --> 00:58:43,960
No, you want to get rid of the switch statement. Yes.

1115
00:58:43,960 --> 00:58:46,960
I guess I'm asking why would you not do this?

1116
00:58:46,960 --> 00:58:48,960
Because there's a software engineering overhead.

1117
00:58:48,960 --> 00:58:50,960
You have to design your system for this.

1118
00:58:50,960 --> 00:58:51,960
To do this.

1119
00:58:51,960 --> 00:58:53,960
And prior to...

1120
00:58:53,960 --> 00:58:54,960
There's another system before it's Snowflake.

1121
00:58:54,960 --> 00:58:57,960
The co-founder Snowflake, but another system called vector-wise,

1122
00:58:57,960 --> 00:59:01,960
which is a four-community B, which is one of the early comms store systems.

1123
00:59:01,960 --> 00:59:05,960
Prior to them, the vector-wise view, I think,

1124
00:59:05,960 --> 00:59:07,960
innovated on this.

1125
00:59:07,960 --> 00:59:09,960
Like, nobody did it this way.

1126
00:59:10,960 --> 00:59:11,960
Just...

1127
00:59:11,960 --> 00:59:13,960
Because they didn't, I don't know.

1128
00:59:13,960 --> 00:59:16,960
The alternative is also pre...

1129
00:59:16,960 --> 00:59:17,960
Like, you can do code generation.

1130
00:59:17,960 --> 00:59:19,960
Like, what single store was talking about?

1131
00:59:19,960 --> 00:59:21,960
Like, you take the query plan, they generate the YOP codes,

1132
00:59:21,960 --> 00:59:23,960
and they compile that to machine code for every single query.

1133
00:59:23,960 --> 00:59:25,960
The alternative is to do that.

1134
00:59:25,960 --> 00:59:27,960
But I did that in the 70s,

1135
00:59:27,960 --> 00:59:30,960
and then abandoned it because it was a software engineering overhead.

1136
00:59:32,960 --> 00:59:35,960
Also, too, comms stores weren't really a thing until the 2000s.

1137
00:59:35,960 --> 00:59:37,960
So it didn't really make sense.

1138
00:59:38,960 --> 00:59:40,960
Like, for doing OTP stuff,

1139
00:59:40,960 --> 00:59:41,960
like in a bus tub,

1140
00:59:41,960 --> 00:59:42,960
post with my SQL system,

1141
00:59:42,960 --> 00:59:44,960
you're going to grab one row.

1142
00:59:44,960 --> 00:59:46,960
It won't make a difference.

1143
00:59:46,960 --> 00:59:47,960
But now, if you're doing O-lap,

1144
00:59:47,960 --> 00:59:49,960
where you're just ripping through an account of a billion tuples,

1145
00:59:49,960 --> 00:59:51,960
that switch statement becomes a big bottleneck.

1146
00:59:54,960 --> 00:59:57,960
All right, so they're going to separate the table data from the metadata,

1147
00:59:57,960 --> 00:59:58,960
and I'll talk about it in a second.

1148
00:59:58,960 --> 01:00:00,960
There is no buffer pool at every single node.

1149
01:00:00,960 --> 01:00:04,960
There is a cache, but it's not what we think of as traditional buffer pool.

1150
01:00:05,960 --> 01:00:12,960
And then the internal storage format for Snorflex,

1151
01:00:12,960 --> 01:00:15,960
Snorflex is basically packs that we talked about before.

1152
01:00:15,960 --> 01:00:17,960
But they do support reading data from park, CSVs,

1153
01:00:17,960 --> 01:00:19,960
and all other data types you would have.

1154
01:00:21,960 --> 01:00:23,960
All right, so the architecture itself is,

1155
01:00:23,960 --> 01:00:26,960
let's take a time to go through this real quickly.

1156
01:00:26,960 --> 01:00:28,960
But it's just aggregate storage.

1157
01:00:28,960 --> 01:00:30,960
So you have the compute nodes,

1158
01:00:30,960 --> 01:00:31,960
and then you have the storage.

1159
01:00:32,960 --> 01:00:35,960
And then all the storage is just the cloud object storage stuff we talked about before.

1160
01:00:35,960 --> 01:00:38,960
So we talked about before about, like I said,

1161
01:00:38,960 --> 01:00:39,960
you don't want to use the OS for anything,

1162
01:00:39,960 --> 01:00:41,960
but when it comes to a cloud database,

1163
01:00:41,960 --> 01:00:44,960
it's maybe you want to use Amazon's S3 or Azure Storage,

1164
01:00:44,960 --> 01:00:46,960
and aren't giving things up.

1165
01:00:46,960 --> 01:00:48,960
So in the research papers about Snorflex,

1166
01:00:48,960 --> 01:00:51,960
they talk about how it made their lives so much easier

1167
01:00:51,960 --> 01:00:54,960
to all float all that storage stuff to Amazon,

1168
01:00:54,960 --> 01:00:57,960
and it's worth making a really fast engine.

1169
01:00:58,960 --> 01:01:01,960
So you can, and it gives you the flexibility of scaling out

1170
01:01:01,960 --> 01:01:04,960
compute separately from the storage.

1171
01:01:04,960 --> 01:01:08,960
So the sake of time, I want to skip all of this.

1172
01:01:10,960 --> 01:01:12,960
I think we already talked about this.

1173
01:01:12,960 --> 01:01:15,960
But let me tell one thing they do do is that it is actually interesting.

1174
01:01:16,960 --> 01:01:21,960
So, the S3 shows up that wants to scan a lot of data, right?

1175
01:01:21,960 --> 01:01:23,960
And say that we're doing a simple join here,

1176
01:01:23,960 --> 01:01:25,960
and the build side and the probe side.

1177
01:01:26,960 --> 01:01:31,960
But let's say that this side of the query is doing a massive scan

1178
01:01:31,960 --> 01:01:34,960
on maybe petabytes of data.

1179
01:01:34,960 --> 01:01:40,960
And if I have a fixed number of machines or workers

1180
01:01:40,960 --> 01:01:45,960
to process this query, this will become a bottleneck for you.

1181
01:01:45,960 --> 01:01:48,960
So what they have the ability to do is while the query is running,

1182
01:01:48,960 --> 01:01:51,960
they can identify that, okay, I have to,

1183
01:01:51,960 --> 01:01:53,960
this side is taking too long.

1184
01:01:53,960 --> 01:01:59,960
So they can dynamically rewrite the query plan to split it up

1185
01:01:59,960 --> 01:02:02,960
into separate operations.

1186
01:02:02,960 --> 01:02:07,960
And in this case here, you can basically add more nodes.

1187
01:02:07,960 --> 01:02:10,960
They start doing the table scan you need,

1188
01:02:10,960 --> 01:02:13,960
and they're going to write it out to one to attempt files.

1189
01:02:13,960 --> 01:02:18,960
And then you load it back in on the regular worker nodes,

1190
01:02:18,960 --> 01:02:21,960
they're then doing union all, and then you produce the correct answer.

1191
01:02:21,960 --> 01:02:24,960
So like while the query is running, they can add more nodes

1192
01:02:24,960 --> 01:02:26,960
to scale things out dynamically.

1193
01:02:26,960 --> 01:02:32,960
And use the user or the customer you don't know, right?

1194
01:02:32,960 --> 01:02:35,960
And then the enemy results are just getting it back to S3.

1195
01:02:35,960 --> 01:02:38,960
So for them, that's cheap and fast.

1196
01:02:38,960 --> 01:02:40,960
Fast enough.

1197
01:02:40,960 --> 01:02:42,960
Yes.

1198
01:02:42,960 --> 01:02:44,960
Is this different from the Michela's view?

1199
01:02:44,960 --> 01:02:46,960
So Michela's view would be like,

1200
01:02:46,960 --> 01:02:49,960
I compute the answer once,

1201
01:02:49,960 --> 01:02:53,960
and then other queries can then reuse that result.

1202
01:02:53,960 --> 01:02:56,960
And then if the table gets updated or anything gets updated,

1203
01:02:56,960 --> 01:02:58,960
then it gets automatically updated.

1204
01:02:58,960 --> 01:03:02,960
This is just for a single query, yes.

1205
01:03:02,960 --> 01:03:09,960
And also too, I don't think this thing supports incremental updates.

1206
01:03:09,960 --> 01:03:12,960
Like Delta, something like that.

1207
01:03:12,960 --> 01:03:18,960
Is this done like basically a process?

1208
01:03:18,960 --> 01:03:21,960
The question is, how do they figure this out?

1209
01:03:21,960 --> 01:03:26,960
Is this done while it's running or is it done before it starts running?

1210
01:03:26,960 --> 01:03:28,960
Actually, I think I missedpoke.

1211
01:03:28,960 --> 01:03:30,960
It's done at query optimization time.

1212
01:03:30,960 --> 01:03:33,960
So they look at it, they know how much data you're going to read,

1213
01:03:33,960 --> 01:03:36,960
they know that this is going to be a bottleneck.

1214
01:03:36,960 --> 01:03:39,960
Therefore they can give you a resources ahead of time.

1215
01:03:39,960 --> 01:03:41,960
The estimation I think, yes.

1216
01:03:41,960 --> 01:03:43,960
What's the edge of the thing about is that the extra resources

1217
01:03:43,960 --> 01:03:47,960
they're coming from, they're not like things you have to pre-allocate.

1218
01:03:47,960 --> 01:03:50,960
They have basically like a bullpen or like a spare worker pool.

1219
01:03:50,960 --> 01:03:52,960
I think you can borrow nodes from other customers

1220
01:03:52,960 --> 01:03:55,960
because none of the covers of this is all hidden from you.

1221
01:03:55,960 --> 01:03:58,960
So you basically say, say you pay for like, I want five compute nodes.

1222
01:03:58,960 --> 01:04:00,960
This query shows up and they'll give you maybe a few extra

1223
01:04:00,960 --> 01:04:04,960
just to finish the query and you're borrowing them from somebody else.

1224
01:04:04,960 --> 01:04:07,960
And that's all hidden from you.

1225
01:04:07,960 --> 01:04:11,960
Because otherwise they would be idle.

1226
01:04:11,960 --> 01:04:12,960
Okay.

1227
01:04:12,960 --> 01:04:16,960
Again, so snowflake, again, it's a distributed share data.

1228
01:04:16,960 --> 01:04:21,960
ShareDesk, vectorized push-based O-lap engine

1229
01:04:21,960 --> 01:04:23,960
that runs entirely off of...

1230
01:04:23,960 --> 01:04:25,960
They originally started on S3,

1231
01:04:25,960 --> 01:04:27,960
but they support other cloud platforms as well.

1232
01:04:27,960 --> 01:04:31,960
And remember, I think the Marcin, the co-founder,

1233
01:04:31,960 --> 01:04:33,960
like in the early days, people are asking,

1234
01:04:33,960 --> 01:04:34,960
you know, you're crazy to be cloud native.

1235
01:04:34,960 --> 01:04:36,960
You know, I went around on-prem, make it around on-prem.

1236
01:04:36,960 --> 01:04:38,960
And they made the hard choice of deciding not to do that,

1237
01:04:38,960 --> 01:04:40,960
even though some customers were offering their money

1238
01:04:40,960 --> 01:04:42,960
and in the end it paid off.

1239
01:04:42,960 --> 01:04:46,960
And they went IPO 2018, 2017.

1240
01:04:46,960 --> 01:04:48,960
They went IPO in five years.

1241
01:04:48,960 --> 01:04:50,960
It's amazing.

1242
01:04:50,960 --> 01:04:51,960
Okay.

1243
01:04:51,960 --> 01:04:53,960
So this is the day we said that was voted for the most.

1244
01:04:53,960 --> 01:04:55,960
MangerDB.

1245
01:04:55,960 --> 01:04:57,960
All right.

1246
01:04:57,960 --> 01:04:58,960
That's the best logo I could find.

1247
01:04:58,960 --> 01:04:59,960
It's the only logo I find.

1248
01:04:59,960 --> 01:05:00,960
All right.

1249
01:05:00,960 --> 01:05:02,960
So what does MangerDB?

1250
01:05:02,960 --> 01:05:05,960
So MangerDB is a satirical implementation of MongoDB.

1251
01:05:05,960 --> 01:05:06,960
It's written in Python.

1252
01:05:06,960 --> 01:05:09,960
I can't run it because it only supports an older version of Python

1253
01:05:09,960 --> 01:05:10,960
and libraries.

1254
01:05:10,960 --> 01:05:14,960
And only supports the MangerDB wire protocol up to version two.

1255
01:05:14,960 --> 01:05:21,960
So the key idea of MangerDB is that all the data is written to DevNall.

1256
01:05:21,960 --> 01:05:25,960
And so the reason why with the joke is based on is that

1257
01:05:25,960 --> 01:05:27,960
the original version of MangerDB,

1258
01:05:27,960 --> 01:05:30,960
like this thing, like 2009, 2008, 2010,

1259
01:05:30,960 --> 01:05:35,960
that they would put out these blog articles or these social media posts

1260
01:05:35,960 --> 01:05:39,960
showing how much faster MangerDB was than every other database system.

1261
01:05:40,960 --> 01:05:43,960
And part of the trick that MangerDB was doing is that

1262
01:05:43,960 --> 01:05:45,960
when you wrote to the database system,

1263
01:05:45,960 --> 01:05:48,960
you sent a right request to MangerDB,

1264
01:05:48,960 --> 01:05:51,960
they would immediately come back with an acknowledgment and say,

1265
01:05:51,960 --> 01:05:52,960
yep, we got it.

1266
01:05:52,960 --> 01:05:53,960
Right.

1267
01:05:53,960 --> 01:05:55,960
And that was the benchmark numbers they were reporting.

1268
01:05:55,960 --> 01:05:57,960
Like them versus my SQL versus Postgres.

1269
01:05:57,960 --> 01:05:58,960
Right.

1270
01:05:58,960 --> 01:06:00,960
And the obvious reason why that's a bad idea,

1271
01:06:00,960 --> 01:06:02,960
because it wasn't that, oh, you know,

1272
01:06:02,960 --> 01:06:03,960
not that you even started running the query.

1273
01:06:03,960 --> 01:06:06,960
You just got the message on the server side.

1274
01:06:07,960 --> 01:06:11,960
And there was no guarantee that that right request would actually get written to disk.

1275
01:06:11,960 --> 01:06:14,960
If you wanted to know whether your right was actually written to disk,

1276
01:06:14,960 --> 01:06:16,960
you then had to send another request and say, hey,

1277
01:06:16,960 --> 01:06:17,960
I think it is totally to write.

1278
01:06:17,960 --> 01:06:18,960
Did you actually write it?

1279
01:06:18,960 --> 01:06:20,960
And it would block and to actually did it.

1280
01:06:20,960 --> 01:06:22,960
So this obviously meant that, like,

1281
01:06:22,960 --> 01:06:25,960
if you were doing a lot of rights in your application,

1282
01:06:25,960 --> 01:06:27,960
and there was a crash, which, of course,

1283
01:06:27,960 --> 01:06:29,960
every system was going to crash at some point,

1284
01:06:29,960 --> 01:06:32,960
that there's no guarantee that things you actually thought were written

1285
01:06:33,960 --> 01:06:35,960
but then some time window were actually made at the disk.

1286
01:06:35,960 --> 01:06:38,960
There's other things they did in the early days too,

1287
01:06:38,960 --> 01:06:40,960
because they were using M-MAP instead of a Bufferple manager,

1288
01:06:40,960 --> 01:06:44,960
that they had a single database lock.

1289
01:06:44,960 --> 01:06:47,960
So even though, again, going back where you were staying before,

1290
01:06:47,960 --> 01:06:49,960
like, you know, if you can't,

1291
01:06:49,960 --> 01:06:50,960
if you don't have one writer reader,

1292
01:06:50,960 --> 01:06:52,960
is that really multi-threaded?

1293
01:06:52,960 --> 01:06:53,960
So it was basically the same idea.

1294
01:06:53,960 --> 01:06:55,960
They had a single exclusive lock on the disk.

1295
01:06:55,960 --> 01:06:56,960
And in the end, you didn't update.

1296
01:06:56,960 --> 01:06:58,960
It would lock the whole database system.

1297
01:06:58,960 --> 01:06:59,960
Right.

1298
01:06:59,960 --> 01:07:01,960
Because they couldn't handle doing multi-updits.

1299
01:07:02,960 --> 01:07:04,960
The M-MAP stuff was a whole other on a ball wax.

1300
01:07:04,960 --> 01:07:08,960
So I know I don't like to show you guys source code,

1301
01:07:08,960 --> 01:07:10,960
but we can look at source code from MangleDB,

1302
01:07:10,960 --> 01:07:11,960
because this is it.

1303
01:07:11,960 --> 01:07:15,960
This is literally the entire, this is the literally entire database system.

1304
01:07:15,960 --> 01:07:18,960
So the first thing to point out here,

1305
01:07:18,960 --> 01:07:19,960
and this line here,

1306
01:07:19,960 --> 01:07:24,960
they open up a photo script here to DevNo, fantastic.

1307
01:07:24,960 --> 01:07:25,960
Great.

1308
01:07:25,960 --> 01:07:26,960
Yes.

1309
01:07:26,960 --> 01:07:27,960
Then down in here,

1310
01:07:27,960 --> 01:07:29,960
this is actually, if a command shows up,

1311
01:07:29,960 --> 01:07:35,960
so by is telling you to disconnect,

1312
01:07:35,960 --> 01:07:37,960
wait is waiting for,

1313
01:07:37,960 --> 01:07:39,960
wait,

1314
01:07:39,960 --> 01:07:41,960
a conditional lock up there.

1315
01:07:41,960 --> 01:07:42,960
Right.

1316
01:07:42,960 --> 01:07:44,960
So this is actually command actually doing something.

1317
01:07:44,960 --> 01:07:46,960
So there's our single global lock entire database system.

1318
01:07:46,960 --> 01:07:47,960
We require that.

1319
01:07:47,960 --> 01:07:49,960
Then we write out whatever you sent over the wire

1320
01:07:49,960 --> 01:07:51,960
to the database server to DevNo,

1321
01:07:51,960 --> 01:07:52,960
fantastic, right.

1322
01:07:52,960 --> 01:07:53,960
And then they have,

1323
01:07:53,960 --> 01:07:55,960
if you're in durable mode,

1324
01:07:55,960 --> 01:07:58,960
they'll flush the output buffer.

1325
01:07:58,960 --> 01:08:01,960
And then you do an fsync on the photo scripter,

1326
01:08:01,960 --> 01:08:02,960
which is DevNo,

1327
01:08:02,960 --> 01:08:04,960
so it comes back immediately.

1328
01:08:04,960 --> 01:08:06,960
And then if you're running with

1329
01:08:06,960 --> 01:08:08,960
eventual consistency mode,

1330
01:08:08,960 --> 01:08:09,960
then no matter what you,

1331
01:08:09,960 --> 01:08:10,960
what you send us,

1332
01:08:10,960 --> 01:08:12,960
we'll send the server to get back 42.

1333
01:08:12,960 --> 01:08:13,960
Otherwise,

1334
01:08:13,960 --> 01:08:15,960
you get a random value, right.

1335
01:08:15,960 --> 01:08:17,960
And then you release the lock.

1336
01:08:17,960 --> 01:08:19,960
So this is, you know,

1337
01:08:19,960 --> 01:08:20,960
the joke is again,

1338
01:08:20,960 --> 01:08:21,960
is this good as MangleDB?

1339
01:08:21,960 --> 01:08:22,960
Well,

1340
01:08:22,960 --> 01:08:23,960
if you care about your data,

1341
01:08:23,960 --> 01:08:24,960
you would obviously wouldn't want to use this,

1342
01:08:24,960 --> 01:08:25,960
and you probably wouldn't want to use

1343
01:08:25,960 --> 01:08:27,960
early versions of MangleDB.

1344
01:08:27,960 --> 01:08:28,960
What's that?

1345
01:08:28,960 --> 01:08:29,960
It's WebScale.

1346
01:08:29,960 --> 01:08:30,960
That video we cannot show,

1347
01:08:30,960 --> 01:08:32,960
because it's a lot of profanity there.

1348
01:08:32,960 --> 01:08:34,960
We can close that later.

1349
01:08:34,960 --> 01:08:36,960
Just Google MangleDB WebScale.

1350
01:08:36,960 --> 01:08:37,960
You'll see it.

1351
01:08:37,960 --> 01:08:38,960
It's a cartoon.

1352
01:08:38,960 --> 01:08:43,960
So I'm not trying to pick on MangleDB, right.

1353
01:08:43,960 --> 01:08:49,960
The sort of,

1354
01:08:49,960 --> 01:08:50,960
how this is,

1355
01:08:50,960 --> 01:08:51,960
the playbook,

1356
01:08:51,960 --> 01:08:52,960
if you will,

1357
01:08:52,960 --> 01:08:54,960
of what MangleDB does,

1358
01:08:54,960 --> 01:08:57,960
what MangleDB did to get become successful,

1359
01:08:57,960 --> 01:08:58,960
has been done before,

1360
01:08:58,960 --> 01:08:59,960
meaning put out a,

1361
01:08:59,960 --> 01:09:00,960
quote unquote,

1362
01:09:00,960 --> 01:09:01,960
inferior product

1363
01:09:01,960 --> 01:09:02,960
that people like to use,

1364
01:09:02,960 --> 01:09:03,960
because it's easy,

1365
01:09:03,960 --> 01:09:04,960
and it's new,

1366
01:09:04,960 --> 01:09:05,960
and it's exciting,

1367
01:09:05,960 --> 01:09:07,960
get enough traction,

1368
01:09:07,960 --> 01:09:09,960
where that you get enough money

1369
01:09:09,960 --> 01:09:11,960
to then hire engineers to go

1370
01:09:11,960 --> 01:09:13,960
pay off that technical debt

1371
01:09:13,960 --> 01:09:15,960
of the mistakes you made.

1372
01:09:15,960 --> 01:09:17,960
Like, that MangleDB was,

1373
01:09:17,960 --> 01:09:18,960
and the first one did that.

1374
01:09:18,960 --> 01:09:19,960
That was,

1375
01:09:19,960 --> 01:09:20,960
but my SQL did in the 90s.

1376
01:09:20,960 --> 01:09:21,960
My SQL,

1377
01:09:21,960 --> 01:09:22,960
the original,

1378
01:09:22,960 --> 01:09:23,960
the storage engine,

1379
01:09:23,960 --> 01:09:24,960
it was called my ISAM,

1380
01:09:24,960 --> 01:09:25,960
that thing was total crap.

1381
01:09:25,960 --> 01:09:26,960
They would lose data,

1382
01:09:26,960 --> 01:09:27,960
couldn't handle transactions.

1383
01:09:27,960 --> 01:09:29,960
You would corrupt the Davis all the time.

1384
01:09:29,960 --> 01:09:30,960
And then,

1385
01:09:30,960 --> 01:09:31,960
NDB came along

1386
01:09:31,960 --> 01:09:32,960
and fixed all those things,

1387
01:09:32,960 --> 01:09:33,960
and now you would not

1388
01:09:33,960 --> 01:09:34,960
want to use my ISAM.

1389
01:09:34,960 --> 01:09:35,960
But before my SQL,

1390
01:09:35,960 --> 01:09:36,960
this is what Oracle did.

1391
01:09:36,960 --> 01:09:37,960
Oracle was a garbage system,

1392
01:09:37,960 --> 01:09:39,960
in the 70s and the 80s.

1393
01:09:39,960 --> 01:09:41,960
Ingress,

1394
01:09:41,960 --> 01:09:44,960
the predecessor to Postgres,

1395
01:09:44,960 --> 01:09:46,960
that was considered

1396
01:09:46,960 --> 01:09:48,960
the better database system,

1397
01:09:48,960 --> 01:09:50,960
but Oracle got better traction,

1398
01:09:50,960 --> 01:09:52,960
because they made a bunch of claims,

1399
01:09:52,960 --> 01:09:53,960
about what it could do,

1400
01:09:53,960 --> 01:09:54,960
that in the future,

1401
01:09:54,960 --> 01:09:55,960
that eventually they got there,

1402
01:09:55,960 --> 01:09:56,960
and they got big enough,

1403
01:09:56,960 --> 01:09:57,960
where they could hire enough people to fix it.

1404
01:09:57,960 --> 01:09:59,960
And now, Oracle is a solid database system.

1405
01:09:59,960 --> 01:10:01,960
So again, I'm not trying to pick on Mangle.

1406
01:10:01,960 --> 01:10:02,960
This is,

1407
01:10:02,960 --> 01:10:04,960
you can think of like,

1408
01:10:04,960 --> 01:10:06,960
it's a marketing way to say,

1409
01:10:06,960 --> 01:10:07,960
you sort of sell the,

1410
01:10:07,960 --> 01:10:08,960
you know, sell the stake,

1411
01:10:08,960 --> 01:10:09,960
you sell the sizzle.

1412
01:10:09,960 --> 01:10:10,960
So you sell your data system,

1413
01:10:10,960 --> 01:10:11,960
it's going to solve all the world's problems,

1414
01:10:11,960 --> 01:10:12,960
it's state of the art,

1415
01:10:12,960 --> 01:10:13,960
yeah, yeah, yeah, yeah, yeah, yeah, yeah.

1416
01:10:13,960 --> 01:10:14,960
And then,

1417
01:10:14,960 --> 01:10:15,960
yeah, people get burned along the way,

1418
01:10:15,960 --> 01:10:16,960
but whatever, right?

1419
01:10:16,960 --> 01:10:18,960
And then you get the money to fix things.

1420
01:10:18,960 --> 01:10:19,960
Yes.

1421
01:10:19,960 --> 01:10:21,960
So maybe it's anyone's mission credit,

1422
01:10:21,960 --> 01:10:24,960
but I'm very, very, very,

1423
01:10:24,960 --> 01:10:26,960
that is the ability to make these confirmations.

1424
01:10:26,960 --> 01:10:27,960
Mangle DB?

1425
01:10:27,960 --> 01:10:28,960
OK, sorry.

1426
01:10:28,960 --> 01:10:29,960
You pointed,

1427
01:10:29,960 --> 01:10:31,960
it's always like, wait a minute.

1428
01:10:31,960 --> 01:10:32,960
You pointed,

1429
01:10:32,960 --> 01:10:33,960
it's always like, wait a minute.

1430
01:10:33,960 --> 01:10:34,960
I mean,

1431
01:10:34,960 --> 01:10:35,960
the question is,

1432
01:10:35,960 --> 01:10:36,960
is it OK to use like,

1433
01:10:36,960 --> 01:10:38,960
bleeding edge database software,

1434
01:10:38,960 --> 01:10:39,960
if it's,

1435
01:10:39,960 --> 01:10:40,960
for mission credit applications,

1436
01:10:40,960 --> 01:10:41,960
if it's,

1437
01:10:41,960 --> 01:10:42,960
it's not going to be,

1438
01:10:42,960 --> 01:10:43,960
it's not going to be,

1439
01:10:43,960 --> 01:10:44,960
it's not going to be,

1440
01:10:44,960 --> 01:10:45,960
it's not going to be,

1441
01:10:45,960 --> 01:10:46,960
it's not going to be,

1442
01:10:46,960 --> 01:10:47,960
it's not going to be,

1443
01:10:47,960 --> 01:10:48,960
it's not going to be,

1444
01:10:48,960 --> 01:10:50,960
it's not going to be,

1445
01:10:50,960 --> 01:10:51,960
it's going to be,

1446
01:10:51,960 --> 01:10:52,960
it's going to be,

1447
01:10:52,960 --> 01:10:53,960
it's not going to be,

1448
01:10:53,960 --> 01:10:54,960
it's not going to be.

1449
01:10:54,960 --> 01:10:55,960
Y have gone quite a few years,

1450
01:10:55,960 --> 01:10:56,960
it's not going to be,

1451
01:10:56,960 --> 01:10:58,960
sort of electing on your job

1452
01:10:58,960 --> 01:10:59,960
and ever undergoing care sometimes.

1453
01:10:59,960 --> 01:11:00,960
Because,

1454
01:11:00,960 --> 01:11:03,960
your job is to make progress

1455
01:11:03,960 --> 01:11:04,960
ambitious.

1456
01:11:04,960 --> 01:11:06,960
They're going to be airport

1457
01:11:06,960 --> 01:11:07,960
jobs,

1458
01:11:07,960 --> 01:11:10,960
they're going to be overwhelmed

1459
01:11:10,960 --> 01:11:13,199
and are going to teach you

1460
01:11:13,199 --> 01:11:13,960
what to do.

1461
01:11:13,960 --> 01:11:15,960
But the thing that I'm reminding

1462
01:11:15,960 --> 01:11:16,960
us from now,

1463
01:11:16,960 --> 01:11:18,960
other newer systems that can do it.

1464
01:11:18,960 --> 01:11:19,960
Right?

1465
01:11:19,960 --> 01:11:21,960
But yeah, if it's mission critical,

1466
01:11:21,960 --> 01:11:24,600
I would say also too,

1467
01:11:24,600 --> 01:11:25,760
like all the things that

1468
01:11:25,760 --> 01:11:27,359
the NoSQL guys say were a bad idea,

1469
01:11:27,359 --> 01:11:29,039
SQL obviously in the name,

1470
01:11:29,039 --> 01:11:30,399
they do like transactions,

1471
01:11:30,399 --> 01:11:31,880
they didn't like joins,

1472
01:11:31,880 --> 01:11:33,840
all of them have added those things.

1473
01:11:33,840 --> 01:11:35,920
So the intellectual distance between

1474
01:11:35,920 --> 01:11:38,279
a NoSQL system and a relational data system,

1475
01:11:38,279 --> 01:11:42,760
at some point, there is going to be no difference.

1476
01:11:42,760 --> 01:11:44,600
So all the things they say were a bad idea,

1477
01:11:44,600 --> 01:11:46,200
and for me,

1478
01:11:46,200 --> 01:11:49,160
is like SQL maximalists are a pierist,

1479
01:11:49,160 --> 01:11:51,240
that I'm saying, oh, you don't want to be,

1480
01:11:51,240 --> 01:11:52,079
you don't want to do,

1481
01:11:52,079 --> 01:11:53,079
you don't want to not do transactions,

1482
01:11:53,079 --> 01:11:54,600
you don't want to not do SQL,

1483
01:11:54,600 --> 01:11:55,920
turns out they eventually came around

1484
01:11:55,920 --> 01:11:59,120
and added support for it.

1485
01:11:59,120 --> 01:12:01,760
So the only NoSQL system that doesn't support SQL now

1486
01:12:01,760 --> 01:12:03,000
is actually redis.

1487
01:12:03,000 --> 01:12:04,680
There's a clone for that,

1488
01:12:04,680 --> 01:12:07,600
but again, it's primarily being used for a cache.

1489
01:12:07,600 --> 01:12:09,920
I know the MongoDB co-founder,

1490
01:12:09,920 --> 01:12:11,600
he's not there anymore, the CTO,

1491
01:12:11,600 --> 01:12:14,240
he helped out in an earlier

1492
01:12:14,239 --> 01:12:17,199
is when I was at CMU with research funding,

1493
01:12:17,199 --> 01:12:18,519
and I remember him telling me,

1494
01:12:18,519 --> 01:12:19,319
during the study office,

1495
01:12:19,319 --> 01:12:21,079
I was like, oh, MongoDB would never support SQL,

1496
01:12:21,079 --> 01:12:22,079
never going to happen.

1497
01:12:22,079 --> 01:12:23,639
The ad of it two years ago,

1498
01:12:23,639 --> 01:12:26,319
it's after he left, but still.

1499
01:12:26,319 --> 01:12:30,199
So don't want your data devnal,

1500
01:12:31,399 --> 01:12:33,840
and I think, again, for mission critical data,

1501
01:12:33,840 --> 01:12:36,639
I don't think shiny new things are a good idea.

1502
01:12:36,640 --> 01:12:38,480
I meant it's the hardware and support.

1503
01:12:38,480 --> 01:12:39,760
So it's the Intel CPU,

1504
01:12:39,760 --> 01:12:41,480
it's the support that managed to recover,

1505
01:12:41,480 --> 01:12:44,240
so the hardware has been recovered

1506
01:12:44,240 --> 01:12:47,400
even the L12LC data on the radio.

1507
01:12:47,400 --> 01:12:49,680
Yeah, so Intel has this ADR stuff.

1508
01:12:49,680 --> 01:12:50,640
I think it's also rad as well,

1509
01:12:50,640 --> 01:12:52,640
like writing to the district, yeah.

1510
01:12:54,400 --> 01:12:56,720
If the hardware does it, is that coming off?

1511
01:12:56,720 --> 01:12:57,720
Well, I mean,

1512
01:12:59,680 --> 01:13:00,880
well, no, because again,

1513
01:13:00,880 --> 01:13:02,119
there's the whole smash we were talking about.

1514
01:13:02,119 --> 01:13:04,119
Like, things got written to the desk,

1515
01:13:04,599 --> 01:13:08,159
I don't, can you bring back the program state exactly?

1516
01:13:08,159 --> 01:13:09,000
The program account?

1517
01:13:09,000 --> 01:13:09,840
I don't think it can.

1518
01:13:11,000 --> 01:13:11,840
Right?

1519
01:13:11,840 --> 01:13:13,079
So the problem there is like,

1520
01:13:13,079 --> 01:13:15,279
if there's a bug in your software,

1521
01:13:15,279 --> 01:13:17,159
and like it starts going down some copat

1522
01:13:17,159 --> 01:13:18,000
that shouldn't have,

1523
01:13:18,000 --> 01:13:20,599
and it starts writing data to your disk,

1524
01:13:20,599 --> 01:13:22,159
the hardware thinks that's fine,

1525
01:13:22,159 --> 01:13:23,800
software's broken though.

1526
01:13:23,800 --> 01:13:25,519
You gotta recover from that.

1527
01:13:25,519 --> 01:13:27,000
And so if you can't guarantee strong

1528
01:13:27,000 --> 01:13:27,880
consistent transactions,

1529
01:13:27,880 --> 01:13:29,880
like, I mean, across the two nodes,

1530
01:13:29,880 --> 01:13:31,239
then that's gonna be a problem.

1531
01:13:32,199 --> 01:13:35,239
So, you know, as much as I seem like a,

1532
01:13:36,880 --> 01:13:38,639
as a person that kind of has loose morals,

1533
01:13:38,639 --> 01:13:39,639
Nethylbright word,

1534
01:13:41,039 --> 01:13:42,079
when it comes to databases,

1535
01:13:42,079 --> 01:13:44,000
like, I'm super cautious, right?

1536
01:13:44,000 --> 01:13:44,840
Because you don't,

1537
01:13:46,760 --> 01:13:47,840
it's like the operating system.

1538
01:13:47,840 --> 01:13:48,679
It's like,

1539
01:13:48,679 --> 01:13:52,559
it's the core foundation of a software system,

1540
01:13:52,559 --> 01:13:55,159
and that kind of thing you don't wanna mess around with.

1541
01:13:56,159 --> 01:13:57,519
You wanna use JavaScript?

1542
01:13:57,519 --> 01:13:58,479
The application, that's fine.

1543
01:13:58,479 --> 01:13:59,920
Put it all over there.

1544
01:13:59,920 --> 01:14:02,159
Data system should be written in something more serious.

1545
01:14:03,239 --> 01:14:04,920
That's gonna be emails, okay.

1546
01:14:04,920 --> 01:14:07,680
I'm gonna show one more fun system.

1547
01:14:07,680 --> 01:14:09,720
This to me, this is the,

1548
01:14:09,720 --> 01:14:10,560
I'm jealous,

1549
01:14:10,560 --> 01:14:11,399
because this is actually,

1550
01:14:11,399 --> 01:14:12,480
I wish I invented this system.

1551
01:14:12,480 --> 01:14:13,920
This is pure genius.

1552
01:14:15,239 --> 01:14:16,359
It's called TabDB.

1553
01:14:17,600 --> 01:14:19,600
So it's a relational database system

1554
01:14:19,600 --> 01:14:23,000
where they store the contents of your database

1555
01:14:23,000 --> 01:14:27,440
in the titles of your tabs in your web browser.

1556
01:14:27,440 --> 01:14:28,880
So the way the guy did this was,

1557
01:14:28,880 --> 01:14:30,880
he took SQLite C code,

1558
01:14:30,880 --> 01:14:32,239
ran it through M-Scriptin,

1559
01:14:32,239 --> 01:14:35,279
which allows you to convert C code into JavaScript.

1560
01:14:35,279 --> 01:14:37,600
So now SQLite is running in JavaScript

1561
01:14:37,600 --> 01:14:39,920
in your web browser, in your web page,

1562
01:14:39,920 --> 01:14:41,319
and then when it wants to do right,

1563
01:14:41,319 --> 01:14:43,720
it splits up your database file,

1564
01:14:43,720 --> 01:14:47,480
it then writes it into tabs in your web browser.

1565
01:14:48,480 --> 01:14:50,159
And you can run SQL, it's amazing.

1566
01:14:51,199 --> 01:14:51,960
So,

1567
01:14:54,960 --> 01:14:55,960
ah, sorry.

1568
01:14:59,319 --> 01:15:00,159
Mm.

1569
01:15:10,560 --> 01:15:11,640
All right, so we gotta make,

1570
01:15:12,840 --> 01:15:15,760
it makes some tabs, right?

1571
01:15:15,760 --> 01:15:18,440
So we'll call CrateStabit, right?

1572
01:15:18,440 --> 01:15:20,760
Then now you see the tabs have been renamed,

1573
01:15:20,760 --> 01:15:22,600
and then I can run a select statement,

1574
01:15:23,680 --> 01:15:24,440
and I get results back.

1575
01:15:24,440 --> 01:15:26,880
I don't know where the results end up,

1576
01:15:26,880 --> 01:15:28,560
but it ran, right?

1577
01:15:28,560 --> 01:15:31,800
So if I add more tabs, I get more data.

1578
01:15:31,800 --> 01:15:32,960
Oh, I know how to do much to insert.

1579
01:15:32,960 --> 01:15:34,920
That's why I got to do inserts, inserts.

1580
01:15:38,920 --> 01:15:39,760
Yep.

1581
01:15:41,320 --> 01:15:42,440
I can better resolve that.

1582
01:15:42,440 --> 01:15:46,400
And that's stored entirely in the tabs titles.

1583
01:15:46,400 --> 01:15:48,640
Genius, I am very, very jealous of this.

1584
01:15:50,520 --> 01:15:53,240
I, I don't know what my joke database is,

1585
01:15:53,240 --> 01:15:56,160
I gotta think of one, but this is very hard to beat this.

1586
01:15:56,160 --> 01:15:57,000
Yes.

1587
01:15:58,000 --> 01:16:01,119
If you click on a tab, I think you just get,

1588
01:16:02,079 --> 01:16:06,600
yeah, but if you delete a tab, right?

1589
01:16:10,119 --> 01:16:10,960
Oh, so got it.

1590
01:16:16,960 --> 01:16:17,800
Delete the first one.

1591
01:16:23,359 --> 01:16:24,960
Oh, you know what it is?

1592
01:16:24,960 --> 01:16:28,119
It's like the data is so small, actually, I don't.

1593
01:16:31,000 --> 01:16:32,439
It's still in memory.

1594
01:16:32,439 --> 01:16:33,480
Yeah.

1595
01:16:33,480 --> 01:16:36,279
Anyway, all right, that's a fun one, tab DB.

1596
01:16:36,279 --> 01:16:38,039
We tried to get the guy to come give a talk with us,

1597
01:16:38,039 --> 01:16:39,960
and then I was gonna like try to promote it

1598
01:16:39,960 --> 01:16:42,840
as like a distinguished lecturer in the department

1599
01:16:42,840 --> 01:16:45,159
to say that there's the groundbreaking idea

1600
01:16:45,159 --> 01:16:46,880
we can just do this.

1601
01:16:46,880 --> 01:16:49,359
All right, so quickly, quickly, quickly.

1602
01:16:49,359 --> 01:16:50,640
So, collider marks.

1603
01:16:51,600 --> 01:16:53,000
Where did the name bus stop come from?

1604
01:16:53,000 --> 01:16:56,560
So, I have this, I really blog on it

1605
01:16:56,560 --> 01:16:58,079
when the best name of the database system is,

1606
01:16:58,079 --> 01:17:00,479
you pick two random ones syllable words,

1607
01:17:00,479 --> 01:17:02,239
you stick them together, and that makes your,

1608
01:17:02,239 --> 01:17:04,319
makes your database name to be guaranteed unique

1609
01:17:04,319 --> 01:17:05,960
for like, you know, search engines and stuff.

1610
01:17:05,960 --> 01:17:10,000
Like post-cress, post-cress, click house, grid gain.

1611
01:17:10,000 --> 01:17:11,560
Like you search those words and it's guaranteed

1612
01:17:11,560 --> 01:17:13,039
to be your data system.

1613
01:17:13,039 --> 01:17:15,960
So one of my PhD students, he wrote a script

1614
01:17:15,960 --> 01:17:18,640
where every morning on Slack would take two random words

1615
01:17:18,640 --> 01:17:20,600
and put them together and post that on Slack.

1616
01:17:20,600 --> 01:17:22,800
We were trying to figure out which one you would wanna use.

1617
01:17:22,800 --> 01:17:24,119
So they were screwing me the first time

1618
01:17:24,119 --> 01:17:26,079
because the first thing to spit out was poop dish.

1619
01:17:26,079 --> 01:17:29,320
But then the very next day, the real one

1620
01:17:29,320 --> 01:17:31,320
actually pointed to spit out was bus tub.

1621
01:17:31,320 --> 01:17:32,720
We just thought it was hilarious, we did that.

1622
01:17:32,720 --> 01:17:34,239
So we hired someone to draw logo.

1623
01:17:34,239 --> 01:17:36,039
So that's where it came from.

1624
01:17:36,039 --> 01:17:37,680
Why is relational model superior?

1625
01:17:37,680 --> 01:17:39,279
I think I've already said this a couple of times,

1626
01:17:39,279 --> 01:17:42,640
even today, but like, the relational model is,

1627
01:17:42,640 --> 01:17:45,119
it's like the foundation for databases.

1628
01:17:45,119 --> 01:17:47,800
Like, you know, no one's gonna invent a new arithmetic,

1629
01:17:47,800 --> 01:17:48,680
like one plus one equals two.

1630
01:17:48,680 --> 01:17:49,960
No one's gonna reinvent that.

1631
01:17:49,960 --> 01:17:51,720
The relational model can be used to model

1632
01:17:51,720 --> 01:17:55,560
any possible type of application or data set,

1633
01:17:55,560 --> 01:18:00,560
whether it's arrays, lists or, you know, JSON stuff.

1634
01:18:01,039 --> 01:18:02,400
And although that goes against

1635
01:18:02,400 --> 01:18:05,360
with the original idea of what Ted Cod had in the 1970s,

1636
01:18:05,360 --> 01:18:06,360
but what relational model was,

1637
01:18:06,360 --> 01:18:08,680
because he had no lists, he had no documents.

1638
01:18:08,680 --> 01:18:10,440
But over time, the relational model has expanded

1639
01:18:10,440 --> 01:18:12,560
to adapt to changes in how people program,

1640
01:18:13,600 --> 01:18:15,640
where today, it can support everything.

1641
01:18:16,640 --> 01:18:17,680
The next question he had was,

1642
01:18:17,680 --> 01:18:18,920
why did all the tech companies,

1643
01:18:18,920 --> 01:18:21,680
why did tech companies support a lot of multidated systems?

1644
01:18:21,720 --> 01:18:23,600
This is money, right?

1645
01:18:25,720 --> 01:18:26,680
Plain and simple.

1646
01:18:28,800 --> 01:18:29,640
Yeah, so.

1647
01:18:30,840 --> 01:18:34,000
All right, so again, hopefully,

1648
01:18:35,800 --> 01:18:37,240
through the last day of class,

1649
01:18:37,240 --> 01:18:38,119
through that, you've been here with us

1650
01:18:38,119 --> 01:18:39,960
for both the entire semester,

1651
01:18:39,960 --> 01:18:41,600
you now realize that databases are awesome.

1652
01:18:41,600 --> 01:18:42,720
They're super important.

1653
01:18:42,720 --> 01:18:44,280
There's still a lot of activity in this space.

1654
01:18:44,280 --> 01:18:45,400
There's still a lot of money.

1655
01:18:45,400 --> 01:18:47,880
We barely touched what all the different things

1656
01:18:47,880 --> 01:18:48,720
you could actually do.

1657
01:18:48,720 --> 01:18:50,600
I brought up M-Merry Davises today.

1658
01:18:50,600 --> 01:18:51,600
That's the first time we really talked about that.

1659
01:18:51,600 --> 01:18:53,320
That's a whole another category of databases

1660
01:18:54,320 --> 01:18:55,520
that are super fascinating.

1661
01:18:55,520 --> 01:18:57,880
And there's embedded devices and large scale systems.

1662
01:18:57,880 --> 01:18:59,079
So a bunch of these things,

1663
01:18:59,079 --> 01:19:01,680
like there's, the core ideas we talked about,

1664
01:19:01,680 --> 01:19:03,480
even though we described it mostly

1665
01:19:03,480 --> 01:19:05,079
in a single-node context,

1666
01:19:05,079 --> 01:19:07,079
and again, it's applicable everywhere.

1667
01:19:07,079 --> 01:19:08,600
So again, hopefully going forward

1668
01:19:08,600 --> 01:19:09,880
to rest of your career,

1669
01:19:09,880 --> 01:19:11,440
no matter whether you're actually building

1670
01:19:11,440 --> 01:19:12,720
internals of a data system or not,

1671
01:19:12,720 --> 01:19:14,000
you'll understand what's actually going on

1672
01:19:14,000 --> 01:19:15,039
when you run a query.

1673
01:19:15,039 --> 01:19:17,240
And so when there'll be performance problems,

1674
01:19:17,240 --> 01:19:20,079
at least now you can understand what's going on

1675
01:19:20,479 --> 01:19:21,399
and decide is it something

1676
01:19:21,399 --> 01:19:23,039
because we're using the data system wrong

1677
01:19:23,039 --> 01:19:25,159
or it's because the data system

1678
01:19:25,159 --> 01:19:28,920
is just not implemented correctly or good enough.

1679
01:19:28,920 --> 01:19:30,720
And this is going to allow you to make better decisions

1680
01:19:30,720 --> 01:19:33,600
throughout your life about what kind of system you should use.

1681
01:19:33,600 --> 01:19:35,000
Goes back to the thing you was asking me before.

1682
01:19:35,000 --> 01:19:37,519
Why would anybody want to use one of these brand new databases

1683
01:19:37,519 --> 01:19:39,000
or like should you use them

1684
01:19:39,000 --> 01:19:41,680
if it's a mission critical application?

1685
01:19:41,680 --> 01:19:43,159
So now you can go look at the documentation,

1686
01:19:43,159 --> 01:19:44,600
understand what claims a data system

1687
01:19:44,600 --> 01:19:46,840
is actually making to understand

1688
01:19:46,840 --> 01:19:49,079
what are the things that could be a problem later on.

1689
01:19:49,079 --> 01:19:50,439
Because the first five minutes, sure, yeah,

1690
01:19:50,439 --> 01:19:53,640
the query might run fast as a MongoDB did,

1691
01:19:53,640 --> 01:19:57,319
but like as things scale or as you do more complex operations

1692
01:19:57,319 --> 01:19:59,439
on it, you could have a bunch of problems.

1693
01:20:00,439 --> 01:20:01,279
Okay?

1694
01:20:02,159 --> 01:20:03,640
All right, so before we go,

1695
01:20:05,960 --> 01:20:09,760
before we go, we just got noticed from the pre-bust

1696
01:20:11,159 --> 01:20:14,239
from the university that the voting is in

1697
01:20:14,239 --> 01:20:19,239
and DJ 2PO has been voted the most dank course DJ

1698
01:20:19,960 --> 01:20:21,159
at all of Carnegie Mellon.

1699
01:20:21,159 --> 01:20:24,479
So, yeah, it's like right here.

1700
01:20:24,479 --> 01:20:26,039
Oh, there you go.

1701
01:20:26,039 --> 01:20:26,880
There you go.

1702
01:20:26,880 --> 01:20:29,760
Look, you grab this, it's yours.

1703
01:20:29,760 --> 01:20:30,599
You're like this.

1704
01:20:31,599 --> 01:20:32,439
Got it?

1705
01:20:32,439 --> 01:20:33,439
Okay, congratulations.

1706
01:20:33,439 --> 01:20:38,519
All right, and again, for those who came late,

1707
01:20:38,519 --> 01:20:41,239
DJ 2PO's agent sent over photos.

1708
01:20:41,239 --> 01:20:44,800
So he's signing autographs right after class, okay?

1709
01:20:44,800 --> 01:20:46,800
All right, go look, rest your classes.

1710
01:20:46,800 --> 01:20:48,239
Take care, hit it.

1711
01:20:48,239 --> 01:20:49,239
I'm gonna go.

1712
01:20:49,239 --> 01:20:50,239
I'm gonna go.

1713
01:20:50,239 --> 01:20:51,239
I'm gonna go.

1714
01:20:51,239 --> 01:20:52,239
I'm gonna go.

1715
01:20:52,239 --> 01:20:53,239
I'm gonna go.

1716
01:20:53,239 --> 01:20:54,239
I'm gonna go.

1717
01:20:54,239 --> 01:20:55,239
I'm gonna go.

1718
01:20:55,239 --> 01:20:56,239
I'm gonna go.

1719
01:20:56,239 --> 01:20:57,239
I'm gonna go.

1720
01:20:57,239 --> 01:20:58,239
I'm gonna go.

1721
01:20:58,239 --> 01:20:59,239
I'm gonna go.

1722
01:20:59,239 --> 01:21:00,239
I'm gonna go.

1723
01:21:00,239 --> 01:21:01,239
I'm gonna go.

1724
01:21:01,239 --> 01:21:02,239
I'm gonna go.

1725
01:21:02,239 --> 01:21:03,239
I'm gonna go.

1726
01:21:03,239 --> 01:21:04,239
I'm gonna go.

1727
01:21:04,239 --> 01:21:05,239
I'm gonna go.

1728
01:21:05,239 --> 01:21:06,239
I'm gonna go.

1729
01:21:06,239 --> 01:21:07,239
I'm gonna go.

1730
01:21:07,239 --> 01:21:08,239
I'm gonna go.

1731
01:21:08,239 --> 01:21:09,239
I'm gonna go.

1732
01:21:09,239 --> 01:21:10,239
I'm gonna go.

1733
01:21:10,239 --> 01:21:11,239
I'm gonna go.

1734
01:21:11,239 --> 01:21:12,239
I'm gonna go.

1735
01:21:12,239 --> 01:21:13,239
I'm gonna go.

1736
01:21:13,239 --> 01:21:14,239
I'm gonna go.

1737
01:21:14,239 --> 01:21:15,239
I'm gonna go.

1738
01:21:15,239 --> 01:21:16,239
I'm gonna go.

1739
01:21:16,239 --> 01:21:17,239
I'm gonna go.

1740
01:21:17,239 --> 01:21:18,239
I'm gonna go.

1741
01:21:18,239 --> 01:21:19,239
I'm gonna go.

1742
01:21:19,239 --> 01:21:20,239
I'm gonna go.

1743
01:21:20,239 --> 01:21:21,239
I'm gonna go.

1744
01:21:21,239 --> 01:21:22,239
I'm gonna go.

1745
01:21:22,239 --> 01:21:23,239
I'm gonna go.

1746
01:21:23,239 --> 01:21:24,239
I'm gonna go.

1747
01:21:24,239 --> 01:21:25,239
I'm gonna go.

1748
01:21:25,239 --> 01:21:26,239
I'm gonna go.

1749
01:21:26,239 --> 01:21:27,239
I'm gonna go.

1750
01:21:27,239 --> 01:21:28,239
I'm gonna go.

1751
01:21:28,239 --> 01:21:29,239
I'm gonna go.

1752
01:21:29,239 --> 01:21:30,239
I'm gonna go.

1753
01:21:30,239 --> 01:21:31,239
I'm gonna go.

1754
01:21:31,239 --> 01:21:32,239
I'm gonna go.

1755
01:21:32,239 --> 01:21:33,239
I'm gonna go.

1756
01:21:33,239 --> 01:21:34,239
I'm gonna go.

1757
01:21:34,239 --> 01:21:35,239
I'm gonna go.

1758
01:21:35,239 --> 01:21:36,239
I'm gonna go.

1759
01:21:36,239 --> 01:21:37,239
I'm gonna go.

1760
01:21:37,239 --> 01:21:38,239
I'm gonna go.

1761
01:21:38,239 --> 01:21:39,239
I'm gonna go.

1762
01:21:39,239 --> 01:21:40,239
I'm gonna go.

1763
01:21:40,239 --> 01:21:41,239
I'm gonna go.

1764
01:21:41,239 --> 01:21:42,239
I'm gonna go.

1765
01:21:42,239 --> 01:21:43,239
I'm gonna go.

1766
01:21:43,239 --> 01:21:44,239
I'm gonna go.

1767
01:21:44,239 --> 01:21:45,239
I'm gonna go.

1768
01:21:45,239 --> 01:21:46,239
I'm gonna go.

1769
01:21:46,239 --> 01:21:47,239
I'm gonna go.

1770
01:21:47,239 --> 01:21:48,239
I'm gonna go.

1771
01:21:48,239 --> 01:21:49,239
I'm gonna go.

1772
01:21:49,239 --> 01:21:50,239
I'm gonna go.

1773
01:21:50,239 --> 01:21:51,239
I'm gonna go.

1774
01:21:51,239 --> 01:21:52,239
I'm gonna go.

1775
01:21:52,239 --> 01:21:53,239
I'm gonna go.

1776
01:21:53,239 --> 01:21:54,239
I'm gonna go.

1777
01:21:54,239 --> 01:21:55,239
I'm gonna go.

1778
01:21:55,239 --> 01:21:56,239
I'm gonna go.

1779
01:21:56,239 --> 01:21:57,239
I'm gonna go.

1780
01:21:57,239 --> 01:21:58,239
I'm gonna go.

1781
01:21:58,239 --> 01:21:59,239
I'm gonna go.

1782
01:21:59,239 --> 01:22:00,239
I'm gonna go.

1783
01:22:00,239 --> 01:22:01,239
I'm gonna go.

1784
01:22:01,239 --> 01:22:02,239
I'm gonna go.

1785
01:22:02,239 --> 01:22:03,239
I'm gonna go.

1786
01:22:03,239 --> 01:22:04,239
I'm gonna go.

1787
01:22:04,239 --> 01:22:05,239
I'm gonna go.

1788
01:22:05,239 --> 01:22:06,239
I'm gonna go.

1789
01:22:06,239 --> 01:22:07,239
I'm gonna go.

1790
01:22:07,239 --> 01:22:08,239
I'm gonna go.

1791
01:22:08,239 --> 01:22:09,239
I'm gonna go.

1792
01:22:09,239 --> 01:22:10,239
I'm gonna go.

1793
01:22:10,239 --> 01:22:11,239
I'm gonna go.

1794
01:22:11,239 --> 01:22:12,239
I'm gonna go.

1795
01:22:12,239 --> 01:22:13,239
I'm gonna go.

1796
01:22:13,239 --> 01:22:14,239
I'm gonna go.

1797
01:22:14,239 --> 01:22:15,239
I'm gonna go.

