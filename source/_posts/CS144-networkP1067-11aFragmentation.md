---
title: CS144 NetworkP1067 11aFragmentation
---

1
00:00:00,000 --> 00:00:05,400
So in this video, we talk about fragmentation and assembly.

2
00:00:05,400 --> 00:00:07,240
So here's the basic problem in fragmentation assembly

3
00:00:07,240 --> 00:00:08,320
to try to solve.

4
00:00:08,320 --> 00:00:11,160
Let's say that myth, I'm using some, she

5
00:00:11,160 --> 00:00:13,040
and Stanford, and the myth cluster,

6
00:00:13,040 --> 00:00:15,240
and I want to request a web page from Google.

7
00:00:15,240 --> 00:00:17,559
And Google's web page that it sends this to be

8
00:00:17,559 --> 00:00:21,160
response is 10 kilobytes long.

9
00:00:21,160 --> 00:00:24,080
Well, 10 kilobytes chunk of data is pretty big.

10
00:00:24,080 --> 00:00:27,800
And the problem is there might be some hop along the path

11
00:00:27,800 --> 00:00:32,039
from Google to myth that can't support a 10 kilobytes packet.

12
00:00:32,039 --> 00:00:34,840
In fact, Ethernet, the maximum transfer unit, many speeds

13
00:00:34,840 --> 00:00:37,399
of Ethernet support, is 1,500 bytes.

14
00:00:37,399 --> 00:00:41,120
And so what I need to do is take this 10 kilobytes packet

15
00:00:41,120 --> 00:00:43,240
and break it into a series of chunks,

16
00:00:43,240 --> 00:00:48,159
smaller pieces, called fragments, which the network can support.

17
00:00:48,159 --> 00:00:49,799
So imagine like the extreme case, if Google,

18
00:00:49,799 --> 00:00:51,920
if I'm downloading something really big,

19
00:00:51,920 --> 00:00:54,920
I don't want to be sending one gigabyte packets.

20
00:00:54,920 --> 00:00:57,640
They're going to occupy the channel for a huge amounts of time.

21
00:00:57,640 --> 00:01:00,039
So I want to break things into smaller chunks.

22
00:01:00,039 --> 00:01:02,480
So in this case, if I had, say, Ethernet frame size

23
00:01:02,480 --> 00:01:06,319
of 1.5 kilobytes, I'll just split this 10 kilobytes

24
00:01:06,319 --> 00:01:10,719
into seven fragments.

25
00:01:10,719 --> 00:01:13,480
Where these first six could be 1.5 each,

26
00:01:13,480 --> 00:01:18,560
and the last one, say, is 1 kilobyte.

27
00:01:18,560 --> 00:01:20,920
So that's the process of fragmentation.

28
00:01:20,920 --> 00:01:23,000
Then these fragments arrive at myth,

29
00:01:23,000 --> 00:01:25,079
and its job is to assemble, and it's assembly.

30
00:01:25,079 --> 00:01:31,679
So to take these seven fragments, two, three, four, five, six, seven,

31
00:01:31,679 --> 00:01:35,039
and reassemble them to the original 10 kilobytes of data.

32
00:01:35,039 --> 00:01:38,359
And so generally speaking, fragmentation and assembly

33
00:01:38,359 --> 00:01:41,479
occur when a higher layers data unit

34
00:01:41,479 --> 00:01:45,159
is larger than what a lower layer can support.

35
00:01:45,159 --> 00:01:46,920
It's a fragmentation, the process of taking

36
00:01:46,920 --> 00:01:48,759
a large chunk of data and breaking it

37
00:01:48,759 --> 00:01:51,920
into smaller pieces that the lower layer can support.

38
00:01:51,920 --> 00:01:54,840
And assembly is in the process of taking these fragments

39
00:01:54,840 --> 00:01:57,960
and reassembling them into the original data.

40
00:01:57,960 --> 00:02:00,600
This occurs in many different places in networks

41
00:02:00,600 --> 00:02:02,079
at different layers.

42
00:02:02,079 --> 00:02:04,719
For example, it can occur at the transport layer.

43
00:02:04,719 --> 00:02:06,000
So TCP does this.

44
00:02:06,000 --> 00:02:11,759
When it takes a stream of data, it breaks it into segments,

45
00:02:11,759 --> 00:02:16,480
which are then transmitted, and reassembled

46
00:02:16,480 --> 00:02:19,920
at the other side into a reliable stream.

47
00:02:19,920 --> 00:02:22,360
And this assembly is now occurring end-to-end

48
00:02:22,360 --> 00:02:24,719
between the TCP endpoints.

49
00:02:24,719 --> 00:02:28,879
Such that given TCP segment, once it's generated by an endpoint,

50
00:02:28,879 --> 00:02:32,240
is then indivisible and arrives at the other end.

51
00:02:32,240 --> 00:02:36,879
You never see a segment broken into two separate segments.

52
00:02:36,879 --> 00:02:38,919
Although underneath it might be broken into packets

53
00:02:38,919 --> 00:02:41,360
or frames as they'll show.

54
00:02:41,360 --> 00:02:45,280
Contrast the network layer, it's operating on a host-to-host basis.

55
00:02:45,280 --> 00:02:47,759
This is unlike TCP, where once a segment is sent,

56
00:02:47,759 --> 00:02:51,039
that is the segment the endpoint will receive if it arrives.

57
00:02:51,039 --> 00:02:53,039
With IP, at the network layer, it's

58
00:02:53,039 --> 00:02:56,039
possible that some intermediate node takes the packet

59
00:02:56,039 --> 00:02:56,679
and breaks it up.

60
00:02:56,679 --> 00:02:59,680
So an RP packet traversing the network

61
00:02:59,680 --> 00:03:03,479
at some intermediate point might be broken into multiple IP

62
00:03:03,479 --> 00:03:05,359
fragments, which then the endpoint has

63
00:03:05,359 --> 00:03:09,759
to reassemble into the original IP packet.

64
00:03:09,759 --> 00:03:11,319
And so this is at the network layer.

65
00:03:11,319 --> 00:03:14,319
And so it can occur within the network.

66
00:03:14,319 --> 00:03:16,879
Finally, it can also occur at the link layer.

67
00:03:16,879 --> 00:03:21,479
So one example is there's a link layer called Zigbee,

68
00:03:21,479 --> 00:03:25,239
or if 802.15.4, that has a very small frame size

69
00:03:25,239 --> 00:03:29,079
of approximately 120 bytes, 127, but that doesn't yet

70
00:03:29,079 --> 00:03:30,439
include the header in that.

71
00:03:30,439 --> 00:03:32,560
And there are times when you want to send large packets

72
00:03:32,560 --> 00:03:35,479
on this frame size, like an IPv6 packet, which

73
00:03:35,479 --> 00:03:38,879
can be a hundred and 1,280 bytes.

74
00:03:38,879 --> 00:03:42,479
And so what happens is that the IP layer passes a 1280

75
00:03:42,479 --> 00:03:47,319
byte packet to 6-low-pan, called IPv6,

76
00:03:47,319 --> 00:03:49,719
low-power personal network, it's to link layer support

77
00:03:49,719 --> 00:03:51,079
for IPv6.

78
00:03:51,080 --> 00:03:54,960
And 6-low-pan, the link layer breaks it up into fragments,

79
00:03:54,960 --> 00:03:58,160
which are then sent over the link reassembled

80
00:03:58,160 --> 00:04:02,920
at the other end of the link into an original packet.

81
00:04:02,920 --> 00:04:06,320
So in this case, the fragments are purely on the link.

82
00:04:06,320 --> 00:04:08,439
And then network layer doesn't see it.

83
00:04:08,439 --> 00:04:10,600
And the IP case, the network layer sees it,

84
00:04:10,600 --> 00:04:12,800
the transport case, transport layer sees it.

85
00:04:12,800 --> 00:04:16,040
But the other trait-actual transport segments are not broken.

86
00:04:16,040 --> 00:04:17,759
So let's walk through a concrete example.

87
00:04:17,759 --> 00:04:21,240
So the most, one of the really common cases

88
00:04:21,240 --> 00:04:23,480
of fragmentation, or rather, it's not common people

89
00:04:23,480 --> 00:04:25,719
try to avoid it, but it's a very simple mechanism.

90
00:04:25,719 --> 00:04:29,199
So it's good to explain is how fragmentation works in IP

91
00:04:29,199 --> 00:04:31,199
in the internet protocol.

92
00:04:31,199 --> 00:04:32,879
So here, let's imagine we have a route

93
00:04:32,879 --> 00:04:38,680
between across three hops, where the first and third hops

94
00:04:38,680 --> 00:04:42,439
use ethernet within maximum transfer unit of 1,500 bytes.

95
00:04:42,439 --> 00:04:44,439
But the middle hop uses a point-to-point link

96
00:04:44,439 --> 00:04:48,759
with a maximum transfer unit of 576 bytes.

97
00:04:48,759 --> 00:04:51,040
This means that at the link layer, the frames can only

98
00:04:51,040 --> 00:04:54,639
support, say, 576 bytes of data, or 1,500 bytes of data

99
00:04:54,639 --> 00:04:56,639
in their payload.

100
00:04:56,639 --> 00:04:59,199
So what happens now is some application at the house

101
00:04:59,199 --> 00:05:03,319
on the left wants to send a 1,400 byte payload.

102
00:05:03,319 --> 00:05:04,800
And so on the first hop, this is fine.

103
00:05:04,800 --> 00:05:07,000
We can take a 1,400 byte payload.

104
00:05:07,000 --> 00:05:09,159
And IP header is 20 bytes.

105
00:05:09,159 --> 00:05:11,040
And so we have 1,420 bytes.

106
00:05:11,040 --> 00:05:13,839
We can then put that ethernet frame, 1,420,

107
00:05:13,839 --> 00:05:19,000
fits just fine inside ethernet.

108
00:05:19,000 --> 00:05:21,039
But what happens when we hit the second host?

109
00:05:21,039 --> 00:05:23,519
We can't take this 1,400 byte payload

110
00:05:23,519 --> 00:05:28,399
and put it into a PPP frame because it won't fit.

111
00:05:28,399 --> 00:05:32,159
So what IP does is it takes the original packet

112
00:05:32,159 --> 00:05:33,879
and splits it into three fragments.

113
00:05:33,879 --> 00:05:37,919
So this is going to occur here at this node.

114
00:05:37,919 --> 00:05:41,079
This node is going to receive an IP packet of 1,400

115
00:05:41,639 --> 00:05:43,919
byte payload in this given IP header.

116
00:05:43,919 --> 00:05:46,919
Then realizing it should go over this PPP link will take it

117
00:05:46,919 --> 00:05:49,719
and generate three separate IP packets.

118
00:05:49,719 --> 00:05:51,639
I'll show how they're formed out of the minute

119
00:05:51,639 --> 00:05:56,360
as separate PPP frames with smaller payloads.

120
00:05:56,360 --> 00:06:00,599
So in this case, 512, 512, and 376 bytes.

121
00:06:02,719 --> 00:06:04,599
But so the trick, though, is that once this packet

122
00:06:04,599 --> 00:06:07,879
has been fragmented at this second node,

123
00:06:07,879 --> 00:06:10,560
those fragments then pass through the network unchanged.

124
00:06:10,560 --> 00:06:15,560
So the third node here does not reassemble them.

125
00:06:16,519 --> 00:06:19,680
Instead, what's gonna happen is that it's going to just

126
00:06:19,680 --> 00:06:23,959
forward them along and put these three IP fragments

127
00:06:23,959 --> 00:06:26,040
inside ethernet frames and forward them along

128
00:06:26,040 --> 00:06:27,079
to the destination.

129
00:06:27,079 --> 00:06:29,800
And then hopefully the destination will receive all of them

130
00:06:29,800 --> 00:06:34,800
and reassemble the original data of 1,400 bytes.

131
00:06:35,720 --> 00:06:37,240
So how does this work?

132
00:06:37,240 --> 00:06:42,240
So if we look at an IP header, there are a couple fields

133
00:06:42,879 --> 00:06:45,280
in it which allow this to happen.

134
00:06:45,280 --> 00:06:49,960
So basically, there's the IDEN field in an IP packet here.

135
00:06:50,879 --> 00:06:53,879
And the IDEN field is what allows the fragmentation

136
00:06:53,879 --> 00:06:57,160
assembly layer in IP or the fragmentation assembly in IP

137
00:06:57,160 --> 00:06:59,800
to be able to tell whether or not these are fragments

138
00:06:59,800 --> 00:07:01,519
of the same original packet.

139
00:07:01,519 --> 00:07:04,400
So before fragmentation, we're gonna see a packet

140
00:07:04,400 --> 00:07:06,319
that looks like this where it's IDEN

141
00:07:06,319 --> 00:07:08,159
to say some value X.

142
00:07:08,159 --> 00:07:11,959
And remember here, this is the more fragment bit

143
00:07:11,959 --> 00:07:12,800
of the IP header.

144
00:07:12,800 --> 00:07:13,639
This was zero here.

145
00:07:13,639 --> 00:07:15,639
This is the more fragment bit.

146
00:07:15,639 --> 00:07:17,199
And there's the offset field.

147
00:07:17,199 --> 00:07:18,120
This is original packet.

148
00:07:18,120 --> 00:07:20,040
This is standard IP packet.

149
00:07:20,040 --> 00:07:21,399
It's just an identifier.

150
00:07:21,399 --> 00:07:22,680
There are no fragments.

151
00:07:22,680 --> 00:07:24,000
This is offset zero.

152
00:07:24,000 --> 00:07:26,719
And it's just a 1,400 byte fragment.

153
00:07:26,719 --> 00:07:29,199
But then after the packet is fragmented,

154
00:07:29,199 --> 00:07:32,279
the more fragment bit is set for all what the last fragments.

155
00:07:32,279 --> 00:07:35,759
So here is first fragment here and the second fragment.

156
00:07:35,759 --> 00:07:39,000
Both have the more fragment bit set to indicate

157
00:07:39,000 --> 00:07:40,439
that more fragments are coming.

158
00:07:40,439 --> 00:07:42,199
The last one does not.

159
00:07:42,199 --> 00:07:46,680
And then the offset field tells a receiver

160
00:07:46,680 --> 00:07:48,759
where this data begins.

161
00:07:48,759 --> 00:07:52,319
And so as we can see here, this is a 512 bytes of payload.

162
00:07:53,360 --> 00:07:58,519
And so this goes from offset zero to 511.

163
00:07:58,519 --> 00:08:02,079
Now the second fragment is gonna start at byte 512

164
00:08:02,079 --> 00:08:06,000
and goes from byte 512 to 1024.

165
00:08:06,000 --> 00:08:07,959
And so the offset field is what indicates this.

166
00:08:07,959 --> 00:08:09,959
So the offset field is not in terms of bytes,

167
00:08:09,959 --> 00:08:11,399
but rather an 8 byte chunks.

168
00:08:11,399 --> 00:08:15,759
And so 64 times 8 is 512.

169
00:08:15,759 --> 00:08:18,639
And so this tells a receiver that this second fragment

170
00:08:18,639 --> 00:08:22,759
occurs at offset 512 within the packet.

171
00:08:22,759 --> 00:08:23,719
It's at offset zero.

172
00:08:23,719 --> 00:08:27,039
And then this is of course at offset 1024.

173
00:08:27,039 --> 00:08:29,439
The ident field is identical in all three fragments.

174
00:08:29,439 --> 00:08:31,479
And so this means that now in an endpoint,

175
00:08:31,480 --> 00:08:36,240
receiving these three fragments can properly reassemble

176
00:08:36,240 --> 00:08:39,120
the original IP datagram.

177
00:08:39,120 --> 00:08:41,879
And so the combination of the ident field

178
00:08:41,879 --> 00:08:44,720
and the source address is what allows it

179
00:08:44,720 --> 00:08:47,039
to cluster these three fragments together.

180
00:08:48,480 --> 00:08:50,399
And now since the offset field is encoded

181
00:08:50,399 --> 00:08:54,840
in 8 byte chunks, that means that each of these chunks,

182
00:08:54,840 --> 00:08:57,279
these fragments must be a multiple of 8 byte long,

183
00:08:57,279 --> 00:08:59,200
8 bytes long except for the last one.

184
00:09:00,200 --> 00:09:02,759
So fragmentation is in the IP case really helpful

185
00:09:02,759 --> 00:09:05,280
because it means that an endpoint can generate an IP packet

186
00:09:05,280 --> 00:09:10,360
without having to worry about what the intermediate maximum

187
00:09:10,360 --> 00:09:12,560
transfer units of the links are.

188
00:09:12,560 --> 00:09:15,160
So it's a great way for an endpoint to be able to generate

189
00:09:15,160 --> 00:09:17,440
a packet without having to know properties of the entire path,

190
00:09:17,440 --> 00:09:20,440
especially if say the path is dynamic.

191
00:09:20,440 --> 00:09:22,879
That being said, in practice,

192
00:09:22,879 --> 00:09:25,720
systems really try to avoid IP fragmentation.

193
00:09:25,720 --> 00:09:27,040
And the reason is that you've suddenly

194
00:09:27,039 --> 00:09:30,480
taken one packet, admitted into multiple packets.

195
00:09:30,480 --> 00:09:33,319
And so now the chance is that any one of those packets

196
00:09:33,319 --> 00:09:35,480
might be dropped, goes up, let's say,

197
00:09:35,480 --> 00:09:37,559
one percent of all packets are dropped suddenly,

198
00:09:37,559 --> 00:09:40,759
increasing the probability that any that one of those three

199
00:09:40,759 --> 00:09:44,000
will be dropped and therefore the whole original packet

200
00:09:44,000 --> 00:09:45,480
will have to be lost.

201
00:09:45,480 --> 00:09:48,000
IP doesn't support any reliability or retransmission

202
00:09:48,000 --> 00:09:50,240
of these fragments, so if one fragment is lost,

203
00:09:50,240 --> 00:09:52,199
generally you have to retransmit all of them

204
00:09:52,199 --> 00:09:53,959
that's up to a higher layer.

205
00:09:54,920 --> 00:09:57,560
So generally one of Void IP fragmentation.

206
00:09:57,560 --> 00:10:01,000
So one interesting trick that I'll approach the TCP

207
00:10:01,000 --> 00:10:05,240
sometimes uses is to actually choose a segment size

208
00:10:05,240 --> 00:10:06,720
to avoid fragmentation.

209
00:10:06,720 --> 00:10:11,720
Since TCP segments can be of any size that TCP wants,

210
00:10:12,160 --> 00:10:14,840
what it does is it tries to generate segments

211
00:10:14,840 --> 00:10:19,160
which will fit inside IP packets and not fragment

212
00:10:19,160 --> 00:10:21,160
on the path to destination.

213
00:10:21,160 --> 00:10:23,920
And the way you can do this is by setting the don't fragment

214
00:10:24,079 --> 00:10:26,879
and so say TCP connection when it opens up,

215
00:10:26,879 --> 00:10:29,479
it can say choose, well I'm gonna try sending,

216
00:10:29,479 --> 00:10:33,759
let's just say standard Ethernet frame with 1500 bytes.

217
00:10:33,759 --> 00:10:35,959
I'm gonna set the don't fragment.

218
00:10:37,159 --> 00:10:39,199
And if it gets an ICMP error saying,

219
00:10:39,199 --> 00:10:42,639
oh, you know, couldn't, you know, this thing,

220
00:10:42,639 --> 00:10:44,679
I had to fragment and I couldn't, then it says,

221
00:10:44,679 --> 00:10:45,879
oh, I'll try something else.

222
00:10:45,879 --> 00:10:46,919
There must be some smaller like,

223
00:10:46,919 --> 00:10:50,039
oh, I'll see if maybe there's a 512 byte PPP link.

224
00:10:50,039 --> 00:10:51,599
There's a bunch of ways you can search for this.

225
00:10:51,599 --> 00:10:52,959
One is to do a binary search.

226
00:10:52,960 --> 00:10:54,040
There's expensive.

227
00:10:54,040 --> 00:10:57,160
You can also search common, try common sizes like 1500 bytes.

228
00:10:58,639 --> 00:11:00,280
As an RSC that talks about the option.

229
00:11:00,280 --> 00:11:02,639
This is an approach where TCP can actually sense the connection,

230
00:11:02,639 --> 00:11:05,160
sense the properties of the path for connection.

231
00:11:05,160 --> 00:11:09,160
And based on that pick an optimal segment size such that

232
00:11:09,160 --> 00:11:10,600
it doesn't have fragmentation,

233
00:11:10,600 --> 00:11:12,960
but it's also able to minimize header overhead.

234
00:11:12,960 --> 00:11:17,080
It has as much payload per header given that it's minimized

235
00:11:17,080 --> 00:11:18,639
in the north segments that it sends.

236
00:11:23,040 --> 00:11:27,580
So,

237
00:11:27,580 --> 00:11:36,820
that's quite a huge amount of overhead.

238
00:11:36,820 --> 00:11:43,860
Some like resolver European Al 그런 Sort of W closet.

239
00:11:43,860 --> 00:11:47,860
So,

