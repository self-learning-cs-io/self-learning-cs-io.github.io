---
title: CS144 NetworkP1278 7Integrity
---

1
00:00:00,000 --> 00:00:06,200
Encryption provides confidentiality, but we also need integrity.

2
00:00:06,200 --> 00:00:10,279
For a system to be secure, we need to know that a message is actually generated by someone

3
00:00:10,279 --> 00:00:13,040
else and no one has modified it.

4
00:00:13,040 --> 00:00:16,839
For example, suppose we want a secure file system protocol.

5
00:00:16,839 --> 00:00:21,400
Without integrity, an adversary could have been append garbage data to rights or potentially

6
00:00:21,400 --> 00:00:24,440
create new right commands with garbage data.

7
00:00:24,440 --> 00:00:27,760
The basic point is that secrecy is not enough.

8
00:00:27,760 --> 00:00:30,520
It's important to prevent someone from reading our messages, but it doesn't protect them

9
00:00:30,520 --> 00:00:32,600
from tempering.

10
00:00:32,600 --> 00:00:37,840
The second property of secure systems, besides confidentiality, is integrity.

11
00:00:37,840 --> 00:00:41,160
Integrity algorithms let you know for sure that a message was generated by someone with

12
00:00:41,160 --> 00:00:42,160
a key.

13
00:00:42,160 --> 00:00:46,799
So assuming the key is secret, you can be assured it came from a specific program, host,

14
00:00:46,799 --> 00:00:48,000
et cetera.

15
00:00:48,000 --> 00:00:49,600
This is really useful.

16
00:00:49,600 --> 00:00:53,439
For example, with integrity, you can know that a routing vector actually came from the

17
00:00:53,439 --> 00:00:55,200
node that supposedly came from.

18
00:00:55,200 --> 00:00:59,120
An adversary is trying to trick you into routing traffic through them.

19
00:00:59,120 --> 00:01:03,560
You can know that the person who's making a bid in an auction actually made that bid.

20
00:01:03,560 --> 00:01:07,560
And you can know if you receive a message to terminate a connection or a bad message that

21
00:01:07,560 --> 00:01:11,120
might cause you to terminate the connection, that the message actually came from the other

22
00:01:11,120 --> 00:01:15,879
endpoint and isn't someone trying to shut down the connection on you.

23
00:01:15,879 --> 00:01:19,359
Generally speaking, insecurity, integrity usually comes first.

24
00:01:19,359 --> 00:01:24,200
There are lots of cases where you want integrity, but confidentiality isn't that important.

25
00:01:24,200 --> 00:01:30,840
And it's very rare that you want confidentiality without integrity.

26
00:01:30,840 --> 00:01:36,760
Cryptographic caches and message authentication codes are two major integrity primitives.

27
00:01:36,760 --> 00:01:40,960
Cryptographic caches let you safely determine that data hasn't been modified.

28
00:01:40,960 --> 00:01:43,120
Anyone can generate a cryptographic cache.

29
00:01:43,120 --> 00:01:45,560
They require no key.

30
00:01:45,560 --> 00:01:49,159
It's a hash function with some special properties.

31
00:01:49,159 --> 00:01:51,800
Cryptographic caches are useful for storing data.

32
00:01:51,799 --> 00:01:55,319
You can be sure no one has tampered with the data.

33
00:01:55,319 --> 00:02:02,079
And since no key is needed, anyone can check that the data hasn't been tampered with.

34
00:02:02,079 --> 00:02:04,640
Message authentication codes are max.

35
00:02:04,640 --> 00:02:08,400
Are a second way to verify that data hasn't been modified.

36
00:02:08,400 --> 00:02:12,400
They have all of the integrity properties that cryptographic caches do.

37
00:02:12,400 --> 00:02:16,199
What they have the additional property that they ensure that the person who generated

38
00:02:16,199 --> 00:02:18,960
the Mac has a key.

39
00:02:18,960 --> 00:02:23,719
So only someone else with the same key can check that the Mac is correct.

40
00:02:23,719 --> 00:02:26,080
So message authentication codes are useful in networks.

41
00:02:26,080 --> 00:02:30,400
If you send a message to the Mac appended to it, the receiver, if they have the corresponding

42
00:02:30,400 --> 00:02:35,640
key, can check that the message they receive is the message you sent, that you sent it,

43
00:02:35,640 --> 00:02:38,640
and since you had to have had the key to generate the Mac.

44
00:02:38,640 --> 00:02:43,319
In that way, Mac's also probably provide authentication hence their name.

45
00:02:43,319 --> 00:02:49,439
So let's look at cryptographic caches first.

46
00:02:49,439 --> 00:02:54,560
A cryptographic cache is a hash function with some special properties.

47
00:02:54,560 --> 00:03:00,199
Like an ordinary hash function, a cryptographic cache produces a fixed length output from

48
00:03:00,199 --> 00:03:02,240
an arbitrary length input.

49
00:03:02,240 --> 00:03:06,879
For example, I can compute a 256-bit hash from a gigabyte of data.

50
00:03:06,879 --> 00:03:11,159
They're generally very fast to compute faster than the network.

51
00:03:11,159 --> 00:03:16,120
Cryptographic caches, like normal hash functions, typically work by performing a single scan

52
00:03:16,120 --> 00:03:21,240
of the data and performing some mathematical operations based on each fighter word.

53
00:03:21,240 --> 00:03:24,599
That way you don't have to keep the entire data in one's and memory at once, you can just

54
00:03:24,599 --> 00:03:27,639
stream through it.

55
00:03:27,639 --> 00:03:32,599
Cryptographic caches provide the property that they're collision-resistant.

56
00:03:32,599 --> 00:03:38,719
What this means is that if I have some data X and a hash, H of X, that it's intractable

57
00:03:38,719 --> 00:03:45,319
to generate a message Y such that the hash of Y is equal to the hash of X.

58
00:03:45,319 --> 00:03:47,919
Of course, there are many such collisions.

59
00:03:47,919 --> 00:03:52,240
So let's say I have a 256-bit cryptographic hash.

60
00:03:52,240 --> 00:03:56,800
There are two, the 256 different values this hash could take.

61
00:03:56,800 --> 00:03:59,560
Let's say I'm hashing a gigabyte of data.

62
00:03:59,560 --> 00:04:02,680
Well, there are two to the 30 bits.

63
00:04:02,680 --> 00:04:09,360
So two to the two to the 30 different blocks of data, but only two to the 256-bit different

64
00:04:09,360 --> 00:04:12,200
hashes.

65
00:04:12,200 --> 00:04:17,560
So while such collisions exist, they're very difficult to find such that people spend years

66
00:04:17,560 --> 00:04:19,480
trying to do so and don't.

67
00:04:19,480 --> 00:04:25,439
You can't just try two of the different, to 1220 different data blocks.

68
00:04:25,439 --> 00:04:28,079
This is a very, very deep idea.

69
00:04:28,079 --> 00:04:30,000
Make sure you understand it.

70
00:04:30,000 --> 00:04:37,959
When a hash value H, it is intractable to generate a piece of data that has that hash value.

71
00:04:37,959 --> 00:04:42,120
This might seem very simple, but it is amazingly powerful.

72
00:04:42,120 --> 00:04:49,519
Given a hash value H, it is intractable to generate a piece of data that has that hash value.

73
00:04:49,519 --> 00:04:53,360
If you need to use a hash function, then use SHA 256 or SHA 512.

74
00:04:53,360 --> 00:04:59,480
These are the SHA secure hash algorithm too, SHA 2 algorithms, with either 256 or 512

75
00:04:59,480 --> 00:05:01,120
-bit hashes.

76
00:05:01,120 --> 00:05:03,960
SHA 1 is nearly broken today.

77
00:05:03,960 --> 00:05:08,200
There's also SHA 3, which the National Institute of Stems' Technology selected in October

78
00:05:08,200 --> 00:05:13,439
2012 to be an alternative hash to SHA 2, which is just as strong, but based on different

79
00:05:13,439 --> 00:05:15,520
mathematical principles.

80
00:05:15,520 --> 00:05:21,800
That way, if there's something wrong with SHA 2, we can fall back on SHA 3.

81
00:05:21,800 --> 00:05:27,640
Now SHA 2 is designed by the National Security Agency or NSA in published in 2001.

82
00:05:27,639 --> 00:05:30,879
Given all the recent press on the NSA trying to build back doors, you might think there's

83
00:05:30,879 --> 00:05:32,919
one in SHA 2.

84
00:05:32,919 --> 00:05:34,759
Really chances are there isn't.

85
00:05:34,759 --> 00:05:39,319
It's been around for over a decade, and it was vetted in a public process.

86
00:05:39,319 --> 00:05:43,639
Anyone who has anyone in cryptography and security has taken a look, and it seems fine.

87
00:05:43,639 --> 00:05:45,120
Seems fine.

88
00:05:45,120 --> 00:05:51,039
Raking SHA 2 would be the equivalent of developing Einstein's theory of relativity and physics.

89
00:05:51,039 --> 00:05:55,399
SHA 3 was designed by a group of security researchers and won a competition sponsored

90
00:05:55,399 --> 00:05:56,399
by Mist for the...

