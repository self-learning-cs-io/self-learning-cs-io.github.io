---
title: 计算机网络 007 principle - Layering
date: 2025-10-19 10:00:06
---

发言人   00:00
In the last few videos, you've seen many references to layering, particularly in the video describing the four layer internet model. Layering is very, very widely used principle and has been used in networking for decades, predating the internet. In fact, layering is a design principle used widely outside networking as well. It's commonly used as a design principle in many, many types of computer system. There are lots of reasons for layering, and we'll explore some of them in this video. 
在最近的几个视频中，您已经看到了许多关于分层的参考，特别是在描述四层互联网模型的视频中。分层是一种非常广泛使用的原则，在网络中已经使用了几十年，比互联网还早。事实上，分层也是一种在网络外部广泛使用的设计原则。它通常被用作许多、许多类型的计算机系统的设计原则。分层的原因有很多，我们将在本视频中探讨其中的一些。

发言人   00:27
We'll explore what layering is. We'll look at some of the simple examples of layering in communication and computer systems, and will explain why so many systems are layered either by natural happenstance or deliberately by design. 
我们将探索什么是分层。我们将看看通信和计算机系统中分层的一些简单例子，并将解释为什么如此多的系统是通过自然偶然或故意设计分层的。


发言人   00:40
Let's start with a definition of layering. Layering is the name we give to the organization of a system into a number of separate functional components or layers. The layers are hierarchical and they communicate sequentially. In other words, each layer has an interface only to the layer directly above and below. Each layer provides well bedeviled service to the layer above, using the services provided by layers below and its own private processing. 
让我们从分层的定义开始。分层是我们给系统组织成许多独立功能组件或层的名称。这些层是分层的，它们按顺序通信。换句话说，每一层都只有一个直接连接上方和下方层的接口。每一层都使用下面各层提供的服务及其自己的私有处理，为上面的层提供了良好的服务。



发言人   01:11
There are many examples of layering in everyday life, particularly when one service is deliberately or naturally layered on top of another. 
在日常生活中有很多分层的例子，特别是当一项服务有意或自然地分层在另一项服务之上时。

发言人   01:18
For example, if you're looking for airplane tickets, you might visit a visit a brokerage website such as Google Flight Hipmunk, or Kayak. These websites let you find tickets across a wide range of airlines. By communicating with a single service, you could instead go to the website of every airline to query what tickets they have available. The brokerage website is providing you a service layer on top of each airline, abstracting away the details of each airline's website for you. 
例如，如果您正在寻找机票，您可以访问诸如Google航班Hipmunk或Kayak等经纪网站。这些网站可以让你找到各种航空公司的机票。通过与单一服务通信，您可以改为访问每个航空公司的网站来查询他们有哪些机票。经纪网站在每个航空公司的基础上为您提供服务层，为您抽象出每个航空公司网站的详细信息。

发言人   01:45
Now, if we look under the covers of each airline, they fly different types of airplane over different routes. The airplane takes care of the details of providing the service and offers you the simple abstraction of a ticket valid for a particular flight to take you between two airports. They're hiding many other details, too, such as how they provide the awful food they serve in cases they have a number of suppliers to provide meals, drinks, fuel, and so on. Each of those are naturally hidden from us, the consumer. This separation of concerns allows each layer in the hierarchy to focus on doing its job well and provide a well defined service to the layer above. 
现在，如果我们看一下每家航空公司的封面，它们会在不同的航线上飞行不同类型的飞机。飞机负责提供服务的细节，并为您提供适用于特定航班的简单抽象机票，以带您在两个机场之间旅行。他们还隐藏了许多其他细节，比如他们如何提供糟糕的食物，以应对有多个供应商提供的膳食、饮料、燃料等情况。每一个自然都是隐藏的，对我们消费者来说。这种关注点的分离允许层次结构中的每一层专注于做好自己的工作，并为上面的层提供定义良好的服务。


发言人   02:26
Another well known example of layering closer to the internet is the Postal Service. Imagine that I have a book that I want to send to fill. I placed the book in an envelope, add Phil's address and mine, and then hand it over to Olive to take to the mailbox. The Postal Service sorts the mail, then sends it by a variety of different means, airplanes, mail trucks, trains, etcetera, until it reaches a sorting office near Phil. The mailman delivers the letter to Phil, who opens it and finds the book inside. The service is clearly layered at the top. 
另一个众所周知的更接近互联网的分层例子是邮政服务。想象一下，我有一本书想要发送来填充。我把书放在一个信封里，加上Phil的地址和我的地址，然后把它交给Olive取走。邮政服务对邮件进行分类，然后通过各种不同的方式发送，如飞机、邮件卡车、火车等，直到邮件到达位于Phil附近的分拣办公室。邮差把信交给了Phil，Phil打开后在里面找到了那本书。该服务显然是在顶部分层的。




发言人   03:09
I don't care how the letters get from me to fill, whether they go by airplane, truck, or hovercraft. And I don't care about the route that the book takes or how many sorting offices it passes through along the way. I don't mind whether Olive Wars skips bicycles or runs to the mailbox. I don't care which mailbox she posts the letter in. I want the lower layers to extract away the details for me, providing me with a simple service model. I put the book in an envelope and the layers below deliver it to fill in turn. Olive doesn't need to know how the Postal Service delivers the letter. She simply communicates with the layer below by posting the letter. Phil just wants the book. 
我不在乎这些信件是如何由我来填写的，无论它们是通过飞机、卡车还是气垫船。我不关心这本书要走的路线，也不关心沿途经过多少个分拣办公室。我不介意橄榄战争是跳过自行车还是跑到邮箱。我不在乎她把信放在哪个邮箱里。我想让下层为我提取细节，为我提供一个简单的服务模型。我把书放在一个信封里，下面的层依次寄出。橄榄不需要知道邮政服务如何投递信件。她通过张贴信件与下面的层简单地沟通。菲儿只想要这本书。

发言人   03:50
Notice that each layer communicates only with the layers above and below. If the Postal Service deploys new trains or starts using a different airline freight service, Phil and I don't need to know about it, in other words, because communication is simply up and down with a well-defined interface between layers, we can improve each layer independently over time. 
请注意，每一层仅与上一层和下一层通信。如果邮政服务部署新的火车或开始使用不同的航空货运服务，Phil和我不需要知道这件事，换句话说，因为通信很简单，各层之间有一个定义明确的接口，我们可以随着时间的推移独立改进每一层。

发言人   04:10
For example, if I want faster guarantee delivery, I could handle the envelope to a carrier such as DHL or FedEx. The interface is almost the same, I simply give them an envelope, and money layering is deliberately designed into many computer systems when we write programs. This is Ty editing a program. 
例如，如果我想要更快的保证交付，我可以将信封交给DHL或联邦快递等承运人。接口几乎相同，我只是给他们一个信封，当我们编写程序时，金钱分层被故意设计到许多计算机系统中。这是在编辑一个程序。


发言人   04:29
We create source code using a language that abstracts away the details of the operating system, how virtual memory works, and how the low level details of the hardware. Okay, so C is in great at hiding the details, but many other languages, such as Java and Python, deliberately shield us from how the lower layers work. 
我们使用一种语言创建源代码，这种语言抽象了操作系统的细节、虚拟内存的工作原理以及硬件的底层细节。好的，所以C很擅长隐藏细节，但许多其他语言，如Java和Python，故意保护我们免受下层的工作方式的影响。

发言人   04:46
As a programmer, we communicate with the layer below the compiler by handing out our source code. The compiler is a self-sustained functional component that is responsible for several tasks such as lexical analysis, parsing our code, preprocessing declarations, and code generation. Generation optimization. The compiler generates object code, which then it then passes to the linker. The linker links together the compiled object files and libraries, it generates an executable file. The CPU, real or virtual, then executes the code. 
作为一名程序员，我们通过分发我们的源代码与编译器下面的层进行通信。编译器是一个自我维持的功能组件，负责多个任务，如词法分析、解析代码、预处理声明和代码生成。生成优化。编译器生成目标代码，然后将其传递给链接器。链接器将编译后的目标文件和库链接在一起，它生成一个可执行文件。CPU，无论是真实的还是虚拟的，然后执行代码。



发言人   05:23
If you have experience writing computer programs, the benefits of layering are fairly clear. In this example, layering breaks down the overall problem of writing programs that execute on hardware into modules or functional component, each with a well defined role and providing a well defined service to the layer above. It also provides a clear separation of concerns. The compiler can focus on lexical analysis, parsing, and so on. The linker can focus on efficiently piecing objects together. Neither has to worry about the job of the other, and each can be improved, upgraded, and replaced over time as technology and no how it progresses. For example, we might swap out a commercial C compiler with GCC, or vice versa, without needing to change the linker or the language we use. 
如果你有编写计算机程序的经验，分层的好处是相当明显的。在这个例子中，分层将编写在硬件上执行的程序的整体问题分解为模块或功能组件，每个模块或组件都有一个明确定义的角色，并为上层提供明确定义的服务。它还提供了明确的关注点分离。编译器可以专注于词法分析、解析等。链接器可以专注于有效地将对象拼接在一起。双方都不必担心对方的工作，随着技术的进步，两者都可以随着时间的推移得到改进、升级和替换。例如，我们可以使用GCC替换商业C编译器，反之亦然，而无需更改我们使用的链接器或语言。

发言人   06:14
When Nick first drafted these slides, I was excited that he put compilers in as an example of layering. The great example of both the benefits of layering, as well as how sometimes you need to break layering despite the very negative consequences. 
当尼克第一次起草这些幻灯片时，我很兴奋他把编译器作为分层的例子。这是一个很好的例子，既展示了分层的好处，也展示了尽管会产生非常负面的后果，有时还是需要打破分层。

发言人   06:28
So let's take the C programming language as an example. Generally speaking, a piece of C code can be compiled for almost any processor. We can take C code like this statement I plus plus, and compile it for an Arm processor and a phone. An X 8664 processor, and a laptop or a microcontroller, an ultra modern dishwasher. In this way, the C code is hardware independent and so it keeps the layer in here. But sometimes we need our C code to do something special that only our processor can do. For example, in x 8664 processor, as all kinds of special instructions that a microcontroller doesn't, C allows you to include except a code directly, software like operating system kernels such as Linux and Windows use this for some of those lowest level implementations. 
那么让我们以C编程语言为例。一般来说，一段C代码可以编译为几乎任何处理器。我们可以像这样使用C代码语句I plus plus，并将其编译为Arm处理器和手机。一个x8664处理器，一个笔记本电脑或微控制器，一个超现代的洗碗机。这样，C代码是独立于硬件的，因此它将层保留在这里。但有时我们需要C代码做一些只有我们的处理器才能做的特殊事情。例如，在x 8664处理器中，作为微控制器不具备的各种特殊指令，C允许您直接包含除代码外的其他代码，如Linux和Windows等操作系统内核的软件将其用于某些最低级别的实现。

发言人   07:14
The layering that C provides hides those details, so doesn't let you do so directly, but you have to do so to achieve your goal. So OS kernels include assembly code doing so, this means that the code is no longer layer independent, the Linux context switch assembly written for Arm only works for Arm, so you have to write a version of this code for each layer. If Linux wants to run on a new processor, developers need to write new assembly code for that processor. So this is a great example because it shows the benefits of layers that separate concerns and simplify your system, just as programming C is easier than assembly, but sometimes you have to break the layer of boundaries, doing so has a huge cost. 
C提供的分层隐藏了这些细节，因此不允许您直接这样做，但您必须这样做才能实现您的目标。因此操作系统内核包括汇编代码这样做，这意味着代码不再是层独立的，为Arm编写的Linux上下文切换汇编只适用于Arm，所以你必须为每层编写一个版本的代码。如果Linux想要在新的处理器上运行，开发人员需要为该处理器编写新的汇编代码。所以这是一个很好的例子，因为它展示了分层的好处，可以分离关注点并简化您的系统，就像编程C比汇编更容易一样，但有时您必须打破边界层，这样做会有巨大的成本。

发言人   07:57
Suddenly, you are no longer independent of the lower, greatly limiting flexibility. So sometimes you have to do it, but do so only when you really, really have to, as we'll see a lot of the practical operational challenges in the internet today result from people breaking layering and assuming things above and below their service interface. There's a continual tension to improve the internet by making cross layer optimizations and the resulting loss of flexibility. We'll see one really telling example of this was something called Nats or network network address translators, tremendously useful devices that have unfortunately made it almost impossible to add new transport protocols to the internet. 
突然间，你不再独立于底层，极大地限制了灵活性。所以有时你必须这样做，但只有在你真的必须这样做的时候才这样做，因为我们会看到今天互联网中的许多实际运营挑战都是由于人们打破分层并假设其服务接口上方和下方的事物。通过进行跨层优化和由此导致的灵活性损失来改善互联网，这一紧张局势持续存在。我们将看到一个非常有说服力的例子，那就是称为Nats或网络网络地址转换器的东西，这是非常有用的设备，不幸的是，几乎不可能向互联网添加新的传输协议。


发言人   08:40
So in summary, there are five main reasons we use layering and computer systems. 
总之，我们使用分层和计算机系统有五个主要原因。

发言人   08:45
Modularity, it breaks down the system into smaller, more manageable modules to well defined service. Each layer provides a well defined service to the layer above. Third, reuse. A layer above can rely on all the hard work put in by others to implement the layers below. It saves us the time to write each layer whenever we build a new system. Fourth, separation of concerns. Each layer can focus on its own job without having to worry about how other layers do theirs. The only communication is up and down the layers, so it helps keep one layer processing and data local and internal where possible, minimizing the complex interactions between layers. Fifth, it allows continuous improvement of each function. 
模块化，它将系统分解为更小、更易于管理的模块，以提供明确定义的服务。每一层都在上一层提供定义良好的服务。第三，再利用。上面的一层可以依靠其他人投入的所有辛勤工作来实现下面的层。每当我们构建新系统时，它为我们节省了编写每一层的时间。第四，关注点分离。每一层都可以专注于自己的工作，而不必担心其他层如何做。唯一的通信是上下各层，因此它有助于保持一层处理和数据本地和内部 (如果可能)，最大限度地减少层之间复杂的交互。第五，它允许每个功能的持续改进。

发言人   09:31
A sixth benefit is specific to layered communication systems such as the Internet, that is, peer to peer communications. In the 4 layer Internet model, we saw how each layer communicates with its peer on another system using the delivery service provided by it provided by the layers below. Similarly, in the mail example, Phil and I were communicating with each other as users without worrying about how the communication service works. 
第六个好处是专门针对分层通信系统的，例如互联网，即点对点通信。在4层互联网模型中，我们看到了每一层如何使用下面各层提供的交付服务与另一个系统上的对等方进行通信。同样，在邮件示例中，我和Phil作为用户相互通信，而不必担心通信服务如何工作。