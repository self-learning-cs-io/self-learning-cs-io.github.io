---
title: 计算机网络 010 Network Byte Order
date: 2025-10-19 10:00:09
---

发言人   00:01
So why does this matter? 
这有什么关系呢？

发言人   00:02
If two computers are going to communicate, they need to agree on whether they represent numbers using big Indian or little Indian formats. This is complicated by the fact that different processors use different Indianness. For example, x 86 processors, processors from Intel and AMD are little Indian. The least significant byte comes first. Arm processors and contrast, such as those used in the iPhone, are big endian. Where the most significant bike comes first. We don't want two computers to care or know whether the other side is big indium or little indium, so protocol specification bodies typically pick one and stick with it. For the internet, this means big Andean. All protocols that are internet specifications use a big Indian format. 
如果两台计算机要通信，它们需要就是否使用大印度或小印度格式代表数字达成一致。这很复杂，因为不同的处理器使用不同的Indianness。例如，x86处理器，英特尔和AMD的处理器都是印度的。最低有效字节先出现。Arm处理器和对比度 (例如iPhone中使用的那些) 都是大端字节。最重要的自行车首先出现在哪里。我们不希望两台计算机关心或知道另一侧是大铟还是小铟，因此协议规范机构通常会选择其中一个并坚持使用它。对于互联网来说，这意味着大安第斯山脉。所有互联网规范的协议都使用一种大印度格式。

发言人   00:44
Here's an example snippet of C code that will tell you whether your computer is big, indan, or little in a 6 16 B value and casts a pointer to it that letsgo code. Look at the bytes individually. If the byte index 0 is 0x 4 0, this means the most significant byte comes first and the computer is big ndianiche byte index 1 is 0x 4 0, then it's little ndian. Wait, this creates a complication. You need an internet packet to be in big NDN format, but what if your processor is little Indian? Let's say, for example, that you want to set the port number of TCP segment to be 80, the Http port. A simple way to do this might be to create AC struct that has a field port at the right offset. But if you use a value 80 to compare with a poor field, that 80 will be stored little Indian with 0x 5 0 as the first byte being India needs 0x 5 0 stored in the second byte, So although the port field in the segment is 80 and you have a as your value, this test will fail to make this easier. 
这是一段C代码的示例片段，它将告诉您计算机的值是6 16 B中的大、多或小，并将指针强制转换为letsgo代码指向它。逐个查看字节。如果字节索引0是0 x40，这意味着最重要的字节首先出现，计算机是大的，字节索引1是0 x40，那么它是小的ndian。等等，这就产生了一个复杂性。你需要一个大NDN格式的互联网数据包，但如果你的处理器是小印度呢？例如，假设您想要将TCP段的端口号设置为80，即Http端口。一种简单的方法是创建交流结构，在右侧偏移处有一个字段端口。但是，如果您使用值80与贫穷字段进行比较，则该80将被存储为0 x5 0，因为第一个字节是印度需要0 x5 0存储在第二个字节中，因此，尽管段中的端口字段为80，并且您的值为，这个测试将无法使这更容易。


发言人   01:44
See, networking libraries provide utility functions that convert between host and network order. The function H2 NS, for example, takes a host short 16 b value as a parameter and returns a value in network order. There's also functions for converting a network short to a host short and functions for longs, 30 cubic values. So the right way to test whether the packet port is 80 is to read the port field with packet structure and call N 2 HS to convert it from network order to height host order. You can then compare it with 80 and get the correct result. In the case of little Indian architecture and to HS and H 10 s, reverse the order of the 2 B. In the case of a big Indian architecture, they just return the value unchanged. 
请参阅，网络库提供在主机和网络顺序之间进行转换的实用函数。例如，函数h2ns将主机的short 16 b值作为参数，并按网络顺序返回一个值。还有用于将网络短转换为主机短的功能，以及用于长30立方值的功能。因此，测试数据包端口是否为80的正确方法是使用数据包结构读取端口字段，并调用N 2 HS将其从网络顺序转换为高度主机顺序。然后你可以将它与80进行比较，并得到正确的结果。在小印度建筑和HS和h10的情况下，将2 B的顺序颠倒。在印度大型建筑的情况下，它们只是返回未改变的值。


发言人   02:30
These functions provide you the mechanisms by which you can write nakin code that's independent of your processor architecture. But be careful, I really can't stress this enough, Be careful whenever you handle network data. If you aren't principled and rigorous about when you translate between host and network order, you'll give yourself a tremendous headache because you've forgotten to convert or have inadvertently converted twice, and suddenly protocols behaving wrongly are triggering all kinds of weird bugs. I've certainly done this many times, and so you want to move on as much as you can. 
这些函数提供了一种机制，使您可以编写独立于处理器架构的纳金代码。但要小心，我真的不能强调这一点，无论何时处理网络数据都要小心。如果你对在主机和网络顺序之间进行转换不坚持原则和严格要求，你会给自己带来极大的头痛，因为你已经忘记转换或无意中转换了两次，突然之间协议的错误行为引发了各种奇怪的错误。我确实这样做了很多次，所以你想尽可能地继续前进。


发言人   03:02
Now that we know how internet specifications lay out multi-byte values in network order or big endean, we can look at how Internet specifications describe their packet formats. For historical reasons, internet specifications are written in plain Ascii text. The block on the text on the left is taken verbatim from request for Commons RFC 791, which specifies the Internet Protocol version 4 or Ipv 4. The top shows the bits from 0 to 31. Packets are written 4 B wide. Since Ipv 4 has five rows of required fields, this means that an Ipv 4 header is at least 20 B long. 
既然我们知道了互联网规范如何以网络顺序或大数顺序排列多字节值，我们可以看看互联网规范如何描述它们的数据包格式。由于历史原因，互联网规范是用纯Ascii文本编写的。左边文本上的块是从request for Commons RFC 791中逐字获取的，它指定了互联网协议版本4或Ipv 4。顶部显示了从0到31的位。数据包的写入宽度为4 B。由于Ipv 4有五行必填字段，这意味着Ipv 4标头至少有20 B长。

发言人   03:39
Nick and I often use a simpler visual format when we show packets like the one on the right. To use this as an example, the total length field of an Ipv 4 packet is 2 B or 16 b long. You can see in the upper right, this means that an Ipv 4 packet can't be longer than 65535 B. That field in the packet is stored big Andean, a packet length of 1400 B is stored at 0x 5 7 8, so the third byte of an IP packet of that length is 0x 0 5. Let's see this in Wireshark. I'm just going to start Wireshark and listen for packets. This first packet is for something called TLS or transport layer security, it'll web browser is used for secure connections. Https TLS hides the data of the packet from us, but we can still see its headers. 
当我们展示像右边的数据包时，尼克和我经常使用更简单的视觉格式。以此为例，一个Ipv 4数据包的总长度字段为2 B或16 b长。你可以在右上角看到，这意味着一个Ipv 4数据包不能超过65535 B。数据包中的该字段存储得很大，长度为1400 B的数据包存储在0 x5 7 8，因此该长度的IP数据包的第三个字节为0 x0 5。让我们在Wireshark看看这个。我只是要启动Wireshark并监听数据包。这个第一个数据包用于称为TLS或传输层安全的东西，它将web浏览器用于安全连接。Https TLS隐藏了数据包的数据，但我们仍然可以看到它的标头。


发言人   04:26
Using Wireshark, we can see that a TLS payload is inside a TCP segment to port 443, the standard TLS port. This TCP segment is inside the Ipv 4 header, looking in detail at the Ipv 4 header, we can see that the packet's total length field is 1230. The hexadecimal for 1030 is 0x 0 4 CE 1 24, or 4x 256 plus 106, or 0x CE at the bottom. Wireshark shows us the actual bytes of the packet, and there it is 0 4 CE in Big Andean, our network order. 
使用Wireshark，我们可以看到TLS负载在到端口443的TCP段内，这是标准的TLS端口。这个TCP段在Ipv 4报头内部，详细查看Ipv 4报头，我们可以看到数据包的总长度字段是1230。1030的十六进制值是0x0 4欧洲合格认证1 24，或4x256加106，或底部的0x欧洲合格认证。Wireshark向我们展示了数据包的实际字节数，它在我们的网络顺序中是0 4欧洲合格认证。


发言人   05:05
You've seen how different processors layout numbers differently. But since network particles need to agree protocol specifications, decide how the numbers are laid out in their packets, which can differ from your processor. To help you with this, see networking libraries provide helper functions that convert between host and network order, but use them carefully. Using them haphazardly can easily lead you to many lost yards of debugging, which be prevented by being careful when you start and deciding on a principled approach to converting in your code. 
你已经看到不同处理器布局数字的不同。但是由于网络粒子需要同意协议规范，因此决定数字在其数据包中的布局方式，这可能与您的处理器不同。为了帮助您实现这一点，请参阅网络库提供了帮助函数，可以在主机和网络顺序之间进行转换，但要谨慎使用。随意使用它们很容易导致您丢失许多调试代码的错误，这可以通过在开始时小心并决定在代码中进行转换的原则性方法来防止。