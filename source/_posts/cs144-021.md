---
title: 计算机网络 021 FSM 
date: 2025-10-19 10:00:20
---

发言人   00:00
I'm going to explain finite state machines, something very commonly used when specifying network protocols and systems. I'll also explain the common way they're drawn a network protocols. I'll conclude by showing you the finite state machine that's part of the TCP specification, which defines how TCP connections are set up and torn down. So you'll see how you can describe something like the three way handshake of TCP in a finite state machine. 
我将解释有限状态机，这是在指定网络协议和系统时非常常用的东西。我还将解释他们绘制网络协议的常见方式。最后，我将向您展示有限状态机，它是TCP规范的一部分，它定义了如何建立和断开TCP连接。因此，您将看到如何在有限状态机中描述类似于TCP的三次握手的事情。

发言人   00:24
As the name suggests, a finite state machine is composed of a finite number of states. A state is a particular configuration of the system. 
顾名思义，有限状态机由有限数量的状态组成。状态是系统的特定配置。

发言人   00:32
I'm going to start with an abstract example. In this example, we have three states, state one, state two in state 3. So our system can be in one of these three states. Edges between the states define how we transition between them. When we draw an edge, we first specify what events caused the transition to occur. Below this, we can state what actions the system will take when that transition occurs. The second part is optional because not all transitions have actions associated with them. But if there is an action, you should specify it. Otherwise, you have an incomplete specification and people might not test or implement it correctly. 
我将从一个抽象的例子开始。在这个例子中，我们有三个状态，第一个状态，第二个状态在第三个状态。因此，我们的系统可以处于这三种状态之一。状态之间的边界定义了我们如何在它们之间转换。当我们绘制边缘时，我们首先指定导致转换发生的事件。下面，我们可以说明当转换发生时系统将采取什么操作。第二部分是可选的，因为并非所有过渡都有关联的操作。但如果有操作，你应该指定它。否则，您的规范不完整，人们可能无法正确测试或实现它。

发言人   01:12
If the system is in a state and an event arrives for which there is no transition described, then the behavior of the FSM is undefined. There could be multiple transitions from a single state. So here we have a second transition from state one, a different event that will take the system into state 3. For any given state, the transition for an event must be unique. In this example, an event can cause state one to transition to state two or transition to state three, but you can't have the same event associated with both transitions, otherwise the transition is ambiguous. If the event occurs, would you be in state 2 or state three? 
如果系统处于某种状态，并且事件到达而没有描述任何转换，则未定义FSM的行为。单个状态可能有多个转换。这里我们有状态一的第二个转换，一个不同的事件将把系统带入状态3。对于任何给定的状态，事件的转换必须是唯一的。在这个例子中，一个事件可能会导致状态1转换到状态2或转换到状态3，但你不能让同一个事件与两个转换相关联，否则转换是不明确的。如果事件发生，你会处于状态2还是状态3？

发言人   01:52
The system can only be in one state. So let's walk through an example, an Http request. Http requests are a bit more complex than this. There are all kinds of options, so for this example is used a very simple form, let's describe our system this way in our starting state, we are viewing a page or otherwise idle, we want to load a new page, we transition to the page requesting state, so the event is load new page and the action is open a connection to the web server. Once we've opened a connection, we're now in the page requesting state, we'll transition back to the idle state when the connection closes. When we finish requesting every resource on the page, we need one more state which describes where we are in requesting a page. On the event of having more resources to request, we take the action of requesting a resource within Http get this puts us in the requesting pending state on the event of receiving the response, our system transitions back to the page requesting state. So here we have a three state systems idle page requesting and request pending. 
系统只能处于一种状态。让我们来看一个例子，一个Http请求。Http请求比这复杂一点。有各种各样的选项，所以这个例子使用了一个非常简单的形式，让我们在开始状态下这样描述我们的系统，我们正在查看页面或其他空闲状态，我们想要加载一个新页面，我们转换到页面请求状态，因此，事件将加载新页面，并且操作是打开与web服务器的连接。一旦我们打开一个连接，我们现在处于页面请求状态，当连接关闭时，我们将转换回空闲状态。当我们完成页面上每个资源的请求时，我们还需要一个状态来描述我们在请求页面时的位置。在有更多资源请求的事件中，我们采取在Http中请求资源的操作，这将使我们处于请求挂起状态，在收到响应的事件中，我们的系统转换回页面请求状态。所以在这里，我们有一个三状态系统空闲页面请求和请求挂起。

发言人   03:08
On one hand, this is a nice simple FSM, but if you were to try to implement it, it leaves a lot on set. Specifically, we have four events in the system page request more request receive response and connection closed, so what happens if the connection close event arrives when we're in the request pending state or when we receive a page request while in the page requesting state, or receive a response while in the idle state? 
一方面，这是一个不错的简单FSM，但如果你试图实现它，它会在现场留下很多东西。具体来说，我们在系统页面请求中有四个事件，更多的请求接收响应和连接关闭，那么如果连接关闭事件在我们处于请求挂起状态或在页面请求状态下收到页面请求时到达，或者在空闲状态下收到响应时到达，会发生什么？

发言人   03:33
If you want to be completely explicit and careful, you should specify what happens on each state for every event, but this can lead to complicated FSM, which have tons of edges. So often instead, you'll write down just the common cases in the FSM for ease of understanding and have some supporting text about other transitions. Or in some cases, it can even be acceptable to leave something undefined. The Internet Engineering Task Force, for example, the ITF often doesn't completely specify every FSM. The idea is that by specifying only the parts that are necessary for interoperability, you can leave the specification flexible for future exploration. If people use the protocol, they'll figure out if something is important, and if so, can specify that extra part later. So let's walk through a real example of an FSM, probably the most famous FSM on the Internet. 
如果你想完全明确和小心，你应该指定每个事件在每个状态上发生的事情，但这可能会导致复杂的FSM，它有大量的边缘。因此，通常情况下，您会在FSM中写下常见情况，以便于理解，并提供一些关于其他转换的支持文本。或者在某些情况下，未定义某些东西甚至可能是可以接受的。例如，互联网工程任务组 (ITF) 通常不会完全指定每个FSM。这个想法是，通过只指定互操作性所需的部分，您可以将规范灵活地留给未来的探索。如果人们使用该协议，他们会弄清楚某些事情是否重要，如果重要，可以稍后指定额外的部分。让我们来看看一个FSM的真实例子，可能是互联网上最著名的FSM。

发言人   04:26
This diagram here describes the finite state machine of TCP. I know it looks very complicated. It has 12 states, but I'll walk through it bit by bit and you'll see how it all fits together. First off, the diagram really has four parts, which we can look at separately. These top four states, or what describe how you open a TCP connection. This center state established, it's when TCP is sending and receiving data, It's after the connection has been established but before it's been closed. These six states describe how connections close this state At the bottom, closed denotes the connection is closed and the node can forget about it. Note that the top state is also the closed state. 
这里的图表描述了TCP的有限状态机。我知道这看起来很复杂。它有12个州，但我会一点一点地走进去，你会看到它们是如何融合在一起的。首先，图表确实有四个部分，我们可以分别查看。这四个最常见的状态，或者描述如何打开TCP连接的状态。此中心状态已建立，当TCP发送和接收数据时，它是在连接建立之后但在关闭之前。这六个状态描述了连接如何关闭在底部的这个状态，关闭表示连接已关闭，节点可以忘记它。请注意，顶部状态也是关闭状态。

发言人   05:18
Before we open the connection, recall that you start a TCP connection with a 300 way handshake C synac A the client or active open penerapan a Syn synchronization message to a program list for connection requests. When this node receives a sin, it responds with a sinac, synchronizing and acknowledging the original synchronization. The active opener on receiving the CAC responds with an Acker and A the state diagram here describes how TCP behaves on both sides of the TCP. 
在我们打开连接之前，请回忆一下，您使用300次握手C同步a启动TCP连接，客户端或活动打开penerapa将Syn同步消息发送到程序列表以获取连接请求。当该节点收到sin时，它会以sinac响应，同步并确认原始同步。接收到CAC时，活动的开启者用一个Acker响应，这里的状态图描述了TCP在TCP两侧的行为。

发言人   05:54
Three way handshake. A passive opener is a listener, is a server. It listens for a request for connections from active openers clients. So in a program calls listen, the socket transition from the orange closed state to the yellow listen state. The protocol takes no actions. When this happens, it doesn't send any messages if the server calls close on the socket when it's in the listen state, it transitions immediately to the closed state. 
三次握手。被动的开场白是一个监听器，是一个服务器。它侦听来自活动openers客户端的连接请求。因此，在程序调用listen时，套接字从橙色关闭状态转换到黄色监听状态。该协议不采取任何行动。发生这种情况时，如果服务器在监听状态下在套接字上调用close，它不会发送任何消息，它会立即转换为关闭状态。

发言人   06:25
Let's walk through the 300 way handshake, starting with a first step. When a client tries to open a connection and sends a Syn pack to the server, we can see that this first transition for the Klein side of the connection is this orange arrow from closed to the sin sense state. This happens when the client program calls connect the event. And the client sends a send message. 
让我们从第一步开始，走过300次握手。当客户端尝试打开连接并向服务器发送同步包时，我们可以看到连接的Klein端的第一个转换是从关闭状态到sin感知状态的橙色箭头。当客户端程序调用connect事件时，会发生这种情况。并且客户端发送一条发送消息。

发言人   06:55
Once the first sin is sent, the client is in the sin sent state, and the server is in a listen state. When the syn arrives at the server, this leads to this blue transition. You can see the event is receiving a send message. The action is to send a send a message in response. Now the server is in the send received state. Let's jump back to the client. Remember it was in the sin sense state. Now when it receives the synapse, the server, it transitions to the established state. Its action is to send an A message, the third message of the sin CAC, a handshake. Now the client can start sending data to the server. 
一旦第一个sin被发送，客户端就处于sin已发送状态，而服务器则处于listen状态。当同步到达服务器时，这导致了这个蓝色转变。您可以看到事件正在接收发送消息。操作是发送一条消息作为响应。现在服务器处于发送接收状态。让我们回到客户端。记住，它处于罪恶感知状态。现在当它接收到突触 (服务器) 时，它会转换到已建立的状态。它的动作是发送一条消息，sin CAC的第三条消息是握手。现在客户端可以开始向服务器发送数据了。

发言人   07:41
Finally, let's go back to the server, which is in the sin receive state. When receives the app from the client, it transitions to the established state and it can send data. 
最后，让我们回到服务器，它处于sin接收状态。当接收到客户端的应用程序时，它会转换到已建立的状态，并且可以发送数据。