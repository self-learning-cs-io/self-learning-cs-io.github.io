---
title: 计算机网络 022 FSM Example
date: 2025-10-19 10:00:21
---


发言人   00:00
The answer to the second question is closed. We start in the closed state, and the user program calls connect, and we transition to the sin sense state. While in the Sinn state, the user program calls close. There's an edge from Sinn on the close event back to the close date. So now our sockets are in the established state. They're exchanging data. 
第二个问题的答案已经结束。我们从关闭状态开始，用户程序调用connect，然后转换到sin感知状态。在Sinn状态下，用户程序调用close。从结束活动的Sinn到结束日期有一个优势。所以现在我们的套接字处于建立状态。他们正在交换数据。

发言人   00:25
The six states in blue boxes are how TCP tears down a connection or how it closes it. It's sometimes useful to talk about tearing down a connection because the word close means something in terms of system calls. A connection exists after one side closes it. As we'll see, there's symmetry between how TCP sets up a connection and how it tears it down, Where connection establishment uses synchronization or Syn packets, connection pterodon uses finish or fin packets. 
蓝色框中的六个州是TCP如何断开连接或如何关闭连接。有时候谈论断开连接是有用的，因为关闭这个词在系统调用方面意味着什么。连接在一侧关闭后就存在了。正如我们将看到的，TCP如何建立连接和它如何分解连接之间存在对称性，其中连接建立使用同步或同步数据包，连接pterodon使用完成或fin数据包。

发言人   00:55
If one of the sides of the connection calls close versus along the right edge on the left to the thin weight one state, this caused it to send a thin packet to the other side of the connection. This is called the active closer because it starts the operation. The other side receives the fin and takes the blue edge on the right to the close weight state. It remains in this state until the program on site calls close, at which point it sends AF, here's where. 
如果连接的一侧调用close而不是沿着左侧的右边缘调用瘦重一状态，这将导致它向连接的另一侧发送瘦数据包。这被称为主动接近，因为它开始操作。另一侧接收鳍，并将右侧的蓝色边缘带到接近重量状态。它一直保持这种状态，直到站点上的程序关闭，此时它会发送AF，这是在哪里。

发言人   01:24
It gets a little complicated. A TCP connection is bidirectional. The active closer has closed its direction of the connection, so it can't write any more data. But it could be the passive closer has more data to send, so the passive closer can continue to send data which the active closer it receives and acknowledges, or could close its side of the connection to, or it could even have decided to close that connection at the same time such that we have two fin packets crossing each other in the network from the fin weight one state where the active closer is, there are three possible outcomes. 
它变得有点复杂。一个TCP连接是双向的。活动的接近器已经关闭了它的连接方向，因此它无法再写入任何数据。但是可能是被动的更近器有更多的数据要发送，因此被动更近器可以继续发送主动更近器接收和确认的数据，或者可以关闭其连接的一侧，或者它甚至可以决定同时关闭该连接，使得我们在网络中有两个fin数据包相互交叉，从fin权重的一个状态开始，其中主动接近的状态，有三种可能的结果。

发言人   02:01
First, the passive closer might acknowledge the fin, but not send a fin. In this case, the passive closure is in the closed weight state and can continue to send data. This is the lowermost edge where the active closure enters the fin weight 2 state. Second, the passive closer might close its side too, acknowledging the fin and sending a fin of its own. This is the middle edge to the time weight state. 
首先，被动接近可能会确认鳍，但不会发送鳍。在这种情况下，被动关闭处于关闭权重状态，可以继续发送数据。这是主动闭合进入翅片重量2状态的最低边缘。其次，被动更近器可能也会关闭其一侧，确认鳍并发送自己的鳍。这是时间权重状态的中间边缘。

发言人   02:29
Finally, it could be that both sides actively close at almost the same time and send fins to each other. In this case, both are in the thin weight one state. Each one will see a fin from the other side that doesn't act its own fin. In this case, we transition to the closing state and when R fin is acknowledged, we transition to the time weight state. Just as with the middle age TCP transitions from thin weight 2 to time weight. When we receive a fin from the other side, it then stays in the time weight for a period of time until it can safely transition to close the final blue edge from last act to close occurs when the passive closer's fin is acknowledged. 
最后，可能是双方几乎同时主动靠近并互相发送鳍。在这种情况下，两者都处于瘦重一种状态。每个人都会看到另一侧的一个不起作用的鳍。在这种情况下，我们转换到关闭状态，当R fin被确认时，我们转换到时间权重状态。就像中年TCP从瘦重2过渡到时间重一样。当我们从另一侧接收到一个鳍时，它会在时间重量中停留一段时间，直到它可以安全地过渡到关闭状态。当被动闭合器的鳍被确认时，最后一个动作到关闭状态的最后一个蓝边就会发生。

发言人   03:20
Now, on one hand, that's a lot of detail. There are 12 states covering lots of cases, But I hope you can see how this finite state machine makes what was previously a few colloquial descriptions, gives them detail and precision, trying to implement a properly interoperating TCP based on those descriptions would be really hard. This diagram precisely specifies how TCP behaves. And so it's tremendously useful. 
现在，一方面，这有很多细节。有12个状态涵盖了许多情况，但我希望你能看到这个有限状态机是如何做出以前一些口语化的描述，给它们提供细节和精度，试图基于这些描述实现正确互操作的TCP真的很困难。这个图精确地指定了TCP的行为。因此它非常有用。
