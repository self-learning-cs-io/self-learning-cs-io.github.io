---
title: 计算机网络 023 Flow Control Stop-and-Wait
date: 2025-10-19 10:00:22
---


发言人   00:01
This video is about flow control, one of the basic building blocks of reliable, efficient communication describes the basics of flow control as well as its simplest implementation, something called a stop and wait protocol. 
这个视频是关于流量控制的，可靠、高效通信的基本积木之一描述了流量控制的基础知识及其最简单的实现，称为停止和等待协议。

发言人   00:14
The basic problem flow control tries to solve is when a sender can send data faster than the receiver can process it. So here we have a case where the sender A can send some 500000 packets per second, but the receiver B can only receive 200000 packets per second. This might be because B has a slower processor, its networking card isn't as good or for whatever reason, and so the issue is that if A sends data at this full rate of 500000 packets per second, then 300000 of those are going to have to be dropped at B, that is B will not be able to process them. So only 40% of the packets will come through, and there's a lot of wasted effort on Aces part. So there a lot of wasted effort in the network, and it's also going to completely saturate B, there's no reason for A to be sending data faster than the rate at which B can receive it. And so the basic approach the flow control takes is to make it that the sender doesn't send packets faster than the receiver can process them. The way this usually works is the receiver gives the sender some kind of feedback, whether it's implicit feedback or explicit, whether it's to slow down or speed up or to set a rate. 
流量控制试图解决的基本问题是，当发送方发送数据的速度比接收方处理数据的速度快时。所以这里有一种情况，发送方a每秒可以发送大约500000个数据包，但接收方B每秒只能接收200000个数据包。这可能是因为B的处理器速度较慢，它的网卡不够好或者出于任何原因，因此问题是，如果a以每秒500000个数据包的全速发送数据，那么B将不得不丢弃300000个数据包。也就是说，B将无法处理它们。因此只有40% 的数据包会通过，并且在a部分浪费了很多精力。因此，网络中浪费了很多精力，而且它也将完全饱和B，没有理由让a发送数据的速度超过B可以接收数据的速度。因此，流量控制采取的基本方法是确保发送方发送数据包的速度不超过接收方处理数据包的速度。通常的工作方式是接收者给发送者某种反馈，无论是隐式反馈还是显式反馈，无论是减速还是加速，还是设置速率。

发言人   01:26
So two basic approaches used in most protocols today. The first stop and wait talk about in this video, which is very simple, very simple implement, very simple financing machine. The second is what's called sliding window. So to talk about in a later video, which is a bit more complex, but can provide better performance. 
所以目前大多数协议中使用的两种基本方法。在这个视频中第一站并等待讨论，这是非常简单的工具，非常简单的融资机器。第二个就是所谓的滑动窗口。所以在稍后的视频中讨论，这个视频稍微复杂一些，但可以提供更好的性能。

发言人   01:44
So just a refresher on finite state machine diagrams. So when we draw a finite state machine of a protocol, we show the states that it can enter here, state one, state two, state three, and then edges between the states have two pieces of information. First, the event that can cause a state transition on top and then below the action the protocol takes on making that state transition. 
所以只是对有限状态机图的复习。因此，当我们绘制一个协议的有限状态机时，我们会显示它可以在此处进入的状态，状态一，状态二，状态三，然后状态之间的边有两条信息。首先，可能导致状态转换的事件在其顶部，然后在协议进行状态转换时所采取的操作下方。

发言人   02:07
A stop point algorithm is very simple. It has at most one packet in flight at any time from the sender to the receiver. So the basic algorithm is a sender sends one packet, it then waits for an Ackman from the receiver When it receives the acknowledgement, it then, if it has more data, that sends another packet. If it waits for some time and reaches a timeout and hasn't heard an Ackman, then it assumes that the packet has been lost, it has left the network, it was dropped on a router, or it was dropped to the receiver, something happened and where the acknowledg dropped, and it resends the data. So there's a timeout, which point it tries again. 
停止点算法非常简单。它在任何时候从发送方到接收方最多有一个数据包在飞行。基本算法是，发送方发送一个数据包，然后在收到确认时等待接收方的Ackman通知，如果有更多的数据，则发送另一个数据包。如果它等待一段时间并达到超时并且没有听到Ackman，则它会认为数据包已经丢失，它已经离开网络，它被丢弃在路由器上，或者它被丢弃到接收方，发生了一些事情并且确认丢弃了。它会重新发送数据。所以有一个超时，它会再次尝试。


发言人   02:47
That's the basic algorithm. So the receiver has a one state, finite state machine, which is wait for packets when it receives new data, it sends an a.n.r. or receives data, it sends an acknowledgement for that data, and if the data is new, it delivers that data to the application. 
这就是基本算法。所以接收方有一个状态有限的状态机，当它收到新数据时等待数据包，它发送一个a.n.r。 或者接收数据，它发送对该数据的确认，如果数据是新的，则将该数据传递给应用程序。



发言人   03:07
The center finite state machine has two states. The first state, it's waiting for data from the applications. This is where it's ready to send, but the data, the application is not yet provided the data to send when the application calls send the protocol sends a packet with that data or as much as it can fit in a packet, it then enters the wait for XX state. 
中心有限状态机有两个状态。第一个状态，它正在等待应用程序的数据。这是它准备发送的地方，但是当应用程序调用发送协议发送包含该数据的数据包或尽可能多的数据包时，应用程序尚未提供要发送的数据，然后进入等待XX状态。

发言人   03:29
In this state, there are two transitions. The first is if it receives an ackn, if the protocol receives an acknowledgement, then it does nothing goes back to wait for data. If there's more data to send, it'll send new data, or if there's no more data sent, it'll wait until the software calls, send the second transition is when there's a timeout. So this is a case where it is sent a packet of data, but it hasn't received the acknowledgement. It's waiting, and it's waiting, and it's waiting, and it times out, and it just tries resending. So it wants to pick this time out that it's conservative, it's pretty sure that the data or the subsequent acknowledgement has been lost. 
在这种状态下，有两个转换。第一种情况是，如果它收到ackn，如果协议收到确认，那么它什么也不做来等待数据。如果有更多的数据要发送，它将发送新数据，或者如果没有更多的数据发送，它将等到软件调用，发送第二个转换是超时。所以这是一个发送了一个数据包，但它没有收到确认的情况。它在等待，它在等待，它在等待，它超时了，它只是尝试重新发送。所以它想指出这个时候它是保守的，很确定数据或随后的确认已经丢失。

发言人   04:02
So it only has one packet in the network at any time. So that's the basic stop and weight algorithm. So here are four sample executions. The first is when there's no loss, everything works perfectly, the sender sends its data, the receiver receives it sends acknowledgement, and now the sender, if it had more data, it could send more, second case data is lost. Now the sender sends data, it's lost in the network, and so the sender times out and tries resending the data. So it's sitting in that, waiting for a state, the timeout hits, and it resends. 
因此，它在任何时候都只有一个数据包在网络中。所以这就是基本的止损和权重算法。所以这里有四个示例执行。第一种情况是当没有损失时，一切正常，发送方发送数据，接收方收到确认，现在发送方如果有更多数据，可以发送更多数据，第二种情况数据丢失。现在发送方发送数据，但数据在网络中丢失了，因此发送方超时并尝试重新发送数据。所以它坐在那里，等待一个状态，超时到达，然后重新发送。


发言人   04:39
Here's a third case where the data is successfully delivered, but the acknow is lost. And so now the sender is in the way for a state. It times out, it resends the data, and then this causes the receiver to send a new acknowledgement, at which point then the sender gets the Ackman and continues as in the first case. 
这是第三种情况，数据成功传递，但accut丢失了。所以现在发送者妨碍了一个国家。超时后，它会重新发送数据，然后这会导致接收方发送新的确认，此时发送方会收到Ackman并继续执行，就像第一种情况一样。

发言人   05:01
So the fourth case is a little more complicated and actually shows a failure with the basic algorithm, as I described before, which is the sender sends some data and the receiver sends an acknowledgement. But let's say something happens in the network. Suddenly a link becomes very slow, or there's a big queue somewhere in the network, and the acknowledgement is delayed past the time of the timeout. And so the sender sends some data and Ackman comes, but the sender resends the data before the Ackman arrives. The acknowledgement then arrives very shortly. 
因此，第四种情况稍微复杂一些，实际上显示了基本算法的失败，正如我之前所描述的，即发送方发送一些数据而接收方发送一个确认。但是假设网络中发生了一些事情。突然，一个链接变得非常慢，或者网络中某个地方有一个大队列，确认被延迟超过超时时间。因此，发送方发送了一些数据，然后Ackman来了，但发送方在Ackman到达之前重新发送了数据。然后确认很快就到了。

发言人   05:37
And so now the sender knows that the data was acknowledged, it sends another data packet. But let's say that in fact, this data packet is lost. So now this retransmission, this first retransmission of the first data packet, arrives at the receiver. The receiver acknowledges it. 
因此，现在发送方知道数据已被确认，它会发送另一个数据包。但假设事实上，这个数据包丢失了。所以现在这个重传，第一个数据包的第一次重传，到达接收方。接收者确认了。

发言人   05:57
The center doesn't know whether this acknowledgement here, this act, is for the retransmission here of the data, or it's for the new data packet. And so here we can have an error where if it assumes it was for the retransmission of the old data, it something has to keep track of that something, the finite state machines to keep track of. If it assumes it's for the new data, it might, that data might not have arrived. It could be assuming that data has arrived, which hasn't. So this is a basic problem that comes up in any reliable protocol that comes up in flow control, which is how do you detect duplicates? 
中心不知道这里的确认行为是用于数据的重传，还是用于新的数据包。因此，在这里我们可能会遇到一个错误，如果它假设它是用于重新传输旧数据，它必须跟踪那个东西，有限状态机来跟踪。如果它假设这是为了新数据，那么数据可能还没有到达。它可能是假设数据已经到达，而数据并没有到达。所以这是一个基本问题，在流量控制中出现的任何可靠协议中都会出现，那就是如何检测重复项？

发言人   06:37
How do you know when acknowl are from retransmissions or duplicated copies of packets versus new data? And so in the case of stop and wait, we can solve this problem with a 1 b counter. And so the idea is that use this 1 b counter on all data acknowledgement and acknowledgement packet. So a sender sends data 0, then it receives a 0 data one, act 1 data 0, act 0. And so now the receiver can tell if this is new data or a duplicate. And so in that prior case, I showed you would be able to distinguish between the acket for the retransmission of packet 0 and an acket for the first transmission of packet one. 
你怎么知道acknow是来自重传或重复的数据包副本还是新数据？因此，在停止和等待的情况下，我们可以使用1 b计数器解决这个问题。因此，这个想法是在所有数据确认和确认数据包上使用这个1 b计数器。因此，发送方发送数据0，然后接收0数据1，操作1数据0，操作0。因此，现在接收方可以判断这是新数据还是重复数据。因此，在先前的情况下，我向您展示了能够区分用于重传数据包0的数据包和用于第一次传输数据包1的数据包。

发言人   07:15
Now, a single bit counter makes a couple of simplifying assumptions. This doesn't work all the time. Like, what if a packet is delayed for many round trip times? It could be, for example, that this data 0 is delayed all the way to here, and then the receiver acts it, but it turns out it's actually just a copy of oldt data. And so this particular 1 b counter approach makes two simplifying assumptions. First, the network isn't duplicating packets itself. Second, the packets are not being delayed for multiple timeouts. Now, you can solve these problems by increasing the sequence number space, but for the simplifying assumptions to the simple protocol operating environment, this 1 b counter can help a lot. 
现在，一个单比特计数器做了几个简化的假设。这并不是一直都有效。比如，如果一个数据包延迟了多次往返怎么办？例如，可能这个数据0一直延迟到这里，然后接收方发出动作，但事实证明它实际上只是oldt数据的副本。因此，这种特定的1 b计数器方法提出了两个简化假设。首先，网络本身并没有复制数据包。第二，数据包不会因为多次超时而延迟。现在，您可以通过增加序列号空间来解决这些问题，但对于简单协议经营环境的简化假设，这个1 b计数器可以提供很大的帮助。