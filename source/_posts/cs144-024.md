---
title: 计算机网络 024 Flow Control Sliding Window
date: 2025-10-19 10:00:23
---

发言人   00:00
This video I'm going to talk about a slightly advanced flow control algorithm called sliding window used in most high performance protocols today. So recall a simple, a simple flow control algorithm called stop and wait has at most one packet in flight at any time. So this is the basic simple protocol, You might say algorithm might try to implement the first time you're doing reliable communication. So sender sends a packet or a chunk of data, the receiver sends an acknowledgement. The sender, if it doesn't receive the Ack and times out, tries resending. If it gets the acknowledgement, it sends more data, and there's some issues with duplicate, so you can maintain a counter, a 1 b counter to figure out if there's a duplicate act or an active duplicate or new data, as long as things aren't duplicated for more than around trip time stopping way it works, it's great. It's simpler. So while stop and wait works correctly, it has one major problem. 
在这个视频中，我将谈论一种稍微先进的流量控制算法，称为滑动窗口，目前在大多数高性能协议中使用。回想一下，一个简单的、称为停止并等待的流量控制算法，在任何时候最多有一个数据包在飞行。所以这是基本的简单协议，你可能会说算法可能会在你第一次进行可靠通信时尝试实现。所以发送方发送一个数据包或一块数据，接收方发送一个确认。发送者如果没有收到Ack并且超时，会尝试重新发送。如果它获得确认，它会发送更多的数据，并且存在一些重复问题，因此您可以维护一个计数器，一个1 b计数器，以确定是否有重复行为、活动重复或新数据，只要事情没有重复超过旅行时间，它就会停止工作，这很棒。这更简单。因此，虽然停止和等待正常工作，但它有一个主要问题。


发言人   00:54
Let's say you're trying to communicate between Boston and San Francisco, and the bottleneck is say 10 Mb per second. So there's a 10 mbps link here. Or let's say the Boston node can receive at 10 Mb per second. That's the rate at which you can process data in round trip times is 50 milliseconds. And let's just say for simplicity's sake, we're sending ethernet frames, so that's the size of the data, so which are basically 1.5 kB, 12 kb. Now around trip times, 50 milliseconds. That means that San Francisco can send 1 packet 50. And if that packets received successfully, 50 milliseconds later, it'll get an acknowledgement. 
假设您尝试在波士顿和旧金山之间进行通信，瓶颈是每秒10 MB。所以这里有一个10 mbps的链接。或者假设波士顿节点可以每秒接收10 Mb。在往返时间内处理数据的速率是50毫秒。为了简单起见，我们假设发送的是以太网帧，这就是数据的大小，基本上是1.5 kB、12 kb。现在大约旅行时间，50毫秒。这意味着旧金山可以发送1个分组50。如果该数据包成功接收，50毫秒后，它将获得确认。

发言人   01:37
So we have 1000 milliseconds per seconds divided by 50 milliseconds. This means that we can send at most 20 packets per second on this pop, now 20 packets per second times 12 kb kilobits per packet is equal to 240 kb kilobits per second. 
所以我们有每秒1000毫秒除以50毫秒。这意味着我们在这个流行音乐上每秒最多可以发送20个数据包，现在每秒20个数据包，每个数据包12 kb千比特等于每秒240 kb千比特。

发言人   02:05
So this path between San Francisco and Boston using a stopping weight protocol can send at most 240 kb per second, assuming no packets are lost, just constant RTT 50 milliseconds, but the bottleneck is 10 Mb per second. This means that this stopping wave protocol is using 2% of the capacity of what the communication can be to stop and wait while it works can be astoundingly inefficient. 
因此，使用停止权重协议的旧金山和波士顿之间的这条路径每秒最多可以发送240 kb，假设没有数据包丢失，只需恒定的RTT 50毫秒，但瓶颈是每秒10 Mb。这意味着这个停止波协议使用了通信容量的2% 来停止和等待工作，效率极低。

发言人   02:36
San Francisco could be sending data much faster than what stopping late allows. So the basic solution that most protocols use today for this problem is something called a sliding window. And sliding windows are a generalization of stop and weights, where a stop and wait allows one packet in flight at any time. 
旧金山发送数据的速度可能比延迟停止所允许的速度要快得多。因此，目前大多数协议用于解决此问题的基本解决方案是所谓的滑动窗口。和滑动窗口是停止和重量的概括，停止和等待允许任何时候一个数据包在飞行中。


发言人   02:55
Sliding window protocol allows up to N packets in flight. So when n equals to 1, a sliding window protocol behaves like stop and wait. And so let's say we have a sliding window protocol with an n equal to, say, five packets. This means that San Francisco can have five packets. In flight and simultaneously, there can be 5 acknowled. Maybe me 5 aowd GS coming back from Boston. And the idea here is that if you adapt, if you can set n to be the correct value, then you can keep the pipeful. 
滑动窗口协议允许最多N个数据包在传输中。因此，当n等于1时，滑动窗口协议的行为类似于停止和等待。因此，假设我们有一个滑动窗口协议，其中n等于五个数据包。这意味着旧金山可以有五个数据包。在飞行中同时，可以有5个被承认。也许我5 aowd GS从波士顿回来。这里的想法是，如果你能适应，如果你能将n设置为正确的值，那么你可以保持管道。

发言人   03:39
That is, San Francisco could send data to Boston at 10 Mb per second. So let's say that's Boston's rate. And so Boston can, by configuring the sliding window size, can have San Francisco send data at a rate equal to 10 Mb per second. 
也就是说，旧金山可以以每秒10 Mb的速度向波士顿发送数据。让我们假设这是波士顿的费率。因此，通过配置滑动窗口大小，波士顿可以让旧金山以每秒10 Mb的速率发送数据。

发言人   03:57
And so in this particular case, right, if we have an RTT of 50 milliseconds and a bottleneck of 10 Mb per second, let's say that we're sending ethernet frames, right, 10 kb per packet, and we have 20 round trip times. That essentially means that the sliding window is going to be 10 Mb per second. Divided by 20 round trip times, basically, which is equal to 500 kb per round trip time. So we're looking at a sliding window of around 49, sorry, around 41 packets. 40 is 480 kb per on trip time. So 41, it'll be 492. And so if we had a sliding window of 40 packets, then we would actually be able to sustain a 10 Mb connection from San Francisco, go to Boston with a round trip time of 50 milliseconds. 
因此，在这种特定情况下，如果我们的RTT为50毫秒，瓶颈为10 MB每秒，假设我们正在发送以太网帧，对吧，每个数据包10 kb，并且我们有20个往返时间。这基本上意味着滑动窗口将为每秒10 Mb。除以20个往返时间，基本上等于每个往返时间500 kb。所以我们正在看一个大约49个包的滑动窗口，抱歉，大约41个包。40是480 kb/次旅行时间。所以41，这将是492。因此，如果我们有一个40个数据包的滑动窗口，那么我们实际上能够维持从旧金山到波士顿的10 Mb连接，往返时间为50毫秒。

发言人   05:04
So just to draw a picture, kind of show what this looks like. So here is the original. Here's the stop and weight. We have this 1 b counter data, 0x 0 data, 1x 1 data, 0x 0, so the sliding window, let's say we have a sliding window of size 3. Well, the sender will send three packets. Let's call them d 0, D1, D2. And the receiver can then acknowledge them. Act 0, act 1, act 2. Well, as soon as acknowledgement zero arrives, the sender can send data 3. As soon as acknowledging one arrives, the sender can send data. For as soon as acknowledgment two arrives, the sender can send data 5. 
所以只是为了画一幅画，展示它的样子。这就是原文。这是停止和重量。我们有这个1 b计数器数据，0 x0数据，1 x1数据，0 x0，所以滑动窗口，假设我们有一个大小为3的滑动窗口。那么，发送者将发送三个数据包。让我们称它们为d 0，D1，d2。然后接收者可以确认它们。第0幕，第1幕，第2幕。一旦确认零到达，发送方就可以发送数据3。一旦确认一个到达，发送者就可以发送数据。因为一旦确认2到，发送方就可以发送数据5。


发言人   05:52
This is the basic idea. Rather than having this one packet, you could have many packets. So in the case of having a seing window of size 40, you can imagine there are tons and tons and tons of packets in flight. So let's look at more concretely what this algorithm looks like for both the sender and the receiver, just as we did for stop and wait. 
这是基本的想法。与其有这个数据包，你可以有多个数据包。因此，在尺寸为40的窗户的情况下，你可以想象有大量的包裹在飞行中。所以让我们更具体地看看这个算法对于发送者和接收者都是什么样子，就像我们为停止和等待所做的一样。


发言人   06:11
So a sliding windows sender first, in a sliding window protocol, every segment has a sequence number. So in protocols like TCP, this is usually done in terms of bytes because they can be variable size. For simplicity's sake, we'll just do it in terms of packet numbers. So there's a sequence number for every segment, so the sender maintains three variables, the size of its sending window, the last acknowledgement it received from the receiver, and the last segment it sent. And the sender's job is to maintain this invariant that the last segment sent minus the last acknowledgement received, has to be less than or equal to the send window size. So this means that if it has received packet n, a packet with a sequence number of at n, the sender can not send packet past n plus Sws. 
因此，滑动窗口发送者首先，在滑动窗口协议中，每个段都有一个序列号。因此，在像TCP这样的协议中，这通常以字节为单位完成，因为它们的大小可以是可变的。为了简单起见，我们只根据数据包编号来处理。因此，每个段都有一个序列号，因此发送方维护三个变量，即其发送窗口的大小、从接收方收到的最后一次确认以及它发送的最后一段。而发送方的工作是保持这种不变性，即最后发送的数据段减去最后收到的确认后，必须小于或等于发送窗口大小。所以这意味着如果它收到了数据包n，序列号为n的数据包，则发送者无法通过n加Sws发送数据包。

发言人   07:07
So let's say we have a sending window is equal to 5. And the last Ackman that's been received is equal to 11. Then this means that the sender can not send a packet past 12, 1314, 1516. It's not allowed to send 17 until it gets 8 dollars for 12. 
那么假设我们有一个发送窗口等于5。并且收到的最后一个Ackman等于11。那么这意味着发送方不能发送超过12、1314、1516的数据包。在收到12美元的8美元之前，不允许发送17。

发言人   07:29
When you get a new acknowledgement, you advance La as necessary and you buffer up to sending window size segments in case suddenly you get an acknowledgement. And then you want to send a whole bunch of new data. 
当您收到新的确认时，您可以根据需要前进，并缓冲发送窗口大小段，以防突然收到确认。然后你想要发送一大堆新数据。

发言人   07:42
Let's pretend for a second we have a sending window size equal to 3. And so here's packet. So 0, 1, 2, 3, say zero had been sent and acknowledged, so our sending window size is 3. The last acknowledgement for the receiver is 0. So Ler is equal to 0, Sws is equal to 3. This just means that the last segment sent is equal to 3. So now when an acknowledging arrives, say for one, then the sending window can advance, and so now the protocol can send four, and let's say an ad group for four arrives, then the window can advance and it can send 5, 6, and 7. 
让我们假设我们有一个等于3的发送窗口大小。这是包裹。所以0，1，2，3，表示没有发送和确认，因此我们的发送窗口大小为3。接收者的最后确认是0。所以Ler等于0，Sws等于3。这仅仅意味着发送的最后一个段等于3。所以现在当一个确认到达时，比如说一个，然后发送窗口可以前进，所以现在协议可以发送四个，假设一个四个的广告组到达，然后窗口可以前进，它可以发送5、6和7。

发言人   08:31
Now, one thing that's important here is that let's say we have a sun window, which includes 5, 6, and 7, and 5 is lost, but 6 and 7 arrive at the receiver and are acknowledged. The sender can not advance the window past 5 until 5 is acknowledged. And so the windows, what's called stalling the window, can stall where although most of the data in the window has been delivered, it can't move past the first unacknowledged piece of data. So it can't advance the window past. 
现在，这里有一件重要的事情，假设我们有一个太阳窗，包括5、6和7，并且5丢失了，但6和7到达接收器并得到确认。发送者不能将窗口前进到5后，直到确认5为止。因此，这些窗口被称为窗口停滞，可以停滞在窗口中，尽管窗口中的大部分数据已经传递，但它无法移动超过第一个未确认的数据块。所以它不能把窗户推进过去。

发言人   09:01
The receiver also maintains three variables. It has received window size, the last acceptable segment. So this is the last segment that it will receive, won't drop on the floor. If it receives a segment pass this value, it'll assume something is wrong or it was not going to buffer, and it'll just discard it. Then there's the last segment it's actually received. And so the sender, the receiver, is then maintaining this invariant that the last acceptable segment minus the last segment would receive must be less than or equal to the receive window size. And so if you have received window size is equal to 5, and a last segment received equal to 3, then it's not going to excite anything past 4, 5, 6, 7, 8. So if it receives suddenly segment 10, it won't accept it, and it will drop it. 
接收者还维护三个变量。它已收到窗口大小，即最后一个可接受的段。所以这是它将接收的最后一个段，不会掉在地板上。如果它接收到一个传递此值的段，它将认为某些事情是错误的或者它不会缓冲，它将丢弃它。然后是它实际接收到的最后一个片段。因此，发送者，接收者，将保持这种不变性，即最后一个可接受的段减去最后一个段将接收必须小于或等于接收窗口大小。因此，如果您收到的窗口大小等于5，并且收到的最后一个段等于3，那么它不会在4、5、6、7、8之后激发任何东西。因此，如果它突然收到第10段，它将不接受它，并将丢弃它。


发言人   09:53
Now if the received packet is less than this acceptable segment, then we'll send an acknowledgement. And so if it receives any of these packets, it will send an aowei. 
现在，如果接收到的数据包小于这个可接受的段，那么我们将发送确认。因此，如果它收到任何这些数据包，它将发送一个aowei。

发言人   10:07
Now, in the basic case, the way most sliding window protocols work, these ads are what are called cumulative ads, such that you send an acknowledgement for not the data you received, but rather what is the end of the contiguous data that you receive that is cumulative? If I acknowledge three, that means that I have received three and everything before it, not just three. And so it represents a cumulative state of reception across the entire communication. So in this example, if a receiver receive 1, 2, 3, and 5, and then suddenly receives 5, it doesn't acknowledge 5, it acknowledges three. Now, there are some protocols that can do things like actually selective ANDSA, but the basic case is that use cumulative acknowledgments, which is cumulatively what is the contiguous chunk of data that you've received. 
现在，在基本情况下，大多数滑动窗口协议的工作方式，这些广告被称为累积广告，这样你发送的确认不是你收到的数据，而是你收到的连续数据的结束是累积的？如果我承认三个，这意味着我已经收到了三个和之前的所有东西，而不仅仅是三个。因此它代表了整个通信接收的累积状态。因此，在这个例子中，如果接收方收到1、2、3和5，然后突然收到5，它不确认5，确认3。现在，有一些协议可以做一些事情，比如实际选择性和sa，但基本情况是使用累积确认，即累积您收到的连续数据块。

发言人   11:05
So one little detail here. TCP doesn't take knowledge the data it's received, but rather n plus 1. So TCP ackleton are in terms of bytes. And so if TCP is received up to byte n, it's acknowledged in packets. We'll say n plus 1. So it's the first byte of data that's expected. So if you're looking at a TCP trace or trying to see how the TCP protocol works, just keep this in mind. The acknowledgement value in the TCP header isn't the last byte receive the cumulative acknow rather than next byte, the first missing byte. 
所以这里有一个小细节。TCP不会获取接收到的数据，而是使用n加1。所以TCP的ackleton是以字节为单位的。因此，如果TCP被接收到字节n，它将在数据包中得到确认。我们会说n加1。所以这是预期的数据的第一个字节。因此，如果您正在查看TCP跟踪或试图了解TCP协议的工作原理，请记住这一点。TCP标头中的确认值不是接收累积accnget的最后一个字节，而是下一个字节，即第一个缺失的字节。

发言人   11:41
So one of the things we talked about in stop and wave, the stop and wave protocol is that a counter of p.s., a 1 b counter was sufficient assuming the packets weren't delayed more than a round trip time. 
因此，我们在stop and wave协议中讨论的一件事是，假设数据包的延迟不超过往返时间，则使用p.s. 的计数器1 b计数器就足够了。


发言人   11:52
So what about in sliding window protocol? Suddenly of a receive window, we have a send window. How big a sequence number space do we need? The C window is always greater than one. The send window is always greater than one, greater than equal to one, and their C window is greater than is less than or equal to the send window. This is because if the receive window is ever greater than the send window, it's a waste. The sender would never have those packets in flight, and so there's this extra buffer space which will never be used. 
那么在滑动窗口协议中呢？突然有一个接收窗口，我们有一个发送窗口。我们需要多大的序列号空间？C窗口总是大于一。发送窗口始终大于一，大于等于一，并且它们的C窗口大于小于或等于发送窗口。这是因为如果接收窗口大于发送窗口，那就是浪费。发送方永远不会有那些数据包在传输中，因此有这个额外的缓冲空间永远不会被使用。

发言人   12:22
However, there are cases where the receive window can be smaller than the send window, and the protocol still works. So here's one interesting basic case of that called go back, and let's say a receive window of size 1 and ascending window that's larger than larger than one. Well, in this case, we're going to need sending window size plus 1 sequence numbers. So what does this protocol look like? 
但是，在某些情况下，接收窗口可能比发送窗口小，协议仍然可以工作。这里有一个有趣的基本情况，称为返回，假设接收窗口大小为1，升序窗口大于1。在这种情况下，我们需要发送窗口大小加1个序列号。那么这个协议是什么样子的呢？

发言人   12:43
Well, the sender say, says send window size, it's equal to 3. So the sender sends 0, 1, and 2. And let's say those are all acknowledged, and so the receiver acknowledges zero and acknowledges one and acknowledges two, but when it acknowledges zero, the sender is going to send 3, slide the window to 4. When it acknowledges one, it's going send four. And when it acknowledges two, it's going to send 5. So now let's say that three is dropped. Now the sender, the receiver is going to still receive 4 and 5, and so it can act 2, it's going to send act 2, act 2. The sender is going to time out and rescind 3. So this is called a go back end protocol. 
嗯，发送者说，发送窗口大小等于3。所以发送方发送了0、1和2。假设这些都被确认，接收方确认零，确认一，确认二，但当它确认零时，发送方将发送3，将窗口滑动到4。当它确认一个时，它会发送四个。当它确认为2时，它将发送5。所以现在让我们假设三个被删除了。现在发送者，接收者仍然会接收4和5，因此它可以执行第二个动作，它将发送第二个动作，第二个动作。发件人将要超时并撤销3。所以这被称为后端协议。

发言人   13:32
Because the receive window was size 1, the receiver could not buffer 4 or 5. And so when a single packet is lost, in this case 3, the sender has to go back in. It has to retransmit the entire send window worth of packets. It will have to retransmit 3. You'll have to retransmit 4, and you'll have to retransmit 5. In contrast, if the receive window size had been three, then the receiver could have buffered 4 and 5. The sender would only have had to retransmit 3, then you're an act 5, and it could go on and send 6, 7. And so here, in the case of a go back end protocol, you need to send window size plus 1 sequence numbers. 
因为接收窗口的大小是1，所以接收方无法缓冲4或5。因此，当一个数据包丢失时，在这种情况下是3，发件人必须返回。它必须重新传输整个发送窗口中价值的数据包。它将不得不重新传输3。你必须重新传输4个，你必须重新传输5个。相比之下，如果接收窗口的大小是3，那么接收方可以缓冲4和5。发送者只需要重新传输3个，那么你就是第5个，它可以继续发送6、7个。因此，在后端协议的情况下，您需要发送窗口大小加1个序列号。

发言人   14:14
Because you imagine if you have only the same window size, there's 0, 1, 2, And then remember what happened in stop and wait when there's a packet delayed where, hey, let's say that the act for 0 is delayed, there's a timeout, you retransmit 0. Now you can't distinguish whether or not the delayed acknowledgement was for the retransmission or for the old data. 
因为你想象一下，如果你只有相同的窗口大小，有0、1、2，然后记住在停止和等待时发生的事情，当有一个数据包延迟时，嘿，假设0的行为被延迟，有一个超时，你重新传输0。现在，您无法区分延迟的确认是针对重传还是旧数据。

发言人   14:42
Generally speaking, if the two windows are the same size, you need twice basically their sum. And so that's the generalization that you need Rws plus Sws sequence numbers. You need sequence number spaces, least as big as the sum of the window sizes. So that's the basic sliding window algorithm. And the algorithms that the sender and the receiver use and how the sender manages the window. 
一般来说，如果两个窗口的大小相同，则基本上需要其总和的两倍。这就是你需要Rws加上Sws序列号的概括。你需要序列号空间，至少要有窗口大小之和那么大。这就是基本的滑动窗口算法。以及发送方和接收方使用的算法以及发送方如何管理窗口。

发言人   15:06
What does this look like in TCP? So TCP is a sliding window protocol and uses that for flow control, and so here's the TCP header, and so the way TCP works is the receiver specifies a flow control window using the window field, this in terms of bytes. And so it basically says this is the buffer size that I have on the receiver. And so the set of packets that I will accept. And the basic rule is that here, the data sequence number and the acknowledgement sequence number, and so a TCP receiver will only handle data equal to the acknowledged sequence number plus the window. So the sender isn't allowed to send data past a plus window. That's to make sure it doesn't send data, which the receiver is not going to. And so this is a way for the receiver to essentially set what the send window size is. 
这在TCP中看起来像什么？TCP是一个滑动窗口协议，并将其用于流量控制，这里是TCP标头，TCP的工作方式是接收方使用窗口字段指定一个流量控制窗口，以字节为单位。所以它基本上说这是我在接收器上的缓冲区大小。所以我将接受的数据包集。基本规则是，这里有数据序列号和确认序列号，因此TCP接收方只处理等于确认序列号加上窗口的数据。所以发送者不允许发送数据经过加号窗口。这是为了确保它不会发送接收方不会发送的数据。因此，这是接收方基本上设置发送窗口大小的一种方法。


发言人   16:07
So let's walk through an example. So here again I'm going to talk in terms of packets rather than in bytes like in TCP. And here's the sequence number space for the packets from 0 up to 29. So let's say that we have a receive window size equal to 2 and ascend window size I equal to 3. 
那么，让我们举一个例子。所以在这里我将再次谈论数据包，而不是像在TCP中那样以字节为单位。这是从0到29的数据包的序列号空间。所以假设我们有一个接收窗口大小等于2，升窗大小I等于3。

发言人   16:33
So communication begins and the sender is going to send 0, 1, and 2. Let's say all three of those packets arrive. And so the receiver receive 0. It's going to acknowledge zero. It's then going to receive one, acknowledge one, receive two, and acknowledge two. When the sender here's a 0, it'll advance the window, the send window, and it'll send three when it hears the Aow, and for one, it'll advance the window and send for when it here's the acknowledgement. For 2, it'll advance the window and send five. 
因此通信开始，发件人将发送0、1和2。假设这三个数据包全部到达。因此，接收方收到0。它将承认零。然后它将接收一个，确认一个，接收两个，并确认两个。当发送者在这里是0时，它将推进窗口，发送窗口，当它听到Aow时，它将发送三个，对于第一个，它将推进窗口并在这里确认时发送。对于2，它将推进窗口并发送5。

发言人   17:16
Now let's say that packet three arrive successfully and is acknowledged, but packet for is lost in the network. So now we have this case where? Act 3 has been sent, packet 4 is lost. Then packet 5 arrives at the receiver. 
现在，假设数据包三成功到达并得到确认，但数据包在网络中丢失。那么现在我们有了这个案例，在哪里？操作3已发送，数据包4丢失。然后，数据包5到达接收方。

发言人   17:40
Now the receiver is going to send another acknowl 3 again because of cumulative acknow gence. And so now the sender heard act 3, then another. Act 3 waits times out and resends 4, so it'll resend 4, let's say four arrives. Now this receiver can acknowledge for, so it can act for, but because its receive windows of size 2, it actually had 5 buffered, and so it can also acknowledge 5, and so it'll send back 5. So a sliding window flow control algorithm allows an unacknowledged, so a whole window of unacknowledged packets to be in flight. And so this allows is if you can set that window size appropriately, it allows a sender to be able to actually fully utilize the capacity that the receiver has, unlike a stop and wave protocol where you can have at most one packet in flight. 
由于累积的确认结果，接收方将再次发送另一个确认3。所以现在发送者听到了第3幕，然后是另一个。第3行等待超时并重新发送4，因此它将重新发送4，假设4到达。现在这个接收器可以确认，因此它可以代理，但由于它的接收窗口大小为2，它实际上有5个缓冲，因此它也可以确认5，因此它将发送回5。因此，滑动窗口流量控制算法允许未确认的数据包在整个窗口中传输。因此，这允许如果您能够适当地设置窗口大小，它允许发送方能够真正充分利用接收方的容量，不像停止和波浪协议，您最多可以有一个数据包在飞行。

发言人   18:50
When acknow arrive for new data, the sender advances the window. 
当acnow获取新数据时，发送方会向前推进窗口。

发言人   18:54
Generally, sliding window protocols use cumulative acknowledgements and the exact sequence number of space you use depends on the window sizes. So it turns out TCP uses a large sequence number space just for ease of use and to really be robust against heavily delayed packets. But if you're implementing your own protocol, you might be able to get away with something a little bit smaller. 
通常，滑动窗口协议使用累积确认，您使用的空间确切序号取决于窗口大小。所以事实证明，TCP使用大的序列号空间只是为了易于使用，并且对严重延迟的数据包真正具有鲁棒性。但是如果你正在实施自己的协议，你也许能够使用稍微小一点的东西逃脱。
