---
title: 计算机网络 027 TCP Setup and Teardown
date: 2025-10-19 10:00:26
---


发言人   00:00
In this video I'm going to dig into the details of TCP connection setup and teardown. This is a deeper look and sort of the initial service model we presented looking at a couple of edge cases and the entire TCP state diagram. So I'm going to look at three way handshake, something called simultaneous open, which turns out to be really important today in peer to peer applications and actually show the full TCP state machine for connection setup and teardown. 
在这个视频中，我将深入了解TCP连接设置和拆除的细节。这是一个更深入的了解，也是我们提出的初始服务模型的排序，考虑了几个边缘案例和整个TCP状态图。所以我将看一下三次握手，一种被称为同步打开的东西，它在当今的点对点应用中非常重要，实际上展示了用于连接设置和拆除的完整的TCP状态机。

发言人   00:23
So the high level problem here is if we want to communicate reliably, it turns out it's very helpful to have state on one or both ends of the connection. You can, in fact, turn. Turns out you can communicate reliably with having something stateless on one end or the other, but it's much less efficient. Having a little bit of state is great, it'll make you have much better throughput, etc. 
因此，这里的高层次问题是，如果我们想要可靠地通信，那么在连接的一端或两端拥有状态是非常有帮助的。事实上，你可以转身。事实证明，你可以在一端或另一端使用无状态的东西进行可靠地通信，但效率要低得多。有一点状态是很好的，它会让你有更好的吞吐量，等等。

发言人   00:42
But if we have this state, there's this problem of how do we set up that state, what is it? So connection establishment, but then also given the state's going to take up Ram in your machine, when can you tear it down? When is can you garbage collect this state and reuse it? So examples of the memory is using for your T speed connection. The buffers are also the port numbers that you've used. 
但如果我们有这种状态，就会出现如何建立这种状态的问题，它是什么？所以要建立连接，但考虑到国家将在您的机器中占用Ram，您什么时候可以拆除它？什么时候你可以垃圾收集这个状态并重新使用它？因此，内存的示例用于您的T速度连接。缓冲区也是您使用过的端口号。

发言人   01:04
So are these problems of connection establishment and tear down? So here's the standard TCP header with its standard 20 B payload and then options. So for connection setup, as we've seen before, there are four parts of the header that are used, The sequence number, the a.n.t number, the Ack bit, and the sin bit. 
那么这些是连接建立和拆除的问题吗？所以这是标准的TCP报头及其标准的20 b负载，然后是选项。因此，对于连接设置，正如我们之前所看到的，使用的标头有四个部分: 序列号、a.n.t编号、确认位和sin位。



发言人   01:29
So here I'm going to walk through the through a handshake in a little bit more detail as to what happens in the packets that are exchanged. So recall in the standard 3 handshake model, we have an active opener and a passive opener. The passive opener sitting, listening, waiting for connection request, such as say, a web server. The active opener is the one who initiates the request to start the connection. So in the first step, the active opener sends a TCP segment with the sin bit set to indicate that it's synchronizing the passive side to the beginning of its stream. It's saying, what is the first sequence number of my stream? So let's call it s sub a. 
所以在这里，我将更详细地介绍一下握手过程，以了解在交换的数据包中发生了什么。回想一下，在标准的3次握手模型中，我们有一个主动开启者和一个被动开启者。被动的开启者坐下来，倾听，等待连接请求，比如web服务器。主动开启者是发起请求以启动连接的人。因此，在第一步中，主动开启者发送一个设置了sin位的TCP段，以指示它正在将被动端同步到其流的开头。它的意思是，我的流的第一个序列号是什么？那我们就叫它sub a吧。

发言人   02:09
So you do this rather than just say, assume zero for a bunch of reasons. Number one, it's very helpful to randomize your starting sequence. Number for security reasons means that people can guess where your stream starts and try to insert data on you. Also, it's useful if there happen to be old packets flying around the internet, which sometimes happens to give tremendous delay somewhere. If you randomize your starting sequence number, then it becomes very unlikely that some random segment or perhaps a corrupted segment is going to overlap your own sequence window. 
所以你这样做，而不只是说，出于很多原因假设零。第一，随机化你的起始序列非常有帮助。出于安全原因，数字意味着人们可以猜测您的流从哪里开始，并尝试在您身上插入数据。此外，如果碰巧有旧数据包在互联网上飞来飞去，这有时会在某个地方产生巨大的延迟，这将非常有用。如果您将起始序列号随机化，则某些随机段或可能是损坏的段将不太可能与您自己的序列窗口重叠。

发言人   02:42
So the active side sends a sin saying, this is my starting sequence number s sub. The passive side responds also with a sin saying, okay, that I'm going to synchronize you. My starting sequence number is that, say S sub p for passive, but I'm also going to set the a bit, which means that the ANC when sequence number in the packet is valid, and I'm going to act Sa plus 1. 
所以主动端发送一个sin，说这是我的起始序列号sub。被动的一面也会用一种罪恶回应，说: 好的，我要让你同步。我的起始序列号是，例如sub p表示被动，但我也要设置a位，这意味着当数据包中的序列号有效时，ANC将执行Sa加1操作。

发言人   03:07
Recall that a node acknowledges not the last byte received, but rather the first byte that hasn't been received. So by sending a essay plus one, the passive side has acknowledged that it received the sin, which is effectively bite s sub A, the active side then responds it doesn't need to send a send because it's synchronized. So it sends a packet with sequence number sp plus one. That's commonly the what's used, and a s I'm sorry, sends a pack with S a plus 1 and a Sp plus one. And so now it's acknowledging saying I have received your sin. 
回想一下，节点不会确认收到的最后一个字节，而是确认没有收到的第一个字节。因此，通过发送一篇文章加一，被动端已经承认它收到了罪，这实际上是咬sub a，主动端然后响应它不需要发送发送，因为它是同步的。所以它发送序列号为sp加一的数据包。这通常是使用的内容，抱歉，会发送一个带有s加号和Sp加号的包。所以现在它承认说我已经接受了你的罪。

发言人   03:52
And I'm acknowledging that now this initial packet, the sequence number is sass plus one, but it tends to be of 0 length. So if there were a byte in the packet, it would be Sa plus one, but it's not. Instead of length 0, this is just a simple control packet. And so there's the sequence number of which the bytes would start, but there are no bytes. So that's the basic connection setup, sin CAC AAA plus 1 p, p plus 1, and then an empty segment just for connection establishment. 
我承认现在这个初始数据包的序列号是sass加一，但它的长度往往是0。因此，如果数据包中有一个字节，它将是Sa加一，但它不是。这只是一个简单的控制包，而不是长度为0。因此，有字节开始的序列号，但没有字节。这就是基本连接设置，sin CAC AAA加1 p，p加1，然后是一个空段，用于建立连接。

发言人   04:25
So it turns out TCP also supports another way of opening a connection, something that's called simultaneous open, which as I said, is used a lot, as we'll see later in the course, in peer to peer applications to traverse things called network address translation boxes. 
因此，事实证明，TCP还支持另一种打开连接的方式，称为同时打开，正如我所说，这种方式经常使用，正如我们在课程稍后将看到的那样，在点对点应用程序中通过称为网络地址翻译框的东西。

发言人   04:39
And so the way simultaneous open works is this happens if both the active, if the two sides, we call them active and passive. But now they're really both active. Both know each other's port numbers. So the node on the left knows that the port, that the node on the right is issuing a connection request from the one on the is the same for the node on the left. And they're using the correct port. And they do this, they negotiate the say beforehand. 
因此，同时开放工作的方式是，如果双方都主动，我们称之为主动和被动。但是现在他们两个都很活跃。双方都知道对方的端口号。所以左边的节点知道端口，右边的节点发出的连接请求对于左边的节点来说是一样的。他们正在使用正确的端口。他们这样做，他们事先谈判发言权。

发言人   05:04
So what happens with simultaneous open is both sides send sins at the same time. And so here, the one on the left sends a sin. Let's call it just s sub a, again, s sub a, but at the same time, the northern right sends a sin s sub p, Well then on the left responds and it sends sin. 
因此，同时开放发生的事情是双方同时发送罪恶。所以在这里，左边的那个发出了罪恶。让我们只叫它sub a，再一次，sub a，但同时，北方右侧发送一个sin s sub p，然后在左侧响应并发送sin。

发言人   05:36
S sub P plus 1. Similarly, the neuron, the right responds with sin. S sub PA, s sub a plus 1. 
S sub P + 1。同样地，神经元以罪恶作为反应。S子PA，s子a加1。

发言人   05:50
At this point, we've now established the connection. Both sides have synchronized to know the starting sequence numbers. They've acknowledged that, but note that this takes four messages rather than three. So let's see this just a standard through a handshake in practice. So here I've opened up Wireshark filtering on port 80 and a certain IP address. And so I'm just going to telnet to port 80 on that host. And we'll see the C CAC A set up. So there it is. So here's the first packet sent from my host to the destination, and we see that it's an Http port 80 Sin sequence number 0, and there's no a, there's no AC bit. And so the acknow field is invalid, it's not displayed. 
在这一点上，我们现在已经建立了连接。两边都同步了以了解起始序列号。他们已经承认了这一点，但请注意，这需要四条消息，而不是三条。因此，让我们通过实践中的握手来看看这只是一个标准。所以在这里，我已经在80端口和某个IP地址上打开了Wireshark过滤。所以我只是要通过telnet连接到该主机上的80端口。我们会看到CC A设置。所以它就在那里。这是我的主机发送到目的地的第一个数据包，我们看到它是一个Http端口80，Sin序列号为0，没有a，没有交流位。因此，acnow字段无效，它不会显示。




发言人   06:30
Now, it turns out the sequence number in this packet isn't actually zero with tools like Wireshark do, just to make things easier to read is they use relative sequence numbers. They show you what the sequence number is relative to the beginning of the stream. And since we're just starting the scene, we see sequence number 0. 
现在，事实证明，使用像Wireshark这样的工具，这个数据包中的序列号实际上并不是零，只是为了使内容更容易阅读，他们使用了相对序列号。它们向您展示序列号相对于流开头的位置。由于我们刚刚开始这个场景，我们看到序列号为0。

发言人   06:46
We dig inside the packet. Down here at the bottom, you can see where a shark tells you sequence number zero, relative sequence number. And if we then look at the actual field, it's CCB D1 DBB, and so it's much larger than 0. 
我们深入挖掘这个包裹。在这里的底部，你可以看到鲨鱼告诉你序列号是0，相对序列号。如果我们再看看实际字段，它是CCB D1 DBB，因此它比0大得多。



发言人   07:00
Now, what we then see is for the second packet that's acknowledging this, it's going to acknowledge with CCB D1 Dbc here, again, it's using relative ACTC numbers, but that's what we see CC BC 1 D BC, it's also sending a sin. So here's the sin act, and so the sequence number, again, a relative sequence number of 0, but it's 3004, 1135 AE. 
现在，我们接下来看到的是第二个数据包承认这一点，它将在这里使用CCB D1 Dbc确认，再次，它使用相对ACTC数字，但这就是我们CC BC 1 D BC看到的，它也发送了一个sin。所以这是罪恶行为，所以序列号，再次，相对序列号为0，但它是3004，1135 AE。


发言人   07:29
So this is from my host to the server. This is the server back, the synac, then my host responds with an act. And so you can see sequence number one acknowledging one, so it's acknowledging the sin that was sent from the server, and it gives us sequence number one, but it's a length of 0. And so it's saying, aha, you know, I this packet contains the stream starting at byte 1, but there's nothing in it, so there's actually no data yet. So there we see a simple three way handshake. So now let's look at a T speed connection when there is data, so we're going to see the sin, sin mac, and then some data communication. So I can do the same thing as before, except this time rather than telnet to port 80 where there's no data transfer. I'm just going to do a standard web request to port 80. 
这是从我的主机到服务器。这是服务器后端，是synac，然后我的主机用一个动作回应。因此，您可以看到序列号1确认1，因此它确认从服务器发送的sin，并为我们提供了序列号1，但它的长度为0。所以它的意思是，啊哈，你知道，这个包包含从字节1开始的流，但里面什么都没有，所以实际上还没有数据。因此，我们看到了一个简单的三次握手。现在让我们看一下有数据时的T速度连接，我们将看到sin，sin mac，然后是一些数据通信。所以我可以和以前做同样的事情，除了这次而不是telnet到没有数据传输的80端口。我只是要对端口80执行标准的web请求。



发言人   08:16
And so here we see a tspc connection, and so here we have the sin synac acts. Now the connection's been established, and then data transmission starts. 
所以在这里我们看到了一个tspc连接，所以在这里我们有了sin synac动作。现在连接已经建立，然后数据传输开始。


发言人   08:28
And so here's a packet showing it's TTP. And if we look inside this particular T 3 segment, see sequence number one, so it's the start of the data stream, length 474. So this particular chunk of data was 474 B long. So the next sequence number would be 475, still a one. And so there's the data that we're sending as the request to the web server, Then the web server responds and responds with a 475, So the next byte you would expect is 475. But sequence number one, this is just link 0, this Ack, it has no data in it. This is what we call sort of off just an a packet, right? And so it has no TCP segment data, but is acknowledging the data that it's received the next packet though from the server actually has data in it. 
这里有一个数据包，显示它是TTP。如果我们查看这个特定的t3段，请参阅序列号1，它是数据流的开始，长度为474。所以这个特定的数据块有474 B长。所以下一个序列号将是475，仍然是一个。因此，我们将数据作为请求发送给web服务器，然后web服务器响应并响应475，因此下一个字节应该是475。但是序列号一，这只是链路0，这个Ack里面没有数据。这就是我们所说的，只是一个小包，对吧？因此它没有TCP段数据，但承认它接收到的下一个数据包中的数据，尽管从服务器实际上有数据。


发言人   09:21
So you can see here, length 1448, but sequence number one, so it's one to 1, 4, 4, 9. And here's the next TCP segment. And then we see here, putting that together, there's the Http response, which it's put together. And so there we see the connection to establishment. And now the sequence and acknowledgement number of spaces are walking forward according to the data communication. 
所以你可以在这里看到，长度为1448，但序列号为1，所以它是1到1，4，4，9。这是下一个TCP段。然后我们在这里看到，将它们放在一起，就是Http响应，它被放在一起。因此，我们看到了与建立的联系。现在，空间的序列和确认数量根据数据通信向前推进。

发言人   09:45
So next, we're going to look at how TCP tears down a connection, like a connection setup that uses the sequence number acknowledgement number fields. But unlike connection setup, which uses the synchronization bit to synchronize sequence numbers, connection teardown, use the fin bit to denote that there's no more data sense. It uses the A and fin bits. And so when TCP sends a packet with the fin bit, what this means is that that sender has no more data to send. 
接下来，我们将看看TCP如何断开连接，例如使用序列号确认编号字段的连接设置。但与连接设置不同，连接设置使用同步位同步序列号，连接拆解使用fin位表示不再有数据感知。它使用A和fin位。当TCP发送一个带有fin位的包时，这意味着发送方没有更多的数据可以发送。


发言人   10:10
This is the end of the stream. This is caused when you say call close or shutdown in the application. But TCB connections, like most reliable connections, are bidirectional. And so it's not until both sides have nothing to send that you actually terminate the connection because it is going to be one side is done, but the other side has more to send. And so it's not until both sides have have thinned and you've acknowledged those that you can tear things down. 
这是小溪的终点。当您在应用程序中说关闭或关闭时，会导致这种情况。但是TCB连接像大多数可靠连接一样，是双向的。所以直到双方都没有任何东西可以发送，你才真正终止连接，因为它将是一侧完成，但另一侧有更多的东西要发送。因此，直到双方都变得稀薄，并且你已经承认了那些你可以撕毁的东西。


发言人   10:35
So typical Teardown Exchange looks like this, where we say if A and B who are communicating and A closes first. And so it sends a packet with the fin bit with sequence number s sub a and acknowledging s sub BB, then sends a packet to acknowledge this fin. So xs s sub a plus 1. Then at some point later b decides it needs to close its the connection. So it sends a fin sequence number s sub b, ack, and s sub 1, and still acknowledging sa plus 1, which then a responds saying, I'll acknowledge SB plus one. So Finn, like Fi, represents of the last byte of the connection the way that you like sin represents the first byte. The way you acknowledge this by acknowledging plus one with Finn, you acknowledge you receive it by acknowledging plus one. Of course you can have also have simultaneous close where they send the fins in parallel and the same exchange occurs. 
所以典型的拆解交换看起来像这样，我们说如果A和B正在通信并且A先关闭。因此，它发送一个带有序列号sub a和确认sub BB的fin位的数据包，然后发送一个数据包来确认这个fin。所以xs sub a加1。然后在某个时候，b决定需要关闭它的连接。所以它发送一个fin序列号sub b，ack和sub 1，并且仍然确认sa加1，然后a响应说，我会确认SB加一。因此，像Fi一样，Finn代表连接的最后一个字节，就像sin代表第一个字节一样。你通过与Finn确认加一来确认这一点的方式，你通过确认加一来确认你收到了它。当然，您也可以同时关闭，它们并行发送鳍，并且发生相同的交换。

发言人   11:30
Great, so now we've exchanged these messages and we've acknowledged them. 
太好了，现在我们已经交换了这些信息并向它们表示了感谢。

发言人   11:34
When can we actually tear down the connection? When can we actually delete the state? When cool, you reuse the ports, it turns out to be non trivial, you can't do it immediately. So for example, what happens if this final act is lost in the network? So how I've sent Fin, then I receive a fin and IA it. I can't immediately tear down my connection because what happens if that act is lost? The other side's never going to hear it. It's never going to know whether the connection was torn down. 
我们什么时候才能真正拆掉连接？什么时候我们才能真正删除这个国家？冷却后，您重复使用端口，结果证明它不是简单的，您不能立即执行。例如，如果最后一幕在网络中丢失，会发生什么？那么我如何发送鳍，然后我收到一个鳍并对其进行了操作。我不能立即撕毁我的联系，因为如果失去了这种行为会发生什么？另一方永远不会听到它。它永远不会知道连接是否被断开。


发言人   12:03
Another issue is it could be that we do a thin Fna and acknowledge and tear down and then the same port pair. The same port pair is used immediately for a new connection. We want to make sure that we don't by accident then corrupt the data because the sequence number spaces overlap. So the solution that's used is the active closer, it goes into something called time weight. And what this means is that if I'm the person who sends the fin first, then once the connection is torn down, I have to wait a little while before I can reuse my state. And so you keep the socket around for two, what's sort of maximum segment lifetimes, or two times, or what you'd expect to be the longest time segments might live in the network on, which is on the order of, say, a minute or so. So this approach of 2 maximum segment lifetimes can pose problems with servers. In particular, if I have a server and it says tons and tons of sockets which are in this time weight state, this can slow things down. 
另一个问题可能是我们进行了精简的Fna、确认和拆除，然后使用相同的端口对。同一端口对立即用于新连接。我们希望确保我们不会因为序列号空间重叠而意外损坏数据。所以使用的解决方案是主动接近的，它进入称为时间权重的东西。这意味着，如果我是第一个发送鳍的人，那么一旦连接断开，我必须等待一段时间才能重新使用我的状态。所以你将套接字保留两次，最大段寿命是多少，或者两次，或者你期望的最长段可能在网络中存在的时间，大约是一分钟左右。因此，这种最大2个段寿命的方法可能会给服务器带来问题。特别是，如果我有一台服务器，它显示了处于这个时间重量状态的大量套接字，这可能会减慢速度。

发言人   13:00
It was the for closing first. So there are tricks you can send a reset to delete the socket. You can set an option to make the linger time to be 0. Another issue is the us might not let you reuse a port because it's still in use. There is an option you can do called Soo Reuse Outer that'll let you to rebind a port number. This is useful, say you're just debugging something and gosh, I don't want to wait two hours just because I happen to have and in this in this order. 
这是为了先结束。所以有一些技巧可以发送重置来删除套接字。您可以设置一个选项以使停留时间为0。另一个问题是美国可能不允许您重复使用某个端口，因为它仍在使用中。有一个叫做Soo Reuse Outer的选项可以让你重新绑定端口号。这很有用，假设你只是在调试什么东西，天哪，我不想等两个小时，因为我碰巧有这样的顺序。

发言人   13:26
So let's see what a connection teardown looks like. So here's a basic connection setup in CAC A, and then here's the teardown. So because we are exchanging data, we have the acknow bit set, so here's the fin, here's the initial fin from my host when I close the connection. And so it sets the fin bit, act 1, sequence number one, act 1, then the server in response is also closing, so it sends a fin sequence number one, act 2, so it's acknowledging my fin, and then my host responds with an act for that fins sequence number two, act 2. So here's a simple three way handshake for tearing down the connection fin, acknowledging some prior data, acknowledging the fin, sending your own fin, and then acknowledging the fin. So if we put all of this together, we can see what the full TCP finite state machine looks like. And so this is something you're going to come across many, many times. 
那么让我们看看连接拆解是什么样子的。这里是CAC a中的基本连接设置，然后是拆解。因为我们正在交换数据，所以我们设置了acnose位，所以这是fin，这是我关闭连接时主机的初始fin。因此它设置了fin位，动作1，序列号1，动作1，然后响应的服务器也正在关闭，因此它发送了一个fin序列号1，第二幕，所以它正在确认我的fin，然后我的宿主响应于该fin序列号2的动作，第二幕。所以这里有一个简单的三次握手，用于拆除连接鳍，确认一些先前的数据，确认鳍，发送自己的鳍，然后确认鳍。所以如果我们把所有这些放在一起，我们可以看到完整的TCP有限状态机是什么样子。所以这是你会遇到很多次的事情。




发言人   14:23
This is well-established inite state machine that really sort of lays the groundwork for how you want to set up reliable connections. And so I'm going to walk through it. It looks pretty complicated and you foresee, but it's because there are a couple of cases. And actually, given we've presented before, it should all be pretty simple. 
这是一个完善的状态机器，它为您如何建立可靠的连接奠定了基础。所以我要走过去。看起来相当复杂，你可以预见到，但这是因为有几个案例。实际上，鉴于我们之前已经介绍过，这一切应该都很简单。

发言人   14:39
So first, we're starting in the closed state, so this is when there are no connections open, you know I'm just sitting there, my applications not trying to open a connection. So then the first transition here to the listen state, this is the passive openers, this is a server, server is listening for connection, so you can see the Is listen and there's no packets exchanged. If you close it, you then return to the closed state. So this, if I'm listening to our connections, I hear nothing or turn to the closed state. 
所以首先，我们在关闭状态下开始，所以这是在没有打开连接的时候，你知道我只是坐在那里，我的应用程序没有尝试打开连接。那么这里第一次转换到监听状态，这是被动的开启器，这是一个服务器，服务器正在监听连接，所以你可以看到正在监听，并且没有交换数据包。如果您关闭它，则返回到关闭状态。所以，如果我在监听我们的连接，我会什么也听不到或者进入关闭状态。

发言人   15:10
The other transition out of the closed state is the active open. So here's the connect. And connect causes a sin packet to be set. This is step one of the three way handshake. So you send a sin and you're now in a state state, this is the active side. 
关闭状态的另一个转换是活动打开。这就是连接。并且连接会导致设置sin包。这是三次握手的第一步。所以你发送了罪恶，现在你处于一种状态，这是主动的一面。

发言人   15:26
Red lines are showing the active opener of the three way connection. So sin sent. Then if you receive a sin and A, this is the stage 2, you send an act and now the connection is established. So this path here, this is the active opener. Now let's watch the passive opener. So the passive opens in the listen state and it receives a sin from an active opener. In response, it sends a sin, A enters the sin receives state. Then if it receives an acknowledging for its sin, this is stage 3 of the three way handshake. It's the reflection of this step here, then the connection has been established. 
红线显示了三向连接的主动开启器。所以罪发送。然后，如果你收到了一个罪恶和一个，这是第二阶段，你发送了一个行为，现在建立了连接。所以这条路径在这里，这是活跃的开场白。现在让我们看看被动的开场。因此被动在listen状态下打开，并从主动开启者接收sin。作为回应，它发送一个罪恶，进入罪恶接收状态。那么，如果它收到了对其罪的承认，这是三次握手的第三阶段。这是这一步的反映，那么连接已经建立。

发言人   16:05
Now if you're in the listen state, it's possible that you can also call send, which would then result in sending a send message. Or you can also, in that way, you're then gon na, even though you're in the listen state, you can actively open and active in an open state. 
现在如果你处于监听状态，你也可以调用send，这将导致发送一条发送消息。或者你也可以这样做，即使你处于监听状态，你也可以积极地打开并处于开放状态。

发言人   16:21
So now there's one more path here, which I mentioned the four way simultaneous open, which is this. And so this is when both sides have sent sin. So we're just looking at one side of the connection. And in response to a sin you get is sin from the other side. And so this is the two sins crossing. So in response, you sin, sin plus act, sin received, then you act. And so there's the four messages. Each is sent to sin. Each is received a sin and then received a sin. They send a CAC and there's an act, and data chain exchange can occur. And so now we're in the established state. 
所以现在这里还有一条路径，我提到了四种方式同时开放，就是这样。所以这就是双方都犯了罪的时候。所以我们只是看连接的一面。作为对罪的回应，你得到的是另一边的罪。所以这就是两个罪恶的交叉。所以作为回应，你犯了罪，加上行为，收到了罪，然后你采取行动。所以有四个信息。每个人都被派去犯罪。每个人都被接受了罪，然后又被接受了罪。他们发送了一个CAC，然后就有了动作，数据链交换就会发生。所以现在我们处于既定状态。

发言人   17:01
Now, of course, you can always transition. Now we like to closes and resets, but so now at this point, we've gone through connection establishment. 
现在，当然，你可以随时过渡。现在我们喜欢关闭和重置，但现在我们已经建立了连接。

发言人   17:17
Now we're going to go into connection teardown. 
现在我们要进行连接拆解。

发言人   17:25
And so there are two cases here. One is that if we're the active closer here, we call close, that results in a fin message being sent, a fin pack with a fin bit. We now enter a fin weight 1. The other is if we receive AF, then we acknowledge it and we're now in the passive close state where the other side is closed, and then call. 
所以这里有两个案例。一个是如果我们在这里更接近活跃，我们称之为close，这导致发送一条鳍信息，一个带有鳍位的鳍包。我们现在输入一个鳍的重量为1。另一种情况是，如果我们接收到AF，然后我们承认它，我们现在处于被动关闭状态，即另一侧关闭，然后呼叫。

发言人   17:45
When we actually call close, we'll send Fin, send the last act and be closed. And so here closed weight is we are still allowed to send data, right? Until we call closed. This is the other side is closed, but we haven't. So now when close is called, we're in the F1 state, and there are a bunch of transitions out of that. One is that we receive a fin. So we've sent a fin, receive a fins. 
当我们实际呼叫close时，我们将发送finand，发送最后一幕并被关闭。所以在这里，我们仍然可以发送数据，对吧？直到我们称之为关闭。这是另一边是封闭的，但我们还没有。所以现在调用close时，我们处于F1状态，并且有一些转换。一个是我们收到了一个鳍。所以我们发送了一个鳍，接收了一个鳍。

发言人   18:06
This is the example I showed with the TCP teardown. So we've sent a fin, we receive a fin, we acknowledge that we're now in the closing state, we then transition to time weight, Another is that we receive a thin plus an act, so we can just acknowledge that and enter time weight. The final one is that we receive an act, but no fin. So this is we have closed our side of the connection, the other side hasn't, and so it's sort of the this state here is correlated with this state here, then when we do receive the fin, we acknowledge it, enter the time weight state, and then we have the time up before we can actually close and recover the state. So you can ask, what's the difference between this transition to closing and time weight? The reason is that this transition to closing is when the two fins past each other, so I send a fin, the other side fin sends me a fin, hasn't acknowledged my fin. This is the difference between Finn slash A and fin plus A slash A, and so then I wait for that fin to be acknowledged and then transition to time weight. 
这是我展示的使用TCP拆解的示例。所以我们发送了一个鳍，我们收到了一个鳍，我们承认我们现在处于关闭状态，然后我们过渡到时间重量，另一个是我们收到了一个薄加上一个动作，所以我们可以承认并输入时间重量。最后一个是我们收到了一个动作，但没有鳍。所以这是我们已经关闭了我们这一侧的连接，另一侧没有，所以这里的这个状态与这里的这个状态相关，然后当我们收到鳍时，我们承认它，进入时间权重状态。然后我们在实际关闭并恢复状态之前还有时间。所以你可以问，这个过渡到关闭和时间权重之间有什么区别？原因是这种向关闭的过渡是当两个鳍相互经过时，所以我发送一个鳍，另一侧的鳍发送给我一个鳍，没有确认我的鳍。这是Finn斜杠A和fin加上斜杠A之间的区别，因此我等待该鳍被确认，然后转换为时间权重。


发言人   19:08
This is the full TCP finite state machine, it looks really complicated, I mean, it does have 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 states. But when you realize it breaks into these two parts, connection, establishment, connection, teardown, and really there's just a bunch of different possible ways the fins can be exchanged. It's actually not that complicated, and so I encourage you to open up Wireshark and just open up a couple of web connections, just see what what's happening with your TCP connections, and you'll be able to see how those different connections are traversing this finite state machine. 
这是一个完整的TCP有限状态机，看起来非常复杂，我的意思是，它确实有1、2、3、4、5、6、7、8、9、10、11, 12个状态。但是当你意识到它分裂为这两个部分，连接，建立，连接，拆除，并且实际上只有一堆不同的可能方式可以交换鳍。它实际上并不那么复杂，所以我鼓励你打开Wireshark，只打开几个网络连接，看看你的TCP连接发生了什么，你将能够看到这些不同的连接如何遍历这个有限状态机。